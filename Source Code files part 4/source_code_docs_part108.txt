   disabled(1),
                          blocking(2),
                          listening(3),
                          learning(4),
                          forwarding(5),
                          broken(6)
                      }
              ACCESS  read-only
              STATUS  mandatory
              DESCRIPTION
                      "The port's current state as defined by
                      application of the Spanning Tree Protocol.  This
                      state controls what action a port takes on
                      reception of a frame.  If the bridge has detected
                      a port that is malfunctioning it will place that
                      port into the broken(6) state.  For ports which
                      are disabled (see dot1dStpPortEnable), this object
                      will have a value of disabled(1)."
              REFERENCE
                      "IEEE 802.1D-1990: Section 4.5.5.2"
              ::= { dot1dStpPortEntry 3 }






          dot1dStpPortEnable OBJECT-TYPE
              SYNTAX  INTEGER {
                          enabled(1),
                          disabled(2)
                      }
              ACCESS  read-write
              STATUS  mandatory
              DESCRIPTION
                      "The enabled/disabled status of the port."
              REFERENCE
                      "IEEE 802.1D-1990: Section 4.5.5.2"
              ::= { dot1dStpPortEntry 4 }

          dot1dStpPortPathCost OBJECT-TYPE
              SYNTAX  INTEGER (1..65535)
              ACCESS  read-write
              STATUS  mandatory
              DESCRIPTION
                      "The contribution of this port to the path cost of
                      paths towards the spanning tree root which include
                      this port.  802.1D-1990 recommends that the
                      default value of this parameter be in inverse
                      proportion to the speed of the attached LAN."
              REFERENCE
                      "IEEE 802.1D-1990: Section 4.5.5.3"
              ::= { dot1dStpPortEntry 5 }

          dot1dStpPortDesignatedRoot OBJECT-TYPE
              SYNTAX  BridgeId
              ACCESS  read-only
              STATUS  mandatory
              DESCRIPTION
                      "The unique Bridge Identifier of the Bridge
                      recorded as the Root in the Configuration BPDUs
                      transmitted by the Designated Bridge for the
                      segment to which the port is attached."
              REFERENCE
                      "IEEE 802.1D-1990: Section 4.5.5.4"
              ::= { dot1dStpPortEntry 6 }

          dot1dStpPortDesignatedCost OBJECT-TYPE
              SYNTAX  INTEGER
              ACCESS  read-only
              STATUS  mandatory
              DESCRIPTION
                      "The path cost of the Designated Port of the
                      segment connected to this port.  This value is
                      compared to the Root Path Cost field in received





                      bridge PDUs."
              REFERENCE
                      "IEEE 802.1D-1990: Section 4.5.5.5"
              ::= { dot1dStpPortEntry 7 }

          dot1dStpPortDesignatedBridge OBJECT-TYPE
              SYNTAX  BridgeId
              ACCESS  read-only
              STATUS  mandatory
              DESCRIPTION
                      "The Bridge Identifier of the bridge which this
                      port considers to be the Designated Bridge for
                      this port's segment."
              REFERENCE
                      "IEEE 802.1D-1990: Section 4.5.5.6"
              ::= { dot1dStpPortEntry 8 }

          dot1dStpPortDesignatedPort OBJECT-TYPE
              SYNTAX  OCTET STRING (SIZE (2))
              ACCESS  read-only
              STATUS  mandatory
              DESCRIPTION
                      "The Port Identifier of the port on the Designated
                      Bridge for this port's segment."
              REFERENCE
                      "IEEE 802.1D-1990: Section 4.5.5.7"
              ::= { dot1dStpPortEntry 9 }

          dot1dStpPortForwardTransitions OBJECT-TYPE
              SYNTAX  Counter
              ACCESS  read-only
              STATUS  mandatory
              DESCRIPTION
                      "The number of times this port has transitioned
                      from the Learning state to the Forwarding state."
              ::= { dot1dStpPortEntry 10 }


          -- the dot1dTp group

          -- Implementation of the dot1dTp group is optional.  It is
          -- implemented by those bridges that support the transparent
          -- bridging mode.  A transparent or SRT bridge will implement
          -- this group.


          dot1dTpLearnedEntryDiscards OBJECT-TYPE
              SYNTAX  Counter





              ACCESS  read-only
              STATUS  mandatory
              DESCRIPTION
                      "The total number of Forwarding Database entries,
                      which have been or would have been learnt, but
                      have been discarded due to a lack of space to
                      store them in the Forwarding Database.  If this
                      counter is increasing, it indicates that the
                      Forwarding Database is regularly becoming full (a
                      condition which has unpleasant performance effects
                      on the subnetwork).  If this counter has a
                      significant value but is not presently increasing,
                      it indicates that the problem has been occurring
                      but is not persistent."
              REFERENCE
                      "IEEE 802.1D-1990: Section 6.7.1.1.3"
              ::= { dot1dTp 1 }

          dot1dTpAgingTime OBJECT-TYPE
              SYNTAX   INTEGER (10..1000000)
              ACCESS   read-write
              STATUS   mandatory
              DESCRIPTION
                      "The timeout period in seconds for aging out
                      dynamically learned forwarding information.
                      802.1D-1990 recommends a default of 300 seconds."
              REFERENCE
                      "IEEE 802.1D-1990: Section 6.7.1.1.3"
              ::= { dot1dTp 2 }


          --  The Forwarding Database for Transparent Bridges

          dot1dTpFdbTable OBJECT-TYPE
              SYNTAX  SEQUENCE OF Dot1dTpFdbEntry
              ACCESS  not-accessible
              STATUS  mandatory
              DESCRIPTION
                      "A table that contains information about unicast
                      entries for which the bridge has forwarding and/or
                      filtering information.  This information is used
                      by the transparent bridging function in
                      determining how to propagate a received frame."
              ::= { dot1dTp 3 }

          dot1dTpFdbEntry OBJECT-TYPE
              SYNTAX  Dot1dTpFdbEntry
              ACCESS  not-accessible





              STATUS  mandatory
              DESCRIPTION
                      "Information about a specific unicast MAC address
                      for which the bridge has some forwarding and/or
                      filtering information."
              INDEX   { dot1dTpFdbAddress }
              ::= { dot1dTpFdbTable 1 }

          Dot1dTpFdbEntry ::=
              SEQUENCE {
                  dot1dTpFdbAddress
                      MacAddress,
                  dot1dTpFdbPort
                      INTEGER,
                  dot1dTpFdbStatus
                      INTEGER
              }

          dot1dTpFdbAddress OBJECT-TYPE
              SYNTAX  MacAddress
              ACCESS  read-only
              STATUS  mandatory
              DESCRIPTION
                      "A unicast MAC address for which the bridge has
                      forwarding and/or filtering information."
              REFERENCE
                      "IEEE 802.1D-1990: Section 3.9.1, 3.9.2"
              ::= { dot1dTpFdbEntry 1 }

          dot1dTpFdbPort OBJECT-TYPE
              SYNTAX  INTEGER
              ACCESS  read-only
              STATUS  mandatory
              DESCRIPTION
                      "Either the value '0', or the port number of the
                      port on which a frame having a source address
                      equal to the value of the corresponding instance
                      of dot1dTpFdbAddress has been seen.  A value of
                      '0' indicates that the port number has not been
                      learned but that the bridge does have some
                      forwarding/filtering information about this
                      address (e.g. in the dot1dStaticTable).
                      Implementors are encouraged to assign the port
                      value to this object whenever it is learned even
                      for addresses for which the corresponding value of
                      dot1dTpFdbStatus is not learned(3)."
              ::= { dot1dTpFdbEntry 2 }






          dot1dTpFdbStatus OBJECT-TYPE
              SYNTAX  INTEGER {
                          other(1),
                          invalid(2),
                          learned(3),
                          self(4),
                          mgmt(5)
                      }
              ACCESS  read-only
              STATUS  mandatory
              DESCRIPTION
                      "The status of this entry.  The meanings of the
                      values are:

                        other(1)   : none of the following.  This would
                                     include the case where some other
                                     MIB object (not the corresponding
                                     instance of dot1dTpFdbPort, nor an
                                     entry in the dot1dStaticTable) is
                                     being used to determine if and how
                                     frames addressed to the value of
                                     the corresponding instance of
                                     dot1dTpFdbAddress are being
                                     forwarded.

                        invalid(2) : this entry is not longer valid
                                     (e.g., it was learned but has since
                                     aged-out), but has not yet been
                                     flushed from the table.

                        learned(3) : the value of the corresponding
                                     instance of dot1dTpFdbPort was
                                     learned, and is being used.

                        self(4)    : the value of the corresponding
                                     instance of dot1dTpFdbAddress
                                     represents one of the bridge's
                                     addresses.  The corresponding
                                     instance of dot1dTpFdbPort
                                     indicates which of the bridge's
                                     ports has this address.

                        mgmt(5)    : the value of the corresponding
                                     instance of dot1dTpFdbAddress is
                                     also the value of an existing
                                     instance of dot1dStaticAddress."
              ::= { dot1dTpFdbEntry 3 }






          --  Port Table for Transparent Bridges

          dot1dTpPortTable OBJECT-TYPE
              SYNTAX  SEQUENCE OF Dot1dTpPortEntry
              ACCESS  not-accessible
              STATUS  mandatory
              DESCRIPTION
                      "A table that contains information about every
                      port that is associated with this transparent
                      bridge."
              ::= { dot1dTp 4 }

          dot1dTpPortEntry OBJECT-TYPE
              SYNTAX  Dot1dTpPortEntry
              ACCESS  not-accessible
              STATUS  mandatory
              DESCRIPTION
                      "A list of information for each port of a
                      transparent bridge."
              INDEX   { dot1dTpPort }
              ::= { dot1dTpPortTable 1 }

          Dot1dTpPortEntry ::=
              SEQUENCE {
                  dot1dTpPort
                      INTEGER,
                  dot1dTpPortMaxInfo
                      INTEGER,
                  dot1dTpPortInFrames
                      Counter,
                  dot1dTpPortOutFrames
                      Counter,
                  dot1dTpPortInDiscards
                      Counter
              }

          dot1dTpPort OBJECT-TYPE
              SYNTAX  INTEGER (1..65535)
              ACCESS  read-only
              STATUS  mandatory
              DESCRIPTION
                      "The port number of the port for which this entry
                      contains Transparent bridging management
                      information."
              ::= { dot1dTpPortEntry 1 }

          -- It would be nice if we could use ifMtu as the size of the
          -- largest INFO field, but we can't because ifMtu is defined





          -- to be the size that the (inter-)network layer can use which
          -- can differ from the MAC layer (especially if several layers
          -- of encapsulation are used).

          dot1dTpPortMaxInfo OBJECT-TYPE
              SYNTAX  INTEGER
              ACCESS  read-only
              STATUS  mandatory
              DESCRIPTION
                      "The maximum size of the INFO (non-MAC) field that
                      this port will receive or transmit."
              ::= { dot1dTpPortEntry 2 }

          dot1dTpPortInFrames OBJECT-TYPE
              SYNTAX  Counter
              ACCESS  read-only
              STATUS  mandatory
              DESCRIPTION
                      "The number of frames that have been received by
                      this port from its segment. Note that a frame
                      received on the interface corresponding to this
                      port is only counted by this object if and only if
                      it is for a protocol being processed by the local
                      bridging function, including bridge management
                      frames."
              REFERENCE
                      "IEEE 802.1D-1990: Section 6.6.1.1.3"
              ::= { dot1dTpPortEntry 3 }

          dot1dTpPortOutFrames OBJECT-TYPE
              SYNTAX  Counter
              ACCESS  read-only
              STATUS  mandatory
              DESCRIPTION
                      "The number of frames that have been transmitted
                      by this port to its segment.  Note that a frame
                      transmitted on the interface corresponding to this
                      port is only counted by this object if and only if
                      it is for a protocol being processed by the local
                      bridging function, including bridge management
                      frames."
              REFERENCE
                      "IEEE 802.1D-1990: Section 6.6.1.1.3"
              ::= { dot1dTpPortEntry 4 }

          dot1dTpPortInDiscards OBJECT-TYPE
              SYNTAX   Counter
              ACCESS   read-only





              STATUS   mandatory
              DESCRIPTION
                      "Count of valid frames received which were
                      discarded (i.e., filtered) by the Forwarding
                      Process."
              REFERENCE
                      "IEEE 802.1D-1990: Section 6.6.1.1.3"
              ::= { dot1dTpPortEntry 5 }


          -- The Static (Destination-Address Filtering) Database

          -- Implementation of this group is optional.


          dot1dStaticTable OBJECT-TYPE
              SYNTAX  SEQUENCE OF Dot1dStaticEntry
              ACCESS  not-accessible
              STATUS  mandatory
              DESCRIPTION
                      "A table containing filtering information
                      configured into the bridge by (local or network)
                      management specifying the set of ports to which
                      frames received from specific ports and containing
                      specific destination addresses are allowed to be
                      forwarded.  The value of zero in this table as the
                      port number from which frames with a specific
                      destination address are received, is used to
                      specify all ports for which there is no specific
                      entry in this table for that particular
                      destination address.  Entries are valid for
                      unicast and for group/broadcast addresses."
              REFERENCE
                      "IEEE 802.1D-1990: Section 6.7.2"
              ::= { dot1dStatic 1 }

          dot1dStaticEntry OBJECT-TYPE
              SYNTAX  Dot1dStaticEntry
              ACCESS  not-accessible
              STATUS  mandatory
              DESCRIPTION
                      "Filtering information configured into the bridge
                      by (local or network) management specifying the
                      set of ports to which frames received from a
                      specific port and containing a specific
                      destination address are allowed to be forwarded."
              REFERENCE
                      "IEEE 802.1D-1990: Section 6.7.2"





              INDEX   { dot1dStaticAddress, dot1dStaticReceivePort }
              ::= { dot1dStaticTable 1 }

          Dot1dStaticEntry ::=
              SEQUENCE {
                  dot1dStaticAddress
                      MacAddress,
                  dot1dStaticReceivePort
                      INTEGER,
                  dot1dStaticAllowedToGoTo
                      OCTET STRING,
                  dot1dStaticStatus
                      INTEGER
              }

          dot1dStaticAddress OBJECT-TYPE
              SYNTAX  MacAddress
              ACCESS  read-write
              STATUS  mandatory
              DESCRIPTION
                      "The destination MAC address in a frame to which
                      this entry's filtering information applies.  This
                      object can take the value of a unicast address, a
                      group address or the broadcast address."
              REFERENCE
                      "IEEE 802.1D-1990: Section 3.9.1, 3.9.2"
              ::= { dot1dStaticEntry 1 }

          dot1dStaticReceivePort OBJECT-TYPE
              SYNTAX  INTEGER
              ACCESS  read-write
              STATUS  mandatory
              DESCRIPTION
                      "Either the value '0', or the port number of the
                      port from which a frame must be received in order
                      for this entry's filtering information to apply.
                      A value of zero indicates that this entry applies
                      on all ports of the bridge for which there is no
                      other applicable entry."
              ::= { dot1dStaticEntry 2 }

          dot1dStaticAllowedToGoTo OBJECT-TYPE
              SYNTAX  OCTET STRING
              ACCESS  read-write
              STATUS  mandatory
              DESCRIPTION
                      "The set of ports to which frames received from a
                      specific port and destined for a specific MAC





                      address, are allowed to be forwarded.  Each octet
                      within the value of this object specifies a set of
                      eight ports, with the first octet specifying ports
                      1 through 8, the second octet specifying ports 9
                      through 16, etc.  Within each octet, the most
                      significant bit represents the lowest numbered
                      port, and the least significant bit represents the
                      highest numbered port.  Thus, each port of the
                      bridge is represented by a single bit within the
                      value of this object.  If that bit has a value of
                      '1' then that port is included in the set of
                      ports; the port is not included if its bit has a
                      value of '0'.  (Note that the setting of the bit
                      corresponding to the port from which a frame is
                      received is irrelevant.)  The default value of
                      this object is a string of ones of appropriate
                      length."
              ::= { dot1dStaticEntry 3 }

          dot1dStaticStatus OBJECT-TYPE
              SYNTAX  INTEGER {
                          other(1),
                          invalid(2),
                          permanent(3),
                          deleteOnReset(4),
                          deleteOnTimeout(5)
                      }
              ACCESS  read-write
              STATUS  mandatory
              DESCRIPTION
                      "This object indicates the status of this entry.
                      The default value is permanent(3).

                           other(1) - this entry is currently in use but
                                the conditions under which it will
                                remain so are different from each of the
                                following values.
                           invalid(2) - writing this value to the object
                                removes the corresponding entry.
                           permanent(3) - this entry is currently in use
                                and will remain so after the next reset
                                of the bridge.
                           deleteOnReset(4) - this entry is currently in
                                use and will remain so until the next
                                reset of the bridge.
                           deleteOnTimeout(5) - this entry is currently
                                in use and will remain so until it is
                                aged out."





              ::= { dot1dStaticEntry 4 }


          -- Traps for use by Bridges

          -- Traps for the Spanning Tree Protocol

          newRoot TRAP-TYPE
              ENTERPRISE  dot1dBridge
              DESCRIPTION
                      "The newRoot trap indicates that the sending agent
                      has become the new root of the Spanning Tree; the
                      trap is sent by a bridge soon after its election
                      as the new root, e.g., upon expiration of the
                      Topology Change Timer immediately subsequent to
                      its election.  Implementation of this trap is
                      optional."
              ::= 1

          topologyChange TRAP-TYPE
              ENTERPRISE  dot1dBridge
              DESCRIPTION
                      "A topologyChange trap is sent by a bridge when
                      any of its configured ports transitions from the
                      Learning state to the Forwarding state, or from
                      the Forwarding state to the Blocking state.  The
                      trap is not sent if a newRoot trap is sent for the
                      same transition.  Implementation of this trap is
                      optional."
              ::= 2

          END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\mibs\snmpv2\rfcs\rfc1724.txt ===
RIPv2-MIB DEFINITIONS ::= BEGIN

   IMPORTS
       MODULE-IDENTITY, OBJECT-TYPE, Counter32,
       TimeTicks, IpAddress                     FROM SNMPv2-SMI
       TEXTUAL-CONVENTION, RowStatus            FROM SNMPv2-TC
       MODULE-COMPLIANCE, OBJECT-GROUP          FROM SNMPv2-CONF
       mib-2                                    FROM RFC1213-MIB;

   --  This MIB module uses the extended OBJECT-TYPE macro as
   --  defined in [9].

   rip2  MODULE-IDENTITY
           LAST-UPDATED "9407272253Z"      -- Wed Jul 27 22:53:04 PDT 1994
           ORGANIZATION "IETF RIP-II Working Group"
           CONTACT-INFO
          "       Fred Baker
          Postal: Cisco Systems
                  519 Lado Drive
                  Santa Barbara, California 93111
          Tel:    +1 805 681 0115
          E-Mail: fbaker@cisco.com

          Postal: Gary Malkin
                  Xylogics, Inc.
                  53 Third Avenue
                  Burlington, MA  01803

          Phone:  (617) 272-8140
          EMail:  gmalkin@Xylogics.COM"
      DESCRIPTION
         "The MIB module to describe the RIP2 Version 2 Protocol"
     ::= { mib-2 23 }

 --  RIP-2 Management Information Base

 -- the RouteTag type represents the contents of the
 -- Route Domain field in the packet header or route entry.
 -- The use of the Route Domain is deprecated.

 RouteTag ::= TEXTUAL-CONVENTION
     STATUS      current
     DESCRIPTION
        "the RouteTag type represents the contents of the Route Domain
        field in the packet header or route entry"
    SYNTAX      OCTET STRING (SIZE (2))


--4.1 Global Counters

--      The RIP-2 Globals Group.
--      Implementation of this group is mandatory for systems
--      which implement RIP-2.

-- These counters are intended to facilitate debugging quickly
-- changing routes or failing neighbors

rip2Globals OBJECT IDENTIFIER ::= { rip2 1 }

    rip2GlobalRouteChanges OBJECT-TYPE
        SYNTAX   Counter32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The number of route changes made to the IP Route
           Database by RIP.  This does not include the refresh
           of a route's age."
       ::= { rip2Globals 1 }

    rip2GlobalQueries OBJECT-TYPE
        SYNTAX   Counter32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The number of responses sent to RIP queries
           from other systems."
       ::= { rip2Globals 2 }

--4.2 RIP Interface Tables

--  RIP Interfaces Groups
--  Implementation of these Groups is mandatory for systems
--  which implement RIP-2.

-- The RIP Interface Status Table.

    rip2IfStatTable OBJECT-TYPE
        SYNTAX   SEQUENCE OF Rip2IfStatEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "A list of subnets which require separate
           status monitoring in RIP."
       ::= { rip2 2 }

   rip2IfStatEntry OBJECT-TYPE
       SYNTAX   Rip2IfStatEntry
       MAX-ACCESS   not-accessible
       STATUS   current
       DESCRIPTION
          "A Single Routing Domain in a single Subnet."
      INDEX { rip2IfStatAddress }
      ::= { rip2IfStatTable 1 }

    Rip2IfStatEntry ::=
        SEQUENCE {
            rip2IfStatAddress
                IpAddress,
            rip2IfStatRcvBadPackets
                Counter32,
            rip2IfStatRcvBadRoutes
                Counter32,
            rip2IfStatSentUpdates
                Counter32,
            rip2IfStatStatus
                RowStatus
    }

    rip2IfStatAddress OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The IP Address of this system on the indicated
           subnet. For unnumbered interfaces, the value 0.0.0.N,
           where the least significant 24 bits (N) is the ifIndex
           for the IP Interface in network byte order."
       ::= { rip2IfStatEntry 1 }

    rip2IfStatRcvBadPackets OBJECT-TYPE
        SYNTAX   Counter32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The number of RIP response packets received by
           the RIP process which were subsequently discarded
           for any reason (e.g. a version 0 packet, or an
           unknown command type)."
       ::= { rip2IfStatEntry 2 }

    rip2IfStatRcvBadRoutes OBJECT-TYPE
        SYNTAX   Counter32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The number of routes, in valid RIP packets,
           which were ignored for any reason (e.g. unknown
           address family, or invalid metric)."
       ::= { rip2IfStatEntry 3 }

    rip2IfStatSentUpdates OBJECT-TYPE
        SYNTAX   Counter32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The number of triggered RIP updates actually
           sent on this interface.  This explicitly does
           NOT include full updates sent containing new
           information."
       ::= { rip2IfStatEntry 4 }

    rip2IfStatStatus OBJECT-TYPE
        SYNTAX   RowStatus
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "Writing invalid has the effect of deleting
           this interface."
       ::= { rip2IfStatEntry 5 }

-- The RIP Interface Configuration Table.

    rip2IfConfTable OBJECT-TYPE
        SYNTAX   SEQUENCE OF Rip2IfConfEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "A list of subnets which require separate
           configuration in RIP."
       ::= { rip2 3 }

   rip2IfConfEntry OBJECT-TYPE
       SYNTAX   Rip2IfConfEntry
       MAX-ACCESS   not-accessible
       STATUS   current
       DESCRIPTION
          "A Single Routing Domain in a single Subnet."
      INDEX { rip2IfConfAddress }
      ::= { rip2IfConfTable 1 }

    Rip2IfConfEntry ::=
        SEQUENCE {
            rip2IfConfAddress
                IpAddress,
            rip2IfConfDomain
                RouteTag,
            rip2IfConfAuthType
                INTEGER,
            rip2IfConfAuthKey
                OCTET STRING (SIZE(0..16)),
            rip2IfConfSend
                INTEGER,
            rip2IfConfReceive
                INTEGER,
            rip2IfConfDefaultMetric
                INTEGER,
            rip2IfConfStatus
                RowStatus,
            rip2IfConfSrcAddress
                IpAddress
    }

    rip2IfConfAddress OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The IP Address of this system on the indicated
           subnet.  For unnumbered interfaces, the value 0.0.0.N,
           where the least significant 24 bits (N) is the ifIndex
           for the IP Interface in network byte order."
       ::= { rip2IfConfEntry 1 }

    rip2IfConfDomain OBJECT-TYPE
        SYNTAX   RouteTag
        MAX-ACCESS   read-create
        STATUS   obsolete
        DESCRIPTION
           "Value inserted into the Routing Domain field
           of all RIP packets sent on this interface."
       DEFVAL { '0000'h }
       ::= { rip2IfConfEntry 2 }

    rip2IfConfAuthType OBJECT-TYPE
        SYNTAX   INTEGER {
                    noAuthentication (1),
                    simplePassword (2),
                    md5 (3)
                 }
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The type of Authentication used on this
           interface."
       DEFVAL { noAuthentication }
       ::= { rip2IfConfEntry 3 }

    rip2IfConfAuthKey OBJECT-TYPE
        SYNTAX   OCTET STRING (SIZE(0..16))
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The value to be used as the Authentication Key
           whenever the corresponding instance of
           rip2IfConfAuthType has a value other than
           noAuthentication.  A modification of the corresponding
           instance of rip2IfConfAuthType does not modify
           the rip2IfConfAuthKey value.  If a string shorter
           than 16 octets is supplied, it will be left-
           justified and padded to 16 octets, on the right,
           with nulls (0x00).

           Reading this object always results in an  OCTET
           STRING of length zero; authentication may not
           be bypassed by reading the MIB object."
       DEFVAL { ''h }
       ::= { rip2IfConfEntry 4 }

    rip2IfConfSend OBJECT-TYPE
        SYNTAX   INTEGER {
                    doNotSend (1),
                    ripVersion1 (2),
                    rip1Compatible (3),
                    ripVersion2 (4),
                    ripV1Demand (5),
                    ripV2Demand (6)
                 }
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "What the router sends on this interface.
           ripVersion1 implies sending RIP updates compliant
           with  RFC  1058.   rip1Compatible implies
           broadcasting RIP-2 updates using RFC 1058 route
           subsumption rules.  ripVersion2 implies
           multicasting RIP-2 updates.  ripV1Demand indicates
           the use of Demand RIP on a WAN interface under RIP
           Version 1 rules.  ripV2Demand indicates the use of
           Demand RIP on a WAN interface under Version 2 rules."
       DEFVAL { rip1Compatible }
       ::= { rip2IfConfEntry 5 }

    rip2IfConfReceive OBJECT-TYPE
        SYNTAX   INTEGER {
                    rip1 (1),
                    rip2 (2),
                    rip1OrRip2 (3),
                    doNotRecieve (4)
                 }
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "This indicates which version of RIP updates
           are to be accepted.  Note that rip2 and
           rip1OrRip2 implies reception of multicast
           packets."
       DEFVAL { rip1OrRip2 }
       ::= { rip2IfConfEntry 6 }

    rip2IfConfDefaultMetric OBJECT-TYPE
        SYNTAX   INTEGER ( 0..15 )
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "This variable indicates the metric that is to
           be used for the default route entry in RIP updates
           originated on this interface.  A value of zero
           indicates that no default route should be
           originated; in this case, a default route via
           another router may be propagated."
       ::= { rip2IfConfEntry 7 }

    rip2IfConfStatus OBJECT-TYPE
        SYNTAX   RowStatus
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "Writing invalid has  the  effect  of  deleting
           this interface."
       ::= { rip2IfConfEntry 8 }

    rip2IfConfSrcAddress OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The IP Address this system will use as a source
            address on this interface.  If it is a numbered
            interface, this MUST be the same value as
            rip2IfConfAddress.  On unnumbered interfaces,
            it must be the value of rip2IfConfAddress for
            some interface on the system."
       ::= { rip2IfConfEntry 9 }

--4.3 Peer Table

--  Peer Table

--      The RIP Peer Group
--      Implementation of this Group is Optional

--      This group provides information about active peer
--      relationships intended to assist in debugging.  An
--      active peer is a router from which a valid RIP
--      updated has been heard in the last 180 seconds.

    rip2PeerTable OBJECT-TYPE
        SYNTAX   SEQUENCE OF Rip2PeerEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "A list of RIP Peers."
       ::= { rip2 4 }

   rip2PeerEntry OBJECT-TYPE
       SYNTAX   Rip2PeerEntry
       MAX-ACCESS   not-accessible
       STATUS   current
       DESCRIPTION
          "Information regarding a single routing peer."
      INDEX { rip2PeerAddress, rip2PeerDomain }
      ::= { rip2PeerTable 1 }

    Rip2PeerEntry ::=
        SEQUENCE {
            rip2PeerAddress
                IpAddress,
            rip2PeerDomain
                RouteTag,
            rip2PeerLastUpdate
                TimeTicks,
            rip2PeerVersion
                INTEGER,
            rip2PeerRcvBadPackets
                Counter32,
            rip2PeerRcvBadRoutes
                Counter32
            }

    rip2PeerAddress OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The IP Address that the peer is using as its source
            address.  Note that on an unnumbered link, this may
            not be a member of any subnet on the system."
       ::= { rip2PeerEntry 1 }

    rip2PeerDomain OBJECT-TYPE
        SYNTAX   RouteTag
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The value in the Routing Domain field  in  RIP
           packets received from the peer.  As domain suuport
           is deprecated, this must be zero."
       ::= { rip2PeerEntry 2 }

    rip2PeerLastUpdate OBJECT-TYPE
        SYNTAX   TimeTicks
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The value of sysUpTime when the most recent
           RIP update was received from this system."
       ::= { rip2PeerEntry 3 }

    rip2PeerVersion OBJECT-TYPE
        SYNTAX   INTEGER ( 0..255 )
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The RIP version number in the header of the
           last RIP packet received."
       ::= { rip2PeerEntry 4 }

    rip2PeerRcvBadPackets OBJECT-TYPE
        SYNTAX   Counter32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The number of RIP response packets from this
           peer discarded as invalid."
       ::= { rip2PeerEntry 5 }


    rip2PeerRcvBadRoutes OBJECT-TYPE
        SYNTAX   Counter32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The number of routes from this peer that were
           ignored because the entry format was invalid."
       ::= { rip2PeerEntry 6 }


-- conformance information

rip2Conformance OBJECT IDENTIFIER ::= { rip2 5 }
rip2Groups      OBJECT IDENTIFIER ::= { rip2Conformance 1 }
rip2Compliances OBJECT IDENTIFIER ::= { rip2Conformance 2 }

-- compliance statements
rip2Compliance MODULE-COMPLIANCE
    STATUS  current
    DESCRIPTION
       "The compliance statement "
    MODULE  -- this module
    MANDATORY-GROUPS {
                 rip2GlobalGroup,
                 rip2IfStatGroup,
                 rip2IfConfGroup,
                 rip2PeerGroup
        }
    GROUP       rip2GlobalGroup
    DESCRIPTION
       "This group defines global controls for RIP-II systems."
    GROUP       rip2IfStatGroup
    DESCRIPTION
       "This group defines interface statistics for RIP-II systems."
    GROUP       rip2IfConfGroup
    DESCRIPTION
       "This group defines interface configuration for RIP-II systems."
    GROUP       rip2PeerGroup
    DESCRIPTION
       "This group defines peer information for RIP-II systems."
    ::= { rip2Compliances 1 }

-- units of conformance

rip2GlobalGroup    OBJECT-GROUP
    OBJECTS {
                rip2GlobalRouteChanges,
                rip2GlobalQueries
    }
    STATUS  current
    DESCRIPTION
       "This group defines global controls for RIP-II systems."
    ::= { rip2Groups 1 }

rip2IfStatGroup    OBJECT-GROUP
    OBJECTS {
            rip2IfStatAddress,
            rip2IfStatRcvBadPackets,
            rip2IfStatRcvBadRoutes,
            rip2IfStatSentUpdates,
            rip2IfStatStatus
    }
    STATUS  current
    DESCRIPTION
       "This group defines interface statistics for RIP-II systems."
    ::= { rip2Groups 2 }

rip2IfConfGroup    OBJECT-GROUP
    OBJECTS {
            rip2IfConfAddress,
            rip2IfConfAuthType,
            rip2IfConfAuthKey,
            rip2IfConfSend,
            rip2IfConfReceive,
            rip2IfConfDefaultMetric,
            rip2IfConfStatus,
            rip2IfConfSrcAddress
    }
    STATUS  current
    DESCRIPTION
       "This group defines interface configuration for RIP-II systems."
    ::= { rip2Groups 3 }

rip2PeerGroup    OBJECT-GROUP
    OBJECTS {
            rip2PeerAddress,
            rip2PeerDomain,
            rip2PeerLastUpdate,
            rip2PeerVersion,
            rip2PeerRcvBadPackets,
            rip2PeerRcvBadRoutes
    }
    STATUS  current
    DESCRIPTION
       "This group defines peer information for RIP-II systems."
    ::= { rip2Groups 4 }
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\mibs\snmpv2\rfcs\rfc1759.txt ===
Printer-MIB DEFINITIONS ::= BEGIN

IMPORTS
    MODULE-IDENTITY, OBJECT-TYPE, experimental, Counter32, Integer32,
        TimeTicks, NOTIFICATION-TYPE, OBJECT-IDENTITY FROM SNMPv2-SMI
    TEXTUAL-CONVENTION FROM SNMPv2-TC
    MODULE-COMPLIANCE, OBJECT-GROUP FROM SNMPv2-CONF
    hrDeviceIndex, hrStorageIndex FROM HOST-RESOURCES-MIB;

printmib MODULE-IDENTITY
    LAST-UPDATED "9411250000Z"
    ORGANIZATION "IETF Printer MIB Working Group"
    CONTACT-INFO
            "        Steven Waldbusser
         Postal: Carnegie Mellon University
                     4910 Forbes Ave
                  Pittsburgh, PA, 15213

                Tel: 412-268-6628
                Fax: 412-268-4987
             E-mail: waldbusser@cmu.edu"
    DESCRIPTION
            "The MIB module for management of printers."
    ::= { mib-2 43 }

-- Textual conventions for this MIB module

MediaUnit ::= TEXTUAL-CONVENTION
    STATUS       current
    DESCRIPTION
            "Units of measure for media dimensions."
    -- This is a type 1 enumeration.
    SYNTAX       INTEGER {
                     tenThousandthsOfInches(3),  -- .0001
                     micrometers(4)
                 }

CapacityUnit ::= TEXTUAL-CONVENTION
    STATUS       current
    DESCRIPTION
            "Units of measure for media capacity."
    -- This is a type 1 enumeration.
    SYNTAX       INTEGER {
                     tenThousandthsOfInches(3),  -- .0001
                     micrometers(4),
                     sheets(8),
                     feet(16),
                     meters(17)
                 }

SubUnitStatus ::= TEXTUAL-CONVENTION
    STATUS       current
    DESCRIPTION
            "Status of a printer sub-unit.

             The SubUnitStatus is an integer that is the sum of 5
             distinct values, Availability, Non-Critical, Critical,
             On-line, and Transitioning. These values are:

     Availability                           value

            Available and Idle              0       000'b
            Available and Standby           2       010'b
            Available and Active            4       100'b
            Available and Busy              6       110'b
            Unavailable and OnRequest       1       001'b
            Unavailable because Broken      3       011'b
            Unknown                         5       101'b

    Non-Critical

            No Non-Critical Alerts          0
            Non-Critical Alerts             8

    Critical

            No Critical Alerts              0
            Critical Alerts                 16

    On-Line

            Intended state is On-Line       0
            Intended state is Off-Line      32

    Transitioning

            At intended state               0
            Transitioning to intended state 64
    "

    SYNTAX       INTEGER (0..126)

PresentOnOff ::= TEXTUAL-CONVENTION
    STATUS       current
    DESCRIPTION
            "Presence and configuration of a device or feature."
    -- This is a type 1 enumeration.
    SYNTAX       INTEGER {
                     other(1),
                     on(3),
                     off(4),
                     notPresent(5)
                 }

  CodedCharSet ::= TEXTUAL-CONVENTION
      STATUS     current
      DESCRIPTION
         "A coded character set value that specifies both a set of
          characters that may be used and an encoding (as one or more
          octets) that is used to represent the characters in the
          set. These values are to be used to identify the encoding
          employed for strings in the MIB where this is not fixed by
          the MIB.

          Some objects that allow a choice of coded character set
          are: the prtLocalizationCharacterSet object in the
          LocalizationTable and prtInterpreterDefaultCharSetIn.
          The prtGeneralCurrentLocalization and prtConsoleLocalization
          objects in turn contain the index in the LocalizationTable
          of the current localization (country, language, and coded
          character set) of the `description' objects and the console,
          respectively.

          The space of the coded character set enumeration has been
          divide into three regions. The first region (3-999) consists
          of coded character sets that have been standardized by some
          standard setting organization. This region is intended for
          standards that do not have subset implementations. The
          second region (1000-1999) is for the Unicode and ISO/IEC 10646
          coded character sets together with a specification of a (set
          of) sub-repetoires that may occur.  The third region (>1999)
          is intended for vendor specific coded character sets.

          NOTE: Unicode and ISO 10646 character coded data may be
          processed and stored in either Big Endian (most significant
          octet first) or Little Endian (least significant octet
          first) order.  Intel x86, VAX, and Alpha/AXP architectures are
          examples of Little Endian processor architectures.
          Furthermore, in environments where either order may occur,
          so-called Unicode BYTE ORDER MARK (BOM) character (which is
          ISO 10646 ZERO WIDTH NO BREAK SPACE), coded as FEFF in two
          octets and 0000FEFF in four octets is used at the beginning
          of the data as a signature to indicate the order of the
          following data (See ISO 10646 Annex F).  Thus either
          ordering and BOM may occur in print data streams sent to the
          interpreter.  However, ISO 8824/8825 (ASN.1/BER) used by
          SNMP is quite clear that Big Endian order shall be used and
          BOM shall NOT be used in transmission in the protocol.
          Transmitting Unicode in Big Endian order in SNMP should
          not prove to be a hardship for Little Endian machines,
          since SNMP ASN.1/BER requires integers to be transmitted
          in Big Endian order as well.  So SNMP implementations on
          Little Endian machines are already reversing the order of
          integers to make them Big Endian for transmission via
          SNMP.  Also Unicode characters are usually treated as
          two-octet integers, not short text strings, so that it will
          be straightforward for Little Endian machines to reverse the
          order of Unicode character octets as well before
          transmitting them and after receiving them via the SNMP
          protocol.

          Where a given coded character set may be known by more than
          one name, the most commonly known name is used as the name
          of the enumeration and other names are shown in the
          comments.  The comments also indicate where to find detailed
          information on the coded character set and briefly
          characterize its relationship to other similar coded
          character sets.

          The current list of character sets and their enumerated
          values used to reference them is contained in the IANA
          Character Set registry.  The enum value is indicated by
          the MIBenum entry in the registry.  The enum symbol is
          indicated by the Alias that starts with `cs' for character
          set.

          The IANA character sets registry is available via
          anonymous ftp.

          The ftp server is ftp.isi.edu.
          The subdirectory is /in-notes/iana/assignments/.

          The file name is character-sets.

          To add a character set to the IANA Registry:

             1. Format an entry like those in the current list,
                omitting the MIBenum value.
             2. Send the entry with a request to add the entry
                to the character set list to iana@ISI.EDU.
             3. The IANA will supply a unique MIBenum value
                and update the list."

      -- This is a type 3 enumeration.

      SYNTAX     INTEGER {
        other(1)               -- used if the designated coded
                               -- character set is not currently in
                               -- the enumeration

      -- See IANA Registry for standard character sets in the
      -- MIBenum range of 3-999.

      -- See IANA Registry for Unicode and vendor-supplied
      -- combinations of ISO collections and character sets based
      -- on Unicode in the MIBenum range of 1000-1999.
      -- See IANA Registry for vendor developed character sets
      -- in the MIBenum range of 2000-xxxx.
   }


-- The General Printer Group
--
-- The general printer sub-unit is responsible for the overall control
-- and status of the printer.  There is exactly one general printer
-- sub-unit in a printer.
--
-- Implementation of every object in this group is mandatory.

prtGeneral  OBJECT IDENTIFIER ::= { printmib 5 }

prtGeneralTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtGeneralEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A table of general information per printer.
        Objects in this table are defined in various
        places in the MIB, nearby the groups to
        which they apply.  They are all defined
        here to minimize the number of tables that would
        otherwise need to exist."
    ::= { prtGeneral 1 }

prtGeneralEntry OBJECT-TYPE
    SYNTAX      PrtGeneralEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "An entry exists in this table for each
        device entry in the hostmib device table who's type
        is `printer'"
    INDEX  { hrDeviceIndex }
    ::= { prtGeneralTable 1 }

PrtGeneralEntry ::= SEQUENCE {
    -- Note that not all of the objects in this sequence are in the
    -- general printer group.
    prtGeneralConfigChanges         Counter32,
    prtGeneralCurrentLocalization   Integer32,
    prtGeneralReset                 INTEGER,
    prtGeneralCurrentOperator       DisplayString,
    prtGeneralServicePerson         DisplayString,
    prtInputDefaultIndex            Integer32,
    prtOutputDefaultIndex           Integer32,
    prtMarkerDefaultIndex           Integer32,
    prtMediaPathDefaultIndex        Integer32,
    prtConsoleLocalization          Integer32,
    prtConsoleNumberOfDisplayLines  Integer32,
    prtConsoleNumberOfDisplayChars  Integer32,
    prtConsoleDisable               INTEGER
}

prtGeneralConfigChanges OBJECT-TYPE
    SYNTAX     Counter32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "Counts configuration changes that change the capabilities of
        a printer, such as the addition/deletion of input/output bins,
        the addition/deletion of interpreters, or changes in media
        size.  Such changes will often affect the capability of the
        printer to service certain types of print jobs.

        Management applications may cache infrequently changed
        configuration  information about sub-units on the printer.
        This object should be incremented whenever the agent wishes
        such applications to invalidate that cache and re-download

        all of this configuration information, thereby signalling a
        change in the printer's configuration.

        For example, if an input tray that contained paper of
        different dimensions was added, this counter would be
        incremented.

        As an additional example, this counter would not be
        incremented when an input tray is removed or the level of an
        input device changes."
    ::= { prtGeneralEntry 1 }

prtGeneralCurrentLocalization OBJECT-TYPE
    SYNTAX     Integer32 (1..65535)
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The value of the prtLocalizationIndex corresponding to the
        current language, country, and character set to be used for
        localized string values that are identified as being dependent
        on the value of this object.  Note that this object does not
        apply to localized strings in the prtConsole group or any
        object that is not identified as above."
    ::= { prtGeneralEntry 2 }

prtGeneralReset OBJECT-TYPE
    -- This value is a type 3 enumeration
    SYNTAX     INTEGER {
                   notResetting(3),
                   powerCycleReset(4), -- Cold Start
                   resetToNVRAM(5), -- Warm Start
                   resetToFactoryDefaults(6) -- Reset contents of
                                             -- NVRAM to factory defaults
               }
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "Setting this value to `powerCycleReset', `resetToNVRAM', or
        `resetToFactoryDefaults' will result in the resetting of the
        printer.  When read, this object will always have the value
        `notResetting(3)', and a SET of the value `notResetting' shall
        have no effect on the printer.  Some of the defined values are
        optional.  However, every implementation must support at least
        the values `notResetting' and resetToNVRAM'."
    ::= { prtGeneralEntry 3 }

-- The Cover Table
--
-- The cover portion of the General print sub-unit describes the
-- covers and interlocks of the printer.  The Cover Table has an
-- entry for each cover and interlock.

prtCover    OBJECT IDENTIFIER ::= { printmib 6 }

prtCoverTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtCoverEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A table of the covers and interlocks of the printer."
    ::= { prtCover 1 }

prtCoverEntry OBJECT-TYPE
    SYNTAX     PrtCoverEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "Information about a cover or interlock.
        Entries may exist in the table for each device
        index whose device type is `printer'."
    INDEX  { hrDeviceIndex, prtCoverIndex }
    ::= { prtCoverTable 1 }

PrtCoverEntry ::= SEQUENCE {
    prtCoverIndex            Integer32,
    prtCoverDescription      DisplayString,
    prtCoverStatus           INTEGER
}

prtCoverIndex OBJECT-TYPE
    SYNTAX     Integer32 (1..65535)
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A unique value used by the printer to identify this Cover
        sub-unit.  Although these values may change due to a major
        reconfiguration of the device (e.g. the addition of new
        cover sub-units to the printer), values are expected to
        remain stable across successive printer power cycles."
    ::= { prtCoverEntry 1 }

prtCoverDescription OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..255))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The manufacturer provided cover sub-mechanism  name in the
        localization specified by prtGeneralCurrentLocalization."
    ::= { prtCoverEntry 2 }

prtCoverStatus  OBJECT-TYPE
    --  This value is a type 2 enumeration
    SYNTAX     INTEGER {
                   other(1),
                   doorOpen(3),
                   doorClosed(4),
                   interlockOpen(5),
                   interlockClosed(6)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The status of this cover sub-unit."
    ::= { prtCoverEntry 3 }

-- The Localization Table
--

-- The localization portion of the General printer sub-unit is

-- responsible for identifying the natural language, country, and
-- character set in which character strings are expressed. There
-- may be one or more localizations supported per printer. The
-- available localizations are represented by the Localization table.

prtLocalization  OBJECT IDENTIFIER ::= { printmib 7 }

prtLocalizationTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtLocalizationEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "The available localizations in this printer."
    ::= { prtLocalization 1 }

prtLocalizationEntry OBJECT-TYPE
    SYNTAX     PrtLocalizationEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A description of a localization.
        Entries may exist in the table for each device
        index who's device type is `printer'."
    INDEX  { hrDeviceIndex, prtLocalizationIndex }
    ::= { prtLocalizationTable 1 }

PrtLocalizationEntry ::= SEQUENCE {
        prtLocalizationIndex                Integer32,
        prtLocalizationLanguage             DisplayString,
        prtLocalizationCountry              DisplayString,
        prtLocalizationCharacterSet         CodedCharSet
}

prtLocalizationIndex OBJECT-TYPE
    SYNTAX     Integer32 (1..65535)
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A unique value used by the printer to identify this
        localization entry.  Although these values may change due to a
        major reconfiguration of the device (e.g., the addition of new
        Cover sub-units to the printer), values are expected to remain
        stable across successive printer power cycles."
    ::= { prtLocalizationEntry 1 }

prtLocalizationLanguage OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..2))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "A two character language code from ISO 639.  Examples EN, GB,
        CA, FR, DE."
    ::= { prtLocalizationEntry 2 }

prtLocalizationCountry OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..2))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "A two character country code from ISO 3166, a blank string
        (two space characters) shall indicate that the country is
        not defined.  Examples: US, FR, DE, ..."
    ::= { prtLocalizationEntry 3 }

prtLocalizationCharacterSet OBJECT-TYPE
    SYNTAX     CodedCharSet
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The coded character set used for this localization."
    ::= { prtLocalizationEntry 4 }

-- The System Resources Tables

-- The Printer MIB makes use of the Host MIB to
-- define system resources by referencing the storage
-- and device groups of the print group.  In order to
-- determine, amongst multiple printers serviced by
-- one agent, which printer owns a particular
-- resource, the prtStorageRef and prtDeviceRef tables
-- associate particular storage and device entries to
-- printers.

prtStorageRefTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtStorageRefEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        ""
    ::= { prtGeneral 2 }

prtStorageRefEntry OBJECT-TYPE
    SYNTAX     PrtStorageRefEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "This table will have an entry for each entry in
        the host MIB storage table that represents storage associated
        with a printer managed by this agent."
    INDEX      { hrStorageIndex, prtStorageRefSeqNumber }
    ::= { prtStorageRefTable 1 }

PrtStorageRefEntry ::= SEQUENCE {
    prtStorageRefSeqNumber  Integer32,
    prtStorageRefIndex      Integer32
}

prtStorageRefSeqNumber OBJECT-TYPE
    SYNTAX     Integer32 (0..65535)
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "This value will be unique amongst all entries with a common
        value of hrStorageIndex.

        This object allows a storage entry to point to the multiple
        printer devices with which it is associated."
    ::= { prtStorageRefEntry 1 }

prtStorageRefIndex OBJECT-TYPE
    SYNTAX     Integer32 (0..65535)
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The value of the hrDeviceIndex of the printer device that this
        storageEntry is associated with."
    ::= { prtStorageRefEntry 2 }

prtDeviceRefTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtDeviceRefEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        ""
    ::= { prtGeneral 3 }

prtDeviceRefEntry OBJECT-TYPE
    SYNTAX     PrtDeviceRefEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "This table will have an entry for each entry in
        the host MIB device table that represents a device associated
        with a printer managed by this agent."
    INDEX      { hrDeviceIndex, prtDeviceRefSeqNumber }
    ::= { prtDeviceRefTable 1 }

PrtDeviceRefEntry ::= SEQUENCE {
    prtDeviceRefSeqNumber   Integer32,
    prtDeviceRefIndex       Integer32
}

prtDeviceRefSeqNumber OBJECT-TYPE
    SYNTAX     Integer32 (0..65535)
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "This value will be unique amongst all entries with a common
        value of hrDeviceIndex.

        This object allows a device entry to point to the multiple
        printer devices with which it is associated."
    ::= { prtDeviceRefEntry 1 }

prtDeviceRefIndex OBJECT-TYPE
    SYNTAX     Integer32 (0..65535)
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The value of the hrDeviceIndex of the printer device that this
        deviceEntry is associated with."
    ::= { prtDeviceRefEntry 2 }

-- The Responsible Party group
--
-- This group is optional.  However, to claim conformance to this
-- group, it is necessary to implement every object in the group.

prtGeneralCurrentOperator OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..127))
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The name of the current human operator responsible for
        operating this printer. It is suggested that this string
        include information that would enable other humans to reach
        the operator, such as a phone number."
    ::= { prtGeneralEntry 4 }

prtGeneralServicePerson OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..127))
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The name of the last human responsible for servicing
        this printer. It is suggested that this string
        include information that would enable other humans to reach
        the service person, such as a phone number."
    ::= { prtGeneralEntry 5 }

-- The Input Group
--
-- Input sub-units are managed as a tabular, indexed collection of
-- possible devices capable of providing media for input to the printing
-- process.  Input sub-units typically have a location, a type, an
-- identifier, a set of constraints on possible media sizes and
-- potentially other media characteristics, and may be capable of
-- indicating current status or capacity.
--
-- Implementation of every object in this group is mandatory.


prtInput   OBJECT IDENTIFIER ::= { printmib 8 }

prtInputDefaultIndex OBJECT-TYPE
    SYNTAX     Integer32 (1..65535)
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
       "The value of prtInputIndex corresponding to the default input
        sub-unit: that is, this object selects the default source of
        input media."
    ::= { prtGeneralEntry 6 }

prtInputTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtInputEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A table of the devices capable of providing media for input
        to the printing process."
    ::= { prtInput 2 }

prtInputEntry OBJECT-TYPE
    SYNTAX     PrtInputEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "Attributes of a device capable of providing media for input
        to the printing process.

        Entries may exist in the table for each device
        index who's device type is `printer'."
    INDEX  { hrDeviceIndex, prtInputIndex }
    ::= { prtInputTable 1 }

PrtInputEntry ::= SEQUENCE {
        prtInputIndex                     Integer32,
        prtInputType                      INTEGER,
        prtInputDimUnit                   MediaUnit,
        prtInputMediaDimFeedDirDeclared   Integer32,
        prtInputMediaDimXFeedDirDeclared  Integer32,
        prtInputMediaDimFeedDirChosen     Integer32,
        prtInputMediaDimXFeedDirChosen    Integer32,
        prtInputCapacityUnit              CapacityUnit,
        prtInputMaxCapacity               Integer32,
        prtInputCurrentLevel              Integer32,
        prtInputStatus                    SubUnitStatus,
        prtInputMediaName                 DisplayString,
        prtInputName                      DisplayString,
        prtInputVendorName                DisplayString,
        prtInputModel                     DisplayString,
        prtInputVersion                   DisplayString,
        prtInputSerialNumber              DisplayString,
        prtInputDescription               DisplayString,
        prtInputSecurity                  PresentOnOff,
        prtInputMediaWeight               Integer32,
        prtInputMediaType                 DisplayString,
        prtInputMediaColor                DisplayString,
        prtInputMediaFormParts            Integer32
}

prtInputIndex OBJECT-TYPE
    SYNTAX     Integer32 (1..65535)
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A unique value used by the printer to identify this input
        sub-unit. Although these values may change due to a major
        reconfiguration of the device (e.g. the addition of new
        input sub-units to the printer), values are expected to
        remain stable across successive printer power cycles."
    ::= { prtInputEntry 1 }

prtInputType OBJECT-TYPE
    --  This value is a type 2 enumeration
    SYNTAX     INTEGER {
                   other(1),
                   unknown(2),
                   sheetFeedAutoRemovableTray(3),
                   sheetFeedAutoNonRemovableTray(4),
                   sheetFeedManual(5),
                   continuousRoll(6),
                   continuousFanFold(7)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The type of technology (discriminated primarily according to
        feeder mechanism type) employed by the input sub-unit.  Note,
        the Optional Input Class provides for a descriptor field to
        further qualify the other choice."
    ::= { prtInputEntry 2 }

prtInputDimUnit OBJECT-TYPE
    SYNTAX     MediaUnit
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The unit of measurement for use calculating and relaying
        dimensional values for this input sub-unit."
    ::= { prtInputEntry 3 }

prtInputMediaDimFeedDirDeclared OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "This object provides the value of the declared dimension, in
        the feed direction, of the media that is (or, if empty, was or
        will be) in this input sub-unit.  The feed direction is the
        direction in which the media is fed on this sub-unit.  This
        dimension is measured in input sub-unit dimensional units
        (prtInputDimUnit).  If this input sub-unit can reliably sense
        this value, the value is sensed by the printer and may not be
        changed by management requests.  Otherwise, the value may be
        changed. The value (-1) means other and specifically means
        that this sub-unit places no restriction on this parameter.
        The value (-2) indicates unknown."
    ::= { prtInputEntry 4 }

prtInputMediaDimXFeedDirDeclared OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "This object provides the value of the declared dimension, in
        the cross feed direction, of the media that is (or, if empty,
        was or will be) in this input sub-unit.  The cross  feed
        direction is ninety degrees relative to the feed direction
        associated with this sub-unit. This dimension is measured in
        input sub-unit dimensional units (prtInputDimUnit).  If this
        input sub-unit can reliably sense this value, the value is
        sensed by the printer and may not be changed by management
        requests. Otherwise, the value may be changed. The value (-1)
        means other and specifically means that this sub-unit places
        no restriction on this parameter. The value (-2) indicates
        unknown."
    ::= { prtInputEntry 5 }

prtInputMediaDimFeedDirChosen OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The printer will act as if media of the chosen dimension (in
        the feed direction) is present in this input source.  Note
        that this value will be used even if the input tray is empty.
        Feed dimension measurements
        are taken parallel relative to the feed direction
        associated with that sub-unit and are in input sub-unit
        dimensional units (DimUnit). If the printer supports the
        declared dimension, the granted dimension is the same as
        the declared dimension. If not, the granted dimension is
        set to the closest dimension that the printer supports
        when the declared dimension is set. The value (-1) means
        other and specifically indicates that this sub-unit
        places no restriction on this parameter. The value (-2)
        indicates unknown."
    ::= { prtInputEntry 6 }

prtInputMediaDimXFeedDirChosen OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The printer will act as if media of the chosen dimension (in
        the cross feed direction) is present in this input source.
        Note that this value will be used even if the input tray is
        empty.  The cross feed direction is ninety degrees relative
        to the feed direction associated with this sub-unit. This
        dimension is measured in input sub-unit dimensional units
        (DimUnit).  If the printer supports the declared
        dimension, the granted dimension is the same as the
        declared dimension. If not, the granted dimension is set
        to the closest dimension that the printer supports when
        the declared dimension is set. The value (-1) means other
        and specifically indicates that this sub-unit places no
        restriction on this parameter.  The value (-2) indicates
        unknown."
    ::= { prtInputEntry 7 }

prtInputCapacityUnit OBJECT-TYPE
    SYNTAX     CapacityUnit
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The unit of measurement for use in calculating and relaying
        capacity values for this input sub-unit."
    ::= { prtInputEntry 8 }

prtInputMaxCapacity OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The maximum capacity of the input sub-unit in input
        sub-unit capacity units (CapacityUnit).  There is no
        convention associated with the media itself so this value
        reflects claimed capacity. If this input sub-unit can
        reliably sense this value, the value is sensed by the
        printer and may not be changed by management requests;
        otherwise, the value may be written (by a Remote
        Contol Panel or a Management Application).
        The value (-1) means other and specifically
        indicates that the sub-unit places no restrictions
        on this parameter.  The value (-2) means unknown."
    ::= { prtInputEntry 9 }

prtInputCurrentLevel OBJECT-TYPE
    SYNTAX     Integer32 --    in capacity units (CapacityUnit).
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The current capacity of the input sub-unit in input
        sub-unit capacity units (CapacityUnit). If this input
        sub-unit can reliably sense this value, the value is
        sensed by the printer and may not be changed by
        management requests; otherwise, the value may
        be written (by a Remote Contol Panel or a
        Management Application).  The value (-1) means other and
        specifically indicates that the sub-unit places no
        restrictions on this parameter. The value (-2) means unknown.
        The value (-3) means that the printer knows that at least one
        unit remains."
    ::= { prtInputEntry 10 }

prtInputStatus OBJECT-TYPE
    SYNTAX     SubUnitStatus
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The current status of this input sub-unit."
    ::= { prtInputEntry 11 }

prtInputMediaName OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..63))
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "A description of the media contained in this input sub-unit;
        This description is intended for display to a human operator.
        This description is not processed by the printer.  It is used
        to provide information not expressible in terms of the other
        media attributes (e.g. prtInputMediaDimFeedDirChosen,
        prtInputMediaDimXFeedDirChosen, prtInputMediaWeight,
        prtInputMediaType). An example would be `legal tender bond
        paper'."
    ::= { prtInputEntry 12 }

--               INPUT MEASUREMENT
--
--     _______ |                     |
--      ^      |                     |
--      |      |                     |                    |
--      |      |_ _ _ _ _ _ _ _ _ _ _| _________________  |direction
--      |      |                     |      ^             v
-- MaxCapacity |                     |      |
--      |      | Sheets left in tray | CurrentLevel
--      |      |                     |      |
--      v      |                     |      v
--     _______ +_____________________+ _______

-- The Extended Input Group
--
-- This group is optional.  However, to claim conformance to this
-- group, it is necessary to implement every object in the group.


prtInputName OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..63))
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The name assigned to this input sub-unit."
    ::= { prtInputEntry 13 }

prtInputVendorName OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..63))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The vendor name of this input sub-unit."
    ::= { prtInputEntry 14 }

prtInputModel OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..63))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The model name of this input sub-unit."
    ::= { prtInputEntry 15 }

prtInputVersion OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..63))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The version of this input sub-unit."
    ::= { prtInputEntry 16 }

prtInputSerialNumber OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..32))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The serial number assigned to this input sub-unit."
    ::= { prtInputEntry 17 }

prtInputDescription OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..255))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "A free-form text description of this input
        sub-unit in the localization specified by
        prtGeneralCurrentLocalization."
    ::= { prtInputEntry 18 }

prtInputSecurity OBJECT-TYPE
    SYNTAX     PresentOnOff
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "Indicates if this input sub-unit has some security
        associated with it."
    ::= { prtInputEntry 19 }

-- The Input Media Group
--
-- The Input Media Group supports identification of media installed
-- or available for use on a printing device. Medium resources are
-- identified by name, and include a collection of characteristic
-- attributes that may further be used for selection and management
-- of them. The Input Media group consists of a set of optional
-- "columns" in the Input Table. In this manner, a minimally
-- conforming implementation may choose to not support reporting
-- of media resources if it cannot do so.
--
-- This group is optional.  However, to claim conformance to this
-- group, it is necessary to implement every object in the group.

prtInputMediaWeight  OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The weight of the medium associated with this input
        sub-unit in grams / per meter squared. The value (-2) means
        unknown."
    ::= { prtInputEntry 20 }

prtInputMediaType OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..63))
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The name of the type of medium associated with this input
        sub-unit. This name need not be processed by the printer; it
        might simply be displayed to an operator. The standardized
        string values from ISO 10175 (DPA) and ISO 10180 (SPDL) are:

        stationery       Separately cut sheets of an opaque material
        transparency     Separately cut sheets of a transparent material
        envelope         Envelopes that can be used for conventional
        mailing purposes
        envelope-plain   Envelopes that are not preprinted and have no
                         windows
        envelope-window  Envelopes that have windows for addressing
                         purposes
        continuous-long  Continuously connected sheets of an opaque
                         material connected along the long edge
        continuous-short Continuously connected sheets of an opaque
                         material connected along the short edge
        tab-stock        Media with tabs
        multi-part-form  Form medium composed of multiple layers not
                         pre-attached to one another; each sheet may be
                         drawn separately from an input source
        labels           Label stock
        multi-layer      Form medium composed of multiple layers which
                         are pre-attached to one another; e.g., for
                         use with impact printers"
    ::= { prtInputEntry 21 }

prtInputMediaColor OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..63))
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The name of the color of the medium associated with
        this input sub-unit using standardized string values
        from ISO 10175 (DPA) and ISO 10180 (SPDL) which are:

        other
        unknown
        white
        pink
        yellow
        buff
        goldenrod
        blue
        green
        transparent

        Implementors may add additional string values. The naming
        conventions in ISO 9070 are recommended in order to avoid
        potential name clashes."
    ::= { prtInputEntry 22 }

prtInputMediaFormParts OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
         "The number of parts associated with the medium
         associated with this input sub-unit if the medium is a
         multi-part form.  The value (-1) means other and
         specifically indicates that the device places no
         restrictions on this parameter.  The value (-2) means
         unknown."
    ::= { prtInputEntry 23 }

-- The Output Group
--
-- Output sub-units are managed as a tabular, indexed collection of
-- possible devices capable of receiving media delivered from the
-- printing process.  Output sub-units typically have a location,
-- a type, an identifier, a set of constraints on possible media
-- sizes and potentially other characteristics, and may be capable
-- of indicating current status or capacity.
--
-- Implementation of every object in this group is mandatory.

prtOutput  OBJECT IDENTIFIER ::= { printmib 9 }

prtOutputDefaultIndex OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The  value of prtOutputIndex  corresponding to the default
        output sub-unit; that is, this object selects the default
        output destination."
    ::= { prtGeneralEntry 7 }

prtOutputTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtOutputEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A table of the devices capable of receiving media delivered
        from the printing process."
    ::= { prtOutput 2 }

prtOutputEntry OBJECT-TYPE
    SYNTAX     PrtOutputEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "Attributes of a device capable of receiving media delivered
        from the printing process.

        Entries may exist in the table for each device
        index who's device type is `printer'."
    INDEX  { hrDeviceIndex, prtOutputIndex }
    ::= { prtOutputTable 1 }

PrtOutputEntry ::= SEQUENCE {
        prtOutputIndex                    Integer32,
        prtOutputType                     INTEGER,
        prtOutputCapacityUnit             CapacityUnit,
        prtOutputMaxCapacity              Integer32,
        prtOutputRemainingCapacity        Integer32,
        prtOutputStatus                   SubUnitStatus,
        prtOutputName                     DisplayString,
        prtOutputVendorName               DisplayString,
        prtOutputModel                    DisplayString,
        prtOutputVersion                  DisplayString,
        prtOutputSerialNumber             DisplayString,
        prtOutputDescription              DisplayString,
        prtOutputSecurity                 PresentOnOff,
        prtOutputDimUnit                  MediaUnit,
        prtOutputMaxDimFeedDir            Integer32,
        prtOutputMaxDimXFeedDir           Integer32,
        prtOutputMinDimFeedDir            Integer32,
        prtOutputMinDimXFeedDir           Integer32,
        prtOutputStackingOrder            INTEGER,
        prtOutputPageDeliveryOrientation  INTEGER,
        prtOutputBursting                 PresentOnOff,
        prtOutputDecollating              PresentOnOff,
        prtOutputPageCollated             PresentOnOff,
        prtOutputOffsetStacking           PresentOnOff
}

prtOutputIndex OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A unique value used by this printer to identify this
        output sub-unit. Although these values may change due
        to a major reconfiguration of the sub-unit (e.g.  the
        addition of new output devices to the printer), values
        are expected to remain stable across successive printer
        power cycles."
    ::= { prtOutputEntry 1 }

prtOutputType OBJECT-TYPE
    -- This value is a type 2 enumeration
    SYNTAX     INTEGER {
                   other(1),
                   unknown(2),
                   removableBin(3),
                   unRemovableBin(4),
                   continuousRollDevice(5),
                   mailBox(6),
                   continuousFanFold(7)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The type of technology supported by this output sub-unit."
    ::= { prtOutputEntry 2 }

prtOutputCapacityUnit OBJECT-TYPE
    SYNTAX     CapacityUnit
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The unit of measurement for use in calculating and relaying
        capacity values for this output sub-unit."
    ::= { prtOutputEntry 3 }

prtOutputMaxCapacity OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The maximum capacity of this output sub-unit in output
        sub-unit capacity units (CapacityUnit). There is no
        convention associated with the media itself so this value
        essentially reflects claimed capacity. If this output
        sub-unit can reliably sense this value, the value is
        sensed by the printer and may not be changed by management
        requests; otherwise, the value may be written
        (by a Remote Contol Panel or a Management Application).
        The value (-1) means other and specifically indicates
        that the sub-unit places no restrictions on this parameter.
        The value (-2) means unknown."
    ::= { prtOutputEntry 4 }

prtOutputRemainingCapacity OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The remaining capacity of the possible output sub-unit
        capacity in output sub-unit capacity units (CapacityUnit)
        of this output sub-unit. If this output sub-unit can
        reliably sense this value, the value is sensed by the
        printer and may not be modified by management requests;
        otherwise, the value may be written (by
        a Remote Contol Panel or a Management
        Application).  The value (-1) means other and
        specifically indicates that the sub-unit places no
        restrictions on this parameter.  The value (-2) means
        unknown.  The value (-3) means that the printer knows that
        there remains capacity for at least one unit."
    ::= { prtOutputEntry 5 }

prtOutputStatus OBJECT-TYPE
    SYNTAX     SubUnitStatus
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The current status of this output sub-unit."
    ::= { prtOutputEntry 6 }


--               OUTPUT MEASUREMENT
--
--     _______ |                     | _______
--      ^      |                     |      ^
--      |      |                     |      |
--      |      |                     | RemainingCapacity
-- MaxCapacity |                     |      |
--      |      |                     |      v               ^
--      |      |_ _ _ _ _ _ _ _ _ _ _| ___________________  |direction
--      |      |                     |                      |
--      |      |  Sheets in output   |
--      v      |                     |
--     _______ +_____________________+

-- The Extended Output Group
--
-- This group is optional.  However, to claim conformance to this
-- group, it is necessary to implement every object in the group.

prtOutputName OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..63))
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The name assigned to this output sub-unit."
    ::= { prtOutputEntry 7 }

prtOutputVendorName OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..63))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The vendor name of this output sub-unit."
    ::= { prtOutputEntry 8 }

prtOutputModel OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..63))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The name assigned to this output sub-unit."
    ::= { prtOutputEntry 9 }

prtOutputVersion OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..63))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The version of this output sub-unit."
    ::= { prtOutputEntry 10 }

prtOutputSerialNumber OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..63))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The serial number assigned to this output sub-unit."
    ::= { prtOutputEntry 11 }

prtOutputDescription OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..255))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "  A free-form text description of this output sub-unit in the
        localization specified by prtGeneralCurrentLocalization."
    ::= { prtOutputEntry 12 }

prtOutputSecurity OBJECT-TYPE
    SYNTAX     PresentOnOff
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "Indicates if this output sub-unit has some security associated
        with it and if that security is enabled or not."
    ::= { prtOutputEntry 13 }

-- The Output Dimensions Group
--
-- This group is optional.  However, to claim conformance to this
-- group, it is necessary to implement every object in the group.

prtOutputDimUnit OBJECT-TYPE
    SYNTAX     MediaUnit
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The unit of measurement for use in calculating and relaying
        dimensional values for this output sub-unit."
    ::= { prtOutputEntry 14 }

prtOutputMaxDimFeedDir OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The maximum dimensions supported by this output sub-unit
        for measurements taken parallel relative to the feed
        direction associated with that sub-unit in output
        sub-unit dimensional units (DimUnit). If this output
        sub-unit can reliably sense this value, the value is
        sensed by the printer and may not be changed with
        management protocol operations."
    ::= { prtOutputEntry 15 }

prtOutputMaxDimXFeedDir OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The maximum dimensions supported by this output sub-unit
        for measurements taken ninety degrees relative to the
        feed direction associated with that sub-unit in output
        sub-unit dimensional units (DimUnit). If this output
        sub-unit can reliably sense this value, the value is
        sensed by the printer and may not be changed with
        management protocol operations."
    ::= { prtOutputEntry 16 }

prtOutputMinDimFeedDir OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The minimum dimensions supported by this output sub-unit
        for measurements taken parallel relative to the feed
        direction associated with that sub-unit in output
        sub-unit dimensional units (DimUnit).  If this output
        sub-unit can reliably sense this value, the value is
        sensed by the printer and may not be changed with
        management protocol operations."
    ::= { prtOutputEntry 17 }

prtOutputMinDimXFeedDir OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The minimum dimensions supported by this output sub-unit
        for measurements taken ninety degrees relative to the
        feed direction associated with that sub-unit in output
        sub-unit dimensional units (DimUnit). If this output
        sub-unit can reliably sense this value, the value is
        sensed by the printer and may not be changed with
        management protocol operations."
    ::= { prtOutputEntry 18 }

-- The Output Features Group
--
-- This group is optional.  However, to claim conformance to this
-- group, it is necessary to implement every object in the group.

prtOutputStackingOrder OBJECT-TYPE
    --  This value is a type 1 enumeration
    SYNTAX     INTEGER {
                   unknown(2),
                   firstToLast(3),
                   lastToFirst(4)
               }
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The current state of the stacking order for the
        associated output sub-unit. `FirstToLast' means
        that as pages are output the front of the next page is
        placed against the back of the previous page.
        `LasttoFirst' means that as pages are output the back
        of the next page is placed against the front of the
        previous page."
    ::= { prtOutputEntry 19 }

prtOutputPageDeliveryOrientation OBJECT-TYPE
    --   This value is a type 1 enumeration
    SYNTAX     INTEGER {
                   faceUp(3),
                   faceDown(4)
               }
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The reading surface that will be `up' when pages are
        delivered to the associated output sub-unit. Values are
        Face-Up and Face-Down. (Note: interpretation of these
        values is in general context-dependent based on locale;
        presentation of these values to an end-user should be
        normalized to the expectations of the user)."
    ::= { prtOutputEntry 20 }

prtOutputBursting OBJECT-TYPE
    SYNTAX     PresentOnOff
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "This object indicates that the outputing sub-unit
        supports bursting, and if so, whether the feature is enabled.
        Bursting is the process by which continuous media is separated
        into individual sheets, typically by bursting along pre-formed
        perforations."
    ::= { prtOutputEntry 21 }

prtOutputDecollating OBJECT-TYPE
    SYNTAX     PresentOnOff
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "This object indicates that the output supports
        supports decollating, and if so, whether the feature
        is enabled. Decollating is the process by which the
        individual parts within a multi-part form are separated
        and sorted into separate stacks for each part."
    ::= { prtOutputEntry 22 }

prtOutputPageCollated OBJECT-TYPE
    SYNTAX     PresentOnOff
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "This object indicates that the output sub-unit
        supports page collation, and if so, whether the feature is
        enabled."
    ::= { prtOutputEntry 23 }

prtOutputOffsetStacking OBJECT-TYPE
    SYNTAX     PresentOnOff
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "This object indicates that the output supports
        supports offset stacking, and if so, whether the feature is
        enabled."
    ::= { prtOutputEntry 24 }

-- The Marker Group
--
-- A marker is the mechanism that produces marks on the print media.  The
-- marker sub-units and their associated supplies are represented by the
-- Marker Group in the model.  A printer can contain one or more marking
-- mechanisms.  Some examples of multiple marker sub-units are: a printer
-- with separate markers for normal and magnetic ink or an imagesetter
-- that can output to both a proofing device and final film. Each marking
-- device can have its own set of  characteristics associated with it,
-- such as marking technology and resolution.
--
-- Implementation of every object in this group is mandatory.


prtMarker OBJECT IDENTIFIER ::= { printmib 10 }

prtMarkerDefaultIndex OBJECT-TYPE
    SYNTAX     Integer32 (1..65535)
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The value of prtMarkerIndex  corresponding to the
        default markersub-unit; that is, this object selects the
        default marker."
    ::= { prtGeneralEntry 8 }

-- The printable area margins as listed below define an area of the print
-- media which is guaranteed to be printable for all combinations of
-- input, media paths, and interpreters for this marker.

prtMarkerTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtMarkerEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        ""
    ::= { prtMarker 2 }

prtMarkerEntry OBJECT-TYPE
    SYNTAX     PrtMarkerEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "Entries may exist in the table for each device
        index who's device type is `printer'."
    INDEX  { hrDeviceIndex, prtMarkerIndex }
    ::= { prtMarkerTable 1 }

PrtMarkerEntry ::= SEQUENCE {
        prtMarkerIndex                  Integer32,
        prtMarkerMarkTech               INTEGER,
        prtMarkerCounterUnit            INTEGER,
        prtMarkerLifeCount              Counter32,
        prtMarkerPowerOnCount           Counter32,
        prtMarkerProcessColorants       Integer32,
        prtMarkerSpotColorants          Integer32,
        prtMarkerAddressabilityUnit     INTEGER,
        prtMarkerAddressabilityFeedDir  Integer32,
        prtMarkerAddressabilityXFeedDir Integer32,
        prtMarkerNorthMargin            Integer32,
        prtMarkerSouthMargin            Integer32,
        prtMarkerWestMargin             Integer32,
        prtMarkerEastMargin             Integer32,
        prtMarkerStatus                 SubUnitStatus
}


prtMarkerIndex OBJECT-TYPE
    SYNTAX     Integer32 (1..65535)
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A unique value used by the printer to identify this marking
        SubUnitStatus.  Although these values may change due to a major
        reconfiguration of the device (e.g. the addition of new marking
        sub-units to the printer), values are expected to remain
        stable across successive printer power cycles."
    ::= { prtMarkerEntry 1 }

prtMarkerMarkTech OBJECT-TYPE
    -- This value is a type 2 enumeration
    SYNTAX     INTEGER {
                   other(1),
                   unknown(2),
                   electrophotographicLED(3),
                   electrophotographicLaser(4),
                   electrophotographicOther(5),
                   impactMovingHeadDotMatrix9pin(6),
                   impactMovingHeadDotMatrix24pin(7),
                   impactMovingHeadDotMatrixOther(8),
                   impactMovingHeadFullyFormed(9),
                   impactBand(10),
                   impactOther(11),
                   inkjetAqueous(12),
                   inkjetSolid(13),
                   inkjetOther(14),
                   pen(15),
                   thermalTransfer(16),
                   thermalSensitive(17),
                   thermalDiffusion(18),
                   thermalOther(19),
                   electroerosion(20),
                   electrostatic(21),
                   photographicMicrofiche(22),
                   photographicImagesetter(23),
                   photographicOther(24),
                   ionDeposition(25),
                   eBeam(26),
                   typesetter(27)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The type of marking technology used for this marking sub-unit."
    ::= { prtMarkerEntry 2 }

prtMarkerCounterUnit OBJECT-TYPE
    -- This value is a type 1 enumeration
    SYNTAX     INTEGER {
                   tenThousandthsOfInches(3),  -- .0001
                   micrometers(4),
                   characters(5),
                   lines(6),
                   impressions(7),
                   sheets(8),
                   dotRow(9),
                   hours(11),
                   feet(16),
                   meters(17)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The unit that will be used by the printer when reporting
        counter values for this marking sub-unit.  The
        time units of measure are provided for a device like a
        strip recorder that does not or cannot track the physical
        dimensions of the media and does not use characters,
        lines or sheets."
    ::= { prtMarkerEntry 3}

prtMarkerLifeCount OBJECT-TYPE
    SYNTAX     Counter32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The count of the number of units of measure counted during
        the life of printer using units of measure as specified by
        CounterUnit."
    ::= { prtMarkerEntry 4 }

prtMarkerPowerOnCount OBJECT-TYPE
    SYNTAX     Counter32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The count of the number of units of measure counted since the
        equipment was most recently powered on using units of measure as
        specified by CounterUnit."
    ::= { prtMarkerEntry 5 }

prtMarkerProcessColorants OBJECT-TYPE
    SYNTAX     Integer32 (0..65535)
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The number of process colors supported by this marker.  A
        process color of 1 implies monochrome.  The value of this
        object and SpotColorants cannot both be 0.  Must be 0 or
        greater."
    ::= { prtMarkerEntry 6 }

prtMarkerSpotColorants OBJECT-TYPE
    SYNTAX     Integer32 (0..65535)
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The number of spot colors supported by this marker.  The
        value of this object and ProcessColorants cannot
        both be 0.  Must be 0 or greater."
    ::= { prtMarkerEntry 7 }

prtMarkerAddressabilityUnit OBJECT-TYPE
    --   This value is a type 1 enumeration
    SYNTAX     INTEGER {
                   tenThousandthsOfInches(3),  -- .0001
                   micrometers(4)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The unit of measure of distances."
    ::= { prtMarkerEntry 8 }

prtMarkerAddressabilityFeedDir OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The  number of addressable marking positions in the feed
        direction per 10000 units of measure specified by
        AddressabilityUnit.  A value of (-1) implies 'other' or
        'infinite' while a value of (-2) implies 'unknown'."
    ::= { prtMarkerEntry 9 }

prtMarkerAddressabilityXFeedDir OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The number of addressable marking positions in the cross
        feed direction in 10000 units of measure specified by
        AddressabilityUnit.  A value of (-1) implies 'other' or
        'infinite' while a value of (-2) implies 'unknown'."
    ::= { prtMarkerEntry 10 }

prtMarkerNorthMargin OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The margin, in units identified by AddressabilityUnit,
        from the leading edge of the medium as the medium flows
        throught the marking engine with the side to be imaged
        facing the observer. The leading edge is the North edge
        and the other edges are defined by the normal compass
        layout of  directions with the compass facing the
        observer.  Printing within the area bounded by all four
        margins is guaranteed for all interpreters.   The value
        (-2) means unknown."
    ::= { prtMarkerEntry 11 }

prtMarkerSouthMargin OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The margin from the South edge  (see NorthMargin)
        of the medium in units identified by
        AddressabilityUnit.  Printing within the area bounded by
        all four margins  is guaranteed for all interpreters.
        The value (-2) means unknown."
    ::= { prtMarkerEntry 12 }

prtMarkerWestMargin OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The margin from the West edge (see NorthMargin) of the
        medium in units identified by AddressabilityUnit.
        Printing within the area bouned by all four margins is
        guaranteed for all interpreters.   The value (-2) means
        unknown."
    ::= { prtMarkerEntry 13 }

prtMarkerEastMargin OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The margin from the East edge (see NorthMargin) of the
        medium in units identified by AddressabilityUnit.
        Printing within the area bounded by all four margins is
        guaranteed for all interpreters. The value (-2) means
        unknown."
    ::= { prtMarkerEntry 14 }

prtMarkerStatus OBJECT-TYPE
    SYNTAX     SubUnitStatus
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The current status of this marker sub-unit."
        ::= { prtMarkerEntry 15 }

-- The Marker Supplies Group
--
-- This group is optional.  However, to claim conformance to this
-- group, it is necessary to implement every object in the group.

prtMarkerSupplies OBJECT IDENTIFIER ::= { printmib 11 }

prtMarkerSuppliesTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtMarkerSuppliesEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A table of the marker supplies available on this printer."
    ::= { prtMarkerSupplies 1 }

prtMarkerSuppliesEntry OBJECT-TYPE
    SYNTAX     PrtMarkerSuppliesEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "Attributes of a marker supply.

        Entries may exist in the table for each device
        index who's device type is `printer'."
    INDEX  { hrDeviceIndex, prtMarkerSuppliesIndex }
    ::= { prtMarkerSuppliesTable 1 }

PrtMarkerSuppliesEntry ::= SEQUENCE {
        prtMarkerSuppliesIndex          Integer32,
        prtMarkerSuppliesMarkerIndex    Integer32,
        prtMarkerSuppliesColorantIndex  Integer32,
        prtMarkerSuppliesClass          INTEGER,
        prtMarkerSuppliesType           INTEGER,
        prtMarkerSuppliesDescription    DisplayString,
        prtMarkerSuppliesSupplyUnit     INTEGER,
        prtMarkerSuppliesMaxCapacity    Integer32,
        prtMarkerSuppliesLevel          Integer32
}


prtMarkerSuppliesIndex OBJECT-TYPE
    SYNTAX     Integer32 (1..65535)
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A unique value used by the printer to identify this marker
        supply.  Although these values may change due to a major
        reconfiguration of the device (e.g. the addition of new marker
        supplies to the printer), values are expected to remain stable
        across successive printer power cycles."
    ::= { prtMarkerSuppliesEntry 1 }

prtMarkerSuppliesMarkerIndex OBJECT-TYPE
    SYNTAX     Integer32 (0..65535)
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The value of prtMarkerIndex corresponding to the
        marking sub-unit with which this marker supply
        sub-unit is associated."
    ::= { prtMarkerSuppliesEntry 2 }

prtMarkerSuppliesColorantIndex OBJECT-TYPE
    SYNTAX     Integer32 (0..65535)
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The value of prtMarkerColorantIndex
        corresponding to the colorant with which this
        marker supply sub-unit is associated.  This value
        shall be 0 if there is no colorant table."
    ::= { prtMarkerSuppliesEntry 3 }

prtMarkerSuppliesClass OBJECT-TYPE
    --  This value is a type 1 enumeration
    SYNTAX     INTEGER {
                   other(1),
                   supplyThatIsConsumed(3),
                   receptacleThatIsFilled(4)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "Indicates whether this supply entity represents a supply
        container that is consumed or a receptacle that is filled."
    ::= { prtMarkerSuppliesEntry 4 }

prtMarkerSuppliesType OBJECT-TYPE
    --   This value is a type 3 enumeration
    SYNTAX     INTEGER {
                   other(1),
                   unknown(2),
                   toner(3),
                   wasteToner(4),
                   ink(5),
                   inkCartridge(6),
                   inkRibbon(7),
                   wasteInk(8),
                   opc(9),
                   developer(10),
                   fuserOil(11),
                   solidWax(12),
                   ribbonWax(13),
                   wasteWax(14)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The type of this supply."
    ::= { prtMarkerSuppliesEntry 5 }

prtMarkerSuppliesDescription OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..255))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The description of this supply container/receptacle in the
        localization specified by prtGeneralCurrentLocalization."
    ::= { prtMarkerSuppliesEntry 6 }

prtMarkerSuppliesSupplyUnit OBJECT-TYPE
    -- This value is a type 1 enumeration
    SYNTAX     INTEGER {
                   tenThousandthsOfInches(3),  -- .0001
                   micrometers(4),
                   thousandthsOfOunces(12),
                   tenthsOfGrams(13),
                   hundrethsOfFluidOunces(14),
                   tenthsOfMilliliters(15)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "Unit of this marker supply container/receptacle."
    ::= { prtMarkerSuppliesEntry 7 }

prtMarkerSuppliesMaxCapacity OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The maximum capacity of this supply container/receptacle
        expressed in SupplyUnit. If this supply
        container/receptacle can reliably sense this value, the
        value is sensed by the printer and is read-only;
        otherwise, the value may be written (by a Remote Contol
        Panel or a Management Application). The value (-1) means
        other and specifically indicates that the sub-unit places
        no restrictions on this parameter. The value (-2) means
        unknown."
    ::= { prtMarkerSuppliesEntry 8 }

prtMarkerSuppliesLevel OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The current level if this supply is a container; the
        remaining space if this supply is a receptacle. If this
        supply container/receptacle can reliably sense this
        value, the value is sensed by the printer and is
        read-only; otherwise, the value may be written (by a
        Remote Contol Panel or a Management Application). The
        value (-1) means other and specifically indicates that
        the sub-unit places no restrictions on this parameter.
        The value (-2) means unknown.  A value of (-3) means that the
        printer knows that there is some supply/remaining space,
        respectively."
    ::= { prtMarkerSuppliesEntry 9 }

-- The Marker Colorant Group
--
-- This group is optional.  However, to claim conformance to this
-- group, it is necessary to implement every object in the group.

prtMarkerColorant OBJECT IDENTIFIER ::= { printmib 12 }

prtMarkerColorantTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtMarkerColorantEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A table of all of the colorants available on the printer."
    ::= { prtMarkerColorant 1 }

prtMarkerColorantEntry OBJECT-TYPE
    SYNTAX     PrtMarkerColorantEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "Attributes of a colorant available on the printer.

        Entries may exist in the table for each device
        index who's device type is `printer'."
    INDEX { hrDeviceIndex, prtMarkerColorantIndex }
    ::= { prtMarkerColorantTable 1 }

PrtMarkerColorantEntry ::= SEQUENCE {
        prtMarkerColorantIndex          Integer32,
        prtMarkerColorantMarkerIndex    Integer32,
        prtMarkerColorantRole           INTEGER,
        prtMarkerColorantValue          DisplayString,
        prtMarkerColorantTonality       Integer32
}

prtMarkerColorantIndex OBJECT-TYPE
    SYNTAX     Integer32 (1..65535)
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A unique value used by the printer to identify this colorant.
        Although these values may change due to a major
        reconfiguration of the device (e.g. the addition of new
        colorants to the printer), values are expected to remain
        stable across successive printer power cycles."
    ::= { prtMarkerColorantEntry 1 }

prtMarkerColorantMarkerIndex OBJECT-TYPE
    SYNTAX     Integer32 (0..65535)
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The value of prtMarkerIndex corresponding to the
        marker sub-unit with which this colorant entry is
        associated."
    ::= { prtMarkerColorantEntry 2 }

prtMarkerColorantRole OBJECT-TYPE
    -- This value is a type 1 enumeration
    SYNTAX     INTEGER { --  Colorant Role
                   other(1),
                   process(3),
                   spot(4)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The role played by this colorant."
    ::= { prtMarkerColorantEntry 3 }

prtMarkerColorantValue OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..63))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The name of the color of this The name of the color of this
        colorant using standardized string names from ISO 10175 (DPA)
        and ISO 10180 (SPDL) which are:
          other
          unknown
          white
          red
          green
          blue
          cyan
          magenta
          yellow
          black
        Implementors may add additional string values. The naming
        conventions in ISO 9070 are recommended in order to avoid
        potential name clashes"
    ::= { prtMarkerColorantEntry 4 }

prtMarkerColorantTonality OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The distinct levels of tonality realizable by a marking
        sub-unit when using this colorant.  This value does not
        include the number of levels of tonal difference that an
        interpreter can obtain by techniques such as half toning.
        This value must be at least 2."
    ::= { prtMarkerColorantEntry 5 }

-- The Media Path Group
--
-- The media paths encompass the mechanisms in the printer that move the
-- media through the printer and connect all other media related sub-
-- units: inputs, outputs, markers and finishers. A printer contains one
-- or more media paths. These are represented by the Media Path Group in
-- the model. The Media Path group has some attributes that apply to all
-- paths plus a table of the separate media paths.

prtMediaPath OBJECT IDENTIFIER ::= { printmib 13 }

prtMediaPathDefaultIndex OBJECT-TYPE
    SYNTAX     Integer32 (1..65535)
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The value of prtMediaPathIndex corresponding to
        the default media path; that is, the selection of the
        default media path."
    ::= { prtGeneralEntry 9 }

prtMediaPathTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtMediaPathEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        ""
    ::= { prtMediaPath 4 }

prtMediaPathEntry OBJECT-TYPE
    SYNTAX     PrtMediaPathEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "Entries may exist in the table for each device
        index who's device type is `printer'."
    INDEX  { hrDeviceIndex, prtMediaPathIndex }
    ::= { prtMediaPathTable 1 }

PrtMediaPathEntry ::= SEQUENCE {
    prtMediaPathIndex               Integer32,
    prtMediaPathMaxSpeedPrintUnit   INTEGER,
    prtMediaPathMediaSizeUnit       MediaUnit,
    prtMediaPathMaxSpeed            Integer32,
    prtMediaPathMaxMediaFeedDir     Integer32,
    prtMediaPathMaxMediaXFeedDir    Integer32,
    prtMediaPathMinMediaFeedDir     Integer32,
    prtMediaPathMinMediaXFeedDir    Integer32,
    prtMediaPathType                INTEGER,
    prtMediaPathDescription         DisplayString,
    prtMediaPathStatus              SubUnitStatus
}


prtMediaPathIndex OBJECT-TYPE
    SYNTAX     Integer32 (1..65535)
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A unique value used by the printer to identify this media
        path. Although these values may change due to a major
        reconfiguration of the device (e.g. the addition of new
        media paths to the printer), values are expected to remain
        stable across successive printer power
        cycles."
    ::= { prtMediaPathEntry 1 }

prtMediaPathMaxSpeedPrintUnit OBJECT-TYPE
    -- This value is a type 1 enumeration
    SYNTAX     INTEGER {
                   tenThousandthsOfInchesPerHour(3),   -- .0001/hour
                   micrometersPerHour(4),
                   charactersPerHour(5),
                   linesPerHour(6),
                   impressionsPerHour(7),
                   sheetsPerHour(8),
                   dotRowPerHour(9),
                   feetPerHour(16),
                   metersPerHour(17)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The unit of measure used in specifying the speed of all media
        paths in the printer."
    ::= { prtMediaPathEntry 2 }

prtMediaPathMediaSizeUnit OBJECT-TYPE
    SYNTAX     MediaUnit
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The units of measure of media size for use in calculating and
        relaying dimensional values for all media paths in the printer."
    ::= { prtMediaPathEntry 3 }

prtMediaPathMaxSpeed OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The maximum printing speed of this media path expressed in
        prtMediaPathMaxSpeedUnit's.  A value of (-1) implies
        'other'."
    ::= { prtMediaPathEntry 4 }

prtMediaPathMaxMediaFeedDir OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The maximum physical media size in the feed direction of this
        media path expressed in units of measure specified by
        MediaSizeUnit.  A value of (-1) implies 'unlimited'.  A value
        of (-2) implies 'unknown'"
    ::= { prtMediaPathEntry 5 }

prtMediaPathMaxMediaXFeedDir OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The maximum physical media size across the feed direction of
        this media path expressed in units of measure specified by
        MediaSizeUnit.  A value of (-2) implies 'unknown'."
    ::= { prtMediaPathEntry 6 }

prtMediaPathMinMediaFeedDir OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The minimum physical media size in the feed direction of this
        media path expressed in units of measure specified by
        MediaSizeUnit. A value of (-2) implies 'unknown'."
    ::= { prtMediaPathEntry 7 }

prtMediaPathMinMediaXFeedDir OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The minimum physical media size across the feed direction of
        this media path expressed in units of measure specified by
        MediaSizeUnit.  A value of (-2) implies 'unknown'."
    ::= { prtMediaPathEntry 8 }

prtMediaPathType OBJECT-TYPE
    --   This value is a type 2 enumeration
    SYNTAX     INTEGER {
                   other(1),
                   unknown(2),
                   longEdgeBindingDuplex(3),
                   shortEdgeBindingDuplex(4),
                   simplex(5)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The type of the media path for this media path."
    ::= { prtMediaPathEntry 9 }

prtMediaPathDescription OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..255))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The manufacturer-provided description of this media path in
        the localization specified by prtGeneralCurrentLocalization."
    ::= { prtMediaPathEntry 10 }

prtMediaPathStatus OBJECT-TYPE
    SYNTAX     SubUnitStatus
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The current status of this media path."
    ::= { prtMediaPathEntry 11 }

-- The Channel Group
--
-- Implementation of every object in this group is mandatory.

-- Channels are independent sources of print data. Here,
-- print data is the term used for the information that is
-- used to construct printed pages and may have both data
-- and control aspects. The output of a channel is in a form
-- suitable for input to one of the interpreters as a
-- stream. A channel may be independently enabled (allowing
-- print data to flow) or disabled (stopping the flow of
-- print data). A printer may have one or more channels.
--
-- Basically, the channel abstraction is intended to cover
-- all the aspects of getting the print data to an
-- interpreter. This might include transporting the data
-- from one place to another, it might include (invisible)
-- compression, it might include encoding or packetizing to
-- provide multiple information sources over a single
-- physical interface and it might include filtering
-- characters that were destined for another kind of
-- channel. All of these aspects are hidden in the channel
-- abstraction.(Note some Page Description Languages have
-- compression built into them so "invisible" compression
-- refers to compression done by the transport medium and
-- removed before the data is presented to the interpreter.)
--
-- There are many kinds of channels;some of which are based
-- on networks and others which are not. For example, a
-- channel can be a serial (or parallel) connection; it can
-- be a service, such as the Unix Line Printer Daemon (LPD),
-- offering itself over a network connection (interface); or
-- it could be a disk drive into which a floppy disks with
-- the print data is inserted. Each channel is typically
-- identified by the electronic path and/or service protocol
-- used to deliver print data to the printer.
--
-- Channel example                   Implementation
--
-- serial port channel            bi-directional data channel
-- parallel port channel          often uni-directional channel
-- IEEE 1284 port channel         bi-directional channel
-- SCSI port channel              bi-directional
-- Apple PAP channel              may be based on Local-, Ether-or
--                                TokenTalk
-- LPD Server channel             typically TCP/IP based, port 515

-- Novell Remote Printer          typically SPX/IPX based channel
-- Novell Print Server            typically SPX/IPX based channel
-- port 9100 channel              HP and friends
-- Adobe AppSocket(9101) channel  a bi-directional extension of LPD
--
-- It is easy to note that this is a mixed bag.  There are
-- some physical connections over which no (or very meager)
-- protocols are run (e.g. the serial or old parallel ports)
-- and there are services which often have elaborate
-- protocols that run over a number of protocol stacks. In
-- the end what is important is the delivery of print data
-- thru the channel.
--
-- The channel sub-units are represented by the Channel
-- Group in the Model. It has a current Control Language
-- which can be used to specify which interpreter is to be
-- used for the print data and to query and change
-- environment variables used by the interpreters (and
-- Mangement Applications). There is also a default
-- interpreter that is to be used if an interpreter is not
-- explicitly specified using the Control Language. Channel
-- sub-units are based on an underlying interface.

--       The channel table and its underlying structure
--
-- The first seven items in the Channel Table define the
-- "channel" itself.  A channel typically depends on other
-- protocols and interfaces to provide the data that flows
-- thru the channel. It is necessary to provide control of
-- the (perhaps complex) process by which print data arrives
-- at an interpreter. Control is largely limited to enabling
-- or disabling the whole channel. It is likely, however,
-- that more control of the process of accessing print data
-- will be needed over time. Thus, the ChannelType will
-- allow type specific data to be associated with each
-- channel (using ChannelType specific groups in a fashion
-- analogous to the media specific MIBs that are associated
-- with the IANAIfType in the Interfaces Table). As a first
-- step in this direction, each channel will identify the
-- underlying Interface on which it is based. This is the
-- eighth object in each row of the table.

-- Some examples of the kind of control are where
-- compression or encoding is used; and whether the data is
-- filtered to remove file storage anomolies such as those
-- created by using MS-DOS/PC-DOS LPT1:.
--

-- The Channel Table
--
-- The prtChannelTable represents the set of input data sources which
-- can provide print data to one or more of the interpreters
-- available on a printer


prtChannel OBJECT IDENTIFIER ::= { printmib 14 }

prtChannelTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtChannelEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        ""
    ::= { prtChannel 1 }

prtChannelEntry OBJECT-TYPE
    SYNTAX     PrtChannelEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "Entries may exist in the table for each device
        index who's device type is `printer'."
    INDEX  { hrDeviceIndex, prtChannelIndex }
    ::= { prtChannelTable 1 }

PrtChannelEntry ::= SEQUENCE {
    prtChannelIndex                     Integer32,
    prtChannelType                      INTEGER,
    prtChannelProtocolVersion           DisplayString,
    prtChannelCurrentJobCntlLangIndex   Integer32,
    prtChannelDefaultPageDescLangIndex  Integer32,
    prtChannelState                     INTEGER,
    prtChannelIfIndex                   Integer32,
    prtChannelStatus                    SubUnitStatus
}

prtChannelIndex OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A unique value used by the printer to identify this data
        channel.  Although these values may change due to a major
        reconfiguration of the device (e.g. the addition of new data
        channels to the printer), values are expected to remain
        stable across successive printer power cycles."
    ::= { prtChannelEntry 1 }

prtChannelType OBJECT-TYPE
    -- This value is a type 2 enumeration
    SYNTAX     INTEGER {
                   other(1),
                   chSerialPort(3),
                   chParallelPort(4),
                   chIEEE1284Port(5),
                   chSCSIPort(6),
                   chAppleTalkPAP(7), -- AppleTalk Printer Achess Protocol
                   chLPDServer(8),
                   chNetwareRPrinter(9),  -- Netware
                   chNetwarePServer(10),  -- Netware
                   chPort9100(11),
                   chAppSocket(12),       -- a bi-directional, LPD-like
                                          -- protocol using 9101 for
                                          -- control and 9100 for data.
                                          -- Adobe Systems, Inc.
                   chFTP(13),             -- FTP "PUT" to printer
                   chTFTP(14),
                   chDLCLLCPort(15),
                   chIBM3270(16),
                   chIBM5250(17),
                   chFax(18),
                   chIEEE1394(19),
                   chTransport1(20),      -- port 35
                   chCPAP(21),            -- port 170
                   chDCERemoteProcCall(22), -- OSF
                   chONCRemoteProcCall(23), -- Sun Microsystems
                   chOLE(24),               -- Microsoft
                   chNamedPipe(25),
                   chPCPrint(26),           -- Banyan
                   chServerMessageBlock(27),
                        -- File/Print sharing protocol used by
                        -- various network operating systems
                        -- from IBM 3Com, Microsoft and others
                   chDPMF(28),  -- Distributed Print Mgt. Framework, IBM
                   chDLLAPI(29), -- Microsoft
                   chVxDAPI(30), -- Microsoft
                   chSystemObjectManager(31), -- IBM
                   chDECLAT(32),          -- Digital Equipment Corp.
                   chNPAP(33)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The type of this print data channel.  This
        object provides the linkage to ChannelType-specific
        groups that may (conceptually) extend the prtChannelTable
        with additional details about that channel."
    ::= { prtChannelEntry 2 }

prtChannelProtocolVersion OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..63))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The version of the protocol used on this
        channel.  The format used for version numbering depends
        on prtChannelType."
    ::= { prtChannelEntry 3 }

prtChannelCurrentJobCntlLangIndex OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The value of prtInterpreterIndex  corresponding to the
        Control Language Interpreter for this channel. This
        interpreter defines the syntax used for control
        functions, such as querying or changing environment
        variables and identifying job boundaries (e.g. PJL,
        PostScript, NPAP). Must be 1 or greater."
    ::= { prtChannelEntry 4 }

prtChannelDefaultPageDescLangIndex OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The value of prtInterpreterIndex  corresponding to the
        Page Description Language Interpreter for this channel.
        This interpreter defines the default Page Description
        Language interpreter to be used for the print data unless
        the Control Language is used to select a specific
        interpreter (e.g.,  PCL, PostScript Language,
        auto-sense). Must be 1 or greater."
    ::= { prtChannelEntry 5 }

prtChannelState OBJECT-TYPE
    -- This value is a type 1 enumeration
    SYNTAX     INTEGER {
                   other(1),
                   printDataAccepted(3),
                   noDataAccepted(4)
               }
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The state of this print data channel.  The value determines
        whether control information and print data is allowed through
        this channel or not."
    ::= { prtChannelEntry 6 }

prtChannelIfIndex OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The value of ifIndex (in the ifTable; see the interface
        section of MIB-2/RFC 1213) which corresponds to this channel.
        When more than one row of the ifTable is relevant, this is
        the index of the row representing the topmost layer in the
        interface hierarchy.  A value of zero indicates that no
        interface is associated with this channel."
    ::= { prtChannelEntry 7 }

prtChannelStatus OBJECT-TYPE
    SYNTAX     SubUnitStatus
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The current status of the channel."
    ::= { prtChannelEntry 8 }

-- The Interpreter Group
--
-- The interpreter sub-units are responsible for the conversion of a
-- description of intended print instances into images that are to be
-- marked on the media. A printer may have one or more interpreters. The
-- interpreter sub-units are represented by the Interpreter Group in the
-- Model. Each interpreter is generally implemented with software running
-- on the System Controller sub-unit. The Interpreter Table has one entry
-- per interpreter where the interpreters include both Page Description
-- Language (PDL) Interpreters and Control Language Interpreters.
--
-- Implementation of every object in this group is mandatory.


prtInterpreter OBJECT IDENTIFIER ::= { printmib 15 }

--       Interpreter Table
--
-- The prtInterpreterTable is a table representing the interpreters in
-- the printer.  An entry shall be placed in the interpreter table for
-- each interpreter on the printer.

prtInterpreterTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtInterpreterEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        ""
    ::= { prtInterpreter 1 }

prtInterpreterEntry OBJECT-TYPE
    SYNTAX     PrtInterpreterEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "Entries may exist in the table for each device
        index who's device type is `printer'."
    INDEX  { hrDeviceIndex, prtInterpreterIndex }
    ::= { prtInterpreterTable 1 }

PrtInterpreterEntry ::= SEQUENCE {
    prtInterpreterIndex                 Integer32,
    prtInterpreterLangFamily            INTEGER,
    prtInterpreterLangLevel             DisplayString,
    prtInterpreterLangVersion           DisplayString,
    prtInterpreterDescription           DisplayString,
    prtInterpreterVersion               DisplayString,
    prtInterpreterDefaultOrientation    INTEGER,
    prtInterpreterFeedAddressability    Integer32,
    prtInterpreterXFeedAddressability   Integer32,
    prtInterpreterDefaultCharSetIn      CodedCharSet,
    prtInterpreterDefaultCharSetOut     CodedCharSet,
    prtInterpreterTwoWay                INTEGER
}

prtInterpreterIndex OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A unique value for each PDL or control language for which
        there exists an interpreter or emulator in the printer.  The
        value is used to identify this interpreter. Although these
        values may change due to a major reconfiguration of the device
        (e.g. the addition of new interpreters to the printer), values
        are expected to remain stable across successive printer power
        cycles."
    ::= { prtInterpreterEntry 1 }

prtInterpreterLangFamily OBJECT-TYPE
    -- This value is a type 2 enumeration
    SYNTAX     INTEGER {
          other(1),
          langPCL(3),        -- PCL.  Starting with PCL version 5,
                             -- HP-GL/2 is included as part of the
                             -- PCL language.
                             -- PCL and HP-GL/2 are registered
                             -- trademarks of Hewlett-Packard Company.
          langHPGL(4),       -- Hewlett-Packard Graphics Language.
                             -- HP-GL is a registered trademark of
                             -- Hewlett-Packard Company.
          langPJL(5),        -- Peripheral Job Language. Appears in the
                             -- data stream between data intended for a
                             -- page description language.
                             -- Hewlett-Packard Co.
          langPS(6),         -- PostScript Language (tm)
                             -- Postscript - a trademark of Adobe
                             -- Systems Incorporated which may be
                             -- registered in certain jurisdictions
          langPSPrinter(42), -- The PostScript Language used for
                             -- control (with any PDLs)
                             -- Adobe Systems Incorporated
          langIPDS(7),       -- Intelligent Printer Data Stream
                             -- Bi-directional print data stream for
                             -- documents consisting of data objects
                             -- (text, image, graphics, bar codes),
                             -- resources (fonts, overlays) and page,
                             -- form and finishing instructions.
                             -- Facilitates system level device
                             -- control, document tracking and error
                             -- recovery throughout the print process.
                             -- Pennant Systems, IBM
          langPPDS(8),       -- IBM Personal Printer Data Stream.
                             -- Originally called IBM ASCII, the name
                             -- was changed to PPDS when the Laser
                             -- Printer was introduced in 1989.
                             -- Lexmark International, Inc.
          langEscapeP(9),
          langEpson(10),
          langDDIF(11),      -- Digital Document Interchange Format
                             -- Digital Equipment Corp., Maynard MA
          langInterpress(12),
          langISO6429(13),   -- ISO 6429.  Control functions for Coded
                             -- Character Sets (has ASCII control

                             -- characters, plus additional controls for
                             -- character imaging devices.)
                             -- ISO Standard, Geneva, Switzerland
          langLineData(14),  -- line-data:  Lines of data as separate
                             -- ASCII or EBCDIC records and containing
                             -- no control functions (no CR, LF, HT, FF,
                             -- etc.). For use with traditional line
                             -- printers.  May use CR and/or LF to
                             -- delimit lines, instead of records.  See
                             -- ISO 10175 Document Printing Application
                             -- (DPA)
                             -- ISO standard, Geneva, Switzerland
          langMODCA(15),     -- Mixed Object Document Content Architecture
                             -- Definitions that allow the composition,
                             -- interchange, and presentation of final
                             -- form documents as a collection of data
                             -- objects (text, image, graphics, bar
                             -- codes), resources (fonts, overlays) and
                             -- page, form and finishing instructions.
                             -- Pennant Systems, IBM
          langREGIS(16),     -- Remote Graphics Instruction Set,
                             -- Digital Equipment Corp., Maynard MA
          langSCS(17),       -- SNA Character String
                             -- Bi-directional print data stream for SNA
                             -- LU-1 mode of communications
                             -- IBM
          langSPDL(18),      -- ISO 10180 Standard Page Description
                             -- Language
                             -- ISO Standard
          langTEK4014(19),
          langPDS(20),
          langIGP(21),
          langCodeV(22),     -- Magnum Code-V, Image and printer control
                             -- language used to control impact/dot-
                             -- matrix printers.
                             -- QMS, Inc., Mobile AL
          langDSCDSE(23),    -- DSC-DSE:  Data Stream Compatible and
                             -- Emulation Bi-directional print data
                             -- stream for non-SNA (DSC) and SNA LU-3
                             -- 3270 controller (DSE) communications
                             -- IBM
          langWPS(24),       -- Windows Printing System, Resource based
                             -- command/data stream used by Microsoft At
                             -- Work Peripherals.
                             -- Developed by the Microsoft Corporation.
          langLN03(25),      -- Early DEC-PPL3, Digital Equipment Corp.
          langCCITT(26),
          langQUIC(27),      -- QUIC (Quality Information Code), Page
                             -- Description Language for laser printers.
                             -- Included graphics, printer control
                             -- capability and emulation of other well-
                             -- known printer .
                             -- QMS, Inc.
          langCPAP(28),      -- Common Printer Access Protocol
                             -- Digital Equipment Corp.
          langDecPPL(29),    -- Digital ANSI-Compliant Printing Protocol
                             -- (DEC-PPL)
                             -- Digital Equipment Corp.
          langSimpleText(30),-- simple-text:  character coded data,
                             -- including NUL, CR , LF, HT, and FF
                             -- control characters.  See ISO 10175
                             -- Document Printing Application (DPA)
                             -- ISO standard, Geneva, Switzerland
          langNPAP(31),      -- Network Printer Alliance Protocol
                             -- IEEE 1284.1
          langDOC(32),       -- Document Option Commands, Appears in the
                             -- data stream between data intended for a
                             -- page description .
                             -- QMS, Inc.
          langimPress(33),   -- imPRESS, Page description language
                             -- originally developed for the ImageServer
                             -- line of systems. A binary language
                             -- providing representations for text,
                             -- simple graphics (rules, lines, conic
                             -- sections), and some large forms (simple
                             -- bit-map and CCITT group 3/4 encoded).The
                             -- language was intended to be sent over an
                             -- 8-bit channel and supported early
                             -- document preparation languages (e.g. TeX
                             -- and TROFF).
                             -- QMS, Inc.
          langPinwriter(34), -- 24 wire dot matrix printer  for
                             -- USA, Europe, and Asia except Japan.
                             -- More widely used in Germany, and some
                             -- Asian countries than in US.
                             -- NEC
          langNPDL(35),      -- Page printer  for Japanese
                             -- market.
                             -- NEC
          langNEC201PL(36),  -- Serial printer language used in the
                             -- Japanese market.
                             -- NEC
          langAutomatic(37), -- Automatic PDL sensing.  Automatic
                             -- sensing of the interpreter language
                             -- family by the printer examining the
                             -- document content.  Which actual
                             -- interpreter language families are sensed
                             -- depends on the printer implementation.
          langPages(38),     -- Page printer Advanced Graphic Escape Set
                             -- IBM Japan
          langLIPS(39),      -- LBP Image Processing System
          langTIFF(40),      -- Tagged Image File Format (Aldus)
          langDiagnostic(41),-- A hex dump of the input to the
                             -- interpreter
          langCaPSL(43),     -- Canon Print Systems Language
          langEXCL(44),      -- Extended Command Language
                             -- Talaris Systems Inc.
          langLCDS(45),      -- Line Conditioned Data Stream
                             -- Xerox Corporation
          langXES(46)        -- Xerox Escape Sequences
                             -- Xerox Corporation
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The family name of a Page Description Language (PDL) or
        control language which this interpreter in the printer can
        interpret or emulate.  This type 2 list of enumerations
        requires review before additional entries are made."
    ::= { prtInterpreterEntry 2 }

prtInterpreterLangLevel OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..31))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The level of the language which this interpreter is
        interpreting or emulating.  This might contain a value like
        '5e' for an interpreter which is emulating level 5e of the PCL
        language.  It might contain '2' for an interpreter which is
        emulating level 2 of the PostScript language.  Similarly it
        might contain '2' for an interpreter which is emulating level
        2 of the HPGL language."
    ::= { prtInterpreterEntry 3 }

prtInterpreterLangVersion OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..31))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The date code or version of the language which this interpreter
        is interpreting or emulating."
    ::= { prtInterpreterEntry 4 }

prtInterpreterDescription OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..255))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "A string to identify this interpreter in the localization
        specified by prtGeneralCurrentLocalization as opposed to the
        language which is being interpreted.  It is anticipated that
        this string will allow manufacturers to unambiguously identify
        their interpreters."
    ::= { prtInterpreterEntry 5 }

prtInterpreterVersion OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..31))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The date code, version number, or other product specific
        information tied to this interpreter.  This value is
        associated with the interpreter, rather than with the version
        of the language which is being interpreted or emulated."
    ::= { prtInterpreterEntry 6 }

prtInterpreterDefaultOrientation OBJECT-TYPE
    -- This value is a type 1 enumeration
    SYNTAX     INTEGER {
                   other(1),
                   portrait(3),
                   landscape(4)
               }
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The current orientation default for this interpreter.  This
        value may be overridden for a particular job (e.g., by a
        command in the input data stream)."
    ::= { prtInterpreterEntry 7 }

prtInterpreterFeedAddressability OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The maximum interpreter addressability in the feed
        direction in 10000 prtMarkerAddressabilityUnit s (see
        prtMarkerAddressabilityFeedDir ) for this interpreter.
        The value (-1) means other and specifically indicates
        that the sub-unit places no restrictions on this parameter."
    ::= { prtInterpreterEntry 8 }

prtInterpreterXFeedAddressability OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The maximum interpreter addressability in the cross feed
        direction in 10000 prtMarkerAddressabilityUnit s (see
        prtMarkerAddressabilityXFeedDir) for this interpreter.
        The value (-1) means other and specifically indicates
        that the sub-unit places no restrictions on this
        parameter."
    ::= { prtInterpreterEntry 9 }

prtInterpreterDefaultCharSetIn OBJECT-TYPE
    SYNTAX     CodedCharSet
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The default coded character set for input octets
        encountered outside a context in which the Page
        Description Language established the interpretation
        of the octets.

        This value shall be (2) if there is no default."
    ::= { prtInterpreterEntry 10 }

prtInterpreterDefaultCharSetOut OBJECT-TYPE
    SYNTAX     CodedCharSet
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The default character set for data coming from this interpreter
        through the printer's output channel.


        This value shall be (2) if there is no default."
    ::= { prtInterpreterEntry 11 }

prtInterpreterTwoWay OBJECT-TYPE
    -- This value is a type 1 enumeration
    SYNTAX     INTEGER {
                   yes(3),
                   no(4)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "Indicates whether or not this interpreter returns information
        back to the host."
    ::= { prtInterpreterEntry 12 }

-- The Console Group
--
-- Many printers have a console on the printer, the operator console,
-- that is used to display and modify the state of the printer. The
-- console can be as simple as a few indicators and switches or as
-- complicated as full screen displays and keyboards. There can be
-- at most one such console.
--
-- Implementation of every object in this group is mandatory.

prtConsoleLocalization OBJECT-TYPE
    SYNTAX     Integer32 (1..65535)
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The value of the prtLocalizationIndex corresponding to
        the language, country, and character set to be used for the
        console.  This localization applies both to the actual display
        on the console as well as the encoding of these console
        objects in management operations."
    ::= { prtGeneralEntry 10 }

prtConsoleNumberOfDisplayLines OBJECT-TYPE
    SYNTAX     Integer32 (0..65535)
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The number of lines on the printer's physical
        display.  This value is 0 if there are no lines on the
        physical display or if there is no physical display"
    ::= { prtGeneralEntry 11 }

prtConsoleNumberOfDisplayChars OBJECT-TYPE
    SYNTAX     Integer32 (0..65535)
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The number of characters per line displayed on the physical
        display.  This value is 0 if there are no lines on the
        physical display or if there is no physical display"
    ::= { prtGeneralEntry 12 }

prtConsoleDisable OBJECT-TYPE
    SYNTAX     INTEGER {
                   enabled(3),
                   disabled(4)
               }
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "This object enables or disables manual input from the
        operators console."
    ::= { prtGeneralEntry 13 }

-- The Display Buffer Table

prtConsoleDisplayBuffer OBJECT IDENTIFIER ::= { printmib 16 }

prtConsoleDisplayBufferTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtConsoleDisplayBufferEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        ""
    ::= { prtConsoleDisplayBuffer 5 }

prtConsoleDisplayBufferEntry OBJECT-TYPE
    SYNTAX     PrtConsoleDisplayBufferEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "This table contains one entry for each physical line on
        the display.  Lines cannot be added or deleted.

        Entries may exist in the table for each device
        index who's device type is `printer'."
    INDEX  { hrDeviceIndex, prtConsoleDisplayBufferIndex }
    ::= { prtConsoleDisplayBufferTable 1 }

PrtConsoleDisplayBufferEntry ::= SEQUENCE {
    prtConsoleDisplayBufferIndex    Integer32,
    prtConsoleDisplayBufferText     DisplayString
}

prtConsoleDisplayBufferIndex OBJECT-TYPE
    SYNTAX     Integer32 (1..65535)
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A unique value for each console line in the printer.  The
        value is used to identify this console line. Although
        these values may change due to a major reconfiguration of
        the device (e.g. the addition of new console lines to the
        printer), values are expected to remain stable across
        successive printer power cycles."
    ::= { prtConsoleDisplayBufferEntry 1 }

prtConsoleDisplayBufferText OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..255))
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The content of a line in the logical display buffer of
        the operator's console of the printer.  When a write
        operation occurs, normally a critical message, to one of
        the LineText strings, the agent should make that line
        displayable if a physical display is present.  Writing
        a zero length string clears the line.  It is an
        implementation-specific matter as to whether the agent allows
        a line to be overwritten before it has been cleared.
        Printer generated strings shall be in the localization
        specified by ConsoleLocalization.  Management Application
        generated strings should be localized by the Management
        Application."
    ::= { prtConsoleDisplayBufferEntry 2 }

-- The Console Light Table

prtConsoleLights OBJECT IDENTIFIER ::= { printmib 17 }

prtConsoleLightTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtConsoleLightEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        ""
    ::= { prtConsoleLights 6 }

prtConsoleLightEntry OBJECT-TYPE
    SYNTAX     PrtConsoleLightEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "Entries may exist in the table for each device
        index who's device type is `printer'."
    INDEX  { hrDeviceIndex, prtConsoleLightIndex }
    ::= { prtConsoleLightTable 1 }

PrtConsoleLightEntry ::= SEQUENCE {
    prtConsoleLightIndex            Integer32,
    prtConsoleOnTime                Integer32,
    prtConsoleOffTime               Integer32,
    prtConsoleColor                 INTEGER,
    prtConsoleDescription           DisplayString
}

prtConsoleLightIndex OBJECT-TYPE
    SYNTAX     Integer32 (0..65535)
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "A unique value used by the printer to identify this light.
        Although these values may change due to a major
        reconfiguration of the device (e.g. the addition of new lights
        to the printer), values are expected to remain stable across
        successive printer power cycles."
    ::= { prtConsoleLightEntry 1 }

prtConsoleOnTime OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The on time in milliseconds of blinking of this light; 0
        indicates off always.  If both prtConsoleOnTime
        and prtConsoleOffTime are 0, then the light is
        always off."
    ::= { prtConsoleLightEntry 2 }

prtConsoleOffTime OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-write
    STATUS     current
    DESCRIPTION
        "The off time in milliseconds of blinking of this light; 0
        indicates on always.  If both prtConsoleOnTime
        and prtConsoleOffTime are 0, then the light is
        always off."
    ::= { prtConsoleLightEntry 3 }

prtConsoleColor OBJECT-TYPE
    -- This value is a type 2 enumeration
    SYNTAX     INTEGER {
                   other(1),
                   unknown(2),
                   white(3),
                   red(4),
                   green(5),
                   blue(6),
                   cyan(7),
                   magenta(8),
                   yellow(9)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The color of this light."
    ::= { prtConsoleLightEntry 4 }

prtConsoleDescription OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..255))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The vendor description or label of this light in the
        localization specified by prtConsoleLocalization."
    ::= { prtConsoleLightEntry 5 }


-- The Alerts Group
--
-- The prtAlertTable lists all the critical and non-critical alerts
-- currently active in the printer.  A critical alert is one that stops
-- the printer from printing immediately and printing can not continue
-- until the critical alert condition is eliminated.  Non-critical
-- alerts are those items that do not stop printing but may at some
-- future time.
-- The table contains information on the severity, component, detail
-- location within the component, alert code and description of each
-- critical alert that is currently active within the printer.  See
-- 2.2.13 for a more complete description of the alerts table and
-- its management.
--
-- Implementation of every object in this group is mandatory.

prtAlert OBJECT IDENTIFIER ::= { printmib 18 }

prtAlertTable OBJECT-TYPE
    SYNTAX     SEQUENCE OF PrtAlertEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        ""
    ::= { prtAlert 1 }

prtAlertEntry OBJECT-TYPE
    SYNTAX     PrtAlertEntry
    MAX-ACCESS not-accessible
    STATUS     current
    DESCRIPTION
        "Entries may exist in the table for each device
        index who's device type is `printer'."
    INDEX  { hrDeviceIndex, prtAlertIndex }
    ::= { prtAlertTable 1 }

PrtAlertEntry ::= SEQUENCE {
    prtAlertIndex               Integer32,
    prtAlertSeverityLevel       INTEGER,
    prtAlertTrainingLevel       INTEGER,
    prtAlertGroup               INTEGER,
    prtAlertGroupIndex          Integer32,
    prtAlertLocation            Integer32,
    prtAlertCode                INTEGER,
    prtAlertDescription         DisplayString,
    prtAlertTime                TimeTicks
}

prtAlertIndex OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The index value used to determine which alerts
        have been added or removed from the alert table.
        This is an incrementing integer starting from zero
        every time the printer is reset.  When the printer
        adds an alert to the table, that alert is assigned
        the next higher integer value from the last item
        entered into the table.  If the index value reaches
        its maximum value, the next item entered will cause
        the index value to roll over and start at zero
        again.  The first event placed in the alert table
        after a reset of the printer shall
        have an index value of 1.  NOTE: The management
        application will read the alert table when a trap
        or event notification occurs or at a periodic rate
        and then parse the table to determine if any new
        entries were added by comparing the last known index
        value with the current highest index value. The
        management application will then update its copy of
        the alert table.  When the printer discovers that
        an alert is no longer active, the printer shall
        remove the row for that alert from the table and
        shall reduce the number of rows in the table.  The
        printer may add or delete any number of rows from
        the table at any time.  The management station
        can detect when binary alerts have been deleted by
        requesting an attribute of each alert, and noting
        alerts as deleted when that retrieval is not possible."
    ::= { prtAlertEntry 1 }

prtAlertSeverityLevel OBJECT-TYPE
    -- This value is a type 1 enumeration
    SYNTAX     INTEGER {
                   other(1),
                   critical(3),
                   warning(4)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The level of severity of this alert table entry.  The printer
        determines the severity level assigned to each entry into the
        table."
    ::= { prtAlertEntry 2 }

prtAlertTrainingLevel OBJECT-TYPE
    -- This value is a type 2 enumeration
    SYNTAX     INTEGER {
                   other(1),
                   unknown(2),
                   untrained(3),
                   trained(4),
                   fieldService(5),
                   management(6)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The level of training required to handle this alert. The
        training level is an enumeration that is determined and
        assigned by the printer manufacturer based on the information
        or the training required to handle this alert.  The printer
        will break alerts into these different training levels.  It is
        the responsibility of the management application in the system
        to determine how a particular alert is handled and how and to
        whom that alert is routed.  The following are the four
        training levels of alerts:

               Field Service - Alerts that typically require advanced
                      training and technical knowledge of the printer
                      and its sub-units. An example of a technical
                      person would be a manufacture's Field Service
                      representative, or other person formally
                      trained by the manufacturer or similar
                      representative.
               Trained - Alerts that require an intermediate or moderate
                      level of knowledge of the printer and its
                      sub-units. A typical examples of alerts that
                      a trained operator can handle is replacing
                      toner cartridges.
               Untrained - Alerts that can be fixed without prior
                      training either because the action to correct
                      the alert is obvious or the printer can help the
                      untrained person fix the problem. A typical
                      example of such an alert is reloading paper
                      trays and emptying output bins on a low end
                      printer.
               Management - Alerts that have to do with overall
                      operation of and configuration of the printer.
                      Examples of management events are configuration
                      change of sub-units."
    ::= { prtAlertEntry 3 }

prtAlertGroup OBJECT-TYPE
    -- This value is a type 1 enumeration
    SYNTAX     INTEGER {
                   other(1),
                   hostResourcesMIBStorageTable(3),
                   hostResourcesMIBDeviceTable(4),
                   generalPrinter(5),
                   cover(6),
                   localization(7),
                   input(8),
                   output(9),
                   marker(10),
                   markerSupplies(11),
                   markerColorant(12),
                   mediaPath(13),
                   channel(14),
                   interpreter(15),
                   consoleDisplayBuffer(16),
                   consoleLights(17)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The type of sub-unit within the printer model that this alert
        is related.  Input, output, and markers are examples of
        printer model groups, i.e., examples of types of sub-units.

        Whereever possible, these enumerations match the
        sub-identifier that identifies the relevant table in the
        printmib."
    ::= { prtAlertEntry 4 }

prtAlertGroupIndex OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "An index of the row within the principle table in the
        group identified by prtAlertGroup that represents the
        sub-unit of the printer that caused this alert.  The
        combination of the Group and the GroupIndex defines
        exactly which printer sub-unit caused the alert.; for
        example, Input #3, Output #2, and Marker #1.

        Every object in this MIB is indexed with hrDeviceIndex and
        optionally, another index variable.  If this other index
        variable is present in the table that generated the alert, it
        will be used as the value for this object.  Otherwise, this
        value shall be -1."
    ::= { prtAlertEntry 5 }

prtAlertLocation OBJECT-TYPE
    SYNTAX     Integer32
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The sub-unit location that is defined by the printer
        manufacturer to further refine the location of this alert
        within the designated sub-unit.  The location is used in
        conjunction with the Group and GroupIndex values; for
        example, there is an alert in Input #2 at location number 7."
    ::= { prtAlertEntry 6 }

prtAlertCode OBJECT-TYPE
    -- This value is a type 2 enumeration
    SYNTAX     INTEGER {
                   other(1),
                   unknown(2),
                        -- codes common to serveral groups
                   coverOpen(3),
                   coverClosed(4),
                   interlockOpen(5),
                   interlockClosed(6),
                   configurationChange(7),
                   jam(8),
                        -- general Printer group
                   doorOpen(501),
                   doorClosed(502),
                   powerUp(503),
                   powerDown(504),
                        -- Input Group
                   inputMediaTrayMissing(801),
                   inputMediaSizeChange(802),
                   inputMediaWeightChange(803),
                   inputMediaTypeChange(804),
                   inputMediaColorChange(805),
                   inputMediaFormPartsChange(806),
                   inputMediaSupplyLow(807),
                   inputMediaSupplyEmpty(808),
                        -- Output Group
                   outputMediaTrayMissing(901),
                   outputMediaTrayAlmostFull(902),
                   outputMediaTrayFull(903),
                        -- Marker group
                   markerFuserUnderTemperature(1001),
                   markerFuserOverTemperature(1002),
                        -- Marker Supplies group
                   markerTonerEmpty(1101),
                   markerInkEmpty(1102),
                   markerPrintRibbonEmpty(1103),
                   markerTonerAlmostEmpty(1104),
                   markerInkAlmostEmpty(1105),
                   markerPrintRibbonAlmostEmpty(1106),
                   markerWasteTonerReceptacleAlmostFull(1107),
                   markerWasteInkReceptacleAlmostFull(1108),
                   markerWasteTonerReceptacleFull(1109),
                   markerWasteInkReceptacleFull(1110),
                   markerOpcLifeAlmostOver(1111),
                   markerOpcLifeOver(1112),
                   markerDeveloperAlmostEmpty(1113),
                   markerDeveloperEmpty(1114),
                        -- Media Path Device Group
                   mediaPathMediaTrayMissing(1301),
                   mediaPathMediaTrayAlmostFull(1302),
                   mediaPathMediaTrayFull(1303),
                        -- interpreter Group
                   interpreterMemoryIncrease(1501),
                   interpreterMemoryDecrease(1502),
                   interpreterCartridgeAdded(1503),
                   interpreterCartridgeDeleted(1504),
                   interpreterResourceAdded(1505),
                   interpreterResourceDeleted(1506),
                   interpreterResourceUnavailable(1507)
               }
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The code that describes the type of alert for this entry in
        the table.  There are different codes for each
        sub-unit type: for example, Media Supply Low and Media
        Supply Empty are Aler codes for the Input sub-unit."
    ::= { prtAlertEntry 7}

prtAlertDescription OBJECT-TYPE
    SYNTAX     DisplayString (SIZE(0..255))
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "A description of this alert entry in the localization
        specified by prtGeneralCurrentLocalization.  The description is
        provided by the printer to further elaborate on the enumerated
        alert or provide information in the case where the code is
        classified ask `other' or `unknown'.  The printer is required
        to return a description string but the string may be a null
        string."
    ::= { prtAlertEntry 8 }

printerV1Alert OBJECT-IDENTITY
    STATUS  current
    DESCRIPTION
        "The value of the enterprise-specific oid in a SNMPv1 trap sent
        signalling a critical event in the prtAlertTable."
    ::= { prtAlert 2 }

printerV2AlertPrefix OBJECT IDENTIFIER ::= { printerV1Alert 0 }

printerV2Alert NOTIFICATION-TYPE
    OBJECTS { prtAlertIndex, prtAlertSeverityLevel, prtAlertGroup,
              prtAlertGroupIndex, prtAlertLocation, prtAlertCode }
    STATUS  current
    DESCRIPTION
        "This trap is sent whenever a critical event is added to the
        prtAlertTable."
    ::= { printerV2AlertPrefix 1 }

-- Note that the SNMPv2 to SNMPv1 translation rules dictate that the
-- preceding structure will result in SNMPv1 traps of the following
-- form:
--
-- printerAlert TRAP-TYPE
--     ENTERPRISE printerV1Alert
--     VARIABLES { prtAlertIndex, prtAlertSeverityLevel, prtAlertGroup,
--                 prtAlertGroupIndex, prtAlertLocation, prtAlertCode }
--     DESCRIPTION
--        "This trap is sent whenever a critical event is added to the
--        prtAlertTable."
--     ::= 1



-- The Alert Time Group
--
-- This group is optional.  However, to claim conformance to this
-- group, it is necessary to implement every object in the group.

prtAlertTime OBJECT-TYPE
    SYNTAX     TimeTicks
    MAX-ACCESS read-only
    STATUS     current
    DESCRIPTION
        "The value of sysUpTime at the time that this alert was
        generated."
    ::= { prtAlertEntry 9 }


-- Conformance Information

prtMIBConformance OBJECT IDENTIFIER ::= { printmib 2 }

-- compliance statements
prtMIBCompliance MODULE-COMPLIANCE
    STATUS  current
    DESCRIPTION
        "The compliance statement for agents that implement the
        printer MIB."
    MODULE -- this module
    MANDATORY-GROUPS { prtGeneralGroup, prtInputGroup, prtOutputGroup,
                       prtMarkerGroup, prtMediaPathGroup,
                       prtChannelGroup, prtInterpreterGroup,
                       prtConsoleGroup, prtAlertTableGroup }

        OBJECT      prtGeneralReset
        SYNTAX      INTEGER {
                        notResetting(3),
                        resetToNVRAM(5)
                    }
        DESCRIPTION
            "It is conformant to implement just these two states in
            this object.  Any additional states are optional."

        OBJECT      prtConsoleOnTime
        MIN-ACCESS  read-only
        DESCRIPTION
            "It is conformant to implement this object as read-only."

        OBJECT      prtConsoleOffTime
        MIN-ACCESS  read-only
        DESCRIPTION
            "It is conformant to implement this object as read-only."

    -- the prtResponsiblePartyGroup, prtExtendedInputGroup,
    -- prtInputMediaGroup, prtExtendedOutputGroup,
    -- prtOutputDimensionsGroup, prtOutputFeaturesGroup,
    -- prtMarkerSuppliesGroup, prtMarkerColorantGroup,
    -- and the prtAlertTimeGroup are completely optional.
    ::= { prtMIBConformance 1 }

prtMIBGroups      OBJECT IDENTIFIER ::= { prtMIBConformance 2 }

prtGeneralGroup OBJECT-GROUP
    OBJECTS { prtGeneralConfigChanges, prtGeneralCurrentLocalization,
              prtGeneralReset, prtCoverDescription, prtCoverStatus,
              prtLocalizationLanguage, prtLocalizationCountry,
              prtLocalizationCharacterSet, prtStorageRefIndex,
              prtDeviceRefIndex }
    STATUS  current
    DESCRIPTION
        "The general printer group."
    ::= { prtMIBGroups 1 }

prtResponsiblePartyGroup OBJECT-GROUP
    OBJECTS { prtGeneralCurrentOperator, prtGeneralServicePerson }
    STATUS  current
    DESCRIPTION
        "The responsible party group contains contact information for
        humans responsible for the printer."
    ::= { prtMIBGroups 2 }

prtInputGroup OBJECT-GROUP
    OBJECTS { prtInputDefaultIndex, prtInputType, prtInputDimUnit,
              prtInputMediaDimFeedDirDeclared,
              prtInputMediaDimXFeedDirDeclared,
              prtInputMediaDimFeedDirChosen,
              prtInputMediaDimXFeedDirChosen, prtInputCapacityUnit,
              prtInputMaxCapacity, prtInputCurrentLevel,
              prtInputStatus, prtInputMediaName }
    STATUS  current
    DESCRIPTION
        "The input group."
    ::= { prtMIBGroups 3 }

prtExtendedInputGroup OBJECT-GROUP
    OBJECTS { prtInputName, prtInputVendorName, prtInputModel,
              prtInputVersion, prtInputSerialNumber,
              prtInputDescription, prtInputSecurity }
    STATUS  current
    DESCRIPTION
        "The extended input group."
    ::= { prtMIBGroups 4 }

prtInputMediaGroup OBJECT-GROUP
    OBJECTS { prtInputMediaWeight, prtInputMediaType,
              prtInputMediaColor, prtInputMediaFormParts }
    STATUS  current
    DESCRIPTION
        "The input media group."
    ::= { prtMIBGroups 5 }

prtOutputGroup OBJECT-GROUP
    OBJECTS { prtOutputDefaultIndex, prtOutputType,
              prtOutputCapacityUnit, prtOutputMaxCapacity,
              prtOutputRemainingCapacity,  prtOutputStatus }
    STATUS  current
    DESCRIPTION
        "The output group."
    ::= { prtMIBGroups 6 }

prtExtendedOutputGroup OBJECT-GROUP
    OBJECTS { prtOutputName, prtOutputVendorName, prtOutputModel,
              prtOutputVersion, prtOutputSerialNumber,
              prtOutputDescription, prtOutputSecurity }
    STATUS  current
    DESCRIPTION
        "The extended output group."
    ::= { prtMIBGroups 7 }

prtOutputDimensionsGroup OBJECT-GROUP
    OBJECTS { prtOutputDimUnit, prtOutputMaxDimFeedDir,
              prtOutputMaxDimXFeedDir, prtOutputMinDimFeedDir,
              prtOutputMinDimXFeedDir }
    STATUS  current
    DESCRIPTION
        "The output dimensions group"
    ::= { prtMIBGroups 8 }

prtOutputFeaturesGroup OBJECT-GROUP
    OBJECTS { prtOutputStackingOrder,
              prtOutputPageDeliveryOrientation, prtOutputBursting,
              prtOutputDecollating, prtOutputPageCollated,
              prtOutputOffsetStacking }
    STATUS  current
    DESCRIPTION
        "The output features group."
    ::= { prtMIBGroups 9 }

prtMarkerGroup OBJECT-GROUP
    OBJECTS { prtMarkerDefaultIndex, prtMarkerMarkTech,
              prtMarkerCounterUnit, prtMarkerLifeCount,
              prtMarkerPowerOnCount, prtMarkerProcessColorants,
              prtMarkerSpotColorants, prtMarkerAddressabilityUnit,
              prtMarkerAddressabilityFeedDir,
              prtMarkerAddressabilityXFeedDir, prtMarkerNorthMargin,
              prtMarkerSouthMargin, prtMarkerWestMargin,
              prtMarkerEastMargin, prtMarkerStatus }
    STATUS  current
    DESCRIPTION
        "The marker group."
    ::= { prtMIBGroups 10 }

prtMarkerSuppliesGroup OBJECT-GROUP
    OBJECTS { prtMarkerSuppliesMarkerIndex,
              prtMarkerSuppliesColorantIndex, prtMarkerSuppliesClass,
              prtMarkerSuppliesType, prtMarkerSuppliesDescription,
              prtMarkerSuppliesSupplyUnit,
              prtMarkerSuppliesMaxCapacity, prtMarkerSuppliesLevel }
    STATUS  current
    DESCRIPTION
        "The marker supplies group."
    ::= { prtMIBGroups 11 }

prtMarkerColorantGroup OBJECT-GROUP
    OBJECTS { prtMarkerColorantMarkerIndex, prtMarkerColorantRole,
              prtMarkerColorantValue, prtMarkerColorantTonality }
    STATUS  current
    DESCRIPTION
        "The marker colorant group."
    ::= { prtMIBGroups 12 }

prtMediaPathGroup OBJECT-GROUP
    OBJECTS { prtMediaPathDefaultIndex, prtMediaPathMaxSpeedPrintUnit,
              prtMediaPathMediaSizeUnit, prtMediaPathMaxSpeed,
              prtMediaPathMaxMediaFeedDir,
              prtMediaPathMaxMediaXFeedDir,
              prtMediaPathMinMediaFeedDir,
              prtMediaPathMinMediaXFeedDir, prtMediaPathType,
              prtMediaPathDescription, prtMediaPathStatus}
    STATUS  current
    DESCRIPTION
        "The media path group."
    ::= { prtMIBGroups 13 }

prtChannelGroup OBJECT-GROUP
    OBJECTS { prtChannelType, prtChannelProtocolVersion,
              prtChannelCurrentJobCntlLangIndex,
              prtChannelDefaultPageDescLangIndex, prtChannelState,
              prtChannelIfIndex, prtChannelStatus }
    STATUS  current
    DESCRIPTION
        "The channel group."
    ::= { prtMIBGroups 14 }

prtInterpreterGroup OBJECT-GROUP
    OBJECTS { prtInterpreterLangFamily, prtInterpreterLangLevel,
              prtInterpreterLangVersion, prtInterpreterDescription,
              prtInterpreterVersion, prtInterpreterDefaultOrientation,
              prtInterpreterFeedAddressability,
              prtInterpreterXFeedAddressability,
              prtInterpreterDefaultCharSetIn,
              prtInterpreterDefaultCharSetOut, prtInterpreterTwoWay }
    STATUS  current
    DESCRIPTION
        "The interpreter group."
    ::= { prtMIBGroups 15 }

prtConsoleGroup OBJECT-GROUP
    OBJECTS { prtConsoleLocalization, prtConsoleNumberOfDisplayLines,
              prtConsoleNumberOfDisplayChars, prtConsoleDisable,
              prtConsoleDisplayBufferText, prtConsoleOnTime,
              prtConsoleOffTime, prtConsoleColor,
              prtConsoleDescription }
    STATUS  current
    DESCRIPTION
        "The console group."
    ::= { prtMIBGroups 16 }

prtAlertTableGroup OBJECT-GROUP
    OBJECTS { prtAlertSeverityLevel, prtAlertTrainingLevel,
              prtAlertGroup, prtAlertGroupIndex, prtAlertLocation,
              prtAlertCode, prtAlertDescription }
    STATUS  current
    DESCRIPTION
        "The alert table group."
    ::= { prtMIBGroups 17 }

prtAlertTimeGroup OBJECT-GROUP
    OBJECTS { prtAlertTime }
    STATUS  current
    DESCRIPTION
        "The alert time group."
    ::= { prtMIBGroups 18 }


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\mofs\snmpv1\rfcs\placefil.txt ===
rfc1213.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1229.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1230.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1231.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1238.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1253.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1269.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1271.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1285.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1304.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1315.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1316.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1317.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1318.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1354.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1381.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1382.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1389.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1398.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1406.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1407.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1414.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1461.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1471.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1472.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1473.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1474.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1493.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1512.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1513.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1514.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1515.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1516.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1525.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1559.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1593.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1742.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1757.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
rfc1792.mof	WMI_PSDK\SNMP\MOFS\SNMPv1\RFCs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\mibs\snmpv2\rfcs\rfc1850.txt ===
OSPF-MIB DEFINITIONS ::= BEGIN

    IMPORTS
            MODULE-IDENTITY, OBJECT-TYPE, Counter32, Gauge32,
            Integer32, IpAddress
                FROM SNMPv2-SMI
            TEXTUAL-CONVENTION, TruthValue, RowStatus
                FROM SNMPv2-TC
            MODULE-COMPLIANCE, OBJECT-GROUP          FROM SNMPv2-CONF
            mib-2                                    FROM RFC1213-MIB;

--  This MIB module uses the extended OBJECT-TYPE macro as
--  defined in [9].

ospf MODULE-IDENTITY
        LAST-UPDATED "9501201225Z" -- Fri Jan 20 12:25:50 PST 1995
        ORGANIZATION "IETF OSPF Working Group"
        CONTACT-INFO
       "       Fred Baker
       Postal: Cisco Systems
               519 Lado Drive
               Santa Barbara, California 93111
       Tel:    +1 805 681 0115
       E-Mail: fred@cisco.com

               Rob Coltun
       Postal: RainbowBridge Communications
       Tel:    (301) 340-9416
       E-Mail: rcoltun@rainbow-bridge.com"
    DESCRIPTION
       "The MIB module to describe the OSPF Version 2
       Protocol"
    ::= { mib-2 14 }

--  The Area ID, in OSPF, has the same format as an IP Address,
--  but has the function of defining a summarization point for
--  Link State Advertisements

AreaID ::= TEXTUAL-CONVENTION
    STATUS      current
    DESCRIPTION
       "An OSPF Area Identifier."
    SYNTAX      IpAddress


--  The Router ID, in OSPF, has the same format as an IP Address,
--  but identifies the router independent of its IP Address.

RouterID ::= TEXTUAL-CONVENTION
    STATUS      current
    DESCRIPTION
       "A OSPF Router Identifier."
    SYNTAX      IpAddress


--  The OSPF Metric is defined as an unsigned value in the range

Metric ::= TEXTUAL-CONVENTION
    STATUS      current
    DESCRIPTION
       "The OSPF Internal Metric."
    SYNTAX      Integer32 (0..'FFFF'h)

BigMetric ::= TEXTUAL-CONVENTION
    STATUS      current
    DESCRIPTION
       "The OSPF External Metric."
    SYNTAX      Integer32 (0..'FFFFFF'h)

--  Status Values

Status ::= TEXTUAL-CONVENTION
    STATUS      current
    DESCRIPTION
       "The status of an interface: 'enabled' indicates that
       it is willing to communicate with other OSPF Routers,
       while 'disabled' indicates that it is not."
    SYNTAX      INTEGER { enabled (1), disabled (2) }

--  Time Durations measured in seconds

PositiveInteger ::= TEXTUAL-CONVENTION
    STATUS      current
    DESCRIPTION
       "A positive integer. Values in excess are precluded as
       unnecessary and prone to interoperability issues."
    SYNTAX      Integer32 (0..'7FFFFFFF'h)

HelloRange ::= TEXTUAL-CONVENTION
    STATUS      current
    DESCRIPTION
       "The range of intervals on which hello messages are
       exchanged."
    SYNTAX      Integer32 (1..'FFFF'h)

UpToMaxAge ::= TEXTUAL-CONVENTION
    STATUS      current
    DESCRIPTION
       "The values that one might find or configure for
       variables bounded by the maximum age of an LSA."
    SYNTAX      Integer32 (0..3600)


--  The range of ifIndex

InterfaceIndex ::= TEXTUAL-CONVENTION
    STATUS      current
    DESCRIPTION
       "The range of ifIndex."
    SYNTAX      Integer32


--  Potential Priorities for the Designated Router Election

DesignatedRouterPriority ::= TEXTUAL-CONVENTION
    STATUS      current
    DESCRIPTION
       "The values defined for the priority of a system for
       becoming the designated router."
    SYNTAX      Integer32 (0..'FF'h)

TOSType ::= TEXTUAL-CONVENTION
    STATUS      current
    DESCRIPTION
       "Type of Service is defined as a mapping to the IP Type of
       Service Flags as defined in the IP Forwarding Table MIB

       +-----+-----+-----+-----+-----+-----+-----+-----+
       |                 |                       |     |
       |   PRECEDENCE    |    TYPE OF SERVICE    |  0  |
       |                 |                       |     |
       +-----+-----+-----+-----+-----+-----+-----+-----+

                IP TOS                IP TOS
           Field     Policy      Field     Policy

           Contents    Code      Contents    Code
           0 0 0 0  ==>   0      0 0 0 1  ==>   2
           0 0 1 0  ==>   4      0 0 1 1  ==>   6
           0 1 0 0  ==>   8      0 1 0 1  ==>  10
           0 1 1 0  ==>  12      0 1 1 1  ==>  14
           1 0 0 0  ==>  16      1 0 0 1  ==>  18
           1 0 1 0  ==>  20      1 0 1 1  ==>  22
           1 1 0 0  ==>  24      1 1 0 1  ==>  26
           1 1 1 0  ==>  28      1 1 1 1  ==>  30

       The remaining values are left for future definition."
    SYNTAX      Integer32 (0..30)


--  OSPF General Variables

--      These parameters apply globally to the Router's
--      OSPF Process.

ospfGeneralGroup OBJECT IDENTIFIER ::= { ospf 1 }


    ospfRouterId OBJECT-TYPE
        SYNTAX   RouterID
        MAX-ACCESS   read-write
        STATUS   current
        DESCRIPTION
           "A  32-bit  integer  uniquely  identifying  the
           router in the Autonomous System.

           By  convention,  to  ensure  uniqueness,   this
           should  default  to  the  value  of  one of the
           router's IP interface addresses."
       REFERENCE
          "OSPF Version 2, C.1 Global parameters"
      ::= { ospfGeneralGroup 1 }


    ospfAdminStat OBJECT-TYPE
        SYNTAX   Status
        MAX-ACCESS   read-write
        STATUS   current
        DESCRIPTION
           "The  administrative  status  of  OSPF  in  the
           router.   The  value 'enabled' denotes that the
           OSPF Process is active on at least  one  inter-
           face;  'disabled'  disables  it  on  all inter-
           faces."
       ::= { ospfGeneralGroup 2 }

    ospfVersionNumber OBJECT-TYPE
        SYNTAX   INTEGER    { version2 (2) }
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The current version number of the OSPF  proto-
           col is 2."
       REFERENCE
          "OSPF Version 2, Title"
      ::= { ospfGeneralGroup 3 }


    ospfAreaBdrRtrStatus OBJECT-TYPE
        SYNTAX   TruthValue
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "A flag to note whether this router is an  area
           border router."
       REFERENCE
          "OSPF Version 2, Section 3 Splitting the AS into
          Areas"
      ::= { ospfGeneralGroup 4 }


    ospfASBdrRtrStatus OBJECT-TYPE
        SYNTAX   TruthValue
        MAX-ACCESS   read-write
        STATUS   current
        DESCRIPTION
           "A flag to note whether this router is  config-
           ured as an Autonomous System border router."
       REFERENCE
          "OSPF Version 2, Section 3.3  Classification  of
          routers"
      ::= { ospfGeneralGroup 5 }

    ospfExternLsaCount OBJECT-TYPE
        SYNTAX   Gauge32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The number of external (LS type 5)  link-state
           advertisements in the link-state database."
       REFERENCE
          "OSPF Version 2, Appendix A.4.5 AS external link
          advertisements"
      ::= { ospfGeneralGroup 6 }


    ospfExternLsaCksumSum OBJECT-TYPE
        SYNTAX   Integer32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The 32-bit unsigned sum of the LS checksums of
           the  external  link-state  advertisements  con-
           tained in the link-state  database.   This  sum
           can  be  used  to determine if there has been a
           change in a router's link state  database,  and
           to  compare  the  link-state  database  of  two
           routers."
       ::= { ospfGeneralGroup 7 }


    ospfTOSSupport OBJECT-TYPE
        SYNTAX   TruthValue
        MAX-ACCESS   read-write
        STATUS   current
        DESCRIPTION
           "The router's support for type-of-service rout-
           ing."
       REFERENCE
          "OSPF Version 2,  Appendix  F.1.2  Optional  TOS
          support"
      ::= { ospfGeneralGroup 8 }

    ospfOriginateNewLsas OBJECT-TYPE
        SYNTAX   Counter32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The number of  new  link-state  advertisements
           that  have been originated.  This number is in-
           cremented each time the router originates a new
           LSA."
       ::= { ospfGeneralGroup 9 }


    ospfRxNewLsas OBJECT-TYPE
        SYNTAX   Counter32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The number of  link-state  advertisements  re-
           ceived  determined  to  be  new instantiations.
           This number does not include  newer  instantia-
           tions  of self-originated link-state advertise-
           ments."
       ::= { ospfGeneralGroup 10 }

    ospfExtLsdbLimit OBJECT-TYPE
        SYNTAX   Integer32 (-1..'7FFFFFFF'h)
        MAX-ACCESS   read-write
        STATUS   current
        DESCRIPTION
           "The  maximum   number   of   non-default   AS-
           external-LSAs entries that can be stored in the
           link-state database.  If the value is -1,  then
           there is no limit.

           When the number of non-default AS-external-LSAs
           in   a  router's  link-state  database  reaches
           ospfExtLsdbLimit, the router  enters  Overflow-
           State.   The   router  never  holds  more  than
           ospfExtLsdbLimit  non-default  AS-external-LSAs
           in  its  database. OspfExtLsdbLimit MUST be set
           identically in all routers attached to the OSPF
           backbone  and/or  any regular OSPF area. (i.e.,
           OSPF stub areas and NSSAs are excluded)."
       DEFVAL { -1 }
       ::= { ospfGeneralGroup 11 }

    ospfMulticastExtensions OBJECT-TYPE
        SYNTAX   Integer32
        MAX-ACCESS   read-write
        STATUS   current
        DESCRIPTION
           "A Bit Mask indicating whether  the  router  is
           forwarding  IP  multicast  (Class  D) datagrams
           based on the algorithms defined in  the  Multi-
           cast Extensions to OSPF.

           Bit 0, if set, indicates that  the  router  can
           forward  IP multicast datagrams in the router's
           directly attached areas (called intra-area mul-
           ticast routing).

           Bit 1, if set, indicates that  the  router  can
           forward  IP  multicast  datagrams  between OSPF
           areas (called inter-area multicast routing).

           Bit 2, if set, indicates that  the  router  can
           forward  IP  multicast  datagrams between Auto-
           nomous Systems (called inter-AS multicast rout-
           ing).

           Only certain combinations of bit  settings  are
           allowed,  namely: 0 (no multicast forwarding is
           enabled), 1 (intra-area multicasting  only),  3
           (intra-area  and  inter-area  multicasting),  5
           (intra-area and inter-AS  multicasting)  and  7
           (multicasting  everywhere). By default, no mul-
           ticast forwarding is enabled."
       DEFVAL { 0 }
       ::= { ospfGeneralGroup 12 }

    ospfExitOverflowInterval OBJECT-TYPE
        SYNTAX   PositiveInteger
        MAX-ACCESS   read-write
        STATUS   current
        DESCRIPTION
           "The number of  seconds  that,  after  entering
           OverflowState,  a  router will attempt to leave
           OverflowState. This allows the router to  again
           originate  non-default  AS-external-LSAs.  When
           set to 0, the router will not  leave  Overflow-
           State until restarted."
       DEFVAL { 0 }
       ::= { ospfGeneralGroup 13 }


    ospfDemandExtensions OBJECT-TYPE
        SYNTAX   TruthValue
        MAX-ACCESS   read-write
        STATUS   current
        DESCRIPTION
           "The router's support for demand routing."
       REFERENCE
          "OSPF Version 2, Appendix on Demand Routing"
      ::= { ospfGeneralGroup 14 }


--      The OSPF Area Data Structure contains information
--      regarding the various areas. The interfaces and
--      virtual links are configured as part of these areas.
--      Area 0.0.0.0, by definition, is the Backbone Area


    ospfAreaTable OBJECT-TYPE
        SYNTAX   SEQUENCE OF OspfAreaEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "Information describing the configured  parame-
           ters  and cumulative statistics of the router's
           attached areas."
       REFERENCE
          "OSPF Version 2, Section 6  The Area Data Struc-
          ture"
      ::= { ospf 2 }


    ospfAreaEntry OBJECT-TYPE
        SYNTAX   OspfAreaEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "Information describing the configured  parame-
           ters  and  cumulative  statistics of one of the
           router's attached areas."
       INDEX { ospfAreaId }
       ::= { ospfAreaTable 1 }

OspfAreaEntry ::=
    SEQUENCE {
        ospfAreaId
            AreaID,
        ospfAuthType
            Integer32,
        ospfImportAsExtern
            INTEGER,
        ospfSpfRuns
            Counter32,
        ospfAreaBdrRtrCount
            Gauge32,
        ospfAsBdrRtrCount
            Gauge32,
        ospfAreaLsaCount
            Gauge32,
        ospfAreaLsaCksumSum
            Integer32,
        ospfAreaSummary
            INTEGER,
        ospfAreaStatus
            RowStatus
              }

    ospfAreaId OBJECT-TYPE
        SYNTAX   AreaID
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "A 32-bit integer uniquely identifying an area.
           Area ID 0.0.0.0 is used for the OSPF backbone."
       REFERENCE
          "OSPF Version 2, Appendix C.2 Area parameters"
      ::= { ospfAreaEntry 1 }


    ospfAuthType OBJECT-TYPE
        SYNTAX   Integer32
                    -- none (0),
                    -- simplePassword (1)
                    -- md5 (2)
                    -- reserved for specification by IANA (> 2)
        MAX-ACCESS   read-create
        STATUS   obsolete
        DESCRIPTION
           "The authentication type specified for an area.
           Additional authentication types may be assigned
           locally on a per Area basis."
       REFERENCE
          "OSPF Version 2, Appendix E Authentication"
      DEFVAL { 0 }        -- no authentication, by default
      ::= { ospfAreaEntry 2 }

    ospfImportAsExtern OBJECT-TYPE
        SYNTAX   INTEGER    {
                    importExternal (1),
                    importNoExternal (2),
                    importNssa (3)
                  }
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The area's support for importing  AS  external
           link- state advertisements."
       REFERENCE
          "OSPF Version 2, Appendix C.2 Area parameters"
      DEFVAL { importExternal }
      ::= { ospfAreaEntry 3 }


    ospfSpfRuns OBJECT-TYPE
        SYNTAX   Counter32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The number of times that the intra-area  route
           table  has  been  calculated  using this area's
           link-state database.  This  is  typically  done
           using Dijkstra's algorithm."
       ::= { ospfAreaEntry 4 }


    ospfAreaBdrRtrCount OBJECT-TYPE
        SYNTAX   Gauge32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The total number of area border routers reach-
           able within this area.  This is initially zero,
           and is calculated in each SPF Pass."
       ::= { ospfAreaEntry 5 }

    ospfAsBdrRtrCount OBJECT-TYPE
        SYNTAX   Gauge32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The total number of Autonomous  System  border
           routers  reachable  within  this area.  This is
           initially zero, and is calculated in  each  SPF
           Pass."
       ::= { ospfAreaEntry 6 }


    ospfAreaLsaCount OBJECT-TYPE
        SYNTAX   Gauge32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The total number of link-state  advertisements
           in  this  area's link-state database, excluding
           AS External LSA's."
       ::= { ospfAreaEntry 7 }


    ospfAreaLsaCksumSum OBJECT-TYPE
        SYNTAX   Integer32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The 32-bit unsigned sum of the link-state  ad-
           vertisements'  LS  checksums  contained in this
           area's link-state database.  This sum  excludes
           external (LS type 5) link-state advertisements.
           The sum can be used to determine if  there  has
           been  a  change  in a router's link state data-
           base, and to compare the link-state database of
           two routers."
       DEFVAL   { 0 }
       ::= { ospfAreaEntry 8 }

    ospfAreaSummary OBJECT-TYPE
        SYNTAX   INTEGER    {
                    noAreaSummary (1),
                    sendAreaSummary (2)
                  }
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The variable ospfAreaSummary controls the  im-
           port  of  summary LSAs into stub areas.  It has
           no effect on other areas.

           If it is noAreaSummary, the router will neither
           originate  nor  propagate summary LSAs into the
           stub area.  It will rely entirely  on  its  de-
           fault route.

           If it is sendAreaSummary, the router will  both
           summarize and propagate summary LSAs."
       DEFVAL   { noAreaSummary }
       ::= { ospfAreaEntry 9 }


    ospfAreaStatus OBJECT-TYPE
        SYNTAX   RowStatus
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "This variable displays the status of  the  en-
           try.  Setting it to 'invalid' has the effect of
           rendering it inoperative.  The internal  effect
           (row removal) is implementation dependent."
       ::= { ospfAreaEntry 10 }


--  OSPF Area Default Metric Table

--      The OSPF Area Default Metric Table describes the metrics
--      that a default Area Border Router will advertise into a
--      Stub area.


    ospfStubAreaTable OBJECT-TYPE
        SYNTAX   SEQUENCE OF OspfStubAreaEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "The set of metrics that will be advertised  by
           a default Area Border Router into a stub area."
       REFERENCE
          "OSPF Version 2, Appendix C.2, Area Parameters"
      ::= { ospf 3 }


    ospfStubAreaEntry OBJECT-TYPE
        SYNTAX   OspfStubAreaEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "The metric for a given Type  of  Service  that
           will  be  advertised  by  a default Area Border
           Router into a stub area."
       REFERENCE
          "OSPF Version 2, Appendix C.2, Area Parameters"
      INDEX { ospfStubAreaId, ospfStubTOS }
      ::= { ospfStubAreaTable 1 }

OspfStubAreaEntry ::=
    SEQUENCE {
        ospfStubAreaId
            AreaID,
        ospfStubTOS
            TOSType,
        ospfStubMetric
            BigMetric,
        ospfStubStatus
            RowStatus,
        ospfStubMetricType
            INTEGER
              }

    ospfStubAreaId OBJECT-TYPE
        SYNTAX   AreaID
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The 32 bit identifier for the Stub  Area.   On
           creation,  this  can  be  derived  from the in-
           stance."
       ::= { ospfStubAreaEntry 1 }

    ospfStubTOS OBJECT-TYPE
        SYNTAX   TOSType
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The  Type  of  Service  associated  with   the
           metric.   On creation, this can be derived from
           the instance."
       ::= { ospfStubAreaEntry 2 }


    ospfStubMetric OBJECT-TYPE
        SYNTAX   BigMetric
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The metric value applied at the indicated type
           of  service.  By default, this equals the least
           metric at the type of service among the  inter-
           faces to other areas."
       ::= { ospfStubAreaEntry 3 }


    ospfStubStatus OBJECT-TYPE
        SYNTAX   RowStatus
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "This variable displays the status of  the  en-
           try.  Setting it to 'invalid' has the effect of
           rendering it inoperative.  The internal  effect
           (row removal) is implementation dependent."
       ::= { ospfStubAreaEntry 4 }

    ospfStubMetricType OBJECT-TYPE
        SYNTAX   INTEGER    {
                    ospfMetric (1),                -- OSPF Metric
                    comparableCost (2),        -- external type 1
                    nonComparable  (3)        -- external type 2
                  }
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "This variable displays the type of metric  ad-
           vertised as a default route."
       DEFVAL   { ospfMetric }
       ::= { ospfStubAreaEntry 5 }

--  OSPF Link State Database

--      The Link State Database contains the Link State
--      Advertisements from throughout the areas that the
--      device is attached to.


    ospfLsdbTable OBJECT-TYPE
        SYNTAX   SEQUENCE OF OspfLsdbEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "The OSPF Process's Link State Database."
       REFERENCE
          "OSPF Version 2, Section 12  Link  State  Adver-
          tisements"
      ::= { ospf 4 }


    ospfLsdbEntry OBJECT-TYPE
        SYNTAX   OspfLsdbEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "A single Link State Advertisement."
       INDEX { ospfLsdbAreaId, ospfLsdbType,
               ospfLsdbLsid, ospfLsdbRouterId }
       ::= { ospfLsdbTable 1 }

OspfLsdbEntry ::=
    SEQUENCE {
        ospfLsdbAreaId
            AreaID,
        ospfLsdbType
            INTEGER,
        ospfLsdbLsid
            IpAddress,
        ospfLsdbRouterId
            RouterID,
        ospfLsdbSequence
            Integer32,
        ospfLsdbAge
            Integer32,
        ospfLsdbChecksum
            Integer32,
        ospfLsdbAdvertisement
            OCTET STRING
              }

    ospfLsdbAreaId OBJECT-TYPE
        SYNTAX   AreaID
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The 32 bit identifier of the Area  from  which
           the LSA was received."
       REFERENCE
          "OSPF Version 2, Appendix C.2 Area parameters"
      ::= { ospfLsdbEntry 1 }

-- External Link State Advertisements are permitted
-- for backward compatibility, but should be displayed in
-- the ospfExtLsdbTable rather than here.

    ospfLsdbType OBJECT-TYPE
        SYNTAX   INTEGER    {
                    routerLink (1),
                    networkLink (2),
                    summaryLink (3),
                    asSummaryLink (4),
                    asExternalLink (5), -- but see ospfExtLsdbTable
                    multicastLink (6),
                    nssaExternalLink (7)
                  }
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The type  of  the  link  state  advertisement.
           Each  link state type has a separate advertise-
           ment format."
       REFERENCE
          "OSPF Version 2, Appendix A.4.1 The  Link  State
          Advertisement header"
      ::= { ospfLsdbEntry 2 }

    ospfLsdbLsid OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The Link State ID is an LS Type Specific field
           containing either a Router ID or an IP Address;
           it identifies the piece of the  routing  domain
           that is being described by the advertisement."
       REFERENCE
          "OSPF Version 2, Section 12.1.4 Link State ID"
      ::= { ospfLsdbEntry 3 }

    ospfLsdbRouterId OBJECT-TYPE
        SYNTAX   RouterID
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The 32 bit number that uniquely identifies the
           originating router in the Autonomous System."
       REFERENCE
          "OSPF Version 2, Appendix C.1 Global parameters"
      ::= { ospfLsdbEntry 4 }

--  Note that the OSPF Sequence Number is a 32 bit signed
--  integer.  It starts with the value '80000001'h,
--  or -'7FFFFFFF'h, and increments until '7FFFFFFF'h
--  Thus, a typical sequence number will be very negative.

    ospfLsdbSequence OBJECT-TYPE
        SYNTAX   Integer32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The sequence number field is a  signed  32-bit
           integer.   It  is used to detect old and dupli-
           cate link state advertisements.  The  space  of
           sequence  numbers  is  linearly  ordered.   The
           larger the sequence number the more recent  the
           advertisement."
       REFERENCE
          "OSPF Version  2,  Section  12.1.6  LS  sequence
          number"
      ::= { ospfLsdbEntry 5 }


    ospfLsdbAge OBJECT-TYPE
        SYNTAX   Integer32    -- Should be 0..MaxAge
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "This field is the age of the link state adver-
           tisement in seconds."
       REFERENCE
          "OSPF Version 2, Section 12.1.1 LS age"
      ::= { ospfLsdbEntry 6 }

    ospfLsdbChecksum OBJECT-TYPE
        SYNTAX   Integer32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "This field is the  checksum  of  the  complete
           contents  of  the  advertisement, excepting the
           age field.  The age field is excepted  so  that
           an   advertisement's  age  can  be  incremented
           without updating the  checksum.   The  checksum
           used  is  the same that is used for ISO connec-
           tionless datagrams; it is commonly referred  to
           as the Fletcher checksum."
       REFERENCE
          "OSPF Version 2, Section 12.1.7 LS checksum"
      ::= { ospfLsdbEntry 7 }


    ospfLsdbAdvertisement OBJECT-TYPE
        SYNTAX   OCTET STRING (SIZE (1..65535))
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The entire Link State Advertisement, including
           its header."
       REFERENCE
          "OSPF Version 2, Section 12  Link  State  Adver-
          tisements"
      ::= { ospfLsdbEntry 8 }


--  Address Range Table

--      The Address Range Table acts as an adjunct to the Area
--      Table; It describes those Address Range Summaries that
--      are configured to be propagated from an Area to reduce
--      the amount of information about it which is known beyond
--      its borders.

    ospfAreaRangeTable OBJECT-TYPE
        SYNTAX   SEQUENCE OF OspfAreaRangeEntry
        MAX-ACCESS   not-accessible
        STATUS   obsolete
        DESCRIPTION
           "A range if IP addresses  specified  by  an  IP
           address/IP  network  mask  pair.   For example,
           class B address range of X.X.X.X with a network
           mask  of  255.255.0.0 includes all IP addresses
           from X.X.0.0 to X.X.255.255"
       REFERENCE
          "OSPF Version 2, Appendix C.2  Area parameters"
      ::= { ospf 5 }

    ospfAreaRangeEntry OBJECT-TYPE
        SYNTAX   OspfAreaRangeEntry
        MAX-ACCESS   not-accessible
        STATUS   obsolete
        DESCRIPTION
           "A range if IP addresses  specified  by  an  IP
           address/IP  network  mask  pair.   For example,
           class B address range of X.X.X.X with a network
           mask  of  255.255.0.0 includes all IP addresses
           from X.X.0.0 to X.X.255.255"
       REFERENCE
          "OSPF Version 2, Appendix C.2  Area parameters"
      INDEX { ospfAreaRangeAreaId, ospfAreaRangeNet }
      ::= { ospfAreaRangeTable 1 }

OspfAreaRangeEntry ::=
    SEQUENCE {
        ospfAreaRangeAreaId
            AreaID,
        ospfAreaRangeNet
            IpAddress,
        ospfAreaRangeMask
            IpAddress,
        ospfAreaRangeStatus
            RowStatus,
        ospfAreaRangeEffect
            INTEGER
              }

    ospfAreaRangeAreaId OBJECT-TYPE
        SYNTAX   AreaID
        MAX-ACCESS   read-only
        STATUS   obsolete
        DESCRIPTION
           "The Area the Address  Range  is  to  be  found
           within."
       REFERENCE
          "OSPF Version 2, Appendix C.2 Area parameters"
      ::= { ospfAreaRangeEntry 1 }


    ospfAreaRangeNet OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   obsolete
        DESCRIPTION
           "The IP Address of the Net or Subnet  indicated
           by the range."
       REFERENCE
          "OSPF Version 2, Appendix C.2 Area parameters"
      ::= { ospfAreaRangeEntry 2 }


    ospfAreaRangeMask OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-create
        STATUS   obsolete
        DESCRIPTION
           "The Subnet Mask that pertains to  the  Net  or
           Subnet."
       REFERENCE
          "OSPF Version 2, Appendix C.2 Area parameters"
      ::= { ospfAreaRangeEntry 3 }

    ospfAreaRangeStatus OBJECT-TYPE
        SYNTAX   RowStatus
        MAX-ACCESS   read-create
        STATUS   obsolete
        DESCRIPTION
           "This variable displays the status of  the  en-
           try.  Setting it to 'invalid' has the effect of
           rendering it inoperative.  The internal  effect
           (row removal) is implementation dependent."
       ::= { ospfAreaRangeEntry 4 }


    ospfAreaRangeEffect OBJECT-TYPE
        SYNTAX   INTEGER    {
                    advertiseMatching (1),
                    doNotAdvertiseMatching (2)
                  }
        MAX-ACCESS   read-create
        STATUS   obsolete
        DESCRIPTION
           "Subnets subsumed by ranges either trigger  the
           advertisement  of the indicated summary (adver-
           tiseMatching), or result in  the  subnet's  not
           being advertised at all outside the area."
       DEFVAL   { advertiseMatching }
       ::= { ospfAreaRangeEntry 5 }



--  OSPF Host Table

--      The Host/Metric Table indicates what hosts are directly
--      attached to the Router, and what metrics and types of
--      service should be advertised for them.

    ospfHostTable OBJECT-TYPE
        SYNTAX   SEQUENCE OF OspfHostEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "The list of Hosts, and their metrics, that the
           router will advertise as host routes."
       REFERENCE
          "OSPF Version 2, Appendix C.6  Host route param-
          eters"
      ::= { ospf 6 }


    ospfHostEntry OBJECT-TYPE
        SYNTAX   OspfHostEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "A metric to be advertised, for a given type of
           service, when a given host is reachable."
       INDEX { ospfHostIpAddress, ospfHostTOS }
       ::= { ospfHostTable 1 }

OspfHostEntry ::=
    SEQUENCE {
        ospfHostIpAddress
            IpAddress,
        ospfHostTOS
            TOSType,
        ospfHostMetric
            Metric,
        ospfHostStatus
            RowStatus,
        ospfHostAreaID
            AreaID
              }

    ospfHostIpAddress OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The IP Address of the Host."
       REFERENCE
          "OSPF Version 2, Appendix C.6 Host route parame-
          ters"
      ::= { ospfHostEntry 1 }


    ospfHostTOS OBJECT-TYPE
        SYNTAX   TOSType
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The Type of Service of the route being config-
           ured."
       REFERENCE
          "OSPF Version 2, Appendix C.6 Host route parame-
          ters"
      ::= { ospfHostEntry 2 }


    ospfHostMetric OBJECT-TYPE
        SYNTAX   Metric
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The Metric to be advertised."
       REFERENCE
          "OSPF Version 2, Appendix C.6 Host route parame-
          ters"
      ::= { ospfHostEntry 3 }

    ospfHostStatus OBJECT-TYPE
        SYNTAX   RowStatus
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "This variable displays the status of  the  en-
           try.  Setting it to 'invalid' has the effect of
           rendering it inoperative.  The internal  effect
           (row removal) is implementation dependent."
       ::= { ospfHostEntry 4 }


    ospfHostAreaID OBJECT-TYPE
        SYNTAX   AreaID
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The Area the Host Entry is to be found within.
           By  default, the area that a subsuming OSPF in-
           terface is in, or 0.0.0.0"
       REFERENCE
          "OSPF Version 2, Appendix C.2 Area parameters"
      ::= { ospfHostEntry 5 }


--  OSPF Interface Table

--      The OSPF Interface Table augments the ipAddrTable
--             with OSPF specific information.

    ospfIfTable OBJECT-TYPE
        SYNTAX   SEQUENCE OF OspfIfEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "The OSPF Interface Table describes the  inter-
           faces from the viewpoint of OSPF."
       REFERENCE
          "OSPF Version 2, Appendix C.3  Router  interface
          parameters"
      ::= { ospf 7 }


    ospfIfEntry OBJECT-TYPE
        SYNTAX   OspfIfEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "The OSPF Interface Entry describes one  inter-
           face from the viewpoint of OSPF."
       INDEX { ospfIfIpAddress, ospfAddressLessIf }
       ::= { ospfIfTable 1 }

OspfIfEntry ::=
    SEQUENCE {
        ospfIfIpAddress
            IpAddress,
        ospfAddressLessIf
            Integer32,
        ospfIfAreaId
            AreaID,
        ospfIfType
            INTEGER,
        ospfIfAdminStat
            Status,
        ospfIfRtrPriority
            DesignatedRouterPriority,
        ospfIfTransitDelay
            UpToMaxAge,
        ospfIfRetransInterval
            UpToMaxAge,
        ospfIfHelloInterval
            HelloRange,
        ospfIfRtrDeadInterval
            PositiveInteger,
        ospfIfPollInterval
            PositiveInteger,
        ospfIfState
            INTEGER,
        ospfIfDesignatedRouter
            IpAddress,
        ospfIfBackupDesignatedRouter
            IpAddress,
        ospfIfEvents
            Counter32,
        ospfIfAuthType
            INTEGER,
        ospfIfAuthKey
            OCTET STRING,
        ospfIfStatus
            RowStatus,
        ospfIfMulticastForwarding
            INTEGER,
        ospfIfDemand
            TruthValue
              }

    ospfIfIpAddress OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The IP address of this OSPF interface."
       ::= { ospfIfEntry 1 }

    ospfAddressLessIf OBJECT-TYPE
        SYNTAX   Integer32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "For the purpose of easing  the  instancing  of
           addressed   and  addressless  interfaces;  This
           variable takes the value 0 on  interfaces  with
           IP  Addresses,  and  the corresponding value of
           ifIndex for interfaces having no IP Address."
       ::= { ospfIfEntry 2 }

    ospfIfAreaId OBJECT-TYPE
        SYNTAX   AreaID
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "A 32-bit integer uniquely identifying the area
           to  which  the  interface  connects.   Area  ID
           0.0.0.0 is used for the OSPF backbone."
       DEFVAL   { '00000000'H }    -- 0.0.0.0
       ::= { ospfIfEntry 3 }

    ospfIfType OBJECT-TYPE
        SYNTAX   INTEGER    {
                    broadcast (1),
                    nbma (2),
                    pointToPoint (3),
                    pointToMultipoint (5)
                  }
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The OSPF interface type.

           By way of a default, this field may be intuited
           from the corresponding value of ifType.  Broad-
           cast LANs, such as  Ethernet  and  IEEE  802.5,
           take  the  value  'broadcast', X.25 and similar
           technologies take the value 'nbma',  and  links
           that  are  definitively point to point take the
           value 'pointToPoint'."
       ::= { ospfIfEntry 4 }


    ospfIfAdminStat OBJECT-TYPE
        SYNTAX   Status
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The OSPF  interface's  administrative  status.
           The  value formed on the interface, and the in-
           terface will be advertised as an internal route
           to  some  area.   The  value 'disabled' denotes
           that the interface is external to OSPF."
       DEFVAL { enabled }
       ::= { ospfIfEntry 5 }

    ospfIfRtrPriority OBJECT-TYPE
        SYNTAX   DesignatedRouterPriority
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The  priority  of  this  interface.   Used  in
           multi-access  networks,  this  field is used in
           the designated router election algorithm.   The
           value 0 signifies that the router is not eligi-
           ble to become the  designated  router  on  this
           particular  network.   In the event of a tie in
           this value, routers will use their Router ID as
           a tie breaker."
       DEFVAL { 1 }
       ::= { ospfIfEntry 6 }


    ospfIfTransitDelay OBJECT-TYPE
        SYNTAX   UpToMaxAge
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The estimated number of seconds  it  takes  to
           transmit  a  link state update packet over this
           interface."
       DEFVAL { 1 }
       ::= { ospfIfEntry 7 }


    ospfIfRetransInterval OBJECT-TYPE
        SYNTAX   UpToMaxAge
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The number of seconds between  link-state  ad-
           vertisement  retransmissions,  for  adjacencies
           belonging to this  interface.   This  value  is
           also used when retransmitting database descrip-
           tion and link-state request packets."
       DEFVAL { 5 }
       ::= { ospfIfEntry 8 }


    ospfIfHelloInterval OBJECT-TYPE
        SYNTAX   HelloRange
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The length of time, in  seconds,  between  the
           Hello  packets that the router sends on the in-
           terface.  This value must be the same  for  all
           routers attached to a common network."
       DEFVAL { 10 }
       ::= { ospfIfEntry 9 }


    ospfIfRtrDeadInterval OBJECT-TYPE
        SYNTAX   PositiveInteger
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The number of seconds that  a  router's  Hello
           packets  have  not been seen before it's neigh-
           bors declare the router down.  This  should  be
           some  multiple  of  the  Hello  interval.  This
           value must be the same for all routers attached
           to a common network."
       DEFVAL { 40 }
       ::= { ospfIfEntry 10 }


    ospfIfPollInterval OBJECT-TYPE
        SYNTAX   PositiveInteger
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The larger time interval, in seconds,  between
           the  Hello  packets  sent  to  an inactive non-
           broadcast multi- access neighbor."
       DEFVAL { 120 }
       ::= { ospfIfEntry 11 }


    ospfIfState OBJECT-TYPE
        SYNTAX   INTEGER    {
                    down (1),
                    loopback (2),
                    waiting (3),
                    pointToPoint (4),
                    designatedRouter (5),
                    backupDesignatedRouter (6),
                    otherDesignatedRouter (7)
                  }
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The OSPF Interface State."
       DEFVAL { down }
       ::= { ospfIfEntry 12 }


    ospfIfDesignatedRouter OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The IP Address of the Designated Router."
       DEFVAL   { '00000000'H }    -- 0.0.0.0
       ::= { ospfIfEntry 13 }


    ospfIfBackupDesignatedRouter OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The  IP  Address  of  the  Backup   Designated
           Router."
       DEFVAL   { '00000000'H }    -- 0.0.0.0
       ::= { ospfIfEntry 14 }

    ospfIfEvents OBJECT-TYPE
        SYNTAX   Counter32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The number of times this  OSPF  interface  has
           changed its state, or an error has occurred."
       ::= { ospfIfEntry 15 }


    ospfIfAuthKey OBJECT-TYPE
        SYNTAX   OCTET STRING (SIZE (0..256))
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The Authentication Key.  If the Area's Author-
           ization  Type  is  simplePassword,  and the key
           length is shorter than 8 octets, the agent will
           left adjust and zero fill to 8 octets.

           Note that unauthenticated  interfaces  need  no
           authentication key, and simple password authen-
           tication cannot use a key of more  than  8  oc-
           tets.  Larger keys are useful only with authen-
           tication mechanisms not specified in this docu-
           ment.

           When read, ospfIfAuthKey always returns an  Oc-
           tet String of length zero."
       REFERENCE
          "OSPF Version 2, Section 9  The  Interface  Data
          Structure"
      DEFVAL   { '0000000000000000'H }    -- 0.0.0.0.0.0.0.0
      ::= { ospfIfEntry 16 }

    ospfIfStatus OBJECT-TYPE
        SYNTAX   RowStatus
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "This variable displays the status of  the  en-
           try.  Setting it to 'invalid' has the effect of
           rendering it inoperative.  The internal  effect
           (row removal) is implementation dependent."
       ::= { ospfIfEntry 17 }


    ospfIfMulticastForwarding OBJECT-TYPE
        SYNTAX   INTEGER    {
                            blocked (1),        -- no multicast forwarding
                            multicast (2),        -- using multicast address
                            unicast (3)        -- to each OSPF neighbor
                  }
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The way multicasts should  forwarded  on  this
           interface;  not  forwarded,  forwarded  as data
           link multicasts, or forwarded as data link uni-
           casts.   Data link multicasting is not meaning-
           ful on point to point and NBMA interfaces,  and
           setting ospfMulticastForwarding to 0 effective-
           ly disables all multicast forwarding."
       DEFVAL { blocked }
       ::= { ospfIfEntry 18 }


    ospfIfDemand OBJECT-TYPE
        SYNTAX   TruthValue
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "Indicates whether Demand OSPF procedures (hel-
           lo supression to FULL neighbors and setting the
           DoNotAge flag on proogated LSAs) should be per-
           formed on this interface."
       DEFVAL { false }
       ::= { ospfIfEntry 19 }


    ospfIfAuthType OBJECT-TYPE
        SYNTAX   INTEGER (0..255)
                    -- none (0),
                    -- simplePassword (1)
                    -- md5 (2)
                    -- reserved for specification by IANA (> 2)
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The authentication type specified for  an  in-
           terface.   Additional  authentication types may
           be assigned locally."
       REFERENCE
          "OSPF Version 2, Appendix E Authentication"
      DEFVAL { 0 }        -- no authentication, by default
      ::= { ospfIfEntry 20 }


--  OSPF Interface Metric Table

--      The Metric Table describes the metrics to be advertised
--      for a specified interface at the various types of service.
--      As such, this table is an adjunct of the OSPF Interface
--      Table.

-- Types of service, as defined by RFC 791, have the ability
-- to request low delay, high bandwidth, or reliable linkage.

-- For the purposes of this specification, the measure of
-- bandwidth

--      Metric = 10^8 / ifSpeed

-- is the default value.  For multiple link interfaces, note
-- that ifSpeed is the sum of the individual link speeds.
-- This yields a number having the following typical values:

--      Network Type/bit rate   Metric

--      >= 100 MBPS                 1
--      Ethernet/802.3             10
--      E1                         48
--      T1 (ESF)                   65
--       64 KBPS                 1562
--       56 KBPS                 1785
--       19.2 KBPS               5208
--        9.6 KBPS              10416

-- Routes that are not specified use the default (TOS 0) metric

    ospfIfMetricTable OBJECT-TYPE
        SYNTAX   SEQUENCE OF OspfIfMetricEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "The TOS metrics for  a  non-virtual  interface
           identified by the interface index."
       REFERENCE
          "OSPF Version 2, Appendix C.3  Router  interface
          parameters"
      ::= { ospf 8 }

    ospfIfMetricEntry OBJECT-TYPE
        SYNTAX   OspfIfMetricEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "A particular TOS metric for a non-virtual  in-
           terface identified by the interface index."
       REFERENCE
          "OSPF Version 2, Appendix C.3  Router  interface
          parameters"
      INDEX { ospfIfMetricIpAddress,
  ospfIfMetricAddressLessIf,
  ospfIfMetricTOS }
      ::= { ospfIfMetricTable 1 }

OspfIfMetricEntry ::=
    SEQUENCE {
        ospfIfMetricIpAddress
            IpAddress,
        ospfIfMetricAddressLessIf
            Integer32,
        ospfIfMetricTOS
            TOSType,
        ospfIfMetricValue
            Metric,
        ospfIfMetricStatus
            RowStatus
              }

    ospfIfMetricIpAddress OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The IP address of this OSPF interface.  On row
           creation,  this  can  be  derived  from the in-
           stance."
       ::= { ospfIfMetricEntry 1 }

    ospfIfMetricAddressLessIf OBJECT-TYPE
        SYNTAX   Integer32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "For the purpose of easing  the  instancing  of
           addressed   and  addressless  interfaces;  This
           variable takes the value 0 on  interfaces  with
           IP  Addresses, and the value of ifIndex for in-
           terfaces having no IP Address.   On  row  crea-
           tion, this can be derived from the instance."
       ::= { ospfIfMetricEntry 2 }


    ospfIfMetricTOS OBJECT-TYPE
        SYNTAX   TOSType
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The type of service metric  being  referenced.
           On  row  creation, this can be derived from the
           instance."
       ::= { ospfIfMetricEntry 3 }


    ospfIfMetricValue OBJECT-TYPE
        SYNTAX   Metric
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The metric of using this type  of  service  on
           this interface.  The default value of the TOS 0
           Metric is 10^8 / ifSpeed."
       ::= { ospfIfMetricEntry 4 }

    ospfIfMetricStatus OBJECT-TYPE
        SYNTAX   RowStatus
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "This variable displays the status of  the  en-
           try.  Setting it to 'invalid' has the effect of
           rendering it inoperative.  The internal  effect
           (row removal) is implementation dependent."
       ::= { ospfIfMetricEntry 5 }


--  OSPF Virtual Interface Table

--      The Virtual Interface Table describes the virtual
--      links that the OSPF Process is configured to
--      carry on.

    ospfVirtIfTable OBJECT-TYPE
        SYNTAX   SEQUENCE OF OspfVirtIfEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "Information about this router's virtual inter-
           faces."
       REFERENCE
          "OSPF Version  2,  Appendix  C.4   Virtual  link
          parameters"
      ::= { ospf 9 }


    ospfVirtIfEntry OBJECT-TYPE
        SYNTAX   OspfVirtIfEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "Information about a single Virtual Interface."
       INDEX { ospfVirtIfAreaId, ospfVirtIfNeighbor }
       ::= { ospfVirtIfTable 1 }

OspfVirtIfEntry ::=
    SEQUENCE {
        ospfVirtIfAreaId
            AreaID,
        ospfVirtIfNeighbor
            RouterID,
        ospfVirtIfTransitDelay
            UpToMaxAge,
        ospfVirtIfRetransInterval
            UpToMaxAge,
        ospfVirtIfHelloInterval
            HelloRange,
        ospfVirtIfRtrDeadInterval
            PositiveInteger,
        ospfVirtIfState
            INTEGER,
        ospfVirtIfEvents
            Counter32,
        ospfVirtIfAuthType
            INTEGER,
        ospfVirtIfAuthKey
            OCTET STRING,
        ospfVirtIfStatus
            RowStatus
              }

    ospfVirtIfAreaId OBJECT-TYPE
        SYNTAX   AreaID
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The  Transit  Area  that  the   Virtual   Link
           traverses.  By definition, this is not 0.0.0.0"
       ::= { ospfVirtIfEntry 1 }


    ospfVirtIfNeighbor OBJECT-TYPE
        SYNTAX   RouterID
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The Router ID of the Virtual Neighbor."
       ::= { ospfVirtIfEntry 2 }


    ospfVirtIfTransitDelay OBJECT-TYPE
        SYNTAX   UpToMaxAge
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The estimated number of seconds  it  takes  to
           transmit  a link- state update packet over this
           interface."
       DEFVAL { 1 }
       ::= { ospfVirtIfEntry 3 }

    ospfVirtIfRetransInterval OBJECT-TYPE
        SYNTAX   UpToMaxAge
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The number of seconds between  link-state  ad-
           vertisement  retransmissions,  for  adjacencies
           belonging to this  interface.   This  value  is
           also used when retransmitting database descrip-
           tion  and  link-state  request  packets.   This
           value  should  be well over the expected round-
           trip time."
       DEFVAL { 5 }
       ::= { ospfVirtIfEntry 4 }


    ospfVirtIfHelloInterval OBJECT-TYPE
        SYNTAX   HelloRange
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The length of time, in  seconds,  between  the
           Hello  packets that the router sends on the in-
           terface.  This value must be the same  for  the
           virtual neighbor."
       DEFVAL { 10 }
       ::= { ospfVirtIfEntry 5 }


    ospfVirtIfRtrDeadInterval OBJECT-TYPE
        SYNTAX   PositiveInteger
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The number of seconds that  a  router's  Hello
           packets  have  not been seen before it's neigh-
           bors declare the router down.  This  should  be
           some  multiple  of  the  Hello  interval.  This
           value must be the same for the  virtual  neigh-
           bor."
       DEFVAL { 60 }
       ::= { ospfVirtIfEntry 6 }


    ospfVirtIfState OBJECT-TYPE
        SYNTAX   INTEGER    {
                    down (1),            -- these use the same encoding
                    pointToPoint (4)     -- as the ospfIfTable
                  }
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "OSPF virtual interface states."
       DEFVAL   { down }
       ::= { ospfVirtIfEntry 7 }


    ospfVirtIfEvents OBJECT-TYPE
        SYNTAX   Counter32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The number of state changes or error events on
           this Virtual Link"
       ::= { ospfVirtIfEntry 8 }


    ospfVirtIfAuthKey OBJECT-TYPE
        SYNTAX   OCTET STRING (SIZE(0..256))
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "If Authentication Type is simplePassword,  the
           device  will left adjust and zero fill to 8 oc-
           tets.

           Note that unauthenticated  interfaces  need  no
           authentication key, and simple password authen-
           tication cannot use a key of more  than  8  oc-
           tets.  Larger keys are useful only with authen-
           tication mechanisms not specified in this docu-
           ment.

           When  read,  ospfVifAuthKey  always  returns  a
           string of length zero."
       REFERENCE
          "OSPF Version 2, Section 9  The  Interface  Data
          Structure"
      DEFVAL   { '0000000000000000'H }    -- 0.0.0.0.0.0.0.0
      ::= { ospfVirtIfEntry 9 }


    ospfVirtIfStatus OBJECT-TYPE
        SYNTAX   RowStatus
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "This variable displays the status of  the  en-
           try.  Setting it to 'invalid' has the effect of
           rendering it inoperative.  The internal  effect
           (row removal) is implementation dependent."
       ::= { ospfVirtIfEntry 10 }


    ospfVirtIfAuthType OBJECT-TYPE
        SYNTAX   INTEGER (0..255)
                    -- none (0),
                    -- simplePassword (1)
                    -- md5 (2)
                    -- reserved for specification by IANA (> 2)
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The authentication type specified for a virtu-
           al  interface.  Additional authentication types
           may be assigned locally."
       REFERENCE
          "OSPF Version 2, Appendix E Authentication"
      DEFVAL { 0 }        -- no authentication, by default
      ::= { ospfVirtIfEntry 11 }


--  OSPF Neighbor Table

--      The OSPF Neighbor Table describes all neighbors in
--      the locality of the subject router.

    ospfNbrTable OBJECT-TYPE
        SYNTAX   SEQUENCE OF OspfNbrEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "A table of non-virtual neighbor information."
       REFERENCE
          "OSPF Version 2, Section 10  The  Neighbor  Data
          Structure"
      ::= { ospf 10 }


    ospfNbrEntry OBJECT-TYPE
        SYNTAX   OspfNbrEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "The information regarding a single neighbor."
       REFERENCE
          "OSPF Version 2, Section 10  The  Neighbor  Data
          Structure"
      INDEX { ospfNbrIpAddr, ospfNbrAddressLessIndex }
      ::= { ospfNbrTable 1 }

OspfNbrEntry ::=
    SEQUENCE {
        ospfNbrIpAddr
            IpAddress,
        ospfNbrAddressLessIndex
            InterfaceIndex,
        ospfNbrRtrId
            RouterID,
        ospfNbrOptions
            Integer32,
        ospfNbrPriority
            DesignatedRouterPriority,
        ospfNbrState
            INTEGER,
        ospfNbrEvents
            Counter32,
        ospfNbrLsRetransQLen
            Gauge32,
        ospfNbmaNbrStatus
            RowStatus,
        ospfNbmaNbrPermanence
            INTEGER,
        ospfNbrHelloSuppressed
            TruthValue
              }

    ospfNbrIpAddr OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The IP address this neighbor is using  in  its
           IP  Source  Address.  Note that, on addressless
           links, this will not be 0.0.0.0,  but  the  ad-
           dress of another of the neighbor's interfaces."
       ::= { ospfNbrEntry 1 }


    ospfNbrAddressLessIndex OBJECT-TYPE
        SYNTAX   InterfaceIndex
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "On an interface having an  IP  Address,  zero.
           On  addressless  interfaces,  the corresponding
           value of ifIndex in the Internet Standard  MIB.
           On  row  creation, this can be derived from the
           instance."
       ::= { ospfNbrEntry 2 }


    ospfNbrRtrId OBJECT-TYPE
        SYNTAX   RouterID
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "A 32-bit integer (represented as a type  IpAd-
           dress)  uniquely  identifying  the  neighboring
           router in the Autonomous System."
       DEFVAL   { '00000000'H }    -- 0.0.0.0
       ::= { ospfNbrEntry 3 }


    ospfNbrOptions OBJECT-TYPE
        SYNTAX   Integer32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "A Bit Mask corresponding to the neighbor's op-
           tions field.

           Bit 0, if set, indicates that the  system  will
           operate  on  Type of Service metrics other than
           TOS 0.  If zero, the neighbor will  ignore  all
           metrics except the TOS 0 metric.

           Bit 1, if set, indicates  that  the  associated
           area  accepts and operates on external informa-
           tion; if zero, it is a stub area.

           Bit 2, if set, indicates that the system is ca-
           pable  of routing IP Multicast datagrams; i.e.,
           that it implements the Multicast Extensions  to
           OSPF.

           Bit 3, if set, indicates  that  the  associated
           area  is  an  NSSA.  These areas are capable of
           carrying type 7 external advertisements,  which
           are  translated into type 5 external advertise-
           ments at NSSA borders."
       REFERENCE
          "OSPF Version 2, Section 12.1.2 Options"
      DEFVAL { 0 }
      ::= { ospfNbrEntry 4 }


    ospfNbrPriority OBJECT-TYPE
        SYNTAX   DesignatedRouterPriority
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "The priority of this neighbor in the designat-
           ed router election algorithm.  The value 0 sig-
           nifies that the neighbor is not eligible to be-
           come  the  designated router on this particular
           network."
       DEFVAL { 1 }
       ::= { ospfNbrEntry 5 }


    ospfNbrState OBJECT-TYPE
        SYNTAX   INTEGER    {
                    down (1),
                    attempt (2),
                    init (3),
                    twoWay (4),
                    exchangeStart (5),
                    exchange (6),
                    loading (7),
                    full (8)
                  }
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The State of the relationship with this Neigh-
           bor."
       REFERENCE
          "OSPF Version 2, Section 10.1 Neighbor States"
      DEFVAL   { down }
      ::= { ospfNbrEntry 6 }


    ospfNbrEvents OBJECT-TYPE
        SYNTAX   Counter32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The number of times this neighbor relationship
           has changed state, or an error has occurred."
       ::= { ospfNbrEntry 7 }


    ospfNbrLsRetransQLen OBJECT-TYPE
        SYNTAX   Gauge32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The  current  length  of  the   retransmission
           queue."
       ::= { ospfNbrEntry 8 }


    ospfNbmaNbrStatus OBJECT-TYPE
        SYNTAX   RowStatus
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "This variable displays the status of  the  en-
           try.  Setting it to 'invalid' has the effect of
           rendering it inoperative.  The internal  effect
           (row removal) is implementation dependent."
       ::= { ospfNbrEntry 9 }


    ospfNbmaNbrPermanence OBJECT-TYPE
        SYNTAX   INTEGER    {
                    dynamic (1),        -- learned through protocol
                    permanent (2)       -- configured address
                  }
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "This variable displays the status of  the  en-
           try.   'dynamic'  and  'permanent' refer to how
           the neighbor became known."
       DEFVAL { permanent }
       ::= { ospfNbrEntry 10 }


    ospfNbrHelloSuppressed OBJECT-TYPE
        SYNTAX   TruthValue
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "Indicates whether Hellos are being  suppressed
           to the neighbor"
       ::= { ospfNbrEntry 11 }


--  OSPF Virtual Neighbor Table

--      This table describes all virtual neighbors.
--      Since Virtual Links are configured in the
--      virtual interface table, this table is read-only.

    ospfVirtNbrTable OBJECT-TYPE
        SYNTAX   SEQUENCE OF OspfVirtNbrEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "A table of virtual neighbor information."
       REFERENCE
          "OSPF Version 2, Section 15  Virtual Links"
      ::= { ospf 11 }


    ospfVirtNbrEntry OBJECT-TYPE
        SYNTAX   OspfVirtNbrEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "Virtual neighbor information."
       INDEX { ospfVirtNbrArea, ospfVirtNbrRtrId }
       ::= { ospfVirtNbrTable 1 }

OspfVirtNbrEntry ::=
    SEQUENCE {
        ospfVirtNbrArea
            AreaID,
        ospfVirtNbrRtrId
            RouterID,
        ospfVirtNbrIpAddr
            IpAddress,
        ospfVirtNbrOptions
            Integer32,
        ospfVirtNbrState
            INTEGER,
        ospfVirtNbrEvents
            Counter32,
        ospfVirtNbrLsRetransQLen
            Gauge32,
        ospfVirtNbrHelloSuppressed
                TruthValue
              }

    ospfVirtNbrArea OBJECT-TYPE
        SYNTAX   AreaID
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The Transit Area Identifier."
       ::= { ospfVirtNbrEntry 1 }


    ospfVirtNbrRtrId OBJECT-TYPE
        SYNTAX   RouterID
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "A  32-bit  integer  uniquely  identifying  the
           neighboring router in the Autonomous System."
       ::= { ospfVirtNbrEntry 2 }


    ospfVirtNbrIpAddr OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The IP address this Virtual  Neighbor  is  us-
           ing."
       ::= { ospfVirtNbrEntry 3 }


    ospfVirtNbrOptions OBJECT-TYPE
        SYNTAX   Integer32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "A Bit Mask corresponding to the neighbor's op-
           tions field.

           Bit 1, if set, indicates that the  system  will
           operate  on  Type of Service metrics other than
           TOS 0.  If zero, the neighbor will  ignore  all
           metrics except the TOS 0 metric.

           Bit 2, if set, indicates  that  the  system  is
           Network  Multicast  capable; ie, that it imple-
           ments OSPF Multicast Routing."
       ::= { ospfVirtNbrEntry 4 }

    ospfVirtNbrState OBJECT-TYPE
        SYNTAX   INTEGER    {
                    down (1),
                    attempt (2),
                    init (3),
                    twoWay (4),
                    exchangeStart (5),
                    exchange (6),
                    loading (7),
                    full (8)
                  }
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The state of the  Virtual  Neighbor  Relation-
           ship."
       ::= { ospfVirtNbrEntry 5 }


    ospfVirtNbrEvents OBJECT-TYPE
        SYNTAX   Counter32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The number of  times  this  virtual  link  has
           changed its state, or an error has occurred."
       ::= { ospfVirtNbrEntry 6 }


    ospfVirtNbrLsRetransQLen OBJECT-TYPE
        SYNTAX   Gauge32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The  current  length  of  the   retransmission
           queue."
       ::= { ospfVirtNbrEntry 7 }


    ospfVirtNbrHelloSuppressed OBJECT-TYPE
        SYNTAX   TruthValue
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "Indicates whether Hellos are being  suppressed
           to the neighbor"
       ::= { ospfVirtNbrEntry 8 }

--  OSPF Link State Database, External

--      The Link State Database contains the Link State
--      Advertisements from throughout the areas that the
--      device is attached to.

--             This table is identical to the OSPF LSDB Table in
--      format, but contains only External Link State
--             Advertisements.  The purpose is to allow external
--      LSAs to be displayed once for the router rather
--      than once in each non-stub area.

    ospfExtLsdbTable OBJECT-TYPE
        SYNTAX   SEQUENCE OF OspfExtLsdbEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "The OSPF Process's Links State Database."
       REFERENCE
          "OSPF Version 2, Section 12  Link  State  Adver-
          tisements"
      ::= { ospf 12 }


    ospfExtLsdbEntry OBJECT-TYPE
        SYNTAX   OspfExtLsdbEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "A single Link State Advertisement."
       INDEX { ospfExtLsdbType, ospfExtLsdbLsid, ospfExtLsdbRouterId }
       ::= { ospfExtLsdbTable 1 }

OspfExtLsdbEntry ::=
    SEQUENCE {
        ospfExtLsdbType
            INTEGER,
        ospfExtLsdbLsid
            IpAddress,
        ospfExtLsdbRouterId
            RouterID,
        ospfExtLsdbSequence
            Integer32,
        ospfExtLsdbAge
            Integer32,
        ospfExtLsdbChecksum
            Integer32,
        ospfExtLsdbAdvertisement
            OCTET STRING
              }

    ospfExtLsdbType OBJECT-TYPE
        SYNTAX   INTEGER    {
                    asExternalLink (5)
                  }
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The type  of  the  link  state  advertisement.
           Each  link state type has a separate advertise-
           ment format."
       REFERENCE
          "OSPF Version 2, Appendix A.4.1 The  Link  State
          Advertisement header"
      ::= { ospfExtLsdbEntry 1 }


    ospfExtLsdbLsid OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The Link State ID is an LS Type Specific field
           containing either a Router ID or an IP Address;
           it identifies the piece of the  routing  domain
           that is being described by the advertisement."
       REFERENCE
          "OSPF Version 2, Section 12.1.4 Link State ID"
      ::= { ospfExtLsdbEntry 2 }


    ospfExtLsdbRouterId OBJECT-TYPE
        SYNTAX   RouterID
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The 32 bit number that uniquely identifies the
           originating router in the Autonomous System."
       REFERENCE
          "OSPF Version 2, Appendix C.1 Global parameters"
      ::= { ospfExtLsdbEntry 3 }

--  Note that the OSPF Sequence Number is a 32 bit signed
--  integer.  It starts with the value '80000001'h,
--  or -'7FFFFFFF'h, and increments until '7FFFFFFF'h
--  Thus, a typical sequence number will be very negative.

    ospfExtLsdbSequence OBJECT-TYPE
        SYNTAX   Integer32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The sequence number field is a  signed  32-bit
           integer.   It  is used to detect old and dupli-
           cate link state advertisements.  The  space  of
           sequence  numbers  is  linearly  ordered.   The
           larger the sequence number the more recent  the
           advertisement."
       REFERENCE
          "OSPF Version  2,  Section  12.1.6  LS  sequence
          number"
      ::= { ospfExtLsdbEntry 4 }


    ospfExtLsdbAge OBJECT-TYPE
        SYNTAX   Integer32    -- Should be 0..MaxAge
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "This field is the age of the link state adver-
           tisement in seconds."
       REFERENCE
          "OSPF Version 2, Section 12.1.1 LS age"
      ::= { ospfExtLsdbEntry 5 }


    ospfExtLsdbChecksum OBJECT-TYPE
        SYNTAX   Integer32
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "This field is the  checksum  of  the  complete
           contents  of  the  advertisement, excepting the
           age field.  The age field is excepted  so  that
           an   advertisement's  age  can  be  incremented
           without updating the  checksum.   The  checksum
           used  is  the same that is used for ISO connec-
           tionless datagrams; it is commonly referred  to
           as the Fletcher checksum."
       REFERENCE
          "OSPF Version 2, Section 12.1.7 LS checksum"
      ::= { ospfExtLsdbEntry 6 }


    ospfExtLsdbAdvertisement OBJECT-TYPE
        SYNTAX   OCTET STRING (SIZE(36))
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The entire Link State Advertisement, including
           its header."
       REFERENCE
          "OSPF Version 2, Section 12  Link  State  Adver-
          tisements"
      ::= { ospfExtLsdbEntry 7 }


--  OSPF Use of the CIDR Route Table

ospfRouteGroup           OBJECT IDENTIFIER ::= { ospf 13 }

-- The IP Forwarding Table defines a number of objects for use by
-- the routing protocol to externalize its information.  Most of
-- the variables (ipForwardDest, ipForwardMask, ipForwardPolicy,
-- ipForwardNextHop, ipForwardIfIndex, ipForwardType,
-- ipForwardProto, ipForwardAge, and ipForwardNextHopAS) are
-- defined there.

-- Those that leave some discretion are defined here.

-- ipCidrRouteProto is, of course, ospf (13).

-- ipCidrRouteAge is the time since the route was first calculated,
-- as opposed to the time since the last SPF run.

-- ipCidrRouteInfo is an OBJECT IDENTIFIER for use by the routing
-- protocol.  The following values shall be found there depending
-- on the way the route was calculated.

ospfIntraArea      OBJECT IDENTIFIER ::= { ospfRouteGroup 1 }
ospfInterArea      OBJECT IDENTIFIER ::= { ospfRouteGroup 2 }
ospfExternalType1  OBJECT IDENTIFIER ::= { ospfRouteGroup 3 }
ospfExternalType2  OBJECT IDENTIFIER ::= { ospfRouteGroup 4 }

-- ipCidrRouteMetric1 is, by definition, the primary routing
-- metric.  Therefore, it should be the metric that route
-- selection is based on.  For intra-area and inter-area routes,
-- it is an OSPF metric.  For External Type 1 (comparable value)
-- routes, it is an OSPF metric plus the External Metric.  For
-- external Type 2 (non-comparable value) routes, it is the
-- external metric.

-- ipCidrRouteMetric2 is, by definition, a secondary routing
-- metric.  Therefore, it should be the metric that breaks a tie
-- among routes having equal metric1 values and the same
-- calculation rule.  For intra-area, inter-area routes, and
-- External Type 1 (comparable value) routes, it is unused.  For
-- external Type 2 (non-comparable value) routes, it is the metric
-- to the AS border router.

-- ipCidrRouteMetric3, ipCidrRouteMetric4, and ipCidrRouteMetric5 are
-- unused.

--
--      The OSPF Area Aggregate Table
--
--      This table replaces the OSPF Area Summary Table, being an
--      extension of that for CIDR routers.

    ospfAreaAggregateTable OBJECT-TYPE
        SYNTAX   SEQUENCE OF OspfAreaAggregateEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "A range of IP addresses  specified  by  an  IP
           address/IP  network  mask  pair.   For example,
           class B address range of X.X.X.X with a network
           mask  of  255.255.0.0 includes all IP addresses
           from X.X.0.0  to  X.X.255.255.   Note  that  if
           ranges  are configured such that one range sub-
           sumes  another  range  (e.g.,   10.0.0.0   mask
           255.0.0.0  and  10.1.0.0 mask 255.255.0.0), the
           most specific match is the preferred one."
       REFERENCE
          "OSPF Version 2, Appendix C.2  Area parameters"
      ::= { ospf 14 }


    ospfAreaAggregateEntry OBJECT-TYPE
        SYNTAX   OspfAreaAggregateEntry
        MAX-ACCESS   not-accessible
        STATUS   current
        DESCRIPTION
           "A range of IP addresses  specified  by  an  IP
           address/IP  network  mask  pair.   For example,
           class B address range of X.X.X.X with a network
           mask  of  255.255.0.0 includes all IP addresses
           from X.X.0.0  to  X.X.255.255.   Note  that  if
           ranges are range configured such that one range
           subsumes another  range  (e.g.,  10.0.0.0  mask
           255.0.0.0  and  10.1.0.0 mask 255.255.0.0), the
           most specific match is the preferred one."
       REFERENCE
          "OSPF Version 2, Appendix C.2  Area parameters"
      INDEX { ospfAreaAggregateAreaID, ospfAreaAggregateLsdbType,
              ospfAreaAggregateNet, ospfAreaAggregateMask }
      ::= { ospfAreaAggregateTable 1 }


OspfAreaAggregateEntry ::=
    SEQUENCE {
        ospfAreaAggregateAreaID
            AreaID,
        ospfAreaAggregateLsdbType
            INTEGER,
        ospfAreaAggregateNet
            IpAddress,
        ospfAreaAggregateMask
            IpAddress,
        ospfAreaAggregateStatus
            RowStatus,
        ospfAreaAggregateEffect
            INTEGER
              }

    ospfAreaAggregateAreaID OBJECT-TYPE
        SYNTAX   AreaID
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The Area the Address Aggregate is to be  found
           within."
       REFERENCE
          "OSPF Version 2, Appendix C.2 Area parameters"
      ::= { ospfAreaAggregateEntry 1 }


    ospfAreaAggregateLsdbType OBJECT-TYPE
        SYNTAX   INTEGER    {
                    summaryLink (3),
                    nssaExternalLink (7)
                  }
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The type of the Address Aggregate.  This field
           specifies  the  Lsdb type that this Address Ag-
           gregate applies to."
       REFERENCE
          "OSPF Version 2, Appendix A.4.1 The  Link  State
          Advertisement header"
      ::= { ospfAreaAggregateEntry 2 }


    ospfAreaAggregateNet OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The IP Address of the Net or Subnet  indicated
           by the range."
       REFERENCE
          "OSPF Version 2, Appendix C.2 Area parameters"
      ::= { ospfAreaAggregateEntry 3 }


    ospfAreaAggregateMask OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The Subnet Mask that pertains to  the  Net  or
           Subnet."
       REFERENCE
          "OSPF Version 2, Appendix C.2 Area parameters"
      ::= { ospfAreaAggregateEntry 4 }


    ospfAreaAggregateStatus OBJECT-TYPE
        SYNTAX   RowStatus
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "This variable displays the status of  the  en-
           try.  Setting it to 'invalid' has the effect of
           rendering it inoperative.  The internal  effect
           (row removal) is implementation dependent."
       ::= { ospfAreaAggregateEntry 5 }


    ospfAreaAggregateEffect OBJECT-TYPE
        SYNTAX   INTEGER    {
                    advertiseMatching (1),
                    doNotAdvertiseMatching (2)
                  }
        MAX-ACCESS   read-create
        STATUS   current
        DESCRIPTION
           "Subnets subsumed by ranges either trigger  the
           advertisement  of  the indicated aggregate (ad-
           vertiseMatching), or result in the subnet's not
           being advertised at all outside the area."
       DEFVAL   { advertiseMatching }
       ::= { ospfAreaAggregateEntry 6 }


-- conformance information

ospfConformance OBJECT IDENTIFIER ::= { ospf 15 }

ospfGroups      OBJECT IDENTIFIER ::= { ospfConformance 1 }
ospfCompliances OBJECT IDENTIFIER ::= { ospfConformance 2 }

-- compliance statements

    ospfCompliance MODULE-COMPLIANCE
        STATUS  current
        DESCRIPTION
           "The compliance statement "
       MODULE  -- this module
       MANDATORY-GROUPS {
                    ospfBasicGroup,
                    ospfAreaGroup,
                    ospfStubAreaGroup,
                    ospfIfGroup,
                    ospfIfMetricGroup,
                    ospfVirtIfGroup,
                    ospfNbrGroup,
                    ospfVirtNbrGroup,
                    ospfAreaAggregateGroup
           }
       ::= { ospfCompliances 1 }


-- units of conformance

    ospfBasicGroup    OBJECT-GROUP
        OBJECTS {
                    ospfRouterId,
                    ospfAdminStat,
                    ospfVersionNumber,
                    ospfAreaBdrRtrStatus,
                    ospfASBdrRtrStatus,
                    ospfExternLsaCount,
                    ospfExternLsaCksumSum,
                    ospfTOSSupport,
                    ospfOriginateNewLsas,
                    ospfRxNewLsas,
                    ospfExtLsdbLimit,
                    ospfMulticastExtensions,
                    ospfExitOverflowInterval,
                    ospfDemandExtensions
        }
        STATUS  current
        DESCRIPTION
           "These objects are required for OSPF systems."
       ::= { ospfGroups 1 }


    ospfAreaGroup    OBJECT-GROUP
        OBJECTS {
                    ospfAreaId,
                    ospfImportAsExtern,
                    ospfSpfRuns,
                    ospfAreaBdrRtrCount,
                    ospfAsBdrRtrCount,
                    ospfAreaLsaCount,
                    ospfAreaLsaCksumSum,
                    ospfAreaSummary,
                    ospfAreaStatus
        }
        STATUS  current
        DESCRIPTION
           "These objects are required  for  OSPF  systems
           supporting areas."
       ::= { ospfGroups 2 }


    ospfStubAreaGroup    OBJECT-GROUP
        OBJECTS {
                    ospfStubAreaId,
                    ospfStubTOS,
                    ospfStubMetric,
                    ospfStubStatus,
                    ospfStubMetricType
        }
        STATUS  current
        DESCRIPTION
           "These objects are required  for  OSPF  systems
           supporting stub areas."
       ::= { ospfGroups 3 }

    ospfLsdbGroup    OBJECT-GROUP
        OBJECTS {
                    ospfLsdbAreaId,
                    ospfLsdbType,
                    ospfLsdbLsid,
                    ospfLsdbRouterId,
                    ospfLsdbSequence,
                    ospfLsdbAge,
                    ospfLsdbChecksum,
                    ospfLsdbAdvertisement
        }
        STATUS  current
        DESCRIPTION
           "These objects are required  for  OSPF  systems
           that display their link state database."
       ::= { ospfGroups 4 }


    ospfAreaRangeGroup    OBJECT-GROUP
        OBJECTS {
                    ospfAreaRangeAreaId,
                    ospfAreaRangeNet,
                    ospfAreaRangeMask,
                    ospfAreaRangeStatus,
                    ospfAreaRangeEffect
        }
        STATUS  obsolete
        DESCRIPTION
           "These objects are required for  non-CIDR  OSPF
           systems that support multiple areas."
       ::= { ospfGroups 5 }


    ospfHostGroup    OBJECT-GROUP
        OBJECTS {
                    ospfHostIpAddress,
                    ospfHostTOS,
                    ospfHostMetric,
                    ospfHostStatus,
                    ospfHostAreaID
        }
        STATUS  current
        DESCRIPTION
           "These objects are required  for  OSPF  systems
           that support attached hosts."
       ::= { ospfGroups 6 }

    ospfIfGroup    OBJECT-GROUP
        OBJECTS {
                    ospfIfIpAddress,
                    ospfAddressLessIf,
                    ospfIfAreaId,
                    ospfIfType,
                    ospfIfAdminStat,
                    ospfIfRtrPriority,
                    ospfIfTransitDelay,
                    ospfIfRetransInterval,
                    ospfIfHelloInterval,
                    ospfIfRtrDeadInterval,
                    ospfIfPollInterval,
                    ospfIfState,
                    ospfIfDesignatedRouter,
                    ospfIfBackupDesignatedRouter,
                    ospfIfEvents,
                    ospfIfAuthType,
                    ospfIfAuthKey,
                    ospfIfStatus,
                    ospfIfMulticastForwarding,
                    ospfIfDemand
        }
        STATUS  current
        DESCRIPTION
           "These objects are required for OSPF systems."
       ::= { ospfGroups 7 }


    ospfIfMetricGroup    OBJECT-GROUP
        OBJECTS {
                    ospfIfMetricIpAddress,
                    ospfIfMetricAddressLessIf,
                    ospfIfMetricTOS,
                    ospfIfMetricValue,
                    ospfIfMetricStatus
        }
        STATUS  current
        DESCRIPTION
           "These objects are required for OSPF systems."
       ::= { ospfGroups 8 }


    ospfVirtIfGroup    OBJECT-GROUP
        OBJECTS {
                    ospfVirtIfAreaId,
                    ospfVirtIfNeighbor,
                    ospfVirtIfTransitDelay,
                    ospfVirtIfRetransInterval,
                    ospfVirtIfHelloInterval,
                    ospfVirtIfRtrDeadInterval,
                    ospfVirtIfState,
                    ospfVirtIfEvents,
                    ospfVirtIfAuthType,
                    ospfVirtIfAuthKey,
                    ospfVirtIfStatus
        }
        STATUS  current
        DESCRIPTION
           "These objects are required for OSPF systems."
       ::= { ospfGroups 9 }


    ospfNbrGroup    OBJECT-GROUP
        OBJECTS {
                    ospfNbrIpAddr,
                    ospfNbrAddressLessIndex,
                    ospfNbrRtrId,
                    ospfNbrOptions,
                    ospfNbrPriority,
                    ospfNbrState,
                    ospfNbrEvents,
                    ospfNbrLsRetransQLen,
                    ospfNbmaNbrStatus,
                    ospfNbmaNbrPermanence,
                    ospfNbrHelloSuppressed
        }
        STATUS  current
        DESCRIPTION
           "These objects are required for OSPF systems."
       ::= { ospfGroups 10 }


    ospfVirtNbrGroup    OBJECT-GROUP
        OBJECTS {
                    ospfVirtNbrArea,
                    ospfVirtNbrRtrId,
                    ospfVirtNbrIpAddr,
                    ospfVirtNbrOptions,
                    ospfVirtNbrState,
                    ospfVirtNbrEvents,
                    ospfVirtNbrLsRetransQLen,
                    ospfVirtNbrHelloSuppressed
        }
        STATUS  current
        DESCRIPTION
           "These objects are required for OSPF systems."
       ::= { ospfGroups 11 }


    ospfExtLsdbGroup    OBJECT-GROUP
        OBJECTS {
                    ospfExtLsdbType,
                    ospfExtLsdbLsid,
                    ospfExtLsdbRouterId,
                    ospfExtLsdbSequence,
                    ospfExtLsdbAge,
                    ospfExtLsdbChecksum,
                    ospfExtLsdbAdvertisement
        }
        STATUS  current
        DESCRIPTION
           "These objects are required  for  OSPF  systems
           that display their link state database."
       ::= { ospfGroups 12 }


    ospfAreaAggregateGroup    OBJECT-GROUP
        OBJECTS {
                    ospfAreaAggregateAreaID,
                    ospfAreaAggregateLsdbType,
                    ospfAreaAggregateNet,
                    ospfAreaAggregateMask,
                    ospfAreaAggregateStatus,
                    ospfAreaAggregateEffect
        }
        STATUS  current
        DESCRIPTION
           "These objects are required for OSPF systems."
       ::= { ospfGroups 13 }

END

OSPF-TRAP-MIB DEFINITIONS ::= BEGIN

    IMPORTS
            MODULE-IDENTITY, OBJECT-TYPE, NOTIFICATION-TYPE, IpAddress
                FROM SNMPv2-SMI
            MODULE-COMPLIANCE, OBJECT-GROUP
                FROM SNMPv2-CONF
            ospfRouterId, ospfIfIpAddress, ospfAddressLessIf, ospfIfState,
            ospfVirtIfAreaId, ospfVirtIfNeighbor, ospfVirtIfState,
            ospfNbrIpAddr, ospfNbrAddressLessIndex, ospfNbrRtrId,
            ospfNbrState, ospfVirtNbrArea, ospfVirtNbrRtrId, ospfVirtNbrState,
            ospfLsdbType, ospfLsdbLsid, ospfLsdbRouterId, ospfLsdbAreaId,
            ospfExtLsdbLimit, ospf
                FROM OSPF-MIB;

    ospfTrap MODULE-IDENTITY
           LAST-UPDATED "9501201225Z" -- Fri Jan 20 12:25:50 PST 1995
           ORGANIZATION "IETF OSPF Working Group"
           CONTACT-INFO
           "                      Fred Baker
           Postal:                Cisco Systems
                                  519 Lado Drive
                                  Santa Barbara, California 93111
           Tel:                   +1 805 681 0115
           E-Mail:                fred@cisco.com

                                  Rob Coltun
           Postal:                RainbowBridge Communications
           Tel:                   (301) 340-9416
           E-Mail:                rcoltun@rainbow-bridge.com"
       DESCRIPTION
          "The MIB module to describe traps for  the  OSPF
          Version 2 Protocol."
      ::= { ospf 16 }

-- Trap Support Objects

--         The following are support objects for the OSPF traps.

ospfTrapControl OBJECT IDENTIFIER ::= { ospfTrap 1 }
ospfTraps OBJECT IDENTIFIER ::= { ospfTrap 2 }

    ospfSetTrap OBJECT-TYPE
        SYNTAX   OCTET STRING (SIZE(4))
        MAX-ACCESS   read-write
        STATUS   current
        DESCRIPTION
           "A four-octet string serving as a bit  map  for
           the trap events defined by the OSPF traps. This
           object is used to enable and  disable  specific
           OSPF   traps   where  a  1  in  the  bit  field
           represents enabled.  The right-most bit  (least
           significant) represents trap 0."
       ::= { ospfTrapControl 1 }


    ospfConfigErrorType OBJECT-TYPE
        SYNTAX   INTEGER   {
                    badVersion (1),
                    areaMismatch (2),
                    unknownNbmaNbr (3), -- Router is Dr eligible
                    unknownVirtualNbr (4),
                    authTypeMismatch(5),
                    authFailure (6),
                    netMaskMismatch (7),
                    helloIntervalMismatch (8),
                    deadIntervalMismatch (9),
                    optionMismatch (10) }
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "Potential types  of  configuration  conflicts.
           Used  by the ospfConfigError and ospfConfigVir-
           tError traps."
   ::= { ospfTrapControl 2 }


    ospfPacketType OBJECT-TYPE
        SYNTAX   INTEGER   {
                    hello (1),
                    dbDescript (2),
                    lsReq (3),
                    lsUpdate (4),
                    lsAck (5) }
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "OSPF packet types."
   ::= { ospfTrapControl 3 }


    ospfPacketSrc OBJECT-TYPE
        SYNTAX   IpAddress
        MAX-ACCESS   read-only
        STATUS   current
        DESCRIPTION
           "The IP address of an inbound packet that  can-
           not be identified by a neighbor instance."
       ::= { ospfTrapControl 4 }


-- Traps


    ospfIfStateChange NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfIfIpAddress,
                    ospfAddressLessIf,
                    ospfIfState   -- The new state
                  }
        STATUS             current
        DESCRIPTION
           "An ospfIfStateChange trap signifies that there
           has been a change in the state of a non-virtual
           OSPF interface. This trap should  be  generated
           when  the interface state regresses (e.g., goes
           from Dr to Down) or progresses  to  a  terminal
           state  (i.e.,  Point-to-Point, DR Other, Dr, or
           Backup)."
   ::= { ospfTraps 16 }


    ospfVirtIfStateChange NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfVirtIfAreaId,
                    ospfVirtIfNeighbor,
                    ospfVirtIfState  -- The new state
                  }
        STATUS             current
        DESCRIPTION
           "An ospfIfStateChange trap signifies that there
           has  been a change in the state of an OSPF vir-
           tual interface.
           This trap should be generated when  the  inter-
           face  state  regresses  (e.g., goes from Point-
           to-Point to Down) or progresses to  a  terminal
           state (i.e., Point-to-Point)."
   ::= { ospfTraps 1 }


    ospfNbrStateChange NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfNbrIpAddr,
                    ospfNbrAddressLessIndex,
                    ospfNbrRtrId,
                    ospfNbrState  -- The new state
                  }
        STATUS             current
        DESCRIPTION
           "An  ospfNbrStateChange  trap  signifies   that
           there  has been a change in the state of a non-
           virtual OSPF neighbor.   This  trap  should  be
           generated  when  the  neighbor  state regresses
           (e.g., goes from Attempt or Full  to  1-Way  or
           Down)  or progresses to a terminal state (e.g.,
           2-Way or Full).  When an  neighbor  transitions
           from  or  to Full on non-broadcast multi-access
           and broadcast networks, the trap should be gen-
           erated  by the designated router.  A designated
           router transitioning to Down will be  noted  by
           ospfIfStateChange."
   ::= { ospfTraps 2 }

    ospfVirtNbrStateChange NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfVirtNbrArea,
                    ospfVirtNbrRtrId,
                    ospfVirtNbrState  -- The new state
                  }
        STATUS             current
        DESCRIPTION
           "An ospfIfStateChange trap signifies that there
           has  been a change in the state of an OSPF vir-
           tual neighbor.  This trap should  be  generated
           when  the  neighbor state regresses (e.g., goes
           from Attempt or  Full  to  1-Way  or  Down)  or
           progresses to a terminal state (e.g., Full)."
   ::= { ospfTraps 3 }

    ospfIfConfigError NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfIfIpAddress,
                    ospfAddressLessIf,
                    ospfPacketSrc,  -- The source IP address
                    ospfConfigErrorType, -- Type of error
                    ospfPacketType
                  }
        STATUS             current
        DESCRIPTION
           "An ospfIfConfigError  trap  signifies  that  a
           packet  has  been received on a non-virtual in-
           terface  from  a  router  whose   configuration
           parameters  conflict  with this router's confi-
           guration parameters.  Note that the  event  op-
           tionMismatch  should  cause  a  trap only if it
           prevents an adjacency from forming."
                  ::= { ospfTraps 4 }


    ospfVirtIfConfigError NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfVirtIfAreaId,
                    ospfVirtIfNeighbor,
                    ospfConfigErrorType, -- Type of error
                    ospfPacketType
                  }
        STATUS             current
        DESCRIPTION
           "An ospfConfigError trap signifies that a pack-
           et  has  been  received  on a virtual interface
           from a router  whose  configuration  parameters
           conflict   with   this  router's  configuration
           parameters.  Note that the event optionMismatch
           should  cause a trap only if it prevents an ad-
           jacency from forming."
   ::= { ospfTraps 5 }


    ospfIfAuthFailure NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfIfIpAddress,
                    ospfAddressLessIf,
                    ospfPacketSrc,  -- The source IP address
                    ospfConfigErrorType, -- authTypeMismatch or
                                         -- authFailure
                    ospfPacketType
                  }
        STATUS             current
        DESCRIPTION
           "An ospfIfAuthFailure  trap  signifies  that  a
           packet  has  been received on a non-virtual in-
           terface from a router whose authentication  key
           or  authentication  type  conflicts  with  this
           router's authentication key  or  authentication
           type."
   ::= { ospfTraps 6 }


    ospfVirtIfAuthFailure NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfVirtIfAreaId,
                    ospfVirtIfNeighbor,
                    ospfConfigErrorType, -- authTypeMismatch or
                                         -- authFailure
                    ospfPacketType
                  }
        STATUS             current
        DESCRIPTION
           "An ospfVirtIfAuthFailure trap signifies that a
           packet has been received on a virtual interface
           from a router whose authentication key  or  au-
           thentication  type conflicts with this router's
           authentication key or authentication type."
   ::= { ospfTraps 7 }


    ospfIfRxBadPacket NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfIfIpAddress,
                    ospfAddressLessIf,
                    ospfPacketSrc,  -- The source IP address
                    ospfPacketType
                  }
        STATUS             current
        DESCRIPTION
           "An ospfIfRxBadPacket trap  signifies  that  an
           OSPF  packet has been received on a non-virtual
           interface that cannot be parsed."
   ::= { ospfTraps 8 }

    ospfVirtIfRxBadPacket NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfVirtIfAreaId,
                    ospfVirtIfNeighbor,
                    ospfPacketType
                  }
        STATUS             current
        DESCRIPTION
           "An ospfRxBadPacket trap signifies that an OSPF
           packet has been received on a virtual interface
           that cannot be parsed."
   ::= { ospfTraps 9 }


    ospfTxRetransmit NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfIfIpAddress,
                    ospfAddressLessIf,
                    ospfNbrRtrId, -- Destination
                    ospfPacketType,
                    ospfLsdbType,
                    ospfLsdbLsid,
                    ospfLsdbRouterId
                  }
        STATUS             current
        DESCRIPTION
           "An ospfTxRetransmit  trap  signifies  than  an
           OSPF  packet  has  been retransmitted on a non-
           virtual interface.  All packets that may be re-
           transmitted  are associated with an LSDB entry.
           The LS type, LS ID, and Router ID are  used  to
           identify the LSDB entry."
   ::= { ospfTraps 10 }


    ospfVirtIfTxRetransmit NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfVirtIfAreaId,
                    ospfVirtIfNeighbor,
                    ospfPacketType,
                    ospfLsdbType,
                    ospfLsdbLsid,
                    ospfLsdbRouterId
                  }
        STATUS             current
        DESCRIPTION
           "An ospfTxRetransmit  trap  signifies  than  an
           OSPF packet has been retransmitted on a virtual
           interface.  All packets that may be retransmit-
           ted  are  associated with an LSDB entry. The LS
           type, LS ID, and Router ID are used to identify
           the LSDB entry."
   ::= { ospfTraps 11 }


    ospfOriginateLsa NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfLsdbAreaId,  -- 0.0.0.0 for AS Externals
                    ospfLsdbType,
                    ospfLsdbLsid,
                    ospfLsdbRouterId
                  }
        STATUS             current
        DESCRIPTION
           "An ospfOriginateLsa trap signifies that a  new
           LSA  has  been originated by this router.  This
           trap should not be invoked for simple refreshes
           of  LSAs  (which happesn every 30 minutes), but
           instead will only be invoked  when  an  LSA  is
           (re)originated due to a topology change.  Addi-
           tionally, this trap does not include LSAs  that
           are  being  flushed  because  they have reached
           MaxAge."
   ::= { ospfTraps 12 }


    ospfMaxAgeLsa NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfLsdbAreaId,  -- 0.0.0.0 for AS Externals
                    ospfLsdbType,
                    ospfLsdbLsid,
                    ospfLsdbRouterId
                  }
        STATUS             current
        DESCRIPTION
           "An ospfMaxAgeLsa trap signifies  that  one  of
           the LSA in the router's link-state database has
           aged to MaxAge."
   ::= { ospfTraps 13 }

    ospfLsdbOverflow NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfExtLsdbLimit
                  }
        STATUS             current
        DESCRIPTION
           "An ospfLsdbOverflow trap  signifies  that  the
           number of LSAs in the router's link-state data-
           base has exceeded ospfExtLsdbLimit."
   ::= { ospfTraps 14 }


    ospfLsdbApproachingOverflow NOTIFICATION-TYPE
        OBJECTS {
                    ospfRouterId, -- The originator of the trap
                    ospfExtLsdbLimit
                  }
        STATUS             current
        DESCRIPTION
           "An ospfLsdbApproachingOverflow trap  signifies
           that  the  number of LSAs in the router's link-
           state database has exceeded ninety  percent  of
           ospfExtLsdbLimit."
   ::= { ospfTraps 15 }


-- conformance information

ospfTrapConformance OBJECT IDENTIFIER ::= { ospfTrap 3 }

ospfTrapGroups      OBJECT IDENTIFIER ::= { ospfTrapConformance 1 }
ospfTrapCompliances OBJECT IDENTIFIER ::= { ospfTrapConformance 2 }

-- compliance statements

    ospfTrapCompliance MODULE-COMPLIANCE
        STATUS  current
        DESCRIPTION
           "The compliance statement "
       MODULE  -- this module
       MANDATORY-GROUPS { ospfTrapControlGroup }


        GROUP       ospfTrapControlGroup
        DESCRIPTION
           "This group is optional but recommended for all
           OSPF systems"
       ::= { ospfTrapCompliances 1 }


-- units of conformance

    ospfTrapControlGroup    OBJECT-GROUP
        OBJECTS {
                           ospfSetTrap,
                           ospfConfigErrorType,
                           ospfPacketType,
                           ospfPacketSrc
        }
        STATUS  current
        DESCRIPTION
           "These objects are required  to  control  traps
           from OSPF systems."
       ::= { ospfTrapGroups 1 }


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\mibs\snmpv2\rfcs\rfc1573.txt ===
IANAifType-MIB DEFINITIONS ::= BEGIN

   IMPORTS
       MODULE-IDENTITY, OBJECT-TYPE        FROM SNMPv2-SMI
       TEXTUAL-CONVENTION                  FROM SNMPv2-TC;

   ianaifType MODULE-IDENTITY
       LAST-UPDATED "9311082155Z"
       ORGANIZATION "IANA"
       CONTACT-INFO

                  "        Internet Assigned Numbers Authority

                   Postal: USC/Information Sciences Institute
                           4676 Admiralty Way, Marina del Rey, CA 90292

                   Tel:    +1  310 822 1511
                   E-Mail: iana@isi.edu"
       DESCRIPTION
               "The MIB module which defines the IANAifType textual
               convention, and thus the enumerated values of the
               ifType object defined in MIB-II's ifTable."
       ::= { mib-2 30 }


   IANAifType ::= TEXTUAL-CONVENTION
       STATUS       current
       DESCRIPTION
               "This data type is used as the syntax of the ifType
               object in the (updated) definition of MIB-II's
               ifTable.

               The definition of this textual convention with the
               addition of newly assigned values is published
               periodically by the IANA, in either the Assigned
               Numbers RFC, or some derivative of it specific to
               Internet Network Management number assignments.  (The
               latest arrangements can be obtained by contacting the
               IANA.)

               Requests for new values should be made to IANA via
               email (iana@isi.edu).

               The relationship between the assignment of ifType
               values and of OIDs to particular media-specific MIBs
               is solely the purview of IANA and is subject to change
               without notice.  Quite often, a media-specific MIB's
               OID-subtree assignment within MIB-II's 'transmission'
               subtree will be the same as its ifType value.
               However, in some circumstances this will not be the
               case, and implementors must not pre-assume any
               specific relationship between ifType values and
               transmission subtree OIDs."
       SYNTAX  INTEGER {
                   other(1),          -- none of the following
                   regular1822(2),
                   hdh1822(3),
                   ddnX25(4),
                   rfc877x25(5),
                   ethernetCsmacd(6),
                   iso88023Csmacd(7),
                   iso88024TokenBus(8),
                   iso88025TokenRing(9),
                   iso88026Man(10),
                   starLan(11),
                   proteon10Mbit(12),
                   proteon80Mbit(13),
                   hyperchannel(14),
                   fddi(15),
                   lapb(16),
                   sdlc(17),
                   ds1(18),           -- DS1/E1 (RFC 1406)
                   e1(19),            -- obsolete
                   basicISDN(20),
                   primaryISDN(21),
                   propPointToPointSerial(22), -- proprietary serial
                   ppp(23),
                   softwareLoopback(24),
                   eon(25),            -- CLNP over IP (RFC 1070)
                   ethernet3Mbit(26),
                   nsip(27),           -- XNS over IP
                   slip(28),           -- generic SLIP
                   ultra(29),          -- ULTRA technologies
                   ds3(30),            -- T-3
                   sip(31),            -- SMDS
                   frameRelay(32),    -- DTE only
                   rs232(33),
                   para(34),           -- parallel-port
                   arcnet(35),         -- arcnet
                   arcnetPlus(36),     -- arcnet plus
                   atm(37),            -- ATM cells
                   miox25(38),
                   sonet(39),          -- SONET or SDH
                   x25ple(40),
                   iso88022llc(41),
                   localTalk(42),
                   smdsDxi(43),
                   frameRelayService(44),  -- Frame relay DCE
                   v35(45),
                   hssi(46),
                   hippi(47),
                   modem(48),          -- Generic modem
                   aal5(49),           -- AAL5 over ATM
                   sonetPath(50),
                   sonetVT(51),
                   smdsIcip(52),       -- SMDS InterCarrier Interface
                   propVirtual(53),    -- proprietary virtual/internal
                   propMultiplexor(54) -- proprietary multiplexing
               }

   END

   IF-MIB DEFINITIONS ::= BEGIN

   IMPORTS
       MODULE-IDENTITY, OBJECT-TYPE, Counter32, Gauge32,
       Integer32, TimeTicks,
       NOTIFICATION-TYPE                        FROM SNMPv2-SMI
       TEXTUAL-CONVENTION, DisplayString,
       PhysAddress, TruthValue, RowStatus,
       AutonomousType, TestAndIncr              FROM SNMPv2-TC
       MODULE-COMPLIANCE, OBJECT-GROUP          FROM SNMPv2-CONF
       IANAifType                               FROM IANAifType-MIB
       interfaces                               FROM RFC-1213;

   ifMIB MODULE-IDENTITY
       LAST-UPDATED "9311082155Z"
       ORGANIZATION "IETF Interfaces MIB Working Group"
       CONTACT-INFO

                  "        Keith McCloghrie

                   Postal: Hughes LAN Systems
                           1225 Charleston Road, Mountain View, CA 94043

                   Tel:    +1 415 966 7934
                   E-Mail: kzm@hls.com


                           Frank Kastenholz

                   Postal: FTP Software
                           2 High Street, North Andover, MA 01845

                   Tel:    +1 508 685 4000
                   E-Mail: kasten@ftp.com"
       DESCRIPTION
               "The MIB module to describe generic objects for
               network interface sub-layers.  This MIB is an updated
               version of MIB-II's ifTable, and incorporates the
               extensions defined in RFC 1229."
       ::= { mib-2 31 }

   ifMIBObjects OBJECT IDENTIFIER ::= { ifMIB 1 }

   -- OwnerString has the same semantics as used in RFC 1271

   OwnerString ::= TEXTUAL-CONVENTION
       DISPLAY-HINT "255a"
       STATUS       current
       DESCRIPTION
               "This data type is used to model an administratively
               assigned name of the owner of a resource.  This
               information is taken from the NVT ASCII character set.
               It is suggested that this name contain one or more of
               the following: ASCII form of the manager station's
               transport address, management station name (e.g.,
               domain name), network management personnel's name,
               location, or phone number.  In some cases the agent
               itself will be the owner of an entry.  In these cases,
               this string shall be set to a string starting with
               'agent'."
       SYNTAX       OCTET STRING (SIZE(0..255))

   -- InterfaceIndex contains the semantics of ifIndex and
   -- should be used for any objects defined on other mib
   -- modules that need these semantics.

   InterfaceIndex ::= TEXTUAL-CONVENTION
       DISPLAY-HINT "d"
       STATUS       current
       DESCRIPTION
               "A unique value, greater than zero, for each interface
               or interface sub-layer in the managed system.  It is
               recommended that values are assigned contiguously
               starting from 1.  The value for each interface sub-
               layer must remain constant at least from one re-
               initialization of the entity's network management
               system to the next re-initialization."
       SYNTAX       Integer32

   ifNumber  OBJECT-TYPE
       SYNTAX      Integer32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The number of network interfaces (regardless of their
               current state) present on this system."
       ::= { interfaces 1 }


   -- the Interfaces table

   -- The Interfaces table contains information on the entity's
   -- interfaces.  Each sub-layer below the internetwork-layer
   -- of a network interface is considered to be an interface.

   ifTable OBJECT-TYPE
       SYNTAX      SEQUENCE OF IfEntry
       MAX-ACCESS  not-accessible
       STATUS      current
       DESCRIPTION
               "A list of interface entries.  The number of entries
               is given by the value of ifNumber."
       ::= { interfaces 2 }

   ifEntry OBJECT-TYPE
       SYNTAX      IfEntry
       MAX-ACCESS  not-accessible
       STATUS      current
       DESCRIPTION
               "An entry containing management information applicable
               to a particular interface."
       INDEX   { ifIndex }
       ::= { ifTable 1 }

   IfEntry ::=
       SEQUENCE {
           ifIndex                 InterfaceIndex,
           ifDescr                 DisplayString,
           ifType                  IANAifType,
           ifMtu                   Integer32,
           ifSpeed                 Gauge32,
           ifPhysAddress           PhysAddress,
           ifAdminStatus           INTEGER,
           ifOperStatus            INTEGER,
           ifLastChange            TimeTicks,
           ifInOctets              Counter32,
           ifInUcastPkts           Counter32,
           ifInNUcastPkts          Counter32,  -- deprecated
           ifInDiscards            Counter32,
           ifInErrors              Counter32,
           ifInUnknownProtos       Counter32,
           ifOutOctets             Counter32,
           ifOutUcastPkts          Counter32,
           ifOutNUcastPkts         Counter32,  -- deprecated
           ifOutDiscards           Counter32,
           ifOutErrors             Counter32,
           ifOutQLen               Gauge32,    -- deprecated
           ifSpecific              OBJECT IDENTIFIER -- deprecated
       }


   ifIndex OBJECT-TYPE
       SYNTAX      InterfaceIndex
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "A unique value, greater than zero, for each
               interface.  It is recommended that values are assigned
               contiguously starting from 1.  The value for each
               interface sub-layer must remain constant at least from
               one re-initialization of the entity's network
               management system to the next re-initialization."
       ::= { ifEntry 1 }

   ifDescr OBJECT-TYPE
       SYNTAX      DisplayString (SIZE (0..255))
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "A textual string containing information about the
               interface.  This string should include the name of the
               manufacturer, the product name and the version of the
               interface hardware/software."
       ::= { ifEntry 2 }

   ifType OBJECT-TYPE
       SYNTAX      IANAifType
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The type of interface.  Additional values for ifType
               are assigned by the Internet Assigned Numbers
               Authority (IANA), through updating the syntax of the
               IANAifType textual convention."
       ::= { ifEntry 3 }

   ifMtu OBJECT-TYPE
       SYNTAX      Integer32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The size of the largest packet which can be
               sent/received on the interface, specified in octets.
               For interfaces that are used for transmitting network
               datagrams, this is the size of the largest network
               datagram that can be sent on the interface."
       ::= { ifEntry 4 }

   ifSpeed OBJECT-TYPE
       SYNTAX      Gauge32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "An estimate of the interface's current bandwidth in
               bits per second.  For interfaces which do not vary in
               bandwidth or for those where no accurate estimation
               can be made, this object should contain the nominal
               bandwidth.  If the bandwidth of the interface is
               greater than the maximum value reportable by this
               object then this object should report its maximum
               value (4,294,967,295) and ifHighSpeed must be used to
               report the interace's speed.  For a sub-layer which
               has no concept of bandwidth, this object should be
               zero."
       ::= { ifEntry 5 }

   ifPhysAddress OBJECT-TYPE
       SYNTAX      PhysAddress
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The interface's address at its protocol sub-layer.
               The interface's media-specific MIB must define the bit
               and byte ordering and format of the value contained by
               this object.  For interfaces which do not have such an
               address (e.g., a serial line), this object should
               contain an octet string of zero length."
       ::= { ifEntry 6 }

   ifAdminStatus OBJECT-TYPE
       SYNTAX  INTEGER {
                   up(1),       -- ready to pass packets
                   down(2),
                   testing(3)   -- in some test mode
               }
       MAX-ACCESS  read-write
       STATUS      current
       DESCRIPTION
               "The desired state of the interface.  The testing(3)
               state indicates that no operational packets can be
               passed.  When a managed system initializes, all
               interfaces start with ifAdminStatus in the down(2)
               state.  As a result of either explicit management
               action or per configuration information retained by
               the managed system, ifAdminStatus is then changed to
               either the up(1) or testing(3) states (or remains in
               the down(2) state)."
       ::= { ifEntry 7 }

   ifOperStatus OBJECT-TYPE
       SYNTAX  INTEGER {
                   up(1),       -- ready to pass packets
                   down(2),
                   testing(3),  -- in some test mode
                   unknown(4),  -- status can not be determined
                                -- for some reason.
                   dormant(5)
               }
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The current operational state of the interface.  The
               testing(3) state indicates that no operational packets
               can be passed.  If ifAdminStatus is down(2) then
               ifOperStatus should be down(2).  If ifAdminStatus is
               changed to up(1) then ifOperStatus should change to
               up(1) if the interface is ready to transmit and
               receive network traffic; it should change to
               dormant(5) if the interface is waiting for external
               actions (such as a serial line waiting for an
               incomming connection); it should remain in the down(2)
               state if and only if there is a fault that prevents if
               from going to the up(1) state."
       ::= { ifEntry 8 }

   ifLastChange OBJECT-TYPE
       SYNTAX      TimeTicks
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The value of sysUpTime at the time the interface
               entered its current operational state.  If the current
               state was entered prior to the last re-initialization
               of the local network management subsystem, then this
               object contains a zero value."
       ::= { ifEntry 9 }

   ifInOctets OBJECT-TYPE
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The total number of octets received on the interface,
               including framing characters."
       ::= { ifEntry 10 }

   ifInUcastPkts OBJECT-TYPE
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The number of packets, delivered by this sub-layer to
               a higher (sub-)layer, which were not addressed to a
               multicast or broadcast address at this sub-layer."
       ::= { ifEntry 11 }

   ifInNUcastPkts OBJECT-TYPE
       SYNTAX  Counter32
       MAX-ACCESS  read-only
       STATUS      deprecated
       DESCRIPTION
               "The number of packets, delivered by this sub-layer to
               a higher (sub-)layer, which were addressed to a
               multicast or broadcast address at this sub-layer.
               This object is deprecated in favour of
               ifInMulticastPkts and ifInBroadcastPkts."
       ::= { ifEntry 12 }

   ifInDiscards OBJECT-TYPE
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The number of inbound packets which were chosen to be
               discarded even though no errors had been detected to
               prevent their being deliverable to a higher-layer
               protocol.  One possible reason for discarding such a
               packet could be to free up buffer space."
       ::= { ifEntry 13 }

   ifInErrors OBJECT-TYPE
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "For packet-oriented interfaces, the number of inbound
               packets that contained errors preventing them from
               being deliverable to a higher-layer protocol.  For
               character-oriented or fixed-length interfaces, the
               number of inbound transmission units that contained
               errors preventing them from being deliverable to a
               higher-layer protocol."
       ::= { ifEntry 14 }

   ifInUnknownProtos OBJECT-TYPE
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "For packet-oriented interfaces, the number of packets
               received via the interface which were discarded
               because of an unknown or unsupported protocol.  For
               character-oriented or fixed-length interfaces which
               support protocol multiplexing the number of
               transmission units received via the interface which
               were discarded because of an unknown or unsupported
               protocol.  For any interface which does not support
               protocol multiplexing, this counter will always be 0."
       ::= { ifEntry 15 }

   ifOutOctets OBJECT-TYPE
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The total number of octets transmitted out of the
               interface, including framing characters."
       ::= { ifEntry 16 }

   ifOutUcastPkts OBJECT-TYPE
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION

               "The total number of packets that higher-level
               protocols requested be transmitted, and which were not
               addressed to a multicast or broadcast address at this
               sub-layer, including those that were discarded or not
               sent."
       ::= { ifEntry 17 }

   ifOutNUcastPkts OBJECT-TYPE
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      deprecated
       DESCRIPTION
               "The total number of packets that higher-level
               protocols requested be transmitted, and which were
               addressed to a multicast or broadcast address at this
               sub-layer, including those that were discarded or not
               sent.

               This object is deprecated in favour of
               ifOutMulticastPkts and ifOutBroadcastPkts."
       ::= { ifEntry 18 }

   ifOutDiscards OBJECT-TYPE
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The number of outbound packets which were chosen to
               be discarded even though no errors had been detected
               to prevent their being transmitted.  One possible
               reason for discarding such a packet could be to free
               up buffer space."
       ::= { ifEntry 19 }

   ifOutErrors OBJECT-TYPE
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "For packet-oriented interfaces, the number of
               outbound packets that could not be transmitted because
               of errors.  For character-oriented or fixed-length
               interfaces, the number of outbound transmission units
               that could not be transmitted because of errors."
       ::= { ifEntry 20 }

   ifOutQLen OBJECT-TYPE
       SYNTAX      Gauge32
       MAX-ACCESS  read-only
       STATUS      deprecated
       DESCRIPTION
               "The length of the output packet queue (in packets)."
       ::= { ifEntry 21 }

   ifSpecific OBJECT-TYPE
       SYNTAX      OBJECT IDENTIFIER
       MAX-ACCESS  read-only
       STATUS      deprecated
       DESCRIPTION
               "A reference to MIB definitions specific to the
               particular media being used to realize the interface.
               It is recommended that this value point to an instance
               of a MIB object in the media-specific MIB, i.e., that
               this object have the semantics associated with the
               InstancePointer textual convention defined in RFC
               1443.  In fact, it is recommended that the media-
               specific MIB specify what value ifSpecific should/can
               take for values of ifType.  If no MIB definitions
               specific to the particular media are available, the
               value should be set to the OBJECT IDENTIFIER { 0 0 }."
       ::= { ifEntry 22 }


   --
   --   Extension to the interface table
   --
   -- This table replaces the ifExtnsTable table.
   --

   ifXTable        OBJECT-TYPE
       SYNTAX      SEQUENCE OF IfXEntry
       MAX-ACCESS  not-accessible
       STATUS      current
       DESCRIPTION
               "A list of interface entries.  The number of entries
               is given by the value of ifNumber.  This table
               contains additional objects for the interface table."
       ::= { ifMIBObjects 1 }

   ifXEntry        OBJECT-TYPE
       SYNTAX      IfXEntry
       MAX-ACCESS  not-accessible
       STATUS      current
       DESCRIPTION
               "An entry containing additional management information
               applicable to a particular interface."
       AUGMENTS    { ifEntry }
       ::= { ifXTable 1 }

   IfXEntry ::=
       SEQUENCE {
           ifName                  DisplayString,
           ifInMulticastPkts       Counter32,
           ifInBroadcastPkts       Counter32,
           ifOutMulticastPkts      Counter32,
           ifOutBroadcastPkts      Counter32,
           ifHCInOctets            Counter64,
           ifHCInUcastPkts         Counter64,
           ifHCInMulticastPkts     Counter64,
           ifHCInBroadcastPkts     Counter64,
           ifHCOutOctets           Counter64,
           ifHCOutUcastPkts        Counter64,
           ifHCOutMulticastPkts    Counter64,
           ifHCOutBroadcastPkts    Counter64,
           ifLinkUpDownTrapEnable  INTEGER,
           ifHighSpeed             Gauge32,
           ifPromiscuousMode       TruthValue,
           ifConnectorPresent      TruthValue
       }


   ifName OBJECT-TYPE
       SYNTAX      DisplayString
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The textual name of the interface.  The value of this
               object should be the name of the interface as assigned
               by the local device and should be suitable for use in
               commands entered at the device's `console'.  This
               might be a text name, such as `le0' or a simple port
               number, such as `1', depending on the interface naming
               syntax of the device.  If several entries in the
               ifTable together represent a single interface as named
               by the device, then each will have the same value of
               ifName.  If there is no local name, or this object is
               otherwise not applicable, then this object contains a
               0-length string."
       ::= { ifXEntry 1 }

   ifInMulticastPkts OBJECT-TYPE
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The number of packets, delivered by this sub-layer to
               a higher (sub-)layer, which were addressed to a
               multicast address at this sub-layer.  For a MAC layer
               protocol, this includes both Group and Functional
               addresses."
       ::= { ifXEntry 2 }

   ifInBroadcastPkts OBJECT-TYPE
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The number of packets, delivered by this sub-layer to
               a higher (sub-)layer, which were addressed to a
               broadcast address at this sub-layer."
       ::= { ifXEntry 3 }

   ifOutMulticastPkts OBJECT-TYPE
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The total number of packets that higher-level
               protocols requested be transmitted, and which were
               addressed to a multicast address at this sub-layer,
               including those that were discarded or not sent.  For
               a MAC layer protocol, this includes both Group and
               Functional addresses."
       ::= { ifXEntry 4 }

   ifOutBroadcastPkts OBJECT-TYPE
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The total number of packets that higher-level
               protocols requested be transmitted, and which were
               addressed to a broadcast address at this sub-layer,
               including those that were discarded or not sent."
       ::= { ifXEntry 5 }

   --
   -- High Capacity Counter objects.  These objects are all

   -- 64 bit versions of the "basic" ifTable counters.  These
   -- objects all have the same basic semantics as their 32-bit
   -- counterparts, however, their syntax has been extended
   -- to 64 bits.
   --

   ifHCInOctets OBJECT-TYPE
       SYNTAX      Counter64
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The total number of octets received on the interface,
               including framing characters.  This object is a 64-bit
               version of ifInOctets."
       ::= { ifXEntry 6 }

   ifHCInUcastPkts OBJECT-TYPE
       SYNTAX      Counter64
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The number of packets, delivered by this sub-layer to
               a higher (sub-)layer, which were not addressed to a
               multicast or broadcast address at this sub-layer.
               This object is a 64-bit version of ifInUcastPkts."
       ::= { ifXEntry 7 }

   ifHCInMulticastPkts OBJECT-TYPE
       SYNTAX      Counter64
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The number of packets, delivered by this sub-layer to
               a higher (sub-)layer, which were addressed to a
               multicast address at this sub-layer.  For a MAC layer
               protocol, this includes both Group and Functional
               addresses.  This object is a 64-bit version of
               ifInMulticastPkts."
       ::= { ifXEntry 8 }

   ifHCInBroadcastPkts OBJECT-TYPE
       SYNTAX      Counter64
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The number of packets, delivered by this sub-layer to
               a higher (sub-)layer, which were addressed to a
               broadcast address at this sub-layer.  This object is a
               64-bit version of ifInBroadcastPkts."
       ::= { ifXEntry 9 }

   ifHCOutOctets OBJECT-TYPE
       SYNTAX      Counter64
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The total number of octets transmitted out of the
               interface, including framing characters.  This object
               is a 64-bit version of ifOutOctets."
       ::= { ifXEntry 10 }

   ifHCOutUcastPkts OBJECT-TYPE
       SYNTAX      Counter64
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The total number of packets that higher-level
               protocols requested be transmitted, and which were not
               addressed to a multicast or broadcast address at this
               sub-layer, including those that were discarded or not
               sent.  This object is a 64-bit version of
               ifOutUcastPkts."
       ::= { ifXEntry 11 }

   ifHCOutMulticastPkts OBJECT-TYPE
       SYNTAX      Counter64
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The total number of packets that higher-level
               protocols requested be transmitted, and which were
               addressed to a multicast address at this sub-layer,
               including those that were discarded or not sent.  For
               a MAC layer protocol, this includes both Group and
               Functional addresses.  This object is a 64-bit version
               of ifOutMulticastPkts."
       ::= { ifXEntry 12 }

   ifHCOutBroadcastPkts OBJECT-TYPE
       SYNTAX      Counter64
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "The total number of packets that higher-level
               protocols requested be transmitted, and which were
               addressed to a broadcast address at this sub-layer,
               including those that were discarded or not sent.  This
               object is a 64-bit version of ifOutBroadcastPkts."
       ::= { ifXEntry 13 }

   ifLinkUpDownTrapEnable  OBJECT-TYPE
       SYNTAX      INTEGER { enabled(1), disabled(2) }
       MAX-ACCESS  read-write
       STATUS      current
       DESCRIPTION
               "Indicates whether linkUp/linkDown traps should be
               generated for this interface.

               By default, this object should have the value
               enabled(1) for interfaces which do not operate on
               'top' of any other interface (as defined in the
               ifStackTable), and disabled(2) otherwise."
       ::= { ifXEntry 14 }

   ifHighSpeed OBJECT-TYPE
       SYNTAX      Gauge32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "An estimate of the interface's current bandwidth in
               units of 1,000,000 bits per second.  If this object
               reports a value of `n' then the speed of the interface
               is somewhere in the range of `n-500,000' to
               `n+499,999'.  For interfaces which do not vary in
               bandwidth or for those where no accurate estimation
               can be made, this object should contain the nominal
               bandwidth.  For a sub-layer which has no concept of
               bandwidth, this object should be zero."
       ::= { ifXEntry 15 }

   ifPromiscuousMode  OBJECT-TYPE
       SYNTAX      TruthValue
       MAX-ACCESS  read-write
       STATUS      current
       DESCRIPTION
               "This object has a value of false(2) if this interface
               only accepts packets/frames that are addressed to this
               station.  This object has a value of true(1) when the
               station accepts all packets/frames transmitted on the
               media.  The value true(1) is only legal on certain
               types of media.  If legal, setting this object to a
               value of true(1) may require the interface to be reset
               before becoming effective.

               The value of ifPromiscuousMode does not affect the
               reception of broadcast and multicast packets/frames by
               the interface."
       ::= { ifXEntry 16 }

   ifConnectorPresent   OBJECT-TYPE
       SYNTAX      TruthValue
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
               "This object has the value 'true(1)' if the interface
               sublayer has a physical connector and the value
               'false(2)' otherwise."
       ::= { ifXEntry 17 }


   --           The Interface Stack Group
   --
   -- Implementation of this group is mandatory for all systems
   --

   ifStackTable  OBJECT-TYPE
        SYNTAX        SEQUENCE OF IfStackEntry
        MAX-ACCESS    not-accessible
        STATUS        current
        DESCRIPTION
               "The table containing information on the relationships
               between the multiple sub-layers of network interfaces.
               In particular, it contains information on which sub-
               layers run 'on top of' which other sub-layers.  Each
               sub-layer corresponds to a conceptual row in the
               ifTable."
        ::= { ifMIBObjects 2 }


   ifStackEntry  OBJECT-TYPE
        SYNTAX        IfStackEntry
        MAX-ACCESS    not-accessible
        STATUS        current
        DESCRIPTION
               "Information on a particular relationship between two
               sub-layers, specifying that one sub-layer runs on
               'top' of the other sub-layer.  Each sub-layer
               corresponds to a conceptual row in the ifTable."
        INDEX { ifStackHigherLayer, ifStackLowerLayer }
        ::= { ifStackTable 1 }


   IfStackEntry ::=
       SEQUENCE {
           ifStackHigherLayer  Integer32,
           ifStackLowerLayer   Integer32,
           ifStackStatus       RowStatus
        }


   ifStackHigherLayer  OBJECT-TYPE
        SYNTAX        Integer32
        MAX-ACCESS    not-accessible
        STATUS        current
        DESCRIPTION
               "The value of ifIndex corresponding to the higher
               sub-layer of the relationship, i.e., the sub-layer
               which runs on 'top' of the sub-layer identified by the
               corresponding instance of ifStackLowerLayer.  If there
               is no higher sub-layer (below the internetwork layer),
               then this object has the value 0."
        ::= { ifStackEntry 1 }


   ifStackLowerLayer  OBJECT-TYPE
        SYNTAX        Integer32
        MAX-ACCESS    not-accessible
        STATUS        current
        DESCRIPTION
               "The value of ifIndex corresponding to the lower sub-
               layer of the relationship, i.e., the sub-layer which
               runs 'below' the sub-layer identified by the
               corresponding instance of ifStackHigherLayer.  If
               there is no lower sub-layer, then this object has the
               value 0."
        ::= { ifStackEntry 2 }


   ifStackStatus  OBJECT-TYPE
       SYNTAX         RowStatus
       MAX-ACCESS     read-write
       STATUS         current
       DESCRIPTION
               "The status of the relationship between two sub-
               layers.

               Changing the value of this object from 'active' to
               'notInService' or 'destroy' will likely have
               consequences up and down the interface stack.  Thus,
               write access to this object is likely to be
               inappropriate for some types of interfaces, and many
               implementations will choose not to support write-
               access for any type of interface."
       ::= { ifStackEntry 3 }


   --
   --    The Interface Test Table
   --
   -- This group of objects is optional.  However, a media-specific
   -- MIB may make implementation of this group mandatory.
   --
   -- This table replaces the ifExtnsTestTable
   --

   ifTestTable   OBJECT-TYPE
       SYNTAX      SEQUENCE OF IfTestEntry
       MAX-ACCESS  not-accessible
       STATUS      current
       DESCRIPTION
               "This table contains one entry per interface.  It
               defines objects which allow a network manager to
               instruct an agent to test an interface for various
               faults.  Tests for an interface are defined in the
               media-specific MIB for that interface.  After invoking
               a test, the object ifTestResult can be read to
               determine the outcome.  If an agent can not perform
               the test, ifTestResult is set to so indicate.  The
               object ifTestCode can be used to provide further
               test-specific or interface-specific (or even
               enterprise-specific) information concerning the
               outcome of the test.  Only one test can be in progress
               on each interface at any one time.  If one test is in
               progress when another test is invoked, the second test
               is rejected.  Some agents may reject a test when a
               prior test is active on another interface.
               Before starting a test, a manager-station must first
               obtain 'ownership' of the entry in the ifTestTable for
               the interface to be tested.  This is accomplished with
               the ifTestId and ifTestStatus objects as follows:

            try_again:
                get (ifTestId, ifTestStatus)
                while (ifTestStatus != notInUse)
                    /*
                     * Loop while a test is running or some other
                     * manager is configuring a test.
                     */
                    short delay
                    get (ifTestId, ifTestStatus)
                }

                /*
                 * Is not being used right now -- let's compete
                 * to see who gets it.
                 */
                lock_value = ifTestId

                if ( set(ifTestId = lock_value, ifTestStatus = inUse,
                         ifTestOwner = 'my-IP-address') == FAILURE)
                    /*
                     * Another manager got the ifTestEntry -- go
                     * try again
                     */
                    goto try_again;

                /*
                 * I have the lock
                 */
                set up any test parameters.

                /*
                 * This starts the test
                 */
                set(ifTestType = test_to_run);

                wait for test completion by polling ifTestResult

                when test completes, agent sets ifTestResult
                     agent also sets ifTestStatus = 'notInUse'

                retrieve any additional test results, and ifTestId

                if (ifTestId == lock_value+1) results are valid

              A manager station first retrieves the value of the
              appropriate ifTestId and ifTestStatus objects,
              periodically repeating the retrieval if necessary,
              until the value of ifTestStatus is 'notInUse'.  The
              manager station then tries to set the same ifTestId
              object to the value it just retrieved, the same
              ifTestStatus object to 'inUse', and the corresponding
              ifTestOwner object to a value indicating itself.  If
              the set operation succeeds then the manager has
              obtained ownership of the ifTestEntry, and the value of
              the ifTestId object is incremented by the agent (per
              the semantics of TestAndIncr).  Failure of the set
              operation indicates that some other manager has
              obtained ownership of the ifTestEntry.

              Once ownership is obtained, any test parameters can be
              setup, and then the test is initiated by setting
              ifTestType.  On completion of the test, the agent sets
              ifTestStatus to 'notInUse'.  Once this occurs, the
              manager can retrieve the results.  In the (rare) event
              that the invocation of tests by two network managers
              were to overlap, then there would be a possibility that
              the first test's results might be overwritten by the
              second test's results prior to the first results being
              read.  This unlikely circumstance can be detected by a
              network manager retrieving ifTestId at the same time as
              retrieving the test results, and ensuring that the
              results are for the desired request.

              If ifTestType is not set within an abnormally long
              period of time after ownership is obtained, the agent
              should time-out the manager, and reset the value of the
              ifTestStatus object back to 'notInUse'.  It is
              suggested that this time-out period be 5 minutes.

              In general, a management station must not retransmit a
              request to invoke a test for which it does not receive
              a response; instead, it properly inspects an agent's
              MIB to determine if the invocation was successful.
              Only if the invocation was unsuccessful, is the
              invocation request retransmitted.

              Some tests may require the interface to be taken off-
              line in order to execute them, or may even require the
              agent to reboot after completion of the test.  In these
              circumstances, communication with the management
              station invoking the test may be lost until after
              completion of the test.  An agent is not required to
              support such tests.  However, if such tests are
              supported, then the agent should make every effort to
              transmit a response to the request which invoked the
              test prior to losing communication.  When the agent is
              restored to normal service, the results of the test are
              properly made available in the appropriate objects.
              Note that this requires that the ifIndex value assigned
              to an interface must be unchanged even if the test
              causes a reboot.  An agent must reject any test for
              which it cannot, perhaps due to resource constraints,
              make available at least the minimum amount of
              information after that test completes."
       ::= { ifMIBObjects 3 }

   ifTestEntry OBJECT-TYPE
       SYNTAX       IfTestEntry
       MAX-ACCESS   not-accessible
       STATUS       current
       DESCRIPTION
               "An entry containing objects for invoking tests on an
               interface."
       AUGMENTS  { ifEntry }
       ::= { ifTestTable 1 }

   IfTestEntry ::=
       SEQUENCE {
           ifTestId           TestAndIncr,
           ifTestStatus       INTEGER,
           ifTestType         AutonomousType,
           ifTestResult       INTEGER,
           ifTestCode         OBJECT IDENTIFIER,
           ifTestOwner        OwnerString
       }

   ifTestId         OBJECT-TYPE
       SYNTAX       TestAndIncr
       MAX-ACCESS   read-write
       STATUS       current
       DESCRIPTION
               "This object identifies the current invocation of the
               interface's test."
       ::= { ifTestEntry 1 }

   ifTestStatus     OBJECT-TYPE
       SYNTAX       INTEGER { notInUse(1), inUse(2) }
       MAX-ACCESS   read-write
       STATUS       current
       DESCRIPTION
               "This object indicates whether or not some manager
               currently has the necessary 'ownership' required to
               invoke a test on this interface.  A write to this
               object is only successful when it changes its value
               from 'notInUse(1)' to 'inUse(2)'.  After completion of
               a test, the agent resets the value back to
               'notInUse(1)'."
       ::= { ifTestEntry 2 }

   ifTestType       OBJECT-TYPE
       SYNTAX       AutonomousType
       MAX-ACCESS   read-write
       STATUS       current
       DESCRIPTION
               "A control variable used to start and stop operator-
               initiated interface tests.  Most OBJECT IDENTIFIER
               values assigned to tests are defined elsewhere, in
               association with specific types of interface.
               However, this document assigns a value for a full-
               duplex loopback test, and defines the special meanings
               of the subject identifier:

                   noTest  OBJECT IDENTIFIER ::= { 0 0 }

               When the value noTest is written to this object, no
               action is taken unless a test is in progress, in which
               case the test is aborted.  Writing any other value to
               this object is only valid when no test is currently in
               progress, in which case the indicated test is
               initiated.

               When read, this object always returns the most recent
               value that ifTestType was set to.  If it has not been
               set since the last initialization of the network
               management subsystem on the agent, a value of noTest
               is returned."
       ::= { ifTestEntry 3 }

   ifTestResult  OBJECT-TYPE
       SYNTAX       INTEGER {
                        none(1),          -- no test yet requested
                        success(2),
                        inProgress(3),
                        notSupported(4),
                        unAbleToRun(5),   -- due to state of system
                        aborted(6),
                        failed(7)
                    }
       MAX-ACCESS   read-only
       STATUS       current
       DESCRIPTION
               "This object contains the result of the most recently
               requested test, or the value none(1) if no tests have
               been requested since the last reset.  Note that this
               facility provides no provision for saving the results
               of one test when starting another, as could be
               required if used by multiple managers concurrently."
       ::= { ifTestEntry 4 }

   ifTestCode  OBJECT-TYPE
       SYNTAX       OBJECT IDENTIFIER
       MAX-ACCESS   read-only
       STATUS       current
       DESCRIPTION
               "This object contains a code which contains more
               specific information on the test result, for example
               an error-code after a failed test.  Error codes and
               other values this object may take are specific to the
               type of interface and/or test.  The value may have the
               semantics of either the AutonomousType or
               InstancePointer textual conventions as defined in RFC
               1443.  The identifier:

                   testCodeUnknown  OBJECT IDENTIFIER ::= { 0 0 }

               is defined for use if no additional result code is
               available."
       ::= { ifTestEntry 5 }

   ifTestOwner      OBJECT-TYPE
       SYNTAX       OwnerString
       MAX-ACCESS   read-write
       STATUS       current
       DESCRIPTION
               "The entity which currently has the 'ownership'
               required to invoke a test on this interface."
       ::= { ifTestEntry 6 }


   --   Generic Receive Address Table
   --
   -- This group of objects is mandatory for all types of
   -- interfaces which can receive packets/frames addressed to
   -- more than one address.
   --
   -- This table replaces the ifExtnsRcvAddr table.  The main
   -- difference is that this table makes use of the RowStatus
   -- textual convention, while ifExtnsRcvAddr did not.

   ifRcvAddressTable  OBJECT-TYPE
       SYNTAX      SEQUENCE OF IfRcvAddressEntry
       MAX-ACCESS  not-accessible
       STATUS      current
       DESCRIPTION
               "This table contains an entry for each address
               (broadcast, multicast, or uni-cast) for which the
               system will receive packets/frames on a particular
               interface, except as follows:

               - for an interface operating in promiscuous mode,
               entries are only required for those addresses for
               which the system would receive frames were it not
               operating in promiscuous mode.

               - for 802.5 functional addresses, only one entry is
               required, for the address which has the functional
               address bit ANDed with the bit mask of all functional
               addresses for which the interface will accept frames."
       ::= { ifMIBObjects 4 }

   ifRcvAddressEntry  OBJECT-TYPE
       SYNTAX      IfRcvAddressEntry
       MAX-ACCESS  not-accessible
       STATUS      current
       DESCRIPTION
               "A list of objects identifying an address for which
               the system will accept packets/frames on the
               particular interface identified by the index value
               ifIndex."
       INDEX  { ifIndex, ifRcvAddressAddress }
       ::= { ifRcvAddressTable 1 }

   IfRcvAddressEntry ::=
       SEQUENCE {
           ifRcvAddressAddress   PhysAddress,
           ifRcvAddressStatus    RowStatus,
           ifRcvAddressType      INTEGER
       }

   ifRcvAddressAddress OBJECT-TYPE
       SYNTAX      PhysAddress
       MAX-ACCESS  read-create
       STATUS      current
       DESCRIPTION
               "An address for which the system will accept
               packets/frames on this entry's interface."
       ::= { ifRcvAddressEntry 1 }

   ifRcvAddressStatus OBJECT-TYPE
       SYNTAX      RowStatus
       MAX-ACCESS  read-write
       STATUS      current
       DESCRIPTION
               "This object is used to create and delete rows in the
               ifRcvAddressTable."

       ::= { ifRcvAddressEntry 2 }

   ifRcvAddressType OBJECT-TYPE
       SYNTAX      INTEGER {
                       other(1),
                       volatile(2),
                       nonVolatile(3)
                   }

       MAX-ACCESS  read-create
       STATUS      current
       DESCRIPTION
               "This object has the value nonVolatile(3) for those
               entries in the table which are valid and will not be
               deleted by the next restart of the managed system.
               Entries having the value volatile(2) are valid and
               exist, but have not been saved, so that will not exist
               after the next restart of the managed system.  Entries
               having the value other(1) are valid and exist but are
               not classified as to whether they will continue to
               exist after the next restart."

       DEFVAL  { volatile }

       ::= { ifRcvAddressEntry 3 }


   -- definition of interface-related traps.

   linkDown NOTIFICATION-TYPE
       OBJECTS { ifIndex, ifAdminStatus, ifOperStatus }
       STATUS  current
       DESCRIPTION
               "A linkDown trap signifies that the SNMPv2 entity,
               acting in an agent role, has detected that the
               ifOperStatus object for one of its communication links
               is about to transition into the down state."
       ::= { snmpTraps 3 }

   linkUp NOTIFICATION-TYPE
       OBJECTS { ifIndex, ifAdminStatus, ifOperStatus }
       STATUS  current
       DESCRIPTION
               "A linkUp trap signifies that the SNMPv2 entity,
               acting in an agent role, has detected that the
               ifOperStatus object for one of its communication links
               has transitioned out of the down state."
       ::= { snmpTraps 4 }


   -- conformance information

   ifConformance OBJECT IDENTIFIER ::= { ifMIB 2 }

   ifGroups      OBJECT IDENTIFIER ::= { ifConformance 1 }
   ifCompliances OBJECT IDENTIFIER ::= { ifConformance 2 }


   -- compliance statements

   ifCompliance MODULE-COMPLIANCE
       STATUS  current
       DESCRIPTION
               "The compliance statement for SNMPv2 entities which
               have network interfaces."

       MODULE  -- this module
           MANDATORY-GROUPS { ifGeneralGroup, ifStackGroup }

           GROUP       ifFixedLengthGroup
           DESCRIPTION
               "This group is mandatory for all network interfaces
               which are character-oriented or transmit data in
               fixed-length transmission units."

           GROUP       ifHCFixedLengthGroup
           DESCRIPTION
               "This group is mandatory only for those network
               interfaces which are character-oriented or transmit
               data in fixed-length transmission units, and for which
               the value of the corresponding instance of ifSpeed is
               greater than 20,000,000 bits/second."

           GROUP       ifPacketGroup
           DESCRIPTION
               "This group is mandatory for all network interfaces
               which are packet-oriented."

           GROUP       ifHCPacketGroup
           DESCRIPTION
               "This group is mandatory only for those network
               interfaces which are packet-oriented and for which the
               value of the corresponding instance of ifSpeed is
               greater than 650,000,000 bits/second."
           GROUP       ifTestGroup
           DESCRIPTION
               "This group is optional.  Media-specific MIBs which
               require interface tests are strongly encouraged to use
               this group for invoking tests and reporting results.
               A medium specific MIB which has mandatory tests may
               make implementation of this group mandatory."

           GROUP       ifRcvAddressGroup
           DESCRIPTION
               "The applicability of this group MUST be defined by
               the media-specific MIBs.  Media-specific MIBs must
               define the exact meaning, use, and semantics of the
               addresses in this group."

           OBJECT      ifLinkUpDownTrapEnable
           MIN-ACCESS  read-only
           DESCRIPTION
               "Write access is not required."

           OBJECT      ifPromiscuousMode
           MIN-ACCESS  read-only
           DESCRIPTION
               "Write access is not required."

           OBJECT      ifStackStatus
           SYNTAX      INTEGER { active(1) } -- subset of RowStatus
           MIN-ACCESS  read-only
           DESCRIPTION
               "Write access is not required, and only one of the six
               enumerated values for the RowStatus textual convention
               need be supported, specifically: active(1)."

           OBJECT       ifAdminStatus
           SYNTAX       INTEGER { up(1), down(2) }
           MIN-ACCESS   read-only
           DESCRIPTION
               "Write access is not required, nor is support for the
               value testing(3)."
       ::= { ifCompliances 1 }


   -- units of conformance

   ifGeneralGroup    OBJECT-GROUP
       OBJECTS { ifDescr, ifType, ifSpeed, ifPhysAddress,
                 ifAdminStatus, ifOperStatus, ifLastChange,
                 ifLinkUpDownTrapEnable, ifConnectorPresent,
                 ifHighSpeed, ifName }
       STATUS  current
       DESCRIPTION
               "A collection of objects providing information
               applicable to all network interfaces."
       ::= { ifGroups 1 }

   -- the following five groups are mutually exclusive; at most
   -- one of these groups is implemented for any interface

   ifFixedLengthGroup    OBJECT-GROUP
       OBJECTS { ifInOctets, ifOutOctets, ifInUnknownProtos,
                 ifInErrors, ifOutErrors }
       STATUS  current
       DESCRIPTION
               "A collection of objects providing information
               specific to non-high speed, character-oriented or
               fixed-length-transmission network interfaces.  (Non-
               high speed interfaces transmit and receive at speeds
               less than or equal to 20,000,000 bits/second.)"
       ::= { ifGroups 2 }

   ifHCFixedLengthGroup    OBJECT-GROUP
       OBJECTS { ifHCInOctets, ifHCOutOctets,
                 ifInOctets, ifOutOctets, ifInUnknownProtos,
                 ifInErrors, ifOutErrors }
       STATUS  current
       DESCRIPTION
               "A collection of objects providing information
               specific to high speed (greater than 20,000,000
               bits/second) character-oriented or fixed-length-
               transmission network interfaces."
       ::= { ifGroups 3 }

   ifPacketGroup    OBJECT-GROUP
       OBJECTS { ifInOctets, ifOutOctets, ifInUnknownProtos,
                 ifInErrors, ifOutErrors,
                 ifMtu, ifInUcastPkts, ifInMulticastPkts,
                 ifInBroadcastPkts, ifInDiscards,
                 ifOutUcastPkts, ifOutMulticastPkts,
                 ifOutBroadcastPkts, ifOutDiscards,
                 ifPromiscuousMode }
       STATUS  current
       DESCRIPTION
               "A collection of objects providing information
               specific to non-high speed, packet-oriented network
               interfaces.  (Non-high speed interfaces transmit and
               receive at speeds less than or equal to 20,000,000
               bits/second.)"
       ::= { ifGroups 4 }

   ifHCPacketGroup    OBJECT-GROUP
       OBJECTS { ifHCInOctets, ifHCOutOctets,
                 ifInOctets, ifOutOctets, ifInUnknownProtos,
                 ifInErrors, ifOutErrors,
                 ifMtu, ifInUcastPkts, ifInMulticastPkts,
                 ifInBroadcastPkts, ifInDiscards,
                 ifOutUcastPkts, ifOutMulticastPkts,
                 ifOutBroadcastPkts, ifOutDiscards,
                 ifPromiscuousMode }
       STATUS  current
       DESCRIPTION
               "A collection of objects providing information
               specific to high speed (greater than 20,000,000
               bits/second but less than or equal to 650,000,000
               bits/second) packet-oriented network interfaces."
       ::= { ifGroups 5 }

   ifVHCPacketGroup    OBJECT-GROUP
       OBJECTS { ifHCInUcastPkts, ifHCInMulticastPkts,
                 ifHCInBroadcastPkts, ifHCOutUcastPkts,
                 ifHCOutMulticastPkts, ifHCOutBroadcastPkts,
                 ifHCInOctets, ifHCOutOctets,
                 ifInOctets, ifOutOctets, ifInUnknownProtos,
                 ifInErrors, ifOutErrors,
                 ifMtu, ifInUcastPkts, ifInMulticastPkts,
                 ifInBroadcastPkts, ifInDiscards,
                 ifOutUcastPkts, ifOutMulticastPkts,
                 ifOutBroadcastPkts, ifOutDiscards,
                 ifPromiscuousMode }
       STATUS  current
       DESCRIPTION
               "A collection of objects providing information
               specific to higher speed (greater than 650,000,000
               bits/second) packet-oriented network interfaces."
       ::= { ifGroups 6 }

   ifRcvAddressGroup    OBJECT-GROUP
       OBJECTS { ifRcvAddressStatus, ifRcvAddressType }
       STATUS  current
       DESCRIPTION
               "A collection of objects providing information on the
               multiple addresses which an interface receives."
       ::= { ifGroups 7 }

   ifTestGroup    OBJECT-GROUP
       OBJECTS { ifTestId, ifTestStatus, ifTestType,
                 ifTestResult, ifTestCode, ifTestOwner }
       STATUS  current
       DESCRIPTION
               "A collection of objects providing the ability to
               invoke tests on an interface."
       ::= { ifGroups 8 }

   ifStackGroup    OBJECT-GROUP
       OBJECTS { ifStackStatus }
       STATUS  current
       DESCRIPTION
               "A collection of objects providing information on the
               layering of MIB-II interfaces."
       ::= { ifGroups 9 }

   END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\smir_mofs\snmpv1\rfcs\placefil.txt ===
rfc1213.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1229.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1230.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1231.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1238.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1253.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1269.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1271.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1285.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1304.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1315.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1316.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1317.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1318.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1354.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1381.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1382.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1389.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1398.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1406.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1407.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1414.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1461.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1471.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1472.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1473.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1474.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1493.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1512.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1513.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1514.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1515.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1516.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1525.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1559.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1593.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1742.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1757.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
rfc1792.mof	WMI_PSDK\SNMP\SMIR_MOFS\SNMPv1\RFCs\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\wmi provider.doc ===
Microsoft Word 6.0 Document MSWordDocTimes New Roman Symbol Arial Times New Roman Arial Courier Symbol  Copyright (c) 1997-1999 Microsoft Corporation All you need to know to run and test the WMI Provider Tuesday, May 26, 1998 The WMI Provider Overview The WMI Provider provides the interface to the WMI layer in Windows 98 and NT 5 only.  WMI is not supported in Win95 or NT 4.   The WMI Provider queries WMI and translates the WMI data blobs into instances of CIMOM classes that are defined by MOFS.   The large majority of MOFS for WMI will be physically included within the drivers as a binary resource.  The WMI Provider will extract these MOFS and add them to the CIMOM database under the ROOT\WMI namespace.  The WMI Provider also provides the capability to query drivers located in the system ROM and will add those MOFS to the namespace as well. The user can then retrieve instances of those classes, if the driver is able - modify those instances, execute methods, and monitor WMI events.  The rest of this document is devoted to configuring the WMI Provider and using the tool WBEMTEST to execute the above mentioned functionality. Configuring the WMI Provider Before attempting to configure the WMI Provider, you must make sure the WMI service is running as the WMI Provider will not function without it.  The WMI Service is NOT the WMI Provider, the service is the interface through which the WMI Provider can read/write driver and low-level system information.  The WMI files are included in the operating system, these files are: WMI.DLL WMICORE.DLL - This file includes the WMI Super MOF. The WMI Provider is a core WBEM component.  There are two files required, from the WBEM perspective, and these are: WMIPROV.DLL.   The actual WMI Provider WMI.MOF Enables the WMI Provider These files are included in the operating systems Windows 98 or NT 5, under the system32\WBEM directory.  If you are running WBEM setup, then select the WMI checkbox to install the latest files on your system. After installation, you must use the WBEM tool, mofcomp, on the WMI.MOF in order to create the WMI namespace, default WMI classes and register the provider.   Note: Appendix A covers the WMI.MOF in detail. Syntax: mofcomp WMI.MOF At this point, you should be ready to execute the WBEM tool, WBEMTEST, to open the WMI Namespace.  The next section will cover this in detail. Configuration Summary Verify you are running Windows 98 or NT 5. Insure the WMI service is running. Use the WMI Provider that is included in the operating system, or use WBEM Setup to install.  Run MOFCOMP on the WMI.MOF to create the namespace, default classes and register the provider. The WMI Namespace - Class Provider In order to work with the WMI Provider, you must open the WMI Namespace.   One way you can open the WMI Namespace is through the tool WBEMTEST.     Start WBEMTEST. Click on the Connect button. In the Server / Namespace box, type in ROOT\WMI. Click on Login. The first time you log on to this namespace, you will see a delay, since the first time CIMOM loads the WMI Provider, the following takes place: The WMI Provider opens a connection to WMI and queries for a list of binary MOFS. WMI will return a list of binary MOF resources, and/or names of drivers to query. The WMI Provider will loop through the list If it is a binary MOF resource to extract, the provider will: First query for any instances of the class WMIBinaryMofResource with the resource file name as the key, if it is found, the files size and date are saved. Get the current size and date of the driver we are processing. If we found an instance of WMIBinaryMofResource for this driver, and the size and date are the same, then the provider skips to the next driver.  However, if there was no record, or the size/date changed, then the driver is opened, and if the resource name specified is found, it is extracted from the file and passed on to the mof_d.dll to compile and add to the CIMOM database. If successfully added to the database, an instance of WMIBinaryMofResource is created, using the filename as the key, and the file size and date are saved. If it is a name of a driver to query: The WMI Provider will query WMI for a data blob that will contain the binary mof for that driver.   This type of query is for drivers located in the system ROM.  At present, there is not an instance of WMIBinaryMofResource created for these drivers due to an outstanding DCR in WMI. If a successful WMI data blob is retrieved, the provider extracts the binary mof and passes it onto the mof_d.dll to compile and add to the CIMOM database. The WMI Provider will then register an event with WMI that requests it be informed whenever a new driver of either type is added to the system.  This event should not be confused with events from the Event Provider.  This event is automatically enabled each time the WMI Provider is loaded - the life span of the open WMI namespace. As you can see, WMIBinaryMofResource is used to keep track of which MOFS the provider has compiled before.   This allows speedier processing, and as the provider does not allow the user to delete the class definitions, it is an effective way in eliminating unnecessary processing. This binary MOF processing is the WMI Provider s implementation of a Class provider.  When the WMI Provider has completed it s processing, you can select the Enum Classes button to display all of the classes in the namespace. Thereafter, whenever the namespace is closed, then re-opened, the above processing takes place. At the very least, when you enumerate the classes, you will see the classes that are in the WMI.MOF.  In addition, you will see the classes that are extracted from the WMICORE.DLL.  These are NDIS, Keyboard, and Mouse classes.  See Appendix B for a current list. WMI Namespace - Class Provider Summary Each time the namespace is opened, the WMI Provider runs process binary MOFS. WMI Provider adds all binary MOFS the very first time the namespace is opened, thereafter, it will check dates/sizes for optimal processing. Enumerate classes will list the classes extracted from the binary MOFS and the classes that are defined in the WMI.MOF.  The WMI Instance Provider As an Instance Provider, the WMI Provider will query WMI for any class you select from the available classes.  You may look at a class name, but the WMI Provider must get the guid and pass this on to the WMI Layer, as the guid, and/or guid/instance name combination, is the only thing the WMI Layer understands. You can query for all instances, or for a specific instance.  These are two separate code paths.     To query for all instances, select Enum Instances and type in the class name. To query for a single instance, select Open Instance, type in the class and instance name. The main point of the WMI Provider is to interpret the WMI data blobs into instances of classes.  The user doesn t have to worry about how these are constructed or linked, how this works is worth a document in itself, but there are several things that should be understood here. WMI Data blobs can be linked, if you are querying for all instances, verify the WMI Provider is returning the correct number of instances by double checking that same guid through the test tool EnumGuid.  EnumGuid is a useful tool written by Alan Warwick that reads through WMI Data Blobs and displays the data as hex values.  The data can be very confusing to look at and you must know the order of the data displayed.  If you look at the definition of the class using WbemTest, you will see a WMIDataId qualifier on each property and a number.  These numbers represent the order of the data in the blocks.  For example,      PropertyA   - has a qualifier of WMIDataId 2       PropertyB  -  has a qualifier of WMIDataId 1 So, in the WMI Data Blob, you will actually see PropertyB show up before PropertyA. WMI Data blobs are naturally aligned.  What this means is, a byte is aligned on a byte boundary, a word on a word boundary, a dword on a dword boundary.  Embedded classes are a little trickier and are aligned on the largest data type within the class.  The WMI Provider needs to maneuver through the alignment correctly, in order to provide the correct values.    The nothing.sys driver is a special driver written by Alan Warwick that exercises quite a range of data alignments.  You must first install the driver by clicking on nothing.reg and rebooting.  If you see classes from this driver with all zero values, chances are you just found a bug.  Verify results using the test tool nothing.exe.   After you retrieve an instance, if the driver lets you, you can modify and put the data back.  There are two ways to Put Data.   Put Instance functionality After you have modified your instance, simply select Save Object.  Retrieve the object again and make sure the values have changed. Put Property functionality This is a little more involved.  First, you must select the Edit Context button on WbemTest.  There are two code paths to putting a single property of an instance.   You can put a single property, or an array of selected properties.  If you want to put a single property, edit the context by adding __PUT_EXTENSIONS.  This signals the provider you are going to be putting single properties.  If this qualifier is not within the context, the WMI Provider will put the whole instance.  If you wish to put an array of selected properties, add __PUT_EXT_PROPERTIES to the context. This will force the provider to call a different WMI interface and put just the single properties that changed. The WMI Instance Provider Summary To query for all instances, select Enum Instances and type in the class name. To query for a single instance, select Open Instance, type in the class and instance name. Install the nothing.sys driver, you must have the latest nothing.sys, nothing.reg, and nothing.exe. Verify results using EnumGuid and Nothing.exe. To put an instance, select Save Object on the edited instance. To put a property, you must edit the context by adding __PUT_EXTENSIONS / __PUT_EXT_PROPERTIES The WMI Method Provider The WMI Provider supports methods.   The methods are simply passed on to WMI identified by the guid, instance name and WMI Method Id.  The results are returned in the form of a WMI Data Blob and the provider translates the results into the specified Out Class Parameters.  To test a method, using WbemTest, you must do the following: You must procure an instance of a class and select the __RELPATH. Select Execute Method and insert the value of __RELPATH. Select the method to execute and edit any parameters. To execute, select the execute button. The WMI Method Provider Summary To test a method, you must get an instance of a class first. You must select the method you wish to execute from the drop down list box. Results are displayed through the out class parameters. The WMI Event Provider The WMI Provider supports events.  In order to register an event, you must select a class that has been derived from WMIEvent.   Using WBEMTest, click on the Execute Asynchronously checkbox,  then select Notification Query.  Type in your query.  In general it will look like this: Select * from NdisMediaConnect CIMOM notifies the WMI Provider of the requested registration.  The WMI Provider simply passes this request on to the WMI Layer and gives the WMI Layer an entry point to call when the event is triggered.  Once the event is triggered, the WMI Provider receives either a series of WMI Data Blobs each representing instances, or a single one, representing a single instance.  This data is translated and sent to CIMOM. When CIMOM signals the WMI Provider to cancel the event, the WMI Provider in turn notifies the WMI Layer and that event is removed from the list.  Note, the hard coded binary MOF event is present at all times the WMI Provider is loaded. The WMI Event Provider Summary Click the execute Asynchronously checkbox before you select the Notification Query button. You will keep on receiving events until you cancel them. The hard coded binary MOF event is always registered with the WMI Interface as long as the provider is loaded. Appendix A - The WMI.MOF The WMI.MOF is used to register the WMI Provider.  This MOF creates the ROOT\WMI namespace, sets up the default WMI classes, registers the WMI Provider as the following providers   class WMIBinaryMofResource     [read, key]          string Name ;     [read, volatile]     uint32 LowDateTime ;     [read, volatile]     uint32 HighDateTime ; instance of __Win32Provider as $P     Name = "WMIProv";     ClsId   = "{D2D588B5-D081-11d0-99E0-00C04FC2F8EC}" ; instance of __InstanceProviderRegistration Provider = $P; SupportsGet = "TRUE"; SupportsPut = "TRUE"; SupportsEnumeration = "TRUE"; SupportsDelete = "FALSE"; instance of __MethodProviderRegistration Provider = $P; instance of __Win32Provider as $P1     Name = "WMIEventProv";     ClsId   = "{0725C3CB-FEFB-11d0-99F9-00C04FC2F8EC}"; class WMIEvent : __ExtrinsicEvent instance of __EventProviderRegistration     Provider = $P1;     EventQueryList = {"select * from WMIEvent"}; instance of __ClassProviderRegistration Provider = $P; InteractionType = 1; ResultSetQueries={"select * from meta_class"}; ReferencedSetQueries={"select * from meta_class"}; UnsupportedQueries=NULL; SupportsGet = "TRUE"; SupportsPut = "FALSE"; SupportsEnumeration = "TRUE"; SupportsDelete = "FALSE"; Appendix B - The Default Classes These classes are the ones extracted from the WMICORE.DLL binary mof.  This is the minimum you should see on your system. [abstract] class DiskDriver [dynamic: ToInstance, provider("WMIProv"), WMI, Description("Disk Geometry"), guid("{25007F51-57C2-11d1-A528-00A0C9062910}"), locale("MS\\0x409")] class DiskGeometry : DiskDriver [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1), read] sint64 Cylinders; [WmiDataId(2), WmiEnum{"0=Format is unknown", "1=5.25, 1.2MB,  512 bytes/sector", "2=3.5,  1.44MB, 512 bytes/sector", "3=3.5,  2.88MB, 512 bytes/sector", "4=3.5,  20.8MB, 512 bytes/sector", "5=3.5,  720KB,  512 bytes/sector", "6=5.25, 360KB,  512 bytes/sector", "7=5.25, 320KB,  512 bytes/sector", "8=5.25, 320KB,  1024 bytes/sector", "9=5.25, 180KB,  512 bytes/sector", "10=5.25, 160KB,  512 bytes/sector", "11=Removable media other than floppy", "12=Fixed hard disk media", "13=3.5, 120M Floppy", "14=3.5 ,  640KB,  512 bytes/sector", "15=5.25,  640KB,  512 bytes/sector", "16=5.25, 720KB,  512 bytes/sector", "17=3.5 ,  1.2Mb,  512 bytes/sector", "18=3.5 ,  1.23Mb, 1024 bytes/sector", "19=5.25,  1.23MB, 1024 bytes/sector", "20=3.5 MO 128Mb   512 bytes/sector", "21=3.5 MO 230Mb   512 bytes/sector", "22=8, 256KB, 128 bytes/sector"}, read] uint32 MediaType; [WmiDataId(3), read] uint32 TracksPerCylinder; [WmiDataId(4), read] uint32 SectorsPerTrack; [WmiDataId(5), read] uint32 BytesPerSector; [dynamic: ToInstance, provider("WMIProv"), WMI, Description("Disk performance statistics"), guid("BDD865D1-D7C1-11d0-A501-00A0C9062910"), locale("MS\\0x409")] class DiskPerf [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1), Description("Number of bytes read on disk"), read] sint64 BytesRead; [WmiDataId(2), Description("Number of bytes written on disk"), read] sint64 BytesWritten; [WmiDataId(3), Description("Amount off time spent reading from disk"), read] sint64 ReadTime; [WmiDataId(4), Description("Amount off time spent writing to disk"), read] sint64 WriteTime; [WmiDataId(5), Description("Number of read operations from disk"), read] uint32 ReadCount; [WmiDataId(6), Description("Number of write operations to disk"), read] uint32 WriteCount; [WmiDataId(7), Description("Number of requests waiting in the disk queue"), read] uint32 QueueDepth; [WMI, guid("{A1C15015-B069-11d1-9290-00A0C9062910}")] class EC1 [WmiDataId(1)] boolean Xboolean; [WmiDataId(2)] uint8 Xuint8; [WmiDataId(3)] uint16 Xuint16; [WmiDataId(4)] uint32 Xuint32; [WmiDataId(5)] uint64 Xuint64; [WmiDataId(6)] sint8 Xint8; [WmiDataId(7)] sint16 Xint16; [WmiDataId(8)] sint32 Xint32; [WmiDataId(9)] sint64 Xint64; [WmiDataId(10)] datetime Xdatetime; [WmiDataId(11)] string Xstring; [WMI, guid("{A1C15016-B069-11d1-9290-00A0C9062910}")] class EC2 [WmiDataId(1), MAX(8)] boolean Xboolean[]; [WmiDataId(2), MAX(8)] uint8 Xuint8[]; [WmiDataId(3), MAX(4)] uint16 Xuint16[]; [WmiDataId(4), MAX(2)] uint32 Xuint32[]; [WmiDataId(5)] uint64 Xuint64; [WmiDataId(6), MAX(8)] sint8 Xint8[]; [WmiDataId(7), MAX(4)] sint16 Xint16[]; [WmiDataId(8), MAX(2)] sint32 Xint32[]; [WmiDataId(9)] sint64 Xint64; [WmiDataId(10)] datetime Xdatetime; [WmiDataId(11)] string Xstring; [dynamic: ToInstance, provider("WMIProv"), WMI, Description("Keyboard class driver information"), guid("{4731F899-71CB-11d1-A52C-00A0C9062910}"), locale("MS\\0x409")] class KeyboardClassInformation [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1), read, Description("An identification number for the device")] uint64 DeviceId; [dynamic: ToInstance, provider("WMIProv"), WMI, Description("Keyboard port driver information"), guid("{4731F89A-71CB-11d1-A52C-00A0C9062910}"), locale("MS\\0x409")] class KeyboardPortInformation [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1), read, WmiEnum{"0=I8042 Connector1=Serial Connector", "2=USB Connector"}, Description("How the mouse is connected to the computer")] uint32 ConnectorType; [WmiDataId(2), read, Description("The DataQueueSize property indicates the size of the data queue.")] uint32 DataQueueSize; [WmiDataId(3), read, Description("Number of errors that occured on this device")] uint32 ErrorCount; [WmiDataId(4), read, Description("The NumberOfFunctionKeys property indicates the number of function keys on the keyboard.")] uint32 NumberFunctionKeys; [WmiDataId(5), read, Description("The NumberOfIndicators property indicates the number of indicator leds on the keyboard.")] uint32 NumberIndicators; [dynamic: ToInstance, provider("WMIProv"), WMI, Description("Mouse class driver information"), guid("{4731F89B-71CB-11d1-A52C-00A0C9062910}"), locale("MS\\0x409")] class MouseClassInformation [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1), read, Description("An identification number for the device")] uint64 DeviceId; [dynamic: ToInstance, provider("WMIProv"), WMI, Description("Mouse port driver information"), guid("{4731F89C-71CB-11d1-A52C-00A0C9062910}"), locale("MS\\0x409")] class MousePortInformation [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1), read, WmiEnum{"0=I8042 Connector1=Serial Connector", "2=USB Connector"}, Description("How the mouse is connected to the computer")] uint32 ConnectorType; [WmiDataId(2), read, Description("The DataQueueSize property indicates the size of the data queue.")] uint32 DataQueueSize; [WmiDataId(3), read, Description("Number of errors that occured on this device")] uint32 ErrorCount; [WmiDataId(4), read, Description("The NumberOfButtons property indicates the number of buttons on the pointing device.")] uint32 NumberOfButtons; [WmiDataId(5), read, WmiEnum{"0=Standard Mouse", "1=Standard Pointer", "2=Standard Absolute Pointer", "3=Tablet", "4=Touch Screen", "5=Pen", "6=Track Ball", "256=Other"}, Description("The HardwareType property indicates the hardware type of the pointing device.")] string HardwareType; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad1a1-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS ATM Hardware Current Address")] class NdisAtmHardwareCurrentAddress [key, read] string InstanceName; [read] boolean Active; [read, Description("The address of the NIC encoded in the hardware."), WmiDataId(1)] NetworkAddress NdisAtmHardwareCurrentAddress; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad1a5-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS ATM Maximum AAL0 Packet Size")] class NdisAtmMaxAal0PacketSize [key, read] string InstanceName; [read] boolean Active; [read, Description("Maximum supported size for AAL0 packets."), WmiDataId(1)] uint32 NdisAtmMaxAal0PacketSize; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad1a6-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS ATM Maximum AAL1 Packet Size")] class NdisAtmMaxAal1PacketSize [key, read] string InstanceName; [read] boolean Active; [read, Description("Maximum supported size for AAL1 packets."), WmiDataId(1)] uint32 NdisAtmMaxAal1PacketSize; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad1a7-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS ATM Maximum AAL3/4 Packet Size")] class NdisAtmMaxAal34PacketSize [key, read] string InstanceName; [read] boolean Active; [read, Description("Maximum supported size for AAL3/4 packets."), WmiDataId(1)] uint32 NdisAtmMaxAal34PacketSize; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad191-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS ATM Maximum AAL5 Packet Size")] class NdisAtmMaxAal5PacketSize [key, read] string InstanceName; [read] boolean Active; [read, Description("Maximum supported size for AAL5 packets."), WmiDataId(1)] uint32 NdisAtmMaxAal5PacketSize; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad1a3-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS ATM Maximum Active VCI Bits")] class NdisAtmMaxActiveVciBits [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of bits controllable in the VCI field of the cell header."), WmiDataId(1)] uint32 NdisAtmMaxActiveVciBits; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad1a2-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS ATM Maximum Active VCs")] class NdisAtmMaxActiveVcs [key, read] string InstanceName; [read] boolean Active; [read, Description("Maximum number of active VCs the adapter can support."), WmiDataId(1)] uint32 NdisAtmMaxActiveVcs; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad1a4-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS ATM Maximum Active VPI Bits")] class NdisAtmMaxActiveVpiBits [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of bits controllable in the VPI field of the cell header."), WmiDataId(1)] uint32 NdisAtmMaxActiveVpiBits; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{0a21480c-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS ATM Receive Cells Dropped")] class NdisAtmReceiveCellsDropped [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of receive cells the NIC has dropped."), WmiDataId(1)] uint64 NdisAtmReceiveCellsDropped; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{0a21480a-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS ATM Receive Cells OK")] class NdisAtmReceiveCellsOk [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of cells the NIC has received without errors."), WmiDataId(1)] uint64 NdisAtmReceiveCellsOk; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad1a0-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS ATM Supported AAL Types")] class NdisAtmSupportedAalTypes [key, read] string InstanceName; [read] boolean Active; [read, Description("Bit mask defining the AAL types supported by the hardware."), WmiDataId(1)] uint32 NdisAtmSupportedAalTypes; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad19f-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS ATM Supported Service Category")] class NdisAtmSupportedServiceCategory [key, read] string InstanceName; [read] boolean Active; [read, Description("Bit mask defining the service categories supported by the hardware."), WmiDataId(1)] uint32 NdisAtmSupportedServiceCategory; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad19e-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS ATM Supported VC Rates")] class NdisAtmSupportedVcRates [key, read] string InstanceName; [read] boolean Active; [read, Description("Minimum cell rate supported."), WmiDataId(1)] uint32 MinCellRate; [read, Description("Maximum cell rate supported."), WmiDataId(2)] uint32 MaxCellRate; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{0a21480b-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS ATM Transmit Cells OK")] class NdisAtmTransmitCellsOk [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of cells the NIC has transmitted without errors."), WmiDataId(1)] uint64 NdisAtmTransmitCellsOk; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad198-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS Driver Version")] class NdisCoDriverVersion [key, read] string InstanceName; [read] boolean Active; [read, Description("The NDIS version in use by the NIC driver."), WmiDataId(1)] uint32 NdisCoDriverVersion; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad192-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS Hardware Status")] class NdisCoHardwareStatus [key, read] string InstanceName; [read] boolean Active; [read, Description("Current hardware status of the underlying NIC."), WmiDataId(1)] uint32 NdisCoHardwareStatus; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad195-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS Link Speed")] class NdisCoLinkSpeed [key, read] string InstanceName; [read] boolean Active; [read, Description("The maximum inbound and outbound speeds of the NIC (kbps)."), WmiDataId(1)] NetworkLinkSpeed NdisCoLinkSpeed; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad19a-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS MAC Options")] class NdisCoMacOptions [key, read] string InstanceName; [read] boolean Active; [read, Description("A bitmask that defines optional properties of the underlying driver or its NIC."), WmiDataId(1)] uint32 NdisCoMacOptions; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad19b-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS Media Connect Status")] class NdisCoMediaConnectStatus [key, read] string InstanceName; [read] boolean Active; [read, Description("The connection status of the NIC on the network."), WmiEnum{"0=NdisMediaStateConnected", "1=NdisMediaStateDisconnected"}, WmiDataId(1)] uint32 NdisCoMediaConnectStatus; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad194-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS Media Types In Use")] class NdisCoMediaInUse [key, read] string InstanceName; [read] boolean Active; [read, Description("Number of media types in use."), WmiDataId(1)] uint32 NumberElements; [read, Description("List of media types the NIC is currently supporting."), WmiDataId(2), WmiSizeIs("NumberElements")] uint32 NdisCoMediaInUse[]; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad193-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS Media Types Supported")] class NdisCoMediaSupported [key, read] string InstanceName; [read] boolean Active; [read, Description("Number of media types supported."), WmiDataId(1)] uint32 NumberElements; [read, Description("List of media types the NIC supports."), WmiDataId(2), WmiSizeIs("NumberElements")] uint32 NdisCoMediaSupported[]; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad19d-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS Minimum Link Speed")] class NdisCoMinimumLinkSpeed [key, read] string InstanceName; [read] boolean Active; [read, Description("The maximum inbound and outbound speeds of the NIC (kbps)."), WmiDataId(1)] NetworkLinkSpeed NdisCoMinimumLinkSpeed; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{0a214808-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS Receive PDU Errors")] class NdisCoReceivePduErrors [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of PDUs a NIC receives but does not indicate to the protocols due to errors."), WmiDataId(1)] uint32 NdisCoReceivePduErrors; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{0a214809-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS Receive PDUs No Buffer")] class NdisCoReceivePdusNoBuffer [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of PDUs the NIC cannot receive due to lack of NIC receive buffer space."), WmiDataId(1)] uint32 NdisCoReceivePdusNoBuffer; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{0a214806-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS Receive PDUs OK")] class NdisCoReceivePdusOk [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of PDUs the NIC receives without errors and indicates to bound protocols."), WmiDataId(1)] uint32 NdisCoReceivePdusOk; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{0a214807-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS Transmit PDU Errors")] class NdisCoTransmitPduErrors [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of PDUs a NIC fails to transmit."), WmiDataId(1)] uint32 NdisCoTransmitPduErrors; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{0a214805-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS Transmits PDUs OK")] class NdisCoTransmitPdusOk [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of PDUs transmitted without errors"), WmiDataId(1)] uint32 NdisCoTransmitPdusOk; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad197-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS Vendor Description")] class NdisCoVendorDescription [key, read] string InstanceName; [read] boolean Active; [read, Description("Zero-terminated string describing the NIC."), WmiDataId(1)] string NdisCoVendorDescription; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad19c-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS Vendor's Driver Version")] class NdisCoVendorDriverVersion [key, read] string InstanceName; [read] boolean Active; [read, Description("The vendor-assigned version number of the NIC driver."), WmiDataId(1)] uint32 NdisCoVendorDriverVersion; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{791ad196-e35c-11d0-9692-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("CoNDIS Vendor ID")] class NdisCoVendorId [key, read] string InstanceName; [read] boolean Active; [read, Description("A three-byte IEEE-registered vendor code, followed by a single byte the vendor assigns to identify a particular NIC."), WmiDataId(1)] uint32 NdisCoVendorID; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec10361-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Current Lookahead")] class NdisCurrentLookahead [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of bytes of received packet data, excluding the header, that will be indicated to the protocol driver."), WmiDataId(1)] uint32 NdisCurrentLookahead; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec10360-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Current Packet Filter")] class NdisCurrentPacketFilter [key, read] string InstanceName; [read] boolean Active; [read, Description("Current packet types that will be received and indicated by the NIC."), WmiDataId(1)] uint32 NdisCurrentPacketFilter; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec10362-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Driver Version")] class NdisDriverVersion [key, read] string InstanceName; [read] boolean Active; [read, Description("The NDIS version in use by the NIC driver."), WmiDataId(1)] uint16 NdisDriverVersion; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{981f2d7f-b1f3-11d0-8dd7-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Enumerate Adapter")] class NdisEnumerateAdapter [key, read] string InstanceName; [read] boolean Active; [read, Description("Device name."), WmiDataId(1)] string DeviceName; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{981f2d82-b1f3-11d0-8dd7-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Enumerate VC")] class NdisEnumerateVc [key, read] string InstanceName; [read] boolean Active; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{44795700-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Ethernet Current Address")] class NdisEthernetCurrentAddress [key, read] string InstanceName; [read] boolean Active; [read, Description("The address the NIC is currently using."), WmiDataId(1)] NetworkAddress NdisCurrentAddress; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{44795703-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Ethernet MAC Options")] class NdisEthernetMacOptions [key, read] string InstanceName; [read] boolean Active; [read, Description("Features supported by the underlying driver, which could be emulating Ethernet."), WmiDataId(1)] uint32 NdisEthernetMacOptions; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{44795702-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("Adpater Ethernet Maximum Multicast List Size")] class NdisEthernetMaximumMulticastListSize [key, read] string InstanceName; [read] boolean Active; [read, Description("The maximum number of multicast addresses the NIC driver can manage."), WmiDataId(1)] uint32 NdisEthernetMaximumMulticastListSize; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{44795706-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Ethernet More Transmit collisions")] class NdisEthernetMoreTransmitCollisions [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of frames successfully transmitted after more than one collision."), WmiDataId(1)] uint32 NdisEthernetMoreTransmitCollisions; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{44795701-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Ethernet Multicast List")] class NdisEthernetMulticastList [key, read] string InstanceName; [read] boolean Active; [read, Description("Number of multicast addresses enabled on the NIC."), WmiDataId(1)] uint32 NumberElements; [read, Description("The multicast address list on the NIC enabled for packet reception."), WmiDataId(2), WmiSizeIs("NumberElements")] NetworkAddress NdisMulticastList[]; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{44795705-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Ethernet One Transmit collision")] class NdisEthernetOneTransmitCollision [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of frames successfully transmitted after exactly one collision."), WmiDataId(1)] uint32 NdisEthernetOneTransmitCollision; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{447956ff-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Ethernet Permanent Address")] class NdisEthernetPermanentAddress [key, read] string InstanceName; [read] boolean Active; [read, Description("The address of the NIC encoded in the hardware."), WmiDataId(1)] NetworkAddress NdisPermanentAddress; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{44795704-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Ethernet Receive Error Alignment")] class NdisEthernetReceiveErrorAlignment [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of frames received with alignment errors."), WmiDataId(1)] uint32 NdisEthernetReceiveErrorAlignment; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf1403d-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI Attachment Type")] class NdisFddiAttachmentType [key, read] string InstanceName; [read] boolean Active; [read, Description("Defines the attachment of the NIC to the network."), WmiEnum{"1=NdisFddiTypeIsolated", "2=NdisFddiTypeLocalA", "3=NdisFddiTypeLocalB", "4=NdisFddiTypeLocalAB", "5=NdisFddiTypeLocalS", "6=NdisFddiTypeWrapA", "7=NdisFddiTypeWrapB", "8=NdisFddiTypeWrapAB", "9=NdisFddiTypeWrapS", "10=NdisFddiTypeCWrapA", "11=NdisFddiTypeCWrapB", "12=NdisFddiTypeCWrapS", "13=NdisFddiTypeThrough"}, WmiDataId(1)] uint32 NdisFddiAttachmentType; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf1403f-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI Downstream Node Long")] class NdisFddiDownstreamNodeLong [key, read] string InstanceName; [read] boolean Active; [read, Description("The long address of the station below this NIC on the ring or zero if the address is unknown."), WmiDataId(1)] NetworkAddress NdisFddiDownstreamNodeLong; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf14040-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI Frame Errors")] class NdisFddiFrameErrors [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of frames detected in error by this NIC that have not been detected in error by another device on the ring."), WmiDataId(1)] uint32 NdisFddiFrameErrors; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf14041-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI Frames Lost")] class NdisFddiFramesLost [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of times this NIC detected a format error during frame reception such that the frame was stripped."), WmiDataId(1)] uint32 NdisFddiFramesLost; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf14045-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI LConnect State")] class NdisFddiLConnectionState [key, read] string InstanceName; [read] boolean Active; [read, Description("Defines the state of this port's Physical Connection Management (PCM) state machine."), WmiEnum{"1=NdisFddiStateOff", "2=NdisFddiStateBreak", "3=NdisFddiStateTrace", "4=NdisFddiStateConnect", "5=NdisFddiStateNext", "6=NdisFddiStateSignal", "7=NdisFddiStateJoin", "8=NdisFddiStateVerify", "9=NdisFddiStateActive", "10=NdisFddiStateMaintenance"}, WmiDataId(1)] uint32 NdisFddiLConnectionState; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf14043-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI LCT Failures")] class NdisFddiLctFailures [key, read] string InstanceName; [read] boolean Active; [read, Description("The count of the consecutive times the link confidence test (LCT) has failed during connection management."), WmiDataId(1)] uint32 NdisFddiLctFailures; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf14044-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI LEM Rejects")] class NdisFddiLemRejects [key, read] string InstanceName; [read] boolean Active; [read, Description("The link error monitor (LEM) count of times that a link was rejected."), WmiDataId(1)] uint32 NdisFddiLemRejects; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf14036-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI Long Current Address")] class NdisFddiLongCurrentAddress [key, read] string InstanceName; [read] boolean Active; [read, Description("The long address the NIC is currently using."), WmiDataId(1)] NetworkAddress NdisCurrentAddress; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf14038-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI Long Maximum List Size")] class NdisFddiLongMaximumListSize [key, read] string InstanceName; [read] boolean Active; [read, Description("The maximum number of multicast long addresses the NIC driver can manage."), WmiDataId(1)] uint32 NdisFddiLongMaximumListSize; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf14037-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI Long Multicast List")] class NdisFddiLongMulticastList [key, read] string InstanceName; [read] boolean Active; [read, Description("Number of multicast addresses enabled on the NIC."), WmiDataId(1)] uint32 NumberElements; [read, Description("The multicast long address list on the NIC enabled for packet reception."), WmiDataId(2), WmiSizeIs("NumberElements")] NetworkAddress NdisMulticastList[]; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf14035-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI Long Permanent Address")] class NdisFddiLongPermanentAddress [key, read] string InstanceName; [read] boolean Active; [read, Description("The long address of the NIC encoded in the hardware."), WmiDataId(1)] NetworkAddress NdisPermanentAddress; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf14042-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI Ring Management State")] class NdisFddiRingManagmentState [key, read] string InstanceName; [read] boolean Active; [read, Description("Defines the current state of the Ring Management state machine."), WmiEnum{"1=NdisFddiRingIsolated", "2=NdisFddiRingNonOperational", "3=NdisFddiRingOperational", "4=NdisFddiRingDetect", "5=NdisFddiRingNonOperationalDup", "6=NdisFddiRingOperationalDup", "7=NdisFddiRingDirected", "8=NdisFddiRingTrac"}, WmiDataId(1)] uint32 NdisFddiRingManagmentState; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf1403a-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI Short Current Address")] class NdisFddiShortCurrentAddress [key, read] string InstanceName; [read] boolean Active; [read, Description("The short address the NIC is currently using."), WmiDataId(1)] NetworkShortAddress NdisCurrentAddress; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf1403c-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI Short Maximum List Size")] class NdisFddiShortMaximumListSize [key, read] string InstanceName; [read] boolean Active; [read, Description("The maximum number of multicast short addresses the NIC driver can manage."), WmiDataId(1)] uint32 NdisFddiShortMaximumListSize; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf1403b-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI Short Multicast List")] class NdisFddiShortMulticastList [key, read] string InstanceName; [read] boolean Active; [read, Description("Number of multicast short addresses enabled on the NIC."), WmiDataId(1)] uint32 NumberElements; [read, Description("The multicast short address list on the NIC enabled for packet reception."), WmiDataId(2), WmiSizeIs("NumberElements")] NetworkShortAddress NdisMulticastList[]; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf14039-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI Short Permanent Address")] class NdisFddiShortPermanentAddress [key, read] string InstanceName; [read] boolean Active; [read, Description("The short address of the NIC encoded in the hardware."), WmiDataId(1)] NetworkShortAddress NdisPermanentAddress; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf1403e-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS FDDI Upstream Node Long")] class NdisFddiUpstreamNodeLong [key, read] string InstanceName; [read] boolean Active; [read, Description("The long address of the station above this NIC on the ring or zero if the address is unknown."), WmiDataId(1)] NetworkAddress NdisFddiUpstreamNodeLong; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec10354-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Hardware Status")] class NdisHardwareStatus [key, read] string InstanceName; [read] boolean Active; [read, Description("Current hardware status of the underlying NIC."), WmiEnum{"0=NdisHardwareStatusReady", "1=NdisHardwareStatusInitializing", "2=NdisHardwareStatusReset", "3=NdisHardwareStatusClosing", "4=NdisHardwarestatusNotReady"}, WmiDataId(1)] uint32 NdisHardwareStatus; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec10359-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Link Speed")] class NdisLinkSpeed [key, read] string InstanceName; [read] boolean Active; [read, Description("The maximum speed of the NIC (kbps)."), WmiDataId(1)] uint32 NdisLinkSpeed; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec10365-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS MAC Options")] class NdisMacOptions [key, read] string InstanceName; [read] boolean Active; [read, Description("A bitmask that defines optional properties of the underlying driver or its NIC."), WmiDataId(1)] uint32 NdisMacOptions; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec10358-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Maximum Frame Size")] class NdisMaximumFrameSize [key, read] string InstanceName; [read] boolean Active; [read, Description("The maximum network packet size in bytes the NIC supports, not including a header."), WmiDataId(1)] uint32 NdisMaximumFrameSize; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec10357-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Maximum Lookahead Supported")] class NdisMaximumLookahead [key, read] string InstanceName; [read] boolean Active; [read, Description("The maximum number of bytes the NIC can always provide as lookahead data."), WmiDataId(1)] uint32 NdisMaximumLookahead; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec10367-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Maximum Send Packets")] class NdisMaximumSendPackets [key, read] string InstanceName; [read] boolean Active; [read, Description("The maximum number of send packets the MiniportSendPackets function can accept."), WmiDataId(1)] uint32 NdisMaximumSendPackets; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec10363-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Maximum Packet Total Size")] class NdisMaximumTotalSize [key, read] string InstanceName; [read] boolean Active; [read, Description("The maximum total packet length, in bytes, the NIC supports, including the header."), WmiDataId(1)] uint32 NdisMaximumTotalSize; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec10366-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Media Connect Status")] class NdisMediaConnectStatus [key, read] string InstanceName; [read] boolean Active; [read, Description("The connection status of the NIC on the network."), WmiEnum{"0=NdisMediaStateConnected", "1=NdisMediaStateDisconnected"}, WmiDataId(1)] uint32 NdisMediaConnectStatus; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec10356-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Media Types In Use")] class NdisMediaInUse [key, read] string InstanceName; [read] boolean Active; [read, Description("Number of media types in use."), WmiDataId(1)] uint32 NumberElements; [read, Description("List of media types the NIC is currently supporting."), WmiDataId(2), WmiSizeIs("NumberElements")] uint32 NdisMediaInUse[]; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec10355-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Media Types Supported")] class NdisMediaSupported [key, read] string InstanceName; [read] boolean Active; [read, Description("Number of media types supported."), WmiDataId(1)] uint32 NumberElements; [read, Description("List of media types the NIC supports."), WmiDataId(2), WmiSizeIs("NumberElements")] uint32 NdisMediaSupported[]; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec1035d-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Receive Block Size")] class NdisReceiveBlockSize [key, read] string InstanceName; [read] boolean Active; [read, Description("The amount of storage, in bytes, that a single packet occupies in the receive buffer space of the NIC."), WmiDataId(1)] uint32 NdisReceiveBlockSize; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec1035b-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Receive Buffer Space")] class NdisReceiveBufferSpace [key, read] string InstanceName; [read] boolean Active; [read, Description("The amount of memory on the NIC available for buffering receive data."), WmiDataId(1)] uint32 NdisReceiveBufferSpace; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{447956fd-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Receive Errors")] class NdisReceiveError [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of frames a NIC receives but does not indicate to the protocols due to errors."), WmiDataId(1)] uint32 NdisReceiveError; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{447956fe-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Receive No Buffer")] class NdisReceiveNoBuffer [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of frames the NIC cannot receive due to lack of NIC receive buffer space."), WmiDataId(1)] uint32 NdisReceiveNoBuffer; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{447956fb-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Receives OK")] class NdisReceivesOk [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of frames the NIC receives without errors and indicates to bound protocols."), WmiDataId(1)] uint32 NdisReceivesOk; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{44795708-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Token Ring Current Address")] class NdisTokenRingCurrentAddress [key, read] string InstanceName; [read] boolean Active; [read, Description("The address the NIC is currently using."), WmiDataId(1)] NetworkAddress NdisCurrentAddress; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{44795709-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Token Ring Current Functional Address")] class NdisTokenRingCurrentFunctional [key, read] string InstanceName; [read] boolean Active; [read, Description("The functional address enabled on the NIC for packet reception."), WmiDataId(1)] uint32 NdisTokenRingCurrentFunctional; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{4479570a-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Token Ring Current Group Address")] class NdisTokenRingCurrentGroup [key, read] string InstanceName; [read] boolean Active; [read, Description("The group address enabled on the NIC for packet reception."), WmiDataId(1)] uint32 NdisTokenRingCurrentGroup; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf14032-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Token Ring Current Ring State.")] class NdisTokenRingCurrentRingState [key, read] string InstanceName; [read] boolean Active; [read, Description("The state of the NIC driver with repsect to entering the ring."), WmiEnum{"1=NdisRingStateOpened", "2=NdisRingStateClosed", "3=NdisRingStateOpening", "4=NdisRingStateClosing", "5=NdisRingStateOpenFailure", "6=NdisRingStateRingFailure"}, WmiDataId(1)] uint32 NdisTokenRingCurrentRingState; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{890a36ec-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Token Ring Current Ring Status")] class NdisTokenRingCurrentRingStatus [key, read] string InstanceName; [read] boolean Active; [read, Description("The last ring status indicated with an NDIS_RING_XXX status code."), WmiDataId(1)] uint32 NdisTokenRingCurrentRingStatus; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{4479570b-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Token Ring Last Open Status")] class NdisTokenRingLastOpenStatus [key, read] string InstanceName; [read] boolean Active; [read, Description("The last open error status returned for a protocol's call to NdisOpenAdapter."), WmiDataId(1)] uint32 NdisTokenRingLastOpenStatus; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf14033-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Token Ring Line Errors")] class NdisTokenRingLineErrors [key, read] string InstanceName; [read] boolean Active; [read, Description("Number of frames with an invalid FCS or a code violation."), WmiDataId(1)] uint32 NdisTokenRingLineErrors; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{acf14034-a61c-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Token Ring Lost Frames")] class NdisTokenRingLostFrames [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of frames transmitted that have not circled the ring within the maximum ring latency."), WmiDataId(1)] uint32 NdisTokenRingLostFrames; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{44795707-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Token Ring Permanent Address")] class NdisTokenRingPermanentAddress [key, read] string InstanceName; [read] boolean Active; [read, Description("The address of the NIC encoded in the hardware."), WmiDataId(1)] NetworkAddress NdisPermanentAddress; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec1035c-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Transmit Block Size")] class NdisTransmitBlockSize [key, read] string InstanceName; [read] boolean Active; [read, Description("The minimum number of bytes that a single net packet occupies in the transmit buffer space of the NIC."), WmiDataId(1)] uint32 NdisTransmitBlockSize; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec1035a-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Transmit Buffer Space")] class NdisTransmitBufferSpace [key, read] string InstanceName; [read] boolean Active; [read, Description("The amount of memory, in bytes, on the NIC available for buffering transmit data."), WmiDataId(1)] uint32 NdisTransmitBufferSpace; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{447956fc-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Transmit Errors")] class NdisTransmitsError [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of frames a NIC fails to transmit."), WmiDataId(1)] uint32 NdisTransmitsError; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{447956fa-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Transmits OK")] class NdisTransmitsOk [key, read] string InstanceName; [read] boolean Active; [read, Description("The number of frames transmitted without errors"), WmiDataId(1)] uint32 NdisTransmitsOk; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec1035f-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Vendor Description")] class NdisVendorDescription [key, read] string InstanceName; [read] boolean Active; [read, Description("Zero-terminated string describing the NIC."), WmiDataId(1)] string NdisVendorDescription; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{447956f9-a61b-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Vendor's Driver Version")] class NdisVendorDriverVersion [key, read] string InstanceName; [read] boolean Active; [read, Description("The vendor-assigned version number of the NIC driver."), WmiDataId(1)] uint32 NdisVendorDriverVersion; [WMI, dynamic: ToInstance, provider("WMIProv"), guid("{5ec1035e-a61a-11d0-8dd4-00c04fc3358c}"), locale("MS\\0x409"), WmiExpense(1), Description("NDIS Vendor ID")] class NdisVendorID [key, read] string InstanceName; [read] boolean Active; [read, Description("A three-byte IEEE-registered vendor code, followed by a single byte the vendor assigns to identify a particular NIC."), WmiDataId(1)] uint32 NdisVendorID; [WMI, guid("{B5BD98B7-0201-11d1-A50E-00A0C9062910}")] class NetworkAddress [read, WmiDataId(1), MAX(6)] uint8 Address[]; [WMI, guid("{60fc6b57-0f66-11d1-96a7-00c04fc3358c}")] class NetworkLinkSpeed [read, WmiDataId(1)] uint32 Outbound; [read, WmiDataId(2)] uint32 Inbound; [WMI, guid("{B5BD98B8-0201-11d1-A50E-00A0C9062910}")] class NetworkShortAddress [read, WmiDataId(1), MAX(2)] uint8 Address[]; [dynamic: ToInstance, provider("WMIProv"), WMI, Description("The buffer for this control is a BOOLEAN and indicates if the device should dynamically power on and off while the system is working.   A driver would only support such a setting if there is a significant user noticeable effect for powering off the device.  E.g., turning on the device may cause a user noticeable delay.  Regardless of this setting, the driver is still required to support system sleeping states irps (which likely translates to powering off the device when a system sleep occurs)."), guid("827c0a6f-feb0-11d0-bd26-00aa00b7b32a"), locale("MS\\0x409")] class PowerDeviceEnable [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1), read, write] boolean Enable; [dynamic: ToInstance, provider("WMIProv"), WMI, Description("The buffer for this control is a BOOLEAN and indicates if the device should be configured to wake a sleeping system or not.  A driver would only support such a setting if the device is capable of waking the system, which requires the device to have the specific feature as well as the parent PDO.  Sending a Pnp irp to query the device objects capabilities checks the parent PDO.  Note this setting does not necessarily alter the drivers use of the device's wake signal for runtime usage, only the drivers usage of a wait_wake irp during a system sleep needs to be effected if this setting is supported.   Any device supporting this setting may also allow a programmatic setting of the device feature by the current consumer of the device (application, etc..) through a device specific mechanism.  In such a case, the programmatic setting overrides this setting."), guid("a9546a82-feb0-11d0-bd26-00aa00b7b32a"), locale("MS\\0x409")] class PowerDeviceWakeEnable [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1), read, write] boolean Enable; class WMIBinaryMofResource [read, key] string Name; [read, volatile] uint32 LowDateTime; [read, volatile] uint32 HighDateTime; [WMI, dynamic: ToInstance, provider("WmiProv"), guid("{15D851F9-6539-11d1-A529-00A0C9062910}")] class WmiFireEvent [key, read] string InstanceName; [read] boolean Active; [WmiMethodId(1)] void FireEvent(}; [WMI, dynamic: ToInstance, provider("WmiProv"), guid("{15D851F8-6539-11d1-A529-00A0C9062910}")] class WmiGetSetData [key, read] string InstanceName; [read] boolean Active; [WmiMethodId(1)] void SetEC1( [WmiMethodId(2)] void SetEC2( [WmiMethodId(3)] void GetEC1( [WmiMethodId(4)] void GetEC2( [WmiMethodId(5)] void DumpEC1( [WmiMethodId(6)] void DumpEC2( [WmiMethodId(7)] void SetEC1AsEc( [WmiMethodId(8)] void SetEC2AsEc( [WmiMethodId(9)] void GetEC1AsEc( [WmiMethodId(10)] void GetEC2AsEc( [WmiMethodId(11)] void DumpEC1AsEc( [WmiMethodId(12)] void DumpEC2AsEc(}; [dynamic: ToInstance, provider("WMIProv"), WMI, Description("This class supplies the binary mof information"), guid("{05901221-D566-11d1-B2F0-00A0C9062910}"), locale("MS\\0x409")] class WmiMofData [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1), read] uint32 Size; [WmiDataId(2), WmiSizeIs("Size"), read] uint8 BinaryMofData[]; [dynamic: ToInstance, provider("WMIProv"), WMI, Description("This class supplies additional information about a data provider. Querying this class with an instance name returned from another class query will return additional information about the instance"), guid("{C7BF35D0-AADB-11d1-BF4A-00A0C9062910}"), locale("MS\\0x409")] class WmiProviderInfo [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1), read] string FriendlyName; [WmiDataId(2), read] string Description; [WmiDataId(3), read] string Location; [WmiDataId(4), read] string Manufacturer; [WmiDataId(5), read] string Service; [WMI, dynamic: ToInstance, provider("WmiProv"), guid("{15D851F1-6539-11d1-A529-00A0C9062910}")] class WmiSampleClass1 [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1)] boolean Xboolean; [WmiDataId(2)] uint8 Xuint8; [WmiDataId(3)] uint16 Xuint16; [WmiDataId(4)] uint32 Xuint32; [WmiDataId(5)] uint64 Xuint64; [WmiDataId(6)] sint8 Xint8; [WmiDataId(7)] sint16 Xint16; [WmiDataId(8)] sint32 Xint32; [WmiDataId(9)] sint64 Xint64; [WmiDataId(11)] datetime Xdatetime; [WmiDataId(10)] string Xstring; [WMI, dynamic: ToInstance, provider("WmiProv"), guid("{15D851F2-6539-11d1-A529-00A0C9062910}")] class WmiSampleClass2 [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1)] EC1 EmbeddedClass1; [WMI, dynamic: ToInstance, provider("WmiProv"), guid("{15D851F3-6539-11d1-A529-00A0C9062910}")] class WmiSampleClass3 [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1), MAX(4)] EC1 EmbeddedClass1[]; [WMI, dynamic: ToInstance, provider("WmiProv"), guid("{15D851F4-6539-11d1-A529-00A0C9062910}")] class WmiSampleClass4 [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1)] uint32 Count; [WmiDataId(2), WmiSizeIs("Count")] EC1 EmbeddedClass1[]; [WMI, dynamic: ToInstance, provider("WmiProv"), guid("{15D851F5-6539-11d1-A529-00A0C9062910}")] class WmiSampleClass5 [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1)] EC2 EmbeddedClass2; [WMI, dynamic: ToInstance, provider("WmiProv"), guid("{15D851F6-6539-11d1-A529-00A0C9062910}")] class WmiSampleClass6 [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1), MAX(4)] EC2 EmbeddedClass2[]; [WMI, dynamic: ToInstance, provider("WmiProv"), guid("{15D851F7-6539-11d1-A529-00A0C9062910}")] class WmiSampleClass7 [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1)] uint32 Count; [WmiDataId(2), WmiSizeIs("Count")] EC2 EmbeddedClass2[]; [abstract] class WMISMmBios [dynamic: ToInstance, provider("WMIProv"), WMI, Description("Raw SMBIOS Tables"), guid("{8F680850-A584-11d1-BF38-00A0C9062910}"), locale("MS\\0x409")] class RawSMBiosTables : WMISMmBios [key, read] string InstanceName; [read] boolean Active; [WmiDataId(1), read] uint32 Size; [WmiDataId(2), WmiSizeIs("Size"), read] uint8 SMBiosData[]; ~|vpnlj {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg {wsokg Normal Default Paragraph Font
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\wdmhiperf.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Unassigned Microsoft Unassigned Title Version Distribution Component Feature Product Product Version Project Status Internal Unassigned Unassigned Quasar Quasar DraftUnassigned Jenny McCollum WBEM Specification Jenny McCollum Microsoft Word 9.0&v6_</l WDMHiPerf jennymc jennymcbjbjU WDM  Provider Spec Title WDM Provider Version  DOCPROPERTY "Version"  \* MERGEFORMAT  Distribution  FORMDROPDOWN  Component Providers Feature area Feature scope A Feature Product  DOCPROPERTY "Product"  \* MERGEFORMAT  Product Version  DOCPROPERTY "Product Version"  \* MERGEFORMAT  Quasar Project  DOCPROPERTY "Project"  \* MERGEFORMAT  Quasar Author  AUTHOR \* FirstCap \* MERGEFORMAT  Jenny McCollum Manager Nadir Ahmed Status  FORMDROPDOWN  Last Changed 2/16/2000 Revision Summary Version Author Changes 2/16/2000 Jenny Initial draft Overview This document describes the functionality of the WDM Provider.  The WDM Provider is an instance, method, event, pseudo-class and hi perf provider. The hi-perf component will be part of the Quasar time frame and will ship as part of W2K+1 and additionally on the web for platforms that have already been released to Manufacture.  The remaining components have already been shipped. Goals & Objectives The goal of this document is to describe the set of interfaces that will be exposed from the WDM Provider and the functionality of the WDMLIB.LIB - which processes the WNODES and manages calls to the WDM APIs. Dependencies The WDM Provider will be dependent upon a stable set of WDM APIs to be delivered by Alan Warwick. This spec covers two components that must be maintained by this team.   WDMLIB.LIB -  An internal project library which contains the common processing code which actually calls into WDM and parses the WNODES. WDMPROV.DLL  - The actual provider that is shipped. The WDMLIB.LIB is dependent upon the following libraries: $(WBEMCOMN_STATIC_LIB) \ $(STDLIBRARY_LIB) \ $(MINIMFC_LIB) \ $(WMIIDL_LIB) \ $(WBEMINT_LIB) \ $(UTILLIB_LIB) \ $(WDMLIB_ADVAPIP_LIB) \ $(SDK_LIB_PATH)\wmip.lib \ $(SDK_LIB_PATH)\ole32.lib \ $(SDK_LIB_PATH)\oleaut32.lib \ $(SDK_LIB_PATH)\uuid.lib \ $(SDK_LIB_PATH)\kernel32.lib \ $(SDK_LIB_PATH)\advapi32.lib \ $(SDK_LIB_PATH)\vccomsup.lib \ $(SDK_LIB_PATH)\rpcrt4.lib \ $(SDK_LIB_PATH)\user32.lib\ The WMIPROV.DLL is dependent upon the following libraries: $(WBEMCOMN_STATIC_LIB)\ $(STDLIBRARY_LIB) \ $(MINIMFC_LIB) \ $(WMIIDL_LIB) \ $(WBEMINT_LIB) \ $(UTILLIB_LIB) \ $(ESSCLI_STATIC_LIB) \ $(WDMLIB_LIB) \ $(WDMLIB_ADVAPIP_LIB) \ $(SDK_LIB_PATH)\ole32.lib \ $(SDK_LIB_PATH)\oleaut32.lib \ $(SDK_LIB_PATH)\uuid.lib \ $(SDK_LIB_PATH)\wmip.lib\ $(SDK_LIB_PATH)\kernel32.lib \ $(SDK_LIB_PATH)\advapi32.lib \ $(SDK_LIB_PATH)\vccomsup.lib \ $(SDK_LIB_PATH)\rpcrt4.lib \ $(SDK_LIB_PATH)\user32.lib Security All security is handled within the WMIPROV.DLL.  The WDM apis will only allow clients with SecurityImpersonation and SecurityDelegation levels only, so the WMIPROV.DLL must check client impersonation each time one of the following interfaces is called:  STDMETHODIMP CRefresher::Refresh STDMETHODIMP CWDM_Prov::Initialize STDMETHODIMP CWDM_Prov::QueryInstances STDMETHODIMP CWDM_Prov::CreateRefreshableEnum STDMETHODIMP CWDM_Prov::GetObjects STDMETHODIMP CWMIEventProvider::ProvideEvents STDMETHODIMP CWMIEventProvider::NewQuery STDMETHODIMP CWMIEventProvider::CancelQuery STDMETHODIMP CWMIEventProvider::AccessCheck HRESULT CWDM_Prov::PutInstanceAsync HRESULT CWDM_Prov::CreateInstanceEnumAsync HRESULT CWDM_Prov::ExecQueryAsync HRESULT CWDM_Prov::GetObjectAsync STDMETHODIMP CWDM_Prov::ExecMethodAsync In addition, when the namespace is initially opened, the WMIPROV.DLL will query WDM for a list of WDM enabled and available drivers, before this query is executed the provider must insure the proper security level is available before calling into WDM.  If it is not, then the local notification events are not setup and will be checked again the next time any of the above methods listed are called. Provider registration The provider will export DllRegisterServer and DLLUnregisterServer.  The following keys will be either added or deleted, depending upon which function is called:       The keys for the WMI Instance Provider (includes pseudo-class and method provider):  HKEY_CLASSES_ROOT\CLSID\{D2D588B5-D081-11d0-99E0-00C04FC2F8EC}\ WDM Instance Provider HKEY_CLASSES_ROOT\CLSID\{D2D588B5-D081-11d0-99E0-00C04FC2F8EC} \InProcServer32\ WMIProv.dll HKEY_CLASSES_ROOT\CLSID\{D2D588B5-D081-11d0-99E0-00C04FC2F8EC} \InProcServer32\ThreadingModel\       The keys for the WMI Event Provider:  HKEY_CLASSES_ROOT\CLSID\{0725C3CB-FEFB-11d0-99F9-00C04FC2F8EC}\ WDM Event Provider HKEY_CLASSES_ROOT\CLSID\{0725C3CB-FEFB-11d0-99F9-00C04FC2F8EC} \InProcServer32\ WMIProv.dll HKEY_CLASSES_ROOT\CLSID\{0725C3CB-FEFB-11d0-99F9-00C04FC2F8EC} \InProcServer32\ThreadingModel\      The keys for the WMI HiPerf Provider:  HKEY_CLASSES_ROOT\CLSID\{F5280F80-0D8C-4fb7-B60D-CEB99AB45DBC}\ WDM HiPerf Provider HKEY_CLASSES_ROOT\CLSID\{F5280F80-0D8C-4fb7-B60D-CEB99AB45DBC} \InProcServer32\ WMIProv.dll HKEY_CLASSES_ROOT\CLSID\{F5280F80-0D8C-4fb7-B60D-CEB99AB45DBC} \InProcServer32\ThreadingModel\ As the WDM Hi Perf provider is now included with the existing WDM Instance and Event providers, no further work is required by the setup team. Scope of operating system support The WDM provider will only work on Win98, Millenium, Windows 2000 due to the dependency on the WDM layer which is only supported on the above platforms. Prerequisites  The operation of the WDM Provider is dependent upon the successfully compilation of the WMI.MOF, which will create the namespace. External Component Dependencies The WDM Provider is dependent upon components that are included in the operating system: Operating, International Support The provider will define a number of makefiles representing the lists of platforms that require different makefile declarations.  The provider will be required to support full Unicode or full Ansi depending on the platforms that are supported by the provider. The provider will not be accepted into test unless all imported system functions refer to the Unicode or Ansi versions depending on the platform. The following table defines the language support. Platform Language support Win98 Millenium Windows 2000 Unicode All constant strings specified in the provider implementation and used for internal purposes will be placed in a common header.  Logging support The WDM provider will continue to use the existing core logging facility.  The format of the registry is documented in the WMI documentation.   This requires that WMILIB.LIB defines the following in order to identify the log file.   #define THISPROVIDER LOG_WIMPROV LOG_WIMPROV is defined in the core logging facility as one of the official logs it maintains. In order to enter an item in the log, the following macro is called: ERRORTRACE((THISPROVIDER,"Text Message....%x\n",nSize)); The ERRORTRACE macro is defined in the core common include files. Performance and Scalability The Hi Performance provider within WMIPROV.DLL must be able to meet the following refreshing requirements:  12,000 per second. Test coverage Although every WDM driver, in theory, can be a hi perf driver, the WDM Provider will require WDM Hi Performance drivers in order to provide adequate test coverage.   The EVERYTHING.SYS driver, supported by test, should be updated to return hi performance data. The WMIPROV.DLL and WDMLIB.LIB architecture The WDM Provider is composed of two major pieces.  The WDMLIB.LIB and the WDMPROV.DLL, which uses the WDMLIB.LIB. The following represents a high-level view of the relationships of the major classes within the Provider: CWDM_Prov The class that contains the instance, method, class and hi perf provider and the WMIHandleMap and WMIHiPerfHandleMap. CWDM_Event The class that contains the event provider and WMIHandleMap. CWDMHiPerfShell The class that calls the hi perf apis . CWDMStandardShell The class that calls the standard apis. CWDMHiPerfDataBlock Parses the WNODEs and sets the information using IWbemObjectAccess. CWDMStandardDataBlock Parses the WNODEs and sets the information using IWbemClassObject CWDMProcessClass Contains all of the information in order to process the class. CWDM_IDOrder Determines the order of the WMIDataIds/Properties, in order to translate the WNODE   basically, contains the mapping of the WNODE. CWMI_Management Contains all of the pointers necessary to communicate with the core, such as IwbemServices, IwbemContext, etc. WMIPROV.DLL The WDMLIB.LIB exposes two classes - CWMIStandardShell and  CWMIHiPerfShell   that are used by the WMIProv.dll to query WDM, extract the data and fill in the IWbemClassObject or IWbemObjectAccess objects. The provider will expose the following interfaces ( the ones listed below are the ones that contain significant processing, interfaces such as AddRef(), the class factory interfaces,etc., are not included in this spec as they are self-explanatory): All access to internal lists and handle maps are protected by critical sections.  All calls to the parser and WDM shells are protected by try/catch blocks. Upon failure, the provider will return an extended error object, containing either a specific WDM error message - return value, or a Win32_PrivilegesStatus, if applicable. Upon success, the provider will set the status then return. The WMIPROV.DLL also has two main classes: CWDM_PROV that inherits from IWbemServices,                                IWbemProviderInit,                                IwbemHiPerfProvider CWDM_EVENT that inherits from IWbemEventProvider,                                 IWbemEventProviderQuerySink,                                 IWbemProviderInit,                                IWbemEventProviderSecurity The Instance Provider HRESULT CWDM_Prov::Initialize The provider calls RevertToSelf() ( as everyone has the rights to see classes ) then the CWMIBinMof class to process the binary mofs and clean up the namespace.   After this is completed, the provider then registers for binary mof added/deleted events.  This function is only called once, when the namespace is opened.  Before returning, the provider impersonates the client. HRESULT CWDM_Prov::CreateInstanceEnumAsync The provider impersonates the client, and checks to make sure the client has sufficient privileges, then calls the CWDMStandardShell ProcessAllInstances to get a list of all of the instances of the requested class.  HRESULT CWDM_Prov::PutInstanceAsync The provider impersonates the client, and checks to make sure the client has sufficient privileges, then checks the context to determine if we are setting a single property, or the whole instance.  If there is no context object, then obviously, put the whole instance, otherwise if __PUT_EXT_PROPERTIES is set, then send the list to the CWDMStandardShell FillInAndSubmitWMIDataBlob function to write the information. STDMETHODIMP CWDM_Prov::ExecMethodAsync The provider impersonates the client, and checks to make sure the client has sufficient privileges, then the path is parsed, using the CObjectPathParser.   The class is checked for input and output parameter classes, then all of the information is sent to the CWDMStandardShell ExecuteMethod function to execute the method and get the input/output data. HRESULT CWDM_Prov::GetObjectAsync The provider impersonates the client, and checks to make sure the client has sufficient privileges, then the path is parsed to get the class name.  The CWDMStandardShell ProcessSingleInstance function is called to get the instance of the specified object. The Event Provider  STDMETHODIMP CWMIEventProvider::Initialize Checks to make sure the class  WMIEvent  is defined in the namespace. STDMETHODIMP CWMIEventProvider::ProvideEvents Opportunity for internal initialization and returns S_OK STDMETHODIMP CWMIEventProvider::NewQuery The provider impersonates the client, and checks to make sure the client has sufficient privileges, then uses the SQL1_Parser to get the class name,  and calls the CWDMStandardShell RegisterWMIEvent function to register the event, providing the address of the call back function, for WDM to call once the event triggers.  The id of the event is stored in the event list, along with the WDM identifying information. STDMETHODIMP CWMIEventProvider::CancelQuery The provider impersonates the client, and checks to make sure the client has sufficient privileges, then if the event id is found in the event list, the CWDMStandardShell RemoveWMIEvent function is called. STDMETHODIMP CWMIEventProvider::AccessCheck This is only valid on NT, if running on Win9x, simply returns success.  The provider impersonates the client, and checks the access permissions when the client subscribes to the specified event to make sure they have sufficient WMIGUID_QUERY privileges. The Hi Perf Provider STDMETHODIMP CWDM_Prov::QueryInstances The provider impersonates the client, and checks to make sure the client has sufficient privileges, then uses  CWDMHiPerfShell ( with WMIGUID_QUERY access ) QueryAllHiPerfData function to get a complete list of instances for the specified class. STDMETHODIMP CWDM_Prov::CreateRefresher The provider impersonates the client, and checks to make sure the client has sufficient privileges, then allocates a new refresher based upon an internal definition, initialize and addref it, then return it.     STDMETHODIMP CWDM_Prov::CreateRefreshableObject The provider impersonates the client, and checks to make sure the client has sufficient privileges, then calls the CWDMHiPerfShell AddAccessObjectToRefresher function to add the object specified by the client into the specified refresher.  An id is returned that uniquely identifies this object.  The provider maintains a HiPerfhandle map that lists the handles of Access Instances ( actual instances )and Enumerator Instances (enumerators ) and the unqiue id to identify the object. STDMETHODIMP CWDM_Prov::CreateRefreshableEnum The provider impersonates the client, and checks to make sure the client has sufficient privileges, then calls the CWDMHiPerfShell AddEnumeratorObjectToRefresher function to add the enumerator.  .  The provider maintains a HiPerfhandle map that lists the handles of Access Instances ( actual instances )and Enumerator Instances (enumerators ) and the unqiue id to identify the object. STDMETHODIMP CWDM_Prov::StopRefreshing The provider impersonates the client, and checks to make sure the client has sufficient privileges, then calls the CWDMHiPerfShell RemoveObjectFromHandleMap to remove an object from the refresher.  The id can be either an instance or enumerator and is removed from the HiPerf Handle Map. STDMETHODIMP CWDM_Prov::GetObjects The provider impersonates the client, and checks to make sure the client has sufficient privileges, then uses  the CWDMHiPerfShell  GetAllObjects to provide all instances currently being managed by the provider in the specified namespace ( which is only ROOT\WMI at present ). STDMETHODIMP CRefresher::Refresh The provider impersonates the client, and checks to make sure the client has sufficient privileges, then uses the CWDMHiPerfShell RefreshCompleteList to refresh a set of instances bound to a particular refresher. WDMLIB.LIB This common library is composed of the following files: BMOF.C This is copied code soon to be made into a common library by the core team CRC32.C This is copied as well, soon to be included in a common library WMIMOF.CPP This contains the code that processes the binary mofs and maintains the namespace. WMICLASS.CPP This contains the code that manages the IwbemClassObjects and IwbemAccessObjects, and provides any interface needed to these WMI objects. WMICOM.CPP This contains the code that is common to the other classes, as well as the WMI common pointers, such as IwbemServices, IwbemContext, handle maps, etc. WMIDATA.CPP This contains the code that calls the WDM interfaces and parses the WNODES. WMIMAP.CPP This contains the code that maps the WDM data types to WMI data types. WDMSHELL.CPP This is the file that exposes the external interfaces to the library, the two classes:  CWMIStandardShell and CWMIHiPerfShell Processing the Binary Mofs and Managing the Namespace The provider extracts and submits the binary mofs by querying WDM for ROM binary mofs or via WDM enabled drivers and automatically maintains the namespace.  Before querying for the binary mofs, the provider calls RevertToSelf(), as everyone has the right to see the classes, they just may not have the right to get instances. These classes process this binary mof and maintain the namespace. CWMIBinMof   Queries WDM and processes the binary mofs, if needed, then calls the namespace class to determine if any classes are to be deleted. CNamespaceManagement This class maps drivers to classes and determines if any classes or drivers need to be deleted after all of the latest binary mofs have been processed. The first time the namespace is opened, the provider does the following: Queries the WDM layer by creating a CWDMStandardShell class and calling the function   QueryAndProcessAllBinaryGuidInstances(), which queries WDM with the GUID {05901221-D566-11d1-B2F0-00A0C9062910} .  This will return a list of instances, with the binary mofs inserted into the data blocks.  Simply open the data block and continue identical processing as if the binary mof had just been extracted from the physical file, as stated below.  Loop through all instances, and build up the namespace management query as specified below. Queries the WDM layer by calling WmiMofEnumerateResources for a list of binary mof resources, this list is composed of a filename/resource combination, or the name of a class to query   The provider processes each of these resources, there are two types: A file name of a file and resource name, in order to extract the binary mof as a named resource from the physical file. A class to query for and receive the binary mof as a WNODE. The provider will loop through the list.  If the resource is a filename/resouce name combination: The provider will go to the specified location and get the date/time of the file, using:     GetFileTime( (HANDLE)hFile, &ftCreationTime,  &ftLastAccessTime, &ftLastWriteTime )) Then it will attempt to open an instance of WMIBinaryMofResource, with the key of the complete path[resource] of the specified file  If it isn t found, then we know we have never processed this driver before, so we go ahead and process it. If it is found, compare the file date and time.  If the time matches,  do NOT process it, as this is the latest verion.  If it does not match, then process the binary mof. If it is determined the binary mof needs to be processed, the binary mof must be physically extracted from the file by loading the file and finding the resource, using LoadLibraryEx and FindResource().  Once a pointer to the data is found, then process the binary mof.  If the resource is a GUID to query: Submit the guid to WMIQuerySingleInstance, then open the WNODE to get a pointer to the data block.  Take the data block and calculate the CRC using the CRC32 utility class.  Construct the key ( which is the instance name[guid] ) and try to open an instance of WMIBinaryMofResource, using this constructed key.   If it isn t found, then we know we have never processed this binary mof before, so process it.   If it is found, compare the CRC   which is stored in the upper date field. If it matches, do nothing.  If it does not match, then process the binary mof. Processing the binary mof To process a binary mof, the binary mof must be decompressed.  The first 4 DWORDS are the signature, compression type and sizes.  The signature must equal BMOF_SIG, and the compression type must be 1.  Using the expanded size ( the 4th DWORD ), allocate enough memory to hold the decompressed mof, then ship it off to the CbaseMrciCompression class to decompress it. After it has been decompressed, call CoCreateInstance(CLSID_WinmgmtMofCompiler  ) and send the binary mof via the WinmgmtCompileBuffer function.  Note:  The flags must be set to 65536, as the WinmgmtCompileBuffer function is hardcoded to look for this flag and automatically put everything in the ROOT\WMI namespace. After processing a binary mof After successfully processing a binary mof/ WNODE, create an instance of WMIBinaryMofResource with the correct information. A mof that comes from a file will use the properties in the following manner:    Name            Complete path/filename[RESOURCENAME]    LowDateTime     The low date time of the file    HighDateTime    The high date time of the file A mof that comes from a WNODE will use the properties in the following manner:    Name            GUID[instance name]    LowDateTime     CRC    HighDateTime    Not used The binary mof must be parsed again (this is a good place for optimization) to get a list of classes that were in the mof   this is done using the CBMOFObjList and CBMOFObj classes.  This copied code (BMOF.C) will soon be replaced by a common library and the provider will be modified to call these functions. The list, along with the information just entered in the WMIBinaryMofResource, which uniquely identifies a driver, is passed to the CNamespaceManagement class, to create the mappings of classes to the driver, and to delete any classes that may have been deleted since the last time the mof was processed. The CNamespaceManagement class creates an instance of WDMClassesOfDriver for each class extracted from the mof with the following properties:    Driver        The value of WMIBinaryMofResource.Name    ClassName     The name of the class    LowDateTime The value of the WMIBinaryMofResource.LowDateTime    HighDateTime  The value of WMIBinaryMofResource.HighDateTime        Maintaining the Namespace It is necessary to have clean up functions to do such actions as deleting stranded classes and old drivers, as it is possible that system crashes, or the user turning off the machine may leave binary mof processing in an unintended state.  Namespace maintenance is done only once, when the namespace is first opened and after all of the current binary mofs have been processed. A query to find drivers no longer WDM enabled will be built up while looping through the list of binary mofs ( via instances and/or drivers ).  This query will be: select * from WMIBinaryMofResource where Name !=  Once all binary mofs have been processed,  CNamespaceManagement class is called to do the following clean up actions: Delete any old drivers that may now be left stranded in the namespace by executing the query that was built above.  For each WMIBinaryMofResource instance returned, get the key of the instance and the high and low dates, if that isn t the one we just entered, then delete any classes that belongs to this unique combination.  This is done via the following query: Once all of the classes we have a record of have been successfully deleted, then delete the instance of WMIBinaryMofResource.  If any error was encountered, do NOT delete the instance of WMIBinaryMofResource. Deleting old classes of a specified driver The query to delete old classes of a specified unique driver is this: select * from WDMClassesOfDriver where Driver = x and (HighDateTime != 111) or (LowDateTime != 222) Now, just because we get a class name here doesn't mean we delete the class, this class could have been updated, in that case we just delete the instance of the WDMClassesOfDriver.  So, in order to check if this class REALLY needs to be deleted or not, we construct the key of the class name with the latest high and low date time of the driver that was passed into this function.  If we get the object, then we know the class is still valid and was simply updated, so just delete the instance of WDMClassesOfDriver with the old dates. If we did not get an instance, we must make certain no other driver owns the class as more than one driver may own a class.  If nobody else owns it, then delete the class definition.  To determine if someone else owns the class, the following query is used: "select * from WDMClassesOfDriver where ClassName = x and Driver != y If nothing is returned, then we know no other driver owns the class. Deleting stranded classes This is a maintenance function that deletes any classes that are not tied to drivers.  This can be determined with the following queries: First,  select * from WMIBinaryMofResource  to get a list of all current drivers in the system.  Initialize the final query,  select * from WDMClassesOfDriver where Driver !=   while looping through the list of drivers from the first query.  For each driver in the list, delete any old classes that do not have the matching high and low dates, accomplish this by calling the DeleteOldClasses function that was already described above. Then, execute the query that was built up, for each class that is returned via this query, delete the instance that was returned, then get the driver and classname, if someone else does t own this class ( remember, more than one driver can own a class ), then delete the class definition, otherwise leave it there.  Processing binary mofs via events After the initial processing when the namespace is first opened, the provider registers for two events, by initializing the global CWDMEvent pointer, this is an instance of the internal event provider class.  Once the pointer is successfully initialized, protected by critical sections, then the RegisterForWMIEvents function is called with the following GUIDS: BINARY MOFS ADDED B48D49A2-E777-11D0-A50C-00A0C9062910 BINARY MOFS DELETED  B48D49A3-E777-11d0-A50C-00A0C9062910 Upon successful registration for this event, the GUID that was successfully is entered into the internal event list.  These events are registered as LOCAL SYSTEM. When an event is received, the GUID is compared with the internal list, if it is determined to b one of the above, the name block is parsed ( for more information on the name and instance blocks, see the section regarding WNODES and parsing the data blocks ). The instance name residing in the name block contains two strings, the first string is the image path, the second is the resource path.  If both strings are filled out, we know we are dealing with a binary mof that is located in a driver, where we must locate the driver and extract the specified mof.  If just the resource name is filled out, then we know we are given a guid to query instances for. If we have received a BINARY MOFS DELETED event, then we delete all classes tied to that resource, and the instance in WMIBinaryMofResource. If we have received a BINARY_MOFS_ADDED event, then we send it to the same processing as above, once we have extracted the binary mof. The WDM APIs  (expensive and not-so-expensive calls regarding Handle Maps) Calls to the WDM APIs are wrapped by the classes CWDMStandardShell, CWDMHiPerfShell, and WDMDataBlock.   WDM deals only in GUIDS, so the class qualifier of GUID must be read in order to obtain the GUID to send to the WDM layer. This wrapper classes require a handle map of which there are two types, one handle map (WMIHandleMap) deals with requests coming via the instance, event, method, class provider, the other handle map ( WMIHiPerfHandleMap ) deals only with hi perf handles.  The purpose of the handle map is to keep the expensive handles open until the provider is unloaded or, as in the case of the hi perf classes, the class is no longer wanted.  The handle map is kept with the parent class, either the CWDM_Prov, CWDM_Event or CWDM_Perf and access is always protected by critical section.  Since the provider uses per-user initialization, each user will get their own handle map. When using a regular WMIHandleMap, and a request comes through, the handle map is checked to see if a handle for that guid is already open, if it is, it is reused, if it isn t, then the WmiQueryGuidInformation api is called to determine if the handle is expensive or not (a WMIGUIDINFORMATION parameter is returned ).  If it is expensive, then the handle is saved in the list and a flag is set, so it won t be closed.  The following information is saved about each handle: HANDLE WMIHandle      The handle returned by the WDM api WmiOpenBlock GUID   Guid           The GUID of the class used in WmiOpenBlock ULONG  uDesiredAccess A combination of the below access flags LONG   RefCount       For future use The access flags used are these: WMIGUID_QUERY- Read access only to the WDM api layer This permission is used for calls generated from CreateInstanceEnumAsync, CreateRefresher,  CreateRefreshableObject, CreateRefreshableEnum,Refresh,StopRefreshing, QueryInstances,  GetObjectAsync WMIGUID_NOTIFICATION | WMIGUID_QUERY   Read access and event access This permission is used for calls generated from ProvideEvents, NewQuery, CancelQuery, AccessCheck,  WMIEventCallback, ExecQueryAsync WMIGUID_QUERY|WMIGUID_EXECUTE- Read access only to the WDM api layer This permission is used for calls generated from the binary mof processing and ExecMethodAsync WMIGUID_SET|WMIGUID_QUERY   Read/Write access to the WDM api layer This permission is used for calls generated from PutInstanceAsync When using the WMIHiPerfHandleMap, all handles are automatically expensive, thereby cutting down processing time by not trying to determine if the handle is expensive or not, and assumes all access is WMIGUID_QUERY.  The handle is still checked and reused if possible.  The following information is saved about each handle: Need to document this after testing is completed. Handles are closed (via WmiCloseBlock) in the following conditions: If the handle was never designated as expensive to begin with, the handle is closed when the wrapper class destructs, usually after the status has been sent back to the core and the return code is returned. If the provider is unloaded, all handle maps, in their destructors, will loop through the remaining handles and close each of them. When a Hi Perf class is no longer needed. The WDM apis are documented in the WDM DDK, but here is a very brief overview.   In general, a call to WMIOpenBlock with the guid of the class is used to obtain a handle, the handle is used in all of the subsequent apis, after receiving the results in the form of WNODES, the handle is closed with WmiCloseBlock. To register for events, use WmiNotificationRegistration with the appropriate guid ( handles not used here ), and provide the entry point as a parameter, which WDM will call back into when the event triggers.   The first time an event is registered, the flag must be passed as NOTIFICATION_CALLBACK_DIRECT, there after, subsequent requests for the same GUID must pass the flag NOTIFICATION_CHECK_ACCESS. To cancel events, use WmiNotificationRegistration, with the appropriate guid ( handles are not used here ). To see if a handle is expensive, call WmiQueryGuidInformation. To set a single property, call WmiSetSingleItem. To execute a method, call WmiExecuteMethod. To get a list of instances, call WmiQueryAllData. To get a specific object, call WmiQuerySingleInstance. To write an instance, call WmiSetSingleInstance. To get a list of Hi Perf instances, call WmiQueryAllDataMultiple. To get a list of Hi Perf specific instances, call WmiQuerySingleInstanceMultiple. The query/object path is parsed using CObjectPathParser to get the class name, path or instance name. Return codes from these WDM Apis are mapped as follows:  WDM error return code WBEM return code ERROR_WMI_GUID_NOT_FOUND    ERROR_NOT_SUPPORTED     ERROR_INVALID_FUNCTION     ERROR_WMI_SERVER_UNAVAILABLE ERROR_WMI_INSTANCE_NOT_FOUND ERROR_WMI_GUID_DISCONNECTED  WBEM_E_NOT_SUPPORTED NO_DATA_AVAILABLE ERROR_INVALID_HANDLE WBEM_E_NOT_AVAILABLE ERROR_WMI_DP_FAILED WBEM_E_INVALID_OPERATION ERROR_WMI_READ_ONLY WBEM_E_READ_ONLY ERROR_INVALID_PARAMETER WBEM_E_INVALID_PARAMETER ERROR_INVALID_DATA WBEM_E_INVALID_PARAMETER ERROR_ACCESS_DENIED ERROR_INVALID_PRIMARY_GROUP ERROR_INVALID_OWNER   WBEM_E_ACCESS_DENIED All other errors WBEM_E_FAILED Parsing WNODES and Mapping Data Types The WDM layer returns all data in the form of WNODES.  Whenever an error occurs, these WNODES  and the raw data of the complete blocks, are dumped to the WMIPROV.log so the driver writer may see what was wrong in the WNODE construction. There are two types of WNODES, WNODE_SINGLE_INSTANCE and WNODE_ALL_DATA.  The single Wnode, as the name implies, contains a single instance, while the PWNODE contains one or more. Each of these WNODES contains a WNODE_HEADER, which contains such information as the total size of the buffer we are parsing, etc.  It is of vital importance to make sure we never step out of the WNDOE, use IsBadReadPtr to check every address before accessing it, make sure that we are never asked to read outside of the block. Each WNODE contains a WNODE_HEADER.  The provider uses this information in the following way: WNODE Field How it is used BufferSize This is used to calculate the max address we are allowed to read from, this max address is used every time we are given a size of  bytes to read, to make sure we never step outside the block. ProviderId Ignored, but logged Version The WDM Version   used in the WmiSetSingleItem call. Linkage The offset of the next WNODE.  If there is a value here, after all current instances in the current WNODE are read, this offset is applied to the beginning of the buffer, to find the address of the next WNODE_HEADER, and the whole process starts again. TimeStamp.LowPart Ignored, but logged TimeStamp.HighPart Ignored, but logged Guid of the class Flags WNODE_FLAG_FIXED_INSTANCE_SIZE   this simply lets us know we are dealing with fixed instances. WNODE_FLAG_TOO_SMALL  - This is tested whenever we successfully get a WNODE, always read the header to see if this flag is set, if it is, then requery with a bigger buffer. This must be done in addition to testing the return code for ERROR_INSUFFICIENT_BUFFER The provider uses the WNODE_ALL_DATA information in the following way: WNODE Field How it is used DataBlockOffset The pointer to the data block InstanceCount How many instances are in the WNODE OffsetInstanceNameOffsets The pointer to the beginning of the name block FixedInstanceSize If we are working with a fixed instance, then use this field to get the size.           OffsetInstanceData LengthInstanceData If we are NOT working with a fixed instance, then we use these two fields to find where the instance is located and how big it is. The provider uses the WNODE_SINGLE_INSTANCE information in the following way: WNODE Field How it is used DataBlockOffset The pointer to the data block InstanceIndex Ignored, but logged OffsetInstanceName The pointer to the beginning of the name block SizeDataBlock Since we always know this is a single instance, we are always dealing with fixed instances.         DumpByte(b1,pTmp,i,nCount);         DumpByte(b2,pTmp,i,nCount);         DumpByte(b3,pTmp,i,nCount); Getting Ready to Process a Data Block Data blocks can either be of fixed instance size or dynamic instance size, so before we read the data block, we must determine what type of data ptr we are working with and adjust it accordingly.   All data within the data blocks is naturally aligned.  After we read one of the blocks and are asked to read another one, we might have to adjust the data block pointer for the next instance, as all instances are always aligned on 8 bytes, and we might not have ended on an 8 byte boundary. If we are working with a fixed instance, the first time we come through, simply set the data pointer to the value specified in the WNODE.  If it is NOT the first time, then we must adjust the data pointer for the fixed instance size and make sure we are aligned on an 8 byte boundary before we continue.   This is accomplished by always keeping an accumulative size of the block ( how many total bytes we have processed so far of the last data block ) .  We can simply test if the accumulative size is smaller than the fixed instance size, the data pointer is incremented by ( fixed instance size   accumulative size ).  Then, make sure the data is aligned on an 8 byte boundary. If we are dealing with a dynamic instance, the accumulative size of the block is set to 0.  The OffsetInstanceData field of the WNODE is an array of ULONGS that specifies the offets to the data blocks for each instance.  There is an array of InstanceCount ULONGS followed by data blocks. The first then we do is see if the current pointer points to NULL, if it does, we know we don t have a data block to read, so we are at the end.   Otherwise, the ULONG the current data pointer points to is the instance size of the data block we are about to read.  The next ULONG is the offset from the beginning of the buffer where the data block is, we are already guaranteed it is on an 8 byte boundary.  We must calculate the address to point to by adding the offset to the beginning of the buffer.  Since this is a common operation, use the following macro: #define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset)) Where Base is the pointer of the WNODE returned by the WDM api, and Offset is the offset we just read from the block. Processing a Name Block The name block contains the names of the instances.  The name block is in a separate location from the data block, and is simply a list of strings   read as a WORD which specifies how many of the next bytes belongs to the string .  Name blocks and Data blocks are positionally matched, if there are three names in the name block, then there are three data blocks to match, the first belongs with the first, and so on.  If there is ever a mismatch, then error out immediately. The address of the name block is calculated by adding the offset (already determined above based on the type of WNDOE ) to the beginning of the WNODE, using OffsetToPtr macro.  If we are dealing with an WNODE_ALL_DATA block, this must be incremented each time, as the name offset points to an array of ULONGS which is an array of offsets for each instance s name. Processing a Binary Mof Data Block Binary mofs may be sent in data blocks, via events.  This is documented in the following section: Processing Binary Mofs and Managing the Namespace - Processing binary mofs via events Binary Mofs do not have corresponding name blocks.  One other note, the CRC is calculated by getting the InstanceSize from a WNODE_ALL_DATA, or SizeDataBlock from a WNODE_SINGLE_INSTANCE. Processing a Data Block Data blocks are read and written according to the WMIDATAID qualifiers.  These provide the road map to reading/writing a data block.  Before we even begin processinga data block, we have already gotten this information in the CWDMProcessClass object, and use this information to interpret the block. Data blocks are also naturally aligned, every data type is aligned on its natural boundary, with the exception of embedded classes, these are aligned on the largest data type within the class. Initializing the pointer to the data block is done differently, depending on what type of node we are dealing with. If we are dealing with a WNODE_ALL_DATA fixed instance, the data pointer is simply calculated by adding the DataBlockOffset to the beginning of the WNODE, using OffsetToPtr. If we are dealing with a WNODE_ALL_DATA dynamic instance, the data pointer is calculated by reading a ULONG at the OffseInstanceDataAndLength address, then the data pointer follows it.  The ULONG is the size of the instance. If we are dealing with a WNODE_SINGLE_INSTANCE, we know it is fixed, and the data pointer is initialized by adding the DataBlockOffset to the beginning of the WNODE. Once the data pointer is initialized, the MaxPointer is set by adding the buffer size to the base WNODE pointer.  This is to identify the maximum value we can safely read.  By always comparing our pointers to this value and using IsBadReadPtr, we are assured to always stay within the block, if directed to read outside the block, then error out immediately.  All reads must be checked before actually read. The data block is parsed by simply looping through the list of properties provided by the CWDMProcessClass object, and reading the number of bytes for each property specified, following the data type rules in the following section.  After the data is translated from WDM data types to CIM_TYPES, they are added to the wbem instance via the CWDMProcessClass interface, and the instance is returned to WMI. There are two types of arrays in a WNODE, fixed and dynamic.  Fixed arrays are specified by a qualifier of MAX on the property, and the array contains the number of elements specified in this qualifier   this information is already known at the time of reading the block.  The size of dynamic arrays are specified by the property contained in the WMISIZEIS qualifier on the array property, the property specified in this qualfier must be read first in order to determin the number of elements to read for the array from the datablock. Some properties have a qualifier of  MissingValue , this is only supported for the following data types:  CIM_SINT8 CIM_SINT32 CIM_UINT32 CIM_UINT16 CIM_SINT64 CIM_UINT64 CIM_UINT8 CIM_BOOLEAN If the value just read from the data block matches the  MissingValue  qualifier, then we need to set the property to NULL.  This is also supported for arrays of the above data types. For WNODE_ALL_DATA, after processing a complete WNODE, we need to check to see if there are any more.  If dealing with dynamic WNODES, we need to check the WnodeHeader.Linkage field.  If it is 0, then we are at the end of the list, otherwise, it specifies an offset we need to use to calculate the address of the next WNODE, using the OffsetToPtr macro.  We then need to go to the address, and read the header for that WNODE, to see how many instances are in the WNODE, the new address of the name block and data blocks, etc. Writing a Data Block Data blocks are read and written according to the WMIDATAID qualifiers.  These provide the road map to reading/writing a data block.  WDM data types are not necessarily the same as CIM types, for example, the WDM BOOL is 1 byte.  All data types must be converted before being written to the data block. It is important to remember, when writing data types, for all data types that have NULL values, we must test to see if a MissingValue qualifier is present on the property, and if it is, we must write the value specified in that qualifier, instead of the NULL value. All data types must be naturally aligned within the data block, and when writing an embedded class, the embedded class is aligned on the largest data type within the class. Input and Output parameters for methods are also constructed as data blocks, following the same rules as the instance data block. Writing a complete instance When PutInstanceAsync is called, the context is checked for the value   __PUT_EXT_PROPERTIES".  If it is not set, then we know to write the complete instance to a data block. Writing a single property When PutInstanceAsync is called, the context is checked for the value   __PUT_EXT_PROPERTIES".  If this value exists, then we are to set the properties calling WmiSetSingleItem for each property that is in the list and writing a data block containing just the one property, instead of writing the complete instance to a data block. Writing arrays of data types  There are two types of arrays in a WNODE, fixed and dynamic.  Fixed arrays are specified by a qualifier of MAX on the property, and the array that is written must match the number of elements specified in this qualifier.  The size of dynamic arrays are specified by the property contained in the WMIDATASIZE qualifier on the array property, the number of elements must be written to this property in the datablock at the specified place. All data types must be naturally aligned within the data block, and when writing an array of embedded classes, the embedded class must be aligned on the largest data type within the class. Data Type Mapping The following is a table showing how the WDM data types differ from the CIM TYPES.  The utility class CWMIDataTypeMap automatically converts the types for both reading and writing purposes.  In general, the differences are as follows: WDM Type Used CIM Type SINT64 CIM_STRING QWORD Unsigned __int64 UINT64 CIM_STRING A string: WORD+ NUMBER OF BYTE SPECIFIED IN WORD CIM_STRING CIM_CHAR CIM_UINT8 DWORD CIM_SINT32 CIM_UINT32 CIM_UINT16 DOUBLE CIM_REAL64 BOOLEAN   ONE BYTE CIM_BOOLEAN SHORT CIM_SINT16 CIM_SINT8 CIM_CHAR16 CIM_REAL32 50 BYTES CIM_DATETIME Managing the Class/Access Objects and Communicating with the Core The CWMIManagement class contains all of the information needed to communicate to the core, such as the IwbemServices, IwbemContext, IwbemObjectSink and HandleMap pointers. Error handling is accomplished by logging information to the WMIPROV.LOG, and sending back extended error objects, containing such information as the specific error codes returned when a WDM api fails, or a list of privileges needed by the user if an access denied error code is returned from WDM.   If the provider is running in HiPerf mode, access to the class is handled via IWbemObjectAccess, and handles are used to access properties, otherwise,  IWbemClassObject is used to access the properties of a class. Regardless of which mode the provider is running in, the first thing that happens, once one of the shell classes is instantiated, the information of the class is stored in the CWDMProcessClass object.  The CWDMProcessClass object sets the class name, gets the GUID ( from the guid class qualifier ), then gets the order of the WDM properties, by looping through all properties of the class and creating a list of all properties containing the WMIDATAID qualifier and in the order specified by these qualifiers.  This is the mapping by which the data block is parsed.  The following information is stored about each property: pwcsPropertyName     The name of the property pwcsEmbeddedObject    The name of the class, if it is an embedded object ltype                The CIMTYPE nWMISize             The size of bytes in WDM terms    lHandle              The handle, if we are using Hi Perf    dwArraySize          The max size of the array, whether by MAX or                          by WMISIZEIS    fPutProperty         If this property is writable. A special note here, we must deal with WMIDATAIDs that legally start with a 0 or a 1.  This must be kept in mind when looping through the list of properties, which is NOT returned in WMIDATAID order.  In general, WMIDATAIDs generated by MOFCOMP for methods start with 0, where WMIDATAIDs provided by driver writers start with 1. Only properties with WMIDATAID qualifiers will be stored in this mapping list, system properties, etc. are NOT included. The CWDMProcessClass object basically is the interface for any actions that take place within the class, such as getting/setting properties, getting qualifier information, etc.  It will use IWbemClassObject when running for the CWDMStandardShell ( the normal provider actions ) or will use IWbemObjectAccess when running for the CWDMHiPerfShell ( the Hi perf provider actions). The Standard and HiPerf Shells The CWDMStandardShell is the public interface to provide standard access to WDM functionality.  The WDMHiPerfShell is for hi performance functionality only.  These are the only two interfaces exposed from the WDM Lib that the WMIPROV.DLL uses. In the CWDMHiPerfShell, only the following data types will be supported:  DWORD and QWORD.  All other data types will cause the class to return WBEM_E_INVALID_OBJECT and the instance will not be added. When the provider methods are invoked in the WMIPROV.DLL, it creates the appropriate shell, initializes it with the IwbemServices, IwbemContext, etc. pointers and calls the public high level functions to perform the requested action. The shell constructors will set all the necessary pointers, but must be initialized with a class name to all of the information of the class it is dealing with before it may be used.  If the class is not valid, the initialization will fail. The CWDMStandardShell exposes the following interfaces: HRESULT Initialize(WCHAR * wcsClass); wcsClass    The name of the class This function initializes all of the information needed about the class, such as getting the guid to communicate with WDM and getting the mapping of the data block. HRESULT ProcessAllInstances(); This function queries WDM for all of the instances for the class that has already been initialized ( in response to CreateInstanceEnum). HRESULT ProcessSingleInstance( WCHAR * wcsInstanceName);       wcsInstanceName    The RELPATH This function queries WDM for the single instance specified ( in response to GetObjectAsync). HRESULT FillInAndSubmitWMIDataBlob( IWbemClassObject * pIClass, int                                       nTypeOfPut, CVARIANT & vList); pIClass      The class to be written nTypeOfPut   A flag specifying PUT_WHOLE_INSTANCE or PUT_SINGLE_PROPERTY VList        If this is a PUT_SINGLE_PROPERTY, then this is the list              Of properties to put individually.  This function writes either a property or an instance, depending on the value in nTypeOfPut ( in response to PutInstanceAsync ) HRESULT ProcessEvent(WORD wBinaryMofType, PWNODE_HEADER WnodeHeader); wBinaryMofType     If this is a binary mof event, it specifies whether                      the mof is being added or deleted. WnodeHeader        The WNODE that was sent when the event triggered. This function sends off the event it just received to be processed  ( in response to WDM calling the event callback function ).  Actions taken would be:  mof added, mof deleted, an instance of a class parsed and sent into WMI. HRESULT  RegisterWMIEvent( WCHAR * wcsGuid, ULONG uContext, CLSID &                             Guid, BOOL fRegistered) wcsGuid      The character form of the guid of the class to register uContext     The address of the callback function Guid         The guid that was sent to WDM fRegistered  If this event was already registered before or not. This function is called when the provider registers for events, either as  local system, for binary mofs added and deleted or when the consumer of the WDMEvent Provider has sent a new query ( in response to NewQuery). HRESULT ExecuteMethod( WCHAR * wcsInstance,                                                   WCHAR * MethodInstanceName,                        IWbemClassObject * pParentClass,                      IWbemClassObject * pInClassData,                         IWbemClassObject * pInClass,                         IWbemClassObject * pOutClass ) WcsInstance           The instance name of the object to execute the method on MethodInstanceName    The name of the method to execute PparentClass          The class of the object we are executing the method on PinClassData          The instance of the input data PinClass              The input class definition POutClass             The output class definition This function is called when the provider wishes to execute a method on a specific WDM instance. The method is executed, any instances of the output class are sent to WMI.  ( in response to ExecMethodAsync) BOOL CancelWMIEventRegistration( GUID gGuid , ULONG uContext ) gguid        The guid of the event to cancel uContext     The address of the EventCallback function This function is called when the provider wishes to cancel registration for an event, either when the provider unloads and it is canceling the binary mof added/deleted events, or in response to a consumer request ( in response to CancelQuery )       HRESULT SetErrorMessage(HRESULT hr)  A utility function that sets information in the extended error object, if needed, and returns the status and hr to WMI. The CWDMHiPerfShell exposes the following interfaces: HRESULT QueryAllHiPerfData() This function queries WDM for a complete list of instances ( in response to QueryInstances ).  Calls WmiQueryAllDataMultiple. HRESULT HiPerfQuerySingleInstances(long lNumObjects,                                  IWbemObjectAccess** apObj) This function queries WDM for the specified objects, calls WmiQueryAllDataMultiple. HRESULT AddAccessObjectToRefresher(IWbemObjectAccess *pAccess,                                     IWbemObjectAccess ** ppRefreshable,                                     LONG * plId) This function adds the IWbemObjectAccess object to the HiPerfHandle map and returns a unqiue id. HRESULT AddEnumeratorObjectToRefresher(IWbemHiPerfEnum* pHiPerfEnum,                                         long* plId) This function adds the IWbemHiPerfEnum object to the HiPerfHandle map and returns a unqiue id. HRESULT RemoveObjectFromHandleMap(long lHiPerfId) This function removes an object from the hi perf handle map that matches the specific id, this could either be an enumerator or an instance.  If it is the last one, then the WDM handle is removed from the regular handle map and the WDM handle is closed.  ( this is in response to StopRefreshing ) HRESULT RefreshCompleteList() This function queries WDM for a complete list of instances ( in response to Refresh) that are tied to a specific refresher. HRESULT SetErrorMessage(HRESULT hr) A utility function that sets information in the extended error object, if needed, and returns the status and hr to WMI. The  WMI MOF ( wmi.mof) The WMI.MOF will be updated to include the Hi Perf provider as follows: //*************************************************************  1998-1999 Microsoft Corporation.  All rights reserved. //************************************************************* #pragma autorecover #pragma classflags("forceupdate") //************************************************************* //*** Creates namespace for WMI //************************************************************* #pragma namespace ("\\\\.\\Root") instance of __Namespace     Name = "WMI"; //************************************************************* //*** Changes focus to new namespace //************************************************************* #pragma namespace ("\\\\.\\Root\\WMI") // HiPerfProvider: instance of __Win32Provider as $PPerf     Name="WDMHiPerf ";     CLSID=" {F5280F80-0D8C-4fb7-B60D-CEB99AB45DBC}";    PerUserInitialization = "TRUE"; instance of __InstanceProviderRegistration     Provider = $PPerf;     SupportsGet = TRUE;     SupportsEnumeration = TRUE;  DATE  3/17/2000 Microsoft Confidential Page   PAGE  \* MERGEFORMAT   DOCPROPERTY "Product"  \* MERGEFORMAT   Specification   TITLE  \* MERGEFORMAT  Unassigned MICROSOFT CONFIDENTIAL CWDMStandardShell CWDMHiPerfDataBlock  CWDMStandardDataBlock CWMI_Prov: Hi perf provider [WMIHiPerfHandleMap] CWMI_Prov: Instance, method, class provider. [WMIHandleMap] CWDMHiPerfShell CWMI_IDOrder CWMIManagement CWMI_Event The event provider [WMIHandleMap] CWDMProcessClass CWMI_Prov The instance, method, class, and hi perf provider.   MSO Palette  )$+*($''-2@7-0=0''8L9=CEHIH+6OUNFT@GHE !E.'.EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE 1A"Qa /[Vi: FVo|I3 ybH~n5A ):m"$ I F}q] q[V0<V *73X4uJ ;PGxR iI!@* Sxp:D VW6)bd K$O'>>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\cfgmgr32.doc ===
Microsoft Word Document MSWordDoc Word.Document.6Microsoft Cairo Setup Application Programming InterfaceCairo Setup Application Programming Interface Spec for Setup APIs available in Cairo Bret Grinslade Setup, API This spec details the APIs exposed in the setupnt.dll. Normal.dot Andrew Krywaniuk Microsoft Word for Windows 95Windows NT Group 32-Bit Configuration Manager Application Programming Interface  TOC \o "1-3"  1. Overview  GOTOBUTTON _Toc364568172    PAGEREF _Toc364568172  2. The Configuration Manager APIs  GOTOBUTTON _Toc364568173    PAGEREF _Toc364568173  2.1 Data Structures  GOTOBUTTON _Toc364568174    PAGEREF _Toc364568174  2.1.1 Memory Resource  GOTOBUTTON _Toc364568175    PAGEREF _Toc364568175  2.1.2 I/O Port Resource  GOTOBUTTON _Toc364568176    PAGEREF _Toc364568176  2.1.3 DMA Resource  GOTOBUTTON _Toc364568177    PAGEREF _Toc364568177  2.1.4 Interrupt Resource  GOTOBUTTON _Toc364568178    PAGEREF _Toc364568178  2.1.5 Class-Specific Resource  GOTOBUTTON _Toc364568179    PAGEREF _Toc364568179  2.1.6 Hardware Profile Information  GOTOBUTTON _Toc364568180    PAGEREF _Toc364568180  2.1.7 Miscellaneous  GOTOBUTTON _Toc364568181    PAGEREF _Toc364568181  2.2 Routines  GOTOBUTTON _Toc364568182    PAGEREF _Toc364568182  2.2.1 CM_Add_Empty_Log_Conf  GOTOBUTTON _Toc364568183    PAGEREF _Toc364568183  2.2.4 CM_Add_Res_Des  GOTOBUTTON _Toc364568184    PAGEREF _Toc364568184  2.2.13 CM_Free_Log_Conf  GOTOBUTTON _Toc364568185    PAGEREF _Toc364568185  2.2.15 CM_Free_Res_Des  GOTOBUTTON _Toc364568186    PAGEREF _Toc364568186  2.2.16 CM_Get_Child  GOTOBUTTON _Toc364568187    PAGEREF _Toc364568187  2.2.18 CM_Get_Device_ID  GOTOBUTTON _Toc364568188    PAGEREF _Toc364568188  2.2.19 CM_Get_Device_ID_Size  GOTOBUTTON _Toc364568189    PAGEREF _Toc364568189  2.2.20 CM_Get_DevNode_Status  GOTOBUTTON _Toc364568190    PAGEREF _Toc364568190  2.2.21 CM_Get_First_Log_Conf  GOTOBUTTON _Toc364568191    PAGEREF _Toc364568191  2.2.23 CM_Get_Hardware_Profile_Info  GOTOBUTTON _Toc364568192    PAGEREF _Toc364568192  2.2.24 CM_Get_HW_Prof_Flags  GOTOBUTTON _Toc364568193    PAGEREF _Toc364568193  2.2.25 CM_Get_Next_Log_Conf  GOTOBUTTON _Toc364568194    PAGEREF _Toc364568194  2.2.26 CM_Get_Next_Res_Des  GOTOBUTTON _Toc364568195    PAGEREF _Toc364568195  2.2.27 CM_Get_Parent  GOTOBUTTON _Toc364568196    PAGEREF _Toc364568196  2.2.28 CM_Get_Res_Des_Data  GOTOBUTTON _Toc364568197    PAGEREF _Toc364568197  2.2.29 CM_Get_Res_Des_Data_Size  GOTOBUTTON _Toc364568198    PAGEREF _Toc364568198  2.2.30 CM_Get_Sibling  GOTOBUTTON _Toc364568199    PAGEREF _Toc364568199  2.2.31 CM_Get_Version  GOTOBUTTON _Toc364568200    PAGEREF _Toc364568200  2.2.34 CM_Locate_DevNode  GOTOBUTTON _Toc364568201    PAGEREF _Toc364568201  2.2.36 CM_Modify_Res_Des  GOTOBUTTON _Toc364568202    PAGEREF _Toc364568202  2.2.48 CM_Set_HW_Prof_Flags  GOTOBUTTON _Toc364568203    PAGEREF _Toc364568203  2.3 New Routines  GOTOBUTTON _Toc364568204    PAGEREF _Toc364568204  2.3.1 CM_Get_DevNode_Registry_Property  GOTOBUTTON _Toc364568205    PAGEREF _Toc364568205  2.3.2 CM_Set_DevNode_Registry_Property  GOTOBUTTON _Toc364568206    PAGEREF _Toc364568206  2.3.3 CM_Open_DevNode_Key  GOTOBUTTON _Toc364568207    PAGEREF _Toc364568207  2.3.4 CM_Delete_DevNode_Key  GOTOBUTTON _Toc364568208    PAGEREF _Toc364568208  2.3.5 CM_Open_Class_Key  GOTOBUTTON _Toc364568209    PAGEREF _Toc364568209  2.3.6 CM_Enumerate_Classes  GOTOBUTTON _Toc364568210    PAGEREF _Toc364568210  2.3.7 CM_Get_Class_Name  GOTOBUTTON _Toc364568211    PAGEREF _Toc364568211  2.3.8 CM_Enumerate_Enumerators  GOTOBUTTON _Toc364568212    PAGEREF _Toc364568212  2.3.9 CM_Get_Device_ID_List  GOTOBUTTON _Toc364568213    PAGEREF _Toc364568213  2.3.10 CM_Get_Device_ID_List_Size  GOTOBUTTON _Toc364568214    PAGEREF _Toc364568214  2.3.12 CM_Connect_Machine  GOTOBUTTON _Toc364568215    PAGEREF _Toc364568215  2.3.13 CM_Disconnect_Machine  GOTOBUTTON _Toc364568216    PAGEREF _Toc364568216  2.3.14 CM_Free_Log_Conf_Handle  GOTOBUTTON _Toc364568217    PAGEREF _Toc364568217  2.3.15 CM_Free_Res_Des_Handle  GOTOBUTTON _Toc364568218    PAGEREF _Toc364568218  2.3.16 CM_Detect_Resource_Conflict  GOTOBUTTON _Toc364568219    PAGEREF _Toc364568219  1. Overview This document describes the 32-bit implementation of the Configuration Manager APIs.  These APIs provide routines to control and configure devices in a Plug & Play environment.  In Windows 95, the Configuration Manager is a VxD, and it exposes these routines as services to both ring 0 and ring 3 components.  In Windows NT, however, these routines will expose functionality from the user-mode Plug&Play manager, thus are exclusively user-mode APIs. The API set presented here is the common subset of APIs that will be shared by a future version of Windows 95 as well as Windows NT.  Windows 95 provides additional CM APIs today in their 16-bit implementation, some of which they may provide in their 32-bit version as well.  These Win95-specific routines will return CR_CALL_NOT_IMPLEMENTED under Windows NT. The structures and routines have been kept as close to their 16-bit counterparts as possible--only expanding the fields and parameters where necessary.  In certain cases, parameters were expanded even larger to represent the larger capacity of Windows NT (e.g. memory ranges are 64-bit). One other important point to note regards synchronization.  In the current (16-bit) implementation, there exist CM APIs that lock the Configuration Manager, thus ensuring that the machine s state doesn t change while someone is in the middle of configuration, enumeration, etc.  Such global locking mechanisms are incompatible with Windows NT goals of concurrency, robustness, etc., so these APIs will not be implemented on Windows NT.  Atomicity will be ensured within a single CM call, but no assumptions can be made about the consistency of state from one call to the next.  Applications will have to be prepared to deal with the situation where, for example, they are enumerating all sibling device instances and, when halfway through, receive a CR_NO_SUCH_DEVNODE, because the parent device instance was removed.  This is analogous to the way registry enumeration must be handled (e.g., calling RegQueryInfoKey returns that there are 5 subkeys of the specified key, but subsequent attempts at enumerating them fail because someone else has deleted them in the meantime).  Indeed, it should be noted that Windows 95 relies on the registry for the storage of much of its Plug & Play configuration information, and therefore is still vulnerable to some extent to asynchronous changes happening that change the system s state, even while CM_Lock is held. The 32-bit Configuration Manager routines are defined to support both the Unicode and ANSI string set (as with other Win32 routines, the corresponding Unicode or ANSI version of the routine is called based on whether UNICODE is defined or not). The Unicode versions will return CR_CALL_NOT_IMPLEMENTED on Windows 95. The Windows NT implementation of these routines is remotable to remote machines via a set of extended configuration manager routines (CM_xxx_Ex). A caller can connect to a remote machine by calling CM_Connect_Machine. The handle returned in that call can then be passed to other extended Configuration manager routines. This feature is only implemented on Windows NT. 2. The Configuration Manager APIs 2.1 Data Structures 2.1.1 Memory Resource The following flags specify attributes for a memory range.  Each bit flag is identified with a constant bitmask, and two additional constants are associated with it specifying the values generated by AND ing the attribute value with the bitmask. fMD_MemoryType (0x1)  Bitmask for flag indicating whether the memory range may be written to.  The two possible values are: fMD_ROM (0x0)  Memory range is read-only fMD_RAM (0x1)  Memory range may be written to fMD_32_24 (0x2)  Bitmask for flag indicating whether the memory range is 24 or 32-bit.  Under Windows NT, this flag will always specify 32-bit memory.  The two possible values are: fMD_24 (0x0)  Memory range is 24-bit (e.g., ISA PnP).  This flag will never be set on Windows NT. fMD_32 (0x2)  Memory range is 32-bit fMD_Prefetchable (0x4)  Bitmask for flag indicating whether the memory range is prefetchable (i.e., does it support read-ahead caching?).  The two possible values are: fMD_PrefetchDisallowed (0x0)  Memory range is not prefetchable fMD_PrefetchAllowed (0x4)  Memory range is prefetchable fMD_Readable (0x8)  Bitmask for flag indicating whether the memory range may be read.  The two possible values are: fMD_ReadAllowed (0x0)  Memory range is readable fMD_ReadDisallowed (0x8)   Memory range is write-only fMD_CombinedWrite (0x10)  Bitmask for flag indicating whether the memory range supports combined-write (i.e., write-behind) caching.  The two possible values are: fMD_CombinedWriteDisallowed (0x0)  Memory range does not support combined-write caching fMD_CombinedWriteAllowed (0x10)  Memory range supports combined-write caching typedef struct Mem_Range_s { DWORDLONG MR_Align; ULONG MR_nBytes; DWORDLONG MR_Min; DWORDLONG MR_Max; DWORD MR_Flags; DWORD MR_Reserved; } MEM_RANGE, *PMEM_RANGE; MEM_RANGE Structure: MR_Align  Specifies the mask for the base alignment. MR_nBytes  Specifies the number of bytes required. MR_Min  Specifies the minimum address of the range. MR_Max  Specifies the maximum address of the range. MR_Flags  Specifies flags describing the range.  May be a combination of the fMD flags described above typedef struct Mem_Des_s { DWORD MD_Count; DWORD MD_Type; DWORDLONG MD_Alloc_Base; DWORDLONG MD_Alloc_End; DWORD MD_Flags; DWORD MD_Reserved; } MEM_DES, *PMEM_DES; MEM_DES Structure: MD_Count  Specifies the number of MEM_RANGE structs in the MEM_RESOURCE structure that this struct is contained in. MD_Type  Specifies the size, in bytes, of the MEM_RANGE structure (used for versioning).  This should be set to MType_Range. MD_Alloc_Base  Specifies the base memory address of the range that was allocated. MD_Alloc_End  Specifies the end of the allocated memory range. MD_Flags  Specifies flags describing the allocated range.  May be a combination of the fMD flags described above. typedef struct Mem_Resource_s { MEM_DES MEM_Header; MEM_RANGE MEM_Data[ANYSIZE_ARRAY]; } MEM_RESOURCE, *PMEM_RESOURCE; MEM_RESOURCE Structure: MEM_Header  Specifies information about the memory range list, as well as the currently allocated memory range. MEM_Data  Contains the list of memory ranges.  The count of memory ranges in this array is given by the MD_Count field in the MEM_Header. 2.1.2 I/O Port Resource The following flags specify attributes for a IO port range.  Each bit flag is identified with a constant bitmask, and two additional constants are associated with it specifying the values generated by AND ing the attribute value with the bitmask. fIOD_PortType (0x1)  Bitmask for flag indicating whether the port is memory or IO.  The two possible values are: fIOD_Memory (0x0)  The Port resource is memory fIOD_IO (0x1)  The Port resource is IO typedef struct IO_Range_s { DWORDLONG IOR_Align; DWORD IOR_nPorts; DWORDLONG IOR_Min; DWORDLONG IOR_Max; DWORD IOR_RangeFlags; DWORDLONG IOR_Alias; } IO_RANGE, *PIO_RANGE; IO_RANGE Structure: IOR_Align  Specifies the mask for the base alignment IOR_nPorts  Specifies the number of ports IOR_Min  Specifies the minimum port address IOR_Max  Specifies the maximum port address IOR_RangeFlags  Specifies flags for this port range IOR_Alias  Specifies a multiplier that generates all aliases for the port(s).  This number is right-shifted by 8 bits, removing the least-significant byte (thus forcing it to always be zero), so the real multiplier is IOR_Alias * 256.  The minimum alias is 4. Remarks: The Alias mask provide additional flexibility in specifying how the address is handled. It provides a convenient method for specifying what port aliases a card responds to. An alias is a port address that is responded to as if it were another address.  The following table illustrates the most common alias values: Specifies that the card supports 16-bit decode Specifies that the card supports 10-bit decode (i.e., 3f2, 7f2, ...) Specifies that the card supports 12-bit decode (i.e., 3f2, 13f2, ...) This is a special value, it specifies positive decode for a PCI device. E.g., an ISA card may decode 10 bits and require port 03C0h. It would need to specify an Alias offset of 04h. For convenience, the alias field can be set to zero indicate no aliases are required. typedef struct IO_Des_s { DWORD IOD_Count; DWORD IOD_Type; DWORDLONG IOD_Alloc_Base; DWORDLONG IOD_Alloc_End; DWORD IOD_DesFlags; } IO_DES, *PIO_DES; IO_DES Structure: IOD_Count  Specifies the number of IO_RANGE structs in the IO_RESOURCE structure that this struct is contained in. IOD_Type  Specifies the size, in bytes, of the IO_RANGE structure (used for versioning).  This should be set to IOType_Range. IOD_Alloc_Base  Specifies the base of the allocated port range. IOD_Alloc_End  Specifies the end of the allocated port range. IOD_DesFlags  Specifies flags relating to the allocated port range typedef struct IO_Resource_s { IO_DES IO_Header; IO_RANGE IO_Data[ANYSIZE_ARRAY]; } IO_RESOURCE, *PIO_RESOURCE; IO_RESOURCE Structure: IO_Header  Specifies information about the I/O port range list, as well as the currently allocated I/O port range. IO_Data  Contains the list of I/O port ranges.  The count of I/O port ranges in this array is given by the IOD_Count field in the IO_Header. 2.1.3 DMA Resource The following flags specify attributes for a DMA resource range.  Each bit flag is identified with a constant bitmask, and additional constants are associated with it specifying the values generated by AND ing the attribute value with the bitmask. mDD_Width (0x3)  Bitmask for flags indicating the width of the DMA channel (byte, word, or dword).  The three possible values are: fDD_BYTE (0x0)  8-bit DMA channel fDD_WORD (0x1)  16-bit DMA channel fDD_DWORD (0x2)  32-bit DMA channel typedef struct DMA_Range_s { ULONG DR_Min; ULONG DR_Max; ULONG DR_Flags; } DMA_RANGE, *PDMA_RANGE; DMA_RANGE Structure: DR_Min  Specifies the minimum DMA port in the range DR_Max  Specifies the maximum DMA port in the range DR_Flags  Specifies flags describing the range.  May be one of the fDD flags described above.  This value must be the same as the DD_Flags value in the corresponding DMA_DES structure. typedef struct DMA_Des_s { DWORD DD_Count; DWORD DD_Type; DWORD DD_Flags; ULONG DD_Alloc_Chan; } DMA_DES, *PDMA_DES; DMA_DES Structure: DD_Count  Specifies the number of DMA_RANGE structs in the DMA_RESOURCE structure that this struct is contained in.  If this value is 0, then the DD_Req_Mask must be used to determine the possible DMA channels. DD_Type  Specifies the size, in bytes, of the DMA_RANGE structure (used for versioning).  This should be set to DType_Range. DD_Flags  Specifies flags describing the DMA channel.  May be one of the fDD flags described above. DD_Alloc_Chan  Specifies the DMA channel that was allocated. typedef struct DMA_Resource_s { DMA_DES DMA_Header; DMA_RANGE DMA_Data[ANYSIZE_ARRAY]; } DMA_RESOURCE, *PDMA_RESOURCE; DMA_RESOURCE Structure: DMA_Header  Specifies information about the DMA channel range list, as well as the currently allocated DMA channel. DMA_Data  Contains the list of DMA channel ranges.  The count of DMA channel ranges in this array is given by the DD_Count field in the DMA_Header. 2.1.4 Interrupt Resource The following flags specify attributes for an interrupt resource range.  Each bit flag is identified with a constant bitmask, and additional constants are associated with it specifying the values generated by AND ing the attribute value with the bitmask. mIRQD_Share (0x1)  Bitmask for flag indicating whether the IRQ may be shared.  The two possible values are: fIRQD_Exclusive (0x0)  The IRQ may not be shared fIRQD_Share (0x1)  The IRQ may be shared mIRQD_Edge_Level (0x2)  Bitmask for flag indicating whether the IRQ is edge- or level-sensitive.  The two possible values are: fIRQD_Level (0x0)  The IRQ is level-sensitive. fIRQD_Edge (0x2)  The IRQ is edge-sensitive. typedef struct IRQ_Range_s { ULONG IRQR_Min; ULONG IRQR_Max; ULONG IRQR_Flags; } IRQ_RANGE, *PIRQ_RANGE; IRQ_RANGE Structure: IRQR_Min  Specifies the minimum IRQ in the range IRQR_Max  Specifies the maximum IRQ in the range IRQR_Flags  Specifies flags describing the range.  May be one of the fIRQD flags described above.  This value must be the same as the IRQD_Flags value in the corresponding IRQ_DES structure. typedef struct IRQ_Des_s { DWORD IRQD_Count; DWORD IRQD_Type; DWORD IRQD_Flags; ULONG IRQD_Alloc_Num; ULONG IRQD_Affinity; } IRQ_DES, *PIRQ_DES; IRQ_DES Structure: IRQD_Count  Specifies the number of IRQ_RANGE structs in the IRQ_RESOURCE structure that this struct is contained in.  If this value is 0, then the IRQD_Req_Mask must be used to determine the possible IRQs. IRQD_Type  Specifies the size, in bytes, of the IRQ_RANGE structure (used for versioning).  This should be set to IRQType_Range.  If this value is zero, then the IRQ_RANGE list must not be used, and the IRQD_Req_Mask must be used instead to determine possible IRQs. IRQD_Flags  Specifies flags describing the IRQ.  May be one of the fIRQD flags described above. IRQD_Alloc_Num  Specifies the IRQ that was allocated. IRQD_Affinity  Specifies the affinity of the IRQ (a value of 0xFFFFFFFF means the interrupt can be serviced by any available processor) typedef struct IRQ_Resource_s { IRQ_DES IRQ_Header; IRQ_RANGE IRQ_Data[ANYSIZE_ARRAY]; } IRQ_RESOURCE, *PIRQ_RESOURCE; IRQ_RESOURCE Structure: IRQ_Header  Specifies information about the IRQ range list, as well as the currently allocated IRQ. IRQ_Data  Contains the list of IRQ ranges.  The count of IRQ ranges in this array is given by the IRQD_Count field in the IRQ_Header. 2.1.5 Class-Specific Resource There may only be one class-specific resource in a particular logical configuration.  This resource is ignored by all arbitrators, Device Manager, etc. #define GUID_STRING_LEN (39) // always 38 chars + terminating NULL typedef struct CS_Des_s { DWORD CSD_SignatureLength; DWORD CSD_LegacyDataOffset; DWORD CSD_LegacyDataSize; DWORD CSD_Flags; GUID CSD_ClassGuid; BYTE CSD_Signature[ANYSIZE_ARRAY]; } CS_DES, *PCS_DES; CS_DES Structure: CSD_SignatureLength  Specifies the size, in bytes, of the class-specific Plug&Play device signature stored at the beginning of the CSD_Signature buffer. CSD_LegacyDataOffset  Specifies the offset, in bytes, from the beginning of the CSD_Signature buffer where the legacy class-specific data begins.  For Windows NT, this data represents the existing contents of the CmResourceTypeDeviceSpecific partial resource descriptor in a CM_RESOURCE_LIST. CSD_LegacyDataSize  Specifies the size, in bytes, of the legacy data. CSD_Flags  No flags are currently defined for this resource type. CSD_ClassGuid  Specifies the class GUID for this signature. CSD_Signature  Variable-length buffer including the Plug&Play device signature and/or legacy class-specific data.  The format of both of these buffers is dependent upon the class specified by CSD_ClassGuid. typedef struct CS_Resource_s { CS_DES CS_Header; } CS_RESOURCE, *PCS_RESOURCE; CS_RESOURCE Structure: CS_Header  Specifies class-specific information about the device associated with this logical configuration. 2.1.6 Hardware Profile Information typedef struct HWProfileInfo_s { ULONG HWPI_ulHWProfile; TCHAR HWPI_szFriendlyName[MAX_PROFILE_LEN]; DWORD HWPI_dwFlags; } HWPROFILEINFO, *PHWPROFILEINFO; Hardware Profile Information Structure: HWPI_ulHWProfile  Handle of the hardware profile. HWPI_szFriendlyName  Friendly name of the hardware profile. HWPI_dwFlags  Flags relating to this hardware profile.  Currently, only bits 0 and 1 are used.  May be one of the following values: Hardware Profile Information Flags: CM_HWPI_NOT_DOCKABLE (0x00000000)  This machine is not dockable. CM_HWPI_UNDOCKED (0x00000001)  This hardware profile is for a docked configuration. CM_HWPI_DOCKED (0x00000002)  This hardware profile is for an undocked configuration. 2.1.7 Miscellaneous Standardized Return Value: typedef DWORD        RETURN_TYPE; typedef RETURN_TYPE  CONFIGRET; Device Instance Handle typedef DWORD        DEVNODE; typedef DEVNODE     *PDEVNODE; Device Instance Identifier typedef TCHAR       *DEVNODEID; The device instance ID specifies the registry path, relative to the Enum key , for a device instance.  For example:  Root\*PNP0500\0000. Logical Configuration Handle: typedef DWORD        LOG_CONF; typedef LOG_CONF    *PLOG_CONF; Resource Descriptor Handle: typedef DWORD        RES_DES; typedef RES_DES     *PRES_DES; Remote Machine Handle: typedef HANDLE       HMACHINE; typedef HMACHINE    *PHMACHINE; Resource ID: typedef ULONG        RESOURCEID; typedef RESOURCEID  *PRESOURCEID; This data type may take one of the following values: ResType_All (0x00000000)  Return all resource types ResType_None (0x00000000)  Arbitration always succeeds ResType_Mem (0x00000001)  Physical address resource ResType_IO (0x00000002)  Physical I/O address resource ResType_DMA (0x00000003)  DMA channels resource ResType_IRQ (0x00000004)  IRQ resource ResType_MAX (0x00000004)  Maximum known ResType ResType_Ignored_Bit (0x00008000)  Ignore this resource ResType_ClassSpecific (0x0000FFFF)  Class-specific resource Registry Key Open Disposition: typedef ULONG        REGDISPOSITION; This data type may take one of the following values: RegDisposition_OpenAlways (0x00000000)  Open the key if it exists, otherwise, create the key.  RegDisposition_OpenExisting (0x00000001)  Open the key only if it already exists. Priority: typedef ULONG        PRIORITY; This data type may take one of the following values: LCPRI_FORCECONFIG (0x00000000)  Coming from a forced config LCPRI_BOOTCONFIG (0x00000001)  Coming from a boot config LCPRI_DESIRED (0x00002000)  Preferable set (better performance) LCPRI_NORMAL (0x00003000)  Workable (acceptable performance) LCPRI_LASTBESTCONFIG (0x00003FFF)  CM only--do not use LCPRI_SUBOPTIMAL (0x00005000)  Not desired, but will work LCPRI_LASTSOFTCONFIG (0x00007FFF)  CM only--do not use LCPRI_RESTART (0x00008000)  Need to restart Windows LCPRI_REBOOT (0x00009000)  Need to reboot Windows LCPRI_POWEROFF (0x0000A000)  Need to shutdown/power-off the machine LCPRI_HARDRECONFIG (0x0000C000)  Need to change a jumper LCPRI_HARDWIRED (0x0000E000)  Cannot be changed LCPRI_IMPOSSIBLE (0x0000F000)  Impossible configuration LCPRI_DISABLED (0x0000FFFF)  Disabled configuration MAX_LCPRI (0x0000FFFF)  Maximum known LC Priority Range List Handle: typedef DWORD              RANGE_LIST; typedef RANGE_LIST        *PRANGE_LIST; Range Element Handle: typedef DWORD              RANGE_ELEMENT; typedef RANGE_ELEMENT     *PRANGE_ELEMENT; 2.2 Routines 2.2.1 CM_Add_Empty_Log_Conf This routine creates an empty logical configuration.  This configuration has no resource descriptor. CONFIGRET CM_Add_Empty_Log_Conf ( OUT PLOG_CONF plcLogConf, IN DEVNODE dnDevNode, IN PRIORITY Priority, IN ULONG ulFlags Parameters: plcLogConf  Address of a variable that receives the handle of the logical configuration. dnDevNode  Handle of a device instance.  This handle is typically retrieved by a call to CM_Locate_DevNode. Priority  Specifies the priority of the logical configuration.  (See Section   REF MiscDataStructs \* MERGEFORMAT   for list of possible Priority values.) ulFlags  Supplies flags relating to the logical configuration.  Must be either BASIC_LOG_CONF , BOOT_LOG_CONF, FILTERED_LOG_CONF, combined with either PRIORITY_EQUAL_FIRST or PRIORITY_EQUAL_LAST. Logical Configuration Flags: BASIC_LOG_CONF  Specifies the requirements list FILTERED_LOG_CONF  Specifies the filtered requirements list OVERRIDE_LOG_CONF  Specifies the filtered requirements list that overrides the FILTERED_LOG_CONF and BASIC_LOG_CONF. BOOT_LOG_CONF  Specifies the boot configuration (only one of these may exist for a particular device instance.  Attempting to add a boot log config to a devnode that already has one fails with the error CR_INVALID_LOG_CONF) FORCED_LOG_CONF  Specifies a configuration that was specifically chosen (typically via an INF or a user). ALLOC_LOG_CONF  Specifies the configuration the device is currently using. PRIORITY_EQUAL_FIRST  Same priority, new one is first PRIORITY_EQUAL_LAST  Same priority, new one is last Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_LOG_CONF, CR_INVALID_FLAG, CR_INVALID_POINTER, CR_OUT_OF_MEMORY. Remarks: Calling this API may invalidate the logical configuration handles returned by the CM_Get_First_Log_Conf and CM_Get_Next_Log_Conf routines.  To continue enumerating logical configurations after adding a logical configuration, always call CM_Get_First_Log_Conf to start again from the beginning.  When the logical configuration handle returned by CM_Add_Empty_Log_Conf is no longer needed, it should be freed by calling CM_Free_Log_Conf_Handle. Note: The CM_Add_Empty_Log_Config routine is used to create logical configurations of any valid Xxx_LOG_CONF type. When adding resource descriptors (by calling CM_Add_Res_Des), you also fill in one of the Xxx_RESOURCE structure fields. The Xxx_RESOURCE structure fields provide for describing both a specific resource (described in the Xxx_DES embedded structure) or a range of possible resources (described in one or more Xxx_RANGE embedded structures). The BASIC_LOG_CONF, FILTERED_LOG_CONF, and OVERRIDE_LOG_CONF logical configuration types describe a range of possible resource configurations. As such, the individual resource descriptors within those logical configurations will have one or more Xxx_RANGE structures filled out and the specific resource data fields of the Xxx_DES field will be ignored. Likewise, the ALLOC_LOG_CONF, BOOT_LOG_CONF, and FORCED_LOG_CONF logical configuration types describe a specific configuration. As such, the individual resource descriptors within those logical configurations will have a completely filled out Xxx_DES structure but will not contain any Xxx_RANGE structures (the count field in the Xxx_DES structure will be zero). 2.2.4 CM_Add_Res_Des This routine adds a resource descriptor to a logical configuration. CONFIGRET CM_Add_Res_Des ( OUT PRES_DES prdResDes, OPTIONAL IN LOG_CONF lcLogConf, IN RESOURCEID ResourceID, IN PVOID ResourceData, IN ULONG ResourceLen, IN ULONG ulFlags Parameters: prdResDes  Optionally specifies the address of a variable that receives a handle for the new resource descriptor. lcLogConf  Supplies the handle of the logical configuration to which the resource descriptor is added. ResourceID  Specifies the type of the resource.  Can be one of the ResType values defined in Section   REF MiscDataStructs \* MERGEFORMAT  ResourceData  Supplies the address of an IO_RESOURCE, MEM_RESOURCE, DMA_RESOURCE, IRQ_RESOURCE, or CS_RESOURCE structure, depending on the given resource type. ResourceLen  Supplies the size, in bytes, of the structure pointed to by ResourceData. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_LOG_CONF, CR_INVALID_POINTER, CR_INVALID_RESOURCE_ID, or CR_OUT_OF_MEMORY. Remarks: When the resource descriptor handle returned by CM_Add_Res_Des is no longer needed, it should be freed by calling CM_Free_Res_Des_Handle. 2.2.13 CM_Free_Log_Conf This routine frees a logical configuration and all resource descriptors associated with it. CONFIGRET CM_Free_Log_Conf ( IN LOG_CONF lcLogConfToBeFreed, IN ULONG ulFlags Parameters: lcLogConfToBeFreed  Supplies the handle of the logical configuration to free.  This handle must have been previously returned from a call to CM_Add_Empty_Log_Conf. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG or CR_INVALID_LOG_CONF. Remarks: This API may invalidate the logical configuration handles returned by the CM_Get_First_Log_Conf and CM_Get_Next_Log_Conf APIs.  To continue enumerating logical configurations, always use the CM_Get_First_Log_Conf API to start again from the beginning. 2.2.15 CM_Free_Res_Des This routine destroys a resource descriptor. CONFIGRET CM_Free_Res_Des ( IN PRES_DES prdResDes, IN RES_DES rdResDes, IN ULONG ulFlags Parameters: prdResDes  Supplies the address of the variable that receives the handle of the previous resource descriptor.  If rdResDes is the handle of the first resource descriptor, this address receives the handle of the logical configuration. rdResDes  Supplies the handle of the resource descriptor to be destroyed. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, CR_INVALID_RES_DES, or CR_NO_MORE_RES_DES. Remarks: This API returns CR_NO_MORE_RES_DES if rdResDes specifies the last resource descriptor. If this API does return the previous resource descriptor, then that resource descriptor handle should be freed (by calling CM_Free_Res_Des_Handle) when it is no longer needed. 2.2.16 CM_Get_Child This routine retrieves the first child of a given device instance. CONFIGRET CM_Get_Child ( OUT PDEVNODE pdnDevNode, IN DEVNODE dnDevNode, IN ULONG ulFlags Parameters: pdnDevNode  Supplies the address of the variable that receives the handle of the device instance. dnDevNode  Supplies the handle of the parent device instance. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_NO_SUCH_DEVNODE. 2.2.18 CM_Get_Device_ID This routine retrieves the device identifier for a device instance. CONFIGRET CM_Get_Device_ID ( IN DEVNODE dnDevNode, OUT PTCHAR Buffer, IN ULONG BufferLen, IN ULONG ulFlags Parameters: dnDevNode  Supplies the handle of the device instance for which to retrieve the device identifier. Buffer  Supplies the address of the buffer that receives the device identifier.  If this buffer is larger than the device identifier, the API appends a null-terminating character to the data.  If it is smaller than the device identifier, the API fills it with as much of the device identifier as will fit and returns CR_BUFFER_SMALL. BufferLen  Supplies the size, in characters, of the buffer for the device identifier. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_BUFFER_SMALL, CR_INVALID_DEVNODE, CR_INVALID_FLAG, or CR_INVALID_POINTER. 2.2.19 CM_Get_Device_ID_Size This routine retrieves the size of a device identifier from a device instance. CONFIGRET CM_Get_Device_ID_Size ( OUT PULONG pulLen, IN DEVNODE dnDevNode, IN ULONG ulFlags Parameters: pulLen  Supplies the address of the variable that receives the size in characters, not including the terminating NULL, of the device identifier.  The API sets the variable to 0 if no identifier exists.  The size is always less than or equal to MAX_DEVICE_ID_LEN. dnDevNode  Supplies the handle of the device instance. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_FLAG, or CR_INVALID_POINTER. Remarks: The device identifier for a device instance consists of the identifier of the enumerator immediately above this device in the hardware tree, the identifier of the device, and the instance number of the device.  For example, the device identifier for an Adaptec 1540c might be \isaenum\aha1540c\1.  Although in Windows 95, this string may be used as a key into the registry, the registry locations are different on Windows NT, and therefore this string should no longer be used for this purpose. The device identifier is limited to MAX_DEVICE_ID_LEN characters. 2.2.20 CM_Get_DevNode_Status This routine retrieves the status of a device instance. CONFIGRET CM_Get_DevNode_Status ( OUT PULONG pulStatus, OUT PULONG pulProblemNumber, IN DEVNODE dnDevNode, IN ULONG ulFlags Parameters: pulStatus  Supplies the address of the variable that receives the status flag of the device instance.  Can be a combination of the following values: Status Flags: DN_HAS_PROBLEM  The device installer is required to resolve conflicts. DN_NEED_TO_ENUM  The device instance may need reenumeration. DN_ROOT_ENUMERATED  The device instance was enumerated by the root. DN_STARTED  The device instance is currently configured. DN_MOVED  The device instance has been moved. DN_DISABLEABLE  The device instance may be reconfigured. DN_REMOVABLE  The device instance may be removed. DN_WILL_BE_REMOVED  The device instance is being removed. pulProblemNumber  Supplies the address of the variable that receives an identifier indicating the problem.  Can be one of the following values: Problem Values: CM_PROB_DISABLED  The device instance is disabled. CM_PROB_NOT_CONFIGURED  There is no configuration for this device. CM_PROB_NEED_RESTART  The problem requires a shutdown-restart. CM_PROB_WILL_BE_REMOVED  The device instance will be removed. CM_PROB_FAILED_INSTALL  The installation of this device instance was unsuccessful. CM_PROB_FAILED_START  The driver for this device instance failed to start CM_PROB_REINSTALL  This device instance needs to be installed CM_PROB_MOVED   The device instance has been moved. dnDevNode  Supplies the handle of the device instance for which to retrieve status. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_FLAG, or CR_INVALID_POINTER. 2.2.21 CM_Get_First_Log_Conf This routine returns a handle to the first logical configuration of the specified type in a device instance. CONFIGRET CM_Get_First_Log_Conf ( OUT PLOG_CONF plcLogConf, IN DEVNODE dnDevNode, IN ULONG ulFlags Parameters: plcLogConf  Supplies the address of the variable that receives the handle of the logical configuration. dnDevNode  Supplies the handle of the device instance for which to retrieve the logical configuration. ulFlags  Configuration type.  Can be one of the following values: Configuration Type Values: ALLOC_LOG_CONF  Retrieve the allocated configuration. BASIC_LOG_CONF  Retrieve the requirements list. BOOT_LOG_CONF  Retrieve the boot configuration. The following additional configuration type is also defined for Windows 95: FILTERED_LOG_CONF  Retrieve the filtered requirements list. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_NO_MORE_LOG_CONF. Remarks: The CM_Add_Empty_Log_Conf and CM_Free_Log_Conf APIs may invalidate the handle of the logical configuration returned by this API.  To enumerate logical configurations after adding or freeing a logical configuration, always call this API again to retrieve a valid handle. When the logical configuration handle returned by CM_Get_First_Log_Conf is no longer needed, it should be freed by calling CM_Free_Log_Conf_Handle. 2.2.23 CM_Get_Hardware_Profile_Info This routine returns information about a hardware profile. CONFIGRET CM_Get_Hardware_Profile_Info ( IN ULONG ulIndex, OUT PHWPROFILEINFO pHWProfileInfo, IN ULONG ulFlags Parameters: ulIndex  Supplies the index of the hardware profile to retrieve information for.  Specifying 0xFFFFFFFF references the currently active hardware profile. pHWProfileInfo  Supplies the address of a HWPROFILEINFO structure that will receive information about the specified hardware profile. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is a CR error code. 2.2.24 CM_Get_HW_Prof_Flags This routine retrieves the configuration-specific configuration flags for a device instance and hardware profile combination. CONFIGRET CM_Get_HW_Prof_Flags ( IN DEVINSTID szDevNodeName, IN ULONG ulHardwareProfile, OUT PULONG pulValue, IN ULONG ulFlags Parameters: szDevNodeName  Supplies the address of a NULL-terminated string specifying the name of the device instance to query. ulHardwareProfile  Supplies the handle of the hardware profile to query.  If 0, the API queries the current hardware profile. pulValue  Supplies the address of the variable that receives the configuration-specific configuration (CSCONFIGFLAG_) flags. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_REGISTRY_ERROR. 2.2.25 CM_Get_Next_Log_Conf This routine returns a handle to the next logical configuration following the given configuration. CONFIGRET CM_Get_Next_Log_Conf ( OUT PLOG_CONF plcLogConf, IN LOG_CONF lcLogConf, IN ULONG ulFlags Parameters: plcLogConf  Supplies the address of the variable that receives the handle of the next logical configuration. lcLogConf  Supplies the handle of a logical configuration.  This handle must have been previously retrieved using either this API or the CM_Get_First_Log_Conf API.  Logical configurations are in priority order. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_LOG_CONF, CR_INVALID_POINTER, or CR_NO_MORE_LOG_CONF. Remarks: This API returns CR_NO_MORE_LOG_CONF if the given handle was retrieved using the CM_Get_First_Log_Conf API with either the ALLOC_LOG_CONF or BOOT_LOG_CONF flag.  There is never more than one active boot logical configuration or currently-allocated logical configuration. The CM_Add_Empty_Log_Conf and CM_Free_Log_Conf APIs may invalidate the logical configuration handle returned by this API.  To continue enumerating logical configuration after addding or freeing a logical configuration, always use the CM_Get_First_Log_Conf API to start again from the beginning. When the logical configuration handle returned by CM_Get_Next_Log_Conf is no longer needed, it should be freed by calling CM_Free_Log_Conf_Handle. 2.2.26 CM_Get_Next_Res_Des This routine returns the handle of the next resource descriptor in a logical configuration. CONFIGRET CM_Get_Next_Res_Des ( OUT PRES_DES prdResDes, IN RES_DES rdResDes, IN RESOURCEID ForResource, OUT PRESOURCEID pResourceID, IN ULONG ulFlags Parameters: prdResDes  Supplies the address of the variable that receives the handle of the next resource descriptor. rdResDes  Supplies the handle of the current resource descriptor or the handle of a logical configuration.  (Both are 32-bit numbers--Configuration Manager can distinguish between them.) ForResource  Specifies the type of the resource to retrieve.  Can be one of the ResType values listed in Section   REF MiscDataStructs \* MERGEFORMAT  pResourceID  Supplies the address of the variable that receives the resource type, when ForResource specifies ResType_All.  (When ForResource is not ResType_All, this parameter can be NULL.) ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, CR_INVALID_LOG_CONF, CR_INVALID_RES_DES, or CR_NO_MORE_RES_DES. Remarks: When the resource descriptor handle returned by CM_Get_Next_Res_Des is no longer needed, it should be freed by calling CM_Free_Res_Des_Handle 2.2.27 CM_Get_Parent This routine retrieves the handle of the parent of a device instance. CONFIGRET CM_Get_Parent ( OUT PDEVNODE pdnDevNode, IN DEVNODE dnDevNode, IN ULONG ulFlags Parameters: pdnDevNode  Supplies the address of the variable that receives a handle to the parent device instance. dnDevNode  Supplies the handle of the child device instance. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_NO_SUCH_DEVNODE. 2.2.28 CM_Get_Res_Des_Data This routine copies the data from a specified resource descriptor into a buffer. CONFIGRET CM_Get_Res_Des_Data ( IN RES_DES rdResDes, OUT PVOID Buffer, IN ULONG BufferLen, IN ULONG ulFlags Parameters: rdResDes  Supplies the handle of the resource descriptor from which data is to be copied. Buffer  Supplies the address of the buffer that receives the data. BufferLen  Supplies the size of the buffer, in bytes. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_BUFFER_SMALL, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_INVALID_RES_DES. Remarks: Use the CM_Get_Res_Des_Data_Size API to determine the buffer size needed to receive the data.  Alternately, set a size that is at least as large as the maximum possible size of the resource.  If the size given is too small, the data is truncated and the API returns CR_BUFFER_SMALL. 2.2.29 CM_Get_Res_Des_Data_Size This routine retrieves the size of a resource descriptor, not including the resource descriptor header. CONFIGRET CM_Get_Res_Des_Data_Size ( OUT PULONG pulSize, IN RES_DES rdResDes, IN ULONG ulFlags Parameters: pulSize  Supplies the address of the variable that receives the size, in bytes, of the resource descriptor data. rdResDes  Supplies the handle of the resource descriptor for which to retrieve the size. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_INVALID_RES_DES. 2.2.30 CM_Get_Sibling This routine retrieves the sibling of a device instance. CONFIGRET CM_Get_Sibling ( OUT PDEVNODE pdnDevNode, IN DEVNODE dnDevNode, IN ULONG ulFlags Parameters: pdnDevNode  Supplies the address of the variable that receives a handle to the sibling device  instance. dnDevNode  Supplies the handle of a device instance. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_NO_SUCH_DEVNODE. Remarks: This API can be called in a loop to retrieve all the siblings of a device instance.  When the API returns CR_NO_SUCH_DEVNODE, there are no more siblings to enumerate.  In order to enumerate all children of  a device instance, this loop must start with the device instance retrieved by calling CM_Get_Child to get the first sibling. 2.2.31 CM_Get_Version This routine retrieves the version number of the Configuration Manager APIs. CM_Get_Version ( Parameters: Return Value: The function returns the major revision number in the high byte and the minor revision number in the low byte. For example, version 4.0 of Configuration Manager returns 0x0400. 2.2.34 CM_Locate_DevNode This routine retrieves the handle of the device instance that corresponds to a specified device identifier. CONFIGRET CM_Locate_DevNode ( OUT PDEVNODE pdnDevNode, IN DEVNODEID pDeviceID, OPTIONAL IN ULONG ulFlags Parameters: pdnDevNode  Supplies the address of the variable that receives the handle of a device instance. pDeviceID  Supplies the address of a null-terminated string specifying a device identifier.  If this parameter is NULL, the API retrieves a handle to the device instance at the root of the hardware tree. ulFlags  Supplies flags specifying options for locating the device instance.  May be a combination of the following values: Create Device Instance Flags: CM_LOCATE_DEVNODE_NORMAL  Locate only device instances that are currently   from the ConfigMgr s point of view. CM_LOCATE_DEVNODE_PHANTOM  Allows a device instance handle to be returned for a device instance that is not currently  , but that does exist in the registry.  This may be used with other CM APIs that require a devnode handle, but for which there currently is none for a particular device (e.g., you want to set a device registry property for a device not currently present).  This flag does not allow you to locate phantom devnodes created by using CM_Create_DevNode with the CM_CREATE_DEVNODE_PHANTOM flag (such device instances are only accessible by the caller who holds the devnode handle returned from that API). Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVICE_ID, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_NO_SUCH_DEVNODE. 2.2.36 CM_Modify_Res_Des This routine modifies a resource descriptor. CONFIGRET CM_Modify_Res_Des ( OUT PRES_DES prdResDes, IN RES_DES rdResDes, IN RESOURCEID ResourceID, IN PVOID ResourceData, IN ULONG ResourceLen, IN ULONG ulFlags Parameters: prdResDes  Supplies the address of the variable that receives the handle of the modified resource descriptor. rdResDes  Supplies the handle of the resource descriptor to be modified. ResourceID  Specifies the type of resource to modify.  Can be one of the ResType values described in Section   REF MiscDataStructs \* MERGEFORMAT  ResourceData  Supplies the address of a resource data structure. ResourceLen  Supplies the size, in bytes, of the new resource data structure.  This size can be different from the size of the original resource data. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, CR_INVALID_RES_DES, or CR_OUT_OF_MEMORY. Remarks: This API retrieves a handle to the new resource descriptor.  This may or may not be the handle of the original resource descriptor.  The original resource descriptor handle is invalid after calling this API. When the new resource descriptor handle returned by CM_Modify_Res_Des is no longer needed, it should be freed by calling CM_Free_Res_Des_Handle. 2.2.48 CM_Set_HW_Prof_Flags This routine sets the configuration-specific configuration flags for a device instance and hardware profile combination. CONFIGRET CM_Set_HW_Prof_Flags ( IN DEVINSTID szDevNodeName, IN ULONG ulConfig, IN ULONG ulValue, IN ULONG ulFlags Parameters: szDevNodeName  Supplies the address of a null-terminated string that specifies the name of a device instance to modify ulConfig  Supplies the number of the hardware profile to modify.  If 0, the API modifies the current hardware profile. ulValue  Supplies the configuration flags value.  Can be a combination of these values: Configuration-Specific Flags: CSCONFIGFLAG_DISABLE  Disable the device instance in this hardware profile. CSCONFIGFLAG_DO_NOT_CREATE  Do not allow this device instance to be created in this hardware profile. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_REGISTRY_ERROR.  (Windows 95 may also return CR_NOT_AT_APPY_TIME.) Remarks: If the CSCONFIGFLAG_DO_NOT_CREATE bit is set for an existing device instance in the current hardware profile, it will be removed.  If the CSCONFIGFLAG_DO_NOT_CREATE bit is cleared in the current hardware profile, the entire hardware tree will be reenumerated, so that the parent of the device instance has the chance to create the device instance if necessary. 2.3 New Routines 2.3.1 CM_Get_DevNode_Registry_Property This routine retrieves the specified value from the device instance s registry storage key. CONFIGRET CM_Get_DevNode_Registry_Property ( IN DEVNODE dnDevNode, IN ULONG ulProperty, OUT PULONG pulRegDataType, OPTIONAL OUT PVOID Buffer, OPTIONAL IN OUT PULONG pulLength, IN ULONG ulFlags Parameters: dnDevNode  Supplies the handle of the device instance for which a property is to be retrieved. ulProperty  Supplies an ordinal specifying the property to be retrieved.  Can be one of the following values: Registry Properties: CM_DRP_DEVICEDESC  DeviceDesc property. CM_DRP_HARDWAREID  HardwareID property. CM_DRP_COMPATIBLEIDS  CompatibleIDs property. CM_DRP_NTDEVICEPATHS  NtDevicePaths property. CM_DRP_SERVICE  Service property. CM_DRP_CONFIGURATION  Configuration property. CM_DRP_CONFIGURATIONVECTOR  ConfigurationVector property. CM_DRP_CLASS  Class property. CM_DRP_CLASSGUID  ClassGUID property. CM_DRP_DRIVER  Driver property. CM_DRP_CONFIGFLAGS  ConfigFlags property. CM_DRP_MFG  Mfg property. pulRegDataType  Optionally, supplies the address of a variable that will receive the registry data type for this property (i.e., the REG_* constants). Buffer  Supplies the address of the buffer that receives the registry data.  Can be NULL when simply retrieving data size. pulLength  Supplies the address of the variable that contains the size, in bytes, of the buffer.  The API replaces the initial size with the number of bytes of registry data copied to the buffer.  If the variable is initially zero, the API replaces it with the buffer size needed to receive all the registry data.  In this case, the Buffer parameter is ignored. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_DEVNODE, CR_INVALID_PROPERTY, CR_INVALID_FLAG, CR_INVALID_POINTER, CR_NO_SUCH_VALUE, CR_REGISTRY_ERROR, or CR_BUFFER_SMALL. Remarks: This API replaces the 16-bit API, CM_Read_Registry_Value.  Direct access to the Plug & Play portions of the registry is prohibited in the 32-bit CM APIs, and access is only allowed via this API, as well as CM_Set_DevNode_Registry_Property. To retrieve device/driver class-specific information, use CM_Open_DevNode_Key. 2.3.2 CM_Set_DevNode_Registry_Property This routine sets the specified value in the device instance s registry storage key. CONFIGRET CM_Set_DevNode_Registry_Property ( IN DEVNODE dnDevNode, IN ULONG ulProperty, IN PVOID Buffer, OPTIONAL IN ULONG ulLength, IN ULONG ulFlags Parameters: dnDevNode  Supplies the handle of the device instance for which a property is to be set. ulProperty  Supplies an ordinal specifying the property to be set.  Can be one of the following values: Registry Properties: CM_DRP_DEVICEDESC  DeviceDesc property (REG_SZ). CM_DRP_HARDWAREID  HardwareID property (REG_MULTI_SZ). CM_DRP_COMPATIBLEIDS  CompatibleIDs property (REG_MULTI_SZ). CM_DRP_SERVICE  Service property (REG_SZ). CM_DRP_CLASS  Class property (REG_SZ). CM_DRP_CLASSGUID  ClassGUID property (REG_SZ). CM_DRP_DRIVER  Driver property (REG_SZ). CM_DRP_CONFIGFLAGS  ConfigFlags property (REG_DWORD). CM_DRP_MFG  Mfg property (REG_SZ). Buffer  Supplies the address of the buffer that contains the registry data.  This data must be of the proper type for that property. ulLength  Supplies the number of bytes of registry data to write. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_DEVNODE, CR_INVALID_PROPERTY, CR_INVALID_FLAG, CR_INVALID_POINTER, CR_REGISTRY_ERROR, CR_INVALID_DATA, or CR_BUFFER_SMALL. Remarks: This API replaces the 16-bit API, CM_Write_Registry_Value.  Direct access to the Plug & Play portions of the registry is prohibited in the 32-bit CM APIs, and access is only allowed via this API, as well as CM_Get_DevNode_Registry_Property. To set device/driver class-specific information, use CM_Open_DevNode_Key. 2.3.3 CM_Open_DevNode_Key This routine opens a registry storage key associated with a device instance. CONFIGRET CM_Open_DevNode_Key ( IN DEVNODE dnDevNode, IN REGSAM samDesired, IN ULONG ulHardwareProfile, IN REGDISPOSITION Disposition, OUT PHKEY phkDevice, IN ULONG ulFlags Parameters: dnDevNode  Handle of a device instance.  This handle is typically retrieved by a call to CM_Locate_DevNode or CM_Create_DevNode. samDesired  Specifies an access mask that describes the desired security access for the key. This parameter can be a combination of the values used in calls to RegOpenKeyEx. ulHardwareProfile  Supplies the handle of the hardware profile to open the storage key under.  This parameter is only used if the CM_REGISTRY_CONFIG flag is specified in ulFlags.  If this parameter is 0, the API uses the current hardware profile. Disposition  Specifies how the registry key is to be opened.  May be one of the following values: Registry Key Open Dispositions: RegDisposition_OpenAlways  Open the key if it exists, otherwise, create the key. RegDisposition_OpenExisting  Open the key if it exists, otherwise, fail with CR_NO_SUCH_REGISTRY_KEY. phkDevice  Supplies the address of the variable that receives an opened handle to the specified key.  When access to this key is completed, it must be closed via RegCloseKey. ulFlags  Specifies what type of storage key should be opened.  Can be a combination of these values: Registry Key Type Flags: CM_REGISTRY_HARDWARE (0x00000000)  Open a key for storing driver-independent information relating to the device instance.  On Windows NT, the full path to such a storage key is of the form: HKLM\SYSTEM\CurrentControlSet\Enum \<Enumerator> \<DeviceID> \<InstanceID> \Device Parameters CM_REGISTRY_SOFTWARE (0x00000001)  Open a key for storing driver-specific information relating to the device instance.  On Windows NT, the full path is to such a storage key is of the form: HKLM\SYSTEM\CurrentControlSet\Control\Class \<DevNodeClass> \<ClassInstanceOrdinal> CM_REGISTRY_USER (0x00000100)  Open the key under HKEY_CURRENT_USER instead of HKEY_LOCAL_MACHINE.  This flag may not be used with CM_REGISTRY_CONFIG.  There is no analogous kernel-mode API on NT to get at per-user device configuration storage, since this concept does not apply to device drivers (no user may be logged on, etc.).  However, this flag is provided, for consistency with Win95, and because it is foreseeable that it could be useful to Win32 services that interact with the Plug&Play model. CM_REGISTRY_CONFIG (0x00000200)  Open the key under a hardware profile branch instead of HKEY_LOCAL_MACHINE.  If this flag is specified, then ulHardwareProfile supplies the handle of the hardware profile to be used.  This flag may not be used with CM_REGISTRY_USER. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_DEVNODE, CR_NO_SUCH_REGISTRY_KEY, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_REGISTRY_ERROR Remarks: This API replaces the 16-bit APIs, CM_Read_Registry_Value and CM_Write_Registry_Value, for storing class-specific configuration information for a device instance.  This API cannot be used to set Plug&Play device instance properties, as these properties are located in a separate location in the registry that is accessible only via CM_Get_Device_Registry_Property, and CM_Set_Device_Registry_Property. 2.3.4 CM_Delete_DevNode_Key This routine deletes a registry storage key associated with a device instance. CONFIGRET CM_Delete_DevNode_Key ( IN DEVNODE dnDevNode, IN ULONG ulHardwareProfile, IN ULONG ulFlags Parameters: dnDevNode  Handle of a device instance.  This handle is typically retrieved by a call to CM_Locate_DevNode or CM_Create_DevNode. ulHardwareProfile  Supplies the handle of the hardware profile to delete the storage key under.  This parameter is only used if the CM_REGISTRY_CONFIG flag is specified in ulFlags.  If this parameter is 0, the API uses the current hardware profile.  If this parameter is 0xFFFFFFFF, then the specified storage key(s) for all hardware profiles is(are) deleted. ulFlags  Specifies what type(s) of storage key(s) should be deleted.  Can be a combination of these values: Registry Key Type Flags: CM_REGISTRY_HARDWARE (0x00000000)  Delete the key for storing driver-independent information relating to the device instance.  (Windows 95 doesn t provide a separate location for user-accessible storage here--it simply uses the devnode key itself.  Therefore, this flag is a no-op for them.) CM_REGISTRY_SOFTWARE (0x00000001)  Delete the key for storing driver-specific information relating to the device instance. CM_REGISTRY_USER (0x00000100)  Delete the specified key(s) under HKEY_CURRENT_USER instead of HKEY_LOCAL_MACHINE.  This flag may not be used with CM_REGISTRY_CONFIG. CM_REGISTRY_CONFIG (0x00000200)  Delete the specified key(s) under a hardware profile branch instead of HKEY_LOCAL_MACHINE.  If this flag is specified, then ulHardwareProfile supplies the handle of the hardware profile to be used.  This flag may not be used with CM_REGISTRY_USER. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_DEVNODE, CR_INVALID_FLAG, or CR_REGISTRY_ERROR Remarks: To delete all possible storage keys associated with a device instance, CM_Delete_DevNode_Key must be called with each of the following flag combinations: CM_REGISTRY_HARDWARE CM_REGISTRY_SOFTWARE CM_REGISTRY_HARDWARE | CM_REGISTRY_USER CM_REGISTRY_SOFTWARE | CM_REGISTRY_USER CM_REGISTRY_HARDWARE | CM_REGISTRY_CONFIG // ulHardwareProfile = 0xFFFFFFFF CM_REGISTRY_SOFTWARE | CM_REGISTRY_CONFIG // ulHardwareProfile = 0xFFFFFFFF 2.3.5 CM_Open_Class_Key This routine opens the class registry key, and optionally, a specific class s subkey. CONFIGRET CM_Open_Class_Key ( IN LPGUID ClassGuid, OPTIONAL IN REGSAM samDesired, IN REGDISPOSITION Disposition, OUT PHKEY phkClass, IN ULONG ulFlags Parameters: ClassGuid  Optionally, supplies the address of a class GUID representing the class subkey to be opened. samDesired  Specifies an access mask that describes the desired security access for the key. This parameter can be a combination of the values used in calls to RegOpenKeyEx. Disposition  Specifies how the registry key is to be opened.  May be one of the following values: Registry Key Open Dispositions: RegDisposition_OpenAlways  Open the key if it exists, otherwise, create the key. RegDisposition_OpenExisting  Open the key if it exists, otherwise, fail with CR_NO_SUCH_REGISTRY_KEY. phkClass  Supplies the address of the variable that receives an opened handle to the specified key.  When access to this key is completed, it must be closed via RegCloseKey. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:CR_NO_SUCH_REGISTRY_KEY, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_REGISTRY_ERROR Remarks: This API is provided for use by the 32-bit Setup APIs.  Since the location of the class branch is different between Windows 95 and Windows NT, this API is present in the Config Manager APIs to provide access to the key via a position-independent interface. 2.3.6 CM_Enumerate_Classes This routine enumerates the installed classes in the system.  It retrieves the GUID for a single class each time it is called. CONFIGRET CM_Enumerate_Classes ( IN ULONG ulClassIndex, OUT LPGUID ClassGuid, IN ULONG ulFlags Parameters: ulClassIndex  Supplies the index of the class to retrieve the class GUID for. ClassGuid  Supplies the address of the variable that receives the GUID for the class whose index is specified by ulClassIndex. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, CR_INVALID_DATA, CR_NO_SUCH_VALUE, or CR_REGISTRY_ERROR Remarks: To enumerate installed classes, an application should initially call the CM_Enumerate_Classes function with the ulClassIndex parameter set to zero. The application should then increment the ulClassIndex parameter and call CM_Enumerate_Classes until there are no more classes (until the function returns CR_NO_SUCH_VALUE).  It is possible to receive a CR_INVALID_DATA error while enumerating installed classes.  This may happen if the registry key represented by the specified index is determined to be an invalid class key.  Such keys should be ignored during enumeration. 2.3.7 CM_Get_Class_Name This routine retrieves the class name associated with the specified class GUID. CONFIGRET CM_Get_Class_Name ( IN LPGUID ClassGuid, OUT PTCHAR Buffer, IN OUT PULONG pulLength, IN ULONG ulFlags Parameters: ClassGuid  Supplies a pointer to the class GUID whose name is to be retrieved. Buffer  Supplies the address of the character buffer that receives the class name corresponding to the specified GUID. pulLength  Supplies the address of the variable that contains the length, in characters, of the Buffer.  Upon return, this variable will contain the number of characters (including terminating NULL) written to Buffer (if the supplied buffer isn t large enough, then the routine will fail with CR_BUFFER_SMALL, and this value will indicate how large the buffer needs to be in order to succeed). ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, CR_BUFFER_SMALL, or CR_REGISTRY_ERROR 2.3.8 CM_Enumerate_Enumerators This routine enumerates the enumerator subkeys under the Enum branch (e.g., Root, PCI, etc.).  These names should not be used to access the registry directly, but may be used as input to the CM_Get_Device_ID_List routine. CONFIGRET CM_Enumerate_Enumerators ( IN ULONG ulEnumIndex, OUT PTCHAR Buffer, IN OUT PULONG pulLength, IN ULONG ulFlags Parameters: ulEnumIndex  Supplies the index of the enumerator subkey name to retrieve. Buffer  Supplies the address of the character buffer that receives the enumerator subkey name whose index is specified by ulEnumIndex. pulLength  Supplies the address of the variable that contains the length, in characters, of the Buffer.  Upon return, this variable will contain the number of characters (including terminating NULL) written to Buffer (if the supplied buffer isn t large enough, then the routine will fail with CR_BUFFER_SMALL, and this value will indicate how large the buffer needs to be in order to succeed). ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, CR_BUFFER_SMALL, CR_NO_SUCH_VALUE, or CR_REGISTRY_ERROR Remarks: To enumerate enumerator subkey names, an application should initially call the CM_Enumerate_Enumerators function with the ulEnumIndex parameter set to zero. The application should then increment the ulEnumIndex parameter and call CM_Enumerate_Enumerators until there are no more subkeys (until the function returns CR_NO_SUCH_VALUE). 2.3.9 CM_Get_Device_ID_List This routine retrieves a list of all device IDs (device instance names) stored in the system, optionally filtered based upon the specified criteria. CONFIGRET CM_Get_Device_ID_List ( IN PCTSTR pszFilter, OPTIONAL OUT PTCHAR Buffer, IN ULONG BufferLen, IN ULONG ulFlags Parameters: pszFilter  Optionally, supplies a string that is used to filter the set of device IDs being returned.  The interpretation of this string is dependent upon the value of ulFlags, described below. Buffer  Supplies the address of the character buffer that receives the device ID list.  Each device ID is null-terminated, with an extra NULL at the end. BufferLen  Supplies the size, in characters, of the Buffer.  This size may be ascertained by calling CM_Get_Device_ID_List_Size. ulFlags  Specifies how the pszFilter string should be used to filter the set of device instances returned.  May be one of the following values: Device ID List Filter Flags: CM_GETIDLIST_FILTER_NONE (0x00000000)  t do any filtering on the device ID list being returned.  If the flag is specified, then pszFilter is ignored. CM_GETIDLIST_FILTER_ENUMERATOR (0x00000001)  Only return device IDs existing under the pszFilter branch of the hardware tree.  In this context, pszFilter can either be an enumerator name (as retrieved from CM_Enumerate_Enumerators), or a device ID, minus the instance ID (e.g., Root\*PNP0500). CM_GETIDLIST_FILTER_SERVICE (0x00000002)  Only return device IDs that are controlled by the service whose name is specified in pszFilter.  For example, specifying a pszFilter of  atdisk  with this filter flag would return only those device instances that are controlled by the atdisk driver.  This flag is not implemented on Windows 95. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_NO_SUCH_REGISTRY_KEY, CR_INVALID_FLAG, CR_INVALID_POINTER, CR_BUFFER_SMALL, or CR_REGISTRY_ERROR 2.3.10 CM_Get_Device_ID_List_Size This routine retrieves the size, in characters, of a list of device identifiers.  It may be used to supply the buffer size necessary for a call to CM_Get_Device_ID_List. CONFIGRET CM_Get_Device_ID_List_Size ( OUT PULONG pulLen, IN PCTSTR pszFilter, OPTIONAL IN ULONG ulFlags Parameters: pulLen  Supplies the address of the variable that receives the size, in characters, required to store a list of all device identifiers (possibly limited to those existing under the pszEnumerator subkey described below).  The size reflects a list of null-terminated device identifiers, with an extra null at the end.  For efficiency, this number represents an upper bound on the size required, and the actual list size may be slightly smaller. pszFilter  Optionally, supplies a string that is used to filter the set of device IDs that make up the list whose size is being returned.  The interpretation of this string is dependent upon the value of ulFlags, described below. ulFlags  Specifies how the pszFilter string should be used to filter the set of device instances comprising the list whose size is to be returned.  May be one of the following values: Device ID List Filter Flags: CM_GETIDLIST_FILTER_NONE (0x00000000)  t do any filtering on the device ID list being returned.  If the flag is specified, then pszFilter is ignored. CM_GETIDLIST_FILTER_ENUMERATOR (0x00000001)  Only include device IDs existing under the pszFilter branch of the hardware tree.  In this context, pszFilter can either be an enumerator name (as retrieved from CM_Enumerate_Enumerators), or a device ID, minus the instance ID (e.g., Root\*PNP0500). CM_GETIDLIST_FILTER_SERVICE (0x00000002)  Only include device IDs that are controlled by the service whose name is specified in pszFilter.  For example, specifying a pszFilter of  atdisk  with this filter flag would return only those device instances that are controlled by the atdisk driver.  This flag is not implemented on Windows 95. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_NO_SUCH_REGISTRY_KEY, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_REGISTRY_ERROR 2.3.12 CM_Connect_Machine This routine establishes a connection to a machine.  The machine handle can then be used on subsequent calls to extended Configuration Manager routines to provide remotable API support. CONFIGRET CM_Connect_Machine ( IN PCWSTR pszMachineName, OUT PHMACHINE phMachine Parameters: pszMachineName  Supplies a string that contains the UNC name of the machine to connect to. phMachine  Supplies the address of a variable of type HMACHINE that will return the handle for the connection to the machine specified in pszMachineName.  This machine handle should be used as the last parameter in subsequent calls to the extended (remotable) Configuration Manager routines (such as CM_Locate_DevNode_Ex). Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_POINTER, CR_OUT_OF_MEMORY, CR_INVALID_MACHINENAME, or CR_FAILURE. Remarks: When you are done calling Configuration Manager routines on the specified machine, you should call CM_Disconnet_Machine to free up internal resources allocated for that connection.  Most of the Configuration Manager routines have extended versions.  In each case, the extended version of the CM routine is simply appended with the _Ex extension and takes an HMACHINE parameter as an additional parameter (always the last parameter). Also note that the following three additional error codes may be returned for any of the extended CM routines: CR_REMOTE_COMM_FAILURE, CR_MACHINE_UNAVAILABLE, or CR_NO_CM_SERVICES. 2.3.13 CM_Disconnect_Machine This routine closes a machine handle that was opened by a call to CM_Connect_Machine.  Once communication with a remote machine using the CM routines is completed, the caller should call CM_Disconnect_Machine to free up resources that were allocated for that connection. CONFIGRET CM_Disconnect_Machine ( IN HMACHINE hMachine Parameters: hMachine  Supplies the machine handle that was returned from a previous call to CM_Connect_Machine. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_POINTER or CR_FAILURE. 2.3.14 CM_Free_Log_Conf_Handle This routine frees a logical configuration handle that was previously retreived by a call to CM_Add_Empty_Log_Conf, CM_Get_First_Log_Conf, or CM_Get_Next_Log_Conf. CONFIGRET CM_Free_Log_Conf_Handle(             IN  LOG_CONF  lcLogConf             ); Parameters: lcLogConf  Supplies the logical configuration handle to be freed. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_LOG_CONF or CR_FAILURE. 2.3.15 CM_Free_Res_Des_Handle This routine frees a resource descriptor handle that was previously retrieved by a call to CM_Add_Res_Des, CM_Free_Res_Des, CM_Get_Next_Res_Des, or CM_Modify_Res_Des. CONFIGRET CM_Free_Res_Des_Handle(             IN  RES_DES  rdResDes             ); Parameters: rdResDes   Supplies the resource descriptor handle to be freed. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_RES_DES or CR_FAILURE. 2.3.16 CM_Detect_Resource_Conflict This routine determines whether the specified set of resources is already in use by some other device. CONFIGRET CM_Detect_Resource_Conflict (          IN  DEVINST    dnDevInst,          IN  RESOURCEID ResourceID,         OPTIONAL          IN  PCVOID     ResourceData,       OPTIONAL          IN  ULONG      ResourceLen,        OPTIONAL          OUT PBOOL      pbConflictDetected,          IN  ULONG      ulFlags, Parameters: dnDevInst - Handle of a device instance. This handle is typically retrieved by a call to CM_Locate_DevNode. ResourceID - Specifies the type of resource to modify. ResType_ClassSpecific is not a valid resource type for this call. ResourceData  - Supplies the address of a resource data structure. ResourceLen - Supplies the size, in bytes, of the resource data structure. pbConflictDetect - Pointer to a boolean value that is returned by this call. If the returned value is FALSE, then no conflict was detected. If the the return value is TRUE, then a conflict was detected. If CM_Detect_Resource_Conflict does not return CR_SUCCESS, then the value of pbConflictDetected is unknown and should not be used. ulFlags - Not used, must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_LOG_CONF, CR_INVALID_FLAG, CR_INVALID_POINTER, CR_INVALID_RESOURCEID, CR_INVALID_DATA.  This name is retained for compatibility with the Windows 95 16-bit Configuration Manager APIs.  Windows NT does not use devnodes, so this data type must be viewed as simply an opaque handle to a device instance.  (In fact, Windows NT will define macros DEVINST and PDEVINST that will be used internally instead of the DEVNODE typedefs.)  This name is retained for compatibility with the 16-bit CM APIs.  Windows NT will define a macro DEVINSTID that will be used internally instead of the DEVNODEID typedef.  For Windows 95, this key is HKLM\Enum; on Windows NT, it is HKLM\System\CurrentControlSet\Enum.  No assumptions should be made about where this key is located.  For Windows NT, this is the same as LCPRI_REBOOT. Document Name 32-Bit Configuration Manager Application Programming Interface Document Name Microsoft Corporation Company Confidential Normal Heading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Default Paragraph Font Prototype (type name) Prototype (proc name) Prototype (direction) Prototype (identifier) Prototype ("Parameters:") Footnote reference character List level 1 List level 2 Parameter values heading Parameter values list Simple list level 1 Simple list level 2 Parameter values subheading 1_Parameter values list Parameter values sub-subhead Parameter values sublist Note (in level 1 list) Procedure name list List level 3 List level 4 Table of Contents level 5 Normal paragraph + keep next Underlined paragraph Hidden paragraph 1_Footnote text Prototype (declaration) Prototype (parameter list) Proto. (param list,para 2) Prototype (Return Value:) Second paragraph for P4 Table of Contents level 6 Running header Running footer Title page--document name Title page--author name Title page--revision number 1_Hidden paragraph Definition of term Code example Diagram TOC 1 TOC 2 TOC 3 TOC 4 Header Footer TOC 5 TOC 6 TOC 7 TOC 8 TOC 9 Footnote Text Footnote Reference Annotation Reference Annotation Text _Toc308507447 _Toc308512738 _Toc308592447 _Toc308601372 _Toc308601682 _Toc308717484 _Toc308718689 _Toc308860136 _Toc308877028 _Toc309035245 _Toc309099783 _Toc309123460 _Toc309123515 _Toc309205845 _Toc309445531 _Toc309446736 _Toc309454977 _Toc309457083 _Toc309458063 _Toc316367185 _Toc317402037 _Toc318525944 _Toc318526188 _Toc318530417 _Toc318530448 _Toc319385045 _Toc323119429 _Toc325168542 _Toc325787180 _Toc327598891 _Toc327611352 _Toc327635253 _Toc327641300 _Toc327677365 _Toc327690769 _Toc327712200 _Toc327861581 _Toc327886462 _Toc328812952 _Toc329750947 _Toc329763211 _Toc330203520 _Toc330342748 _Toc330347561 _Toc330352011 _Toc330610835 _Toc331926949 _Toc334001205 _Toc335798408 _Toc335978310 _Toc335978516 _Toc335985940 _Toc335987452 _Toc336265940 _Toc336312093 _Toc336348839 _Toc336349994 _Toc338123717 _Toc342123784 _Toc342187842 _Toc364568172 _Toc308512747 _Toc308592457 _Toc308601692 _Toc308717494 _Toc308718699 _Toc308860146 _Toc308877038 _Toc309035255 _Toc309099793 _Toc309123470 _Toc309123525 _Toc309205850 _Toc309445536 _Toc309446741 _Toc309454982 _Toc309457088 _Toc309458068 _Toc316367190 _Toc317402042 _Toc318525949 _Toc318526193 _Toc318530422 _Toc318530453 _Toc319385050 _Toc323119434 _Toc325168547 _Toc325787185 _Toc327598892 _Toc327611353 _Toc327635254 _Toc327641301 _Toc327677366 _Toc327690770 _Toc327712201 _Toc327861582 _Toc327886463 _Toc328812953 _Toc329750948 _Toc329763212 _Toc330203521 _Toc330342749 _Toc330347562 _Toc330352012 _Toc330610836 _Toc331926950 _Toc334001206 _Toc335798409 _Toc335978311 _Toc335978517 _Toc335985941 _Toc335987453 _Toc336265941 _Toc336312094 _Toc336348840 _Toc336349995 _Toc338123718 _Toc342123785 _Toc342187843 _Toc364568173 _Toc308512748 _Toc308592458 _Toc308601382 _Toc308601693 _Toc308717495 _Toc308718700 _Toc308860147 _Toc308877039 _Toc309035256 _Toc309099794 _Toc309123471 _Toc309123526 _Toc309205851 _Toc309445537 _Toc309446742 _Toc309454983 _Toc309457089 _Toc309458069 _Toc316367191 _Toc317402043 _Toc318525950 _Toc318526194 _Toc318530423 _Toc318530454 _Toc319385051 _Toc323119435 _Toc325168548 _Toc325787186 _Toc327598893 _Toc327611354 _Toc327635255 _Toc327641302 _Toc327677367 _Toc327690771 _Toc327712202 _Toc327861583 _Toc327886464 _Toc328812954 _Toc329750949 _Toc329763213 _Toc330203522 _Toc330342750 _Toc330347563 _Toc330352013 _Toc330610837 _Toc331926951 _Toc334001207 _Toc335798410 _Toc335978312 _Toc335978518 _Toc335985942 _Toc335987454 _Toc336265942 _Toc336312095 _Toc336348841 _Toc336349996 _Toc338123719 _Toc342123786 _Toc342187844 _Toc364568174 _Toc327598894 _Toc327611355 _Toc327635256 _Toc327641303 _Toc327677368 _Toc327690772 _Toc327712203 _Toc327861584 _Toc327886465 _Toc328812955 _Toc329750950 _Toc329763214 _Toc330203523 _Toc330342751 _Toc330347564 _Toc330352014 _Toc330610838 _Toc331926952 _Toc334001208 _Toc335798411 _Toc335978313 _Toc335978519 _Toc335985943 _Toc335987455 _Toc336265943 _Toc336312096 _Toc336348842 _Toc336349997 _Toc338123720 _Toc342123787 _Toc342187845 _Toc364568175 _Toc327598895 _Toc327611356 _Toc327635257 _Toc327641304 _Toc327677369 _Toc327690773 _Toc327712204 _Toc327861585 _Toc327886466 _Toc328812956 _Toc329750951 _Toc329763215 _Toc330203524 _Toc330342752 _Toc330347565 _Toc330352015 _Toc330610839 _Toc331926953 _Toc334001209 _Toc335798412 _Toc335978314 _Toc335978520 _Toc335985944 _Toc335987456 _Toc336265944 _Toc336312097 _Toc336348843 _Toc336349998 _Toc338123721 _Toc342123788 _Toc342187846 _Toc364568176 _Toc308512751 _Toc308592461 _Toc308601385 _Toc308601696 _Toc308717498 _Toc308718703 _Toc308860151 _Toc308877044 _Toc309035262 _Toc309099801 _Toc309123479 _Toc309123534 _Toc309205859 _Toc309445544 _Toc309446750 _Toc309454991 _Toc309457097 _Toc309458077 _Toc316367199 _Toc317402051 _Toc318525958 _Toc318526201 _Toc318530446 _Toc318530462 _Toc319385062 _Toc323119448 _Toc325168562 _Toc325787202 _Toc327598896 _Toc327611357 _Toc327635258 _Toc327641305 _Toc327677370 _Toc327690774 _Toc327712205 _Toc327861586 _Toc327886467 _Toc328812957 _Toc329750952 _Toc329763216 _Toc330203525 _Toc330342753 _Toc330347566 _Toc330352016 _Toc330610840 _Toc331926954 _Toc334001210 _Toc335798413 _Toc335978315 _Toc335978521 _Toc335985945 _Toc335987457 _Toc336265945 _Toc336312098 _Toc336348844 _Toc336349999 _Toc338123722 _Toc342123789 _Toc342187847 _Toc364568177 _Toc327598897 _Toc327611358 _Toc327635259 _Toc327641306 _Toc327677371 _Toc327690775 _Toc327712206 _Toc327861587 _Toc327886468 _Toc328812958 _Toc329750953 _Toc329763217 _Toc330203526 _Toc330342754 _Toc330347567 _Toc330352017 _Toc330610841 _Toc331926955 _Toc334001211 _Toc335798414 _Toc335978316 _Toc335978522 _Toc335985946 _Toc335987458 _Toc336265946 _Toc336312099 _Toc336348845 _Toc336350000 _Toc338123723 _Toc342123790 _Toc342187848 _Toc364568178 _Toc327611359 _Toc327635260 _Toc327641307 _Toc327677372 _Toc327690776 _Toc327712207 _Toc327861588 _Toc327886469 _Toc328812959 _Toc329750954 _Toc329763218 _Toc330203527 _Toc330342755 _Toc330347568 _Toc330352018 _Toc330610842 _Toc331926956 _Toc334001212 _Toc335798415 _Toc335978317 _Toc335978523 _Toc335985947 _Toc335987459 _Toc336265947 _Toc336312100 _Toc336348846 _Toc336350001 _Toc338123724 _Toc342123791 _Toc342187849 _Toc364568179 _Toc336265948 _Toc336312101 _Toc336348847 _Toc336350002 _Toc338123725 _Toc342123792 _Toc342187850 _Toc364568180 MiscDataStructs _Toc327677373 _Toc327690777 _Toc327712208 _Toc327861589 _Toc327886470 _Toc328812960 _Toc329750955 _Toc329763219 _Toc330203528 _Toc330342756 _Toc330347569 _Toc330352019 _Toc330610843 _Toc331926957 _Toc334001213 _Toc335798416 _Toc335978318 _Toc335978524 _Toc335985948 _Toc335987460 _Toc336265949 _Toc336312102 _Toc336348848 _Toc336350003 _Toc338123726 _Toc342123793 _Toc342187851 _Toc364568181 _Toc327611360 _Toc327635261 _Toc327641308 _Toc327677374 _Toc327690778 _Toc327712209 _Toc327861590 _Toc327886471 _Toc328812961 _Toc329750956 _Toc329763220 _Toc330203529 _Toc330342757 _Toc330347570 _Toc330352020 _Toc330610844 _Toc331926958 _Toc334001214 _Toc335798417 _Toc335978319 _Toc335978525 _Toc335985949 _Toc335987461 _Toc336265950 _Toc336312103 _Toc336348849 _Toc336350004 _Toc338123727 _Toc342123794 _Toc342187852 _Toc364568182 _Toc327635262 _Toc327641309 _Toc327677375 _Toc327690779 _Toc327712210 _Toc327861591 _Toc327886472 _Toc328812962 _Toc329750957 _Toc329763221 _Toc330203530 _Toc330342758 _Toc330347571 _Toc330352021 _Toc330610845 _Toc331926959 _Toc334001215 _Toc335798418 _Toc335978320 _Toc335978526 _Toc335985950 _Toc335987462 _Toc336265951 _Toc336312104 _Toc336348850 _Toc336350005 _Toc338123728 _Toc342123795 _Toc342187853 _Toc364568183 _Toc327635265 _Toc327641312 _Toc327677378 _Toc327690782 _Toc327712213 _Toc327861594 _Toc327886475 _Toc328812965 _Toc329750960 _Toc329763224 _Toc330203533 _Toc330342761 _Toc330347574 _Toc330352024 _Toc330610848 _Toc331926962 _Toc334001218 _Toc335798421 _Toc335978323 _Toc335978529 _Toc335985953 _Toc335987465 _Toc336265954 _Toc336312107 _Toc336348853 _Toc336350008 _Toc338123731 _Toc342123798 _Toc342187856 _Toc364568184 _Toc327641322 _Toc327677388 _Toc327690791 _Toc327712222 _Toc327861603 _Toc327886484 _Toc328812974 _Toc329750969 _Toc329763233 _Toc330203542 _Toc330342770 _Toc330347583 _Toc330352033 _Toc330610857 _Toc331926971 _Toc334001227 _Toc335798430 _Toc335978332 _Toc335978538 _Toc335985962 _Toc335987474 _Toc336265963 _Toc336312116 _Toc336348862 _Toc336350017 _Toc338123740 _Toc342123807 _Toc342187865 _Toc364568185 _Toc327641324 _Toc327677390 _Toc327690793 _Toc327712224 _Toc327861605 _Toc327886486 _Toc328812976 _Toc329750971 _Toc329763235 _Toc330203544 _Toc330342772 _Toc330347585 _Toc330352035 _Toc330610859 _Toc331926973 _Toc334001229 _Toc335798432 _Toc335978334 _Toc335978540 _Toc335985964 _Toc335987476 _Toc336265965 _Toc336312118 _Toc336348864 _Toc336350019 _Toc338123742 _Toc342123809 _Toc342187867 _Toc364568186 _Toc327641325 _Toc327677391 _Toc327690794 _Toc327712225 _Toc327861606 _Toc327886487 _Toc328812977 _Toc329750972 _Toc329763236 _Toc330203545 _Toc330342773 _Toc330347586 _Toc330352036 _Toc330610860 _Toc331926974 _Toc334001230 _Toc335798433 _Toc335978335 _Toc335978541 _Toc335985965 _Toc335987477 _Toc336265966 _Toc336312119 _Toc336348865 _Toc336350020 _Toc338123743 _Toc342123810 _Toc342187868 _Toc364568187 _Toc327641328 _Toc327677394 _Toc327690797 _Toc327712228 _Toc327861609 _Toc327886489 _Toc328812979 _Toc329750974 _Toc329763238 _Toc330203547 _Toc330342775 _Toc330347588 _Toc330352038 _Toc330610862 _Toc331926976 _Toc334001232 _Toc335798435 _Toc335978337 _Toc335978543 _Toc335985967 _Toc335987479 _Toc336265968 _Toc336312121 _Toc336348867 _Toc336350022 _Toc338123745 _Toc342123812 _Toc342187870 _Toc364568188 _Toc327641329 _Toc327677395 _Toc327690798 _Toc327712229 _Toc327861610 _Toc327886490 _Toc328812980 _Toc329750975 _Toc329763239 _Toc330203548 _Toc330342776 _Toc330347589 _Toc330352039 _Toc330610863 _Toc331926977 _Toc334001233 _Toc335798436 _Toc335978338 _Toc335978544 _Toc335985968 _Toc335987480 _Toc336265969 _Toc336312122 _Toc336348868 _Toc336350023 _Toc338123746 _Toc342123813 _Toc342187871 _Toc364568189 _Toc327677396 _Toc327690799 _Toc327712230 _Toc327861611 _Toc327886491 _Toc328812981 _Toc329750976 _Toc329763240 _Toc330203549 _Toc330342777 _Toc330347590 _Toc330352040 _Toc330610864 _Toc331926978 _Toc334001234 _Toc335798437 _Toc335978339 _Toc335978545 _Toc335985969 _Toc335987481 _Toc336265970 _Toc336312123 _Toc336348869 _Toc336350024 _Toc338123747 _Toc342123814 _Toc342187872 _Toc364568190 _Toc327677397 _Toc327690800 _Toc327712231 _Toc327861612 _Toc327886492 _Toc328812982 _Toc329750977 _Toc329763241 _Toc330203550 _Toc330342778 _Toc330347591 _Toc330352041 _Toc330610865 _Toc331926979 _Toc334001235 _Toc335798438 _Toc335978340 _Toc335978546 _Toc335985970 _Toc335987482 _Toc336265971 _Toc336312124 _Toc336348870 _Toc336350025 _Toc338123748 _Toc342123815 _Toc342187873 _Toc364568191 _Toc327677399 _Toc327690802 _Toc327712233 _Toc327861614 _Toc327886494 _Toc328812984 _Toc329750979 _Toc329763243 _Toc330203552 _Toc330342780 _Toc330347593 _Toc330352043 _Toc330610867 _Toc331926981 _Toc334001237 _Toc335798440 _Toc335978342 _Toc335978548 _Toc335985972 _Toc335987484 _Toc336265973 _Toc336312126 _Toc336348872 _Toc336350027 _Toc338123750 _Toc342123817 _Toc342187875 _Toc364568192 _Toc327677400 _Toc327690803 _Toc327712234 _Toc327861615 _Toc327886495 _Toc328812985 _Toc329750980 _Toc329763244 _Toc330203553 _Toc330342781 _Toc330347594 _Toc330352044 _Toc330610868 _Toc331926982 _Toc334001238 _Toc335798441 _Toc335978343 _Toc335978549 _Toc335985973 _Toc335987485 _Toc336265974 _Toc336312127 _Toc336348873 _Toc336350028 _Toc338123751 _Toc342123818 _Toc342187876 _Toc364568193 _Toc327677401 _Toc327690804 _Toc327712235 _Toc327861616 _Toc327886496 _Toc328812986 _Toc329750981 _Toc329763245 _Toc330203554 _Toc330342782 _Toc330347595 _Toc330352045 _Toc330610869 _Toc331926983 _Toc334001239 _Toc335798442 _Toc335978344 _Toc335978550 _Toc335985974 _Toc335987486 _Toc336265975 _Toc336312128 _Toc336348874 _Toc336350029 _Toc338123752 _Toc342123819 _Toc342187877 _Toc364568194 _Toc327677402 _Toc327690805 _Toc327712236 _Toc327861617 _Toc327886497 _Toc328812987 _Toc329750982 _Toc329763246 _Toc330203555 _Toc330342783 _Toc330347596 _Toc330352046 _Toc330610870 _Toc331926984 _Toc334001240 _Toc335798443 _Toc335978345 _Toc335978551 _Toc335985975 _Toc335987487 _Toc336265976 _Toc336312129 _Toc336348875 _Toc336350030 _Toc338123753 _Toc342123820 _Toc342187878 _Toc364568195 _Toc327677403 _Toc327690806 _Toc327712237 _Toc327861618 _Toc327886498 _Toc328812988 _Toc329750983 _Toc329763247 _Toc330203556 _Toc330342784 _Toc330347597 _Toc330352047 _Toc330610871 _Toc331926985 _Toc334001241 _Toc335798444 _Toc335978346 _Toc335978552 _Toc335985976 _Toc335987488 _Toc336265977 _Toc336312130 _Toc336348876 _Toc336350031 _Toc338123754 _Toc342123821 _Toc342187879 _Toc364568196 _Toc327677404 _Toc327690807 _Toc327712238 _Toc327861619 _Toc327886499 _Toc328812989 _Toc329750984 _Toc329763248 _Toc330203557 _Toc330342785 _Toc330347598 _Toc330352048 _Toc330610872 _Toc331926986 _Toc334001242 _Toc335798445 _Toc335978347 _Toc335978553 _Toc335985977 _Toc335987489 _Toc336265978 _Toc336312131 _Toc336348877 _Toc336350032 _Toc338123755 _Toc342123822 _Toc342187880 _Toc364568197 _Toc327690808 _Toc327712239 _Toc327861620 _Toc327886500 _Toc328812990 _Toc329750985 _Toc329763249 _Toc330203558 _Toc330342786 _Toc330347599 _Toc330352049 _Toc330610873 _Toc331926987 _Toc334001243 _Toc335798446 _Toc335978348 _Toc335978554 _Toc335985978 _Toc335987490 _Toc336265979 _Toc336312132 _Toc336348878 _Toc336350033 _Toc338123756 _Toc342123823 _Toc342187881 _Toc364568198 _Toc327690809 _Toc327712240 _Toc327861621 _Toc327886501 _Toc328812991 _Toc329750986 _Toc329763250 _Toc330203559 _Toc330342787 _Toc330347600 _Toc330352050 _Toc330610874 _Toc331926988 _Toc334001244 _Toc335798447 _Toc335978349 _Toc335978555 _Toc335985979 _Toc335987491 _Toc336265980 _Toc336312133 _Toc336348879 _Toc336350034 _Toc338123757 _Toc342123824 _Toc342187882 _Toc364568199 _Toc327690810 _Toc327712241 _Toc327861622 _Toc327886502 _Toc328812992 _Toc329750987 _Toc329763251 _Toc330203560 _Toc330342788 _Toc330347601 _Toc330352051 _Toc330610875 _Toc331926989 _Toc334001245 _Toc335798448 _Toc335978350 _Toc335978556 _Toc335985980 _Toc335987492 _Toc336265981 _Toc336312134 _Toc336348880 _Toc336350035 _Toc338123758 _Toc342123825 _Toc342187883 _Toc364568200 _Toc327690813 _Toc327712244 _Toc327861625 _Toc327886505 _Toc328812995 _Toc329750990 _Toc329763254 _Toc330203563 _Toc330342791 _Toc330347604 _Toc330352054 _Toc330610878 _Toc331926992 _Toc334001248 _Toc335798451 _Toc335978353 _Toc335978559 _Toc335985983 _Toc335987495 _Toc336265984 _Toc336312137 _Toc336348883 _Toc336350038 _Toc338123761 _Toc342123828 _Toc342187886 _Toc364568201 _Toc327690815 _Toc327712246 _Toc327861627 _Toc327886507 _Toc328812997 _Toc329750992 _Toc329763256 _Toc330203565 _Toc330342793 _Toc330347606 _Toc330352056 _Toc330610880 _Toc331926994 _Toc334001250 _Toc335798453 _Toc335978355 _Toc335978561 _Toc335985985 _Toc335987497 _Toc336265986 _Toc336312139 _Toc336348885 _Toc336350040 _Toc338123763 _Toc342123830 _Toc342187888 _Toc364568202 _Toc327690826 _Toc327712257 _Toc327861640 _Toc327886520 _Toc328813010 _Toc329751005 _Toc329763269 _Toc330203578 _Toc330342806 _Toc330347619 _Toc330352069 _Toc330610893 _Toc331927007 _Toc334001263 _Toc335798465 _Toc335978367 _Toc335978573 _Toc335985997 _Toc335987509 _Toc336265998 _Toc336312151 _Toc336348897 _Toc336350052 _Toc338123775 _Toc342123842 _Toc342187900 _Toc364568203 _Toc327712260 _Toc327861643 _Toc327886523 _Toc328813013 _Toc329751008 _Toc329763272 _Toc330203581 _Toc330342809 _Toc330347622 _Toc330352072 _Toc330610896 _Toc331927010 _Toc334001266 _Toc335798468 _Toc335978370 _Toc335978576 _Toc335986000 _Toc335987512 _Toc336266001 _Toc336312154 _Toc336348900 _Toc336350055 _Toc338123778 _Toc342123845 _Toc342187903 _Toc364568204 _Toc327712261 _Toc327861644 _Toc327886524 _Toc328813014 _Toc329751009 _Toc329763273 _Toc330203582 _Toc330342810 _Toc330347623 _Toc330352073 _Toc330610897 _Toc331927011 _Toc334001267 _Toc335798469 _Toc335978371 _Toc335978577 _Toc335986001 _Toc335987513 _Toc336266002 _Toc336312155 _Toc336348901 _Toc336350056 _Toc338123779 _Toc342123846 _Toc342187904 _Toc364568205 _Toc327712262 _Toc327861645 _Toc327886525 _Toc328813015 _Toc329751010 _Toc329763274 _Toc330203583 _Toc330342811 _Toc330347624 _Toc330352074 _Toc330610898 _Toc331927012 _Toc334001268 _Toc335798470 _Toc335978372 _Toc335978578 _Toc335986002 _Toc335987514 _Toc336266003 _Toc336312156 _Toc336348902 _Toc336350057 _Toc338123780 _Toc342123847 _Toc342187905 _Toc364568206 _Toc335978373 _Toc335978579 _Toc335986003 _Toc335987515 _Toc336266004 _Toc336312157 _Toc336348903 _Toc336350058 _Toc338123781 _Toc342123848 _Toc342187906 _Toc364568207 _Toc328813017 _Toc329751012 _Toc329763276 _Toc330203585 _Toc330342813 _Toc330347626 _Toc330352076 _Toc330610900 _Toc331927014 _Toc334001270 _Toc335798472 _Toc335978374 _Toc335978580 _Toc335986004 _Toc335987516 _Toc336266005 _Toc336312158 _Toc336348904 _Toc336350059 _Toc338123782 _Toc342123849 _Toc342187907 _Toc364568208 _Toc336350060 _Toc338123783 _Toc342123850 _Toc342187908 _Toc364568209 _Toc329751014 _Toc329763278 _Toc330203587 _Toc330342815 _Toc330347627 _Toc330352077 _Toc330610901 _Toc331927015 _Toc334001271 _Toc335798473 _Toc335978375 _Toc335978581 _Toc335986005 _Toc335987517 _Toc336266006 _Toc336312159 _Toc336348905 _Toc336350061 _Toc338123784 _Toc342123851 _Toc342187909 _Toc364568210 _Toc329763279 _Toc330203588 _Toc330342816 _Toc330347628 _Toc330352078 _Toc330610902 _Toc331927016 _Toc334001272 _Toc335798474 _Toc335978376 _Toc335978582 _Toc335986006 _Toc335987518 _Toc336266007 _Toc336312160 _Toc336348906 _Toc336350062 _Toc338123785 _Toc342123852 _Toc342187910 _Toc364568211 _Toc330342817 _Toc330347629 _Toc330352079 _Toc330610903 _Toc331927017 _Toc334001273 _Toc335798475 _Toc335978377 _Toc335978583 _Toc335986007 _Toc335987519 _Toc336266008 _Toc336312161 _Toc336348907 _Toc336350063 _Toc338123786 _Toc342123853 _Toc342187911 _Toc364568212 _Toc330342818 _Toc330347630 _Toc330352080 _Toc330610904 _Toc331927018 _Toc334001274 _Toc335798476 _Toc335978378 _Toc335978584 _Toc335986008 _Toc335987520 _Toc336266009 _Toc336312162 _Toc336348908 _Toc336350064 _Toc338123787 _Toc342123854 _Toc342187912 _Toc364568213 _Toc330352081 _Toc330610905 _Toc331927019 _Toc334001275 _Toc335798477 _Toc335978379 _Toc335978585 _Toc335986009 _Toc335987521 _Toc336266010 _Toc336312163 _Toc336348909 _Toc336350065 _Toc338123788 _Toc342123855 _Toc342187913 _Toc364568214 _Toc342187915 _Toc364568215 _Toc342187916 _Toc364568216 _Toc364568217 _Toc364568218 _Toc364568219> Paula Tomlinson E:\nt\private\spec\configmg.doc Paula Tomlinson E:\nt\private\spec\configmg.doc Paula Tomlinson E:\nt\private\spec\configmg.doc Paula Tomlinson C:\temp\cfgmgr32.doc Paula Tomlinson C:\temp\cfgmgr32.doc Paula Tomlinson C:\temp\cfgmgr32.doc Paula Tomlinson C:\temp\cfgmgr32.doc Paula Tomlinson C:\temp\cfgmgr32.doc Bret Grinslade0\\ntddk\internl$\ddk\doc\spec\SETUP\CFGMGR32.DOC Andrew Krywaniuk D:\doc\setup\CFGMGR32.DOC @\\MSPRINT44\26S/2MC CORPK 157.55.80.242 Ne00: winspool \\MSPRINT44\26S/2MC CORPK 157.55.80.242 \\MSPRINT44\26S/2MC CORPK 157.5 Letter \\MSPRINT44\26S/2MC CORPK 157.5 Letter Times New Roman Symbol Arial Courier Times LinePrinter -Cairo Setup Application Programming Interface&Spec for Setup APIs available in Cairo Setup, API6This spec details the APIs exposed in the setupnt.dll. Bret Grinslade Andrew Krywaniuk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\references\cfgmgr32.doc ===
Microsoft Word Document MSWordDoc Word.Document.6Microsoft Cairo Setup Application Programming InterfaceCairo Setup Application Programming Interface Spec for Setup APIs available in Cairo Bret Grinslade Setup, API This spec details the APIs exposed in the setupnt.dll. Normal.dot Andrew Krywaniuk Microsoft Word for Windows 95Windows NT Group 32-Bit Configuration Manager Application Programming Interface  TOC \o "1-3"  1. Overview  GOTOBUTTON _Toc364568172    PAGEREF _Toc364568172  2. The Configuration Manager APIs  GOTOBUTTON _Toc364568173    PAGEREF _Toc364568173  2.1 Data Structures  GOTOBUTTON _Toc364568174    PAGEREF _Toc364568174  2.1.1 Memory Resource  GOTOBUTTON _Toc364568175    PAGEREF _Toc364568175  2.1.2 I/O Port Resource  GOTOBUTTON _Toc364568176    PAGEREF _Toc364568176  2.1.3 DMA Resource  GOTOBUTTON _Toc364568177    PAGEREF _Toc364568177  2.1.4 Interrupt Resource  GOTOBUTTON _Toc364568178    PAGEREF _Toc364568178  2.1.5 Class-Specific Resource  GOTOBUTTON _Toc364568179    PAGEREF _Toc364568179  2.1.6 Hardware Profile Information  GOTOBUTTON _Toc364568180    PAGEREF _Toc364568180  2.1.7 Miscellaneous  GOTOBUTTON _Toc364568181    PAGEREF _Toc364568181  2.2 Routines  GOTOBUTTON _Toc364568182    PAGEREF _Toc364568182  2.2.1 CM_Add_Empty_Log_Conf  GOTOBUTTON _Toc364568183    PAGEREF _Toc364568183  2.2.4 CM_Add_Res_Des  GOTOBUTTON _Toc364568184    PAGEREF _Toc364568184  2.2.13 CM_Free_Log_Conf  GOTOBUTTON _Toc364568185    PAGEREF _Toc364568185  2.2.15 CM_Free_Res_Des  GOTOBUTTON _Toc364568186    PAGEREF _Toc364568186  2.2.16 CM_Get_Child  GOTOBUTTON _Toc364568187    PAGEREF _Toc364568187  2.2.18 CM_Get_Device_ID  GOTOBUTTON _Toc364568188    PAGEREF _Toc364568188  2.2.19 CM_Get_Device_ID_Size  GOTOBUTTON _Toc364568189    PAGEREF _Toc364568189  2.2.20 CM_Get_DevNode_Status  GOTOBUTTON _Toc364568190    PAGEREF _Toc364568190  2.2.21 CM_Get_First_Log_Conf  GOTOBUTTON _Toc364568191    PAGEREF _Toc364568191  2.2.23 CM_Get_Hardware_Profile_Info  GOTOBUTTON _Toc364568192    PAGEREF _Toc364568192  2.2.24 CM_Get_HW_Prof_Flags  GOTOBUTTON _Toc364568193    PAGEREF _Toc364568193  2.2.25 CM_Get_Next_Log_Conf  GOTOBUTTON _Toc364568194    PAGEREF _Toc364568194  2.2.26 CM_Get_Next_Res_Des  GOTOBUTTON _Toc364568195    PAGEREF _Toc364568195  2.2.27 CM_Get_Parent  GOTOBUTTON _Toc364568196    PAGEREF _Toc364568196  2.2.28 CM_Get_Res_Des_Data  GOTOBUTTON _Toc364568197    PAGEREF _Toc364568197  2.2.29 CM_Get_Res_Des_Data_Size  GOTOBUTTON _Toc364568198    PAGEREF _Toc364568198  2.2.30 CM_Get_Sibling  GOTOBUTTON _Toc364568199    PAGEREF _Toc364568199  2.2.31 CM_Get_Version  GOTOBUTTON _Toc364568200    PAGEREF _Toc364568200  2.2.34 CM_Locate_DevNode  GOTOBUTTON _Toc364568201    PAGEREF _Toc364568201  2.2.36 CM_Modify_Res_Des  GOTOBUTTON _Toc364568202    PAGEREF _Toc364568202  2.2.48 CM_Set_HW_Prof_Flags  GOTOBUTTON _Toc364568203    PAGEREF _Toc364568203  2.3 New Routines  GOTOBUTTON _Toc364568204    PAGEREF _Toc364568204  2.3.1 CM_Get_DevNode_Registry_Property  GOTOBUTTON _Toc364568205    PAGEREF _Toc364568205  2.3.2 CM_Set_DevNode_Registry_Property  GOTOBUTTON _Toc364568206    PAGEREF _Toc364568206  2.3.3 CM_Open_DevNode_Key  GOTOBUTTON _Toc364568207    PAGEREF _Toc364568207  2.3.4 CM_Delete_DevNode_Key  GOTOBUTTON _Toc364568208    PAGEREF _Toc364568208  2.3.5 CM_Open_Class_Key  GOTOBUTTON _Toc364568209    PAGEREF _Toc364568209  2.3.6 CM_Enumerate_Classes  GOTOBUTTON _Toc364568210    PAGEREF _Toc364568210  2.3.7 CM_Get_Class_Name  GOTOBUTTON _Toc364568211    PAGEREF _Toc364568211  2.3.8 CM_Enumerate_Enumerators  GOTOBUTTON _Toc364568212    PAGEREF _Toc364568212  2.3.9 CM_Get_Device_ID_List  GOTOBUTTON _Toc364568213    PAGEREF _Toc364568213  2.3.10 CM_Get_Device_ID_List_Size  GOTOBUTTON _Toc364568214    PAGEREF _Toc364568214  2.3.12 CM_Connect_Machine  GOTOBUTTON _Toc364568215    PAGEREF _Toc364568215  2.3.13 CM_Disconnect_Machine  GOTOBUTTON _Toc364568216    PAGEREF _Toc364568216  2.3.14 CM_Free_Log_Conf_Handle  GOTOBUTTON _Toc364568217    PAGEREF _Toc364568217  2.3.15 CM_Free_Res_Des_Handle  GOTOBUTTON _Toc364568218    PAGEREF _Toc364568218  2.3.16 CM_Detect_Resource_Conflict  GOTOBUTTON _Toc364568219    PAGEREF _Toc364568219  1. Overview This document describes the 32-bit implementation of the Configuration Manager APIs.  These APIs provide routines to control and configure devices in a Plug & Play environment.  In Windows 95, the Configuration Manager is a VxD, and it exposes these routines as services to both ring 0 and ring 3 components.  In Windows NT, however, these routines will expose functionality from the user-mode Plug&Play manager, thus are exclusively user-mode APIs. The API set presented here is the common subset of APIs that will be shared by a future version of Windows 95 as well as Windows NT.  Windows 95 provides additional CM APIs today in their 16-bit implementation, some of which they may provide in their 32-bit version as well.  These Win95-specific routines will return CR_CALL_NOT_IMPLEMENTED under Windows NT. The structures and routines have been kept as close to their 16-bit counterparts as possible--only expanding the fields and parameters where necessary.  In certain cases, parameters were expanded even larger to represent the larger capacity of Windows NT (e.g. memory ranges are 64-bit). One other important point to note regards synchronization.  In the current (16-bit) implementation, there exist CM APIs that lock the Configuration Manager, thus ensuring that the machine s state doesn t change while someone is in the middle of configuration, enumeration, etc.  Such global locking mechanisms are incompatible with Windows NT goals of concurrency, robustness, etc., so these APIs will not be implemented on Windows NT.  Atomicity will be ensured within a single CM call, but no assumptions can be made about the consistency of state from one call to the next.  Applications will have to be prepared to deal with the situation where, for example, they are enumerating all sibling device instances and, when halfway through, receive a CR_NO_SUCH_DEVNODE, because the parent device instance was removed.  This is analogous to the way registry enumeration must be handled (e.g., calling RegQueryInfoKey returns that there are 5 subkeys of the specified key, but subsequent attempts at enumerating them fail because someone else has deleted them in the meantime).  Indeed, it should be noted that Windows 95 relies on the registry for the storage of much of its Plug & Play configuration information, and therefore is still vulnerable to some extent to asynchronous changes happening that change the system s state, even while CM_Lock is held. The 32-bit Configuration Manager routines are defined to support both the Unicode and ANSI string set (as with other Win32 routines, the corresponding Unicode or ANSI version of the routine is called based on whether UNICODE is defined or not). The Unicode versions will return CR_CALL_NOT_IMPLEMENTED on Windows 95. The Windows NT implementation of these routines is remotable to remote machines via a set of extended configuration manager routines (CM_xxx_Ex). A caller can connect to a remote machine by calling CM_Connect_Machine. The handle returned in that call can then be passed to other extended Configuration manager routines. This feature is only implemented on Windows NT. 2. The Configuration Manager APIs 2.1 Data Structures 2.1.1 Memory Resource The following flags specify attributes for a memory range.  Each bit flag is identified with a constant bitmask, and two additional constants are associated with it specifying the values generated by AND ing the attribute value with the bitmask. fMD_MemoryType (0x1)  Bitmask for flag indicating whether the memory range may be written to.  The two possible values are: fMD_ROM (0x0)  Memory range is read-only fMD_RAM (0x1)  Memory range may be written to fMD_32_24 (0x2)  Bitmask for flag indicating whether the memory range is 24 or 32-bit.  Under Windows NT, this flag will always specify 32-bit memory.  The two possible values are: fMD_24 (0x0)  Memory range is 24-bit (e.g., ISA PnP).  This flag will never be set on Windows NT. fMD_32 (0x2)  Memory range is 32-bit fMD_Prefetchable (0x4)  Bitmask for flag indicating whether the memory range is prefetchable (i.e., does it support read-ahead caching?).  The two possible values are: fMD_PrefetchDisallowed (0x0)  Memory range is not prefetchable fMD_PrefetchAllowed (0x4)  Memory range is prefetchable fMD_Readable (0x8)  Bitmask for flag indicating whether the memory range may be read.  The two possible values are: fMD_ReadAllowed (0x0)  Memory range is readable fMD_ReadDisallowed (0x8)   Memory range is write-only fMD_CombinedWrite (0x10)  Bitmask for flag indicating whether the memory range supports combined-write (i.e., write-behind) caching.  The two possible values are: fMD_CombinedWriteDisallowed (0x0)  Memory range does not support combined-write caching fMD_CombinedWriteAllowed (0x10)  Memory range supports combined-write caching typedef struct Mem_Range_s { DWORDLONG MR_Align; ULONG MR_nBytes; DWORDLONG MR_Min; DWORDLONG MR_Max; DWORD MR_Flags; DWORD MR_Reserved; } MEM_RANGE, *PMEM_RANGE; MEM_RANGE Structure: MR_Align  Specifies the mask for the base alignment. MR_nBytes  Specifies the number of bytes required. MR_Min  Specifies the minimum address of the range. MR_Max  Specifies the maximum address of the range. MR_Flags  Specifies flags describing the range.  May be a combination of the fMD flags described above typedef struct Mem_Des_s { DWORD MD_Count; DWORD MD_Type; DWORDLONG MD_Alloc_Base; DWORDLONG MD_Alloc_End; DWORD MD_Flags; DWORD MD_Reserved; } MEM_DES, *PMEM_DES; MEM_DES Structure: MD_Count  Specifies the number of MEM_RANGE structs in the MEM_RESOURCE structure that this struct is contained in. MD_Type  Specifies the size, in bytes, of the MEM_RANGE structure (used for versioning).  This should be set to MType_Range. MD_Alloc_Base  Specifies the base memory address of the range that was allocated. MD_Alloc_End  Specifies the end of the allocated memory range. MD_Flags  Specifies flags describing the allocated range.  May be a combination of the fMD flags described above. typedef struct Mem_Resource_s { MEM_DES MEM_Header; MEM_RANGE MEM_Data[ANYSIZE_ARRAY]; } MEM_RESOURCE, *PMEM_RESOURCE; MEM_RESOURCE Structure: MEM_Header  Specifies information about the memory range list, as well as the currently allocated memory range. MEM_Data  Contains the list of memory ranges.  The count of memory ranges in this array is given by the MD_Count field in the MEM_Header. 2.1.2 I/O Port Resource The following flags specify attributes for a IO port range.  Each bit flag is identified with a constant bitmask, and two additional constants are associated with it specifying the values generated by AND ing the attribute value with the bitmask. fIOD_PortType (0x1)  Bitmask for flag indicating whether the port is memory or IO.  The two possible values are: fIOD_Memory (0x0)  The Port resource is memory fIOD_IO (0x1)  The Port resource is IO typedef struct IO_Range_s { DWORDLONG IOR_Align; DWORD IOR_nPorts; DWORDLONG IOR_Min; DWORDLONG IOR_Max; DWORD IOR_RangeFlags; DWORDLONG IOR_Alias; } IO_RANGE, *PIO_RANGE; IO_RANGE Structure: IOR_Align  Specifies the mask for the base alignment IOR_nPorts  Specifies the number of ports IOR_Min  Specifies the minimum port address IOR_Max  Specifies the maximum port address IOR_RangeFlags  Specifies flags for this port range IOR_Alias  Specifies a multiplier that generates all aliases for the port(s).  This number is right-shifted by 8 bits, removing the least-significant byte (thus forcing it to always be zero), so the real multiplier is IOR_Alias * 256.  The minimum alias is 4. Remarks: The Alias mask provide additional flexibility in specifying how the address is handled. It provides a convenient method for specifying what port aliases a card responds to. An alias is a port address that is responded to as if it were another address.  The following table illustrates the most common alias values: Specifies that the card supports 16-bit decode Specifies that the card supports 10-bit decode (i.e., 3f2, 7f2, ...) Specifies that the card supports 12-bit decode (i.e., 3f2, 13f2, ...) This is a special value, it specifies positive decode for a PCI device. E.g., an ISA card may decode 10 bits and require port 03C0h. It would need to specify an Alias offset of 04h. For convenience, the alias field can be set to zero indicate no aliases are required. typedef struct IO_Des_s { DWORD IOD_Count; DWORD IOD_Type; DWORDLONG IOD_Alloc_Base; DWORDLONG IOD_Alloc_End; DWORD IOD_DesFlags; } IO_DES, *PIO_DES; IO_DES Structure: IOD_Count  Specifies the number of IO_RANGE structs in the IO_RESOURCE structure that this struct is contained in. IOD_Type  Specifies the size, in bytes, of the IO_RANGE structure (used for versioning).  This should be set to IOType_Range. IOD_Alloc_Base  Specifies the base of the allocated port range. IOD_Alloc_End  Specifies the end of the allocated port range. IOD_DesFlags  Specifies flags relating to the allocated port range typedef struct IO_Resource_s { IO_DES IO_Header; IO_RANGE IO_Data[ANYSIZE_ARRAY]; } IO_RESOURCE, *PIO_RESOURCE; IO_RESOURCE Structure: IO_Header  Specifies information about the I/O port range list, as well as the currently allocated I/O port range. IO_Data  Contains the list of I/O port ranges.  The count of I/O port ranges in this array is given by the IOD_Count field in the IO_Header. 2.1.3 DMA Resource The following flags specify attributes for a DMA resource range.  Each bit flag is identified with a constant bitmask, and additional constants are associated with it specifying the values generated by AND ing the attribute value with the bitmask. mDD_Width (0x3)  Bitmask for flags indicating the width of the DMA channel (byte, word, or dword).  The three possible values are: fDD_BYTE (0x0)  8-bit DMA channel fDD_WORD (0x1)  16-bit DMA channel fDD_DWORD (0x2)  32-bit DMA channel typedef struct DMA_Range_s { ULONG DR_Min; ULONG DR_Max; ULONG DR_Flags; } DMA_RANGE, *PDMA_RANGE; DMA_RANGE Structure: DR_Min  Specifies the minimum DMA port in the range DR_Max  Specifies the maximum DMA port in the range DR_Flags  Specifies flags describing the range.  May be one of the fDD flags described above.  This value must be the same as the DD_Flags value in the corresponding DMA_DES structure. typedef struct DMA_Des_s { DWORD DD_Count; DWORD DD_Type; DWORD DD_Flags; ULONG DD_Alloc_Chan; } DMA_DES, *PDMA_DES; DMA_DES Structure: DD_Count  Specifies the number of DMA_RANGE structs in the DMA_RESOURCE structure that this struct is contained in.  If this value is 0, then the DD_Req_Mask must be used to determine the possible DMA channels. DD_Type  Specifies the size, in bytes, of the DMA_RANGE structure (used for versioning).  This should be set to DType_Range. DD_Flags  Specifies flags describing the DMA channel.  May be one of the fDD flags described above. DD_Alloc_Chan  Specifies the DMA channel that was allocated. typedef struct DMA_Resource_s { DMA_DES DMA_Header; DMA_RANGE DMA_Data[ANYSIZE_ARRAY]; } DMA_RESOURCE, *PDMA_RESOURCE; DMA_RESOURCE Structure: DMA_Header  Specifies information about the DMA channel range list, as well as the currently allocated DMA channel. DMA_Data  Contains the list of DMA channel ranges.  The count of DMA channel ranges in this array is given by the DD_Count field in the DMA_Header. 2.1.4 Interrupt Resource The following flags specify attributes for an interrupt resource range.  Each bit flag is identified with a constant bitmask, and additional constants are associated with it specifying the values generated by AND ing the attribute value with the bitmask. mIRQD_Share (0x1)  Bitmask for flag indicating whether the IRQ may be shared.  The two possible values are: fIRQD_Exclusive (0x0)  The IRQ may not be shared fIRQD_Share (0x1)  The IRQ may be shared mIRQD_Edge_Level (0x2)  Bitmask for flag indicating whether the IRQ is edge- or level-sensitive.  The two possible values are: fIRQD_Level (0x0)  The IRQ is level-sensitive. fIRQD_Edge (0x2)  The IRQ is edge-sensitive. typedef struct IRQ_Range_s { ULONG IRQR_Min; ULONG IRQR_Max; ULONG IRQR_Flags; } IRQ_RANGE, *PIRQ_RANGE; IRQ_RANGE Structure: IRQR_Min  Specifies the minimum IRQ in the range IRQR_Max  Specifies the maximum IRQ in the range IRQR_Flags  Specifies flags describing the range.  May be one of the fIRQD flags described above.  This value must be the same as the IRQD_Flags value in the corresponding IRQ_DES structure. typedef struct IRQ_Des_s { DWORD IRQD_Count; DWORD IRQD_Type; DWORD IRQD_Flags; ULONG IRQD_Alloc_Num; ULONG IRQD_Affinity; } IRQ_DES, *PIRQ_DES; IRQ_DES Structure: IRQD_Count  Specifies the number of IRQ_RANGE structs in the IRQ_RESOURCE structure that this struct is contained in.  If this value is 0, then the IRQD_Req_Mask must be used to determine the possible IRQs. IRQD_Type  Specifies the size, in bytes, of the IRQ_RANGE structure (used for versioning).  This should be set to IRQType_Range.  If this value is zero, then the IRQ_RANGE list must not be used, and the IRQD_Req_Mask must be used instead to determine possible IRQs. IRQD_Flags  Specifies flags describing the IRQ.  May be one of the fIRQD flags described above. IRQD_Alloc_Num  Specifies the IRQ that was allocated. IRQD_Affinity  Specifies the affinity of the IRQ (a value of 0xFFFFFFFF means the interrupt can be serviced by any available processor) typedef struct IRQ_Resource_s { IRQ_DES IRQ_Header; IRQ_RANGE IRQ_Data[ANYSIZE_ARRAY]; } IRQ_RESOURCE, *PIRQ_RESOURCE; IRQ_RESOURCE Structure: IRQ_Header  Specifies information about the IRQ range list, as well as the currently allocated IRQ. IRQ_Data  Contains the list of IRQ ranges.  The count of IRQ ranges in this array is given by the IRQD_Count field in the IRQ_Header. 2.1.5 Class-Specific Resource There may only be one class-specific resource in a particular logical configuration.  This resource is ignored by all arbitrators, Device Manager, etc. #define GUID_STRING_LEN (39) // always 38 chars + terminating NULL typedef struct CS_Des_s { DWORD CSD_SignatureLength; DWORD CSD_LegacyDataOffset; DWORD CSD_LegacyDataSize; DWORD CSD_Flags; GUID CSD_ClassGuid; BYTE CSD_Signature[ANYSIZE_ARRAY]; } CS_DES, *PCS_DES; CS_DES Structure: CSD_SignatureLength  Specifies the size, in bytes, of the class-specific Plug&Play device signature stored at the beginning of the CSD_Signature buffer. CSD_LegacyDataOffset  Specifies the offset, in bytes, from the beginning of the CSD_Signature buffer where the legacy class-specific data begins.  For Windows NT, this data represents the existing contents of the CmResourceTypeDeviceSpecific partial resource descriptor in a CM_RESOURCE_LIST. CSD_LegacyDataSize  Specifies the size, in bytes, of the legacy data. CSD_Flags  No flags are currently defined for this resource type. CSD_ClassGuid  Specifies the class GUID for this signature. CSD_Signature  Variable-length buffer including the Plug&Play device signature and/or legacy class-specific data.  The format of both of these buffers is dependent upon the class specified by CSD_ClassGuid. typedef struct CS_Resource_s { CS_DES CS_Header; } CS_RESOURCE, *PCS_RESOURCE; CS_RESOURCE Structure: CS_Header  Specifies class-specific information about the device associated with this logical configuration. 2.1.6 Hardware Profile Information typedef struct HWProfileInfo_s { ULONG HWPI_ulHWProfile; TCHAR HWPI_szFriendlyName[MAX_PROFILE_LEN]; DWORD HWPI_dwFlags; } HWPROFILEINFO, *PHWPROFILEINFO; Hardware Profile Information Structure: HWPI_ulHWProfile  Handle of the hardware profile. HWPI_szFriendlyName  Friendly name of the hardware profile. HWPI_dwFlags  Flags relating to this hardware profile.  Currently, only bits 0 and 1 are used.  May be one of the following values: Hardware Profile Information Flags: CM_HWPI_NOT_DOCKABLE (0x00000000)  This machine is not dockable. CM_HWPI_UNDOCKED (0x00000001)  This hardware profile is for a docked configuration. CM_HWPI_DOCKED (0x00000002)  This hardware profile is for an undocked configuration. 2.1.7 Miscellaneous Standardized Return Value: typedef DWORD        RETURN_TYPE; typedef RETURN_TYPE  CONFIGRET; Device Instance Handle typedef DWORD        DEVNODE; typedef DEVNODE     *PDEVNODE; Device Instance Identifier typedef TCHAR       *DEVNODEID; The device instance ID specifies the registry path, relative to the Enum key , for a device instance.  For example:  Root\*PNP0500\0000. Logical Configuration Handle: typedef DWORD        LOG_CONF; typedef LOG_CONF    *PLOG_CONF; Resource Descriptor Handle: typedef DWORD        RES_DES; typedef RES_DES     *PRES_DES; Remote Machine Handle: typedef HANDLE       HMACHINE; typedef HMACHINE    *PHMACHINE; Resource ID: typedef ULONG        RESOURCEID; typedef RESOURCEID  *PRESOURCEID; This data type may take one of the following values: ResType_All (0x00000000)  Return all resource types ResType_None (0x00000000)  Arbitration always succeeds ResType_Mem (0x00000001)  Physical address resource ResType_IO (0x00000002)  Physical I/O address resource ResType_DMA (0x00000003)  DMA channels resource ResType_IRQ (0x00000004)  IRQ resource ResType_MAX (0x00000004)  Maximum known ResType ResType_Ignored_Bit (0x00008000)  Ignore this resource ResType_ClassSpecific (0x0000FFFF)  Class-specific resource Registry Key Open Disposition: typedef ULONG        REGDISPOSITION; This data type may take one of the following values: RegDisposition_OpenAlways (0x00000000)  Open the key if it exists, otherwise, create the key.  RegDisposition_OpenExisting (0x00000001)  Open the key only if it already exists. Priority: typedef ULONG        PRIORITY; This data type may take one of the following values: LCPRI_FORCECONFIG (0x00000000)  Coming from a forced config LCPRI_BOOTCONFIG (0x00000001)  Coming from a boot config LCPRI_DESIRED (0x00002000)  Preferable set (better performance) LCPRI_NORMAL (0x00003000)  Workable (acceptable performance) LCPRI_LASTBESTCONFIG (0x00003FFF)  CM only--do not use LCPRI_SUBOPTIMAL (0x00005000)  Not desired, but will work LCPRI_LASTSOFTCONFIG (0x00007FFF)  CM only--do not use LCPRI_RESTART (0x00008000)  Need to restart Windows LCPRI_REBOOT (0x00009000)  Need to reboot Windows LCPRI_POWEROFF (0x0000A000)  Need to shutdown/power-off the machine LCPRI_HARDRECONFIG (0x0000C000)  Need to change a jumper LCPRI_HARDWIRED (0x0000E000)  Cannot be changed LCPRI_IMPOSSIBLE (0x0000F000)  Impossible configuration LCPRI_DISABLED (0x0000FFFF)  Disabled configuration MAX_LCPRI (0x0000FFFF)  Maximum known LC Priority Range List Handle: typedef DWORD              RANGE_LIST; typedef RANGE_LIST        *PRANGE_LIST; Range Element Handle: typedef DWORD              RANGE_ELEMENT; typedef RANGE_ELEMENT     *PRANGE_ELEMENT; 2.2 Routines 2.2.1 CM_Add_Empty_Log_Conf This routine creates an empty logical configuration.  This configuration has no resource descriptor. CONFIGRET CM_Add_Empty_Log_Conf ( OUT PLOG_CONF plcLogConf, IN DEVNODE dnDevNode, IN PRIORITY Priority, IN ULONG ulFlags Parameters: plcLogConf  Address of a variable that receives the handle of the logical configuration. dnDevNode  Handle of a device instance.  This handle is typically retrieved by a call to CM_Locate_DevNode. Priority  Specifies the priority of the logical configuration.  (See Section   REF MiscDataStructs \* MERGEFORMAT   for list of possible Priority values.) ulFlags  Supplies flags relating to the logical configuration.  Must be either BASIC_LOG_CONF , BOOT_LOG_CONF, FILTERED_LOG_CONF, combined with either PRIORITY_EQUAL_FIRST or PRIORITY_EQUAL_LAST. Logical Configuration Flags: BASIC_LOG_CONF  Specifies the requirements list FILTERED_LOG_CONF  Specifies the filtered requirements list OVERRIDE_LOG_CONF  Specifies the filtered requirements list that overrides the FILTERED_LOG_CONF and BASIC_LOG_CONF. BOOT_LOG_CONF  Specifies the boot configuration (only one of these may exist for a particular device instance.  Attempting to add a boot log config to a devnode that already has one fails with the error CR_INVALID_LOG_CONF) FORCED_LOG_CONF  Specifies a configuration that was specifically chosen (typically via an INF or a user). ALLOC_LOG_CONF  Specifies the configuration the device is currently using. PRIORITY_EQUAL_FIRST  Same priority, new one is first PRIORITY_EQUAL_LAST  Same priority, new one is last Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_LOG_CONF, CR_INVALID_FLAG, CR_INVALID_POINTER, CR_OUT_OF_MEMORY. Remarks: Calling this API may invalidate the logical configuration handles returned by the CM_Get_First_Log_Conf and CM_Get_Next_Log_Conf routines.  To continue enumerating logical configurations after adding a logical configuration, always call CM_Get_First_Log_Conf to start again from the beginning.  When the logical configuration handle returned by CM_Add_Empty_Log_Conf is no longer needed, it should be freed by calling CM_Free_Log_Conf_Handle. Note: The CM_Add_Empty_Log_Config routine is used to create logical configurations of any valid Xxx_LOG_CONF type. When adding resource descriptors (by calling CM_Add_Res_Des), you also fill in one of the Xxx_RESOURCE structure fields. The Xxx_RESOURCE structure fields provide for describing both a specific resource (described in the Xxx_DES embedded structure) or a range of possible resources (described in one or more Xxx_RANGE embedded structures). The BASIC_LOG_CONF, FILTERED_LOG_CONF, and OVERRIDE_LOG_CONF logical configuration types describe a range of possible resource configurations. As such, the individual resource descriptors within those logical configurations will have one or more Xxx_RANGE structures filled out and the specific resource data fields of the Xxx_DES field will be ignored. Likewise, the ALLOC_LOG_CONF, BOOT_LOG_CONF, and FORCED_LOG_CONF logical configuration types describe a specific configuration. As such, the individual resource descriptors within those logical configurations will have a completely filled out Xxx_DES structure but will not contain any Xxx_RANGE structures (the count field in the Xxx_DES structure will be zero). 2.2.4 CM_Add_Res_Des This routine adds a resource descriptor to a logical configuration. CONFIGRET CM_Add_Res_Des ( OUT PRES_DES prdResDes, OPTIONAL IN LOG_CONF lcLogConf, IN RESOURCEID ResourceID, IN PVOID ResourceData, IN ULONG ResourceLen, IN ULONG ulFlags Parameters: prdResDes  Optionally specifies the address of a variable that receives a handle for the new resource descriptor. lcLogConf  Supplies the handle of the logical configuration to which the resource descriptor is added. ResourceID  Specifies the type of the resource.  Can be one of the ResType values defined in Section   REF MiscDataStructs \* MERGEFORMAT  ResourceData  Supplies the address of an IO_RESOURCE, MEM_RESOURCE, DMA_RESOURCE, IRQ_RESOURCE, or CS_RESOURCE structure, depending on the given resource type. ResourceLen  Supplies the size, in bytes, of the structure pointed to by ResourceData. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_LOG_CONF, CR_INVALID_POINTER, CR_INVALID_RESOURCE_ID, or CR_OUT_OF_MEMORY. Remarks: When the resource descriptor handle returned by CM_Add_Res_Des is no longer needed, it should be freed by calling CM_Free_Res_Des_Handle. 2.2.13 CM_Free_Log_Conf This routine frees a logical configuration and all resource descriptors associated with it. CONFIGRET CM_Free_Log_Conf ( IN LOG_CONF lcLogConfToBeFreed, IN ULONG ulFlags Parameters: lcLogConfToBeFreed  Supplies the handle of the logical configuration to free.  This handle must have been previously returned from a call to CM_Add_Empty_Log_Conf. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG or CR_INVALID_LOG_CONF. Remarks: This API may invalidate the logical configuration handles returned by the CM_Get_First_Log_Conf and CM_Get_Next_Log_Conf APIs.  To continue enumerating logical configurations, always use the CM_Get_First_Log_Conf API to start again from the beginning. 2.2.15 CM_Free_Res_Des This routine destroys a resource descriptor. CONFIGRET CM_Free_Res_Des ( IN PRES_DES prdResDes, IN RES_DES rdResDes, IN ULONG ulFlags Parameters: prdResDes  Supplies the address of the variable that receives the handle of the previous resource descriptor.  If rdResDes is the handle of the first resource descriptor, this address receives the handle of the logical configuration. rdResDes  Supplies the handle of the resource descriptor to be destroyed. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, CR_INVALID_RES_DES, or CR_NO_MORE_RES_DES. Remarks: This API returns CR_NO_MORE_RES_DES if rdResDes specifies the last resource descriptor. If this API does return the previous resource descriptor, then that resource descriptor handle should be freed (by calling CM_Free_Res_Des_Handle) when it is no longer needed. 2.2.16 CM_Get_Child This routine retrieves the first child of a given device instance. CONFIGRET CM_Get_Child ( OUT PDEVNODE pdnDevNode, IN DEVNODE dnDevNode, IN ULONG ulFlags Parameters: pdnDevNode  Supplies the address of the variable that receives the handle of the device instance. dnDevNode  Supplies the handle of the parent device instance. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_NO_SUCH_DEVNODE. 2.2.18 CM_Get_Device_ID This routine retrieves the device identifier for a device instance. CONFIGRET CM_Get_Device_ID ( IN DEVNODE dnDevNode, OUT PTCHAR Buffer, IN ULONG BufferLen, IN ULONG ulFlags Parameters: dnDevNode  Supplies the handle of the device instance for which to retrieve the device identifier. Buffer  Supplies the address of the buffer that receives the device identifier.  If this buffer is larger than the device identifier, the API appends a null-terminating character to the data.  If it is smaller than the device identifier, the API fills it with as much of the device identifier as will fit and returns CR_BUFFER_SMALL. BufferLen  Supplies the size, in characters, of the buffer for the device identifier. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_BUFFER_SMALL, CR_INVALID_DEVNODE, CR_INVALID_FLAG, or CR_INVALID_POINTER. 2.2.19 CM_Get_Device_ID_Size This routine retrieves the size of a device identifier from a device instance. CONFIGRET CM_Get_Device_ID_Size ( OUT PULONG pulLen, IN DEVNODE dnDevNode, IN ULONG ulFlags Parameters: pulLen  Supplies the address of the variable that receives the size in characters, not including the terminating NULL, of the device identifier.  The API sets the variable to 0 if no identifier exists.  The size is always less than or equal to MAX_DEVICE_ID_LEN. dnDevNode  Supplies the handle of the device instance. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_FLAG, or CR_INVALID_POINTER. Remarks: The device identifier for a device instance consists of the identifier of the enumerator immediately above this device in the hardware tree, the identifier of the device, and the instance number of the device.  For example, the device identifier for an Adaptec 1540c might be \isaenum\aha1540c\1.  Although in Windows 95, this string may be used as a key into the registry, the registry locations are different on Windows NT, and therefore this string should no longer be used for this purpose. The device identifier is limited to MAX_DEVICE_ID_LEN characters. 2.2.20 CM_Get_DevNode_Status This routine retrieves the status of a device instance. CONFIGRET CM_Get_DevNode_Status ( OUT PULONG pulStatus, OUT PULONG pulProblemNumber, IN DEVNODE dnDevNode, IN ULONG ulFlags Parameters: pulStatus  Supplies the address of the variable that receives the status flag of the device instance.  Can be a combination of the following values: Status Flags: DN_HAS_PROBLEM  The device installer is required to resolve conflicts. DN_NEED_TO_ENUM  The device instance may need reenumeration. DN_ROOT_ENUMERATED  The device instance was enumerated by the root. DN_STARTED  The device instance is currently configured. DN_MOVED  The device instance has been moved. DN_DISABLEABLE  The device instance may be reconfigured. DN_REMOVABLE  The device instance may be removed. DN_WILL_BE_REMOVED  The device instance is being removed. pulProblemNumber  Supplies the address of the variable that receives an identifier indicating the problem.  Can be one of the following values: Problem Values: CM_PROB_DISABLED  The device instance is disabled. CM_PROB_NOT_CONFIGURED  There is no configuration for this device. CM_PROB_NEED_RESTART  The problem requires a shutdown-restart. CM_PROB_WILL_BE_REMOVED  The device instance will be removed. CM_PROB_FAILED_INSTALL  The installation of this device instance was unsuccessful. CM_PROB_FAILED_START  The driver for this device instance failed to start CM_PROB_REINSTALL  This device instance needs to be installed CM_PROB_MOVED   The device instance has been moved. dnDevNode  Supplies the handle of the device instance for which to retrieve status. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_FLAG, or CR_INVALID_POINTER. 2.2.21 CM_Get_First_Log_Conf This routine returns a handle to the first logical configuration of the specified type in a device instance. CONFIGRET CM_Get_First_Log_Conf ( OUT PLOG_CONF plcLogConf, IN DEVNODE dnDevNode, IN ULONG ulFlags Parameters: plcLogConf  Supplies the address of the variable that receives the handle of the logical configuration. dnDevNode  Supplies the handle of the device instance for which to retrieve the logical configuration. ulFlags  Configuration type.  Can be one of the following values: Configuration Type Values: ALLOC_LOG_CONF  Retrieve the allocated configuration. BASIC_LOG_CONF  Retrieve the requirements list. BOOT_LOG_CONF  Retrieve the boot configuration. The following additional configuration type is also defined for Windows 95: FILTERED_LOG_CONF  Retrieve the filtered requirements list. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_NO_MORE_LOG_CONF. Remarks: The CM_Add_Empty_Log_Conf and CM_Free_Log_Conf APIs may invalidate the handle of the logical configuration returned by this API.  To enumerate logical configurations after adding or freeing a logical configuration, always call this API again to retrieve a valid handle. When the logical configuration handle returned by CM_Get_First_Log_Conf is no longer needed, it should be freed by calling CM_Free_Log_Conf_Handle. 2.2.23 CM_Get_Hardware_Profile_Info This routine returns information about a hardware profile. CONFIGRET CM_Get_Hardware_Profile_Info ( IN ULONG ulIndex, OUT PHWPROFILEINFO pHWProfileInfo, IN ULONG ulFlags Parameters: ulIndex  Supplies the index of the hardware profile to retrieve information for.  Specifying 0xFFFFFFFF references the currently active hardware profile. pHWProfileInfo  Supplies the address of a HWPROFILEINFO structure that will receive information about the specified hardware profile. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is a CR error code. 2.2.24 CM_Get_HW_Prof_Flags This routine retrieves the configuration-specific configuration flags for a device instance and hardware profile combination. CONFIGRET CM_Get_HW_Prof_Flags ( IN DEVINSTID szDevNodeName, IN ULONG ulHardwareProfile, OUT PULONG pulValue, IN ULONG ulFlags Parameters: szDevNodeName  Supplies the address of a NULL-terminated string specifying the name of the device instance to query. ulHardwareProfile  Supplies the handle of the hardware profile to query.  If 0, the API queries the current hardware profile. pulValue  Supplies the address of the variable that receives the configuration-specific configuration (CSCONFIGFLAG_) flags. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_REGISTRY_ERROR. 2.2.25 CM_Get_Next_Log_Conf This routine returns a handle to the next logical configuration following the given configuration. CONFIGRET CM_Get_Next_Log_Conf ( OUT PLOG_CONF plcLogConf, IN LOG_CONF lcLogConf, IN ULONG ulFlags Parameters: plcLogConf  Supplies the address of the variable that receives the handle of the next logical configuration. lcLogConf  Supplies the handle of a logical configuration.  This handle must have been previously retrieved using either this API or the CM_Get_First_Log_Conf API.  Logical configurations are in priority order. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_LOG_CONF, CR_INVALID_POINTER, or CR_NO_MORE_LOG_CONF. Remarks: This API returns CR_NO_MORE_LOG_CONF if the given handle was retrieved using the CM_Get_First_Log_Conf API with either the ALLOC_LOG_CONF or BOOT_LOG_CONF flag.  There is never more than one active boot logical configuration or currently-allocated logical configuration. The CM_Add_Empty_Log_Conf and CM_Free_Log_Conf APIs may invalidate the logical configuration handle returned by this API.  To continue enumerating logical configuration after addding or freeing a logical configuration, always use the CM_Get_First_Log_Conf API to start again from the beginning. When the logical configuration handle returned by CM_Get_Next_Log_Conf is no longer needed, it should be freed by calling CM_Free_Log_Conf_Handle. 2.2.26 CM_Get_Next_Res_Des This routine returns the handle of the next resource descriptor in a logical configuration. CONFIGRET CM_Get_Next_Res_Des ( OUT PRES_DES prdResDes, IN RES_DES rdResDes, IN RESOURCEID ForResource, OUT PRESOURCEID pResourceID, IN ULONG ulFlags Parameters: prdResDes  Supplies the address of the variable that receives the handle of the next resource descriptor. rdResDes  Supplies the handle of the current resource descriptor or the handle of a logical configuration.  (Both are 32-bit numbers--Configuration Manager can distinguish between them.) ForResource  Specifies the type of the resource to retrieve.  Can be one of the ResType values listed in Section   REF MiscDataStructs \* MERGEFORMAT  pResourceID  Supplies the address of the variable that receives the resource type, when ForResource specifies ResType_All.  (When ForResource is not ResType_All, this parameter can be NULL.) ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, CR_INVALID_LOG_CONF, CR_INVALID_RES_DES, or CR_NO_MORE_RES_DES. Remarks: When the resource descriptor handle returned by CM_Get_Next_Res_Des is no longer needed, it should be freed by calling CM_Free_Res_Des_Handle 2.2.27 CM_Get_Parent This routine retrieves the handle of the parent of a device instance. CONFIGRET CM_Get_Parent ( OUT PDEVNODE pdnDevNode, IN DEVNODE dnDevNode, IN ULONG ulFlags Parameters: pdnDevNode  Supplies the address of the variable that receives a handle to the parent device instance. dnDevNode  Supplies the handle of the child device instance. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_NO_SUCH_DEVNODE. 2.2.28 CM_Get_Res_Des_Data This routine copies the data from a specified resource descriptor into a buffer. CONFIGRET CM_Get_Res_Des_Data ( IN RES_DES rdResDes, OUT PVOID Buffer, IN ULONG BufferLen, IN ULONG ulFlags Parameters: rdResDes  Supplies the handle of the resource descriptor from which data is to be copied. Buffer  Supplies the address of the buffer that receives the data. BufferLen  Supplies the size of the buffer, in bytes. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_BUFFER_SMALL, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_INVALID_RES_DES. Remarks: Use the CM_Get_Res_Des_Data_Size API to determine the buffer size needed to receive the data.  Alternately, set a size that is at least as large as the maximum possible size of the resource.  If the size given is too small, the data is truncated and the API returns CR_BUFFER_SMALL. 2.2.29 CM_Get_Res_Des_Data_Size This routine retrieves the size of a resource descriptor, not including the resource descriptor header. CONFIGRET CM_Get_Res_Des_Data_Size ( OUT PULONG pulSize, IN RES_DES rdResDes, IN ULONG ulFlags Parameters: pulSize  Supplies the address of the variable that receives the size, in bytes, of the resource descriptor data. rdResDes  Supplies the handle of the resource descriptor for which to retrieve the size. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_INVALID_RES_DES. 2.2.30 CM_Get_Sibling This routine retrieves the sibling of a device instance. CONFIGRET CM_Get_Sibling ( OUT PDEVNODE pdnDevNode, IN DEVNODE dnDevNode, IN ULONG ulFlags Parameters: pdnDevNode  Supplies the address of the variable that receives a handle to the sibling device  instance. dnDevNode  Supplies the handle of a device instance. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_NO_SUCH_DEVNODE. Remarks: This API can be called in a loop to retrieve all the siblings of a device instance.  When the API returns CR_NO_SUCH_DEVNODE, there are no more siblings to enumerate.  In order to enumerate all children of  a device instance, this loop must start with the device instance retrieved by calling CM_Get_Child to get the first sibling. 2.2.31 CM_Get_Version This routine retrieves the version number of the Configuration Manager APIs. CM_Get_Version ( Parameters: Return Value: The function returns the major revision number in the high byte and the minor revision number in the low byte. For example, version 4.0 of Configuration Manager returns 0x0400. 2.2.34 CM_Locate_DevNode This routine retrieves the handle of the device instance that corresponds to a specified device identifier. CONFIGRET CM_Locate_DevNode ( OUT PDEVNODE pdnDevNode, IN DEVNODEID pDeviceID, OPTIONAL IN ULONG ulFlags Parameters: pdnDevNode  Supplies the address of the variable that receives the handle of a device instance. pDeviceID  Supplies the address of a null-terminated string specifying a device identifier.  If this parameter is NULL, the API retrieves a handle to the device instance at the root of the hardware tree. ulFlags  Supplies flags specifying options for locating the device instance.  May be a combination of the following values: Create Device Instance Flags: CM_LOCATE_DEVNODE_NORMAL  Locate only device instances that are currently   from the ConfigMgr s point of view. CM_LOCATE_DEVNODE_PHANTOM  Allows a device instance handle to be returned for a device instance that is not currently  , but that does exist in the registry.  This may be used with other CM APIs that require a devnode handle, but for which there currently is none for a particular device (e.g., you want to set a device registry property for a device not currently present).  This flag does not allow you to locate phantom devnodes created by using CM_Create_DevNode with the CM_CREATE_DEVNODE_PHANTOM flag (such device instances are only accessible by the caller who holds the devnode handle returned from that API). Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVICE_ID, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_NO_SUCH_DEVNODE. 2.2.36 CM_Modify_Res_Des This routine modifies a resource descriptor. CONFIGRET CM_Modify_Res_Des ( OUT PRES_DES prdResDes, IN RES_DES rdResDes, IN RESOURCEID ResourceID, IN PVOID ResourceData, IN ULONG ResourceLen, IN ULONG ulFlags Parameters: prdResDes  Supplies the address of the variable that receives the handle of the modified resource descriptor. rdResDes  Supplies the handle of the resource descriptor to be modified. ResourceID  Specifies the type of resource to modify.  Can be one of the ResType values described in Section   REF MiscDataStructs \* MERGEFORMAT  ResourceData  Supplies the address of a resource data structure. ResourceLen  Supplies the size, in bytes, of the new resource data structure.  This size can be different from the size of the original resource data. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, CR_INVALID_RES_DES, or CR_OUT_OF_MEMORY. Remarks: This API retrieves a handle to the new resource descriptor.  This may or may not be the handle of the original resource descriptor.  The original resource descriptor handle is invalid after calling this API. When the new resource descriptor handle returned by CM_Modify_Res_Des is no longer needed, it should be freed by calling CM_Free_Res_Des_Handle. 2.2.48 CM_Set_HW_Prof_Flags This routine sets the configuration-specific configuration flags for a device instance and hardware profile combination. CONFIGRET CM_Set_HW_Prof_Flags ( IN DEVINSTID szDevNodeName, IN ULONG ulConfig, IN ULONG ulValue, IN ULONG ulFlags Parameters: szDevNodeName  Supplies the address of a null-terminated string that specifies the name of a device instance to modify ulConfig  Supplies the number of the hardware profile to modify.  If 0, the API modifies the current hardware profile. ulValue  Supplies the configuration flags value.  Can be a combination of these values: Configuration-Specific Flags: CSCONFIGFLAG_DISABLE  Disable the device instance in this hardware profile. CSCONFIGFLAG_DO_NOT_CREATE  Do not allow this device instance to be created in this hardware profile. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_REGISTRY_ERROR.  (Windows 95 may also return CR_NOT_AT_APPY_TIME.) Remarks: If the CSCONFIGFLAG_DO_NOT_CREATE bit is set for an existing device instance in the current hardware profile, it will be removed.  If the CSCONFIGFLAG_DO_NOT_CREATE bit is cleared in the current hardware profile, the entire hardware tree will be reenumerated, so that the parent of the device instance has the chance to create the device instance if necessary. 2.3 New Routines 2.3.1 CM_Get_DevNode_Registry_Property This routine retrieves the specified value from the device instance s registry storage key. CONFIGRET CM_Get_DevNode_Registry_Property ( IN DEVNODE dnDevNode, IN ULONG ulProperty, OUT PULONG pulRegDataType, OPTIONAL OUT PVOID Buffer, OPTIONAL IN OUT PULONG pulLength, IN ULONG ulFlags Parameters: dnDevNode  Supplies the handle of the device instance for which a property is to be retrieved. ulProperty  Supplies an ordinal specifying the property to be retrieved.  Can be one of the following values: Registry Properties: CM_DRP_DEVICEDESC  DeviceDesc property. CM_DRP_HARDWAREID  HardwareID property. CM_DRP_COMPATIBLEIDS  CompatibleIDs property. CM_DRP_NTDEVICEPATHS  NtDevicePaths property. CM_DRP_SERVICE  Service property. CM_DRP_CONFIGURATION  Configuration property. CM_DRP_CONFIGURATIONVECTOR  ConfigurationVector property. CM_DRP_CLASS  Class property. CM_DRP_CLASSGUID  ClassGUID property. CM_DRP_DRIVER  Driver property. CM_DRP_CONFIGFLAGS  ConfigFlags property. CM_DRP_MFG  Mfg property. pulRegDataType  Optionally, supplies the address of a variable that will receive the registry data type for this property (i.e., the REG_* constants). Buffer  Supplies the address of the buffer that receives the registry data.  Can be NULL when simply retrieving data size. pulLength  Supplies the address of the variable that contains the size, in bytes, of the buffer.  The API replaces the initial size with the number of bytes of registry data copied to the buffer.  If the variable is initially zero, the API replaces it with the buffer size needed to receive all the registry data.  In this case, the Buffer parameter is ignored. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_DEVNODE, CR_INVALID_PROPERTY, CR_INVALID_FLAG, CR_INVALID_POINTER, CR_NO_SUCH_VALUE, CR_REGISTRY_ERROR, or CR_BUFFER_SMALL. Remarks: This API replaces the 16-bit API, CM_Read_Registry_Value.  Direct access to the Plug & Play portions of the registry is prohibited in the 32-bit CM APIs, and access is only allowed via this API, as well as CM_Set_DevNode_Registry_Property. To retrieve device/driver class-specific information, use CM_Open_DevNode_Key. 2.3.2 CM_Set_DevNode_Registry_Property This routine sets the specified value in the device instance s registry storage key. CONFIGRET CM_Set_DevNode_Registry_Property ( IN DEVNODE dnDevNode, IN ULONG ulProperty, IN PVOID Buffer, OPTIONAL IN ULONG ulLength, IN ULONG ulFlags Parameters: dnDevNode  Supplies the handle of the device instance for which a property is to be set. ulProperty  Supplies an ordinal specifying the property to be set.  Can be one of the following values: Registry Properties: CM_DRP_DEVICEDESC  DeviceDesc property (REG_SZ). CM_DRP_HARDWAREID  HardwareID property (REG_MULTI_SZ). CM_DRP_COMPATIBLEIDS  CompatibleIDs property (REG_MULTI_SZ). CM_DRP_SERVICE  Service property (REG_SZ). CM_DRP_CLASS  Class property (REG_SZ). CM_DRP_CLASSGUID  ClassGUID property (REG_SZ). CM_DRP_DRIVER  Driver property (REG_SZ). CM_DRP_CONFIGFLAGS  ConfigFlags property (REG_DWORD). CM_DRP_MFG  Mfg property (REG_SZ). Buffer  Supplies the address of the buffer that contains the registry data.  This data must be of the proper type for that property. ulLength  Supplies the number of bytes of registry data to write. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_DEVNODE, CR_INVALID_PROPERTY, CR_INVALID_FLAG, CR_INVALID_POINTER, CR_REGISTRY_ERROR, CR_INVALID_DATA, or CR_BUFFER_SMALL. Remarks: This API replaces the 16-bit API, CM_Write_Registry_Value.  Direct access to the Plug & Play portions of the registry is prohibited in the 32-bit CM APIs, and access is only allowed via this API, as well as CM_Get_DevNode_Registry_Property. To set device/driver class-specific information, use CM_Open_DevNode_Key. 2.3.3 CM_Open_DevNode_Key This routine opens a registry storage key associated with a device instance. CONFIGRET CM_Open_DevNode_Key ( IN DEVNODE dnDevNode, IN REGSAM samDesired, IN ULONG ulHardwareProfile, IN REGDISPOSITION Disposition, OUT PHKEY phkDevice, IN ULONG ulFlags Parameters: dnDevNode  Handle of a device instance.  This handle is typically retrieved by a call to CM_Locate_DevNode or CM_Create_DevNode. samDesired  Specifies an access mask that describes the desired security access for the key. This parameter can be a combination of the values used in calls to RegOpenKeyEx. ulHardwareProfile  Supplies the handle of the hardware profile to open the storage key under.  This parameter is only used if the CM_REGISTRY_CONFIG flag is specified in ulFlags.  If this parameter is 0, the API uses the current hardware profile. Disposition  Specifies how the registry key is to be opened.  May be one of the following values: Registry Key Open Dispositions: RegDisposition_OpenAlways  Open the key if it exists, otherwise, create the key. RegDisposition_OpenExisting  Open the key if it exists, otherwise, fail with CR_NO_SUCH_REGISTRY_KEY. phkDevice  Supplies the address of the variable that receives an opened handle to the specified key.  When access to this key is completed, it must be closed via RegCloseKey. ulFlags  Specifies what type of storage key should be opened.  Can be a combination of these values: Registry Key Type Flags: CM_REGISTRY_HARDWARE (0x00000000)  Open a key for storing driver-independent information relating to the device instance.  On Windows NT, the full path to such a storage key is of the form: HKLM\SYSTEM\CurrentControlSet\Enum \<Enumerator> \<DeviceID> \<InstanceID> \Device Parameters CM_REGISTRY_SOFTWARE (0x00000001)  Open a key for storing driver-specific information relating to the device instance.  On Windows NT, the full path is to such a storage key is of the form: HKLM\SYSTEM\CurrentControlSet\Control\Class \<DevNodeClass> \<ClassInstanceOrdinal> CM_REGISTRY_USER (0x00000100)  Open the key under HKEY_CURRENT_USER instead of HKEY_LOCAL_MACHINE.  This flag may not be used with CM_REGISTRY_CONFIG.  There is no analogous kernel-mode API on NT to get at per-user device configuration storage, since this concept does not apply to device drivers (no user may be logged on, etc.).  However, this flag is provided, for consistency with Win95, and because it is foreseeable that it could be useful to Win32 services that interact with the Plug&Play model. CM_REGISTRY_CONFIG (0x00000200)  Open the key under a hardware profile branch instead of HKEY_LOCAL_MACHINE.  If this flag is specified, then ulHardwareProfile supplies the handle of the hardware profile to be used.  This flag may not be used with CM_REGISTRY_USER. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_DEVNODE, CR_NO_SUCH_REGISTRY_KEY, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_REGISTRY_ERROR Remarks: This API replaces the 16-bit APIs, CM_Read_Registry_Value and CM_Write_Registry_Value, for storing class-specific configuration information for a device instance.  This API cannot be used to set Plug&Play device instance properties, as these properties are located in a separate location in the registry that is accessible only via CM_Get_Device_Registry_Property, and CM_Set_Device_Registry_Property. 2.3.4 CM_Delete_DevNode_Key This routine deletes a registry storage key associated with a device instance. CONFIGRET CM_Delete_DevNode_Key ( IN DEVNODE dnDevNode, IN ULONG ulHardwareProfile, IN ULONG ulFlags Parameters: dnDevNode  Handle of a device instance.  This handle is typically retrieved by a call to CM_Locate_DevNode or CM_Create_DevNode. ulHardwareProfile  Supplies the handle of the hardware profile to delete the storage key under.  This parameter is only used if the CM_REGISTRY_CONFIG flag is specified in ulFlags.  If this parameter is 0, the API uses the current hardware profile.  If this parameter is 0xFFFFFFFF, then the specified storage key(s) for all hardware profiles is(are) deleted. ulFlags  Specifies what type(s) of storage key(s) should be deleted.  Can be a combination of these values: Registry Key Type Flags: CM_REGISTRY_HARDWARE (0x00000000)  Delete the key for storing driver-independent information relating to the device instance.  (Windows 95 doesn t provide a separate location for user-accessible storage here--it simply uses the devnode key itself.  Therefore, this flag is a no-op for them.) CM_REGISTRY_SOFTWARE (0x00000001)  Delete the key for storing driver-specific information relating to the device instance. CM_REGISTRY_USER (0x00000100)  Delete the specified key(s) under HKEY_CURRENT_USER instead of HKEY_LOCAL_MACHINE.  This flag may not be used with CM_REGISTRY_CONFIG. CM_REGISTRY_CONFIG (0x00000200)  Delete the specified key(s) under a hardware profile branch instead of HKEY_LOCAL_MACHINE.  If this flag is specified, then ulHardwareProfile supplies the handle of the hardware profile to be used.  This flag may not be used with CM_REGISTRY_USER. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_DEVNODE, CR_INVALID_FLAG, or CR_REGISTRY_ERROR Remarks: To delete all possible storage keys associated with a device instance, CM_Delete_DevNode_Key must be called with each of the following flag combinations: CM_REGISTRY_HARDWARE CM_REGISTRY_SOFTWARE CM_REGISTRY_HARDWARE | CM_REGISTRY_USER CM_REGISTRY_SOFTWARE | CM_REGISTRY_USER CM_REGISTRY_HARDWARE | CM_REGISTRY_CONFIG // ulHardwareProfile = 0xFFFFFFFF CM_REGISTRY_SOFTWARE | CM_REGISTRY_CONFIG // ulHardwareProfile = 0xFFFFFFFF 2.3.5 CM_Open_Class_Key This routine opens the class registry key, and optionally, a specific class s subkey. CONFIGRET CM_Open_Class_Key ( IN LPGUID ClassGuid, OPTIONAL IN REGSAM samDesired, IN REGDISPOSITION Disposition, OUT PHKEY phkClass, IN ULONG ulFlags Parameters: ClassGuid  Optionally, supplies the address of a class GUID representing the class subkey to be opened. samDesired  Specifies an access mask that describes the desired security access for the key. This parameter can be a combination of the values used in calls to RegOpenKeyEx. Disposition  Specifies how the registry key is to be opened.  May be one of the following values: Registry Key Open Dispositions: RegDisposition_OpenAlways  Open the key if it exists, otherwise, create the key. RegDisposition_OpenExisting  Open the key if it exists, otherwise, fail with CR_NO_SUCH_REGISTRY_KEY. phkClass  Supplies the address of the variable that receives an opened handle to the specified key.  When access to this key is completed, it must be closed via RegCloseKey. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:CR_NO_SUCH_REGISTRY_KEY, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_REGISTRY_ERROR Remarks: This API is provided for use by the 32-bit Setup APIs.  Since the location of the class branch is different between Windows 95 and Windows NT, this API is present in the Config Manager APIs to provide access to the key via a position-independent interface. 2.3.6 CM_Enumerate_Classes This routine enumerates the installed classes in the system.  It retrieves the GUID for a single class each time it is called. CONFIGRET CM_Enumerate_Classes ( IN ULONG ulClassIndex, OUT LPGUID ClassGuid, IN ULONG ulFlags Parameters: ulClassIndex  Supplies the index of the class to retrieve the class GUID for. ClassGuid  Supplies the address of the variable that receives the GUID for the class whose index is specified by ulClassIndex. ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, CR_INVALID_DATA, CR_NO_SUCH_VALUE, or CR_REGISTRY_ERROR Remarks: To enumerate installed classes, an application should initially call the CM_Enumerate_Classes function with the ulClassIndex parameter set to zero. The application should then increment the ulClassIndex parameter and call CM_Enumerate_Classes until there are no more classes (until the function returns CR_NO_SUCH_VALUE).  It is possible to receive a CR_INVALID_DATA error while enumerating installed classes.  This may happen if the registry key represented by the specified index is determined to be an invalid class key.  Such keys should be ignored during enumeration. 2.3.7 CM_Get_Class_Name This routine retrieves the class name associated with the specified class GUID. CONFIGRET CM_Get_Class_Name ( IN LPGUID ClassGuid, OUT PTCHAR Buffer, IN OUT PULONG pulLength, IN ULONG ulFlags Parameters: ClassGuid  Supplies a pointer to the class GUID whose name is to be retrieved. Buffer  Supplies the address of the character buffer that receives the class name corresponding to the specified GUID. pulLength  Supplies the address of the variable that contains the length, in characters, of the Buffer.  Upon return, this variable will contain the number of characters (including terminating NULL) written to Buffer (if the supplied buffer isn t large enough, then the routine will fail with CR_BUFFER_SMALL, and this value will indicate how large the buffer needs to be in order to succeed). ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, CR_BUFFER_SMALL, or CR_REGISTRY_ERROR 2.3.8 CM_Enumerate_Enumerators This routine enumerates the enumerator subkeys under the Enum branch (e.g., Root, PCI, etc.).  These names should not be used to access the registry directly, but may be used as input to the CM_Get_Device_ID_List routine. CONFIGRET CM_Enumerate_Enumerators ( IN ULONG ulEnumIndex, OUT PTCHAR Buffer, IN OUT PULONG pulLength, IN ULONG ulFlags Parameters: ulEnumIndex  Supplies the index of the enumerator subkey name to retrieve. Buffer  Supplies the address of the character buffer that receives the enumerator subkey name whose index is specified by ulEnumIndex. pulLength  Supplies the address of the variable that contains the length, in characters, of the Buffer.  Upon return, this variable will contain the number of characters (including terminating NULL) written to Buffer (if the supplied buffer isn t large enough, then the routine will fail with CR_BUFFER_SMALL, and this value will indicate how large the buffer needs to be in order to succeed). ulFlags  Must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_FLAG, CR_INVALID_POINTER, CR_BUFFER_SMALL, CR_NO_SUCH_VALUE, or CR_REGISTRY_ERROR Remarks: To enumerate enumerator subkey names, an application should initially call the CM_Enumerate_Enumerators function with the ulEnumIndex parameter set to zero. The application should then increment the ulEnumIndex parameter and call CM_Enumerate_Enumerators until there are no more subkeys (until the function returns CR_NO_SUCH_VALUE). 2.3.9 CM_Get_Device_ID_List This routine retrieves a list of all device IDs (device instance names) stored in the system, optionally filtered based upon the specified criteria. CONFIGRET CM_Get_Device_ID_List ( IN PCTSTR pszFilter, OPTIONAL OUT PTCHAR Buffer, IN ULONG BufferLen, IN ULONG ulFlags Parameters: pszFilter  Optionally, supplies a string that is used to filter the set of device IDs being returned.  The interpretation of this string is dependent upon the value of ulFlags, described below. Buffer  Supplies the address of the character buffer that receives the device ID list.  Each device ID is null-terminated, with an extra NULL at the end. BufferLen  Supplies the size, in characters, of the Buffer.  This size may be ascertained by calling CM_Get_Device_ID_List_Size. ulFlags  Specifies how the pszFilter string should be used to filter the set of device instances returned.  May be one of the following values: Device ID List Filter Flags: CM_GETIDLIST_FILTER_NONE (0x00000000)  t do any filtering on the device ID list being returned.  If the flag is specified, then pszFilter is ignored. CM_GETIDLIST_FILTER_ENUMERATOR (0x00000001)  Only return device IDs existing under the pszFilter branch of the hardware tree.  In this context, pszFilter can either be an enumerator name (as retrieved from CM_Enumerate_Enumerators), or a device ID, minus the instance ID (e.g., Root\*PNP0500). CM_GETIDLIST_FILTER_SERVICE (0x00000002)  Only return device IDs that are controlled by the service whose name is specified in pszFilter.  For example, specifying a pszFilter of  atdisk  with this filter flag would return only those device instances that are controlled by the atdisk driver.  This flag is not implemented on Windows 95. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_NO_SUCH_REGISTRY_KEY, CR_INVALID_FLAG, CR_INVALID_POINTER, CR_BUFFER_SMALL, or CR_REGISTRY_ERROR 2.3.10 CM_Get_Device_ID_List_Size This routine retrieves the size, in characters, of a list of device identifiers.  It may be used to supply the buffer size necessary for a call to CM_Get_Device_ID_List. CONFIGRET CM_Get_Device_ID_List_Size ( OUT PULONG pulLen, IN PCTSTR pszFilter, OPTIONAL IN ULONG ulFlags Parameters: pulLen  Supplies the address of the variable that receives the size, in characters, required to store a list of all device identifiers (possibly limited to those existing under the pszEnumerator subkey described below).  The size reflects a list of null-terminated device identifiers, with an extra null at the end.  For efficiency, this number represents an upper bound on the size required, and the actual list size may be slightly smaller. pszFilter  Optionally, supplies a string that is used to filter the set of device IDs that make up the list whose size is being returned.  The interpretation of this string is dependent upon the value of ulFlags, described below. ulFlags  Specifies how the pszFilter string should be used to filter the set of device instances comprising the list whose size is to be returned.  May be one of the following values: Device ID List Filter Flags: CM_GETIDLIST_FILTER_NONE (0x00000000)  t do any filtering on the device ID list being returned.  If the flag is specified, then pszFilter is ignored. CM_GETIDLIST_FILTER_ENUMERATOR (0x00000001)  Only include device IDs existing under the pszFilter branch of the hardware tree.  In this context, pszFilter can either be an enumerator name (as retrieved from CM_Enumerate_Enumerators), or a device ID, minus the instance ID (e.g., Root\*PNP0500). CM_GETIDLIST_FILTER_SERVICE (0x00000002)  Only include device IDs that are controlled by the service whose name is specified in pszFilter.  For example, specifying a pszFilter of  atdisk  with this filter flag would return only those device instances that are controlled by the atdisk driver.  This flag is not implemented on Windows 95. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_NO_SUCH_REGISTRY_KEY, CR_INVALID_FLAG, CR_INVALID_POINTER, or CR_REGISTRY_ERROR 2.3.12 CM_Connect_Machine This routine establishes a connection to a machine.  The machine handle can then be used on subsequent calls to extended Configuration Manager routines to provide remotable API support. CONFIGRET CM_Connect_Machine ( IN PCWSTR pszMachineName, OUT PHMACHINE phMachine Parameters: pszMachineName  Supplies a string that contains the UNC name of the machine to connect to. phMachine  Supplies the address of a variable of type HMACHINE that will return the handle for the connection to the machine specified in pszMachineName.  This machine handle should be used as the last parameter in subsequent calls to the extended (remotable) Configuration Manager routines (such as CM_Locate_DevNode_Ex). Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_POINTER, CR_OUT_OF_MEMORY, CR_INVALID_MACHINENAME, or CR_FAILURE. Remarks: When you are done calling Configuration Manager routines on the specified machine, you should call CM_Disconnet_Machine to free up internal resources allocated for that connection.  Most of the Configuration Manager routines have extended versions.  In each case, the extended version of the CM routine is simply appended with the _Ex extension and takes an HMACHINE parameter as an additional parameter (always the last parameter). Also note that the following three additional error codes may be returned for any of the extended CM routines: CR_REMOTE_COMM_FAILURE, CR_MACHINE_UNAVAILABLE, or CR_NO_CM_SERVICES. 2.3.13 CM_Disconnect_Machine This routine closes a machine handle that was opened by a call to CM_Connect_Machine.  Once communication with a remote machine using the CM routines is completed, the caller should call CM_Disconnect_Machine to free up resources that were allocated for that connection. CONFIGRET CM_Disconnect_Machine ( IN HMACHINE hMachine Parameters: hMachine  Supplies the machine handle that was returned from a previous call to CM_Connect_Machine. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_POINTER or CR_FAILURE. 2.3.14 CM_Free_Log_Conf_Handle This routine frees a logical configuration handle that was previously retreived by a call to CM_Add_Empty_Log_Conf, CM_Get_First_Log_Conf, or CM_Get_Next_Log_Conf. CONFIGRET CM_Free_Log_Conf_Handle(             IN  LOG_CONF  lcLogConf             ); Parameters: lcLogConf  Supplies the logical configuration handle to be freed. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_LOG_CONF or CR_FAILURE. 2.3.15 CM_Free_Res_Des_Handle This routine frees a resource descriptor handle that was previously retrieved by a call to CM_Add_Res_Des, CM_Free_Res_Des, CM_Get_Next_Res_Des, or CM_Modify_Res_Des. CONFIGRET CM_Free_Res_Des_Handle(             IN  RES_DES  rdResDes             ); Parameters: rdResDes   Supplies the resource descriptor handle to be freed. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following: CR_INVALID_RES_DES or CR_FAILURE. 2.3.16 CM_Detect_Resource_Conflict This routine determines whether the specified set of resources is already in use by some other device. CONFIGRET CM_Detect_Resource_Conflict (          IN  DEVINST    dnDevInst,          IN  RESOURCEID ResourceID,         OPTIONAL          IN  PCVOID     ResourceData,       OPTIONAL          IN  ULONG      ResourceLen,        OPTIONAL          OUT PBOOL      pbConflictDetected,          IN  ULONG      ulFlags, Parameters: dnDevInst - Handle of a device instance. This handle is typically retrieved by a call to CM_Locate_DevNode. ResourceID - Specifies the type of resource to modify. ResType_ClassSpecific is not a valid resource type for this call. ResourceData  - Supplies the address of a resource data structure. ResourceLen - Supplies the size, in bytes, of the resource data structure. pbConflictDetect - Pointer to a boolean value that is returned by this call. If the returned value is FALSE, then no conflict was detected. If the the return value is TRUE, then a conflict was detected. If CM_Detect_Resource_Conflict does not return CR_SUCCESS, then the value of pbConflictDetected is unknown and should not be used. ulFlags - Not used, must be zero. Return Value: If the function succeeds, the return value is CR_SUCCESS. If the function fails, the return value is one of the following:  CR_INVALID_DEVNODE, CR_INVALID_LOG_CONF, CR_INVALID_FLAG, CR_INVALID_POINTER, CR_INVALID_RESOURCEID, CR_INVALID_DATA.  This name is retained for compatibility with the Windows 95 16-bit Configuration Manager APIs.  Windows NT does not use devnodes, so this data type must be viewed as simply an opaque handle to a device instance.  (In fact, Windows NT will define macros DEVINST and PDEVINST that will be used internally instead of the DEVNODE typedefs.)  This name is retained for compatibility with the 16-bit CM APIs.  Windows NT will define a macro DEVINSTID that will be used internally instead of the DEVNODEID typedef.  For Windows 95, this key is HKLM\Enum; on Windows NT, it is HKLM\System\CurrentControlSet\Enum.  No assumptions should be made about where this key is located.  For Windows NT, this is the same as LCPRI_REBOOT. Document Name 32-Bit Configuration Manager Application Programming Interface Document Name Microsoft Corporation Company Confidential Normal Heading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Default Paragraph Font Prototype (type name) Prototype (proc name) Prototype (direction) Prototype (identifier) Prototype ("Parameters:") Footnote reference character List level 1 List level 2 Parameter values heading Parameter values list Simple list level 1 Simple list level 2 Parameter values subheading 1_Parameter values list Parameter values sub-subhead Parameter values sublist Note (in level 1 list) Procedure name list List level 3 List level 4 Table of Contents level 5 Normal paragraph + keep next Underlined paragraph Hidden paragraph 1_Footnote text Prototype (declaration) Prototype (parameter list) Proto. (param list,para 2) Prototype (Return Value:) Second paragraph for P4 Table of Contents level 6 Running header Running footer Title page--document name Title page--author name Title page--revision number 1_Hidden paragraph Definition of term Code example Diagram TOC 1 TOC 2 TOC 3 TOC 4 Header Footer TOC 5 TOC 6 TOC 7 TOC 8 TOC 9 Footnote Text Footnote Reference Annotation Reference Annotation Text _Toc308507447 _Toc308512738 _Toc308592447 _Toc308601372 _Toc308601682 _Toc308717484 _Toc308718689 _Toc308860136 _Toc308877028 _Toc309035245 _Toc309099783 _Toc309123460 _Toc309123515 _Toc309205845 _Toc309445531 _Toc309446736 _Toc309454977 _Toc309457083 _Toc309458063 _Toc316367185 _Toc317402037 _Toc318525944 _Toc318526188 _Toc318530417 _Toc318530448 _Toc319385045 _Toc323119429 _Toc325168542 _Toc325787180 _Toc327598891 _Toc327611352 _Toc327635253 _Toc327641300 _Toc327677365 _Toc327690769 _Toc327712200 _Toc327861581 _Toc327886462 _Toc328812952 _Toc329750947 _Toc329763211 _Toc330203520 _Toc330342748 _Toc330347561 _Toc330352011 _Toc330610835 _Toc331926949 _Toc334001205 _Toc335798408 _Toc335978310 _Toc335978516 _Toc335985940 _Toc335987452 _Toc336265940 _Toc336312093 _Toc336348839 _Toc336349994 _Toc338123717 _Toc342123784 _Toc342187842 _Toc364568172 _Toc308512747 _Toc308592457 _Toc308601692 _Toc308717494 _Toc308718699 _Toc308860146 _Toc308877038 _Toc309035255 _Toc309099793 _Toc309123470 _Toc309123525 _Toc309205850 _Toc309445536 _Toc309446741 _Toc309454982 _Toc309457088 _Toc309458068 _Toc316367190 _Toc317402042 _Toc318525949 _Toc318526193 _Toc318530422 _Toc318530453 _Toc319385050 _Toc323119434 _Toc325168547 _Toc325787185 _Toc327598892 _Toc327611353 _Toc327635254 _Toc327641301 _Toc327677366 _Toc327690770 _Toc327712201 _Toc327861582 _Toc327886463 _Toc328812953 _Toc329750948 _Toc329763212 _Toc330203521 _Toc330342749 _Toc330347562 _Toc330352012 _Toc330610836 _Toc331926950 _Toc334001206 _Toc335798409 _Toc335978311 _Toc335978517 _Toc335985941 _Toc335987453 _Toc336265941 _Toc336312094 _Toc336348840 _Toc336349995 _Toc338123718 _Toc342123785 _Toc342187843 _Toc364568173 _Toc308512748 _Toc308592458 _Toc308601382 _Toc308601693 _Toc308717495 _Toc308718700 _Toc308860147 _Toc308877039 _Toc309035256 _Toc309099794 _Toc309123471 _Toc309123526 _Toc309205851 _Toc309445537 _Toc309446742 _Toc309454983 _Toc309457089 _Toc309458069 _Toc316367191 _Toc317402043 _Toc318525950 _Toc318526194 _Toc318530423 _Toc318530454 _Toc319385051 _Toc323119435 _Toc325168548 _Toc325787186 _Toc327598893 _Toc327611354 _Toc327635255 _Toc327641302 _Toc327677367 _Toc327690771 _Toc327712202 _Toc327861583 _Toc327886464 _Toc328812954 _Toc329750949 _Toc329763213 _Toc330203522 _Toc330342750 _Toc330347563 _Toc330352013 _Toc330610837 _Toc331926951 _Toc334001207 _Toc335798410 _Toc335978312 _Toc335978518 _Toc335985942 _Toc335987454 _Toc336265942 _Toc336312095 _Toc336348841 _Toc336349996 _Toc338123719 _Toc342123786 _Toc342187844 _Toc364568174 _Toc327598894 _Toc327611355 _Toc327635256 _Toc327641303 _Toc327677368 _Toc327690772 _Toc327712203 _Toc327861584 _Toc327886465 _Toc328812955 _Toc329750950 _Toc329763214 _Toc330203523 _Toc330342751 _Toc330347564 _Toc330352014 _Toc330610838 _Toc331926952 _Toc334001208 _Toc335798411 _Toc335978313 _Toc335978519 _Toc335985943 _Toc335987455 _Toc336265943 _Toc336312096 _Toc336348842 _Toc336349997 _Toc338123720 _Toc342123787 _Toc342187845 _Toc364568175 _Toc327598895 _Toc327611356 _Toc327635257 _Toc327641304 _Toc327677369 _Toc327690773 _Toc327712204 _Toc327861585 _Toc327886466 _Toc328812956 _Toc329750951 _Toc329763215 _Toc330203524 _Toc330342752 _Toc330347565 _Toc330352015 _Toc330610839 _Toc331926953 _Toc334001209 _Toc335798412 _Toc335978314 _Toc335978520 _Toc335985944 _Toc335987456 _Toc336265944 _Toc336312097 _Toc336348843 _Toc336349998 _Toc338123721 _Toc342123788 _Toc342187846 _Toc364568176 _Toc308512751 _Toc308592461 _Toc308601385 _Toc308601696 _Toc308717498 _Toc308718703 _Toc308860151 _Toc308877044 _Toc309035262 _Toc309099801 _Toc309123479 _Toc309123534 _Toc309205859 _Toc309445544 _Toc309446750 _Toc309454991 _Toc309457097 _Toc309458077 _Toc316367199 _Toc317402051 _Toc318525958 _Toc318526201 _Toc318530446 _Toc318530462 _Toc319385062 _Toc323119448 _Toc325168562 _Toc325787202 _Toc327598896 _Toc327611357 _Toc327635258 _Toc327641305 _Toc327677370 _Toc327690774 _Toc327712205 _Toc327861586 _Toc327886467 _Toc328812957 _Toc329750952 _Toc329763216 _Toc330203525 _Toc330342753 _Toc330347566 _Toc330352016 _Toc330610840 _Toc331926954 _Toc334001210 _Toc335798413 _Toc335978315 _Toc335978521 _Toc335985945 _Toc335987457 _Toc336265945 _Toc336312098 _Toc336348844 _Toc336349999 _Toc338123722 _Toc342123789 _Toc342187847 _Toc364568177 _Toc327598897 _Toc327611358 _Toc327635259 _Toc327641306 _Toc327677371 _Toc327690775 _Toc327712206 _Toc327861587 _Toc327886468 _Toc328812958 _Toc329750953 _Toc329763217 _Toc330203526 _Toc330342754 _Toc330347567 _Toc330352017 _Toc330610841 _Toc331926955 _Toc334001211 _Toc335798414 _Toc335978316 _Toc335978522 _Toc335985946 _Toc335987458 _Toc336265946 _Toc336312099 _Toc336348845 _Toc336350000 _Toc338123723 _Toc342123790 _Toc342187848 _Toc364568178 _Toc327611359 _Toc327635260 _Toc327641307 _Toc327677372 _Toc327690776 _Toc327712207 _Toc327861588 _Toc327886469 _Toc328812959 _Toc329750954 _Toc329763218 _Toc330203527 _Toc330342755 _Toc330347568 _Toc330352018 _Toc330610842 _Toc331926956 _Toc334001212 _Toc335798415 _Toc335978317 _Toc335978523 _Toc335985947 _Toc335987459 _Toc336265947 _Toc336312100 _Toc336348846 _Toc336350001 _Toc338123724 _Toc342123791 _Toc342187849 _Toc364568179 _Toc336265948 _Toc336312101 _Toc336348847 _Toc336350002 _Toc338123725 _Toc342123792 _Toc342187850 _Toc364568180 MiscDataStructs _Toc327677373 _Toc327690777 _Toc327712208 _Toc327861589 _Toc327886470 _Toc328812960 _Toc329750955 _Toc329763219 _Toc330203528 _Toc330342756 _Toc330347569 _Toc330352019 _Toc330610843 _Toc331926957 _Toc334001213 _Toc335798416 _Toc335978318 _Toc335978524 _Toc335985948 _Toc335987460 _Toc336265949 _Toc336312102 _Toc336348848 _Toc336350003 _Toc338123726 _Toc342123793 _Toc342187851 _Toc364568181 _Toc327611360 _Toc327635261 _Toc327641308 _Toc327677374 _Toc327690778 _Toc327712209 _Toc327861590 _Toc327886471 _Toc328812961 _Toc329750956 _Toc329763220 _Toc330203529 _Toc330342757 _Toc330347570 _Toc330352020 _Toc330610844 _Toc331926958 _Toc334001214 _Toc335798417 _Toc335978319 _Toc335978525 _Toc335985949 _Toc335987461 _Toc336265950 _Toc336312103 _Toc336348849 _Toc336350004 _Toc338123727 _Toc342123794 _Toc342187852 _Toc364568182 _Toc327635262 _Toc327641309 _Toc327677375 _Toc327690779 _Toc327712210 _Toc327861591 _Toc327886472 _Toc328812962 _Toc329750957 _Toc329763221 _Toc330203530 _Toc330342758 _Toc330347571 _Toc330352021 _Toc330610845 _Toc331926959 _Toc334001215 _Toc335798418 _Toc335978320 _Toc335978526 _Toc335985950 _Toc335987462 _Toc336265951 _Toc336312104 _Toc336348850 _Toc336350005 _Toc338123728 _Toc342123795 _Toc342187853 _Toc364568183 _Toc327635265 _Toc327641312 _Toc327677378 _Toc327690782 _Toc327712213 _Toc327861594 _Toc327886475 _Toc328812965 _Toc329750960 _Toc329763224 _Toc330203533 _Toc330342761 _Toc330347574 _Toc330352024 _Toc330610848 _Toc331926962 _Toc334001218 _Toc335798421 _Toc335978323 _Toc335978529 _Toc335985953 _Toc335987465 _Toc336265954 _Toc336312107 _Toc336348853 _Toc336350008 _Toc338123731 _Toc342123798 _Toc342187856 _Toc364568184 _Toc327641322 _Toc327677388 _Toc327690791 _Toc327712222 _Toc327861603 _Toc327886484 _Toc328812974 _Toc329750969 _Toc329763233 _Toc330203542 _Toc330342770 _Toc330347583 _Toc330352033 _Toc330610857 _Toc331926971 _Toc334001227 _Toc335798430 _Toc335978332 _Toc335978538 _Toc335985962 _Toc335987474 _Toc336265963 _Toc336312116 _Toc336348862 _Toc336350017 _Toc338123740 _Toc342123807 _Toc342187865 _Toc364568185 _Toc327641324 _Toc327677390 _Toc327690793 _Toc327712224 _Toc327861605 _Toc327886486 _Toc328812976 _Toc329750971 _Toc329763235 _Toc330203544 _Toc330342772 _Toc330347585 _Toc330352035 _Toc330610859 _Toc331926973 _Toc334001229 _Toc335798432 _Toc335978334 _Toc335978540 _Toc335985964 _Toc335987476 _Toc336265965 _Toc336312118 _Toc336348864 _Toc336350019 _Toc338123742 _Toc342123809 _Toc342187867 _Toc364568186 _Toc327641325 _Toc327677391 _Toc327690794 _Toc327712225 _Toc327861606 _Toc327886487 _Toc328812977 _Toc329750972 _Toc329763236 _Toc330203545 _Toc330342773 _Toc330347586 _Toc330352036 _Toc330610860 _Toc331926974 _Toc334001230 _Toc335798433 _Toc335978335 _Toc335978541 _Toc335985965 _Toc335987477 _Toc336265966 _Toc336312119 _Toc336348865 _Toc336350020 _Toc338123743 _Toc342123810 _Toc342187868 _Toc364568187 _Toc327641328 _Toc327677394 _Toc327690797 _Toc327712228 _Toc327861609 _Toc327886489 _Toc328812979 _Toc329750974 _Toc329763238 _Toc330203547 _Toc330342775 _Toc330347588 _Toc330352038 _Toc330610862 _Toc331926976 _Toc334001232 _Toc335798435 _Toc335978337 _Toc335978543 _Toc335985967 _Toc335987479 _Toc336265968 _Toc336312121 _Toc336348867 _Toc336350022 _Toc338123745 _Toc342123812 _Toc342187870 _Toc364568188 _Toc327641329 _Toc327677395 _Toc327690798 _Toc327712229 _Toc327861610 _Toc327886490 _Toc328812980 _Toc329750975 _Toc329763239 _Toc330203548 _Toc330342776 _Toc330347589 _Toc330352039 _Toc330610863 _Toc331926977 _Toc334001233 _Toc335798436 _Toc335978338 _Toc335978544 _Toc335985968 _Toc335987480 _Toc336265969 _Toc336312122 _Toc336348868 _Toc336350023 _Toc338123746 _Toc342123813 _Toc342187871 _Toc364568189 _Toc327677396 _Toc327690799 _Toc327712230 _Toc327861611 _Toc327886491 _Toc328812981 _Toc329750976 _Toc329763240 _Toc330203549 _Toc330342777 _Toc330347590 _Toc330352040 _Toc330610864 _Toc331926978 _Toc334001234 _Toc335798437 _Toc335978339 _Toc335978545 _Toc335985969 _Toc335987481 _Toc336265970 _Toc336312123 _Toc336348869 _Toc336350024 _Toc338123747 _Toc342123814 _Toc342187872 _Toc364568190 _Toc327677397 _Toc327690800 _Toc327712231 _Toc327861612 _Toc327886492 _Toc328812982 _Toc329750977 _Toc329763241 _Toc330203550 _Toc330342778 _Toc330347591 _Toc330352041 _Toc330610865 _Toc331926979 _Toc334001235 _Toc335798438 _Toc335978340 _Toc335978546 _Toc335985970 _Toc335987482 _Toc336265971 _Toc336312124 _Toc336348870 _Toc336350025 _Toc338123748 _Toc342123815 _Toc342187873 _Toc364568191 _Toc327677399 _Toc327690802 _Toc327712233 _Toc327861614 _Toc327886494 _Toc328812984 _Toc329750979 _Toc329763243 _Toc330203552 _Toc330342780 _Toc330347593 _Toc330352043 _Toc330610867 _Toc331926981 _Toc334001237 _Toc335798440 _Toc335978342 _Toc335978548 _Toc335985972 _Toc335987484 _Toc336265973 _Toc336312126 _Toc336348872 _Toc336350027 _Toc338123750 _Toc342123817 _Toc342187875 _Toc364568192 _Toc327677400 _Toc327690803 _Toc327712234 _Toc327861615 _Toc327886495 _Toc328812985 _Toc329750980 _Toc329763244 _Toc330203553 _Toc330342781 _Toc330347594 _Toc330352044 _Toc330610868 _Toc331926982 _Toc334001238 _Toc335798441 _Toc335978343 _Toc335978549 _Toc335985973 _Toc335987485 _Toc336265974 _Toc336312127 _Toc336348873 _Toc336350028 _Toc338123751 _Toc342123818 _Toc342187876 _Toc364568193 _Toc327677401 _Toc327690804 _Toc327712235 _Toc327861616 _Toc327886496 _Toc328812986 _Toc329750981 _Toc329763245 _Toc330203554 _Toc330342782 _Toc330347595 _Toc330352045 _Toc330610869 _Toc331926983 _Toc334001239 _Toc335798442 _Toc335978344 _Toc335978550 _Toc335985974 _Toc335987486 _Toc336265975 _Toc336312128 _Toc336348874 _Toc336350029 _Toc338123752 _Toc342123819 _Toc342187877 _Toc364568194 _Toc327677402 _Toc327690805 _Toc327712236 _Toc327861617 _Toc327886497 _Toc328812987 _Toc329750982 _Toc329763246 _Toc330203555 _Toc330342783 _Toc330347596 _Toc330352046 _Toc330610870 _Toc331926984 _Toc334001240 _Toc335798443 _Toc335978345 _Toc335978551 _Toc335985975 _Toc335987487 _Toc336265976 _Toc336312129 _Toc336348875 _Toc336350030 _Toc338123753 _Toc342123820 _Toc342187878 _Toc364568195 _Toc327677403 _Toc327690806 _Toc327712237 _Toc327861618 _Toc327886498 _Toc328812988 _Toc329750983 _Toc329763247 _Toc330203556 _Toc330342784 _Toc330347597 _Toc330352047 _Toc330610871 _Toc331926985 _Toc334001241 _Toc335798444 _Toc335978346 _Toc335978552 _Toc335985976 _Toc335987488 _Toc336265977 _Toc336312130 _Toc336348876 _Toc336350031 _Toc338123754 _Toc342123821 _Toc342187879 _Toc364568196 _Toc327677404 _Toc327690807 _Toc327712238 _Toc327861619 _Toc327886499 _Toc328812989 _Toc329750984 _Toc329763248 _Toc330203557 _Toc330342785 _Toc330347598 _Toc330352048 _Toc330610872 _Toc331926986 _Toc334001242 _Toc335798445 _Toc335978347 _Toc335978553 _Toc335985977 _Toc335987489 _Toc336265978 _Toc336312131 _Toc336348877 _Toc336350032 _Toc338123755 _Toc342123822 _Toc342187880 _Toc364568197 _Toc327690808 _Toc327712239 _Toc327861620 _Toc327886500 _Toc328812990 _Toc329750985 _Toc329763249 _Toc330203558 _Toc330342786 _Toc330347599 _Toc330352049 _Toc330610873 _Toc331926987 _Toc334001243 _Toc335798446 _Toc335978348 _Toc335978554 _Toc335985978 _Toc335987490 _Toc336265979 _Toc336312132 _Toc336348878 _Toc336350033 _Toc338123756 _Toc342123823 _Toc342187881 _Toc364568198 _Toc327690809 _Toc327712240 _Toc327861621 _Toc327886501 _Toc328812991 _Toc329750986 _Toc329763250 _Toc330203559 _Toc330342787 _Toc330347600 _Toc330352050 _Toc330610874 _Toc331926988 _Toc334001244 _Toc335798447 _Toc335978349 _Toc335978555 _Toc335985979 _Toc335987491 _Toc336265980 _Toc336312133 _Toc336348879 _Toc336350034 _Toc338123757 _Toc342123824 _Toc342187882 _Toc364568199 _Toc327690810 _Toc327712241 _Toc327861622 _Toc327886502 _Toc328812992 _Toc329750987 _Toc329763251 _Toc330203560 _Toc330342788 _Toc330347601 _Toc330352051 _Toc330610875 _Toc331926989 _Toc334001245 _Toc335798448 _Toc335978350 _Toc335978556 _Toc335985980 _Toc335987492 _Toc336265981 _Toc336312134 _Toc336348880 _Toc336350035 _Toc338123758 _Toc342123825 _Toc342187883 _Toc364568200 _Toc327690813 _Toc327712244 _Toc327861625 _Toc327886505 _Toc328812995 _Toc329750990 _Toc329763254 _Toc330203563 _Toc330342791 _Toc330347604 _Toc330352054 _Toc330610878 _Toc331926992 _Toc334001248 _Toc335798451 _Toc335978353 _Toc335978559 _Toc335985983 _Toc335987495 _Toc336265984 _Toc336312137 _Toc336348883 _Toc336350038 _Toc338123761 _Toc342123828 _Toc342187886 _Toc364568201 _Toc327690815 _Toc327712246 _Toc327861627 _Toc327886507 _Toc328812997 _Toc329750992 _Toc329763256 _Toc330203565 _Toc330342793 _Toc330347606 _Toc330352056 _Toc330610880 _Toc331926994 _Toc334001250 _Toc335798453 _Toc335978355 _Toc335978561 _Toc335985985 _Toc335987497 _Toc336265986 _Toc336312139 _Toc336348885 _Toc336350040 _Toc338123763 _Toc342123830 _Toc342187888 _Toc364568202 _Toc327690826 _Toc327712257 _Toc327861640 _Toc327886520 _Toc328813010 _Toc329751005 _Toc329763269 _Toc330203578 _Toc330342806 _Toc330347619 _Toc330352069 _Toc330610893 _Toc331927007 _Toc334001263 _Toc335798465 _Toc335978367 _Toc335978573 _Toc335985997 _Toc335987509 _Toc336265998 _Toc336312151 _Toc336348897 _Toc336350052 _Toc338123775 _Toc342123842 _Toc342187900 _Toc364568203 _Toc327712260 _Toc327861643 _Toc327886523 _Toc328813013 _Toc329751008 _Toc329763272 _Toc330203581 _Toc330342809 _Toc330347622 _Toc330352072 _Toc330610896 _Toc331927010 _Toc334001266 _Toc335798468 _Toc335978370 _Toc335978576 _Toc335986000 _Toc335987512 _Toc336266001 _Toc336312154 _Toc336348900 _Toc336350055 _Toc338123778 _Toc342123845 _Toc342187903 _Toc364568204 _Toc327712261 _Toc327861644 _Toc327886524 _Toc328813014 _Toc329751009 _Toc329763273 _Toc330203582 _Toc330342810 _Toc330347623 _Toc330352073 _Toc330610897 _Toc331927011 _Toc334001267 _Toc335798469 _Toc335978371 _Toc335978577 _Toc335986001 _Toc335987513 _Toc336266002 _Toc336312155 _Toc336348901 _Toc336350056 _Toc338123779 _Toc342123846 _Toc342187904 _Toc364568205 _Toc327712262 _Toc327861645 _Toc327886525 _Toc328813015 _Toc329751010 _Toc329763274 _Toc330203583 _Toc330342811 _Toc330347624 _Toc330352074 _Toc330610898 _Toc331927012 _Toc334001268 _Toc335798470 _Toc335978372 _Toc335978578 _Toc335986002 _Toc335987514 _Toc336266003 _Toc336312156 _Toc336348902 _Toc336350057 _Toc338123780 _Toc342123847 _Toc342187905 _Toc364568206 _Toc335978373 _Toc335978579 _Toc335986003 _Toc335987515 _Toc336266004 _Toc336312157 _Toc336348903 _Toc336350058 _Toc338123781 _Toc342123848 _Toc342187906 _Toc364568207 _Toc328813017 _Toc329751012 _Toc329763276 _Toc330203585 _Toc330342813 _Toc330347626 _Toc330352076 _Toc330610900 _Toc331927014 _Toc334001270 _Toc335798472 _Toc335978374 _Toc335978580 _Toc335986004 _Toc335987516 _Toc336266005 _Toc336312158 _Toc336348904 _Toc336350059 _Toc338123782 _Toc342123849 _Toc342187907 _Toc364568208 _Toc336350060 _Toc338123783 _Toc342123850 _Toc342187908 _Toc364568209 _Toc329751014 _Toc329763278 _Toc330203587 _Toc330342815 _Toc330347627 _Toc330352077 _Toc330610901 _Toc331927015 _Toc334001271 _Toc335798473 _Toc335978375 _Toc335978581 _Toc335986005 _Toc335987517 _Toc336266006 _Toc336312159 _Toc336348905 _Toc336350061 _Toc338123784 _Toc342123851 _Toc342187909 _Toc364568210 _Toc329763279 _Toc330203588 _Toc330342816 _Toc330347628 _Toc330352078 _Toc330610902 _Toc331927016 _Toc334001272 _Toc335798474 _Toc335978376 _Toc335978582 _Toc335986006 _Toc335987518 _Toc336266007 _Toc336312160 _Toc336348906 _Toc336350062 _Toc338123785 _Toc342123852 _Toc342187910 _Toc364568211 _Toc330342817 _Toc330347629 _Toc330352079 _Toc330610903 _Toc331927017 _Toc334001273 _Toc335798475 _Toc335978377 _Toc335978583 _Toc335986007 _Toc335987519 _Toc336266008 _Toc336312161 _Toc336348907 _Toc336350063 _Toc338123786 _Toc342123853 _Toc342187911 _Toc364568212 _Toc330342818 _Toc330347630 _Toc330352080 _Toc330610904 _Toc331927018 _Toc334001274 _Toc335798476 _Toc335978378 _Toc335978584 _Toc335986008 _Toc335987520 _Toc336266009 _Toc336312162 _Toc336348908 _Toc336350064 _Toc338123787 _Toc342123854 _Toc342187912 _Toc364568213 _Toc330352081 _Toc330610905 _Toc331927019 _Toc334001275 _Toc335798477 _Toc335978379 _Toc335978585 _Toc335986009 _Toc335987521 _Toc336266010 _Toc336312163 _Toc336348909 _Toc336350065 _Toc338123788 _Toc342123855 _Toc342187913 _Toc364568214 _Toc342187915 _Toc364568215 _Toc342187916 _Toc364568216 _Toc364568217 _Toc364568218 _Toc364568219> Paula Tomlinson E:\nt\private\spec\configmg.doc Paula Tomlinson E:\nt\private\spec\configmg.doc Paula Tomlinson E:\nt\private\spec\configmg.doc Paula Tomlinson C:\temp\cfgmgr32.doc Paula Tomlinson C:\temp\cfgmgr32.doc Paula Tomlinson C:\temp\cfgmgr32.doc Paula Tomlinson C:\temp\cfgmgr32.doc Paula Tomlinson C:\temp\cfgmgr32.doc Bret Grinslade0\\ntddk\internl$\ddk\doc\spec\SETUP\CFGMGR32.DOC Andrew Krywaniuk D:\doc\setup\CFGMGR32.DOC @\\MSPRINT44\26S/2MC CORPK 157.55.80.242 Ne00: winspool \\MSPRINT44\26S/2MC CORPK 157.55.80.242 \\MSPRINT44\26S/2MC CORPK 157.5 Letter \\MSPRINT44\26S/2MC CORPK 157.5 Letter Times New Roman Symbol Arial Courier Times LinePrinter -Cairo Setup Application Programming Interface&Spec for Setup APIs available in Cairo Setup, API6This spec details the APIs exposed in the setupnt.dll. Bret Grinslade Andrew Krywaniuk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\ntdevicetest\readme.txt ===
========================================================================
       Copyright (c) 1999 Microsoft Corporation
       MICROSOFT FOUNDATION CLASS LIBRARY : NTDEVICETEST
========================================================================


AppWizard has created this NTDEVICETEST application for you.  This application
not only demonstrates the basics of using the Microsoft Foundation classes
but is also a starting point for writing your application.

This file contains a summary of what you will find in each of the files that
make up your NTDEVICETEST application.

NTDEVICETEST.h
    This is the main header file for the application.  It includes other
    project specific headers (including Resource.h) and declares the
    CNTDEVICETESTApp application class.

NTDEVICETEST.cpp
    This is the main application source file that contains the application
    class CNTDEVICETESTApp.

NTDEVICETEST.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Developer Studio.

res\NTDEVICETEST.ico
    This is an icon file, which is used as the application's icon.  This
    icon is included by the main resource file NTDEVICETEST.rc.

res\NTDEVICETEST.rc2
    This file contains resources that are not edited by Microsoft 
	Developer Studio.  You should place all resources not
	editable by the resource editor in this file.

NTDEVICETEST.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.


/////////////////////////////////////////////////////////////////////////////

AppWizard creates one dialog class:

NTDEVICETESTDlg.h, NTDEVICETESTDlg.cpp - the dialog
    These files contain your CNTDEVICETESTDlg class.  This class defines
    the behavior of your application's main dialog.  The dialog's
    template is in NTDEVICETEST.rc, which can be edited in Microsoft
	Developer Studio.


/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named NTDEVICETEST.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Developer Studio reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

If your application uses MFC in a shared DLL, and your application is 
in a language other than the operating system's current language, you
will need to copy the corresponding localized resources MFC40XXX.DLL
from the Microsoft Visual C++ CD-ROM onto the system or system32 directory,
and rename it to be MFCLOC.DLL.  ("XXX" stands for the language abbreviation.
For example, MFC40DEU.DLL contains resources translated to German.)  If you
don't do this, some of the UI elements of your application will remain in the
language of the operating system.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\references\windows 95 config mgr.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Windows 95/98 Configuration Manager Routines Title _PID_GUIDWindows 95/98 Configuration Manager Routines a-sanjes Normal a-sanjes Microsoft Word 8.0Windows 95/98 Configuration Manager And The Registry The intention of this document is to help clear up any mysteriousness regarding how the Configuration Manager classes handle the Windows Registry and the Configuration Manager Data stored therein. Why It Was Written The configuration manager classes for the Win32 Providers were written as an attempt to put off having to write a thunking layer and 16-bit code in order to access Windows Configuration Manager resource data (e.g. IRQs, IO Ports, etc.). Currently the resource data is retrieved by reading binary data from the registry and converting said data into resource descriptors as defined in the DDK.  This is an undocumented and most likely unsupported method of grabbing the data, however, it is a fully 32-bit solution.  On the other hand, the data retrieved is only a partial representation of all the data that could possibly be retrieved from the Configuration Manager. In order to access all the data, it is looking more and more likely that we will have to write a thunking layer for Windows 95.  For Windows 98, there is a chance that 32-bit APIs may be available, although I have not researched this. The configuration manager classes that we use, however are an abstraction of the retrieved data.  What this means, is that they provide a single point of entry that may be used for retrieving the data, and translating it into a format used by the rest of our code. How It Works This section describes how we use the registry in order to obtain our data.  Although the method of retrieving the data isn t necessarily documented, the structures that the data corresponds to are, so be aware that there are some leaps of logic being made in terms of how the data is being retrieved. First off, the Configuration Manager stores its allocation data for every device it is aware of , in the HKEY_DYN_DATA\Config Manager\Enum key in the registry.  Under this key exists one subkey for every device on the system.  The subkeys consist of names such as the following: C112E590, C112E670, etc. Each of the subkeys contains a series of values as follows: Allocation, HardwareKey, Problem and Status. Allocation   This is the binary data that describes resource allocations for the device. HardwareKey   This is the subkey under HKEY_LOCAL_MACHINE\Enum where the device descriptions and such can be found. Problem   This is a problem code associated with the device.  If there are no problems, it is 0, if there are, it will have a value. Status   This is a mask of bits combined together that describe the configuration manager status of the device.  This value at times may seem to indicate a problem, but problem will not actually show anything as being wrong.. HardwareKey is the link between the Configuration Manager Device Information and the outside world.  If one goes to the subkey pointed to by the hardware key, one will very quickly find a bunch of human readable data on the device, such as name, manufacturer, etc.  This is the data many of our providers read when we are giving data on Network Adapters, SCSI drives and such.  Unfortunately, there is no quick way to jump from a Hardware Key to a configuration manager device in the registry, although it seems to me that writing such a function would not be very difficult. Allocation Data Format The allocation data appears to consist of a set of different resource descriptors.  There are four standard types of resource descriptors handled by the Configuration Manager: IRQ, IO Port, Device Memory and DMA.  There are structures in the Windows 95 DDK that correspond to each of these resources.  There is a file called  Poormansresource.h  that contains all of these structures for quick and easy reference.  The actual format of the binary data is surprisingly simple: All of these start off with 8 bytes that don t seem to really mean anything.  My guess is version information. The next four bytes are a DWORD describing the size of the immediately following descriptor. The next four bytes are a resource id.  Only the first 5 bits of this id are a number we need to pay attention to.  The rest of the bits may be flags indicating that the resource is ignored, or other information (such as an OEM Number).  The actual resource id determines how the data following should be interpreted, since at that point the data will cleanly fall into one of the appropriate resource descriptors. There is a possibility that a described resource is not one of the four standard resources, in which case, there s not a lot we can do with the data.  The Configuration Manager code will however, grab the resource and place it in the generic resource descriptor object (meaning we won t be able to do much with it). Status And Problem Codes Status and problem code values are also defined in the Poormansresource.h file.  There are also human readable strings corresponding to the problem codes that can be found in the Windows 95 DDK header (they are NOT in the poormansresource.h file). CResourceDescriptor This is the base class for all of our resource descriptors.  It acts as a repository for the binary data for each descriptor.  It provides some virtual functions for implementation by derived classes in order to provide interpreted data from the descriptor.  It is really up to the derived classes to perform the appropriate interpretation, and provide resource specific methods for accessing the binary data.  Currently, there are three derived classes:  CIRQDescriptor, CDMADescriptor, CIODescriptor.  I have written a fourth class, CDeviceMemoryDescriptor, but it is not in the current project. CConfigMgrDevice This class is supplied with the Device ID on its constructor.  This is the registry key from which we are obtaining our data.  It maintains lists of resource descriptors, status and problem codes, a device description and a harware key for the device.  This is where changes (if any) that are made in terms of where we retrieve configuration manager information should be made. Why Does It All Work? I don t know.  Actually, the method we are using for traversing the registry is not really documented, but too much of it fits together for it all to be coincidentally.  So, yes, I really don t know. Where Do We Go From Here? While resource data, device status codes and device problem codes are a significant percentage of the data available from the Configuration Manager, it is still only a subset of the total data available.  Additional pieces of information, such as the bus type of a device, parent-child-sibling relationships of hardware devices and such are all available from the Configuration Manager.  However, accessing this information is not all that straightforward. In Windows 95, the Configuration Manager is a 16-bit piece of code, and talking to it will require an additional 16-bit piece of code from us.  Once that is in place, a thunking layer will need to be established so our 32-bit code can obtain the data.  At this time, I do not believe this will require creation of a VXD or similar piece of code. In Windows 98, the Configuration Manager appears to be accessible from the 32-bit environment, although I do not know how much of the 16-bit API set may be supported and what if any additional data that may be available. Because of the way the Configuration Manager classes are constructed, however, they do provide, I believe, a central location from which hardware data can be obtained and dispersed out for interpretation by the various provider classes.  Specifically, the CConfigMgrDevice class is where the actual configuration manager device is read in and stored.  It is this class, from which resource information, status codes, and problem codes may be obtained.  However, the source of the data is completely irrelevant.  Whether it is performing the current binary interpretation hack, thunking down to 16-bit land, or talking to a 32-bit API, it simply reads in the data, organizes it into the associated structures, and leaves it up to a user to ask it for information.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\references\ralphbrown\intprint.doc ===
INTPRINT v3.10
			    by Ralf Brown

The INTPRINT program is hereby donated to the public domain, with the sincere
hope that proper credit will be retained in all copies and derivatives.

------------------------------------------------------------------------------

INTPRINT.COM is a simple formatter for the interrupt list.  Use this
program to print only a portion of the list, prevent widow lines at the
beginning of a function call, number the pages, boldface key portions,
center the printout, or create a summary of the function calls.  After
formatting is complete, the total number of pages is displayed on the
screen.

Usage:
   intprint [options] intlist [[>|>>]outfile]

where the options are:
	-b    boldface the title lines, Return:, and Notes: by overprinting
	-B    boldface by sending printer control sequences

	-d    (duplex) print even/odd pages with different margins; suitable
	      for binding the printout.

	-e    assume printer is in elite mode (96 characters per line), and
	      indent the output eight spaces to center the printout.  This
	      is primarily for the default printer, as other printers may
	      force the equivalent or override this option.

	-ffile	create a file containing only the data structures described
	      in the interrupt list.
	      NOTE: you must put the filename immediately after the 'f'; no
	      blanks are allowed.

	-Ffile	filter the listing based on include and exclude strings
	      in 'file'.  Only entries whose headers match none of the
	      exclude strings and at least one of the include strings
	      will be processed.  All others will be skipped.
	      NOTE: you must put the filename immediately after the 'F'; no
	      blanks are allowed.

	-H    print a heading on each page indicating which interrupts
	      are listed on the page

	-iN   indent the output N spaces.  The output device is assumed to be
	      at least 80+N characters wide.
	      NOTE: you must put the number immediately after the 'i'; no
	      blanks are allowed.

	-I    assume the printer is capable of producing IBM character
	      graphics.  Printers other than "default" may force this option.

	-k    keep original divider lines instead of replacing them
	      with all dashes.

	-lN   print N lines per pages, overriding the printer-specific
	      default.	Use 0 to omit page breaks (in this case, the
	      reported number of pages and -r page restriction may be
	      incorrect unless you also use -L); this can be useful if
	      you only want to filter the list before processing it
	      further.

	-LN   assume N lines on a page.  If this is more than the number of
	      lines to print on each page, INTPRINT will use line feeds to
	      advance to the next page instead of form feeds.

	-m    specify that the interrupt list is in multiple parts beginning
	      with the named file.  INTPRINT will increment the last
	      character of the name to get the next filename, and continue
	      until it is unable to open the file thus selected.

	-nN   assume N pages have already been printed, and start numbering
	      at N+1.  This option allows you to create a properly-numbered
	      printout even if there is not enough disk space to concatenate
	      the parts of the interrupt list or hold a complete output file.
	      See the examples below.
	      NOTE: you must put the number immediately after the 'n'; no
	      blanks are allowed.

	-p    print the page number at the bottom center of each page

	-Pname use control codes for the specified printer (-P? lists the
	      supported printers).  The printer name may be given in either
	      case and abbreviated to a unique prefix; use either dashes or
	      underscores in place of blanks in the printer name.

	-rN:M print only pages N through M.  The entire input is processed
	      for use in -s and -f summaries (see below) even though only
	      a portion is formatted for printing.  If filtering is enabled,
	      (see -F), page numbers are based on entries selected by the
	      filter file.
	      NOTE: you must put the page numbers immediately after the 'r';
	      no blanks are allowed.  When using -l0 together with -r,
	      you must specify the appropriate page length with -L so
	      that page numbers can be computed correctly.

	-sfile	create a one-line-per-function summary and write it to "file"
	      if -n is also given, the summary will be appended to "file",
	      allowing a properly numbered summary file to be created even if
	      there is not enough disk space to concatenate the parts of the
	      list.  See the examples below.  If -p is also given, page
	      numbers will be included in the summary.	If -V is also given,
	      byte offsets for use by INTERVUE will be included.
	      NOTE: you must put the filename immediately after the 's'; no
	      blanks are allowed.

	-tN   select typeface N for the chosen printer (currently supported
	      only for the HP).

	-Tfile	create a one-line-per-table summary and write it to "file"
	      if -n is also given, the summary will be appended to the named
	      file.  If -p is also given, page numbers will be included in
	      the summary.  If -V is also given, byte offsets for use by
	      INTERVUE will be included.
	      NOTE: you must put the filename immediately after the 'T'; no
	      blanks are allowed.

	-V    indicate that the summary file is intended for use by INTERVUE.
	      INTPRINT will output byte offsets that allow INTERVUE to jump
	      directly to an entry.  Also forces -I.

	-wN   (widow lines) search N lines from the end of the page for a
	      good place to break.  The default is eight lines; the valid
	      range is from 3 to one-half of the page length.
	      NOTE: you must put the number immediately after the 'w'; no
	      blanks are allowed.

	-x    include Index: lines in formatted listing.  These lines are
	      are excluded by default because they are intended primarily
	      for use by hypertext converters.

Options may not be merged; "-ep" is illegal and the "p" will be ignored.
Use "-e -p" instead.

The formatted result of the input file is sent to the specified output file,
or to standard output if no output file is given.  Standard output may be
redirected using the usual Unix or MSDOS redirection characters > or >>.  If
you only want a summary file or data formats file, send or redirect the
output to the null device ("NUL" under MSDOS, "/dev/null" under Unix).


FILTER FILE:
------------

The filter file specified with -F is a simple text file containing
include lines, exclude lines, and comment lines.  Both 'include' and
'exclude' lines may be based on either a category code or a substring
of the entry's title line.  Comment lines start with a hash mark (#) in
the first column and are ignored.  The other valid command characters
in the first column are:

   >  unconditionally include any entry with the specified category letter
   <  unconditionally exclude any entry with the specified category letter
   +  include entries containing the specified string, unless unconditionally
      excluded
   -  exclude entries containing the specified string, unless unconditionally
      included
   i  include entries with the given category letter unless specifically
      excluded by a '-' line
   o  override '-' line and include entry anyway if it has the given
      category letter

Note that any category letters or selection strings must immediately
follow the command character.  All spaces on '+' include and '-' exclude
lines are significant.  Thus,
	+ DOS
will only match entries containing the four-letter sequence " DOS",
while
	+DOS
will match any entries containing the sequence "DOS", whether or not it
is preceded by a blank.

If a filter file is specified, only entries whose title lines contain at
least one of the '+' include lines (ignoring uppercase/lowercase
distinctions), none of the '-' exclude lines, or whose category codes
have been selected by other include/exclude lines, are processed.  Thus,
a filter file must contain at least one include line, or INTPRINT will
skip all interrupt entries and print only the non-interrupt text in the
file.

----cut here----
# SAMPLE1.FLT
# Sample filtering file number 1, using only title includes/excludes.
# Extract MS-DOS calls, but exclude DR-DOS-specific, DOS-extender, and
# non-DOS networking calls.
# Note: a few extraneous calls are still included.
#
+ DOS
-DR DOS
-DR-DOS
-DR Multiuser DOS
-Concurrent DOS
-DOS/16M
-DOS4GX
-DOS/4G
-extender
-LAN Manager
-DECnet DOS
#
# end of SAMPLE1.FLT
----cut here----

----cut here----
# SAMPLE2.FLT
# Sample filtering file number 2, using category includes/excludes.  Extract
# MS-DOS and DR-DOS calls, but exclude OS/2 and other operating systems.
#
# unconditionally include the DOS category
>D
# include 'other OSes' category, but remove OS/2, VMiX, PC-MOS, etc.
iO
-OS/2
-VMiX
-PC-MOS
-STARLITE
-WinDOS
-Acorn BBC
-Linux DOSEMU
#
# end of SAMPLE2.FLT
----cut here----

------------------------------------------------------------------------------

EXAMPLES:
---------

	Print the interrupt list with page numbers, and create a summary file,
	without concatenating INTERRUP.A, INTERRUP.B, and INTERRUP.C:

		A> intprint -sb:interrup.sum -p interrup.a >prn
		146 pages    [screen output from INTPRINT]
		A> intprint -sb:interrup.sum -p -n146 interrup.b prn
		285 pages    [screen output from INTPRINT]
		A> intprint -sb:interrup.sum -p -n285 interrup.c >prn
		403 pages    [screen output from INTPRINT]

	or, more easily:
		A> intprint -sb:interrup.sum -m -p interrup.a prn
		1587 pages   [screen output from INTPRINT]

	Create only a summary file:

		C> intprint -sinterrupt.sum interrup.lst nul

	Create a listing of the tables in the interrupt list:

		C> intprint -Tinterrup.tbl interrup.lst nul

	Print only those entries containing the string "DOS", except
	those containing the string "DR-DOS"

		C> type dos
		+DOS
		-DR-DOS

		C> intprint -Fdos interrup.lst nul
		

	Print the interrupt list on an Epson FX80, using 54 lines per page and
	omitting both page numbers and summary:

		C> intprint -Pepson -l54 interrup.lst >prn

	Print the interrupt list using 120 lines on every 132-line page (using
	superscript mode, for example), and make divider lines using IBM
	character graphics:

		C> intprint -I -l120 -L132 interrup.lst >prn

	Print only pages 123 through 127, assuming that 106 pages are contained
	in the first section of the list:

		C> intprint -n106 -r123:127 interrup.b prn

	Print using HP PCL4/5 escape sequences, numbering pages, from file
	"interrup.lst" to file "interrup.pcl", at the default 69 lines per
	page, using form-feeds:

		C> intprint -Php -p interrup.lst >interrup.pcl
		1587 pages    [screen output from INTPRINT]

------------------------------------------------------------------------------

PORTABILITY:
------------

INTPRINT.C contains the source code for INTPRINT, for those people who
are using the interrupt list on a machine which does not run MSDOS.
This code has been tested with Turbo C v2.0, Borland C++ v3.1, and Mach
(BSD 4.3 Unix) "cc" and "gcc".
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\references\win32 security utility classes.doc ===
Microsoft Word Document MSWordDoc Word.Document.8WIN32 Security Utility Classes Title _PID_GUIDWIN32 Security Utility Classes a-sanjes Normal a-sanjes Microsoft Word 8.0WIN32 Security Utility Classes The intention of this document is to provide a brief outline of the WIN32 Security Model, and how the Security Utility classes that are used by SECRCW32.DLL encapsulate this model.  It is not the intention of this document to thoroughly describe the guts of NT Security.  For this sort of information, a good text is Windows NT Security by Nik Okuntseff. WIN32 Security There are several different constructs one must be familiar with in order to work with Windows NT security.  These are as follows:  SID, ACE, ACL, ACL, DACL, Owner, SECURITY_DESCRIPTOR. A SID is a Security Identifier.  A Security Identifier identifies an account that can be a group, user, or a well-known SID (such as the group EVERYONE).  SIDs are used to identify accounts for which levels of security are being applied.  The class CSid is used to encapsulate the functionality of a SID. ACE stands for Access Control Entry.  An Access Control Entry is a piece of data that must be one of several types: Access Allowed Access Denied System Audit System Alarm (not supported by the provider) Once the type is defined, the ACE itself consists of a SID, an Access Mask and a set of flags.  The SID is the account the ACE describes access for, the Access Mask is the access bits the ACE controls for the user and the flag values vary from ACE Type to ACE Type.  The class CAccessEntry encapsulates the data in an ACE. An ACL is an Access Control List.  ACLs in the Win32 API have a set of APIs for managing them.  ACLs are made up of ACEs.  For usability sake, I created a class called CAccessEntryList that uses a STL Linked List to maintain CAccessEntry objects. A DACL is a Discretionary Access Control List.  A DACL consists of only Access Allowed and Access Denied ACEs.  This is what is traversed by the OS in order to determine whether or not a user has access to a particular object.  An Empty DACL means that nobody has access to the object..  A NULL DACL means there is no security and Everyone has Full Control over the object.  The class CDACL encapsulates a list of Access Allowed and Access Denied CAccessEntry objects. A SACL is a System Access Control List.  A SACL consists of System Audit and System Alarm ACEs.  The class CSACL encapsulates a list of System Audit ACEs (System Alarm ACEs are ignored). Owner Any secured object has an Owner.  The Owner of an object is a SID that ALWAYS has access to change the DACL of an object, so even if a DACL gets set so that nobody can access the object, there is always an account that can fix the DACL.  A CSid is used to describe an object s owner. SECURITY DESCRIPTOR When one gets or sets and object s security, the medium used to transmit the information is a SECURITY_DESCRIPTOR.  A SECURITY_DESCRIPTOR can contain an Owner, a DACL and a SACL.  SECURITY_DESCRIPTORs may be Absolute or Self-Relative.  Self-Relative means the descriptor and all of its components are contained in a single contiguous block of memory.  Absolute means the descriptor contains pointers to external memory blocks.  The CSecurityDescriptor class encapsulates the functionality of a Security Descriptor and is intended to hide the  self-relative vs. Absolute  nastiness of dealing with Security Descriptors, DACLs, SACLs and SIDs. Security Utility Classes This section outlines the different classes in the Security Utils directory.  The intention of these descriptions is to give a brief overview of the classes and what they are used for.  Please note that the basic idea for these classes was lifted from the Windows NT Security by Nik Okuntseff book mentioned earlier, although the actual implementation is somewhat different in terms of how classes are put together and the entry point functions are used to provide the desired functionality. This class holds on to the various data associated with an account.  This includes name, domain, SID and Sid Type.  A CSid can be initialized with a PSID, an account name in  Domain\Name  format, or a separate Domain and Name.  It can also have the name of a computer to execute on specified in order to handle accounts on a remote machine.  Because it lookups can go out over the network, be aware that sometimes instantiating these can be somewhat costly.  There are also three functions that have somewhat mystical returns, that one should be aware of: IsValid() IsOK() IsAccountTypeValid() IsValid() returns if the CSid contains a valid PSID (althoough a Lookup may have failed because a domain controller could not be reached).  This means that at least the contained SID is valid. IsOK() returns if a Lookup was successfully executed, meaning that the SID, Account Name and Domain Name values are all valid (although possibly empty in the case of the last 2 values). IsAccountTypeValid() returns whether or not the Account Type returned by a lookup is a Deleted User, Invalid or Unknown.  A Lookup may succeed for a SID, but specify a Deleted User, in which case the Account Information can be goofy (a domain, but no name). CAccessEntry Access control lists in Win32 are comprised of ACEs.  In the Security Classes we are using, our Access Control Lists are comprised of CAccessEntry objects.  These objects really just act as wrappers for the data held in various ACE objects.  Currently, the objects are differentiated by the ACEType value, although deriving classes from here (e.g. CAccessAllowedEntry, CAccessDeniedEntry) might not be such a bad idea I terms of preserving type-safety and being all objecty and stuff. CAccessEntryList This class encapsulates a linked list of CAccessEntry objects.  It is designed  to provide direct memory access to its data to only itself and derived classes.  Public functions for enumerating and retrieving data only allow the user to work with copies of data held internally by the class.  The idea here is to make the class as goof-proof as possible.  Also, since ACLs tend to consist of finite types of ACEs, the idea here, was to allow derived classes to provide public entry points for adding and removing CAccessEntry objects, so that type-safety in terms of our lists is preserved.  When we build Access Entry Lists, one of our features, is that if we find duplicate ACEs in an ACL, we merge them together so we maintain single ACEs based on SID, Type and Flags. CDACL This class is derived from CAccessEntryList.  It ONLY allows the user to add and remove Access Allowed and Access Denied entries.  Of note here, is the fact that DACLs maintain a canonical order of entries.  What this means, is that in order to optimize the NT access check tests, one should place all access denied entries before one s access allowed entries.  NT does NOT enforce this, however, but it is encouraged.  With this in  mind, when Access Denied entries are added to a DACL, they are added at the head of the list, while Access Allowed entries are appended to the end of the list.  NT 5.0 adds some gotchas to all this which, I will discuss later in an NT 5.0 section. CSACL This class is derived from CAccessEntryList.  It currently only contains functions for adding and removing Audit Entries, however, it is where we would also add Alarm entries when we decide to support those entries as well. CTokenPrivilege In order to perform some  of our operations, such as obtaing SACLs or setting an objct s Owner, certain Windows NT Privileges need to be enabled in the token the thread is using to perform our operations.  This class provides an easy way to enable/disable a named privilege in our associate access token. CSecurityDescriptor This is the big kahuna.  The InitializeSecurity() function call is passed a Security Descriptor which is used to record an Owner SID, a DACL and a SACL.  The DACL is broken into two parts, an Access Allowed DACL and an Access Denied DACL.  If a user requests a DACL, the two are combined together into a single DACL.  By keeping the entries separate internally, it just makes it easy to track which entries are going where.  One of the internal  features  is that NULL DACLs are translated into an Access Allowed DACL with a single ACE for  Everyone  with full control security.  This is automagically translated on the way in and on the way out.  Corresponding entry points for adding and removing typed Access Entries are provided for the DACL and SACL members, as well as for changing an object s owner.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\references\ralphbrown\combine.doc ===
COMBINE.COM v2.00
			     by Ralf Brown
			      19 October 1996

COMBINE.COM will concatenate all of the files in the interrupt list
distribution archives into a single master file, which is required by
some viewers and hypertext conversion programs.

To use COMBINE, just change to the directory into which you extracted
the distribution archives, and type

	COMBINE {dir}

where {dir} is the name of the directory in which you want the combined
list to be stored (typically, you will type "COMBINE ." to store the
result in the same directory as the individual sections).  If there is
not enough free disk space to hold both the individual sections and the
combined list, you will be told and given the option of running COMBINE
again with an option to tell it that it should delete each section as
it is added to the combined file:

	COMBINE -d {dir}

COMBINE will skip any missing sections of the interrupt list; if at
least one section other than INTERRUP.A is present, it will stop as
soon as the last section has been processed (otherwise, it will
continue trying all names through INTERRUP.Z).  On completion, it sets
the combined file's timestamp to be the same as that of the last of
the individual sections.

System Requirements:
	DOS 2.0+ or a DOS compatibility box
	64K available RAM
	a copy of the interrupt list :-)
	sufficient free disk space (~360K with the -d option)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\references\ralphbrown\86bugs.doc ===
Hamarsoft (R) 86BUGS list, supplemental programs.
The 86BUGSxy archive should contain the following files:

- 86BUGS.HLP    Microsoft QuickHelp hypertext version of the list.
- 86LISTnn.LST	The text version of the 86BUGS list.
- FILE_ID.DIZ   An upload description for Bulletin Boards.
- iAPX122.ZIP   Testing software archive from Chris Lueders, Germany.
- INFO.EXE      CPU info program with various information regarding your
                processor.
- STAT.EXE      Pentium Processor Pipeline & features performance monitor.

Both STAT and INFO are provided by Christian Ludloff. These programs are
based on his article in the german C't Magazine of November 1994 (issue 11).

iAPX122 is a testing program provided by Chris Lueders. It tests for some
of the bugs mentioned in the 86BUGS list.

All programs are provided with this list as a service from Hamarsoft to the
readers of the 86BUGS list. Hamarsoft does not accept any liability for
these programs whatsoever.

The 86BUGS list is also distributed with Ralf Brown's Interrupt List.

[86BUGS.HLP has been omitted for space reasons, and the other files except
for 86LISTnn.LST are located in INTERrrD.ZIP.  86LISTnn.LST has been
renamed to 86BUGS.LST for compatibility with hypertext conversion
programs expecting that name.]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\references\raidspec.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Corp. Logical Volume Management Specification Title _PID_GUID _PID_HLINKSLogical Volume Management Specification Catharine van Ingen Normal Catharine van Ingen Microsoft Word 8.0@@@@@@ @@@@@@                                                                                   @\\MSPRINT44\CORPK 26/2557 (MC2S) 172.31.240.249 Ne00: winspool HP LaserJet 4Si/4Si MX PS \\MSPRINT44\CORPK 26/2557 (MC2S Letter \\MSPRINT44\CORPK 26/2557 (MC2S LetterbKKl!B jkC4{r$ nwTnv O-ECV] 0c]j; `j;<l^k ;a)b% ';{T` h_,Do H|Ft>M Djin  2]sB6 M5$y5 s0{/9 kecUe`v R_JSSSn Ck:VTW C4a/$> e+b^4 l -RgOVISIO 5 Drawing VISIO 5.0 Shapes Visio.Drawing.5Pages Page-1 _VPID_PREVIEWSF:\My Documents\NT\RAID.vsdVisio (TM) Drawing  Arial) s New RoWman) Wingd gPJ?@ |cb4u4 K/]/o/ _IO[O +.5,c F?2o~U03NVb 0Mf~[ pM___q_  2|ei)d lo~e# aserJet  /1/C/ om page 11N/ WINSPO HP La serJet 5 \\Res earch\9s 1MailCop P!2s P!: HADB& @@ L2 _Do>_hi &O8OJO\OnO Physic al disk( ?1?C? hSoftw are log volume p rovider CHard Commo managm ent lay G?Y?k? ._?92 _h?z? u-O?OQD _1_C_U_g_y_ o-o?oQocouo ig-magil la aps f or contr olled bi nding, p eru mance  and sta te chang e monito Oh_&/8/J, Free-fro_m-car  pr$/autoi!c Page-1 k fill White Greeun Yellow  dash1 Hairq Short Arial c top le T/imes ] r] d] U ] G] <] -] VISIO 5 Drawing VISIO 5.0 Shapes Visio.Drawing.5Pages Masters Page-1 Dynamic connector Box.13 _VPID_PREVIEWS _PID_LINKBASEVisio (TM) Drawing  Arial) s New RoWman) Wingd gPJ?@ |cb4u4 yJB T S/e/w/ ?!?3? _QOcOuFE +65,c U03^b GO !S_e_w_ \ong#S E&%"ctO Generi c box wi th text  and conn ection p oints. C an be st retched  y dimwens opyright  1996  Visio Co rporatio n.  All  s reser Shape. hlp!#150 V/(!`! '@j'@6 Conn_ector[ This c onnector  automat ically r outes be tween th e shap to glu  ethod3 pyright   1997 V isio Cor poration .  All p2 s reserv shape.h lp!#2600 Generi c box wi th text  and conn ection p oints. C an be st retched  y dimwens opyright  1997  Visio Co rporatio n.  All  s reser Shape. hlp!#150 V/(!`! '@j'@6J'@ ?8--(P q0.O@Ou0UOgO 90q_S gBv- b i(o-& :9Healthy o1oCm Zolo~o( .Bnb'v -pGPa B?T9B RebuildiCng Initia </N/`/r! L/Y/j$ ?0?B?T?f? ?)&a;  N?k0O X-`D-`0-` 8@TQh r6b"q0_a* 6bI2: _a: .{P<d`T t`M: N Page-1 Black  _White Green Yellow 10% x Long d 1Gpxl Hairq rial ck e?red top left o>!6#5I ector 1a 1-6#10 DA `!JD%7 AX d!T mic cQ& ovisP Stylt #Rout 1Clea ranceX lockSiz #Avenu 3P trol sAsInput ..g20 O21$Or uVOr.6 ~Or.19 /:/L/^/ /#?9?BVISIO 5 Drawing VISIO 5.0 Shapes Visio.Drawing.5Pages Masters Page-1 Database 1-D single Dynamic connector _VPID_PREVIEWS _PID_LINKBASEVisio (TM) Drawing  Arial) s New RoWman) Wingd gPJ?@ =?O?j?s? Generi c box wi th text  and conn ection p oints. C an be st retched  y dimwens opyright  1997  Visio Co rporatio n.  All  s reser Shape. hlp!#150 V/(!`! '@j'@6J'@ Repres ents a d atabase,~  sourc or other torage  device.  Right-cl ick to  propert y inform ation. Shape. hlp!#110 Copyrigh  1997  Visio C orporati on.  All "s rese rved. ?!DJ?R ?Data nter inv entory I D numberT equipm facturerW _ nameH Producwt N odewl NC escrip inO " erties !+Sety  for thi s piece  docmd(_1312)>! Open o r closed  arrow.  Place o gains t edg another ing to F ront". opyright  1997  Visio Co rporatio n.  All  R"s reser Shape. hlp!#150o15 Open T Close93 sc~j ch.c1 ~@V:#3 d of arr ps-8R 6D0x0 Q(-DT Conn_ector[ This c onnector  automat ically r outes be tween th e shap to glu  ethod3 pyright   1997 V isio Cor poration .  All p2 s reserv shape.h lp!#2600 ?8--(P Network 6vx#@u utoma gical co nfigurat @/z3@ 'hf4P( P~Z+p 4EDisk Stripin z5Xp] _$_6_H_ MapkQ  caten %;)HH  Plext Zgtkou NqNto E`Ta` 8Wxp k Page-1 Hairli ite fill ial  8pt  centere Net-Thi7ck  Norma Locatio Manuf acturer Produ ctName odelNu visPlac Style| Depth Routing Clearanc top lef Block venue$# Controls AsInputs _%Res%  La#Pl owOnDr 1-gD s' '.10Y nnector Dynamic 9c 6A2&? i0Ni0Ki02i0. i0+i0 /:/L/^/ ?6?H?Z? winspo \\NTP RINT\HP  4Si CORP PRINT\HP  4Si COR PL PS ?Letterinfo subject NT Logical Volume Management Specification  FILENAME  \* MERGEFORMAT  RAIDspec Author: Norbert Kusters, Cristian Teodorescu, Catharine van Ingen, Felipe Cabrera Send Comments about this document to the above  Version 2.2 3 February 1999 Distribution: Microsoft Internal Distribution  Copyright Microsoft Corporation, 1998. All Rights Reserved. Microsoft Confidential Note: This documentation is an early release of the final product documentation. It is meant to accompany software that is still in development. Some of the information in this documentation may be inaccurate or may not be an accurate representation of the functionality of the final retail product. Microsoft assumes no responsibility for any damages that might occur either directly or indirectly from these inaccuracies. DRAFT   TOC \o "1-4"  Introduction  PAGEREF _Toc444866374 \h  No-Care Logical Volume Management  PAGEREF _Toc444866375 \h  Free-From-Care System  PAGEREF _Toc444866376 \h  Glossary  PAGEREF _Toc444866377 \h  Behavioral Model  PAGEREF _Toc444866378 \h  Architectural Model  PAGEREF _Toc444866379 \h  2.1.1 Disks, disk extents, and volume extents  PAGEREF _Toc444866380 \h  2.1.2 Volume attributes  PAGEREF _Toc444866381 \h  2.1.3 Logical volume construction  PAGEREF _Toc444866382 \h  2.1.4 Automagic logical volume configuration  PAGEREF _Toc444866383 \h  2.1.5 Stacking: maps and stripes  PAGEREF _Toc444866384 \h  2.1.6 Stacking: plexing  PAGEREF _Toc444866385 \h  2.1.7 Diskpacks  PAGEREF _Toc444866386 \h  2.1.8 Logical volume management and Wolfpack  PAGEREF _Toc444866387 \h  Provider Interface  PAGEREF _Toc444866388 \h  Provider Attributes  PAGEREF _Toc444866389 \h  3.1.1 QueryProviderControllerID  PAGEREF _Toc444866390 \h  3.1.2 QueryProviderID  PAGEREF _Toc444866391 \h  3.1.3 QueryProviderName  PAGEREF _Toc444866392 \h  3.1.4 QueryProviderType  PAGEREF _Toc444866393 \h  3.1.5 Provider-Specific Extensions  PAGEREF _Toc444866394 \h  3.1.6 QueryDefaults  PAGEREF _Toc444866395 \h  3.1.7 QueryParameters  PAGEREF _Toc444866396 \h  Asynchronous operations  PAGEREF _Toc444866397 \h  3.2.1 CancelOperation  PAGEREF _Toc444866398 \h  3.2.2 CompleteOperation  PAGEREF _Toc444866399 \h  Logical Volume Types and Attributes  PAGEREF _Toc444866400 \h  Automagic Binding  PAGEREF _Toc444866401 \h  3.4.1 BindVolume  PAGEREF _Toc444866402 \h  3.4.2 UnbindVolume  PAGEREF _Toc444866403 \h  3.4.3 ResizeBindVolume  PAGEREF _Toc444866404 \h  Volume Stacking  PAGEREF _Toc444866405 \h  3.5.1 StripeVolume  PAGEREF _Toc444866406 \h  3.5.2 UnstripeVolume  PAGEREF _Toc444866407 \h  3.5.3 MapVolume  PAGEREF _Toc444866408 \h  3.5.4 UnmapVolume  PAGEREF _Toc444866409 \h  Volume Plexing  PAGEREF _Toc444866410 \h  3.6.1 AddPlex  PAGEREF _Toc444866411 \h  3.6.2 RemovePlex  PAGEREF _Toc444866412 \h  Diskpack and Platter Management  PAGEREF _Toc444866413 \h  3.7.1 Create Pack  PAGEREF _Toc444866414 \h  3.7.2 DeletePack  PAGEREF _Toc444866415 \h  3.7.3 AddDisksToPack  PAGEREF _Toc444866416 \h  3.7.4 EvacuateDisks  PAGEREF _Toc444866417 \h  3.7.5 FreeDisksFromPack  PAGEREF _Toc444866418 \h  3.7.6 ReplaceDisk  PAGEREF _Toc444866419 \h  3.7.7 InhabitDisks  PAGEREF _Toc444866420 \h  3.7.8 Create Platter  PAGEREF _Toc444866421 \h  3.7.9 ImportPlatter  PAGEREF _Toc444866422 \h  3.7.10 ExportPlatter  PAGEREF _Toc444866423 \h  3.7.11 MigratePlatter  PAGEREF _Toc444866424 \h  3.7.12 MoveVolumesOntoPlatter  PAGEREF _Toc444866425 \h  3.7.13 MoveVolumesOffPlatter  PAGEREF _Toc444866426 \h  3.7.14 ForgetPlatter  PAGEREF _Toc444866427 \h  Logical Volume Topology Queries  PAGEREF _Toc444866428 \h  3.8.1 QueryDisks  PAGEREF _Toc444866429 \h  3.8.2 QueryVolumes  PAGEREF _Toc444866430 \h  3.8.3 QueryVolumeDeviceObject  PAGEREF _Toc444866431 \h  3.8.4 QueryVolumeDiskExtents  PAGEREF _Toc444866432 \h  3.8.5 QueryVolumeDiskNumber  PAGEREF _Toc444866433 \h  3.8.6 QueryVolumeExtents  PAGEREF _Toc444866434 \h  3.8.7 QueryVolumePlexes  PAGEREF _Toc444866435 \h  3.8.8 QueryVolumeProvider  PAGEREF _Toc444866436 \h  DiskPack and Platter Queries  PAGEREF _Toc444866437 \h  3.9.1 QueryPacks  PAGEREF _Toc444866438 \h  3.9.2 QueryPlatters  PAGEREF _Toc444866439 \h  3.9.3 QueryVolumePack  PAGEREF _Toc444866440 \h  3.9.4 QueryDiskPack  PAGEREF _Toc444866441 \h  3.9.5 QueryPackProvider  PAGEREF _Toc444866442 \h  Logical Volume Attributes  PAGEREF _Toc444866443 \h  3.10.1 QueryVolumeAttributes  PAGEREF _Toc444866444 \h  3.10.2 QueryVolumeSize  PAGEREF _Toc444866445 \h  3.10.3 QueryVolumeType  PAGEREF _Toc444866446 \h  3.10.4 QueryVolumeState  PAGEREF _Toc444866447 \h  3.10.5 QueryVolumeLbnRemap  PAGEREF _Toc444866448 \h  3.10.6 QueryVolumeRebuildPriority  PAGEREF _Toc444866449 \h  3.10.7 ForceVolumeHealthy  PAGEREF _Toc444866450 \h  3.10.8 ForceVolumeInitialize  PAGEREF _Toc444866451 \h  3.10.9 ForceVolumeRebuild  PAGEREF _Toc444866452 \h  3.10.10 SetVolumeLbnRemap  PAGEREF _Toc444866453 \h  3.10.11 SetVolumeRebuildPriority  PAGEREF _Toc444866454 \h  3.10.12 SetVolumeExtensions  PAGEREF _Toc444866455 \h  Disk Attributes  PAGEREF _Toc444866456 \h  3.11.1 QueryDiskSize  PAGEREF _Toc444866457 \h  3.11.2 QueryDiskConnection  PAGEREF _Toc444866458 \h  3.11.3 QueryDiskDeviceObject  PAGEREF _Toc444866459 \h  3.11.4 QueryDiskStatus  PAGEREF _Toc444866460 \h  3.11.5 SetDiskHotSpare  PAGEREF _Toc444866461 \h  3.11.6 QueryDiskProvider  PAGEREF _Toc444866462 \h  Hardware Controllers and Physical Topology  PAGEREF _Toc444866463 \h  3.12.1 QueryControllerParameters  PAGEREF _Toc444866464 \h  3.12.2 QueryControllerAttributes  PAGEREF _Toc444866465 \h  3.12.3 QueryControllerDeviceObject  PAGEREF _Toc444866466 \h  3.12.4 QueryControllerPath  PAGEREF _Toc444866467 \h  3.12.5 QueryControllerLbnRemap  PAGEREF _Toc444866468 \h  3.12.6 ForceControllerHealthy  PAGEREF _Toc444866469 \h  3.12.7 ForceControllerInitialize  PAGEREF _Toc444866470 \h  3.12.8 ForceControllerRebuild  PAGEREF _Toc444866471 \h  3.12.9 ForceControllerPath  PAGEREF _Toc444866472 \h  3.12.10 SetControllerExtensions  PAGEREF _Toc444866473 \h  3.12.11 QueryDiskExtensions  PAGEREF _Toc444866474 \h  3.12.12 QueryDiskParameters  PAGEREF _Toc444866475 \h  3.12.13 QueryDiskAttributes  PAGEREF _Toc444866476 \h  3.12.14 QueryControllerDisks  PAGEREF _Toc444866477 \h  Simple Maintenance Operations  PAGEREF _Toc444866478 \h  3.13.1 StartDiskMaintenance  PAGEREF _Toc444866479 \h  3.13.2 StopDiskMaintenance  PAGEREF _Toc444866480 \h  3.13.3 PulseDiskMaintenance  PAGEREF _Toc444866481 \h  3.13.4 StartControllerMaintenance  PAGEREF _Toc444866482 \h  3.13.5 StopControllerMaintenance  PAGEREF _Toc444866483 \h  3.13.6 PulseControllerMaintenance  PAGEREF _Toc444866484 \h  Controller Maintenance Operations  PAGEREF _Toc444866485 \h  3.14.1 QueryMaintenanceElement  PAGEREF _Toc444866486 \h  3.14.2 SetMaintenanceControl  PAGEREF _Toc444866487 \h  3.14.3 QueryMaintenanceStatus  PAGEREF _Toc444866488 \h  3.14.4 SetMaintenanceThresholds  PAGEREF _Toc444866489 \h  3.14.5 QueryMaintenanceThresholds  PAGEREF _Toc444866490 \h  Provider Support  PAGEREF _Toc444866491 \h  3.15.1 AutomagicToDirectBinding  PAGEREF _Toc444866492 \h  3.15.2 SCSISendDiagnostic  PAGEREF _Toc444866493 \h  3.15.3 SCSIReceiveDiagnostic  PAGEREF _Toc444866494 \h  Performance Monitoring  PAGEREF _Toc444866495 \h  3.16.1 ClearPerformanceCounter  PAGEREF _Toc444866496 \h  3.16.2 DisablePerformanceCounter  PAGEREF _Toc444866497 \h  3.16.3 EnablePerformanceCounter  PAGEREF _Toc444866498 \h  3.16.4 QueryPerformanceCounters  PAGEREF _Toc444866499 \h  3.16.5 QueryPerformanceData  PAGEREF _Toc444866500 \h  3.16.6 QueryPerformanceCounterStatus  PAGEREF _Toc444866501 \h  3.16.7 StartPerformanceMonitor  PAGEREF _Toc444866502 \h  3.16.8 StopPerformanceMonitor  PAGEREF _Toc444866503 \h  Error Monitoring  PAGEREF _Toc444866504 \h  Client Interface  PAGEREF _Toc444866505 \h  ILVM Public Data and Methods  PAGEREF _Toc444866506 \h  4.1.1 BindVolume  PAGEREF _Toc444866507 \h  4.1.2 StripeVolume  PAGEREF _Toc444866508 \h  4.1.3 MapVolume  PAGEREF _Toc444866509 \h  4.1.4 Create Pack  PAGEREF _Toc444866510 \h  4.1.5 QueryDisks  PAGEREF _Toc444866511 \h  4.1.6 QueryPacks  PAGEREF _Toc444866512 \h  4.1.7 QueryProviders  PAGEREF _Toc444866513 \h  4.1.8 QueryVolumes  PAGEREF _Toc444866514 \h  4.1.9 ClearPerformanceCounter  PAGEREF _Toc444866515 \h  4.1.10 QueryPerformanceAttributes  PAGEREF _Toc444866516 \h  4.1.11 StartPerformanceMonitor  PAGEREF _Toc444866517 \h  4.1.12 StopPerformanceMonitor  PAGEREF _Toc444866518 \h  ILVMProvider Public Data and Methods  PAGEREF _Toc444866519 \h  4.2.1 EvacuateDisks  PAGEREF _Toc444866520 \h  4.2.2 InhabitDisks  PAGEREF _Toc444866521 \h  4.2.3 QueryControllers  PAGEREF _Toc444866522 \h  4.2.4 QueryDisks  PAGEREF _Toc444866523 \h  4.2.5 QueryID  PAGEREF _Toc444866524 \h  4.2.6 QueryLUNs  PAGEREF _Toc444866525 \h  4.2.7 QueryName  PAGEREF _Toc444866526 \h  4.2.8 QueryPacks  PAGEREF _Toc444866527 \h  4.2.9 QueryVolumes  PAGEREF _Toc444866528 \h  4.2.10 QueryType  PAGEREF _Toc444866529 \h  IVolume Public Data and Methods  PAGEREF _Toc444866530 \h  4.3.1 Delete  PAGEREF _Toc444866531 \h  4.3.2 Extend  PAGEREF _Toc444866532 \h  4.3.3 Shrink  PAGEREF _Toc444866533 \h  4.3.4 AddPlex  PAGEREF _Toc444866534 \h  4.3.5 RemovePlex  PAGEREF _Toc444866535 \h  4.3.6 ForceHealthy  PAGEREF _Toc444866536 \h  4.3.7 ForceInitialize  PAGEREF _Toc444866537 \h  4.3.8 ForceRebuild  PAGEREF _Toc444866538 \h  4.3.9 SetExtensions  PAGEREF _Toc444866539 \h  4.3.10 SetLbnRemap  PAGEREF _Toc444866540 \h  4.3.11 SetRebuildPriority  PAGEREF _Toc444866541 \h  4.3.12 QueryAttributes  PAGEREF _Toc444866542 \h  4.3.13 QueryControllers  PAGEREF _Toc444866543 \h  4.3.14 QueryDiskExtents  PAGEREF _Toc444866544 \h  4.3.15 QueryDiskNumber  PAGEREF _Toc444866545 \h  4.3.16 QueryExtents  PAGEREF _Toc444866546 \h  4.3.17 QueryID  PAGEREF _Toc444866547 \h  4.3.18 QueryLbnRemap  PAGEREF _Toc444866548 \h  4.3.19 QueryPack  PAGEREF _Toc444866549 \h  4.3.20 QueryPlatter  PAGEREF _Toc444866550 \h  4.3.21 QueryPlexes  PAGEREF _Toc444866551 \h  4.3.22 QueryProvider  PAGEREF _Toc444866552 \h  4.3.23 QuerySize  PAGEREF _Toc444866553 \h  4.3.24 QueryState  PAGEREF _Toc444866554 \h  4.3.25 QueryType  PAGEREF _Toc444866555 \h  4.3.26 QueryVolumeUsingPlex  PAGEREF _Toc444866556 \h  4.3.27 QueryVolumesUsingVolume  PAGEREF _Toc444866557 \h  4.3.28 StartMaintenance  PAGEREF _Toc444866558 \h  4.3.29 StopMaintenance  PAGEREF _Toc444866559 \h  4.3.30 PulseMaintenance  PAGEREF _Toc444866560 \h  4.3.31 ClearPerformanceCounter  PAGEREF _Toc444866561 \h  4.3.32 DisablePerformanceCounter  PAGEREF _Toc444866562 \h  4.3.33 EnablePerformanceCounter  PAGEREF _Toc444866563 \h  4.3.34 QueryPerformanceCounters  PAGEREF _Toc444866564 \h  4.3.35 QueryPerformanceData  PAGEREF _Toc444866565 \h  4.3.36 QueryPerformanceCounterStatus  PAGEREF _Toc444866566 \h  4.3.37 StartPerformanceMonitor  PAGEREF _Toc444866567 \h  4.3.38 StopPerformanceMonitor  PAGEREF _Toc444866568 \h  IPack Public Data and Methods  PAGEREF _Toc444866569 \h  4.4.1 Delete  PAGEREF _Toc444866570 \h  4.4.2 AddDisks  PAGEREF _Toc444866571 \h  4.4.3 CreatePack  PAGEREF _Toc444866572 \h  4.4.4 FreeDisks  PAGEREF _Toc444866573 \h  4.4.5 QueryDisks  PAGEREF _Toc444866574 \h  4.4.6 QueryID  PAGEREF _Toc444866575 \h  4.4.7 QueryPlatters  PAGEREF _Toc444866576 \h  4.4.8 QueryProvider  PAGEREF _Toc444866577 \h  4.4.9 QueryVolumes  PAGEREF _Toc444866578 \h  IPlatter Public Data and Methods  PAGEREF _Toc444866579 \h  4.5.1 Delete  PAGEREF _Toc444866580 \h  4.5.2 Export  PAGEREF _Toc444866581 \h  4.5.3 Import  PAGEREF _Toc444866582 \h  4.5.4 Migrate  PAGEREF _Toc444866583 \h  4.5.5 MoveVolumesOff  PAGEREF _Toc444866584 \h  4.5.6 MoveVolumesOnto  PAGEREF _Toc444866585 \h  4.5.7 QueryDisks  PAGEREF _Toc444866586 \h  4.5.8 QueryPack  PAGEREF _Toc444866587 \h  4.5.9 QueryProvider  PAGEREF _Toc444866588 \h  4.5.10 QueryVolumes  PAGEREF _Toc444866589 \h  IDisk Public Data and Methods  PAGEREF _Toc444866590 \h  4.6.1 ReplaceDisk  PAGEREF _Toc444866591 \h  4.6.2 SetHotSpare  PAGEREF _Toc444866592 \h  4.6.3 QueryConnection  PAGEREF _Toc444866593 \h  4.6.4 QueryController  PAGEREF _Toc444866594 \h  4.6.5 QueryExtensions  PAGEREF _Toc444866595 \h  4.6.6 QueryID  PAGEREF _Toc444866596 \h  4.6.7 QueryParameters  PAGEREF _Toc444866597 \h  4.6.8 QueryPack  PAGEREF _Toc444866598 \h  4.6.9 QueryPlatter  PAGEREF _Toc444866599 \h  4.6.10 QueryProvider  PAGEREF _Toc444866600 \h  4.6.11 QuerySize  PAGEREF _Toc444866601 \h  4.6.12 QueryStatus  PAGEREF _Toc444866602 \h  4.6.13 QueryVolumesUsingDisk  PAGEREF _Toc444866603 \h  IController Public Data and Methods  PAGEREF _Toc444866604 \h  4.7.1 ForceHealthy  PAGEREF _Toc444866605 \h  4.7.2 ForceInitialize  PAGEREF _Toc444866606 \h  4.7.3 ForcePath  PAGEREF _Toc444866607 \h  4.7.4 ForceRebuild  PAGEREF _Toc444866608 \h  4.7.5 SetExtensions  PAGEREF _Toc444866609 \h  4.7.6 QueryAttributes  PAGEREF _Toc444866610 \h  4.7.7 QueryDisks  PAGEREF _Toc444866611 \h  4.7.8 QueryID  PAGEREF _Toc444866612 \h  4.7.9 QueryLbnRemap  PAGEREF _Toc444866613 \h  4.7.10 QueryPath  PAGEREF _Toc444866614 \h  4.7.11 QueryProvider  PAGEREF _Toc444866615 \h  CIM Public Data and Methods  PAGEREF _Toc444866616 \h  NT callbacks  PAGEREF _Toc444866617 \h  5.1.1 EvacuateVolumeExtent  PAGEREF _Toc444866618 \h  5.1.2 InhabitVolumeExtent  PAGEREF _Toc444866619 \h  5.1.3 SynchVolumeContents  PAGEREF _Toc444866620 \h  5.1.4 UpdateWolfpackLVM  PAGEREF _Toc444866621 \h  5.1.5 GetWolfpackLVM  PAGEREF _Toc444866622 \h  Vendor interactions and issues  PAGEREF _Toc444866623 \h  6.1.1 Veritas  PAGEREF _Toc444866624 \h  6.1.2 Minimalist hardware provider  PAGEREF _Toc444866625 \h  6.1.3 Automagic enterprise hardware provider  PAGEREF _Toc444866626 \h  References  PAGEREF _Toc444866627 \h  Issues  PAGEREF _Toc444866628 \h   PAGEREF _Toc444866629 \h  Closed  PAGEREF _Toc444866630 \h  Revision History  PAGEREF _Toc444866631 \h  Introduction The Logical Volume Management API provides a vendor-neutral and technology-neutral interface for the management of logical volumes. Management operations include operations such as binding, topology discovery and tracking, volume status and fault tracking, and performance monitoring. The same client API can be used to manage hardware controller-based and host-based logical volume providers.  This has several benefits: Common configuration management applications can be built. Customers manage heterogeneous storage systems and migrate data across different hardware configurations over time. A single interface for scripting or GUI should simplify those activities.  Common monitoring applications can be built. The API includes both performance monitoring and error monitoring methods and defines a common subscription model for both.   Volume management stacking operation policy is defined. The API enforces limits on configurations eliminating many theoretically possible but either silly or ineffectual configurations. The policy acts as a guideline to simplify configuration planning.   The playing field for storage management applications is leveled. Such applications often encapsulate much operational policy; encouraging multiple vendors to address these policy needs is goodness. We recognize three different types of storage subsystem environments. Each presents different requirements for logical volume management.  No-care subsystems. Laptops and other systems with one or a few disks have little or only transitory need for logical volume services beyond simple disk partitioning.  Logical volume management can simplify storage management tasks but must not act as a tax on these systems.  Free-from-care subsystems. These systems benefit from logical volume management particularly when that management is transparent. Describing data storage desires as  really, really safe  rather than  3-way mirror set  simplifies storage management for the non-technical manager of a small office system. Self-managing storage can also simplify the operation of larger sites by automating fault handling. Free-from-care subsystems represent the bulk of our market and the design center of the LVM API. Our vendor (software and hardware) partners can add value by simplifying management while maximizing data availability and storage performance.  Big-magilla subsystems. Very large or complex enterprise configurations present additional site-specific or application-specific requirements. 100 TB of storage will always require more attention than configuring 100 GB and sites often tune the storage subsystem for a single application which may run only infrequently. (An example is the monthly batch reporting job on an order taking transaction system.) Moreover, system managers of these operations are used to the idea of very controlled, hands-on, storage configuration. We want to avoid anything which prevents us from scaling up to these systems and we want to make sure that it is possible for these customers to discover what the storage subsystem is doing at all times.  The LVM design center is the free-from-care subsystem of moderate size in a domain or cluster of moderate size. Moderate for early Windows 2000 is on the order of 8 disks and 4 machines; your mileage will vary.    No-Care Logical Volume Management Online media migration moves data between physical disks simply without required system downtime. Logical volume management is both more robust and more flexible. Consider the case of wanting to replace an old, small, slow system drive with a new, large, fast drive. For simplicity, assume that the system volume occupies the entire old drive. Online migration begins by creating a partition on the new drive equal in size to the old drive. That partition is then (temporarily) mirrored to the old drive. Once the two mirrors have been synchronized, the mirror set can be broken by removing the  old- drive. The new system volume is on the new drive. That volume can then be extended   giving more space for software installation. No system reboot was necessary and no reinstallation of software required since there was no change in system drive letter. Note that the removed old volume may be reformatted or used for a snapshot backup. The need for logical volume management in no-care systems is transitory. IO requests need be intercepted by the logical volume runtime only while the mirror set is present or the volume is being extended. After the operation completes, the system volume may revert to a simple DOS partition volume once more. The system should not be burdened with the overhead of the logical volume runtime.  Free-From-Care System dentist office cluster  provides a good example of logical volume management in a free-from-care system. This simple cluster consists of two Wolfpack nodes operating in either a  warm spare  mode, one active and one standby system, or  both active , each node supporting a different application.  Each node has a private system disk. Any application necessary for failover reside on one or more application disks.  In the  warm spare  mode, the application drives are managed as a single collection. At any time, only one node owns all application drives. As in non-clustered systems, logical application volumes may automatically extended and contracted as application needs change and dynamically tuned for performance or data safety. In clustered systems, logical volume management also hides the physical topology of the system. A  really safe data  application volume could be a mirror set consisting of two dual-connected SCSI drives or two IDE drives (one per node served via NetDevice). In this latter case, online migration of a processor node also causes online-migration of the storage contained in the box. Glossary Automagic configuration   provider includes a set of rules for choosing logical block remapping based on simple attributes. Automagic providers may also dynamically alter the mapping for performance or fault management. Big-magilla system   very large or complex enterprise class storage system. Binding hints   information given to an automagic volume provider to help that provider select a logical block mapping. Hints include information as to the desired fault tolerance, physical atomicity, and intended IO access pattern.   Configuration data  - describes the mapping of physical resources to logical volumes.   Directed configuration   provider is explicitly provided with rules for choosing logical block remapping.  Disk   physical storage media with a one spindle (i.e. not a hardware RAID volume set).  Disk platter   a subset of a diskpack used for exporting or importing volumes from a diskpack.  Diskpack   a collection of logical volumes and underlying disks. A diskpack is the unit of transitive closure for a volume.  Export   Move a disk platter and all volumes contained on that platter out of one diskpack.  Exposed to NT    a volume which has an associated volume name (drive letter). The volume can be made available to a file system or other data store.  Free agent drive   a disk drive which is not a member of a disk pack. Free agent drives cannot contain logical volumes which are exposed to NT.  Free-from-care system   small office or larger storage subsystem in which the details of logical volume management are transparent.  Friendly volume export   The exported platter contains one or more volumes in addition to those initially specified for export.  Health   volume fault management status. A volume may be initializing, healthy, compromised, unhealthy, or rebuilding. Hot-spotting   temporary plexing of a volume or collection of volume extents.  Import   Move a disk platter and all volumes contained on that platter into one diskpack.  Logical Block Number; addressable unit of storage data. Logical block mapping   relationship between the logical blocks exposed to the logical volume provider to those exposed by the same provider. Logical disk   result of automagic or directed configuration. The lowest stacking level volume configured.  Logical volume provider   software which exposes logical volumes. A provider includes runtime services, configuration data, and management services.  Logical Unit   physically addressable storage unit. Includes both simple disks and hardware RAID volume set.  Management service   software which executes only infrequently to perform volume configuration, monitoring or fault handling.  Mapped volume   a simple linearly logical block mapping which concatenates volumes to expose a single larger volume to NT as a drive letter or mount point.  Mirrored  volume   logical volume which maintains two or more identical data copies. Also termed  RAID 1. No-care-system   small systems which have only transitory use of logical volume management for media migration or archiving.  Parity striped volume   logical volume which maintains parity check information as well as data. The exact mapping and protection scheme is vendor-specific. Includes RAID 3, 4, 5, 6.  Plexed volume    dynamic mirror volume. Plexing is used to create a copy of a volume rather than to provide fault tolerance. The mirror is added to the volume with the intent of removal after the contents have been synchronized.  Runtime service   software which executes on a per-IO request basis.  Simple disk   disk which is not connected to a hardware RAID controller. Often called   or just a bunch of disks.  Stacked volume    volume has been constructed by more than one logical block mapping operation. An example is a stripe set of mirror volumes.  Stacking includes stripping,  mapping, and plexing.  Striped volume set   a logical block mapping which distributes contiguous logical volume extents across multiple volumes. Also termed RAID 0.  Unfriendly volume export   The exported platter contains only those volumes specified for export.  Volume   generic term for a number of disk extents bound into a virtually contiguous range of logical blocks. Volume can also be software shorthand for a mapped volume (i.e. NT drive letter or mount point).   Volume configuration stability   whether volume logical to physical mapping is undergoing change. A volume may be stable, extending, shrinking, plexing, or remapping. Volume extent   a contiguous range of logical blocks contained on a volume. Volume extents are the smallest managed logical volume unit.  Volume status   current use of a volume by the system. A volume may be unused, hot spare, mapped, used, or unknown. Behavioral Model  A logical volume is a software construct consisting of some number of disk extents bound into a virtually contiguous range of logical blocks. This binding may increase the fault tolerance, performance, or capacity characteristics of a single disk drive.  Binding software may execute in the host, in dedicated external hardware, or in a combination of both. This software, or logical volume provider, consists of: Runtime services that execute on a per IO request. This component maps the logical blocks exposed by the provider into blocks presented to the next lower layer and converts each IO request into one or more IO requests.  Configuration data that identifies the physical resources comprising the logical volume. This information must be non-volatile to allow volumes to survive power outages. Any changes to the data must be managed to prevent volume corruption in the event of media failures, interconnect failures, and volume export/import between systems.  Management services which perform all management tasks such as volume configuration (binding, unbinding, hot sparing), performance monitoring, and dynamic event handling.  This LVM API is concerned only with management services. The runtime and configuration data used by the provider are the province of the provider, although the management services place requirements on the implementation. Similarly, other storage subsystem management software, such as NTFS, backup utilities, diskperf, or SCSI monitors, are outside the scope of this document and in addition to the software described herein. Architectural Model An architectural overview of logical volume management appears below. The LVM API defines the interfaces on either side of the common logical volume management layer. The application client interface is used by logical volume management applications. Each logical volume provider (hardware or software) implements the LVM API. Providers may include vendor-specific rules to optimize binding configurations, monitor and dynamically tune performance, automatically handle faults, or any other vendor-specific added functionality.  Hardware logical volume providers include an intelligent controller communicating between one or more hosts and one or more disks. The logical volume runtime executes on the controller and is transparent to the host IO subsystem. The controller exposes a logical unit to host-based IO software. A logical unit is the physical address of the associated logical volume. Volume configuration, fault handling, and performance management functions may be split between the controller and vendor-specific host-based software. For example, volume configuration initiated by a host request may be carried out remotely by the hardware controller. At a minimum, the host-based provider software converts the LVM API methods to industry standard or vendor-specific protocol requests to the controller. Each hardware controller has a unique logical volume provider.   Software logical volume providers are strictly host-based and do not include hardware support. NT currently supports two software logical volume providers: ftdisk and Veritas.  The Common LVM Layer presents the application client a unified view across the multiple hardware and/or software logical volume providers. The Common LVM Layer multiplexes and aggregates requests across providers. The layer performs common policy enforcement checking such as deciding if unbinding a logical volume (and losing all data contained on the volume) should proceed. The layer also implements provider service routines such as file system data flush. The protocol used between logical volume providers, hardware RAID controllers and physical disks is outside this specification. Use of SCSI-3 SCC[1] or SES[2] commands is anticipated, however, for providers which use SCSI.  Disks, disk extents, and volume extents Extents are the smallest unit of space allocation and binding. A disk extent is a contiguous range of logical blocks as exposed by the disk. A volume extent is a contiguous range of logical blocks as exposed by a logical volume.   Volumes may be constructed of disk extents or volume extents. Volumes constructed of volume extents are said to be stacked.  Extent address translation is the responsibility of the disk drive or logical volume provider managing the extent. Almost all disk drives today do a simple redirection for bad block replacement; a given logical block may or may not have an immutable mapping to a given physical block. Disk drives may evolve more complex translations over time, such as replicating hot logical blocks for performance. Logical volume providers already provide more complex translations and those translations are not always simply explainable. For example, the detailed mapping of  RAID5  volumes varies with implementation.   The size of an extent as reported by the disk or logical volume provider is equal to the total space available to an application using that extent. In other words, the size of a disk sector is 512 bytes, regardless of the actual encoding overhead on the media.  The LVM API imposes a size quantum on disk and volume extent allocations. This simplifies space management when dynamically resizing volumes. The LVM API consumer specifies a desired volume size; the logical volume provider rounds up that size to the nearest quantum multiple. A successful volume resize operation results in a volume at least as large as that requested. Extents are allocated and bound to a logical volume in a single atomic (durable and all or nothing) operation.   Hot sparing is the substitution of one disk drive for a failing or failed drive. When a disk fails, the hot spare is substituted and any affected parity RAID or mirror volumes are rebuilt. Hot sparing may be automatic, performed dynamically by logical volume provider, or manual, requiring operator intervention.  Disk drives reserved for hot sparing may not be otherwise bound. If a failed disk contained a non-fault tolerant logical volume, data will be lost. If the hot-spare disk is larger than the failed disk, any overage is unused until explicitly declared available for binding. Once the hot spare has been used for volume recovery, the disk is no longer a hot spare. In other words, one 4 GB drive cannot act as two 2 GB hot spares. A provider may or may not support dynamic hot sparing   this is a policy implementation decision for the provider.  Volume attributes Associated with each logical volume is a collection of attributes describing the current status of that volume. The attributes include information as to the use of the volume by the file system, fault exposure and recovery, and configuration stability.  Volume status describes the use of the volume. The volume may be:  Unused: known to be present, but not bound to any logical volume nor reserved as a hot spare Hot Spare: reserved for use as a hot spare Mapped: bound to a logical volume which is in use by NT and available for application use Offline: mapped, but not made available to applications Used: bound to a logical volume which is not in use by NT Unknown: having a valid volume identifier, but not currently present in the configuration The health of a volume describes its fault exposure. As shown in the figure below, the volume may be: Initializing: rediscovering volume configuration Healthy: containing or able to contain valid data Compromised: a fault tolerant volume missing one or more disk or volume extents; for example, a mirror set with only one mirror currently available Unhealthy: a non-fault tolerant volume missing one or more disk or volume extents; data contained on unhealthy volumes must not be accessed Rebuilding: a previously compromised fault tolerant volume resynchronizing all volume extent data.  Volume configuration stability describes any current volume reconfiguration activity. Reconfiguration includes: Stable: no reconfiguration Extending: volume or disk extents are being added to the volume Shrinking: volume or disk extents are being removed from the volume Plexing: a volume plex is being added or removed from the volume; see   REF _Ref429380139 \r \h  2.1.6 Remapping: volume or disk extents are being remapped to different physical locations. Logical volume construction Volumes may be constructed of disk extents or volume extents. Volumes constructed of volume extents are said to be stacked. As shown below, stacking operations include mapping, stripping, and plexing. Arbitrary stacking is not permitted. A logical volume provider may support one or more of three configuration models. These are:  Automagic The provider includes a set of rules for configuring the volume based on attribute hints. The provider performs all disk space allocation, use or non-use of RAID, and parameter selection such as stripe chunk size. Automagic providers may include features such as automatic performance tuning. Support of this model allows a single operator interface to span multiple vendor providers. All logical volume providers are strongly urged to support this model.    Directed The system administrator explicitly directs the logical volume provider. The system administrator has control over storage mappings, configuration types, and configuration parameters. Directed configuration is used when stacking volumes. Software logical volume providers must support the directed stacking operations; hardware logical volume providers may support the directed stacking operations. Vendor-specific Hardware logical volume providers may chose to support configuration only through a private interface or utility. It is expected that such vendors will offer significant specialized functionality in their controllers. An example of such functionality would be dual site failover replication within a pair of controllers. Vendor specific configuration should not be used in lieu of automagic or directed configuration.   Any logical volume provider may participate in stacking at any level. Examples of very common stacking operations include software striped mirror sets or hardware automagic configuration within a single controller and software striping across controllers. A less common example would be the EMC cross-cabinet mirroring via specialized hardware interconnect. A logical volume is exposed to NT when an NT volume name is allocated and the volume becomes available to the file system or other data store. Exposing is a side effect of mapping; only mapped volumes are exposed. Mapping completes volume configuration and prepares the volume for dynamic resizing. Attempting to stack a mapped (exposed) volume will fail. This enforces a clean handoff of the volume   the provider has a guarantee that no useful data is present on the volume until exposed. A software logical volume provider generally does the final mapping.  Dynamic mirror plexes may be added to volumes. Unlike mirror set members, mirror plexes are transitory - dynamically added only to be subsequently removed. Adding a mirror plex to a volume does not change the guaranteed fault tolerance level of the volume. Specifically, an added plex will not be automatically replaced by a hot-spare drive if the added drive incurs a failure.  Exposed volumes and their contributors may be extended or contracted dynamically. Extents are always appended to or removed from the highest LBN of the volume. No modification of stripe, mirror, or RAID configuration parameters occurs as a side effect; for example, the stripe chunk size remains unchanged. The Common LVM Layer coordinates with the file system prior to shrinking or extending a volume to avoid data loss.  Failed or cancelled volume configuration operations do not have side affects. Configuration by a hardware provider may actually be a two-step process   configuring the controller followed by the volume formatting. Either phase may fail or be cancelled. In this case, any previous step appears to have been undone. For example, any allocated controller cache appears as deallocated. Performance optimizations such as postponing the undo of a time consuming operation are encouraged. The controller cache could remain allocated by the hardware, yet appear free above the hardware provider. Deconfiguring a volume totally breaks the volume into constituent extents and optionally frees all controller resources. No portion of the volume remains and all data on the volume are lost.  Automagic logical volume configuration Automagic logical volume providers have intelligence to select and monitor the storage under their care. The administrator is presented with a simple attribute oriented view of storage. The provider performs all disk extent mapping, disk space allocation and logical volume type selection. Automagic configuration is intended to provide free-from-care storage by providers with sophisticated configuration rules and/or in environments in which the system administrator is not an expert in logical volume management.  Automagic configuration is only performed on disks managed by the same logical volume provider. The logical volume provider associated with each hardware controller automagically constructs disks within that controller. Simple disks not connected to a hardware controller are automagically configured by a software logical volume provider. Note that the disks need not be homogeneous: a volume set could be configured with a RAM disk and a magnetic disk or two magnetic disks of different capacity or access bandwidths.  The result of automagic configuration is a logical disk.  The system administrator may provide hints as to the intended use of the volume. These hints include information such as the intended access pattern and desired fault handling. Access pattern information characterizes the volume as intended for sequential reads or writes, whether the volume will be dominantly read only, and the intended optimal request size and alignment. Desired fault handling includes whether the volume should be fault tolerant, is able to be removed from the configuration, and whether to optimize for safety or performance if the volume undergoes fault recovery.  The provider uses any hints in good faith. The provider need not interpret all hints; for example, a provider could implement only a single parity RAID interleave size. In the event of conflicting hints, the provider may weight any hint over another.  Providers may also expose additional binding parameters.  In all cases, the provider must  do the right thing  and must dutifully report the actual configuration upon query. The binding operations should not fail but rather default to safe or default configurations. Automagic volume providers may perform dynamic reconfiguration of a volume at any time. Automagic reconfiguration includes movement of logical volume extents and changing configuration parameters such as interleave. If the automagic provider retains the configuration hints, the provider may also change volume type, for example substituting a parity stripe volume for a mirror set. The administrator can disable reconfiguration, effectively freezing the volume configuration. Dynamic reconfiguration of a compromised volume must not lose any data contained on the volume. There are no data integrity or configuration integrity guarantees for dynamic reconfiguration of a volume until the volume is exposed to NT. The automagic hints provided give relative control to the big-magilla administrator, even though detailed directed extent-by-extent placement is not supported. For example, the administrator can specify the disks to be used by a hardware controller to configure a parity stripe volume set or controller cache size dedicated to the volume.  The big-magilla administrator is provided with mechanisms to discover the actual configuration at all times and may freeze a configuration at any time by turning off automagic reconfiguration. Automagic dynamic reconfiguration may cause serious problems for in a big-magilla system which want to be tuned for rare but important pre-scheduled operations.  Stacking: maps and stripes The LVM API enforces a hierarchy for logical volume stacking. As shown in   REF _Ref427062615 \r \h  2.1.2 , this hierarchy is:  Mapped (concatenated) volumes  Striped volumes  Automagic volumes Disks and the mapping layer is always present.   Stacking must proceed in sequence up the hierarchy and layers must not be revisited. For example, it is not possible to stripe a mapped volume   the desired volume must be constructed by mapping stripes. Similarly, it is not possible to stripe a stripe set. The imposed hierarchy provides a simple, yet sufficiently general, user model for logical volume services and limits the possibilities for theoretically valid, but foolish or ill-conceived, bindings. Any combination of hardware or software logical volume provider(s) may be used. One and only one provider may be used at any given layer and some topological restrictions may apply. For example, it is possible to use hardware mapping to extend a software stripe set only if the stripe set is fully contained within a single hardware cabinet.  Extents must be of the same type to be striped. No such restriction applies to mapping. For example, attempting to (re) stripe a parity stripe volume and a mirror volume will fail while concatenating a RAM disk with an ordinary disk  or a stripe set with a parity stripe volume  will succeed.  Volume stacking is directed. The system administrator has relatively explicit control over logical volume construction. The API for stacking operations includes the list of volumes to be bound, desired binding type, and binding parameters.  Striped volumes allocate monotonically increasing LBN ranges from each specified volume extent in the order specified. By default the number of extents on the list determines the number of stripes.  Mapped volumes are constructed by concatenating volume extents in the order given.  The logical volume provider determines the exact size and location of the extents used.   Note, of course, that a storage management application may chose to hide these details   effectively making the entire volume configuration process automagic. Common stacking parameters such as chunk (interleave) size are defined. Logical volume providers may expose additional provider-specific parameters. Such extended parameters allow specification of related parameters such as cache MB devoted to this volume or quick format. In all cases, the provider must  do the right thing  when parameters are not specified for a stacking operation. The stacking operation must not fail but rather default to a safe configuration. Explicit specification of a nonsensical interleave will cause the stacking operation to fail. Nonsensical sizes include those unsupported by the provider or which cannot be made an integral divisor of the resulting volume size.  Providers may support variable stripe chunk sizes or impose a fixed size. Mapped volumes may be extended by growing the last (highest LBN) volume or by appending volumes. Shrinking a mapped volume occurs by contracting the last volume and/or removing volumes altogether.  Stripe sets are extended or contracted by resizing the contributing volumes. For example, extending a striped mirror set will cause each mirror to grow. Since all stripe sets are mapped, the exposed volume can also be extended by appending an additional stripe set. Note that there is no consistency checking in this case; the appended stripe set need not share the number of stripes or stripe interleave of the original set.  Dynamic reconfiguration of striped or mapped volumes is not defined. Striped and mapped volumes are not automagic, even if they appear to be so due to the activities of a smart storage management application. Stacking: plexing Dynamic mirror plexing is intended for backup snapshotting or online media replacement. Backup snapshotting should be done only to exposed volumes; this ensures that when the plex is subsequently removed, the file system on that volume is consistent. Online media migration, sometimes called hot-spotting , binds the new disk(s) to an existing volume, synchronizes the volume contents, then removes the older disk(s). Dynamic mirror plexes can only be added at the mapped or striped level. Automagic volume managers may transparently replicate extents at any time; those replicants remain transparent. Note that since all volumes are mapped, hardware volume managers may take advantage of hardware assists.   Directed dynamic plexing operations must be supported. By default, the last added plex is first removed. When adding a snapshot or migration plex, the added volume must be at least as large as the existing volume. If larger, any overage becomes unavailable for other use. In other words, to grow a volume onto a larger drive: add the larger drive as a plex remove older smaller plex extend the volume to occupy the new plex Dynamic mirror plexes must be of the same hierarchical level. For example, it is not possible to add a striped volume as a plex to a mirror volume. Diskpacks Software logical volume providers manage collections of logical disks in diskpacks. A logical disk may be a member of one and only one diskpack.  A system may have any number of diskpacks. Logical units in a diskpack may have arbitrary attributes of performance, media, interconnect protocol or other characteristic. Diskpacks impose scope on software volume configuration. The transitive closure for hardware providers is determined by physical factors; a hardware provider is free to configure automagic volumes on any disks contained within a RAID cabinet or behind associated hardware controller(s).  The software provider may automagically configure logical disks only on simple disks which are members of the same diskpack.  All volumes are created in a diskpack and are always fully contained within one and only one diskpack. Simple disks must be added to a diskpack prior to instructing the associated software provider to automagically configure a logical disk using them.  Disks managed by a hardware provider are not added to diskpacks. A given logical disk may be a member of only one diskpack and the diskpack is passed to the hardware provider at configuration. A given hardware provider may manage volumes which are members of different diskpacks. Whether or not the underlying physical disks span diskpacks is a policy decision of the provider.   Any number of hardware providers may export logical disks to a single diskpack. For example, consider a volume constructed by concatenating a RAM disk with a volume constructed by software striping hardware parity stripe volumes. The diskpack includes disks from each hardware provider managing parity stripe volumes and the RAM disk.. Volumes may be exported from or imported to a diskpack. Volume import:export occurs by first moving the migrating volumes onto a platter and then migrating that platter between diskpacks. The platter must contain at least one volume and an integral number of simple disks and/or logical units. By default, an export causes any logical units to be isolated on physical disks by the associated hardware provider. In other words, export may ensure that a given disk does not span diskpacks. The exported volume(s) must be transitively closed on the platter at migration. Volume export may cause volume extent migration.   If the platter does not contain extents contributing to other (non-exporting) volumes, If the platter is the smallest number of disks and/or logical units that could contain the volume(s) and contains no extents contributing to other volumes, the platter is ready for migration. The exporting volumes are transitively closed on the smallest platter. An example is exporting a two-disk mirror volume in which each mirror occupies the entire drive.  Otherwise, it may be desirable to compact the platter prior to migration. Compacting the platter involves migrating volume extents to evacuate the volume from one or more disks.  For example, a mapped volume with volume extents on three different drives could be compacted onto a single drive prior to export.  If the platter contains extents contributing to other volumes,  A friendly export may cause the other volumes to be exported as well. Friendly export may cause the platter to be expanded: all volumes exported must be transitively closed. For example, exporting a simple volume occupying only half of a disk drive might cause the migration of another volume occupying the other half of that drive.  Otherwise, volume extents contributing to non-exporting volumes must be migrated from the platter.  Volume import to a pack adds all disks and/or logical units in the platter to the receiving pack. Loss of a disk from a platter during migration will cause the migration to fail unless manually overridden. This is an exception of the loose transitive closure behavior of packs, but protects against silent loss of data contained on any lost volumes. Diskpack membership does not encompass any concept of majority or quorum. Diskpack membership is discovered, rather than imposed. Consider a diskpack containing three logical volumes contained on five disks. Inability to access any disk may cause loss of all volumes or no volumes. There is no requirement that at least two volumes or at least three disks be present at any time. The only requirement is that volumes must be transitively closed to used by the system. See   REF _Ref427484252 \n \h  2.1.8  for more discussion of logical volume management in Wolfpack clusters.  The logical volume allocation extent size is common across a diskpack. Import of a platter may cause reconfiguration of the volumes contained on that platter if the exporting pack used a different extent size. See issues. Simple disk drives not contained within a pack are free agent drives. Free agents can be used to provide a pool of resources which can be dynamically allocated to packs. An example is managing a pool of hot spare drives rather than allocating a hot spare per pack. Prior to configuration in a volume or hot spare, free agent disks must be added to a pack. Like disk pack membership, free agent resource management is the responsibility of storage management applications.  Automagic hardware providers do not have free agent drives. Such a provider manages a pool of storage. Disks may be reserved for use as hot spares. Any other disk may be used at any time at the discretion of the provider.   An exported platter retains association with the exporting pack until imported into the importing pack. Disks on a platter are never free agents or hot spares.  Logical volume management and Wolfpack  Logical volume topology queries in a cluster return those volumes owned by the local node and free agent drives owned by that node. To build up a complete picture of the storage attached to a cluster, the query must be executed on each node within the cluster.  Note that all storage resources should be owned by a cluster node; unowned resources are unknown to the cluster and not eligible for use by cluster nodes. Diskpacks, not disks or volumes, are the unit of logical volume failover between Wolfpack nodes. This ensures that volumes remain transitively closed while permitting automagic volume management. Wolfpack implements a shared nothing model; each disk is owned by one and only one cluster node. SCSI RESERVE/RELEASE or, when available, Persistent Reservations are used to enforce this model. This prevents an automagic software volume manager from violating the shared nothing rule. Hardware volume managers may circumvent this. Each logical volume exposed by a hardware RAID controller appears to NT as a single disk (SCSI lun) and is owned by one node. Note, however, that nothing prevents the controller from arbitrary sharing of physical drives between logical volumes Logical volume managers expose mapped volumes to the NT MountManager upon discovery. The volume remains offline (unavailable to application software) until the MountManager requests that the volume be brought online. A software volume provider must not change volume health or configuration stability prior to bringing the volume online. In particular, software providers must not initiate volume rebuilds. The MountManager makes the online request automatically in non-clustered systems; all volumes are brought online as soon as exposed. In clustered systems, the volume must be of interest to this node and sufficiently complete. Wolfpack exports a list of  interesting onlineable  volumes to the MountManager. Resource groups are used to determine the ownership node for each diskpack; only the owner node indicates interest. That interest is pre-qualifying by ensuring that application IO can proceed without data corruption. For spanned and striped volumes, all volume segments must be present. For mirrors and parity stripe volumes, the volume may be compromised. Software volume providers may use the cluster quorum data to provide a higher level of logical volume configuration sanity and robustness. For example, a software provider would use the cluster quorum data to detect that the only existing mirror is stale. This configuration check is done in response to the MountManager request to bring the volume online. If the volume is not sane, the provider declines the request to bring the volume online. Wolfpack replicates the cluster quorum data on the cluster quorum devices. Quorum data must reside on a volume containing one and only one volume extent. The mapping between that extent and the physical disk address must remain constant. Thus, software logical volume providers must not automagically migrate the volume at any time and must report all hot-sparing or other disk replacement of quorum devices. Hardware logical volume providers may manage the extent automagically as long as the exposed controller interconnect address (SCSI lun) and logical block offset remain constant. This requirement is intended to protect Wolfpack against stale quorum data obtained via logical volume manager use of a stale mirror when there is one and only one cluster quorum data volume.  Each Wolfpack node has a private system device containing sufficient information to allow the node to safely join or form a cluster. That device may be managed by a logical volume manager and may be of any volume type. The system device is the only device other than the quorum devices accessed by a Wolfpack node prior to joining or forming a cluster.  All quorum volumes must be within the same diskpack. At any time, only one Wolfpack node owns all quorum devices. This simplifies quorum data updates   only one node actually performs the data writes. The node private system device(s) should be in a node-specific diskpack; the ownership node of these devices is fixed.  NetDevice is transparent to logical volume management providers. NetDevice is used to create a disk interconnect which is logically shared   IDE disks which are private to a given cluster node may be owned and solely accessed by another. From the point of view of logical volume management, NetDevice disks are simply disks.  The known correct quorum configuration data can be accessed any time after a Wolfpack node joins or forms a cluster. For each software-managed logical volume, this data includes the triplet:  Cluster system ID   unique identifier of the cluster (assigned by Wolfpack) Logical volume ID   unique identifier of the volume (assigned by NT at volume creation) Logical volume configuration epoch   unique identifier of the last generational change to the volume (managed by logical volume provider) Software logical volume providers must maintain a configuration epoch.  Each completed volume configuration change causes that epoch to be incremented. Each change in epoch must be reported to the Wolfpack cluster services which then propagate that change to the quorum data. The quorum data must be used as a validity-check or tiebreaker on all subsequent logical volume discoveries. As stated earlier, software providers are expected to maintain volume configuration data on the managed disk drives. That configuration data is the province of the provider; only the correctness thereof is of concern to Wolfpack. Software volume providers may implement an internal quorum algorithm, but that algorithm must be subject to Wolfpack override.  Note the reporting of completed volume configuration changes extends to the local system device. Wolfpack will check the trustworthiness of the system boot cluster data as part of cluster formation. If the node has booted off a different or incorrect system boot device, only manual intervention will allow the node to join or form a cluster.  Hardware logical volume providers need not report configuration changes or maintain a configuration epoch.  Hardware providers are assumed to take advantage of specialized hardware such as battery backed up RAM or dual controller voting. Hardware providers must only persist the volume ID for all configured volumes.  Provider Interface As discussed, the Logical Volume Management API presents two different interfaces:  the Provider Interface used by logical volume managers  the Client Interface used by logical volume management applications The objects presented by the client interface are richer and the Common LVM Layer implements additional methods to filter queries or direct actions; the intent is to simplify the client. The objects presented by the provider interface are aggregated; the intent is to simplify the implementation of the provider and pull as much common data structure manipulation code into the Common LVM Layer.   The interface methods can also be subset into three:  Configuration operations guiding logical volume creation, deletion, modification, and migration between systems.  Topology and state queries to allow discovery of the current configuration (including the physical disks which comprise a given volume and the type of volume) and volume status (such as recovering after disk failure). Topology queries allow determination of what an automagic provider actually did or is doing with the underlying physical resources. All queries apply to the local processor node resources only. To build a cluster-wide view, queries must be executed on each node in turn.  Maintenance and monitoring operations for fault management, performance monitoring, and common site maintenance (such as causing lights to blink on a given controller).  The order reflects the degree to which work has progressed. In true software design tradition, the last is currently fuzzy at best and remains as work. The Provider Logical Volume Management API exposes only one object: the ILVMSpecificProvider. A provider exists for each hardware RAID cabinet and for each software volume manager present on a system.  The LVM API is a COM API. In addition to the methods described herein, the API also includes those necessary to present a COM interface.  Any returned arrays are allocated by the provider or common layer using CoMemTaskAlloc and freed by the client. Logical volumes, disks, diskpacks, and volume providers are identified by unique GUIDs. The Common LVM Layer initially allocates all GUIDs with the exception of those of providers or controllers. A TARGET may be either a volume or disk. typedef GUID  VOLUMEID; typedef GUID  PROVIDERID; typedef GUID  PACKID; typedef GUID  DISKID; typedef GUID  PLATTERID; typedef GUID  CONTROLLERID; Default, wildcard, and error (unknown) values are defined for volumes, providers, and packs. These are: #define ALL_VOLUMES        (101) #define ALL_PROVIDERS      (103) #define ALL_PACKS          (105) #define UNKNOWN_PROVIDER   (113) #define UNKNOWN_PACK       (115) #define UNKNOWN_PLATTER    (117) #define UNKNOWN_CONTROLLER (119) #define NO_PROVIDER        (123) #define NO_PACK            (125) #define NO_PLATTER         (127) #define DEFAULT_PACK      (1) #define DEFAULT_PROVIDER  (1)       #define SOFTWARE_PROVIDER (3)      #define HARDWARE_PROVIDER (5) Logical volume configuration operations operate on allocations and report volume or disk extents.  typedef struct _TARGET {    short       Type;            // target type     [switch_is(Type)] union VALUE {            [case(1)]   DISKID     Disk;            [case(2)]   VOLUMEID   Volume;     }; } TARGET, *PTARGET; typedef struct _ALLOCATION {    TARGET      Target;          // disk or volume    DWORDLONG   Length;          // length in bytes } ALLOCATION, *PALLOCATION; typedef struct _EXTENT {    TARGET      Target;          // disk or volume    DWORDLONG   Length;          // length in bytes    DWORDLONG   StartingOffset; // offset from base of volume } EXTENT, *PEXTENT; Provider Attributes QueryProviderControllerID HRESULT QueryProviderControllerID(                          OUT  PCONTROLLERID*   ControllerID                                                        ); Returns the controller ID associated with this provider. Software providers return NULL. QueryProviderID HRESULT QueryProviderID(                OUT  PPROVIDERID     Id                                      ); Returns the unique identifier of the provider.  QueryProviderName HRESULT QueryProviderName(                   OUT  PWSTR*     lpszName,                   OUT  PDWORD     Instance                                           ); Returns the provider name and instantiation. Since each controller has a unique provider, when multiple identical controllers are present, the providers will each have the same name, but different instances.   QueryProviderType HRESULT QueryProviderType(                                           ); Return indicates whether the provider is a software or hardware provider. .  Provider-Specific Extensions Logical volume providers may expose provider-specific configuration attributes and parameters. Applications using these provider-specific extensions are assumed to have knowledge of their meaning and interpretation of these.   Each attribute consists of a short name, longer descriptive (help) text, and a current value. Values are cast as 64-bit unsigned integers. Parameters add minimum, maximum, and default values for the current value.  These structures allow a generic GUI interface to accommodate arbitrary provider extensions. Note that the provider must default any and all such extensions sensibly; specifying extended attribute values must not be required for successful volume configuration. Each configuration operation includes an LVM_EXTENSIONS structure. This structure includes a count and array of LVM_VALUE extensions. The order of the values within the array is the same as that used by the LVM_ATTRIBUTE or LVM_PARAMETER array used by the provider for the specified VOLUME_TYPE.   The LVM configuration methods pass all extension structures unchanged and unchecked to the provider.  typedef ULONGLONG  LVM_VALUE; typedef PULONGLONG PLVM_VALUE; typedef struct LVM_ATTRIBUTE {     PWSTR     ShortName;     // Name      PWSTR     LongDescription;     // Help text description (long)     LVM_VALUE Value;               // Current value } LVM_ATTRIBUTE, *PLVM_ATTRIBUTE; typedef struct _LVM_PARAMETER {     LVM_ATTRIBUTE    Attribute;     LVM_VALUE        MinimumValue;     LVM_VALUE        MaximumValue;     LVM_VALUE        DefaultValue; } LVM_PARAMETER, *PLVM_PARAMETER; #define ALL_ATTRIBUTES ("ALL_ATTRIBUTES")  // Wild card for defaulting QueryDefaults HRESULT QueryDefaults(              IN      VOLUME_TYPE      VolumeType,              OUT     PLVM_VALUE*      ExtensionArray,              OUT     PDWORD           NumberOfExtensions              );  Returns the array of LVM_VALUE vendor-specific binding extended parameter values. The values returned are the current default values for the specified volume type QueryParameters HRESULT QueryParameters(                 IN      VOLUME_TYPE      VolumeType,                 OUT     PLVM_PARAMETER*  ExtendedParameterArray,                 OUT     PDWORD           NumberOfExtendedParameters                 );  Returns vendor-specific parameter array. Intended for use by a vendor-neutral GUI.  The returned current and default values for each parameter are identical. Asynchronous operations Logical volume configuration and query operations may take considerable time. As such, all methods may be invoked asynchronously. Application completion handling follows the COM model.  The application provides a callback routine and parameter. That callback routine is implemented as an instance of a ILVMComplete class which implements a single callback method. PCALLBACK is a pointer to an instance of this callback object. A NULL PCALLBACK will invokes the method synchronously. All callbacks passed to a provider belong to the common layer. The common layer always intercepts all provider callbacks and marshalls or aggregates them to the client application.  CancelOperation HRESULT CancelOperation(                 IN  PVOLUMEID Volume                 ); CancelOperation cancels any previously pended asynchronous volume configuration operation or configuration query.  CompleteOperation HRESULT CompleteOperation(                  IN  PVOLUMEID Volume                  );                           CompleteOperation waits for the completion of a previously pended asynchronous volume configuration operation or configuration query. Logical Volume Types and Attributes Logical volume types are abstracted. While there are academic definitions for each RAID level, no two implementations are guaranteed to be the same.  The first three types are used for automagic configuration requests only; the remaining types are returned when the results of such a configuration are queried. Thus, an automagic provider may configure a  mirror  volume in response to a binding request for a  fault tolerant  volume. typedef enum _VOLUME_TYPE {     Default,     FaultTolerant,     NotFaultTolerant,     Simple,     Span,     Stripe,                         Mirror,     Parity,      Plex } VOLUME_TYPE, *PVOLUME_TYPE; The current condition of a logical volume and parameters affecting dynamic configuration of that volume are described by volume attributes including::  Access by NT (VOLUME_STATUS) Fault recovery status  (VOLUME_HEALTH) Configuration stability (VOLUME_JELLO) Disk pack membership (VOLUME_PACK) Whether or not the volume is plexed  Whether or not the volume logical mapping is fixed or dynamic Relative rebuild priority (high-low)  typedef struct _VOLUME_ATTRIBUTES {     VOLUME_STATUS   Status;     VOLUME_HEALTH   Health;     VOLUME_JELLO    Jello;     VOLUME_PACK     Pack;     BOOL            Plexed;     BOOL            LbnRemapEnabled;     BOOL            Automagic;     DWORDLONG       ExtentSize;     DWORD           RebuildPriority; } VOLUME_ATTRIBUTES, *PVOLUME_ATTRIBUTES; typedef enum _VOLUME_STATUS {     AnyStatus,     UnknownStatus, // May not be present     Unused,        // Present, but not in use     HotSpare,      // Present, and reserved for hot sparing     InUse,         // Present, and stacked      Mapped         // Present, exposed to NT   } VOLUME_STATUS, *PVOLUME_STATUS; typedef enum _VOLUME_HEALTH {     AllHealth,     UnknownHealth,               Initializing,     Healthy,     Unhealthy,     Compromised,     Rebuilding } VOLUME_HEALTH, *PVOLUME_HEALTH; typedef enum _VOLUME_JELLO {     AllJello,     Stable,     Reconfiguring,     Plexing,     Extending,     Shrinking } VOLUME_JELLO, *PVOLUME_JELLO; typedef enum _VOLUME_PACK {     AllPack,     Normal,     Exporting,     Platter,     ExportedPlatter,     Importing } VOLUME_PACK, *PVOLUME_PACK; As discussed in   REF _Ref441899070 \n \h  3.1.5 , providers may expose provider-specific extensions. When extended attributes are returned, the returned array is chosen to be appropriate to the stacking level of the volume. In other words, querying a mapped automagic volume will return only the mapped extensions.    Automagic Binding  Automagic providers are given hints as to the intended use of the new volume. The provider uses those hints in good faith. The common BIND_HINTS structure is: typedef struct _BIND_HINTS {     DWORD       Length;                      // structure size     BOOL        IsFaultTolerant;     BOOL        FastCrashRecoveryRequired;     BOOL        IsYankable;                  // No migration prior to media removal     BOOL        OptimizeForSequentialReads;     BOOL        OptimizeForSequentialWrites;     BOOL        IsMostlyReads;     BOOL        MigrationOk;     DWORDLONG   ExpectedMaximumSize;     DWORD       OptimalReadSize;             // 0 indicate no optimal size     PDWORD      OptimalReadAlignment;         DWORD       OptimalWriteSize;            // 0 indicate no optimal size     PDWORD      OptimalWriteAlignment;          DWORD       MaximumNumberOfSpindles;     // 0 indicates no maximum     DWORD       InterleaveSize;                  DWORD       RebuildPriority;  } BIND_HINTS, *PBIND_HINTS; #define LOWEST_REBUILD_PRIORITY     (0) #define NORMAL_REBUILD_PRIORITY     (8) #define HIGHEST_REBUILD_PRIORITY    (16) Field Interpretation Length Structure size in bytes IsFaultTolerant Use fault tolerant, mirror or parity stripe, volume  FastCrashRecoveryRequired Bound the time required for volume recovery; support for fast recovery involves use of some sort of change log enabling the provider to recover the volume without comparing the entire contents. IsYankable Volume can be physically removed with minimal system disruption; occupy minimal number of spindles or removable media. OptimizeForSequentialReads Optimize for sequential read or sequential write pattern. If both are false, optimize for random IO. OptimizeForSequentialWrites IsMostlyReads Optimize for read mostly pattern, for example by use of mirroring rather than parity striping.  MigrationOk Volume extents can migrate automagically. If false, mapping of volume extents to disk extents to remain fixed after configuration with the exception of proactive actions avoiding disk failures. ExpectedMaximumSize Maximum size to which the volume is likely to grow. May be greater or less than VolumeSize.  OptimalReadSize Optimal IO size (in bytes) and alignment with respect to the first logical block of the volume.  OptimalReadAlignment OptimalWriteSize OptimalWriteAlignment MaximumNumberOfSpindles Maximum number of disk spindles contributing to the volume. May be used to limit the number of stripe chunks in a stripe set.  InterleaveSize Mirror or parity stripe chunk size. Number of contiguous logical blocks per disk extent prior to changing disk extents. RebuildPriority Relative priority (low:high) for rebuild. Low causes less system impact, but extents the period of exposure.  BindVolume HRESULT BindVolume(           IN  PVOLUMEID             Volume,           IN  PPACKID               Pack,           IN  DWORDLONG             VolumeSize,            IN  VOLUME_TYPE           VolumeType,           IN  PBIND_HINTS           BindHints,           IN  PLVM_VALUE            BindExtensions,           IN  PCALLBACK             Callback,                           ); BindVolume creates and initially configures an automagic volume. The only required parameter is VolumeSize; all others may be defaulted. The provider uses the BindHints and BindExtensions in good faith; these parameters are hints not requirements. BindExtensions are passed without check or change to the provider.   UnbindVolume HRESULT UnBindVolume(             IN   PVOLUMEID          Volume,             IN   PCALLBACK          Callback             ); Deletes and deconfigures the volume. All data are lost. All disk extents which contributed to the volume are freed for immediate reuse by the volume provider.  The Common LVM Layer performs any coordination with NT prior to passing this request to the volume provider.  ResizeBindVolume HRESULT ResizeBindVolume(                 IN   PVOLUMEID      Volume,                   IN   DWORDLONG      NewVolumeSize,                  IN   PCALLBACK      Callback                                        ); An automagic volume can be grown or shrunk using this call. When growing a volume, the new volume must be at least as large as the specified new volume size. When shrinking a volume, the volume must be no smaller than the specified new volume size.  The Common LVM Layer uses this method to implement ILVMProvider :: ExtendVolume and ILVMProvider :: ShrinkVolume. For example, to extend a stripe set, the Common LVM Layer extends each of the contributing volumes.   While implementation of this method is optional, providers are recommended to support online volume growth. No data is lost as a side effect of this call. Prior to shrinking a volume, Common LVM Layer must invoke the NT callback ResizeFileSystem. If the file system is unable to contract freeing the space, the Common LVM Layer aborts the resizing operation and never invokes this method.  Volume Stacking Only software providers implement MapVolume and UnmapVolume.  StripeVolume HRESULT StripeVolume(             IN   PVOLUMEID          Volume,             IN   PALLOCATION        AllocationArray,             IN   DWORD              NumberOfAllocations,             IN   LVM_VALUE          InterleaveSize,                 IN   PLVM_VALUE         StripeExtensions,             IN   PCALLBACK          Callback             ); Creates and configures a striped logical volume using extents from the specified logical volumes or disks. Stripe sets are constructed from equal length extents; equal size extents from each target (volume or disk) in the allocation array are consumed.  The number of elements of that array determines the number of stripes in the volume. The stripe chunk is determined by InterleaveSize; the chunk may be defaulted by specifying DEFAULT_INTERLEAVE (0).   The Common LVM Layer checks the AllocationArray for duplicate targets prior to invoking the provider. It is not possible to construct a stripe set using one and only one disk by specifying the disk twice.  UnstripeVolume     HRESULT     UnstripeVolume(               IN   PVOLUMEID        Volume,                 IN   PCALLBACK        Callback               ); Deletes and deconfigures the stripe set volume.  All data are lost. All volume or disk extents which contributed to the volume are freed for immediate reuse by the stacking volume provider. The Common LVM Layer performs any coordination with NT prior to passing this request to the volume provider. MapVolume HRESULT MapVolume(          IN   PVOLUMEID             Volume,          OUT  PLVM_VALUE            DiskNumber,          IN   PALLOCATION           AllocationArray,          IN   DWORD                 NumberOfAllocations,          IN   PLVM_VALUE            MapExtensions,          IN   PCALLBACK             Callback          ); Configures a mapped volume. Volume extents are allocated in the order specified by the allocation array and concatenated. The resulting mapped volume is exposed to NT and an NT disk number is assigned. Implemented only by software volume providers.     UnmapVolume HRESULT UnMapVolume(            IN   PVOLUMEID           Volume,              IN   PCALLBACK           Callback            ); Deletes and deconfigures the mapped volume. This also removes the volume from NT use and the associated NT disk number is deleted. The Common LVM Layer performs any coordination with NT prior to passing this request to the volume provider. Implemented only by software volume providers. Volume Plexing AddPlex HRESULT AddPlex(        IN     PVOLUMEID             Volume,        IN     PVOLUMEID             PlexVolume,           IN     PLVM_VALUE            PlexExtensions,        OUT    PDWORD                AddedPlexId,        IN     PCALLBACK             Callback        ); Adds a plex to the specified volume. The completion routine is invoked after the added plex has been synchronized with the original volume. The Common LVM layer verifies that the PlexVolume is large enough prior to invoking the provider.  RemovePlex HRESULT RemovePlex(           IN     PVOLUMEID          Volume,           IN     DWORD              PlexId,           OUT    PPVOLUMEID         RemovedVolume,           OUT    PDWORD             RemovedPlexId,           IN     BOOL               SyncFlag,           IN     PCALLBACK          Callback           ); Removes a previously added plex from the specified volume. The Common LVM Layer optionally synchronizes the file system prior to causing the plex to be broken by the provider.  After removal, the plex is no longer held in synchronization with the original volume.  Diskpack and Platter Management Both hardware and software providers may participate in diskpack management. Software providers must implement some notion of diskpack either using the Wolfpack model as explained in   REF _Ref441648413 \n \h  2.1.8  or otherwise. Hardware providers are recommended to simple diskpack support. Such allows management of volume mapping within a RAID cabinet; for example, if the cabinet is shared between systems, it may be desirable to isolate the physical disks accessed by the two systems.  The options for software and hardware providers are summarized in the table below. Basic diskpack support is required for all software providers and optional to hardware providers. Advanced support and migration support are optional to both. All methods of a support level must be implemented.  Method Software Provider Hardware Provider CreatePack Required Basic support DeletePack Required Basic support AddDisksToPack Required EvacuateDisks Advanced support Advanced support FreeDisksFromPack Required ReplaceDisk Required Required InhabitDisks Advanced support Advanced support ImportPlatter Migration support Migration support ExportPlatter Migration support Migration support MigratePlatter Migration support Migration support MoveVolumesToPlatter Migration support Migration support MoveVolumesFromPlatter Migration support Migration support ForgetPlatter Migration support Migration support Create Pack HRESULT CreatePack(            IN  PPACKID    Pack,             IN  DWORDLONG  ExtentSize,            IN  PWSTR      lpszName,            IN  DWORD      cchBufferLength            ); Creates a diskpack. The extent size must be a power of two disk sectors. If the extent size is not specified, the Common LVM Layer will use 1% of the largest disk drive known to be in the configuration.  For example, the extent size would default to 128MB for configurations with 18GB drives. DeletePack HRESULT DeletePack(            IN  PPACKID    Pack,            IN  BOOL       ForceFlag            ); Deletes a diskpack. If ForceFlag is specified as FALSE, the operation will fail if the pack still contains any logical volumes. Specifing ForceFlag as TRUE overrides this and causes to any logical volumes remaining in the pack to be lost.  AddDisksToPack HRESULT AddDisksToPack(               IN PPACKID   Pack,               IN PDISKID   DiskArray,               IN DWORD     ArraySize,               IN BOOL      SpareFlag               ); Adds disks to a pack. Any logical volume originally on the added disks is lost and not imported to the pack. Specifying SpareFlag as TRUE reserves the added disks as hotspares and does not allow them to be immediately inhabitable for automagic dynamic reconfiguration. To swap a free disk with a disk in a pack, use ReplaceDisk. Only simple disks managed by a software provider are added to a pack; logical units exported by a hardware provider are implicitly added to the pack by automagic binding. EvacuateDisks HRESULT EvacuateDisks(               IN  PPACKID   Pack,                 IN  PDISKID   DiskArray,               IN  DWORD     ArraySize,               IN  PCALLBACK Callback              ); This routine moves any volume extents from the disk array to other disks in the diskpack.  Note that to be eligible for removal, any volumes occupying a disk must have been evacuated. In other words, the disk must contain no live data.  The disks remain evacuated until explicitly declared ready for inhabit, freeing from the pack, removal, or hot spare. This method may be used to inhabit simple disks or disks managed by a hardware provider; in the latter case, the PACKID is only advisory.  FreeDisksFromPack HRESULT FreeDisksFromPack(               IN     PPACKID   Pack,               IN     PDISKID   DiskArray,               IN     DWORD     ArraySize,               OUT    PDISKID*  RemovedDiskArray,               OUT    PDWORD    NumberOfRemovedDisks                             ); Removes disks from pack and makes them free agents. Note that to be eligible for removal, any volumes occupying a disk must have been evacuated. In other words, the disk must contain no live data.  Only those disks evacuated will be returned in the RemovedDiskArray. Only simple disks managed by a software provider are added to or freed from a pack; logical units exported by a hardware provider are implicitly added to the pack by automagic binding.  ReplaceDisk HRESULT ReplaceDisk(            IN  PDISKID         DiskToReplace,            IN  PDISKID         NewDisk,            IN  BOOL            StrictFlag,            IN  BOOL            WaitFlag,            IN  PCALLBACK       Callback            ); Substitutes one physical disk for another to allow media migration. Any contents of the replaced disk are migrated, although not necessarily to the new disk. Specifying StrictFlag to be TRUE causes strict replacement; all contents of the replaced disk are migrated to the new disk. If StrictFlag is true and the new disk is not large enough to hold the contents of the replaced disk, the operation will fail. At completion, the replaced disk is no longer in use and may be physically removed. InhabitDisks HRESULT InhabitDisks(              IN  PDISKID   DiskArray,             IN  DWORD     ArraySize         ); Declares the disks available for automagic volume migration or other volume configuration operation. Note that InhabitDisks does not guarantee that the affected disks return to active use or again contain any previously configured logical volume. This method may be used to inhabit simple disks or disks managed by a hardware provider. Create Platter HRESULT CreatePlatter(               IN  PPACKID     Pack,               IN  PPLATTERID  Platter               ); Creates a platter within the specified pack.  ImportPlatter HRESULT ImportPlatter(               IN  PPACKID    Pack,              IN  PPLATTERID Platter,              IN  BOOL       OverrideMissingDisks,              IN  PCALLBACK  Callback              ); Imports all volumes and adds all disks contained on the platter to the pack. This operation may fail or cause reconfiguration of the existing volumes if the volume allocation extent of the platter differs from that of the receiving platter.   If one or more disks have been lost in the movement, volumes contained on the platter may not be transitively closed. Specifying OverrideMissingDisks will import any transitively closed volumes and add all disks. This may cause silent loss of volumes and/or data and should only be done with after careful consideration.  Successful import of a platter also causes deletion of that platter. The imported volumes join all other volumes in the pack.  ExportPlatter HRESULT ExportPlatter(               IN  PPLATTERID  Platter,               IN  PCALLBACK   Callback               ); Marks all disks on the platter ready for export. As a side effect, the disks contained in the platter are recorded such that when the platter is subsequently imported, the receiving pack can determine if all disks are present.  MigratePlatter HRESULT MigratePlatter(               IN  PPLATTERID  Platter,               IN  PPACKID     NewPack,                   IN  PCALLBACK   Callback               ); Atomically moves the platter between packs. Both packs must be present on the same processor node in a cluster.  MoveVolumesOntoPlatter HRESULT MoveVolumesOntoPlatter(                        IN  PPLATTERID  Platter,                        IN  PVOLUMEID   ArrayOfVolumes,                        IN  DWORD       ArrayOfVolumesSize,                        IN  PDISKID     ArrayOfDisks,                        IN  DWORD       ArrayOfDisksSize,                        IN  BOOL        CompactFlag,                        IN  BOOL        FriendlyFlag,                        IN  PCALLBACK   Callback                        );  Prepares a platter for migration by moving one or more volumes to one or more disks. Specifying a disk array is optional; automagic volume managers may select disks for migration. Moving volumes to a platter may cause volume extent migration.  The FriendlyFlag controls whether or not additional volumes may by added to the platter as explained in   REF _Ref427665645 \r \h  2.1.7 . The CompactFlag controls whether or not volume extents are compacted onto disk drives prior to migration.  Logical volume providers compact volumes in good faith   the number of drives is not guaranteed to be the absolute minimal. A hardware provider should ensure that all volumes on the platter are isolated from volumes which belong to a different diskpack when the CompactFlag is set.   Once completed, all affected logical volume providers may do no other automagic migration of volumes to or from the platter. No change in volume type is permitted.  MoveVolumesOffPlatter HRESULT MoveVolumesOffPlatter(                       IN  PPLATTERID  Platter,                       IN  PVOLUMEID   ArrayOfVolumes,                       IN  DWORD       ArrayOfVolumesSize,                       IN  PDISKID     ArrayOfDisks,                       IN  DWORD       ArrayOfDisksSize,                       IN  PCALLBACK   Callback                       );  Explicitly moves volumes or evacuates disks and frees them from a platter. This routine is intended for use only for minor corrections to a friendly export which inadvertently includes a volume or disk.  The FriendlyFlag controls whether or not additional volumes may by added to the platter as explained in   REF _Ref427665645 \r \h  2.1.7 . The CompactFlag controls whether or not volume extents are compacted onto disk drives prior to migration.  Logical volume providers compact volumes in good faith but the number of drives is not guaranteed to be the absolute minimal. A hardware provider should ensure that all volumes on the platter are isolated from volumes which belong to a different diskpack when the CompactFlag is set. Once completed, all affected logical volume providers may do no other automagic migration of volumes to or from the platter. Removing a volume from platter causes that volume to rejoin the diskpack and may result in automagic reconfiguration of the volume if otherwise permitted. ForgetPlatter HRESULT ForgetPlatter(           IN PPLATTERID  Platter    ); Cancels preparation of a platter for volume migration. Any volumes on the platter rejoin the disk pack and may migrate freely. Logical Volume Topology Queries These queries allow a storage management application to determine logical volume configuration. This allows determination of what an automagic provider actually did or is doing with the underlying physical resources. All queries apply to the local processor node resources only. To build a cluster-wide view, queries must be executed on each node in turn.  QueryDisks  HRESULT QueryDisks(           OUT   PDISKID*    ArrayOfDisks,           OUT   PDWORD      NumberOfDisks           ); Return all disks managed by the provider.  QueryVolumes HRESULT QueryVolumes(             OUT  PVOLUMEID*  ArrayOfVolumes,             OUT  PDWORD      NumberOfVolumes             ); Return all volumes known to the provider. Ignores any stacking hierarchy.  QueryVolumeDeviceObject HRESULT QueryVolumeDeviceObject(                        IN  PVOLUMEID  Volume,                        OUT PWSTR*     lpszName,                        OUT PDWORD     cchBufferLength                        ); Returns the NT device object name associated with a hardware RAID volume. The disk IO subsystem treats these volumes as physical disks. The information returned gives that mapping.  Implemented by hardware providers only.  QueryVolumeDiskExtents  HRESULT QueryVolumeDiskExtents(                       IN      PVOLUMEID      Volume,                       IN      BOOL           IncludePlex,                       OUT     PVOLUME_TYPE   Type,                         OUT     PEXTENT*       ArrayOfExtents,                       OUT     PDWORD         NumberOfExtents                       ); Returns all disk extents contributing to the volume. The Common LVM Layer recursively queries the provider at each stacking layer to build the simple physical view of the resources consumed by the volume. Setting IncludePlex to TRUE optionally includes existing plexes. QueryVolumeDiskNumber  HRESULT QueryVolumeDiskNumber(                      IN  PVOLUMEID  Volume,                      OUT PDWORD     DiskNumber,                      OUT PBOOL      VolumeIsMapped                      ); Returns the NT disk number (if any) associated with this volume. If the volume is a mapped volume, the disk number was created at volume configuration. If the volume is not a mapped volume, but the volume contributes extents to a mapped volume, the NT disk number is that of the mapped volume. If the volume is not mapped, there is no NT disk number. Implemented by software providers only. QueryVolumeExtents HRESULT QueryVolumeExtents(                   IN   PVOLUMEID      Volume,                   OUT  PVOLUME_TYPE   Type,                     OUT  PEXTENT*       ArrayOfExtents,                   OUT  PDWORD         NumberOfExtents                   ); Returns all volumes contributing one or more extents to this volume. Only one level of the stacking hierarchy is traversed. The Common LVM Layer recursively queries the provider at each stacking level to build up a complete view. QueryVolumeLUN HRESULT QueryVolumeLUN(                IN   PVOLUMEID      Volume,                OUT  PDWORD         Lun                 ); Returns the LUNS (logical unit) associated with this volume, if any. The Lun is returned as  1 if the volume does not correspond to a logical unit. QueryVolumePlexes HRESULT QueryVolumePlexes(                  IN  PVOLUMEID   Volume,                  OUT PVOLUMEID*  VolumeArray,                   OUT PDWORD      NumberOfPlexes                  ); Finds all plexes of the specified volume. The returned volume array contains plexes in plexId order.   QueryVolumeProvider HRESULT QueryVolumeProvider(                    IN  PVOLUMEID   Volume                    ); Indicates that this provider manages the specified volume.  DiskPack and Platter Queries  Diskpack and platter queries are implemented by those providers implementing diskpacks.  QueryPacks HRESULT QueryPacks(           OUT  PPACKID*   PackArray,            OUT  PDWORD     NumberOfPacks           ); Returns all disk packs managed by the provider. QueryPlatters HRESULT QueryPlatters(              IN   PPACKID      Pack,              OUT  PPLATTERID*  PlatterArray,               OUT  PDWORD       NumberOfPlatters              ); Returns all disk platters in the specified  pack. QueryVolumePack HRESULT QueryVolumePack(                   IN   PVOLUMEID    Volume,                   OUT  PPACKID      Pack,                   OUT  PPLATTERID   Platter                   ); Returns the pack and platter (if any) which contains the volume. If the volume is not on a platter, the platter is returned as NO_PLATTER.  QueryDiskPack HRESULT QueryDiskPack(               IN  PDISKID     Disk,               OUT PPACKID     Pack,               OUT PPLATTERID  Platter               ); Returns the pack and platter (if any) which contains the disk. If the disk is not on a platter, the platter is returned as NO_PLATTER.  QueryPackProvider HRESULT QueryPackProvider(                   IN  PPACKID    Pack                   ); Indicates that this provider manages the specified pack. Logical Volume Attributes  The Common LVM Layer caches the volumes managed by a given provider and invokes the correct provider for all volume queries.  Hardware providers which do not implement diskpacks ignore any PACKID parameters.  QueryVolumeAttributes  HRESULT  QueryVolumeAttributes(                      IN    PVOLUMEID             Volume,                      OUT   PVOLUME_TYPE          VolumeType,                      OUT   PVOLUME_ATTRIBUTES    VolumeAttributes,                      OUT   PLVM_VALUES*          BindValueArray,                      OUT   PDWORD                NumberOfBindValue                      ); Returns volume type, pack, size, and attributes.  QueryVolumeSize HRESULT QueryVolumeSize(                IN  PVOLUMEID    Volume,                OUT PDWORDLONG   VolumeSize                ); Returns volume size. QueryVolumeType HRESULT QueryVolumeType(                IN  PVOLUMEID      Volume,                OUT PVOLUME_TYPE   Type                ); Returns volume type. See   REF _Ref428791617 \n \h   for the definition of VOLUME_TYPE; Default, FaultTolerant, NotFaultTolerant are not returned as a result of this query. QueryVolumeState HRESULT QueryVolumeState(                  IN  PVOLUMEID      Volume,                  OUT PVOLUME_STATUS Status,                  OUT PVOLUME_HEALTH Health,                  OUT PVOLUME_JELLO  Jello                  ); Returns volume status, health, and jello. Only software providers indicate Mapped status.  QueryVolumeLbnRemap HRESULT QueryVolumeLbnRemap(                    IN  PVOLUMEID Volume,                    OUT PBOOL     Enable                    ); Returns whether or not the volume may currently be dynamically reconfigured. If LBN (logical block number) remapping is enabled, the provider may migrate volume extents at will. Note that the returned enable applies only to the specified volume; if the volume is stacked, the constituent volumes may be differently enabled. QueryVolumeRebuildPriority HRESULT QueryVolumeRebuildPriority(                           IN  PVOLUMEID  Volume,                           OUT PBOOL      Enable                            ); Returns the rebuild priority of the volume.  ForceVolumeHealthy HRESULT ForceVolumeHeathy(                  IN  PVOLUMEID    Volume                  ); Forces volume to be healthy. Allows possibly dangerous override in the event of catastrophic disk failures.  ForceVolumeInitialize HRESULT ForceVolumeInitialize(                      IN  PVOLUMEID  Volume                      ); Forces volume to be reinitialized. All data may be lost. Allows possibly dangerous override in the event of catastrophic disk failures.  ForceVolumeRebuild HRESULT ForceVolumeRebuild(                   IN  PVOLUMEID  Volume                   ); Forces volume to be rebuilt. Allows possibly dangerous override in the event of catastrophic disk failures.  SetVolumeLbnRemap HRESULT SetVolumeLbnRemap(                  IN  PVOLUMEID  Volume,                  IN  BOOL       Enable                  ); Enables or disables automagic remapping by the logical volume provider. Disabling LBN remapping  freezes the current logical to physical topology of the volume. SetVolumeRebuildPriority HRESULT SetVolumeRebuildPriority(                         IN  PVOLUMEID  Volume,                         IN  DWORD     Priority                         ); Sets the relative rebuild priority for the volume.   SetVolumeExtensions HRESULT  SetVolumeExtensions(                    IN  PVOLUMEID          Volume,                    IN  BOOL               Override,                    IN  PLVM_VALUE         BindExtensionArray                    ); Sets provider-specific extended attributes for the volume. Disk Attributes QueryDiskSize HRESULT QueryDiskSize(              IN  DISKID       Disk,              OUT PDWORDLONG   DiskSize              ); Returns size in bytes of the specified disk. QueryDiskConnection HRESULT QueryDiskConnection(                    IN  DISKID              Disk,                    OUT PDISK_CONNECT_TYPE  ConnectionType                    ); Returns abstracted physical connection to disk. Connection types are given by: typedef enum _DISK_CONNECTION_TYPE {     UnknownConnection,     Local,                    // local connection only (eg IDE)     DualConnect,              // dual connected (eg SCSI)     NetworkConnect,           // multiply shared (eg FCAL)     DualControllerConnect,    // behind an dual intelligent controller     NetworkControllerConnect, // behind a multiply shared controller     Served                    // remote served (eg NetDevice) } DISK_CONNECT_TYPE, *PDISK_CONNECT_TYPE; QueryDiskDeviceObject HRESULT QueryDiskDeviceObject(                      IN  PDISKID    Disk,                      OUT PWSTR*     lpszName,                      OUT PDWORD     cchBufferLength                      ); Returns the NT device object name associated with the specified disk.  QueryDiskStatus HRESULT QueryDiskStatus(                IN  DISKID          Disk,                OUT PVOLUME_STATUS  Status                ); Returns current access by NT. Disk access is the same as volume access (VOLUME_STATUS). SetDiskHotSpare HRESULT SetDiskHotSpare(                IN  DISKID  Disk,                IN  BOOL    Enable                ); Declares disk to be used as a hot spare. If the disk current contributes to one or more logical volumes, this call will fail. The volumes must be first moved using ReplaceDisk (  REF _Ref428793082 \n \h  4.6.1 QueryDiskProvider HRESULT QueryDiskProvider(                  IN  PDISKID    Disk,                  OUT PBOOL      Mine                  ); Indicates that this provider manages the specified disk. Hardware Controllers and Physical Topology  This portion of the LVM API exports an abstract view of the physical topology and hardware resources of the storage subsystem. The intent is not to supplant WMI, WEBM, CIM, but rather present an interesting and abstracted subset of information managed by them. The LVM API says nothing about the internal implementation mechanism(s).  The current condition of a hardware controller and the volumes behind that controller parameters are described by attributes. Providers may extend these attributes similar to extended binding attributes.   Current controller in active use and path to that controller Battery backup support Physical topology behind controller (number of disks and disk paths) Controller capabilities such as logical block remapping, variable volume rebuild support Controller physical attributes such as cache size and firmware revision  typedef struct _CONTROLLER_ATTRIBUTES {     DWORD              ControllerNumber;     DWORD              ActivePath;     DWORD              TotalPaths;     DWORD              TotalControllers;     DWORD              BatteryBackupHours;     DWORD              TotalBatteryBackupHours;     DWORD              DiskPaths;     DWORD              DisksPerPath;     DWORD              MinimumRebuildPriority;     DWORD              MaximumRebuildPriority;     BOOL               LbnRemapCapable;     BOOL               LbnRemapEnabled;     DWORDLONG          TotalCacheBytes;     DWORDLONG          FirmwareVersion;     DWORDLONG          DiskExtentSize;    // if imposed } CONTROLLER_ATTRIBUTES, *PCONTROLLER_ATTRIBUTES; #define INVALID_DISK_NUMBER   (-1)  #define INVALID_PATH_NUMBER   (-1)  Controller methods are implemented only by hardware providers.  QueryControllerParameters HRESULT QueryControllerParameters(                          OUT    PLVM_PARAMETER*  ExtendedParameterArray,                          OUT    PDWORD           NumberOfExtendedParameters                          );  Returns vendor-specific parameter array. Intended for use by a vendor-neutral GUI. QueryControllerAttributes HRESULT QueryControllerAttributes(                          OUT    PBOOL                    Online,                          OUT    PVOLUME_HEALTH           ControllerHealth,                          OUT    PCONTROLLER_ATTRIBUTES   ControllerAttributes,                          OUT    PLVM_VALUE*              ControllerExtensionArray,                          OUT    PDWORD                   NumberOfControllerExtensions                          );                                             Returns controller type, associated provider, any packs to which the controller contributes disks, whether the controller is currently online, controller health and attributes. Controller health follows VOLUME_HEALTH. QueryControllerDeviceObject HRESULT QueryControllerDeviceObject(                            OUT PWSTR*     lpszName,                            OUT PDWORD     cchBufferLength                            ); Returns the NT device object name associated with the controller.  QueryControllerPath HRESULT QueryControllerPath(                    OUT    PDWORD         PrimaryPath,                    OUT    PDWORD         SecondaryPath,                    OUT    PDWORD         ActivePath                    ); Returns primary, secondary, and currently active paths for a dual pathed controller.  QueryControllerLbnRemap HRESULT QueryControllerLbnRemap(                        OUT    PBOOL          Capable,                        OUT    PBOOL          Enable                        ); Returns whether or not the controller is capable of dynamic volume reconfiguration and whether or not the controller is currently allowed to do so.  If LBN remapping is enabled, the provider may migrate volume extents at will.  ForceControllerHealthy HRESULT ForceControllerHeathy(                      ); Forces controller to be healthy. Allows possibly dangerous override in the event of catastrophic controller or disk failures. ForceControllerInitialize HRESULT ForceControllerInitialize(                          ); Forces controller to reinitialize. Must not affect current volumes configured behind the controller.  ForceControllerRebuild HRESULT ForceControllerRebuild(                       ); Forces all volumes configured behind the controller to be rebuilt. Allows possibly dangerous override in the event of catastrophic controller or disk failures.  ForceControllerPath HRESULT ForceControllerPath(                    IN DWORD        ActivePath                    ); Forces active controller path to specified path.  SetControllerExtensions HRESULT  SetControllerExtensions(                        IN BOOL               Override,                        IN PLVM_VALUE         ConrollerExtensionArray,                        IN DWORD              ControllerExtensionArraySize                        ); Sets provider-specific extended attributes for the controller.  QueryDiskExtensions HRESULT QueryDiskExtensions(                    IN   PDISKID          Disk,                    OUT  PLVM_VALUE*      DiskExtensionArray,                    OUT  PDWORD           NumberOfDiskExtensions                    );  Returns vendor-specific disk parameter array. QueryDiskParameters HRESULT QueryDiskParameters(                    IN   PDISKID           Disk,                    OUT  PLVM_PARAMETER*   ExtendedParameterArray,                    OUT  PDWORD            NumberOfExtendedParameters                    );  Returns the array of LVM_VALUE vendor-specific disk extended parameter values.  QueryDiskAttributes HRESULT QueryDiskAttributes(                    IN    PDISKID             Disk,                     OUT   PLVM_VALUE*         DiskExtensionArray,                    OUT   PDWORD              NumberOfDiskExtensions                    );  Returns associated provider, pack (if any), abstracted connection type, controller, size, status, and vendor-specific extensions for the specified disk.  QueryControllerDisks HRESULT QueryControllerDisks(                     OUT  PDISKID      ArrayOfDisks,                     OUT  PDWORD       NumberOfDisks                     ); Returns an array of disks attached to the specified controller. The array is exactly DiskPaths by DisksPerPath; where DiskPaths and DisksPerPath are controller attributes. If no disk is present at the location, the DISKID array entry is returned as INVALID_DISK. If the array is not sufficiently large, an error is returned and all array contents are suspect.  Simple Maintenance Operations Client interface does any and all CIM conversion. Need a better name for these to distinguish from the controller methods.  Simple maintenance operations are intended target identification or sanity checks. These methods allow simple access to a useful subset of site maintenance operations such as flashing a light on a disk drive.  typedef enum _MAINTENANCE_OPERATION {    NoOperation,    BlinkLight,    BeepAlarm,    SpinDown,         SpinUp,    Ping } MAINTENANCE_OPERATION, *PMAINTENANCE_OPERATION; These operations may be directed to a controller or disk. The Common LVM Layer translates client maintenance operations targeted to a volume to the appropriate disks. For simple disks not behind a hardware controller, the ILVMCommonSupport object also implements these methods.  Specifying nonsensical operations or operations unsupported by the target or logical volume provider will cause the operation to fail with no side effects. Only hardware providers implement the controller maintenance methods.   StartDiskMaintenance HRESULT  StartDiskMaintenance(                     IN   PDISKID               Disk,                     IN   MAINTENANCE_OPERATION Operation                     ); Initiate specified hardware maintenance operation. The operation will repeat until stopped. If the target is a logical volume, the  StopDiskMaintenance HRESULT  StopDiskMaintenance(                    IN   PDISKID               Disk,                    IN   MAINTENANCE_OPERATION Operation                    ); Stop or cancel specified hardware maintenance operation. This stops any repeated operations such as blinking a light.   PulseDiskMaintenance HRESULT  PulseDiskMaintenance(                     IN   PDISKID               Disk,                     IN   MAINTENANCE_OPERATION Operation,                     IN   DWORD                 Count                     ); Repeat specified hardware maintenance operation a specified number of times.  StartControllerMaintenance HRESULT  StartControllerMaintenance(                           IN   MAINTENANCE_OPERATION Operation                           ); Initiate specified hardware maintenance operation. The operation will repeat until stopped StopControllerMaintenance HRESULT  StopControllerMaintenance(                          IN   MAINTENANCE_OPERATION Operation                          ); Stop or cancel specified hardware maintenance operation. This stops any repeated operations such as blinking a light.   PulseControllerMaintenance HRESULT  PulseControllerMaintenance(                           IN   MAINTENANCE_OPERATION Operation,                           IN   DWORD                 Count                           ); Repeat specified hardware maintenance operation a specified number of times.  Controller Maintenance Operations Controller maintenance operations allow detailed inquiries of RAID controller and disk hardware status, including setting hardware alarm thresholds. This model follows the SCSI-3 SES protocol.  The client interface does any and all CIM conversion. Only hardware providers which do not implement the standard SES protocol must implement these methods. The Common LVM Layer ILVMCommonSupport object implements these methods using the standard SES protocol.  Specifying nonsensical operations or operations unsupported by the target or logical volume provider will cause the operation to fail with no side effects. The common controller maintenance definitions follow the SCSI SES diagnostic page definitions. Each structure maps directly to bytes 1:3 of the unsigned longword payload returned in the SCSI CDB element list.  The controller optionally implements one or more of the following maintenance elements. Multiple instances of each type may be present; for example, multiple fans to allow individual fan failure. Each instance is identified by an ordinal index. The collection of all instances can be controlled or an ensemble status obtained by using the overall index.  #define OVERALL_ELEMENT (-1)     typedef enum _MAINTENANCE_ELEMENT {    All,    Device,    PowerSupply,    Cooling,    Temperature,    DoorLock,    AudibleAlarm,    ControllerElectronics,    ConfigurationElectronics,    NonvolatileCache,    UninterruptiblePowerSupply,    Display,    Keypad,    ExternalPort,    Language,    CommunicationsPort,    Voltage,    Current,    TargetPort,    InitiatorPort } MAINTENANCE_ELEMENT, *PMAINTENANCE_ELEMENT; typedef struct _ELEMENT_INSTANCE {    MAINTENANCE_ELEMENT  Element;    DWORD                Index; } ELEMENT_INSTANCE, *PELEMENT_INSTANCE; Maintenance control and status operations associate an instance of an element to a control request, status return, or threshold.  Status and Control DWORDS can be typecast to element-specific structures. Examples of those structures follow. typedef struct _DEVICE_CONTROL {    unsigned short BypassBEnabled : 1;    unsigned short BypassAEnabled : 1;    unsigned short EnableBypassB : 1;    unsigned short EnableBypassA : 1;    unsigned short DeviceOff : 1;    unsigned short RequestFault : 1;    unsigned short FaultSensed : 1;    unsigned short rsv7;    unsigned short Report : 1;    unsigned short Ident : 1;    unsigned short Remove : 1;    unsigned short Insert : 1;    unsigned short rsv12 : 2;    unsigned short NoRemoval : 1;    unsigned short rsv15 : 1; } DEVICE_CONTROL, *PDEVICE_CONTROL; typedef struct _POWER_CONTROL {    unsigned short rsv0 : 4;    unsigned short RequestOn : 1;    unsigned short Failed : 1;    unsigned short rsv7 : 1;    unsigned short rsv8 : 8; } POWER_CONTROL, *PPOWER_CONTROL; typedef struct _VOLTAGE_CONTROL {    unsigned short DCFail : 1;    unsigned short ACFail : 1;    unsigned short OverTempWarn : 1;    unsigned short OverTempFail : 1;    unsigned short Off : 1;    unsigned short RequestOn : 1;    unsigned short Fail : 1;    unsigned short rsv8 : 1;    unsigned short DCOverCurrent : 1;    unsigned short DCUnderVoltage : 1;    unsigned short DCOvervoltage : 1;    unsigned short rsv12 : 4; } VOLTAGE_CONTROL, *PVOLTAGE_CONTROL; typedef struct _FAN_CONTROL {    unsigned short Speed : 3;    unsigned short rsv3 : 1;    unsigned short RequestOn : 1;    unsigned short Failed : 1;    unsigned short rsv7 : 1;    unsigned short rsv8 : 8; } FAN_CONTROL, *PFAN_CONTROL; typedef struct _TEMPERATURE_CONTROL {    unsigned short UnderTempWarning : 1;    unsigned short UnderTempFailure : 1;    unsigned short OverTempWarning : 1;    unsigned short OverTempFailure : 1;    unsigned short rsv4 : 4;    unsigned short Temperature : 8; } TEMPERATURE_CONTROL, *PTEMPERATURE_CONTROL; typedef struct _DOOR_CONTROL {    unsigned short Unlock : 1;    unsigned short rsv4 : 7;    unsigned short rsv8 : 8; } DOOR_CONTROL, *PTEMPERATURE_CONTROL; typedef struct _ALARM_CONTROL {    unsigned short ToneControl : 4;    unsigned short Remind : 1;    unsigned short rsv5 : 1;    unsigned short Mute : 1;    unsigned short rsv7 : 4;    unsigned short rsv8 : 8; } ALARM_CONTROL, *PALARM_CONTROL; typedef struct _ELECTRONICS_CONTROL {    unsigned short rsv0 : 8;    unsigned short Report : 1;    unsigned short rsv9 : 7; } ELECTRONICS_CONTROL, *PELECTRONICS_CONTROL; typedef struct _UPS_CONTROL {    unsigned short BatteryPredictedFailure : 1;    unsigned short BatteryFailed : 1;    unsigned short rsv2 : 6;    unsigned short InterfaceFailed : 1;    unsigned short OutageWarn : 1;    unsigned short UPSFailed : 1;    unsigned short DCFail : 1;    unsigned short ACFail : 1;    unsigned short ACQual : 1;    unsigned short ACHigh : 1;    unsigned short ACLow : 1; } UPS_CONTROL, *PUPS_CONTROL; typedef struct _VOLTAGE_SENSOR_CONTROL {    unsigned short CriticalUnder : 1;    unsigned short CriticalOver : 1;    unsigned short WarningUnder : 1;    unsigned short WarningOver : 1;    unsigned short rsv4 : 4; } VOLTAGE_SENSOR_CONTROL, *PVOLTAGE_SENSOR_CONTROL; Threshold values are defined only for temperature sensors, uninterruptible power supply battery life, voltage sensors, and current sensors.  #define NO_THRESHOLD (0) typedef struct _THRESHOLD {    short  HighCritical;    short  HighWarning;    short  LowWarning;    short  LowCritical; } THRESHOLD, *PTHRESHOLD; QueryMaintenanceElement HRESULT QueryMaintenanceElements (                          OUT  PELEMENT_INSTANCE* ElementArray,                          OUT  PDWORD             NumberOfElements                          ); Returns the supported maintenance targets and instances supported by the controller. The maintenance element type and number of each populate the returned element array.  SetMaintenanceControl HRESULT SetMaintenanceControl (                       IN  PELEMENT_INSTANCE  ElementArray,                       IN  PDWORD             ControlArray,                       IN  DWORD              NumberOfElements                       ); Requests maintenance control operations. Each element of the DWORD array corresponds to one maintenance control operation to be applied to the specified ELEMENT_INSTANCE. If multiple operations are attempted simultaneously, some or all may fail. To determine the resulting controller status, use QueryMaintenanceStatus. QueryMaintenanceStatus     HRESULT QueryMaintenanceStatus(                       IN   PELEMENT_INSTANCE  ElementArray,                       OUT  PDWORD*            StatusArray,                       IN   DWORD              NumberOfElements                       ); Requests return of maintenance status. For each ELEMENT_INSTANCE array entry, a DWORD status is returned. SetMaintenanceThresholds HRESULT SetMaintenanceThresholds(                         IN  PELEMENT_INSTANCE    ElementArray,                         IN  PTHRESHOLD           ThresholdArray,                         IN  DWORD                NumberOfElements                         ); Requests maintenance threshold change operations. For each ELEMENT_INSTANCE array entry, the corresponding array entry in THRESHOLD describes the control operation requested. If multiple operations are attempted simultaneously, some or all may fail. Only Temperature, UninterruptiblePowerSupply, Voltage, and Current elements may be specified. QueryMaintenanceThresholds HRESULT QueryMaintenanceThresholds(                           IN  PELEMENT_INSTANCE    ElementArray,                           OUT PTHRESHOLD*          ThresholdArray,                           IN  DWORD                NumberOfElements                           ); Requests return of maintenance thresholds. For each ELEMENT_INSTANCE array entry, the corresponding array entry in THRESHOLD describes the current threshold. Only Temperature, UninterruptiblePowerSupply, Voltage, and Current elements may be specified. Provider Support  This section enumerates the methods exported by the common multiplexing layer for (optional) use by logical volume providers. These methods are externalized by the ILVMCommonSupport object.  AutomagicToDirectBinding This TBD routine takes automagic hints and translates them to directed binding suggestions. Intended for use by very low end hardware volume managers wanting only very minimal  automagic  functionality. The provider passes along the automagic hints and a list of possible (free) disk or volume extents. The returned directed binding suggestions include type of volume (RAID level) and list of target volume extents to be used.  SCSISendDiagnostic This TBD routine wrappers the SCSI passthrough IOCTL and transmits a SCSI SEND DIAGNOSTIC command.  SCSIReceiveDiagnostic This TBD routine wrappers the SCSI passthrough IOCTL and transmits a SCSI RECEIVE DIAGNOSTIC STATUS command. Performance Monitoring  Performance modeling is a wild statement of intent only at this time. Common performance counters are currently undefined; see issues. How/if/when we should actually proceed is a good question. LVM providers are encouraged to expose performance tuning and monitors to LVM applications (or human). LVM providers must implement these methods, but there are only minimal requirements on that implementation. Software providers are assumed to use the WDM kernel mode infrastructure.  An LVM provider could chose to implement a proprietary automagic performance tuner and expose only the required performance tuning or monitoring. An LVM provider could also chose to be transparent and expose all sorts of tuning knobs and lots of performance monitoring, but take no provider-specific actions. All performance tuning parameters are assumed to be LVM provider-specific. Parameters are described by LVM_ATTRIBUTEs and may be queried and set.  The model for performance monitoring is: Performance monitoring is implemented by counters.  All counter values are 64-bit unsigned  LVM_VALUEs.  A trace is only a collection of counters over time. Counters are described with by an LVM_ATTRIBUTE. The LVM API enumerates a minimum set of common counters and LVM providers are encouraged to implement these.  Each LVM provider may expose additional provider-specific performance counter array elements. The LVM_ATTRIBUTE description allows an LVM application/human to display/understand any performance data obtained. Counters are aggregated into a single array. The common counters form the first elements of that array. The counter array index forms a handle for each counter.  Counters are enabled, disabled, and cleared.  Counters are repeatedly polled to construct an array of data results. Polling returns an array of (counter index, value) tuples for enabled counters only. typedef union {    short       Type;            // target type     [switch_is(Type)] union VALUE {             [case(1)]   DISKID        Disk;            [case(2)]   VOLUMEID      Volume;            [case(3)]   CONTROLLERID  Controller;    };  } PERFORMANCEID, PPERFORMANCEID;  ClearPerformanceCounter HRESULT ClearPerformanceCounter(                        IN    PPERFORMANCEID  Target,                        IN    PDWORD          CounterIndexArray,                        IN    DWORD           CounterIndexArraySize,                        IN    BOOL            ClearAll                        ); Clears (sets to zero) specified performance counters. DisablePerformanceCounter HRESULT DisablePerformanceCounter(                          IN    PPERFORMANCEID  Target,                          IN    PDWORD          CounterIndexArray,                          IN    DWORD           CounterIndexArraySize,                          IN    BOOL            DisableAll                          ); Disables specified performance counters. EnablePerformanceCounter HRESULT EnablePerformanceCounter(                         IN    PPERFORMANCEID Target,                         IN    PDWORD         CounterIndexArray,                         IN    DWORD          CounterIndexArraySize,                         IN    BOOL           EnableAll                         ); Enables specified performance counters.  QueryPerformanceCounters HRESULT QueryPerformanceCounters(                           IN    PPERFORMANCEID   Target,                           OUT   PLVM_ATTRIBUTE*  CommonAttributeArray,                           OUT   PDWORD           NumberOfCommonAttributes,                              OUT   PLVM_ATTRIBUTE*  ExtendedAttributeArray,                           OUT   PDWORD           NumberOfExtendedAttributes                             ); Returns common and vendor-specific performance attribute arrays. QueryPerformanceData     HRESULT QueryPerformanceData(                     IN   PPERFORMANCEID  Target,                     OUT  PDWORD*         CounterIndexArray,                     OUT  PLVM_VALUE*     CounterValueArray,                     OUT  PDWORD          NumberOfCounters                     );  Returns currently enabled performance counter value array.  QueryPerformanceCounterStatus     HRESULT QueryPerformanceCounterStatus(                              IN  PPERFORMANCEID  Target,                              IN  PLVM_VALUE      CounterIndexArray,                              OUT PBOOL*          CounterEnableArray                              IN  DWORD           NumberOfCounters                              );  Returns current performance counter enable. For each element of the counter index array, an element of the enable array is returned. The enable array boolean is TRUE if the counter is enabled.   StartPerformanceMonitor HRESULT StartPerformanceMonitor(                        IN    PERFORMANCEID  Target,                        IN    BOOL           ClearAllCounters                        ); Start performance counters.  StopPerformanceMonitor HRESULT StopPerformanceMonitor(                       IN    PERFORMANCEID  Target,                       IN    BOOL           ClearAllCounters                       ); Stop performance counters. Error Monitoring  Error monitoring is a wild statement of intent only at this time. How we should actually proceed is a good question. See issues The LVM API supports both a publish-subscribe event notification and a counter model for error monitoring. The first model relies on a general event infrastructure and is currently undefined; see issues. The counter model follows that for performance data monitoring.  Examples of error events or counters include:  Diskgonebad Sectorgonebad VolumeCompromised VolumeSpared VolumeHealthy DiskYanked DiskInserted ExtentAddedToVolume ExtentRemovedFromVolume VolumeChangeStarted       -+      VolumeChangeCompleted      +  x   Bind, Unbind, Add, Remove VolumeChangeAborted       -+     VolumeParameterChange ControllerParameterChange ControllerFirmwareUpdate ControllerPathFailover ControllerVolumeFailover ControllerResetStarted ControllerResetCompleted HotSpareInUse HotSpareDeclared DiskFirmwareUpdate PerformanceCountersCleared ErrorCountersCleared PerformanceLogCleared ErrorLogCleared Client Interface As discussed, the Logical Volume Management API presents two different interfaces:  the Provider Interface used by logical volume managers  the Client Interface used by logical volume management applications The objects presented by the client interface are richer and the Common LVM Layer implements additional methods to filter queries or direct actions; the intent is to simplify the client. The objects presented by the provider interface are aggregated; the intent is to simplify the implementation of the provider and pull as much common data structure manipulation code into the Common LVM Layer.   The Client Logical Volume Management API divides the responsibilities for these actions among the following objects: ILVM   global logical volume management services including discovery of all logical volume providers or actions which can be performed by any existing provider.   ILVMProvider   actions performed by one or more providers including volume configuration and volume queries.   IVolume   configuration and status queries directed to a single volume and/or its contributors.  IPack   disk pack membership, configuration and status queries affecting a single disk pack.  IPlatter - disk pack migration, configuration and status queries affecting a single disk platter.  IDisk - status queries and maintenance operations directed to a single disk. IController   status queries and maintenance operations directed to a single hardware RAID controller. The LVM API is a COM API. In addition to the methods described herein, the API also includes those necessary to present a COM interface.  Any returned arrays are allocated by the provider or common layer using CoMemTaskAlloc and freed by the client. ILVM Public Data and Methods The LVM object implements all methods affecting one or more other objects. These actions include asynchronous operation cancellation and completion and provider enumeration.  The ILVM public data returned includes only the method pointers. Logical volume configuration operations operate on allocations and report volume or disk extents.  typedef struct _LVM_TARGET {     short       Type;           // target type     [switch_is(Type)] union VALUE {            [case(1)]   PDISK     disk;            [case(2)]   PVOLUME   volume;     }; } LVM_TARGET, *PLVM_TARGET; typedef struct _LVM_ALLOCATION {     LVM_TARGET  Target;         // disk or volume     DWORDLONG   Length;         // length in bytes } LVM_ALLOCATION, *PLVM_ALLOCATION; typedef struct _LVM_EXTENT {    LVM_TARGET  Target;          // disk or volume     DWORDLONG   StartingOffset;  // offset from base of volume    DWORDLONG   Length;          // length in bytes } LVM_EXTENT, *PLVM_EXTENT; BindVolume HRESULT BindVolume(           OUT PVOLUME               Volume,           IN  PPACK                 Pack,           IN  DWORDLONG             VolumeSize,            IN  VOLUME_TYPE           VolumeType,            IN  PBIND_HINTS           BindHints,             IN  PLVM_VALUE            BindExtensions,             IN  PLVM_CALLBACK         Callback                           ); BindVolume creates and initially configures an automagic volume. The only required parameter is VolumeSize; all others may be defaulted. The provider uses the BindHints and BindExtensions in good faith; these parameters are hints not requirements. BindExtensions are passed without check or change to the provider.  StripeVolume HRESULT StripeVolume(             OUT  PVOLUME               Volume,             IN   PLVM_ALLOCATION       AllocationArray,             IN   DWORD                 NumberOfAllocations,             IN   LVM_VALUE             InterleaveSize,                 IN   PLVM_VALUE            StripeExtensions,             IN   PLVM_CALLBACK         Callback             ); Creates and configures a striped logical volume using extents from the specified logical volumes or disks. Stripe sets are constructed from equal length extents; equal size extents from each target (volume or disk) in the allocation array are consumed.  The number of elements of that array determines the number of stripes in the volume. The stripe chunk is determined by InterleaveSize; the chunk may be defaulted by specifying DEFAULT_INTERLEAVE (0).   The Common LVM Layer checks the AllocationArray for duplicate targets prior to invoking the provider. It is not possible to construct a stripe set using one and only one disk by specifying the disk twice.  MapVolume HRESULT MapVolume(          OUT  PVOLUME               Volume,          OUT  PLVM_VALUE            DiskNumber,          IN   PLVM_ALLOCATION       AllocationArray,          IN   DWORD                 NumberOfAllocations,          IN   PLVM_VALUE            MapExtensions,          IN   PLVM_CALLBACK         Callback          ); Configures a mapped volume. Volume extents are allocated in the order specified by the allocation array and concatenated. The resulting mapped volume is exposed to NT and an NT disk number is assigned.   Create Pack HRESULT CreatePack(            OUT PPACK     Pack,             IN  DWORDLONG ExtentSize,            IN  PWSTR     lpszPackName,            IN  DWORD     cchBufferLength,            IN  PDISK     DiskArray,            IN  BOOL      SpareFlag,            IN  DWORD     ArraySize            ); Creates a diskpack. The extent size must be a power of two disk sectors. If the extent size is not specified, the Common LVM Layer will use 1% of the largest disk drive known to be in the configuration.  For example, the extent size would default to 128MB for configurations with 18GB drives.  If the DiskArray is not empty, also adds disks to a pack. Any logical volume originally on the added disks is lost and not imported to the pack. Specifying SpareFlag as TRUE reserves the added disks as hotspares and does not allow them to be immediately inhabitable for automagic dynamic reconfiguration. To swap a free disk with a disk in a pack, use IDisk :: ReplaceDisk. To add disks to a pack, use IPack :: AddDisk. Only simple disks managed by a software provider are added to a pack; logical units exported by a hardware provider are implicitly added to the pack by automagic binding. QueryDisks  HRESULT QueryDisks(           OUT  PDISK*      ArrayOfDisks,           OUT  PDWORD      NumberOfDisks           ); Return all disks. To scope, use the corresponding ILVMProvider or IPack method.  QueryPacks HRESULT QueryPacks(            OUT PPACK*    PackArray,           OUT PDWORD    NumberOfPacks           ); Returns all disk packs with optional scoping by provider. To scope, use the corresponding ILVMProvider method. QueryProviders HRESULT QueryProviders(               OUT  PPROVIDER*    ArrayOfProviders,               OUT  PDWORD        NumberOfProviders               ); Returns all active logical volume providers.  QueryVolumes HRESULT QueryVolumes(             IN   VOLUME_TYPE      Type,             IN   VOLUME_STATUS    Status,             IN   VOLUME_HEALTH    Health,             IN   VOLUME_JELLO     Jello,             OUT  PVOLUME*         ArrayOfVolumes,             OUT  PDWORD           NumberOfVolumes             ); Return all volumes with optional scoping by type, status, health, and/or jello. Ignores any stacking hierarchy. To scope, use the corresponding ILVMProvider or IPack method. ClearPerformanceCounter HRESULT ClearPerformanceCounter(                        ); Clears (sets to zero) all performance counters.   QueryPerformanceAttributes HRESULT QueryPerformanceAttributes(                           OUT   PLVM_ATTRIBUTE*  CommonAttributeArray,                           OUT   PDWORD           NumberOfCommonAttributes                            ); Returns common performance attribute array. Common attributes apply equally well to volumes, disks, and/or controllers.  StartPerformanceMonitor HRESULT StartPerformanceMonitor(                        IN    BOOL           ClearAllCounters                        ); Start all enabled performance counters.  StopPerformanceMonitor HRESULT StopPerformanceMonitor(                       IN    BOOL           ClearAllCounters                       ); Stop all enabled performance counters. ILVMProvider Public Data and Methods The provider object implements all volume configuration operations and resource queries.  Many of the provider ILVMProvider methods directly correspond to ILVM or ILVMSpecificProvider methods. The ILVM method supplies a  generic provider  and should be used whenever the client is willing to allow the Common LVM Layer to select the appropriate provider (eg use Veritas dynamic disks rather than ftdisk basic disks).  For all of these methods, refer to the ILVM documentation section. Method Reference QueryParameters  REF _Ref442286821 \n \h  3.1.6 QueryExtensions  REF _Ref442286838 \n \h  3.1.6 BindVolume  REF _Ref442286676 \n \h  4.1.1 StripeVolume   REF _Ref442286689 \n \h  4.1.2 MapVolume  REF _Ref442286707 \n \h  4.1.3 CreatePack  REF _Ref442287180 \n \h  4.1.4 ClearPerformanceCounter  REF _Ref442361423 \n \h  4.1.9 StartPerformanceCounter  REF _Ref442361425 \n \h  4.1.11 StopPerformanceCounter  REF _Ref442361427 \n \h  4.1.12 EvacuateDisks HRESULT EvacuateDisks(               IN  PPACKID   Pack,                 IN  PDISKID   DiskArray,               IN  DWORD     ArraySize,               IN  PCALLBACK Callback              ); This routine moves any volume extents from the disk array to other disks in the diskpack.  Note that to be eligible for removal, any volumes occupying a disk must have been evacuated. In other words, the disk must contain no live data.  The disks remain evacuated until explicitly declared ready for inhabit, freeing from a diskpack, removal, or conversion to hot spare. This method may be used to inhabit simple disks or disks managed by a hardware provider; in the latter case, the PACKID is only advisory.  InhabitDisks HRESULT InhabitDisks(               IN  PDISKID   DiskArray,             IN  DWORD     ArraySize         ); Declares the disks available for automagic volume migration or other volume configuration operation. Note that InhabitDisks does not guarantee that the affected disks return to active use or again contain any previously configured logical volume. This method may be used to inhabit simple disks or disks managed by a hardware provider.  The disks must be members of a diskpack.   QueryControllers HRESULT QueryControllers(                 IN OUT PCONTROLLER*    Controller,                 OUT    DWORD           NumberOfControllers                                        ); Returns the associated controller object. Software providers return NULL. Hardware providers are expected to return one controller unless they are hierarchical. QueryDisks  HRESULT QueryDisks(           IN   PPACK       Pack,           OUT  PDISK       ArrayOfDisks,           OUT  PDWORD      NumberOfDisks           ); Return all disks with optional scoping by pack. QueryID HRESULT QueryID(         OUT  PPROVIDERID    ProviderID                        ); Returns the provider ID.  QueryLUNs HRESULT QueryLUNs(           IN OUT  PDWORD*    LUNArray,           OUT     PDWORD     NumberOfLuns           ); Returns the LUNS (logical units) exposed by this provider. Software providers return NULL. QueryName HRESULT QueryName(           OUT  PWSTR*     lpszName,           OUT  PDWORD     Instance                             ); Returns the provider name and instantiation. Since each controller has a unique provider, when multiple identical controllers are present, the providers will each have the same name, but different instances.    QueryPacks HRESULT QueryPacks(           OUT PPACK*     PackArray,           OUT PDWORD    NumberOfPacks           ); Returns all disk packs.  QueryVolumes HRESULT QueryVolumes(             IN   VOLUME_TYPE      Type,             IN   VOLUME_STATUS    Status,             IN   VOLUME_HEALTH    Health,             IN   VOLUME_JELLO     Jello,             IN   PPACK            Pack,             OUT  PVOLUME*         ArrayOfVolumes,             OUT  PDWORD           NumberOfVolumes             ); Return all volumes with optional scoping by type, status, health, jello, and/or pack. Ignores any stacking hierarchy.  QueryType HRESULT QueryType(                             ); Return indicates whether the provider is a software or hardware provider.  IVolume Public Data and Methods For more information on logical volume attributes and parameters, see   REF _Ref441511528 \n \h  Delete HRESULT Delete(       IN   PLVM_CALLBACK      Callback       ); Deletes and deconfigures the volume. All data are lost. All disk extents or volume extents which contributed to the volume are freed for immediate reuse by the volume provider.  The call affects only one stacking layer. To fully delete a mapped, striped, automagic volume requires that all contributing volumes are deleted. The Common LVM Layer performs any coordination with NT prior to passing this request to the volume provider. Extend HRESULT Extend(       IN    PLVM_ALLOCATION   AllocationArray,       IN    DWORD             NumberOfAllocations,       IN    PLVM_CALLBACK     Callback       ); Extend grows the specified volume. The mechanism depends on the type of volume being extended: Simple spanned or mapped volumes are extended by appending volume extents. The appended extents are allocated in order from the allocation array. If the allocation array contains only one volume and that volume is the last (highest LBN) contributor, that volume will be extended by the Common LVM Layer.  Striped volumes are extended by growing each contributing automagic volume. No allocation array is necessary. (See   REF _Ref428786746 \n \h  2.1.5 Plexed volumes are extended by growing each plex. If the allocation array contains only the highest volume contributors, each will be extended by the Common LVM Layer. Otherwise, the allocation array will be used to extend the mapped volume.  The Common LVM Layer grows automagic volumes by invoking ResizeBindVolume (See   REF _Ref441900712 \n \h  3.4.3 .) The Common LVM Layer also has the responsibility of informing the file system that the volume has grown.  Shrink HRESULT Shrink(       IN    DWORDLONG         NumberOfBytesToRemove,       OUT   PLVM_ALLOCATION*  RemovedAllocationArray,       OUT   DWORD             NumberOfRemovedAllocations,       IN    PLVM_CALLBACK     Callback       ); Shrink removes volume extents from the specified volume. Volume extents are always removed from the last (highest) LBN of the volume. Striped volumes are contracted by shrinking each contributing volume.  The Common LVM Layer shrinks automagic volumes by invoking ResizeBindVolume (See   REF _Ref441900712 \n \h  3.4.3 .) The Common LVM Layer also has the responsibility of coordinating with the file system to ensuring that no data is lost. Data is evacuated from the logical block ranges to be removed prior to resizing. AddPlex HRESULT AddPlex(        IN     PVOLUME              PlexVolume,           IN     PLVM_VALUE           PlexExtensions,        OUT    PDWORD               AddedPlexId,        IN     PLVM_CALLBACK        Callback        ); Adds a plex to the specified volume. The completion routine is invoked after the added plex has been synchronized with the original volume. The Common LVM layer verifies that the PlexVolume is large enough prior to invoking the provider.  RemovePlex HRESULT RemovePlex(           IN   DWORD                 PlexId,           OUT  PVOLUME               RemovedVolume,           OUT  PDWORD                RemovedPlexId,           IN   BOOL                  SyncFlag,           IN   PLVM_CALLBACK         Callback           ); Removes a previously added plex from the specified volume. The Common LVM Layer optionally synchronizes the file system prior to causing the plex to be broken by the provider.  After removal, the plex is no longer held in synchronization with the original volume. ForceHealthy HRESULT ForceHeathy(             ); Forces volume to be healthy. Allows possibly dangerous override in the event of catastrophic disk failures.  ForceInitialize HRESULT ForceInitialize(                 ); Forces volume to be reinitialized. All data may be lost. Allows possibly dangerous override in the event of catastrophic disk failures.  ForceRebuild HRESULT ForceRebuild(             ); Forces volume to be rebuilt. Allows possibly dangerous override in the event of catastrophic disk failures.  SetExtensions HRESULT  SetExtensions(               IN BOOL           Override,               IN PLVM_VALUE     BindExtensionArray,               IN DWORD          BindExtensionArraySize               ); Sets provider-specific extended attributes for the volume. SetLbnRemap HRESULT SetLbnRemap(            IN BOOL     Enable            ); Enables or disables automagic remapping by the logical volume provider. Disabling LBN remapping  freezes the current logical to physical topology of the volume. SetRebuildPriority HRESULT SetRebuildPriority(                    IN DWORD    Priority                    ); Sets the relative rebuild priority for the volume.   QueryAttributes  HRESULT  QueryAttributes(                OUT    PVOLUME_TYPE          VolumeType,                OUT    PVOLUME_ATTRIBUTES*   VolumeAttributes,                OUT    PLVM_VALUE*           BindExtensionArray,                OUT    PDWORD                NumberOfBindExtensions                OUT    PBOOL                 IsStacked                   ); Returns volume type, provider, pack, size, and attributes.   QueryControllers HRESULT QueryControllers(                 OUT  PCONTROLLER*   ControllerArray,                 OUT  PDWORD         NumberOfControllers                 ); Returns the any controller(s) associated with the specified volume. QueryDiskExtents  HRESULT QueryDiskExtents(                  OUT   PVOLUME_TYPE   Type,                    OUT   PLVM_EXTENT*   ArrayOfDiskExtents,                  OUT   PDWORD         NumberOfDiskExtents                  ); Returns all disk extents contributing to the volume, regardless of the stacking hierarchy. Intended to provide a simple physical view of the resources consumed by the volume.  QueryDiskNumber  HRESULT QueryDiskNumber(                OUT PDWORD   DiskNumber,                OUT BOOL     VolumeIsMapped                ); Returns the NT disk number (if any) associated with this volume. If the volume is a mapped volume, the disk number was created at volume configuration. If the volume is not a mapped volume, but the volume contributes extents to a mapped volume, the NT disk number is that of the mapped volume. If the volume is not mapped, there is no NT disk number. QueryExtents HRESULT QueryExtents(              OUT  PVOLUME_TYPE    Type,                OUT  PLVM_EXTENT*    ArrayOfTargetExtents,              OUT  PDWORD          NumberOfTargetExtents              ); Returns all volumes contributing one or more extents to this volume. Only one level of the stacking hierarchy is traversed; the query must be made recursively at each stacking level to build up a complete view.  Use QueryDiskExtents to retrieve a flat view of all contributing extents. Use QueryPlexes to retrieve any plex information. QueryID HRESULT QueryID(         OUT PVOLUMEID   VolumeID                        ); Returns the volume ID.  QueryLbnRemap HRESULT QueryLbnRemap(              OUT PBOOL     Enable              ); Returns whether or not the volume may currently be dynamically reconfigured. If LBN (logical block number) remapping is enabled, the provider may migrate volume extents at will. Note that the returned enable applies only to the specified volume; if the volume is stacked, the constituent volumes may be differently enabled. QueryLUN HRESULT QueryLUN(          IN OUT  PDWORD    LUN          ); Returns the LUN (logical units) associated with this volume (if any). If there is no associated LUN, the return is  QueryPack HRESULT QueryPack(           OUT PPACK       Pack,           ); Returns the pack containing the volume.  QueryPlatter HRESULT QueryPlatter(              OUT  PPLATTER  Platter,              OUT  PPACK     Pack              ); Returns the platter (if any) and pack containing the volume. If the volume is not on a platter, the return is NULL.  QueryPlexes HRESULT QueryPlexes(             OUT PVOLUME*   VolumeArray,              OUT PDWORD     NumberOfPlexes             ); Finds all plexes of the specified volume. The returned volume array contains plexes in plexId order.   QueryProvider HRESULT QueryProvider(              OUT PPROVIDER  Provider              );  Returns volume provider. QuerySize HRESULT QuerySize(           OUT PDWORDLONG  VolumeSize           ); Returns volume size. QueryState HRESULT QueryState(           OUT PVOLUME_STATUS Status,           OUT PVOLUME_HEALTH Health,           OUT PVOLUME_JELLO  Jello          ); Returns volume status, health, and jello.  QueryType HRESULT QueryType(          OUT PVOLUME_TYPE   Type          ); Returns volume type. See   REF _Ref428791617 \n \h   for the definition of VOLUME_TYPE; Default, FaultTolerant, NotFaultTolerant are not returned as a result of this query. QueryVolumeUsingPlex     HRESULT QueryVolumeUsingPlex(                     IN  PVOLUME    Plex,                      OUT PVOLUME    Volume,                     OUT PDWORD     PlexId                     ); Finds the base volume of this volume  plex.  The returned plexId is that of the original plex volume. QueryVolumesUsingVolume  HRESULT QueryVolumesUsingVolume(                        IN   BOOL      IncludeStack,                        OUT  PVOLUME   ArrayOfVolumes,                        OUT  PDWORD    NumberOfVolumes                        ); Find all stacked volumes with extents residing on the specified volume.  The IncludeStack boolean scopes the stacking hierarchy; IncludeStack of FALSE returns only the next stacking level volumes. StartMaintenance HRESULT  StartMaintenance(                 IN   MAINTENANCE_OPERATION Operation                 ); Start specified hardware maintenance operation. The operation will affect all disks contributing extents to the volume.  StopMaintenance HRESULT  StopMaintenance(                IN   MAINTENANCE_OPERATION Operation                ); Stop specified hardware maintenance operation. The operation will affect all disks contributing extents to the volume.  PulseMaintenance HRESULT  PulseMaintenance(                 IN   MAINTENANCE_OPERATION Operation,                 IN   DWORD                 Count                 ); Repeat specified hardware maintenance operation a specified number of times. The operation will affect all disks contributing extents to the volume.  ClearPerformanceCounter HRESULT ClearPerformanceCounter(                        IN    PDWORD         CounterIndexArray,                        IN    DWORD          CounterIndexArraySize,                        IN    BOOL           ClearAll                        ); Clears (sets to zero) specified performance counters.   DisablePerformanceCounter HRESULT DisablePerformanceCounter(                          IN    PDWORD         CounterIndexArray,                          IN    DWORD          CounterIndexArraySize,                          IN    BOOL           DisableAll                          ); Disables specified performance counters. EnablePerformanceCounter HRESULT EnablePerformanceCounter(                         IN    PDWORD        CounterIndexArray,                         IN    DWORD         CounterIndexArraySize,                         IN    BOOL          EnableAll                         ); Enables specified performance counters.  QueryPerformanceCounters HRESULT QueryPerformanceCounters(                          OUT   PLVM_ATTRIBUTE*  ExtendedAttributeArray,                         OUT   PDWORD           NumberOfExtendedAttributes                           ); Returns vendor-specific performance attribute arrays. QueryPerformanceData     HRESULT QueryPerformanceData(                     OUT  PDWORD*      CounterIndexArray,                     OUT  LVM_VALUE*   CounterValueArray,                     OUT  PDWORD       NumberOfCounters                     );  Returns current performance counter value array.  QueryPerformanceCounterStatus     HRESULT QueryPerformanceCounterStatus(                              IN  PLVM_VALUE      CounterIndexArray,                              OUT PBOOL*          CounterEnableArray                              IN  DWORD           NumberOfCounters                              );  Returns current performance counter enable. For each element of the counter index array, an element of the enable array is returned. The enable array boolean is TRUE if the counter is enabled. StartPerformanceMonitor HRESULT StartPerformanceMonitor(                        IN    BOOL           ClearAllCounters                        ); Start performance counters.  StopPerformanceMonitor HRESULT StopPerformanceMonitor(                       IN    BOOL           ClearAllCounters                       ); Stop performance counters. IPack Public Data and Methods The disk pack object implements all disk pack membership. Import/export/migration between packs are performed with IPlatter methods.   Delete HRESULT Delete(        IN  BOOL     ForceFlag        ); Deletes a diskpack. If ForceFlag is specified as FALSE, the operation will fail if the pack still contains any logical volumes. Specifing ForceFlag as TRUE overrides this and causes to any logical volumes remaining in the pack to be lost.  AddDisks HRESULT AddDisks(          IN PDISK     DiskArray,          IN BOOL      SpareFlag,          IN DWORD     ArraySize          ); Adds disks to a pack. Any logical volume originally on the added disks is lost and not imported to the pack. Specifying SpareFlag as TRUE reserves the added disks as hotspares and does not allow them to be immediately inhabitable for automagic dynamic reconfiguration. To swap a free disk with a disk in a pack, use ReplaceDisk. Only simple disks managed by a software provider are added to a pack; logical units exported by a hardware provider are implicitly added to the pack by automagic binding. CreatePack HRESULT CreatePack(            OUT  PPLATTER   Platter            ); Creates a platter for volume migration.  FreeDisks HRESULT FreeDisks(           IN     PDISK     DiskArray,           IN     DWORD     ArraySize,           OUT    PDISK*    RemovedDiskArray,           OUT    PDWORD    NumberOfRemovedDisks                         ); Removes disks from pack and makes them free agents. Note that to be eligible for removal, any volumes occupying a disk must have been evacuated. In other words, the disk must contain no live data.  Only those disks actually evacuated will be returned in the RemovedDiskArray. This method affects only simple disks managed by a software provider.  QueryDisks  HRESULT QueryDisks(           OUT  PDISK*      ArrayOfDisks,           OUT  PDWORD      NumberOfDisks           ); Return all disks in the pack.  QueryID HRESULT QueryID(         OUT PPACKID   PackID                        ); Returns the pack ID. QueryLUNs HRESULT QueryLUNs(           IN OUT  PPROVIDERID*  ProviderArray,           IN OUT  PDWORD*       LUNArray,           OUT     PDWORD        NumberOfLuns           ); Returns a pair of arrays containing the provider and lun for all logical units contained within this pack.   QueryPlatters HRESULT QueryPlatters(              OUT   PPLATTER*   PlatterArray,               OUT   PDWORD      NumberOfPlatters              ); Returns all disk platters currently in this pack. QueryProvider HRESULT QueryProvider(              OUT   PPROVIDER   Provider              ); Returns (uppermost) provider responsible for the pack. QueryVolumes HRESULT QueryVolumes(             IN   VOLUME_TYPE      Type,             IN   VOLUME_STATUS    Status,             IN   VOLUME_HEALTH    Health,             IN   VOLUME_JELLO     Jello,             OUT  PVOLUME*         ArrayOfVolumes,             OUT  PDWORD           NumberOfVolumes             ); Return all volumes with optional scoping by type, status, health, and jello. Ignores any stacking hierarchy.  IPlatter Public Data and Methods The disk platter object implements all import/export (disk pack migration) operations.   Delete HRESULT Delete(       ); Cancels preparation of a platter for volume migration. Any volumes on the platter rejoin the disk pack and may migrate freely. Export HRESULT Export(        IN  PLVM_CALLBACK Callback        ); Marks all disks on the platter ready for export. As a side effect, the disks contained in the platter are recorded such that when the platter is subsequently imported, the receiving pack can determine if all disks are present. Import HRESULT Import(        IN  PPACK          Pack,       IN  BOOL           OverrideMissingDisks,       IN  PLVM_CALLBACK  Callback       ); Imports all volumes and adds all disks contained on the platter to the pack. This operation may fail or cause reconfiguration of the existing volumes if the volume allocation extent of the platter differs from that of the receiving platter.   If one or more disks have been lost in the movement, volumes contained on the platter may not be transitively closed. Specifying OverrideMissingDisks will import any transitively closed volumes and add all disks. This may cause silent loss of volumes and/or data and should only be done with after careful consideration.  Successful import of a platter also causes deletion of that platter. The imported volumes join all other volumes in the pack.   Migrate HRESULT Migrate(        IN  PPACK         NewPack,            IN  PLVM_CALLBACK Callback            ); Atomically moves the platter between packs. Both packs must be present on the same processor node in a cluster.  MoveVolumesOff HRESULT MoveVolumesOff(               IN   PVOLUME        ArrayOfVolumes,               IN   DWORD          ArrayOfVolumesSize,               IN   PDISK          ArrayOfDisks,               IN   DWORD          ArrayOfDisksSize,               IN   PLVM_CALLBACK  Callback               );  Explicitly moves volumes or evacuates disks and frees them from a platter. This routine is intended for use only for minor corrections to a friendly export which inadvertently includes a volume or disk.  The FriendlyFlag controls whether or not additional volumes may by added to the platter as explained in   REF _Ref427665645 \r \h  2.1.7 . The CompactFlag controls whether or not volume extents are compacted onto disk drives prior to migration.  Logical volume providers compact volumes in good faith but the number of drives is not guaranteed to be the absolute minimal.  Once completed, all affected logical volume providers may do no other automagic migration of volumes to or from the platter. Removing a volume from platter causes that volume to rejoin the diskpack and may result in automagic reconfiguration of the volume if otherwise permitted.  MoveVolumesOnto HRESULT MoveVolumesOnto(                IN  PVOLUME       ArrayOfVolumes,                IN  DWORD         ArrayOfVolumesSize,                IN  PDISK         ArrayOfDisks,                IN  DWORD         ArrayOfDisksSize,                IN  BOOL          CompactFlag,                IN  BOOL          FriendlyFlag,                IN  PLVM_CALLBACK Callback                );  Prepares a platter for migration by moving one or more volumes to one or more disks. Specifying a disk array is optional; automagic volume managers may select disks for migration. Moving volumes to a platter may cause volume extent migration.  The FriendlyFlag controls whether or not additional volumes may by added to the platter as explained in   REF _Ref427665645 \r \h  2.1.7 . The CompactFlag controls whether or not volume extents are compacted onto disk drives prior to migration.  Logical volume providers compact volumes in good faith   the number of drives is not guaranteed to be the absolute minimal.  Once completed, all affected logical volume providers may do no other automagic migration of volumes to or from the platter. No change in volume type is permitted.  QueryDisks HRESULT QueryDisks(           OUT  PDISK*     DiskArray,            OUT  PDWORD     NumberOfDisks           ); Returns the disks (if any) contained on the platter. QueryPack HRESULT QueryPack(          OUT PPACK       Pack          ); Returns the diskpack containing this platter.  QueryProvider HRESULT QueryProvider(              OUT   PPROVIDER   Provider              ); Returns (uppermost) provider responsible for the platter. QueryVolumes HRESULT QueryVolumes(             IN   VOLUME_TYPE      Type,             IN   VOLUME_STATUS    Status,             IN   VOLUME_HEALTH    Health,             IN   VOLUME_JELLO     Jello,             OUT  PVOLUME*         VolumeArray,             OUT  PDWORD           NumberOfVolumes             ); Returns all volumes (if any) contained on this platter with optional scoping by type, status, health, and jello. Ignores any stacking hierarchy. IDisk Public Data and Methods Many of the IDisk methods directly correspond to IVolume methods. For all of these methods, refer to the IVolume documentation section. Method Reference QueryParameters  REF _Ref442286821 \n \h  3.1.6 QueryExtensions  REF _Ref442286838 \n \h  3.1.6 StartMaintenance  REF _Ref442720229 \n \h  4.3.28 StopMaintenance  REF _Ref442720233 \n \h  4.3.29 PulseMaintenance  REF _Ref442720237 \n \h  4.3.30 ClearPerformanceCounter  REF _Ref442720240 \n \h  4.3.31 DisablePerformanceCounter  REF _Ref442720423 \n \h  4.3.32 EnablePerformanceCounter  REF _Ref442720428 \n \h  4.3.33 QueryPerformanceCounters  REF _Ref442720430 \n \h  4.3.34 QueryPerformanceData  REF _Ref442720433 \n \h  4.3.35 QueryPerformanceCounterStatus  REF _Ref442720257 \n \h  4.3.36 StartPerformanceCounter  REF _Ref442720768 \n \h  4.3.37 StopPerformanceCounter  REF _Ref442720640 \n \h  4.3.38 ReplaceDisk HRESULT ReplaceDisk(            IN  PDISK           NewDisk,            IN  BOOL            StrictFlag,            IN  PLVM_CALLBACK   Callback            ); Substitutes one physical disk for another to allow media migration. Any contents of the replaced disk are migrated, although not necessarily to the new disk. Specifying StrictFlag to be TRUE causes strict replacement; all contents of the replaced disk are migrated to the new disk. If StrictFlag is true and the new disk is not large enough to hold the contents of the replaced disk, the operation will fail. At completion, the replaced disk is no longer in use and may be physically removed. SetHotSpare HRESULT SetHotSpare(             IN HRESULT     Enable             ); Declares disk to be used as a hot spare. If the disk current contributes to one or more logical volumes, this call will fail. The volumes must be first moved using ReplaceDisk (  REF _Ref428793082 \n \h   \* MERGEFORMAT  4.6.1 QueryConnection HRESULT QueryConnection(                OUT PDISK_CONNECT_TYPE ConnectionType                ); Returns abstracted physical connection to disk. See   REF _Ref441511859 \n \h  3.11.2  for the returned connection types.  QueryController HRESULT QueryController(                OUT   PCONTROLLER   Controller                ); Returns the controller (if any) associated with the specified disk.  QueryExtensions HRESULT QueryExtensions(                OUT   PLVM_VALUE*   DiskExtensionArray,                OUT   PDWORD        NumberOfDiskExtensions                );  Returns vendor-specific disk parameter array. QueryID HRESULT QueryID(         OUT DISKID   DiskID                        ); Returns the disk ID. QueryLUNs HRESULT QueryLUNs(           IN OUT  PDWORD*    LUNArray,           OUT     PDWORD     NumberOfLuns           ); Returns any LUNS (logical units) contributed by this disk. Valid only if the disk is managed by a hardware provider. Software providers return NULL. QueryParameters HRESULT QueryParameters(                IN OUT  PLVM_PARAMETER*   ExtendedParameterArray,                OUT     PDWORD            NumberOfExtendedParameters                );  Returns the array of LVM_VALUE vendor-specific disk extended parameter values.  QueryPack HRESULT QueryPacks(           IN OUT PPACK*       PackArray,           OUT    DWORD        NumberOfPacks           ); Returns the diskpack containing the disk. If the disk is a free agent, the returned pack is NULL. If the disk is managed by a software provider, the number of packs must be one.  QueryPlatter HRESULT QueryPlatter(              OUT  PPLATTER  Platter,              OUT  PPACK     Pack              ); Returns the platter (if any) and pack which contains the disk. If the disk is not on a platter, the return is NULL.  If the disk is a free agent, the returned pack is NULL. QueryProvider HRESULT QueryProvider(              OUT PPROVIDER  Provider              );  Returns lowest level provider managing the disk. QuerySize HRESULT QuerySize(          OUT PDWORDLONG  DiskSize          ); Returns size in bytes of the specified disk. QueryStatus HRESULT QueryStatus(            OUT PVOLUME_STATUS Status            ); Returns current access by NT. Disk access is the same as volume access (VOLUME_STATUS). QueryVolumesUsingDisk  HRESULT QueryVolumesUsingDisk(                      IN   VOLUME_TYPE      Type,                      IN   VOLUME_STATUS    Status,                      IN   VOLUME_HEALTH    Health,                      IN   VOLUME_JELLO     Jello,                      IN   BOOL             IncludeStack,                      OUT  PVOLUME*         ArrayOfVolumes,                      OUT  PDWORD           NumberOfVolumes                      ); Finds all volumes with extents residing on the specified disk with optional scoping by type, status, health, and jello. Specifying IncludeStack as FALSE will cause only the lowest level bound volume to be returned. Set IncludeStack to TRUE to traverse the hierarchy locating all stacked volumes. IController Public Data and Methods Many of the IController methods directly correspond to IVolume methods. For all of these methods, refer to the IVolume documentation section. Method Reference QueryParameters  REF _Ref442286821 \n \h  3.1.6 QueryExtensions  REF _Ref442286838 \n \h  3.1.6 StartMaintenance  REF _Ref442720229 \n \h  4.3.28 StopMaintenance  REF _Ref442720233 \n \h  4.3.29 PulseMaintenance  REF _Ref442720237 \n \h  4.3.30 ClearPerformanceCounter  REF _Ref442720240 \n \h  4.3.31 DisablePerformanceCounter  REF _Ref442720423 \n \h  4.3.32 EnablePerformanceCounter  REF _Ref442720428 \n \h  4.3.33 QueryPerformanceCounters  REF _Ref442720430 \n \h  4.3.34 QueryPerformanceData  REF _Ref442720433 \n \h  4.3.35 QueryPerformanceCounterStatus  REF _Ref442720257 \n \h  4.3.36 StartPerformanceCounter  REF _Ref442720768 \n \h  4.3.37 StopPerformanceCounter  REF _Ref442720640 \n \h  4.3.38 ForceHealthy HRESULT ForceHeathy(            ); Forces controller to be healthy. Allows possibly dangerous override in the event of catastrophic controller or disk failures. ForceInitialize HRESULT ForceInitialize(                 ); Forces controller to reinitialize. Must not affect current volumes configured behind the controller.   ForcePath HRESULT ForcePath(          IN DWORD        ActivePath          ); Forces active controller path to specified path.  ForceRebuild HRESULT ForceRebuild(             ); Forces all volumes configured behind the controller to be rebuilt. Allows possibly dangerous override in the event of catastrophic controller or disk failures. SetExtensions HRESULT  SetExtensions(              IN BOOL            Override,              IN PLVM_VALUE*     ConrollerExtensionArray,              IN DWORD           ControllerExtensionArraySize              ); Sets provider-specific extended attributes for the controller.    QueryAttributes HRESULT QueryAttributes(                OUT   PBOOL                    Online,                OUT   PVOLUME_HEALTH           Health,                OUT   PCONTROLLER_ATTRIBUTES*  ControllerAttributes,                 OUT   PLVM_VALUE*              ControllerExtensionArray,                OUT   PDWORD                   NumberOfControllerExtensions                );                                             Returns whether the controller is currently online, vendor-specific controller extended parameter values, and vendor-specific extended binding attributes. QueryDisks HRESULT QueryDisks(           OUT  PDISK*       ArrayOfDisks,           OUT  PDWORD       NumberOfDisks           ); Returns an array of disks attached to the controller. The array is exactly DiskPaths by DisksPerPath; where DiskPaths and DisksPerPath are controller attributes. If no disk is present at the location, the DISKID array entry is returned as INVALID_DISK. If the array is not sufficiently large, an error is returned and all array contents are suspect. QueryID HRESULT QueryID(         OUT PCONTROLLERID  ControllerID                        ); Returns the controller ID.   QueryLbnRemap HRESULT QueryLbnRemap(              OUT    PBOOL          Capable,              OUT    PBOOL          Enable              ); Returns whether or not the controller is capable of dynamic volume reconfiguration and whether or not the controller is currently allowed to do so.  If LBN remapping is enabled, the provider may migrate volume extents at will.  QueryPath HRESULT QueryPath(           OUT    PDWORD         PrimaryPath,           OUT    PDWORD         SecondaryPath,           OUT    PDWORD         ActivePath           ); Returns primary, secondary, and currently active paths for a dual pathed controller. QueryProvider HRESULT QueryProvider(               OUT  PPROVIDER  Provider                                  ); Returns the associated provider.  CIM Public Data and Methods The controller maintenance operations described in   REF _Ref442722482 \r \h   are exposed as CIM objects. The table will summarize correspondence between the SES maintenance element and the CIM object. Full design of the mapping is still TBD. SES Maintenance Element CIM Object Comments PowerSupply Cooling Temperature DoorLock AudibleAlarm ControllerElectronics ConfigurationElectronics NonvolatileCache UninterruptiblePowerSupply Display Keypad ExternalPort Language CommunicationsPort Voltage Current TargetPort InitiatorPort NT callbacks  This section enumerates all NT methods used by the Common LVM Layer. These routines are not to be used by logical volume providers or application clients.   Bare minimum enumeration. All will likely have user and kernel mode equivalents. Known missing include any GUID to device target translations. EvacuateVolumeExtent This TBD routine gets the file system to move files from a list of extents (prior to shrinking a volume). InhabitVolumeExtent This TBD routine informs the file system that the volume has been extended.  SynchVolumeContents This TBD routine causes the file system or database to synchronize the volume media contents. Used prior to breaking a snapshot plex. Implies some companion mechanism by which a database or other application can register a synchronization callback. UpdateWolfpackLVM This TBD routine causes logical volume configuration change information to be written to the Wolfpack quorum data.  GetWolfpackLVM This TBD routine retrieves logical volume configuration change information from the Wolfpack quorum data. Vendor interactions and issues This section very rough.  Suggestions solicited. Veritas Veritas maintains a vxconfigd API. As of this writing, how that API would map to this API is unclear   that API and the underlying architecture are undocumented. The following are known technical issues in addition to any business issues: Veritas groups are not diskpacks. Veritas maintains configuration information for all members of a group on each group member. The base product implements basic volume sanity and supports only one disk group. The LDM-Pro product imposes a majority rule quorum for groups and supports multiple groups. With the possible exception of volume migration between groups, this issue can be addressed by treating groups as  super-packs . Groups provide additional robustness properties over LVM packs. Support for volume migration between groups is unclear. This may be limited to LDM-Pro, or may be more generally restricted.  Volume stacking is supported only with LDM-Pro. Veritas may also support mirrored stripes not striped mirrors.  Veritas integration with Wolfpack is still being worked. The failover unit is the group, but there is a circular dependency between group sanity and quorum volume identity. Veritas does not discover the volumes contained within a group until the group is brought online. Disk ownership must be established prior to bringing the group online. Thus, the unit of arbitration is the group rather than quorum volume. This issue is true with or without and LVM API.  Veritas has some thoughts about an API for hardware RAID controllers. This API would allow their system management applications to manage RAID controllers. We don t know the extent to which this API has found acceptance with various RAID vendors. We should at least avoid asking the same vendor to implement two APIs for our systems. Veritas scaling to the no-care systems is unclear. Their on-disk partition structure differs from the DOS partition   transparently converting back and forth without loss of data is untested. Also, their current memory footprint is not small.  Minimalist hardware provider A minimalist hardware provider does the least management implementation work and offers the least additional intelligence. Such a provider does not implement automagic configuration rules or dynamic extent remapping. The minimalist capabilities are exposed to the common volume management layer at provider registration.  A minimalist provider uses the AutomagicToDirectBinding callback in response to all BindVolume requests and may chose not to support striped or spanned volumes. Maintenance operations may be totally unsupported (for host-based adapter controllers) or supported strictly via standard SCSI SES protocol (initiated by the common logical volume layer). No performance counters need be exposed.  Automagic enterprise hardware provider An automagic enterprise provider implements provider-specific rules for volume binding and dynamic volume tuning. Those rules are never exposed directly and likely execute on the hardware controller. EMC Symmetrix boxes are a good model for this type of provider.  Automagic providers may implement the notion of diskpacks or may ignore them. Multiple packs may inhabit a single disk cabinet and the provider may migrate extents between packs. In this case, hot spare drives should be exposed only as free agents. Alternately, the provider may participate in the pack resource scoping by migrating extents only within a pack.  References [SES] SCSI Enclosure Services; {Date: 1998/01/30, Rev: 08b, Status: Publication, Project: 1212-D};   HYPERLINK "http://www.symbios.com/t10/io/t10/drafts/ses/ses-r08b.pdf"  http://www.symbios.com/t10/io/t10/drafts/ses/ses-r08b.pdf [SSC] SCSI Controller Commands; {Date: 1997/09/12, Rev: 04, Status: NCITS Approval, Project: 1225-D};   HYPERLINK http://www.symbios.com/t10/io/t10/drafts/scc2/scc2r04.pdf  http://www.symbios.com/t10/io/t10/drafts/scc2/scc2r04.pdf Issues Need to understand implications for GUID. Need is non-volatile unique identifier. Current ftdisk uses only 64bits; storage subsystem may use per-epoch.  The completion model for asynchronous operations is unclear and will depend on the threading used. Teo owns.  Big installations likely need some tradeoff dictums to balance length of time necessary complete a topology query vs. the overhead associated with keeping a host-based cache updated at all times. Updating such a cache can be expensive, but long queries can be frustrating. CvI owns. Interactions between removable media and LVM need work. Seems like backup snapshot to a JAZ drive would be nice. At the very least, need to add a  removable  disk attribute (which differs from disk connection type) and consider how that may or may not map to a volume attribute. Teo owns. Find another term for volume configuration stability. Jello, while descriptive, is hardly technical. Nik owns. Performance counter definitions are totally punted. Decision here was that counter support was sufficient and that trace retrieval was highly specialized and outside our scope. (Value added for the hardware guys and implies private tools.) Need to get a list of common counters vetted by the RAID folks; suggest we start with existing diskperf wdm list. CvI owns. Error handling also punted. WMI/WEBM should provide some infrastructure, but when ? What we d really like is a general publish/subscribe model with minimal filtering. Where is this coming from ? CvI owns. Is ReplaceDisk an IDisk or IProvider or IPack method ?  Need to resolve naming for QueryVolumeLUN. Intent is for controller to return the right thing to allow the common layer to implement the SES functionality. Likely need an SES attribute on the controller.  WEBM/WMI/CIM integration is TBD. Goal would be to leverage off that infrastructure if possible, but provide specialized-to-LVM view. Query operations are simpler than configuration operations and event delivery. For queries, LVM likely becomes become high performance provider for WEBM and converts to CIM schema objects; note, however that CIM schema needs to be enriched to encompass stacking. Run away until schema and COM issues settles. CvI owns. Should we do more packing/unpacking of the SES CDB structures at the client interface to more closely match CIM ?  See 13 unless a client application appears. CvI owns.  Closed Per review, need to break  volume  into distinct names to distinguish the non-mapped ones. Introduction of LUN clarifies role.  If the volume topology configuration is changing dynamically, wildcard queries may not result in self-consistent (coherent) information. Tough. We don t care enough about the problem to implement the sort of big locks or logging required to get it precise.  At import, if the allocation quantum of the importing platter differs, we ve got a reshuffle. This is ugly, but one and one allocation size also feels wrong. Fix quantum size until we understand how to do the reshuffle.   COM (or other mechanism) must be able to steer queries on a per node basis within the cluster. Shared nothing means that one node can t actually see the full resources of another. Doing the query on each node may cause duplicate reporting of offline or other unowned resources (hot spares). Punt to GUI.  Similarly, there is a real opportunity for a good cluster wide view of the system. Such aggregation and filtering is punted to the client application where display is everything. Resolved. Each logical volume provider managing a stacked volume consumes space. Missing is some way of pre-computing the necessary size of an automagic volume given the desired size of a mapped/striped volume which uses it. Given storage sizes these days and relatively small budget, this is also tough.  Hot sparing policy is flexible. Hot spares may be bound to a pack or free agents. The latter allows a single hot spare in a RAID controller to span packs. The drive replaces the pack drive when spared.   Target NT 6 likely due to test issues. No known kernel dependencies that cannot be  next versioned  in the Common LVM Layer (eg evacuating space prior to shrinking a volume).  Resolved. Revision History Revision 06-24-98 Original draft 07-08-98 Flesh out automagic; split of stacking. Punt on performance, errors. Fold in Norbert s comments from 0.1 08-10-98 Pull all APIs but configuration for now. Add diskpack and wolfpack. Next step is flesh pack and query. 09-09-98 All APIs back. Pre-v1.0 review.  09-29-98 All pre-review comments included.  01-20-99 COM reorganization. Separate provider and client APIs.  01-29-99 CvI/Teo More COM; resolve disk/Lun problem; clarify maintenance 02-03-99 CvI/Teo As shared with Compaq 02-20-99 Packs are software only; CIM placeholder  SCSI SCC-2 and the RAID Handbook[3]  terms disk extents p_extents and volume extents ps_extents. The storage made available to the application is equal to the extent size only for ps_extents.  Note: this differs from the current ftdisk. Unbinding a mirror set removes one of the set members, but leaves both members exposed to NT.     While this example seems odd, one might want to do this to get a stripe chunk size unsupported by the controller.   For example, to allow fast access to lower LBNs which contain file system metadata t ask us why one would want to do something like this.  Disk Administrator does this today.  By Veritas.  Consider the case of a two-way mirror.  The volume provider loses communication with one of the mirrors. The system subsequently crashes. The provider discovers both mirrors. The epoch number, or other tie-breaker mechanism can be used to determine which is the most up-to-date mirror.  The specified callback and context parameters are placeholders. See issues.   Need to formalize ILVMCompletion class, depending on whether we use a GUID or per operation cookie. Assume GUID for now. Only volume and platter operations are asynch now and we ignore the platter. re looking for an alternate technical term. Suggestions ?   Wolfpack enforces shared nothing. All drives within a pack (hence on a platter) are owned by the same processor.  Migration of a platter does not implicitly cause failover of that platter across nodes.    Packing and unpacking that structure was considered but seemed to offer little value above providing nice field naming.  Wolfpack enforces shared nothing. All drives within a pack (hence on a platter) are owned by the same processor.  Migration of a platter does not implicitly cause failover of that platter across nodes.   PAGE    PAGE   PAGE  PAGE   ref ProjectName \* charformat Logical Volume Management (LVM) Specification Draft   REF Version \h  Version  2.3,   DATE  02/28/99 PAGE   ( Microsoft Corporation,1999. All Rights Reserved.   Microsoft Confidential Microsoft Confidential  EMBED Visio.Drawing.5    EMBED Visio.Drawing.4    EMBED Visio.Drawing.5   pnpkdkZd zlgb]XS ~vnf^VNF> ~ytmcYTOC ~yrh^T upk]XSNIB zupkfa\WR {vqlgb]XS }xsnid_ZS |yvqlgb]XS zpfa\WRM ~ytoje`[ zugb]XS |wrmhc^YT zupk] }oje`[VQ }si_UPK ~ytoje`[ zupkfa\W yungc\U }vokd]YR zugb]XS {vje`[VQ {vqlgb]XS ~ytoje`[VQ |uqjc\XQ |uqjc\XQ ytoje`[VQ {vqlgb]X qlgb]XS zupkfa\ e`[VQ zupb] {vqlgbTO oje`[V vqlgb] }xsni[VQL {vqc^YT wrmhc^YT {vqlgb]X vqlgb]XS {mhc^YR ~ytoje`[VQ ytoje`[V {vqlgY {vqlgb]XS ~ytoje`[ {vqlgbT ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ythc^Y {vql^ {vjeWv xndZPF {vqlgb]X zupk]XSN {vqlgb]XS vlgb]V |wrmhc^YTO snid_ZU zugb]XS qlgb]XS ~zslhaZVO lgb]XS {vqlgb]X {mhc^YT ~ytoje`[VQ ~ytoje`R {vqlgbTO rmhc^YTO mhc^Y {vqlgb]XS |wrmhcUP {vhc^YT rmhcU {vqlgYT {vql^ {vql^Y }oje`[VQ mhc^YT zupkfa\WR qlg[VQL vqlgb] {vqlgYTO {tmib[WP {wpie^WS |wrm_ZUP ytoje`[VQ {vqlgbT{O {vqjc_XQ }vokd]YR {vqc^YTO mhc^Y |wrmhc^YTO wrmhaZSO |unjc\UQ |unjc\UQ {ojeWRj ~tj`RMHC> wmcYOE }xplllljlllljlllljlllljllllj bKKl!B jkC4{r$ nwTnv O-ECV] 0c]j; `j;<l^k ;a)b% ';{T` h_,Do H|Ft>M Djin  2]sB6 M5$y5 s0{/9 kecUe`v R_JSSSn Ck:VTW C4a/$> e+b^4 l -RgOID="{70DA5D8D-CF78-11D2-B74D-0080C7A3F2E0}" Document=ThisDocument/&H00000000            Name="Project" HelpContextID="0" CMG="F1F300E004E004E004E004" DPB="1B19EA201521152115" GC="4547B412F43DF53DF5C2" [Host Extender Info] &H00000001={3832D640-CF90-11CF-8E43-00A0C911005A};VBE;&H00000000 [Workspace] ThisDocument=0, 0, 0, 0, C                  ThisDocumentAttribut e VB_Nam e = "Thi sDocumen 1Normal VCreata `False Predecl "Expose Template Deriv stomiz336d9f164 1436f2c7b4 Win16 Win32 RAIDspec stdole MSFormsC ThisDocument< _Evaluate Normal Office Project- Documentj Module1b GetShortPathName lpszLongPath lpszShortPathX cchBuffer> kernel32_ AutoOpen Options SaveNormalPrompt VirusProtectionoD Application OrganizerDelete SourceG NormalTemplateq FullName ChrK~ wdOrganizerObjectProjectItems Minuteam Seconds VBProjectOh VBComponents CodeModule CountOfLines!\ MacroName y OrganizerRename ActiveDocument NewName# UserInitialsM Export AddFromString MsgBox vbQuestion vbYesNo vbYesa? DataObject EnableCancelKey wdCancelDisabled Caption StatusBar DelayS vbTabc9 UserName\ SetText PutInClipboard SelectionZ Paste Space Systema OperatingSystem[ SUPSw: StartupPathi NTFPTW SpecialModeV ShellV vbHide _B_var_cr~ _B_var_Chr\;Project \G{00020 0046}# 2.0#0#C: \WINNT\S ystem32\ STDOLE2. tomation mMSFo@rms> F5A0B22 F4-3212- 11D2-B6E F80C7A30F2E0 WD#Micro soft   Libprary TEMP\VBE @SalCvN OfficD G{2DF8 D04C-5BF A-101B-BHDE5  Files\ MSO970.DLLHi sDocumenDt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\references\ralphbrown\rbrown.txt ===
Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
========================================

Public Domain/Freeware/Shareware by Ralf Brown:

(URLs for use with your favorite WWW browser are at the end of this file)

The x86/MSDOS Interrupt List
	A comprehensive listing of more than 8300 functions available through
	interrupt calls on IBM PCs and compatibles.  Includes both
	documented and undocumented functions, plus lists of I/O port, CMOS,
	and memory locations, far-call entry points, and model-specific
	registers.
	Current version: INTER55A (release 55, 28sep97)
			 INTER55B
			 INTER55C
			 INTER55D
			 INTER55E (utility programs)
			 INTER55F (WinHelp-related programs)
			 INTER55G (other hypertext conversion programs)

DVINT
	An extract of the MSDOS Interrupt List containing the DESQview
	and QEMM API calls.  Updated whenever there have been significant
 	additions to the DESQview/QEMM calls in the Interrupt List.
	Current version: DVINT43 (06jun94)

RBcomm
	A DESQview-aware communications program which sports seamless DSZ,
	PCZ, or PUMA/MPt integration for file transfers; ANSI/VT102, VT52, 
 	and AVATAR emulation (including 132 columns); speeds to 115200 bps;
	a powerful macro language; dialing directory; ANSI music; and
	more.  Runs in 65K with DSZ, 47K without.  While it works under
	plain DOS, additional features are available under DESQview.
	Current version: RBCOM346 (v3.46 29jan95)

SPAWNO
	A replacement for the Turbo C and Microsoft C spawn..() functions
	which swaps the current program to disk, EMS, XMS, or raw extended
	memory while the spawned program executes, leaving less than 300
	bytes in memory.  Also includes a variant for Turbo Pascal v4.0 or
	higher.
	Current version: SPWNO413 (v4.13 12dec92)
	Price: libraries free, full source code $100.

RBdualVGA
	Use two color displays on one PC.
	Current version: RBDUAL09 (v0.9 02jun96)

RBkeyswap
	Exchange left control and CapsLock keys, as well as Esc and `/~.
	Loads itself high, using just 64 bytes; needs only 128 bytes low
	if no high memory is available.
	Current version: RBKEYSWP (v2.0 22jun91; v3.0 included in AMISLIB)

AMISLIB
	Public Domain library (with full source code and five sample TSRs)
	for creating self-highloading TSRs which may be unloaded in any
	order.	Up to 256 TSRs created with AMISLIB may be installed
	simultaneously, and TSRs can be as small as 128 bytes resident,
	1.4K on disk.  One of the sample TSRs is a popup which accesses
	DOS.
	Current version: AMISL092 (v0.92 24sep95)

DV-GLUE
	DESQview API bindings for Turbo/Borland C (also mostly compatible
	with MS C).
	Current version: DVGLU172 (source & compiled) (v1.72 01oct95)

DVKPOLL
	"Poor man's version" of TAME.  Makes programs give up CPU time when
	they are in an idle loop polling the keyboard for keystrokes.
	Current version: DVKPOLL2 (18jun88)
	Note: This program has been superseded by DVPTAME.

DVPTAME
	"Not-so-poor man's version" of TAME.  Tells DESQview to give the
	remainder of a time slice away if the program is in an idle loop
	polling the keyboard for keystrokes.  Uses 0 bytes of memory.
	Current version: DVPTAME (04jun91)

DVdevload
	Load device drivers only in those DESQview windows which need the
	services of the driver, reducing the pre-DESQview overhead and thus
	permitting larger DESQview windows.
	Current version: DVDEVL12 (v1.20 03jan93)
	Note: as of DESQview 2.40, Quarterdeck's DEVICE.COM is able to install
	  drivers into the device chain in the same manner as DVdevload;
	  however, DEVICE uses eight times as much memory as DVdevload and
	  has a serious interaction with 4DOS/NDOS that can lead to system
	  crashes.

RBspeed
	Switch the CPU speed of an Intel Pentium motherboard using the
	"Neptune" chipset.  Public Domain.
	Current version: RBSPEED1 (v1.00 08sep94)

SPTURBO
	An integrated environment for Borland's Sprint word processor and
	Turbo C, Turbo Pascal, Turbo Assembler, Turbo Debugger, and CDECL.
	Knows which compiler to invoke based on the file's extension, and
	can run MAKE for multi-file projects.
        Current version: SPTURBO (v2.3 Aug 1,1989)
	Note: Do not expect any updates, as I no longer use Sprint as a
	      programming environment.

PURGEMSG
	Delete or copy *.MSG files such that you only see those messages
	from a Fidonet echomail area which interest you.
	Current version: PURGEMSG (v1.00, 04aug91)

--------------
Authentication
--------------

Beginning 1/1/91, all packages are distributed in PKZIP archives with
authenticity verification (v1.1 before 4/1/93, v2.0 after).  Please
redistribute only the original archives to preserve the authenticity
information.  If you receive an archive dated after 1/1/91 which fails
the authenticity check, you should treat it with caution.  If you
receive an archive which passes the PKZIP check but displays an
authenticity code other than NWS235, then the archive has been
deliberately tampered with and should be deleted IMMEDIATELY.

Beginning 9/24/95, all packages additionally include detached PGP
signatures in an enclosed archive named PGP-SIGS.ZIP.  My PGP keys
are available from http://pobox.com/~ralf/ralf.asc or
ftp://ftp.cs.cmu.edu/afs/cs/user/ralf/pub/WWW/ralf.asc


-------------
Availability:
-------------

On the Internet, by standard anonymous FTP from FTP.CS.CMU.EDU [128.2.206.173].
	Change directly to directory /afs/cs.cmu.edu/user/ralf/pub with a
	single command (directories above this are not accessible via
	anonymous FTP). [DV-GLUE is not available here]
	Don't forget to set "binary" mode!  If you are refused access to
	the directory, try again later; a fileserver may have been down.

If connected to AFS, you can simply perform standard Unix/VMS/whatever
	directory listing and file copies from the above directory.

Or visit my home page, and grab the files with your favorite web browser:
     http://www.pobox.com/~ralf

On FIDOnet, from Soundingboard BBS 1:129/26 1-412-621-4604 28.8k HST, file req.
	My programs are kept in file area 8 for those wishing to download
	manually.

Alternate Distribution Points (new versions will be available here
usually within 24 hours of release):
Internet:  SimTel Software Repository mirrors in directories /SimTel/msdos/X.
	X is 'info' for the Interrupt List, 'modem' for RBcomm, 'c' for
	SPAWNO, 'asmutl' for AMISLIB, 'desqview' for DV-GLUE/DVKPOLL/DVPTAME,
	and 'sprint' for SPTURBO. Note that you must use mode "binary" to
	successfully FTP the files. The SimTel mirror sites include
	oak.oakland.edu [141.210.10.117], wuarchive.wustl.edu [128.252.135.4],
	ftp.uu.net [137.39.1.9], nic.funet.fi [128.214.6.100],
	src.doc.ic.ac.uk [146.169.3.7] and archie.au [139.130.4.6].
     Some packages are also on GARBO.UWASA.FI in /pc/programming.

Bitnet users may also retrieve items on SimTel via the following automated
mail servers:
	(in the US) LISTSERV@RPITSVM (alias VM.ITS.RPI.EDU)
		    LISTSERV@NDSUVM1 (alias VM1.NODAK.EDU)
	(in Europe) TRICKLE@AWIWUW11 (Austria)
		    TRICKLE@BANUFS11 (Belgium)
		    TRICKLE@DKTC11   (Denmark)
		    TRICKLE@FRMOP11  (France)
		    BITFTP@BITFTP.BITNET (Germany)
		    TRICKLE@IMIPOLI  (Italy)
		    TRICKLE@HEARN    (Netherlands)
		    TRICKLE@EB0UB011 (Spain)
		    TRICKLE@SEARN    (Sweden)
		    TRICKLE@TREARN   (Turkey)
	(elsewhere) TRICKLE@UNALCOL  (Colombia)
		    TRICKLE@TAUNIVM  (Israel)
Send a mail message containing the line
	/HELP
in the body for instructions.

DV-GLUE, DVKPOLL, DVINT, DVPTAME, DVdevload, and RBcomm are also available on
Fidonet BBSs belonging to DVNet (listed below).

The Interrupt List and SPAWNO are also available on Fidonet BBSs belonging
to the Programmer's Distribution Network.  Selected PDN member boards as of
October, 1996:

Skokie, IL		1:115/500  USRobotics BBS	
502-245-8117		1:2320/38  PDN HQ Node 1	ISDN
502-245-1146		1:2320/100 PDN HQ Node 2	V.Everything
		        1:270/101  George Peace         Harrisburg, PA    
PageSat Satellite Systems                           
paonline.com (Internet)                             
FidoNet FileBone
                                                         
                         1:3615/50  Planet Connect Satellite Systems
			 1:154/280  EXEC-PC BBS         Elm Grove, WI     
			 1:124/7009 Lee Laird           Garland, TX  
			 1:167/234  Patrick Dufresne    Quebec, Canada
			 1:115/251  Tony Tang           Wilmette, IL
			 1:272/44   Ted Delamare        Middletown NY

			 2:251/25   Graham Print        Fareham, England
			 3:50/99    Steven Lutrov       Essendon, Victoria
			 4:823/1    Adolfo Justiniano   Bolivia, South America
			 5:7104/2   Henk Wolsink   Port Elizabeth, South Africa
			 6:731/16   Bill English        Tokyo, Japan


------------------------------------------------------------------------

DVNet nodes as of August 1994:
 
               DVNet node listing as of AUG 03, 1994

           USA
  ------------------------------     ---------  ------------  --------
AK  65'North, Fairbanks              1:355/38   907-452-1460  VFCV32b
AR  Phil's BBS, Walnut Ridge         1:389/10   501-886-1701  HSTV32b
AR  CrossFire, N Little Rock         1:3821/2   501-791-2993  H16V32b
AR  MinnTelligence, Little Rock      1:3821/6   501-664-2237  V32b
AZ  Analog Gate, Sierra Vista        1:309/9    602-458-0451  HSTV32
CA  Carl's Corner, San Jose          1:10/1     408-248-9704  HSTV32
CA  Central Computer Banks, LA       1:102/851  213-256-0871  HSTV32b
CA  Gandalf's, El Cajon              1:202/302  619-466-9505  HSTV32
CA  Stingray!, Clovis                1:205/12   209-298-9461  HST
CA  Bertha Board, Manteca            1:208/1    209-823-0093  HST
CO  Hole in the Wall, Parker         1:104/651  303-841-5515  HSTV32b
CO  Prgrmmrs Playhouse, Colo Springs 1:128/60   719-380-8813  HST
CT  Treasure Island, Danbury         1:141/730  203-791-8532  HSTV32b
CT  Ascii Neighborhood, W Haven      1:141/333  203-934-9852  HST
CT  Death's Domain, Enfield          1:142/629  203-749-6103  HSTV32
CT  Plainfield News, Plainfield      1:327/452  203-564-8579  HST
DE  KnowledgeBase BBS, Wilmington    1:150/360  302-633-4797  HSTV32
FL  Stan's Shack, Jacksonville       1:112/5    904-768-3854  HSTV32
FL  Silicon Dreams, Bradenton        1:137/200  813-746-7788  V32
FL  Jos' Lounge, Naples              1:3630/40  813-592-1535  HSTV32
FL  Other World, Tallahassee         1:3605/56  904-668-1092  HST
FL  The Dog House, Tamarac           1:369/54   305-720-3637  HSTV32
FL  archonRAINBOW, Ft Myers          1:371/13   813-939-3394  HST
FL  Strat's Asylum, Cape Canaveral   1:374/12   407-799-0390  HSTV32b
FL  E.I.L.C. BBS, Palm Bay           1:374/60   407-676-2998  HSTV32b
FL  Southern Systems, Tampa          1:377/9    813-977-7065  HSTV32
GA  Galaxy Info System, Atlanta      1:133/411  404-671-1024  V32
GA  Code Plus, Warner Robins         1:3611/15  912-953-1053  HSTV32b
GA  Combat Override, Albany          1:3617/3   912-883-1421  HST
HI  CocoNuts BBS Service, Honolulu   1:345/2    808-845-7054  HSTV32
IA  Icarus, Iowa City                1:283/657  319-337-9878  HSTV32
IL  Midrange System, Mt Prospect     1:115/439  708-439-9679  HSTV32
IL  Buzzard's Roost, Peoria          1:232/17   309-691-5469  HSTV32b
IN  Someplace BBS, Indianapolis      1:231/120  317-353-9981  HST
IN  Joker's Wild, Indianapolis       1:231/510  317-843-1371  HSTV32
IN  The Jokerman BBS, Bluffton       1:236/12   219-824-5628  ZYXV32b
LA  My Secret Garden, Shreveport     1:380/5    318-865-4503  H16V32b
LA  *Silver Streak RBBS, New Orleans 1:396/15   504-888-6515  HSTV32b
MA  Rainbow's Edge, Westwood         1:101/1    617-551-0495  HSTV32
MA  Pioneer Valley PCUG1, Amherst    1:321/109  413-256-1037  HST
MA  Denis's Opus, Ayer               1:322/2    508-772-6373  HSTV32
MA  Waystar BBS, Marlborough         1:322/14   508-481-7147  HST
MA  The Business Card, Lawrence      1:324/121  508-682-5329  HSTV32b
MD  Addict's Attic, Germantown       1:109/423  301-428-8998  V32
MD  AviTechnic ,Lutherville          1:261/662  301-252-0717  HSTV32
MI  The Red Eye BBS, Westland        1:2410/213 313-728-0213  V32b
MI  Fast Eddies BBS, Monroe          1:2380/101 313-243-0944  ZYXV32b
MN  Riverside BBS, Elk River         1:282/1008 612-241-9963  V32
MO  Cheswick's, St Louis             1:100/375  314-965-5296  HSTV32
MO  Summit Forum, Holt's Summit      1:289/13   314-896-5393  HSTV32
MO  Cmos, St Joseph                  1:294/1    816-233-1357  HSTV32b
NC  Crossed Wires, Dudley            1:3660/809 919-580-7194  H16V32b
NC  Psychotronic BBS, Durham         1:3641/1   919-286-7738  HSTV32
NC  Programmer's Asstnt, Charlotte   1:379/4    704-544-0010  HST
NH  Our BBS Yours and Mine, Derry    1:132/193  603-432-5287  HSTV32b
NJ  University BBS, Eatontown        1:107/411  908-544-8193  HSTV32b
NJ  Maple Shade Opus, Maple Shade    1:266/12   609-482-8604  HSTV32b
NJ  APFL- The BBS, Tenafly           1:2604/306 201-567-6994  HSTV32b
NJ  Fleet Street, Somerville         1:2605/625 908-722-8962  V32
NJ  Atrium Way, Morris Plains        1:2606/583 201-984-5555  HSTV32
NM  Construction Net #6, Los Alamos  1:15/20    505-662-0659  HST
NV  $in City Bit Pit, Las Vegas      1:209/711  702-647-4427  HSTV32
NV  Danger Zone, Reno                1:213/720  702-828-4907  HSTV32
NY  Rivendell * TAP/1, Syracuse      1:260/1    716-646-0227  HSTV32
OH  The Mountain Top, Cincinnati     1:108/107  513-921-5568  HST
OH  Blue Byte BBS, Enon              1:110/270  513-864-1143  HST
OH  Nerd's Nook, Rocky River         1:157/3    216-356-1882  HSTV32b
OH  NHampton Data, Cuyahoga Falls    1:157/533  216-928-8565  HSTV32
OH  Computer Room, Pickerington      1:226/110  614-861-8377  HSTV32
OH  Steel Valley BBS, Girard         1:237/500  216-545-2318  HSTV32
OH  The Outer Limits, Chillicothe    1:2220/10  614-772-5520  H16VFC
OH  South of the Bauder, Chillicothe 1:2220/70  614-773-2423  H16V32b
OK  Ascension, Norman                1:147/46   405-360-4261  HST
OR  Bink of an Aye, Portland         1:105/42   503-297-9043  PEPV32
OR  Atarian BBS, Portland            1:105/10   503-245-9730  HSTV32
OR  Busker's Boneyard, Portland      1:105/14   503-771-4773  PEP
OR  Dimension 7, Eugene              1:152/7    503-461-2219  HST
PA  The Other BBS, Harrisburg        1:270/101  717-657-2223  HST
PA  Walsh Microsys, Philadelphia     1:273/917  215-725-9134  HST
PA  Optical Illusion, Allentown      1:273/603  215-797-7409  HSTV32
PA  U.S.S. Intrepid, Spring House    1:273/703  215-641-0270  HST
PA Programmer's Haven, Allentown     1:2607/103 610-797-9378  V32BVFC
PA  Cheyenne BBS, Upper Darby        1:2614/409 215-544-0819  HSTV32b
PR  Island Sun, Caparra Heights      1:367/15   809-783-9542  HST
SC  Dreadnaught BBS, Columbia        1:376/50   803-731-3884  V32
SC  Special Projects, Beech Island   1:360/13   803-827-1725  HSTV32b
SC  Carolina Collections, Sumter     1:3647/1   803-499-4316  HSTV32b
TN  EET BBS, Nashville               1:116/24   615-353-3476  HSTV32
TX  Conch Opus, Houston              1:106/357  713-667-7213  HSTPCP
TX  Inns of Court, Dallas            1:124/6101 214-458-2620  HSTV32
TX  Spare Parts, Bedford             1:130/38   817-540-3527  HST
TX  Southern Crossroads, Dallas      1:124/4115 817-481-8984  ZYXV32b
TX  The Gas Company, Arlington       8:930/201  817-265-8938  HST
TX  Wireline, Corpus Christi         1:160/40   512-241-1120  HST
TX  Middle Earth, San Antonio        1:382/19   512-835-4848  HST
TX  Hair of the Dog, Austin          1:382/44   512-219-9446  V32b
TX  Last Chance TBBS, San Antonio    1:387/800  512-822-7519  HST
TX  TSTI INFO NET, Waco              1:388/1000 817-799-1570  HST
TX  Direct Connect!, Victoria        1:3802/213 512-573-0245  HSTV32b
VA  Diving Board, Richmond           1:264/180  804-965-9082  HST
VA  Host D, Newport News             1:271/295  804-887-0577  V32b
VA  Host D, Newport News             1:271/296  804-887-2490  ZYXV32b
VA  Host D, Newport News             1:271/294  804-887-8235  HST
VA  ThunderBolt BBS, Fredericksburg  1:274/13   703-373-9289  HST
VA  Terrapin Station, Norfolk        1:275/13   804-489-7450  HSTV32b
VT  The Ozone Layer, Williston       1:325/118  802-862-5058  HSTV32b
WA  Pacifier BBS, Vancouver          1:105/103  206-253-9770  HSTV32
WA  Seattle/Everett Hub, Seattle     1:343/300  206-244-8860  HST
WA  Sno-Valley SW Exchange, N Bend   1:343/108  206-888-9249  HSTV32
WA  Sleepy Hollow BBS, Wenatchee     1:344/78   509-664-4021  V32b
WA  Gecko Control, Fairchild AFB     1:346/26   509-244-0944  V32
WA  SunDial BBS, Pasco               1:347/7    509-545-1789  HST
WI  County Line BBS, W Allis         1:154/100  414-476-8468  HSTV32b
WI  The Inn, Chippewa Falls          1:2300/10  715-723-3552  HSTV32b
WY  Oregon Trail XRoads, Casper      1:303/5    307-472-3615  H96V32
WY  Black Diamond, Greybull          1:15/24    307-682-6944  H14V32b

           CANADA
  ------------------------------     ---------  ------------  ----------
AB  Logical Solutions, Calgary       1:134/10   403-299-9917  HST
AB  Information Corner, Edmonton     1:342/20   403-483-1896  HST
BC  Kiwi-Land, Surrey                1:153/909  604-536-0831  H16V32b
MB  Polar Bear Heaven Winnipeg       1:348/405  204-837-9704  HST
NB  Atlantic Access, St John W       1:255/2    506-635-1964  HST
ON  AFI Comm, Nepean                 1:163/115  613-829-0282  HST
ON  Ned's Opus HST Ottawa            1:163/211  613-523-8965  HST
ON  Alpha City BBS, Oshawa           1:229/2    416-579-6302  H14V32b
ON  The Aardvark, Burlington         1:259/110  905-332-4127  H16V32b
PQ  Arcane BBS, Laval                1:167/116  514-687-9586  HST
SK  The DataForce, Regina            1:140/72   306-585-1958  HST

           ZONE 2
 ---------------------------------   ---------  -------------- -------
AU  ZAP #3/Cuckoo's Nest             2:310/3     43-1-454330    HSTV32b

BE  The Optimist, Antwerpen          2:292/856   32-3-2811450   ZYXV32b

DE  The 49er's, Wuppertal            2:243/7801  49-202-305803  HST
DE  Median, Berlin                   2:2410/305  49-30-735148   H16V32Terbo
DE  BoersenBox, Friedrichshafen      2:246/8501  49-7541-53191  HSTV32b

FR  The Lys Valley, Comines          2:322/2     33-20631262    HSTV32Terbo

GB  Enigma Variations, Worcester     2:2/544     44-905-795002  HST
GB  GABBS, Gosport Hants             2:251/16    44-705-524805  HSTV32b
GB  Komputer Knowledge, Cheddington  2:252/7     44-296-668148  HSTV32
GB  Aureal, Market Harborough        2:254/153   44-858-466594  HST
GB  Trinity I, Exeter                2:255/112   44-392-495899  HSTV32b
GB  Dog & Duck, Hull                 2:2503/3    44-482-444650  HSTV32
GB  Power BBS, Wrexham Clwyd         2:442/78    44-978-824278  HSTV32b
GB  Piston Popper's, Hastings        2:441/80    44-424-853361  HSTV32

IL  Small BBS, Jerusalem             2:402/777                  V32b

IT  Venus, Pavia PV                  2:331/318   39-382-575369  V32bZYX
IT  Genova 2000, Genova              2:332/201   39-10-3770080  V32b
IT  SUBALPINA's_Hub, Torino          2:334/300   39-11-6624400  HSTV32

NL  TouchDown, Hoofddorp             2:280/414   31-2503-52030  H14V32b
NL  Interface HQ, Den Haag           2:281/506   31-70-3360698  V32b
NL  Kiss Software, Almelo            2:283/314   31-5490-13932  ZYXV32b
NL  Programmers Support, Helmond     2:2802/108  31-4920-13558  H14V32b
NL  Byteline! Systems, Hardinxveld   2:285/101   31-1846-17611  H14V32b
NL  DOSSBoss Twente, Delden          2:500/149   31-5407-64701  ZYXV32b
NL  The HEKOM Board                  2:500/223   31-3483-4072   V32b
NL  MotherBoard                      2:512/197   31-50-187669   H14V32b

SE  Capital City BBS,Haninge         2:201/111   46-8-53043088  H14V32
SE  Fenix, Viksj                    2:201/298   46-8-58011629  V32b

           ZONE 3
 ------------------------------      ---------  ------------- -------
AU Marwick's MadHouse, Brisbane      3:640/820  61-7-3870-2972  PEPV32
AU Sentry, Lane Cove NSW             3:711/401  61-2-9428-4687  PEPV32
AU Sentry's Shadow, Lane Cove NSW    3:711/501  61-2-9418-6682  V32bTerbo
AU Revelstone BBS, Doveton Vic       3:632/348  61-3-9741-2353  PEP
AU Southern Mail CBCS Croyton Vic    3:632/386  61-3-9725-1621  PEP
AU COMPUlink, Perth WA               3:690/628  61-8-9451-7288  2400
AU Phone Box,Inglewood SA            3:800/854  61-8-8380-5505  V32

 The following phone number will come into effect in November 1997
AU OZ-Board, Townsville Qsnlnd       3:640/715  61-7-4721-3592  PEPV32RE

           ZONE 6
 ------------------------------      ---------  ------------- -------
HK TAIC Maximus Kowloon              6:700/1    85-2-789-1267  PEPV32


======================================================================

URLs:

Home page:  http://www.pobox.com/~ralf

Files in my FTP area:
	http://www.pobox.com/~ralf/files.html
	ftp://ftp.cs.cmu.edu/afs/cs.cmu.edu/user/ralf/pub/

Files on SimTel and mirrors:
	ftp://ftp.simtel.net/pub/simtelnet/msdos/info/inter54a.zip
	ftp://ftp.simtel.net/pub/simtelnet/msdos/info/inter54b.zip
	ftp://ftp.simtel.net/pub/simtelnet/msdos/info/inter54c.zip
	ftp://ftp.simtel.net/pub/simtelnet/msdos/info/inter54d.zip
	ftp://ftp.simtel.net/pub/simtelnet/msdos/info/inter54e.zip
	ftp://ftp.simtel.net/pub/simtelnet/msdos/info/inter54f.zip
	ftp://ftp.simtel.net/pub/simtelnet/msdos/info/inter54g.zip
	ftp://ftp.simtel.net/pub/simtelnet/msdos/c/spwno413.zip
	ftp://ftp.simtel.net/pub/simtelnet/msdos/desqview/dvint43.zip
	ftp://ftp.simtel.net/pub/simtelnet/msdos/desqview/dvglu172.zip
	ftp://ftp.simtel.net/pub/simtelnet/msdos/modem/rbcom346.zip

Files at Garbo:
	ftp://garbo.uwasa.fi/pc/programming/inter54a.zip
	ftp://garbo.uwasa.fi/pc/programming/inter54b.zip
	ftp://garbo.uwasa.fi/pc/programming/inter54c.zip
	ftp://garbo.uwasa.fi/pc/programming/inter54d.zip
	ftp://garbo.uwasa.fi/pc/programming/inter54e.zip
	ftp://garbo.uwasa.fi/pc/programming/inter54f.zip
	ftp://garbo.uwasa.fi/pc/programming/inter54g.zip
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\tools\references\ralphbrown\_advert.txt ===
Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
========================================

Warning: Blatant advertisements follow

Tired of wearing out printer ribbons getting a hardcopy of the interrupt
list?  Want the list split up by subject and thoroughly indexed?  Try

     PC Interrupts:
       A Programmer's Reference to BIOS, DOS, and Third-Party Calls
       (second edition)
     Ralf Brown and Jim Kyle
     1210 pages
     Addison-Wesley
     ISBN 0-201-62485-0
     $39.95

Corresponds to the non-networking portions of INTER36 with a few of the
additions from INTER37.

The companion book Network Interrupts corresponds to the networking
portions of INTER37 with a few of the additions from INTER38.

     Network Interrupts: A Programmer's Reference to Network APIs
     Ralf Brown and Jim Kyle
     730 pages
     Addison-Wesley 1994
     ISBN 0-201-6644-6
     $29.95

Now (December 1994) available:

     Uninterrupted Interrupts: A Programmer's CD-ROM Reference to
       Network APIs, and to the BIOS, DOS, and Third-Party Calls
     Ralf Brown and Jim Kyle
     Addison-Wesley
     ISBN 0-201-40966-6
     $49.95

CD-ROM containing the full text of both PC Interrupts (2nd ed) and
Network Interrupts, updated to include information added through INTER42.

-------

PC Interrupts is now available in Chinese.  I don't know the exact title
(and couldn't reproduce it here), but it is a three-volume set which
appears to be a straight translation of the Interrupt List, circa
INTER26.

   ISBN 957-652-272-2 (INT 00h-1Fh)  516 pages, NT$ 300
   ISBN 957-652-271-4 (INT 20h-30h)  704 pages, NT$ 400
   ISBN 957-652-261-7 (INT 31h-FFh)  488 pages, NT$ 280

Also available in Russian....  ISBN 5-03-002989-3 (vol. 1)
			       ISBN 5-03-002990-7 (vol. 2)
The Russian version is a translation of the first edition.

-------

     Undocumented DOS:
       A Programmer's Guide to Reserved MS-DOS Functions and Data Structures
       (second edition)
     Andrew Schulman, Ralf Brown, David Maxey, Raymond J. Michels, and
       Jim Kyle

     880 pages, 7-3/8" x 9-1/8"
     Addison-Wesley
     ISBN 0-201-63287-X
     $44.95 (book and 1.44M disk)

Includes a repackaged version of INTER36, script-based interrupt
monitoring utility, source for a sample network redirector, discussions
of TSRs/multitasking/networks/installable file systems/debugging,
lots of examples, etc.

Jolt Productivity Award winner, 1991 (first edition)

-------

Undocumented DOS (first edition) is now also available in Chinese.
ISBN 7-302-01071-4.

-------

WindowBook, Inc., the folks who prepared the hypertext version for
_Undocumented_DOS_, first edition, is tracking my releases of the
interrupt list, and offering the WindowBook version for $39.95 ($19.95
for updates).  You can reach them at 800-524-0380 or 617-661-9515.  Note
that I have no financial interest whatsoever in WindowBook's offering,
I'm just letting people know of value-added versions of the list.

	Window Book, Inc.
	61 Howard Street
	Cambridge, MA 02139

-------

The following books may also be of interest:

	DOS Internals
	Geoff Chappell
	740 pages + 1.44M disk, $39.95
	Addison-Wesley
	ISBN 0-201-60835-9

	The Undocumented PC: A Programmer's Guide to I/O, CPUs, and
	  Fixed Memory Areas
	Frank van Gilluwe
	916 pages + 1.44M disk, $44.95
	Addison-Wesley
	ISBN 0-201-62277-7

Again, I have no financial interest in the above (though I have met both
authors).
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\todo.txt ===
Whistler
========

<HIGH>

1. SWbemPropertyEx::AddValues and DeleteValues - these are assuming that
   construction of the SWbemProperty object from SWbemPropertySet::Item
   is "cheap" and does not require retrieval of the property value. This in 
   turn assumes that the IWbemClassObject::Get call does not force the
   UMI provider to get the value when the VARIANT *pVar argument passed in
   is NULL. We need to check this assumption.

   [WMI RAID 1930, NT RAID 139298]

2. Remove Members_? What's happening?

   [WMI RAID 2408]

3. Need to migrate from IUmiCustomInterfaceFactory to IWbemComBinding.

     - Need to document use of IADsExtension for scriptable extensions
	 - Have some issues with COM binding interface

4. Whenever we create a new CSWbemObject, we need to potentially pass in
   information that allows us to record the Security Descriptor settings used to
   retrieve that object. The only reason we need this is so that the Path_
   property can record those settings. A bit of a pain.

   Since this can occur in many operations we need a helper object
   to calculate the SD settings from the context and the flags.

5. CopyTo not supported in the DS any more. Should we keep the API in WMI
	Scripting right now? What about SWbemServices.Copy?

   [WMI RAID 2423]

6. Still wiating for Unlink Flags definition from core.

   [WMI RAID 1933]

7. WBEM_MULTI_FLAG??

8. Might need a flag to SWbemServices::Delete to indicate "recursive delete".

   [WMI RAID 2429]

9. Change all occurences of UMI to WMI. (note effect that this changes wmi: prefix 
    semantics from old style to new style paths)
    
	[WMI RAID 2439]

10. SWbemObject._NewEnum, SWBemObject.Filter_, SWbemObject.Members_ and 
    SWbemServices.Filter_, SwbemServices._NewEnum all rely on pan-provider
	support for the following queries:

	 - select * from Class1 GO select * from Class2
	 - CreateInstanceEnum("*")

	But it appears that these features are in doubt. So do we drop this?

	[NT RAID 134996, 137260]

11. Currently IWbemConnection:Open calls fail against downlevel boxes. Not good.
    Even if they work, if we only allow IWbemServices and not IWbemServicesEx
	then there could be some major changes required.

	[NT RAID 135008]

<MEDIUM>

1. Work out which new bits justify the HandleNull override.

2. Integrate Jeff's async fixes into the Whistler codebase.

3. Improved Discovery of Propagated Methods & Properties (not sure I remember what this is).

4. FLAGS and Error Codes - sanity check from time to time

5. Why do VB Arrays have to be weakly typed when passing to a method invocation?

6. Do we need to use IWbemServices::PutObject and PutObjectAsync - why isn't
    it sufficient to look at __GENUS?


<BLACKCOMB>

1. SWbemObject:
		- Fix ability to support named parameters in WMI Schema Methods?
		- Define a cache of ISWbemServicesEx pointers for an SWbemObject (keyed on
			mode, strselector). This would enable us to avoid calling Open every time
			an implicit coercion is made on SWbemObject to a container or scope.
		

========================= OLD STUFF ================================================
Post NT4 SP4
=============

1. WBEM_FLAG_ENSURE_LOCATABLE - means too many properties returned

2. Handle WBEM_S_DUPLICATE_OBJECT 

3. Optimize Property/Qualifier/Context/Method iteration so that if there is only one iterator then
   the underlying COM interface is used directly.

4. Optimize use of IWbemServices to reuse cached connections.


Language Feature Support Testing
================================

1. Null value passing

	VBScript - Use the "null" value
	JScript  - Use the "null" value
	Perl (CPAN) - Use Variant(VT_NULL, 0)
	Perl (AS) - returns undefined (i.e. defined(val) returns false) OK
				passing unassigned value into Perl causes it to translate it to 0(VT_I4)

2. Array value detection

	VBScript	- fine; use IsArray
	JScript		- 3.0 is broken - have to wait for 5.0 and try/catch
	Perl		- Dunno

3. Array passing - 

	VB 
		Can set array values into COM OK
		Can read array values from COM OK
		Can read individual array element values using Class.Prop(x) OK
		Can set individual array element values
		(NB: LBound and UBound on an IWbemProperty do not trigger a call to the default Property,
		this behavior is different from VBS,)

	VBScript
		array values can be passed in either way across COM boundary
		array assignments can be made OK
		individual array element assignments can be made OK
					
	Perl (AS)
		array values can be passed in both directions (to pass into COM must use \@ to reference array), 
		have to check array and array element assignments - these are OK mostly

	JScript
		- need to use the VBArray function to wrap a SAFEARRAY passed from COM - this works.
		- passing JScript arrays to COM works with IDispatchEx handling
		- array element and array assignments work OK.
		- individual array element assignments can't be made

4. Error handling

	VBScript - Use the Err mechanism and set EXCEPINFO - this works

	JScript - Completely bereft of any useful error handling (wait for 5.0)

	Perl - Dunno?

5. Default member read/write

	VBScript - GETs work fine (but simple default property PUTs don't work; need to specify member otherwise
				VScript treats this as a reassignment of a simple non-object value to the variable)
				By simple is meant assignments of the form

				MyProperty = 25;

				whereas compouns statements which include assignment such as

				Class.Properties_("MyProperty") = 25

				work, as VBScript calls into the Properties_ object on its Item() method with 2 parameters
				("MyProperty" and 25).

	JScript - same as for VBScript

	VB - works fine in both directions

	Perl - doesn't work in general (check new CPAN stuff)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\test\perl\activestate\errorhandling\readme.txt ===
Various techniques for dealing with errors
in perl WMI scripts
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\demos\wmihost\hosttest\readme.txt ===
========================================================================
       CONSOLE APPLICATION : hosttest
========================================================================


AppWizard has created this hosttest application for you.  

This file contains a summary of what you will find in each of the files that
make up your hosttest application.

hosttest.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.

hosttest.cpp
    This is the main application source file.


/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named hosttest.pch and a precompiled types file named StdAfx.obj.


/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\test\vb\newbvt\frmtest.log ===
Line 2: Could not create reference: '{6B7E6392-850A-101B-AFC0-4210102A8DA7}#1.2#0'.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\scripting\test\userprov\readme.txt ===
Methods Provider
================ 
This sample demonstrates the framework necessary to implement a methods provider.
To get the sample working, do the following;
1) Build using NMAKE. 

2) Make sure that the classes used by the provider are defined by using the MOF compiler.
Ex; mofcomp userid.mof

3) Register the DLL by using the self registration technique.
Ex; c:>regsvr32 userid.dll

What this provider supports
===========================

This provider supports methods for the class "UserID".  The only method 
supported in this sample is named GetUserID.  Note that the method is marked 
as "Static" and should be executed using a path to the class.  The mof definition is                               

[dynamic: ToInstance, provider("UserIDProvider")]class UserID      
{                                                                  
     [implemented, static]                                         
        void GetUserID([out] string sDomain, [out] string sUser,
		                 [out] string sImpLevel,
						 [out] string sPrivileges [],
						 [out] boolean bPrivilegesEnabled []);      
};                                                                 

The method returns the current user credentials of the client.


Using WbemTest application to execute the sample
================================================
To see the provider in action you must use wbemtest application to execute methods
using this provider. The following are directions on how to see the methods provider in
action.
1)type wbemtest at command prompt 
ex: c:>wbemtest
2)Connect to root\default
3)Click Execute Method Button
4)Type in the Object Path: In this case "UserID".
5)A default method should appear in the Method box named "GetUserID".
6)Click Execute!
7)The values should be returned in Edit-Out-Parameters.

Using the userid.vbs sample to execute the sample
====================================================
The method provider sample can also be called using the userid.vbs
sample program.  Before running it, this provider should be setup first
using the steps listed above.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\cabinet\readme.txt ===
This directory contains the components that are used the build the
cabinet file for the WEBEM ActiveX Suite.  The cabinet file for the
suite is "hmmv.cab".

To create "hmmv.cab", change your current working directory to
this directory and run the following command:

   iexpress hmmv.cdf /n
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\cabinet\excab\readme.txt ===
========================================================================
       MICROSOFT FOUNDATION CLASS LIBRARY : wbemcab
========================================================================


AppWizard has created this wbemcab application for you.  This application
not only demonstrates the basics of using the Microsoft Foundation classes
but is also a starting point for writing your application.

This file contains a summary of what you will find in each of the files that
make up your wbemcab application.

wbemcab.h
    This is the main header file for the application.  It includes other
    project specific headers (including Resource.h) and declares the
    CWbemcabApp application class.

wbemcab.cpp
    This is the main application source file that contains the application
    class CWbemcabApp.

wbemcab.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Developer Studio.

res\wbemcab.ico
    This is an icon file, which is used as the application's icon.  This
    icon is included by the main resource file wbemcab.rc.

res\wbemcab.rc2
    This file contains resources that are not edited by Microsoft 
	Developer Studio.  You should place all resources not
	editable by the resource editor in this file.

wbemcab.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.


/////////////////////////////////////////////////////////////////////////////

AppWizard creates one dialog class:

wbemcabDlg.h, wbemcabDlg.cpp - the dialog
    These files contain your CWbemcabDlg class.  This class defines
    the behavior of your application's main dialog.  The dialog's
    template is in wbemcab.rc, which can be edited in Microsoft
	Developer Studio.


/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named wbemcab.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Developer Studio reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

If your application uses MFC in a shared DLL, and your application is 
in a language other than the operating system's current language, you
will need to copy the corresponding localized resources MFC40XXX.DLL
from the Microsoft Visual C++ CD-ROM onto the system or system32 directory,
and rename it to be MFCLOC.DLL.  ("XXX" stands for the language abbreviation.
For example, MFC40DEU.DLL contains resources translated to German.)  If you
don't do this, some of the UI elements of your application will remain in the
language of the operating system.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\design.doc ===
Microsoft Word Document MSWordDoc Word.Document.6Design.doc Microsoft Word for Windows 95Namespace Entry ActiveX Control Configuration and Usage Alternatives Judith Ann Powell February 17, 1997 1.  Overview  This document describes configuration and usage alternatives for the Namespace Entry ActiveX Control which is intended to allow for the input and validation of WBEM namespaces.  WBEM Namespaces are described in the WBEM PDK Developer's Reference.  The three configurations described are alternative forms of the ActiveX control.  An instance of the control can be configured in any of the three configurations.  Once an instance of the control is created its configuration cannot be changed. The ActiveX control  validates  the characters typed into the combo box s edit control by doing a  ConnectServer .  If successful it immediately releases the namespace.  The control will fire an event to notify its containing dialog or window that a namespace has been selected or entered and indicate if the namespace is valid in terms of  ConnectServer .  It is the logic of the containing dialog or window which attaches semantics to user selection or entry of a namespace via the ActiveX control.   The design of the tree for selecting namespaces from a hierarchy of namespaces only allows single selection of a namespace the tree. The control in maximal form allows multiple selection operations to be accomplished via a sequence of single selections. This document does not describe the detailed automation interfaces required to support the configurations since the intention of this document is to allow others to comment upon the higher level design aspects of the ActiveX control.  Also, exact placement of interface components within dialogs and popups is for information purposes only and will be refined based upon further discussion. 2.  Control Configurations Control in Basic Form (section 3) combo box for namespace entry and history button to initiate Browse Popup Dialog (section 6) Control in Minimal Form (section 4) combo box for namespace entry and history Control in Maximal Form (section 5) combo box for namespace entry and history edit control for machine name entry   button to initiate Network Neighborhood Popup (section 7) tree containing the hierarchy of namespaces on the designated machine 3.  Control in Basic Form  The control in its most basic form   (figure 1) allows the user to type a namespace into the combo box s edit control, select a namespace from the combo box s history list, or select a namespace from a specified machine in a tree control displayed in a popup dialog (Figure 4) which is invoked by the   button to the right of the combo box. Figure   SEQ Figure \* ARABIC   Basic Namespace Entry ActiveX Control Basic Form 4.  Control in Minimal Form The ActiveX control without the   button (figure 2) allows the user to type a namespace into the combo box s edit control, or select a namespace from the combo box s history list.  Figure   SEQ Figure \* ARABIC    Namespace Entry ActiveX Control Minimal Form 5.  Control in Maximal Form This configuration (in figure 4) combines the functionality of the basic control with the functionality of the popup dialog.  It allows a machine name to be typed in or selected via the Network Neighborhood Popup (section 7) invoked using the   button and the namepsaces on the selected machine to be browsed via a tree control.  The   button at the bottom of the control fires an event notifying the containing dialog or window of namespace selection in addition to placing the selection in the combo box.  This allows selection of multiple namespaces to be accomplished by a sequence of single selections on one or more machines.  This configuration also has an optional  Cancel  button which is not shown. Figure   SEQ Figure \* ARABIC    Namespace Entry ActiveX Control Maximal Form 6. Browse Popup Dialog This dialog contains an edit control for machine name entry, a button to initiate browsing of the network neighborhood (section 7), and a tree containing the hierarchy of namespaces on the designated machine.  The   button at the bottom of the dialog places the selected namespace in the combo box s edit control, selects it, and adds it to the combo box s history list.   Figure   SEQ Figure \* ARABIC    Namespace Entry ActiveX Control Browse Popup Dialog 7.  Browse Network Neighborhood Popup  This popup is created using the NT Namespace API  SHBrowseForFolder  function.  It displays a dialog box which enables a user to select a shell folder.  It cannot be embedded in a dialog because the API does not provide for that.  It is used by the control in maximal form (section 5) and the Browse Dialog Popup (section 6). Figure   SEQ Figure \* ARABIC   Namespace Entry ActiveX Control Network Neighborhood Popup Normal Heading 1 .hapter   Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Heading 7 Heading 8 Heading 9 Default Paragraph Font Caption Body Text OLE_LINK1 .5C:\pandorang\ActiveXSuite\Controls\NSEntry\Design.doc .6C:\pandorang\ActiveXSuite\Controls\NSEntry\Design2.doc .6C:\pandorang\ActiveXSuite\Controls\NSEntry\Design2.doc Judith Ann PowellB\\pepper\pepper\pandorang\ActiveXSuite\Controls\NSEntry\Design.doc \\MSPRINT9\24/2019 CORPI 157.57.120.248 Ne01: winspool \\MSPRINT9\24/2019 CORPI 157.57.120.248 \\MSPRINT9\24/2019 CORPI 157.57 Letter \\MSPRINT9\24/2019 CORPI 157.57 Letter Times New Roman Symbol Arial
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\iexpress\license.txt ===
WMI SDK Controls
END-USER LICENSE AGREEMENT FOR MICROSOFT SOFTWARE

IMPORTANT-READ CAREFULLY: This Microsoft End-User License Agreement ("EULA") is a legal agreement between you (either an individual or a single entity) and Microsoft Corporation for the Microsoft software product identified above, which includes computer software and associated media and printed materials, and may include "online" or electronic documentation ("SOFTWARE PRODUCT" or "SOFTWARE"). By installing, copying, or otherwise using the SOFTWARE PRODUCT, you agree to be bound by the terms of this EULA. 
If you do not agree to the terms of this EULA; promptly return the unused SOFTWARE PRODUCT to the place from which you obtained it for a full refund; or if you received the SOFTWARE PRODUCT as part of a subscription or other service from Microsoft, you may cancel the subscription and receive a pro rata portion of the subscription price.

You may NOT redistribute the WMI ActiveX Controls or this install package outside of your company.

These files are intended for development purposes only.

SOFTWARE PRODUCT LICENSE
The SOFTWARE PRODUCT is protected by copyright laws and international copyright treaties, as well as other intellectual property laws and treaties. The SOFTWARE PRODUCT is licensed, not sold.

1.	GRANT OF LICENSE. This EULA grants you the following limited, non-exclusive rights:
* Software Product. You may install and use the enclosed SOFTWARE PRODUCT on a single computer to design, develop, and test software application products for use with Microsoft(R) Windows(R) or Windows NT(R) ("Application").
* Microsoft Developer Network Subscriber. If you acquired the SOFTWARE PRODUCT through a subscription to the Microsoft Developer Network, and you are either an individual developer or an individual designated within a single entity, you are granted the following additional rights with respect to the SOFTWARE PRODUCT:  (a) you may make and use copies of the SOFTWARE PRODUCT on up to ten (10) separate computers, provided that you are the only individual using the SOFTWARE PRODUCT on each such computer, and (
b) if you are a single entity, you may designate one individual within your organization to have the right to use the SOFTWARE PRODUCT in the manner described herein.
* Microsoft reserves all rights not expressly granted to you. 

2.	COPYRIGHT. All rights, title, and copyrights in and to the SOFTWARE PRODUCT (including, but not limited to, any images, photographs, animations, video, audio, music, text, and "applets" incorporated into the SOFTWARE PRODUCT) and any copies of the SOFTWARE PRODUCT are owned by Microsoft or its suppliers. The SOFTWARE PRODUCT is protected by copyright laws and international treaty provisions. Therefore, you must treat the SOFTWARE PRODUCT like any other copyrighted material, except that you may eith
er (a) make one copy of the SOFTWARE PRODUCT solely for backup or archival purposes, or (b) install the SOFTWARE PRODUCT on a single computer, provided you keep the original solely for backup or archival purposes. You may not copy the printed materials accompanying the SOFTWARE PRODUCT. 

3.	PRERELEASE CODE. The SOFTWARE PRODUCT may contain PRERELEASE CODE that is not at the level of performance and compatibility of the final, generally available, product offering. These portions of the SOFTWARE PRODUCT may not operate correctly and may be substantially modified prior to first commercial shipment. Microsoft is not obligated to make this or any later version of the SOFTWARE PRODUCT commercially available.  Microsoft grants you the right to distribute test versions of your Application cr
eated using the PRERELEASE CODE provided you comply with the Distribution Requirements described in Section 1 and the following additional provisions: (a)  you must mark the test version of your Application "BETA" and (b) you are solely responsible for updating your customers with versions of your Application that operate satisfactorily with the final commercial release of the PRERELEASE CODE.  

4. 	DESCRIPTION OF OTHER RIGHTS AND LIMITATIONS. 
* Limitations on Reverse-Engineering, Decompilation, and Disassembly. You may not reverse- engineer, decompile, or disassemble the SOFTWARE PRODUCT, except and only to the extent that such activity is expressly permitted by applicable law notwithstanding this limitation.
* Rental. You may not rent or lease the SOFTWARE PRODUCT. 
* Software Transfer. You may permanently transfer all of your rights under this EULA, provided you retain no copies, you transfer all of the SOFTWARE PRODUCT (including all component parts, the media and printed materials, any upgrades, this EULA, and, if applicable, the Certificate of Authenticity), and the recipient agrees to the terms of this EULA. If the SOFTWARE PRODUCT is an upgrade, any transfer must include all prior versions of the SOFTWARE PRODUCT.
* Termination. Without prejudice to any other rights, Microsoft may terminate this EULA if you fail to comply with the terms and conditions of this EULA. In such event, you must destroy all copies of the SOFTWARE PRODUCT and all of its component parts. 

5.	EXPORT RESTRICTIONS. You agree that neither you nor your customers intend to or will, directly or indirectly, export or transmit (a) the SOFTWARE PRODUCT or related documentation and technical data, or (b) your Application as described in Section 1 of this EULA (or any part thereof), or process, or service that is the direct product of the SOFTWARE PRODUCT to any country to which such export or transmission is restricted by any applicable U.S. regulation or statute, without the prior written consen
t, if required, of the Bureau of Export Administration of the U.S. Department of Commerce, or such other governmental entity as may have jurisdiction over such export or transmission. 

6.	U.S. GOVERNMENT RESTRICTED RIGHTS. The SOFTWARE PRODUCT and documentation are provided with RESTRICTED RIGHTS. Use, duplication, or disclosure by the Government is subject to restrictions as set forth in subparagraph (c)(1)(ii) of The Rights in Technical Data and Computer Software clause at DFARS 252.227-7013 or subparagraphs (c)(1) and (2) of the Commercial Computer Software - Restricted Rights at 48 CFR 52.227-19, as applicable. Manufacturer is Microsoft Corporation/One Microsoft Way/Redmond, WA 
98052-6399. 
MISCELLANEOUS

If you acquired this product in the United States, this EULA is governed by the laws of the State of Washington. 

If you acquired this product in Canada, this EULA is governed by the laws of the Province of Ontario, Canada. Each of the parties hereto irrevocably attorns to the jurisdiction of the courts of the Province of Ontario and further agrees to commence any litigation that may arise hereunder in the courts located in the Judicial District of York, Province of Ontario. 
If this product was acquired outside the United States, local law may apply.
Should you have any questions concerning this EULA, or if you desire to contact Microsoft for any reason, please contact the Microsoft subsidiary serving your country, or write: Microsoft Customer Sales and Service/One Microsoft Way/Redmond, WA 98052-6399. 
NO WARRANTIES. To the maximum extent permitted by applicable law, Microsoft expressly disclaims any warranty for the SOFTWARE PRODUCT. The SOFTWARE PRODUCT and any related documentation are provided "as is" without warranty of any kind, either express or implied, including, without limitation, the implied warranties of merchantability or fitness for a particular purpose. The entire risk arising out of use or performance of the SOFTWARE PRODUCT remains with you. 

LIMITATION OF LIABILITY. Microsoft's entire liability and your exclusive remedy under this EULA shall not exceed one hundred dollars (US$100.00). 

NO LIABILITY FOR CONSEQUENTIAL DAMAGES. To the maximum extent permitted by applicable law, in no event shall Microsoft or its suppliers be liable for any damages whatsoever (including, without limitation, damages for loss of business profit, business interruption, loss of business information, or any other pecuniary loss) arising out of the use of, or inability to use, this Microsoft product, even if Microsoft has been advised of the possibility of such damages. Because some states/jurisdictions do not all
ow the exclusion or limitation of liability for consequential or incidental damages, the above limitation may not apply to you. 

Si vous avez acquis votre produit Microsoft au CANADA, la garantie limite suivante vous concerne: 
GARANTIE LIMITE
EXCLUSION DE GARANTIES. Microsoft renonce entirement  toute garantie pour le LOGICIEL. Le LOGICIEL et toute autre documentation s'y rapportant sont fournis  comme tels  sans aucune garantie quelle qu'elle soit, expresse ou implicite, y compris, mais ne se limitant pas aux garanties implicites de la qualit marchande ou un usage particulier. Le risque total dcoulant de l'utilisation ou de la performance du LOGICIEL est entre vos mains. 
RESPONSABILIT LIMITE. La seule obligation de Microsoft et votre recours exclusif concernant ce contrat n'excderont pas cent dollars (US$100.00). 
ABSENCE DE RESPONSABILIT POUR LES DOMMAGES INDIRECTS. Microsoft ou ses 
fournisseurs ne pourront tre tenus responsables en aucune circonstance de tout dommage quel qu'il soit (y compris mais non de faon limitative les dommages directs ou indirects causs par la perte de bnfices commerciaux, l'interruption des affaires, la perte d'information commerciale ou toute autre perte pcuniaire) rsultant de l'utilisation ou de l'impossibilit d'utilisation de ce produit, et ce, mme si la socit Microsoft a t avise de l'ventualit de tels dommages. Certains tats/juridictions 
ne permettent pas l'exclusion ou la limitation de responsabilit relative aux dommages indirects ou conscutifs, et la limitation ci-dessus peut ne pas s'appliquer  votre gard. 
La prsente Convention est rgie par les lois de la province d'Ontario, Canada. Chacune des parties  la Convention reconnat irrvocablement la comptence des tribunaux de la province d'Ontario et consent  instituer tout litige qui pourrait dcouler de la Convention auprs des tribunaux situs dans le district judiciaire de York, province d'Ontario. 
Au cas o vous auriez des questions concernant cette licence ou que vous dsiriez vous mettre en rapport avec Microsoft pour quelque raison que ce soit, veuillez contacter la succursale Microsoft desservant votre pays, dont l'adresse est fournie dans ce produit, ou crire : Microsoft Customer Sales and Service, One Microsoft Way, Redmond, Washington 98052-6399.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\iexpress\instructions.txt ===
1) Install IExpress from http://aicgweb/iexpress

2) Build the following files, and copy them into the directory Nova\ActiveXSuite\IExpress\SrcFiles
WBEMGrid.dll
WBEMLoginDlg.dll
WBEMUtils.dll
MOEngine.dll
WBEMClassNav.ocx
WBEMProvWiz.ocx
WBEMEventReg.ocx
WBEMEventList.ocx
WBEMInstNav.ocx
WBEMMOFComp.ocx
WBEMMOFWiz.ocx
WBEMMultiView.ocx
WBEMNSPicker.ocx
WBEMSchemaValWiz.ocx
WBEMLogin.ocx
WBEMObjView.ocx
WBEMSingleView.ocx
WBEMHelp.ocx

NOTE: You can use the batch files 'GetRelFiles' or 'GetDbgFiles' to copy the files from their build locations

3) From explorer, launch Nova\ActiveXSuite\IExpress\WMICtls.sed

4) You'll be prompted by the IExpress wizard to open an existing SED file - Choose NEXT
5) You'll be prompted to Create a Package - Choose NEXT
6) You'll be prompted to confirm that you want to create a package - Choose NEXT
7) IExpress will take a minute to build the file WMICtls.exe (it will be in the same directory as WMICtls.sed)

The file License.txt will displayed as an end-user license agreement during installation

WMICtls.exe is a self extracting executable that installs the files mentioned in step 2 (and registers the OCX's).  It also provides a Remove option in the Control Panel's add/remove programs option.


WMICtls.exe can be run in 'quiet' mode by specifying /Q
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\eventvbtest\readme.txt ===
========================================================================
		ActiveX Control DLL : EVENTVBTEST
========================================================================

ControlWizard has created this project for your EVENTVBTEST ActiveX Control
DLL, which contains 1 control.

This skeleton project not only demonstrates the basics of writing an
ActiveX Control, but is also a starting point for writing the specific
features of your control.

This file contains a summary of what you will find in each of the files
that make up your EVENTVBTEST ActiveX Control DLL.

EventVBTest.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.

EventVBTest.h
	This is the main include file for the ActiveX Control DLL.  It
	includes other project-specific includes such as resource.h.

EventVBTest.cpp
	This is the main source file that contains code for DLL initialization,
	termination and other bookkeeping.

EventVBTest.rc
	This is a listing of the Microsoft Windows resources that the project
	uses.  This file can be directly edited with the Visual C++ resource
	editor.

EventVBTest.def
	This file contains information about the ActiveX Control DLL that
	must be provided to run with Microsoft Windows.

EventVBTest.clw
	This file contains information used by ClassWizard to edit existing
	classes or add new classes.  ClassWizard also uses this file to store
	information needed to generate and edit message maps and dialog data
	maps and to generate prototype member functions.

EventVBTest.odl
	This file contains the Object Description Language source code for the
	type library of your control.

/////////////////////////////////////////////////////////////////////////////
EventVBTest control:

EventVBTestCtl.h
	This file contains the declaration of the CEventVBTestCtrl C++ class.

EventVBTestCtl.cpp
	This file contains the implementation of the CEventVBTestCtrl C++ class.

EventVBTestPpg.h
	This file contains the declaration of the CEventVBTestPropPage C++ class.

EventVBTestPpg.cpp
	This file contains the implementation of the CEventVBTestPropPage C++ class.

EventVBTestCtl.bmp
	This file contains a bitmap that a container will use to represent the
	CEventVBTestCtrl control when it appears on a tool palette.  This bitmap
	is included by the main resource file EventVBTest.rc.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

stdafx.h, stdafx.cpp
	These files are used to build a precompiled header (PCH) file
	named stdafx.pch and a precompiled types (PCT) file named stdafx.obj.

resource.h
	This is the standard header file, which defines new resource IDs.
	The Visual C++ resource editor reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

ControlWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\searchclient\readme.txt ===
========================================================================
       MICROSOFT FOUNDATION CLASS LIBRARY : SearchClient
========================================================================


AppWizard has created this SearchClient application for you.  This application
not only demonstrates the basics of using the Microsoft Foundation classes
but is also a starting point for writing your application.

This file contains a summary of what you will find in each of the files that
make up your SearchClient application.

SearchClient.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.

SearchClient.h
    This is the main header file for the application.  It includes other
    project specific headers (including Resource.h) and declares the
    CSearchClientApp application class.

SearchClient.cpp
    This is the main application source file that contains the application
    class CSearchClientApp.

SearchClient.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Visual C++.

SearchClient.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.

res\SearchClient.ico
    This is an icon file, which is used as the application's icon.  This
    icon is included by the main resource file SearchClient.rc.

res\SearchClient.rc2
    This file contains resources that are not edited by Microsoft 
	Visual C++.  You should place all resources not editable by
	the resource editor in this file.




/////////////////////////////////////////////////////////////////////////////

AppWizard creates one dialog class:

SearchClientDlg.h, SearchClientDlg.cpp - the dialog
    These files contain your CSearchClientDlg class.  This class defines
    the behavior of your application's main dialog.  The dialog's
    template is in SearchClient.rc, which can be edited in Microsoft
	Visual C++.


/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named SearchClient.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Visual C++ reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

If your application uses MFC in a shared DLL, and your application is 
in a language other than the operating system's current language, you
will need to copy the corresponding localized resources MFC42XXX.DLL
from the Microsoft Visual C++ CD-ROM onto the system or system32 directory,
and rename it to be MFCLOC.DLL.  ("XXX" stands for the language abbreviation.
For example, MFC42DEU.DLL contains resources translated to German.)  If you
don't do this, some of the UI elements of your application will remain in the
language of the operating system.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wiztest\text1.txt ===
I have a MFC COleControl based ActiveX control which brings up a CPropertySheet based wizard in NT 4, SP 3, with Visual C++ 6.0.  The controls are hosted in IE 4 web pages.  If the user opens a second IE window via "File New Window ctrl-n" and brings up the wizard from each control and interacts with both of thw wizards we are seeing a MFC failure in the function  CWnd::FromHandlePermanent.

I am able to repro the problem with a small do nothing control which brings up a small do nothing wizard which is shared out as \\a-judypo1\wiztest.


Below I have a repro scenario, the Afx function where the failure occurs and the complete stack at failure.


Question:

	Does anyone know what is causing the failure and if there is a work around?


To repro failure:

	Load project from \\a-judypo1\wiztest into Visual C++ 6.0.

	Run it.

	Open a second IE window via "File New Window ctrl-n" from the IE menu.

	Click on the control to bring up the wizard from both IE windows.

	Overlap the wizards and do "Next", and "Back", and move the windows around unitl you see the failure.  I do not have a precise repro here and you will just have to manipulate things until it fails.  The message being processed at the time of failure is usually WM_TIMER but I also see the failure less often on the WM_MOUSEMOVE message.
	

CWnd member function FromHandlePermanent fails in AfxWndProc:

LRESULT CALLBACK
AfxWndProc(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	// special message which identifies the window as using AfxWndProc
	if (nMsg == WM_QUERYAFXWNDPROC)
		return 1;

	// all other messages route through message map
	CWnd* pWnd = CWnd::FromHandlePermanent(hWnd);   <---- THIS FAILS!
	ASSERT(pWnd != NULL);
	ASSERT(pWnd->m_hWnd == hWnd);
	return AfxCallWndProc(pWnd, hWnd, nMsg, wParam, lParam);
}



Stack at failure:

AfxWndProc(HWND__ * 0x004d04fc, unsigned int 0x0000000f, unsigned int 0x00000000, long 0x00000000) line 365 + 25 bytes
AfxWndProcDllStatic(HWND__ * 0x004d04fc, unsigned int 0x0000000f, unsigned int 0x00000000, long 0x00000000) line 57 + 21 bytes
USER32! DispatchClientMessage@20 + 42 bytes
USER32! __fnDWORD@4 + 36 bytes
NTDLL! KiUserCallbackDispatcher@12 + 19 bytes
AfxWndProcDllStatic(HWND__ * 0x1001a9b8, unsigned int 0x0169fb4c, unsigned int 0x0169fc40, long 0x0169fbd4) line 55
USER32! 77e712d8()
USER32! DispatchMessageA@4 + 11 bytes
CWinThread::PumpMessage() line 846
CWnd::RunModalLoop(unsigned long 0x00000004) line 3478 + 19 bytes
CPropertySheet::DoModal() line 827 + 12 bytes
CWizTestCtrl::OnLButtonUp(unsigned int 0x00000000, CPoint {x=0x0000003e y=0x00000027}) line 257 + 28 bytes
CWnd::OnWndMsg(unsigned int 0x00000202, unsigned int 0x00000000, long 0x0027003e, long * 0x0169fd6c) line 1964
CWnd::WindowProc(unsigned int 0x00000202, unsigned int 0x00000000, long 0x0027003e) line 1585 + 30 bytes
COleControl::WindowProc(unsigned int 0x00000202, unsigned int 0x00000000, long 0x0027003e) line 1720 + 20 bytes
AfxCallWndProc(CWnd * 0x01542a70 {CWizTestCtrl hWnd=???}, HWND__ * 0x003e04be, unsigned int 0x00000202, unsigned int 0x00000000, long 0x0027003e) line 215 + 26 bytes
AfxWndProc(HWND__ * 0x003e04be, unsigned int 0x00000202, unsigned int 0x00000000, long 0x0027003e) line 368
AfxWndProcDllStatic(HWND__ * 0x003e04be, unsigned int 0x00000202, unsigned int 0x00000000, long 0x0027003e) line 57 + 21 bytes
USER32! DispatchMessageWorker@8 + 135 bytes
USER32! DispatchMessageA@4 + 11 bytes
SHDOCVW! 70767b19()
SHDOCVW! 707679ac()
KERNEL32! BaseThreadStart@8 + 81 bytes


Judy Powell
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wiztest\readme.txt ===
========================================================================
		ActiveX Control DLL : WIZTEST
========================================================================

ControlWizard has created this project for your WIZTEST ActiveX Control
DLL, which contains 1 control.

This skeleton project not only demonstrates the basics of writing an
ActiveX Control, but is also a starting point for writing the specific
features of your control.

This file contains a summary of what you will find in each of the files
that make up your WIZTEST ActiveX Control DLL.

WizTest.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.

WizTest.h
	This is the main include file for the ActiveX Control DLL.  It
	includes other project-specific includes such as resource.h.

WizTest.cpp
	This is the main source file that contains code for DLL initialization,
	termination and other bookkeeping.

WizTest.rc
	This is a listing of the Microsoft Windows resources that the project
	uses.  This file can be directly edited with the Visual C++ resource
	editor.

WizTest.def
	This file contains information about the ActiveX Control DLL that
	must be provided to run with Microsoft Windows.

WizTest.clw
	This file contains information used by ClassWizard to edit existing
	classes or add new classes.  ClassWizard also uses this file to store
	information needed to generate and edit message maps and dialog data
	maps and to generate prototype member functions.

WizTest.odl
	This file contains the Object Description Language source code for the
	type library of your control.

/////////////////////////////////////////////////////////////////////////////
WizTest control:

WizTestCtl.h
	This file contains the declaration of the CWizTestCtrl C++ class.

WizTestCtl.cpp
	This file contains the implementation of the CWizTestCtrl C++ class.

WizTestPpg.h
	This file contains the declaration of the CWizTestPropPage C++ class.

WizTestPpg.cpp
	This file contains the implementation of the CWizTestPropPage C++ class.

WizTestCtl.bmp
	This file contains a bitmap that a container will use to represent the
	CWizTestCtrl control when it appears on a tool palette.  This bitmap
	is included by the main resource file WizTest.rc.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

stdafx.h, stdafx.cpp
	These files are used to build a precompiled header (PCH) file
	named stdafx.pch and a precompiled types (PCT) file named stdafx.obj.

resource.h
	This is the standard header file, which defines new resource IDs.
	The Visual C++ resource editor reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

ControlWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\cdllogvw.txt ===
CDLLOGVW.EXE:

When you run into a code download failure, Run CDLLOGVW.EXE [ This is included the SDK. 
Find it the \bin directory]. This works in retail code as well. The logs are in english 
only now. 

This tool will display code download error logs/details of recently failed code downloads 
on your machine. To view a log for a failed code download, select the log by name 
and then choose "View Log". Names are CLSIDs of the controls as you see them on the 
CLASSID attribute in the OBJECT tag. You can see the parameters of the OBJECT tag by 
choosing View.Source from the browser menu. "View Log" navigates to the log file in a 
new browser window.

To delete a log file, choose "Delete Entry" in CDLLOGVW. Logs get scavenged by the 
browser cache subsystem automatically, so you don't have to worry about them cluttering 
up your hard disk space.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\readme.txt ===
========================================================================
       MICROSOFT FOUNDATION CLASS LIBRARY : Browser
========================================================================


AppWizard has created this Browser application for you.  This application
not only demonstrates the basics of using the Microsoft Foundation classes
but is also a starting point for writing your application.

This file contains a summary of what you will find in each of the files that
make up your Browser application.

Browser.h
    This is the main header file for the application.  It includes other
    project specific headers (including Resource.h) and declares the
    CBrowserApp application class.

Browser.cpp
    This is the main application source file that contains the application
    class CBrowserApp.

Browser.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Developer Studio.

res\Browser.ico
    This is an icon file, which is used as the application's icon.  This
    icon is included by the main resource file Browser.rc.

res\Browser.rc2
    This file contains resources that are not edited by Microsoft 
	Developer Studio.  You should place all resources not
	editable by the resource editor in this file.

Browser.reg
    This is an example .REG file that shows you the kind of registration
    settings the framework will set for you.  You can use this as a .REG
    file to go along with your application or just delete it and rely
    on the default RegisterShellFileTypes registration.

Browser.odl
    This file contains the Object Description Language source code for the
    type library of your application.

Browser.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.

/////////////////////////////////////////////////////////////////////////////

For the main frame window:

MainFrm.h, MainFrm.cpp
    These files contain the frame class CMainFrame, which is derived from
    CFrameWnd and controls all SDI frame features.


/////////////////////////////////////////////////////////////////////////////

AppWizard creates one document type and one view:

BrowserDoc.h, BrowserDoc.cpp - the document
    These files contain your CBrowserDoc class.  Edit these files to
    add your special document data and to implement file saving and loading
    (via CBrowserDoc::Serialize).

BrowserView.h, BrowserView.cpp - the view of the document
    These files contain your CBrowserView class.
    CBrowserView objects are used to view CBrowserDoc objects.


/////////////////////////////////////////////////////////////////////////////

AppWizard has also created classes specific to OLE

CntrItem.h, CntrItem.cpp - this class is used to
	manipulate OLE objects.  They are usually displayed by your
	CBrowserView class and serialized as part of your CBrowserDoc class.


/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named Browser.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Developer Studio reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

If your application uses MFC in a shared DLL, and your application is 
in a language other than the operating system's current language, you
will need to copy the corresponding localized resources MFC40XXX.DLL
from the Microsoft Visual C++ CD-ROM onto the system or system32 directory,
and rename it to be MFCLOC.DLL.  ("XXX" stands for the language abbreviation.
For example, MFC40DEU.DLL contains resources translated to German.)  If you
don't do this, some of the UI elements of your application will remain in the
language of the operating system.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\drivecontainer\readme.txt ===
========================================================================
		ActiveX Control DLL : GENSELECTIONEVENTS
========================================================================

ControlWizard has created this project for your GENSELECTIONEVENTS ActiveX Control
DLL, which contains 1 control.

This skeleton project not only demonstrates the basics of writing an
ActiveX Control, but is also a starting point for writing the specific
features of your control.

This file contains a summary of what you will find in each of the files
that make up your GENSELECTIONEVENTS ActiveX Control DLL.

GenSelectionEvents.mak
	The Visual C++ project makefile for building your ActiveX Control.

GenSelectionEvents.h
	This is the main include file for the ActiveX Control DLL.  It
	includes other project-specific includes such as resource.h.

GenSelectionEvents.cpp
	This is the main source file that contains code for DLL initialization,
	termination and other bookkeeping.

GenSelectionEvents.rc
	This is a listing of the Microsoft Windows resources that the project
	uses.  This file can be directly edited with the Visual C++ resource
	editor.

GenSelectionEvents.def
	This file contains information about the ActiveX Control DLL that
	must be provided to run with Microsoft Windows.

GenSelectionEvents.clw
	This file contains information used by ClassWizard to edit existing
	classes or add new classes.  ClassWizard also uses this file to store
	information needed to generate and edit message maps and dialog data
	maps and to generate prototype member functions.

GenSelectionEvents.odl
	This file contains the Object Description Language source code for the
	type library of your control.

/////////////////////////////////////////////////////////////////////////////
GenSelectionEvents control:

GenSelectionEventsCtl.h
	This file contains the declaration of the CGenSelectionEventsCtrl C++ class.

GenSelectionEventsCtl.cpp
	This file contains the implementation of the CGenSelectionEventsCtrl C++ class.

GenSelectionEventsPpg.h
	This file contains the declaration of the CGenSelectionEventsPropPage C++ class.

GenSelectionEventsPpg.cpp
	This file contains the implementation of the CGenSelectionEventsPropPage C++ class.

GenSelectionEventsCtl.bmp
	This file contains a bitmap that a container will use to represent the
	CGenSelectionEventsCtrl control when it appears on a tool palette.  This bitmap
	is included by the main resource file GenSelectionEvents.rc.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

stdafx.h, stdafx.cpp
	These files are used to build a precompiled header (PCH) file
	named stdafx.pch and a precompiled types (PCT) file named stdafx.obj.

resource.h
	This is the standard header file, which defines new resource IDs.
	The Visual C++ resource editor reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

ControlWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\nsetest\readme.txt ===
========================================================================
       MICROSOFT FOUNDATION CLASS LIBRARY : NSETest
========================================================================


AppWizard has created this NSETest application for you.  This application
not only demonstrates the basics of using the Microsoft Foundation classes
but is also a starting point for writing your application.

This file contains a summary of what you will find in each of the files that
make up your NSETest application.

NSETest.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.

NSETest.h
    This is the main header file for the application.  It includes other
    project specific headers (including Resource.h) and declares the
    CNSETestApp application class.

NSETest.cpp
    This is the main application source file that contains the application
    class CNSETestApp.

NSETest.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Visual C++.

NSETest.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.

res\NSETest.ico
    This is an icon file, which is used as the application's icon.  This
    icon is included by the main resource file NSETest.rc.

res\NSETest.rc2
    This file contains resources that are not edited by Microsoft 
	Visual C++.  You should place all resources not editable by
	the resource editor in this file.

NSETest.reg
    This is an example .REG file that shows you the kind of registration
    settings the framework will set for you.  You can use this as a .REG
    file to go along with your application.

NSETest.odl
    This file contains the Object Description Language source code for the
    type library of your application.



/////////////////////////////////////////////////////////////////////////////

AppWizard creates one dialog class and automation proxy class:

NSETestDlg.h, NSETestDlg.cpp - the dialog
    These files contain your CNSETestDlg class.  This class defines
    the behavior of your application's main dialog.  The dialog's
    template is in NSETest.rc, which can be edited in Microsoft
	Visual C++.

DlgProxy.h, DlgProxy.cpp - the automation object
    These files contain your CNSETestDlgAutoProxy class.  This class
    is called the "automation proxy" class for your dialog, because it
    takes care of exposing the automation methods and properties that
    automation controllers can use to access your dialog.  These methods
    and properties are not exposed from the dialog class directly, because
    in the case of a modal dialog-based MFC application it is cleaner and
    easier to keep the automation object separate from the user interface.


/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named NSETest.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Visual C++ reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

If your application uses MFC in a shared DLL, and your application is 
in a language other than the operating system's current language, you
will need to copy the corresponding localized resources MFC42XXX.DLL
from the Microsoft Visual C++ CD-ROM onto the system or system32 directory,
and rename it to be MFCLOC.DLL.  ("XXX" stands for the language abbreviation.
For example, MFC42DEU.DLL contains resources translated to German.)  If you
don't do this, some of the UI elements of your application will remain in the
language of the operating system.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\readme.txt ===
========================================================================
       MICROSOFT FOUNDATION CLASS LIBRARY : Studio
========================================================================


AppWizard has created this Studio application for you.  This application
not only demonstrates the basics of using the Microsoft Foundation classes
but is also a starting point for writing your application.

This file contains a summary of what you will find in each of the files that
make up your Studio application.

Studio.h
    This is the main header file for the application.  It includes other
    project specific headers (including Resource.h) and declares the
    CStudioApp application class.

Studio.cpp
    This is the main application source file that contains the application
    class CStudioApp.

Studio.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Developer Studio.

res\Studio.ico
    This is an icon file, which is used as the application's icon.  This
    icon is included by the main resource file Studio.rc.

res\Studio.rc2
    This file contains resources that are not edited by Microsoft 
	Developer Studio.  You should place all resources not
	editable by the resource editor in this file.

Studio.reg
    This is an example .REG file that shows you the kind of registration
    settings the framework will set for you.  You can use this as a .REG
    file to go along with your application or just delete it and rely
    on the default RegisterShellFileTypes registration.

Studio.odl
    This file contains the Object Description Language source code for the
    type library of your application.

Studio.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.

/////////////////////////////////////////////////////////////////////////////

For the main frame window:

MainFrm.h, MainFrm.cpp
    These files contain the frame class CMainFrame, which is derived from
    CFrameWnd and controls all SDI frame features.


/////////////////////////////////////////////////////////////////////////////

AppWizard creates one document type and one view:

StudioDoc.h, StudioDoc.cpp - the document
    These files contain your CStudioDoc class.  Edit these files to
    add your special document data and to implement file saving and loading
    (via CStudioDoc::Serialize).

StudioView.h, StudioView.cpp - the view of the document
    These files contain your CStudioView class.
    CStudioView objects are used to view CStudioDoc objects.


/////////////////////////////////////////////////////////////////////////////

AppWizard has also created classes specific to OLE

CntrItem.h, CntrItem.cpp - this class is used to
	manipulate OLE objects.  They are usually displayed by your
	CStudioView class and serialized as part of your CStudioDoc class.


/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named Studio.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Developer Studio reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

If your application uses MFC in a shared DLL, and your application is 
in a language other than the operating system's current language, you
will need to copy the corresponding localized resources MFC40XXX.DLL
from the Microsoft Visual C++ CD-ROM onto the system or system32 directory,
and rename it to be MFCLOC.DLL.  ("XXX" stands for the language abbreviation.
For example, MFC40DEU.DLL contains resources translated to German.)  If you
don't do this, some of the UI elements of your application will remain in the
language of the operating system.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\vb\misctest\form1.log ===
Line 16: Cannot load control Navigator1.
Line 28: Cannot load control ClassNav1.
Line 48: Cannot load control MultiView1.
Line 60: Cannot load control Security1.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\vb\ryantest1\form1.log ===
Line 14: Class CLASSNAVLib.ClassNav of control ClassNav1 was not a loaded control class.
Line 34: Class SECURITYLib.Security of control Security1 was not a loaded control class.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\svtest\readme.txt ===
========================================================================
       MICROSOFT FOUNDATION CLASS LIBRARY : svtest
========================================================================


AppWizard has created this svtest application for you.  This application
not only demonstrates the basics of using the Microsoft Foundation classes
but is also a starting point for writing your application.

This file contains a summary of what you will find in each of the files that
make up your svtest application.

svtest.h
    This is the main header file for the application.  It includes other
    project specific headers (including Resource.h) and declares the
    CSvtestApp application class.

svtest.cpp
    This is the main application source file that contains the application
    class CSvtestApp.

svtest.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Developer Studio.

res\svtest.ico
    This is an icon file, which is used as the application's icon.  This
    icon is included by the main resource file svtest.rc.

res\svtest.rc2
    This file contains resources that are not edited by Microsoft 
	Developer Studio.  You should place all resources not
	editable by the resource editor in this file.

svtest.reg
    This is an example .REG file that shows you the kind of registration
    settings the framework will set for you.  You can use this as a .REG
    file to go along with your application.

svtest.odl
    This file contains the Object Description Language source code for the
    type library of your application.

svtest.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.


/////////////////////////////////////////////////////////////////////////////

AppWizard creates one dialog class and automation proxy class:

svtestDlg.h, svtestDlg.cpp - the dialog
    These files contain your CSvtestDlg class.  This class defines
    the behavior of your application's main dialog.  The dialog's
    template is in svtest.rc, which can be edited in Microsoft
	Developer Studio.

DlgProxy.h, DlgProxy.cpp - the automation object
    These files contain your CSvtestDlgAutoProxy class.  This class
    is called the "automation proxy" class for your dialog, because it
    takes care of exposing the automation methods and properties that
    automation controllers can use to access your dialog.  These methods
    and properties are not exposed from the dialog class directly, because
    in the case of a modal dialog-based MFC application it is cleaner and
    easier to keep the OLE automation object separate from the user interface.


/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named svtest.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Developer Studio reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

If your application uses MFC in a shared DLL, and your application is 
in a language other than the operating system's current language, you
will need to copy the corresponding localized resources MFC40XXX.DLL
from the Microsoft Visual C++ CD-ROM onto the system or system32 directory,
and rename it to be MFCLOC.DLL.  ("XXX" stands for the language abbreviation.
For example, MFC40DEU.DLL contains resources translated to German.)  If you
don't do this, some of the UI elements of your application will remain in the
language of the operating system.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\event\html\placefil.txt ===
default.htm	WMI_SDK\ATLWizards\Event\HTML\1033
WMIClass.htm	WMI_SDK\ATLWizards\Event\HTML\1033
Attributes.htm	WMI_SDK\ATLWizards\Event\HTML\1033
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\event\scripts\placefil.txt ===
default.js	WMI_SDK\ATLWizards\Event\scripts
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\atlclass\placefil.txt ===
ATLClass.htm	WMI_SDK\ATLWizards\ATLClass
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\event\templates\placefil.txt ===
wmiprov.h	WMI_SDK\ATLWizards\Event\Templates\1033\
wmiprov.cpp	WMI_SDK\ATLWizards\Event\Templates\1033\
wmiprov.rgs	WMI_SDK\ATLWizards\Event\Templates\1033\
wmiprov.idl	WMI_SDK\ATLWizards\Event\Templates\1033\
wmiprovco.idl	WMI_SDK\ATLWizards\Event\Templates\1033\
wmiprov.mof	WMI_SDK\ATLWizards\Event\Templates\1033\
header.mof	WMI_SDK\ATLWizards\Event\Templates\1033\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\images\placefil.txt ===
wmievent.ico		WMI_SDK\ATLWizards\Images
wmiinstance.ico		WMI_SDK\ATLWizards\Images
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\instance\html\placefil.txt ===
default.htm	WMI_SDK\ATLWizards\Instance\HTML\1033
WMIClass.htm	WMI_SDK\ATLWizards\Instance\HTML\1033 
Attributes.htm	WMI_SDK\ATLWizards\Instance\HTML\1033
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\include\placefil.txt ===
atlwmiprov.h	WMI_SDK\ATLWizards\Include
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\instance\scripts\placefil.txt ===
default.js	WMI_SDK\ATLWizards\Instance\scripts
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\instance\templates\placefil.txt ===
wmiprov.h	WMI_SDK\ATLWizards\Instance\Templates\1033
wmiprov.cpp	WMI_SDK\ATLWizards\Instance\Templates\1033
wmiprov.rgs	WMI_SDK\ATLWizards\Instance\Templates\1033
wmiprov.idl	WMI_SDK\ATLWizards\Instance\Templates\1033
wmiprovco.idl	WMI_SDK\ATLWizards\Instance\Templates\1033
wmiprov.mof	WMI_SDK\ATLWizards\Instance\Templates\1033
header.mof	WMI_SDK\ATLWizards\Instance\Templates\1033
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\vsz\placefil.txt ===
wmievent.vsz		WMI_SDK\ATLWizards\vsz
wmiinstance.vsz		WMI_SDK\ATLWizards\vsz
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\vsdir\placefil.txt ===
wmi.vsdir	WMI_SDK\ATLWizards\vsdir
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\dyd\placefil.txt ===
framedyd.dll    WMI_PSDK\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\license\placefil.txt ===
REDIST.TXT	WMI_PSDK\License\
SCHEMA.TXT	WMI_PSDK\License\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\license\redist.txt ===
\LICENSE\REDIST.TXT


The files listed below are fully redistributable (located in the WMI SDK directory):

Redist\WMICore.exe
SNMP\Mibs\Snmpv1\Rfcs\1213.txt
SNMP\Mibs\Snmpv1\Rfcs\1229.txt
SNMP\Mibs\Snmpv1\Rfcs\1230.txt
SNMP\Mibs\Snmpv1\Rfcs\1231.txt
SNMP\Mibs\Snmpv1\Rfcs\1238.txt
SNMP\Mibs\Snmpv1\Rfcs\1253.txt
SNMP\Mibs\Snmpv1\Rfcs\1269.txt
SNMP\Mibs\Snmpv1\Rfcs\1271.txt
SNMP\Mibs\Snmpv1\Rfcs\1285.txt
SNMP\Mibs\Snmpv1\Rfcs\1304.txt
SNMP\Mibs\Snmpv1\Rfcs\1315.txt
SNMP\Mibs\Snmpv1\Rfcs\1316.txt
SNMP\Mibs\Snmpv1\Rfcs\1317.txt
SNMP\Mibs\Snmpv1\Rfcs\1318.txt
SNMP\Mibs\Snmpv1\Rfcs\1354.txt
SNMP\Mibs\Snmpv1\Rfcs\1381.txt
SNMP\Mibs\Snmpv1\Rfcs\1382.txt
SNMP\Mibs\Snmpv1\Rfcs\1389.txt
SNMP\Mibs\Snmpv1\Rfcs\1398.txt
SNMP\Mibs\Snmpv1\Rfcs\1406.txt
SNMP\Mibs\Snmpv1\Rfcs\1407.txt
SNMP\Mibs\Snmpv1\Rfcs\1414.txt
SNMP\Mibs\Snmpv1\Rfcs\1461.txt
SNMP\Mibs\Snmpv1\Rfcs\1471.txt
SNMP\Mibs\Snmpv1\Rfcs\1472.txt
SNMP\Mibs\Snmpv1\Rfcs\1473.txt
SNMP\Mibs\Snmpv1\Rfcs\1474.txt
SNMP\Mibs\Snmpv1\Rfcs\1493.txt
SNMP\Mibs\Snmpv1\Rfcs\1512.txt
SNMP\Mibs\Snmpv1\Rfcs\1513.txt
SNMP\Mibs\Snmpv1\Rfcs\1514.txt
SNMP\Mibs\Snmpv1\Rfcs\1515.txt
SNMP\Mibs\Snmpv1\Rfcs\1516.txt
SNMP\Mibs\Snmpv1\Rfcs\1525.txt
SNMP\Mibs\Snmpv1\Rfcs\1559.txt
SNMP\Mibs\Snmpv1\Rfcs\1593.txt
SNMP\Mibs\Snmpv1\Rfcs\1742.txt
SNMP\Mibs\Snmpv1\Rfcs\1757.txt
SNMP\Mibs\Snmpv1\Rfcs\1792.txt
SNMP\Mofs\Snmpv1\Rfcs\1213.mof
SNMP\Mofs\Snmpv1\Rfcs\1229.mof
SNMP\Mofs\Snmpv1\Rfcs\1230.mof
SNMP\Mofs\Snmpv1\Rfcs\1231.mof
SNMP\Mofs\Snmpv1\Rfcs\1238.mof
SNMP\Mofs\Snmpv1\Rfcs\1253.mof
SNMP\Mofs\Snmpv1\Rfcs\1269.mof
SNMP\Mofs\Snmpv1\Rfcs\1271.mof
SNMP\Mofs\Snmpv1\Rfcs\1285.mof
SNMP\Mofs\Snmpv1\Rfcs\1304.mof
SNMP\Mofs\Snmpv1\Rfcs\1315.mof
SNMP\Mofs\Snmpv1\Rfcs\1316.mof
SNMP\Mofs\Snmpv1\Rfcs\1317.mof
SNMP\Mofs\Snmpv1\Rfcs\1318.mof
SNMP\Mofs\Snmpv1\Rfcs\1354.mof
SNMP\Mofs\Snmpv1\Rfcs\1381.mof
SNMP\Mofs\Snmpv1\Rfcs\1382.mof
SNMP\Mofs\Snmpv1\Rfcs\1389.mof
SNMP\Mofs\Snmpv1\Rfcs\1398.mof
SNMP\Mofs\Snmpv1\Rfcs\1406.mof
SNMP\Mofs\Snmpv1\Rfcs\1407.mof
SNMP\Mofs\Snmpv1\Rfcs\1414.mof
SNMP\Mofs\Snmpv1\Rfcs\1461.mof
SNMP\Mofs\Snmpv1\Rfcs\1471.mof
SNMP\Mofs\Snmpv1\Rfcs\1472.mof
SNMP\Mofs\Snmpv1\Rfcs\1473.mof
SNMP\Mofs\Snmpv1\Rfcs\1474.mof
SNMP\Mofs\Snmpv1\Rfcs\1493.mof
SNMP\Mofs\Snmpv1\Rfcs\1512.mof
SNMP\Mofs\Snmpv1\Rfcs\1513.mof
SNMP\Mofs\Snmpv1\Rfcs\1514.mof
SNMP\Mofs\Snmpv1\Rfcs\1515.mof
SNMP\Mofs\Snmpv1\Rfcs\1516.mof
SNMP\Mofs\Snmpv1\Rfcs\1525.mof
SNMP\Mofs\Snmpv1\Rfcs\1559.mof
SNMP\Mofs\Snmpv1\Rfcs\1593.mof
SNMP\Mofs\Snmpv1\Rfcs\1742.mof
SNMP\Mofs\Snmpv1\Rfcs\1757.mof
SNMP\Mofs\Snmpv1\Rfcs\1792.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1213.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1229.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1230.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1231.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1238.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1253.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1269.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1271.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1285.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1304.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1315.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1316.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1317.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1318.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1354.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1381.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1382.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1389.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1398.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1406.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1407.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1414.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1461.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1471.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1472.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1473.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1474.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1493.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1512.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1513.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1514.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1515.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1516.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1525.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1559.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1593.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1742.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1757.mof
SNMP\SMIR_Mofs\Snmpv1\Rfcs\1792.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\locstudioparser\readme.txt ===
LOCALIZATION STUDIO 4.2 PARSER

This DLL provides the ability to localize Amended qualifiers through Localization Studio 4.2.
To install the parser on a workstation already containing LocStudio 4.2, add the following registry entry:

HKLM\Software\Microsoft\LocStudio 4.2\Parsers\
\Parser99
  Description: REG_SZ : "MOF Parser"
  ExtensionList: REG_SZ : "MOF MFL"
  Help: REG_SZ : "WMI MOF files (*.mof, *.mfl")"
  Location: REG_SZ : "D:\M3\locstudioparser\retail\wmiparse.dll"
  ParserID : REG_DWORD : 0x63
\Parser99\File Types
\Parser99\File Types\File Type 1
  Description : REG_SZ : "MOF Parser"
  File Type : REG_DWORD : 0x1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\license\schema.txt ===
CIMV2 Namespace Usage

This document aligns with Win32 Logo Requirements, and MSI and SMBIOS MOF Additions as of 01/25/99 and defines the proper usage of the classes defined in the CIMV2 namespace. Generally, one of four cases may apply:

1) CIM classes which can be freely subclassed. The only restriction being that instances must always apply to the local machine. 

2) CIM classes that cannot be subclassed directly. All the instances of the CIM class are required to be instances known to the win32 instrumentation. As a result subclasses may only be added to the provided Win32 subclasses.

3) CIM classes that can be subclassed even though Win32 classes exist. In this case the set of instances provided by the Win32 classes are not assumed to be complete - that is, the instrumentation supplied cannot detect all relevant instances. It is expected that subclasses of the CIM class will be provided that return instances that are not discovered by the Win32 subclass providers.

4) CIM classes that cannot be subclassed. These are either classes that are at a level of abstraction that makes subclassing undesirable (such as CIM_ManagedSystemElement) or that are simply not relevant to the local environment (such as CIM_Cluster). Note it is never acceptable in the CIMV2 namespace for third parties to instrument CIM classes directly. 


1) The following classes may be freely subclassed.  Subclasses should only be added where the instances introduced are local to the machine.

Classes
* CIM_FRU
* CIM_SupportAccess
* CIM_Configuration
* CIM_MonitorResolution
* CIM_RedundancyGroup and its subclasses
* CIM_ManagementController
* CIM_Statistics and its subclasses
* CIM_StorageError

Associations
* All CIM_Product associations (Exception is the CIM_ProductSoftwareFeatures association which is addressed in the section, "Win32 associations with specific meaning")
* All CIM_FRU and CIM_SupportAccess associations
* All CIM_Configuration associations 
* All CIM_Statistics associations
* CIM_Realizes and most associations of the Physical Model (Exception is the CIM_Container association which is addressed in section 3.
* CIM_DeviceSoftware 
* CIM_AssociatedSensor and its subclasses
* CIM_BIOSLoadedInNV
* CIM_StorageDefect
* CIM_RedundancyComponent and its subclasses
* CIM_ActsAsSpare
* CIM_CollectionOfSensors
* CIM_DeviceServiceImplementation
* CIM_DeviceSAPImplementation


2) Win32 subclasses are provided for the following classes. Only direct subclasses of Win32 classes can be added. That is, the CIM classes should not be subclassed directly.  All instances must be known to the CIMV2 instrumentation.

Classes
* CIM_UnitaryComputerSystem
* CIM_OperatingSystem
* CIM_FileSystem and its subclasses
* CIM_LogicalFile and its subclasses
* CIM_Process
* CIM_Thread
* CIM_Printer
* CIM_Scanner 
* CIM_NetworkAdapter and its subclasses
* CIM_Controller and most of its subclasses (e.g., Video, SCSI, Serial, Parallel, PCI, PCMCIA, USB)
* CIM_POTSModem
* CIM_MediaAccessDevice and its subclasses (e.g., CIM_DisketteDrive, CIM_WORMDrive and CIM_MagnetoOpticalDrive)
* CIM_UserDevice and its subclasses 
* CIM_SystemResource and its subclasses
* CIM_Job
* CIM_JobDestination

Associations
* CIM_HostedJobDestination
* CIM_JobDestinationJobs
* CIM_OSProcess
* CIM_ProcessThread  
* CIM_FileStorage
* CIM_DirectoryContainsFile 
* CIM_OperatingSystemSoftwareFeature 
* CIM_HostedFileSystem
* CIM_BootOSFromFS 
* CIM_InstalledOS
* CIM_RunningOS
* CIM_ProcessExecutable
* CIM_AllocatedResource
* CIM_ResidesOnExtent
* CIM_ComputerSystemResource
* CIM_Export
* CIM_Mount


3) The following Win32 subclasses are instrumented to return a specific and limited set of instances. There may be instances relevant to the local machine that are not provided by the Win32 classes and as a result subclasses are permitted of both the Win32 and CIM classes.  Direct subclassing of Win32 classes is allowed. Other subclasses of the CIM classes are allowed for instances local to the machine and not already known to the Win32 providers. You must be careful not to return instances that are already returned by the Win32 providers.

Classes
* CIM Battery - Win32 classes represent laptop or UP (COM-port attached) batteries
* CIM_PowerSupply and CIM_UninterruptiblePowerSupply - COM-port attached UPSs are represented
* CIM_StorageExtent and its subclasses - Win32 classes represent logical disks (subclass of CIM_LogicalDisk), partitions (subclass of CIM_DiskPartition) and the logical view of SCSI/RAID-based media  (subclass of CIM_VolumeSet) 
* CIM_Processor  - Win32 classes represent "a device capable of interpreting a sequence of machine instructions on a Win32 system"
* CIM_PhysicalElement and its subclasses - Win32 classes representing data available from SMBIOS (e.g., system slots, connectors and enclosures)
* CIM_Memory and its subclasses - SMBIOS data is available (e.g., system memory arrays and cache)
* CIM_CoolingDevice and its subclasses - Win32 classes represent data available from SMBIOS (e.g., fans and refrigeration elements)
* CIM_Sensor and its subclasses - Win32 classes represent data available from SMBIOS (e.g., temperature and voltage sensors)
* CIM_Product - ComputerSystemProduct and software "products" (installed by the Microsoft Software Installer, MSI) are defined and instantiated 
* CIM_Setting - Many subclasses exist containing System Device, User, boot, MSI resource and other information
* CIM_Service, CIM_ServiceAccessPoint and their subclasses - Services represent functionality hosted on the System and OperatingSystem. All OS drivers and Services are instantiated by the CIMV2 instrumentation.  
* CIM_SoftwareFeature, CIM_SoftwareElement, CIM_Checks, CIM_Actions and their subclasses represent the MSI (Microsoft Software Installer) view of applications. Other installation technologies and individual applications may choose to add other subclasses at the same level in the schema.

Associations
* CIM_SystemComponent and its subclasses - Many subclasses exist associating devices, users, software and other classes
* CIM_AssociatedBattery
* CIM_AssociatedCooling 
* CIM_DeviceConnection - Win32 classes are various types of "ControlledBy" associations
* CIM_BasedOn - Win32 classes reference subclasses of CIM_LogicalDisk based on CIM_DiskPartition or CIM_VolumeSets
* CIM_MediaPresent - Win32 between subclasses of CIM_VolumeSet or CIM_DiskPartition 
* CIM_AssociatedMemory - Win32 SMBIOS instrumentation exists for Win32_AssociatedProcessorMemory, relating a Win32_Processor and its cache
* CIM_Container - Win32 instantiates a memory container, with data from SMBIOS
* CIM_ElementSetting - Win32 subclasses exist associating devices and their settings, users with desktops, and many other elements
* CIM_HostedService, CIM_HostedAccessPoint and their subclasses, CIM_ServiceServiceDependency, CIM_ServiceSAPDependency, CIM_SAPSAPDependency, CIM_ServiceAccessBySAP  - Win32 classes represent the associations of OS drivers and services
* All associations defined in the Application Model - Win32 classes represent the MSI view of applications  
* CIM_ProductSoftwareFeatures - Win32 subclass defines the "product" under which an MSI Software Feature is installed 


4) For the following classes subclassing and direct instantiation is not allowed.  These are high level classes or classes that contain instances that are not "local" to the machine.

Classes
* CIM_ManagedSystemElement and CIM_LogicalElement (Subclasses addressed separately)
* CIM_System and CIM_ComputerSystem (Subclasses addressed separately)
* CIM_LogicalDevice (Subclasses addressed separately)
* CIM_VirtualComputerSystem
* CIM_Cluster
* CIM_ClusteringService

Associations
* CIM_ApplicationSystemSoftwareFeature
* CIM_ComponentCS
* CIM_HostedClusterService
* CIM_ClusterServiceAccessBySAP
* CIM_HostingCS
* CIM_ParticipatingCS
* CIM_DeviceAccessedByFile (N/A for Win32 environment)


GENERAL NOTES
Where CIM classes are included in the CimWin32 MOF, these classes reflect the CIM V2.2 Schema, released by the DMTF (Desktop Management Task Force) in September 1998.   Several areas where the CimWin32 MOF differs are discussed below:
 
* Qualifiers exist in CIM as versatile and user-definable meta-data for the Schema.  Creating new qualifiers is allowed by the CIM Specification.  Several examples of new qualifiers (like the "Dynamic" qualifier) can be found in the CimWin32 MOF.    
 
* Many of the CIM Schema keys (identified using the Key qualifier) are labeled as "propagated" and are meant for object identification in an enterprise environment.  These "propagated" keys are typically not needed in the CIMV2 namespace, which reflects the local platform.  In these cases, the keys are identified with the CIM_Key qualifier only.  If the CimWin32 MOF is exported, the CIM_Key qualifier can be directly replaced with the Key qualifier.  The data contained within the CIM_Key properties does not have to be modified.  
 
* Schema-specific properties and methods can be added to CIM classes.  This is allowed by the CIM Specification.  Microsoft uses this feature throughout the CimWin32 MOF, identifying additions as "Schema ("Win32")".
 
* CIM classes, with a few exceptions, are marked with the ABSTRACT qualifier throughout the CimWin32 MOF.  The "Abstract" qualifier states that there are no direct instances of the class.  (In other words, all instances are only instances of subclasses, and not the "Abstract" class itself.)  The use of the ABSTRACT qualifier disallows the installation of a Provider (declaring itself the instrumentation for the class).  At a CIM class level, a provider would have to be aware of the entire instance-level population, which is very unlikely.  In only a few cases does the Win32 Provider instrument CIM classes directly.  One example is the instrumentation of CIM_LogicalFile in the CIMV2 namespace.  
 
* The CimWin32 MOF does not consistently include an Override qualifier.  This will be corrected in the next release of the MOF.  Where property, method or reference names are duplicated in subclasses, these are actually overrides of the parent classes' constructs.  
 
* Where the Write qualifier is not explicitly listed for a property,  it is assumed that the qualifier is FALSE.  This is different than the CIM Schema definition (default value of TRUE).  Changing a qualifier's default value is allowed by the CIM Specification.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\utillib\placefil.txt ===
makefile	WMI_PSDK\Samples\VC\UTILLIB\
precomp.h	WMI_PSDK\Samples\VC\UTILLIB\
utillib.h	WMI_PSDK\Samples\VC\UTILLIB\
utillib.dsp	WMI_PSDK\Samples\VC\UTILLIB\
utils.cpp	WMI_PSDK\Samples\VC\UTILLIB\
Utillib.htm	WMI_PSDK\Samples\VC\UTILLIB\
wbemsec.cpp	WMI_PSDK\Samples\VC\UTILLIB\
precomp.h	WMI_PSDK\Samples\VC\UTILLIB\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\utillib\readme.txt ===
utillib.lib - A collection of routines used by some of the samples applications.

//***************************************************************************
// Function:   WbemErrorString
// Purpose:    Turns sc into a text string
//***************************************************************************
//***************************************************************************
// Function:  PrintError
// Purpose:   Formats and prints the error message
//***************************************************************************
//***************************************************************************
// Function:  PrintErrorAndExit
// Purpose:   Formats an error message & exits program
//***************************************************************************
//***************************************************************************
// Function:  PrintErrorAndAsk
// Purpose:   Prints the error message and prompts to continue
//***************************************************************************
//*****************************************************************************
// Function:   TypeToString
// Purpose:    Takes a variant, returns a pointer to a string that is the variant type
//*****************************************************************************
//*****************************************************************************
// Function:   TypeToString
// Purpose:    Takes a VARTYPE, returns a pointer to a string that is the variant type
//*****************************************************************************
//*****************************************************************************
// Function:   TypeToString
// Purpose:    Takes a CIMTYPE, returns a pointer to a string that is the variant type
//*****************************************************************************
//*****************************************************************************
// Function:   ValueToString 
// Purpose:    Takes a variant, returns a string representation of that variant
//*****************************************************************************
//*****************************************************************************
// Function:   cvt
// Purpose:    Converts unicode to oem for console output
// Note:       y must be freed by caller
//*****************************************************************************
//*****************************************************************************
// Function:   myWFPrintf
// Purpose:    Checks to see if outputing to console and converts strings
//             to oem if necessary.
// Note:       Returns number of characters written (ie if we write 3 oem
//             chars, it returns 3.  If it writes 4 wchars, it returns 4).
//*****************************************************************************
//*****************************************************************************
// Function:   difftime
// Purpose:    Returns the elapsed time between two _timeb structures
// Note:       This is different from the crt routine which works on time_t
//             structures.
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\wbemdump\placefil.txt ===
makefile	WMI_PSDK\Samples\VC\wbemdump\
wbemdump.cpp	WMI_PSDK\Samples\VC\wbemdump\
wbemdump.dsp	WMI_PSDK\Samples\VC\wbemdump\
wbemdump.dsw	WMI_PSDK\Samples\VC\wbemdump\
wbemdump.h	WMI_PSDK\Samples\VC\wbemdump\
WbemDump.htm	WMI_PSDK\Samples\VC\wbemdump\
wbemdump.exe    WMI_PSDK\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\schema.doc ===
Microsoft Word Document MSWordDoc Word.Document.8CIMV2 Namespace Restrictions TitleCIMV2 Namespace Restrictions Andrea Westerinen Normal.dot Michael Maston Microsoft Word 9.0bjbjU CIMV2 Namespace Usage Aligns This document aligns with Win32 Logo Requirements, and MSI and SMBIOS MOF Additions as of  01/2510/99 and defines the proper usage of the classes defined in the CIMV2 namespace. Generally, one of four cases may apply, namely: CIM classes which can be freely subclassed. The only restriction being that instances must always apply to the local machine.  CIM classes that cannot be subclassed directly. All the instances of the CIM class are required to be instances known to the win32 instrumentation. As a result subclasses may only be added to the provided Win32 subclasses. CIM classes that can be subclassed even though Win32 classes exist. In this case the set of instances provided by the Win32 classes are not assumed to be complete   that is, the instrumentation supplied cannot detect all relevant instances. It is expected that subclasses of the CIM class will be provided that return instances that are not discovered by the Win32 subclass providers. CIM classes that cannot be subclassed. These are either classes that are at a level of abstraction that makes subclassing undesirable (such as CIM_ManagedSystemElement) or that are simply not relevant to the local environment (such as CIM_Cluster). Note it is never acceptable in the CIMV2 namespace for third parties to instrument CIM classes directly.  1) The following Objects cClasses may be freely subclassed.     Subclasses should only be added Only where the instances introduced are for objects local to the machine. Classes CIM_FRU,  CIM_SupportAccess, CIM_Configuration,  CIM_MonitorResolution, CIM_RedundancyGroup and its subclasses CIM_ManagementController CIM_Statistics and its subclasses CIM_StorageError Associations Associations freely subclassed   Only for relationships local to the machine All CIM_Product associations (Exception is the  CIM_ProductSoftwareFeatures association which is addressed in the section, "Win32 associations with specific meaning") All CIM_FRU and CIM_SupportAccess associations All CIM_Configuration associations  All CIM_Statistics associations CIM_Realizes and most associations of the Physical Model (Exception is the CIM_Container association which is addressed in the section 3, "Win32 associations with specific meaning"). CIM_DeviceSoftware  CIM_AssociatedSensor and its subclasses CIM_BIOSLoadedInNV CIM_StorageDefect CIM_RedundancyComponent and its subclasses CIM_ActsAsSpare CIM_CollectionOfSensors CIM_DeviceServiceImplementation n and CIM_DeviceSAPImplementation 2) Win32 subclasses are provided for the following classes. Only direct subclasses of Win32 objects classes can be added., Tthat is, the CIM classes should not be subclassed directly.   - All instances must should be known to the CIMV2 instrumentation.     Classes CIM_UnitaryComputerSystem CIM_OperatingSystem CIM_FileSystem and its subclasses (Future) CIM_LogicalFile and its subclasses CIM_Process  and CIM_Thread CIM_Printer CIM_Scanner (Future) CIM_NetworkAdapter and its subclasses CIM_Controller and most of its subclasses (e.g., Video, SCSI, Serial, Parallel, PCI - Future, PCMCIA, USB) CIM_POTSModem CIM_MediaAccessDevice and its subclasses (e.g., CIM_DisketteDrive, CIM_WORMDrive and CIM_MagnetoOpticalDrive   All future) CIM_UserDevice and its subclasses  CIM_SystemResource and its subclasses CIM_Job  and CIM_JobDestination (Future) Associations Only direct subclasses of Win32 associations - All instances should be known to the CIMV2 instrumentation  CIM_HostedJobDestination  and CIM_JobDestinationJobs (Future) CIM_OSProcess  and CIM_ProcessThread (Future)  CIM_FileStorage  and CIM_DirectoryContainsFile (Future)  CIM_OperatingSystemSoftwareFeature (Future)  CIM_HostedFileSystem  and CIM_BootOSFromFS (Future)  CIM_InstalledOS  and CIM_RunningOS (Future) CIM_ProcessExecutable CIM_AllocatedResource CIM_ResidesOnExtent (Future) CIM_ComputerSystemResource CIM_Export  and CIM_Mount (Future) 3) The following Win32 subclasses are instrumented to return a specific and limited set of instances. There may be instances relevant to the local machine that are not provided by the Win32 classes and as a result subclasses are permitted of both the Win32 and CIM classes with specific meaning - Direct subclassing of Win32 classes is allowed.    Other subclasses of the CIM classes are allowed for objects instances local to the machine and not already known to the Win32 providers the CIMWin32 and MSIProv providers  The following Win32 subclasses are instrumented to return a specific and limited set of instances. There may be instances relevant to the local machine that are not provided by the Win32 classes and as a result subclasses are permitted of both the Win32 and CIM classes.  Direct subclassing of Win32 classes is allowed. Other subclasses of the CIM classes are allowed for instances local to the machine and not already known to the Win32 providers. You must be careful not to return instances that are already returned by the Win32 providers. Classes CIM_Service and its subclasses (Excludes BootServices that are hosted on a network and ClusteringService) - Win32 classes represent  executable objects that are installed in a registry database maintained by the Service Control Manager SoftwareElement and its subclasses   Win32 classes represent system BIOS and virtual device drivers Battery   Win32 classes represent laptop or UPS (COM-port attached) batteries CIM Battery   Win32 classes represent laptop or UP (COM-port attached) batteries CIM_PowerSupply and CIM_UninterruptiblePowerSupply   COM-port attached UPSs are represented CIM_StorageExtent and its subclasses   Win32 classes represent logical disks (subclass of CIM_LogicalDisk), partitions (subclass of CIM_DiskPartition) and the logical view of SCSI/RAID-based media  (subclass of CIM_VolumeSet)  CIM_StorageExtent and its subclasses   Win32 classes represent logical disks (subclass of CIM_LogicalDisk), partitions (subclass of CIM_DiskPartition) and the logical view of SCSI/RAID-based media  (subclass of CIM_VolumeSet, Future)  CIM_Processor  - Win32 classes represent  a device capable of interpreting a sequence of machine instructions on a Win32 system CIM_PhysicalElement and its subclasses - Win32 classes representing data available from SMBIOS (for examplee.g., system slots, connectors and enclosures) CIM_Memory and its subclasses - SMBIOS data is available (for examplee.g., system memory arrays and cache) CIM_CoolingDevice and its subclasses - Win32 classes represent data available from SMBIOS (for examplee.g., fans and refrigeration elements) CIM_Sensor and its subclasses - Win32 classes represent data available from SMBIOS (for examplee.g., temperature and voltage sensors) CIM_Product - ComputerSystemProduct and software "products" (installed by the Microsoft Software Installer, MSI) are defined and instantiated  CIM_Setting - Many subclasses exist containing System Device, User, boot, MSI resource and other information CIM_Service, CIM_ServiceAccessPoint and their subclasses - Services represent functionality hosted on the System and OperatingSystem. All OS drivers and Services are instantiated by the CIMV2 instrumentation.   CIM_SoftwareFeature, CIM_SoftwareElement, CIM_Checks, CIM_Actions and their subclasses represent represent the MSI (Microsoft Software Installer) view of applications. oOther installation technologies and individual applications may choose to add other subclasses at the same level in the schema. Associations Win32 associations with specific meaning - Direct subclassing of Win32 associations allowed Other subclasses of the CIM associations allowed for relationships local to the machine and not already known to the CIMWin32 and MSIProv providers CIM_SystemComponent and its subclasses - Many subclasses exist associating dDevices, uUsers, software and other classes CIM_AssociatedBattery  and CIM_AssociatedCooling  CIM_DeviceConnection   Win32 classes are various types of  ControlledBy  associations CIM_BasedOn   Win32 classes reference subclasses of CIM_LogicalDisks based on CIM_DiskPartitions or CIM_VolumeSets (Future) CIM_MediaPresent   (Future) Win32 between classes for subclasses of CIM_VolumeSets or CIM_DiskPartitions  CIM_AssociatedMemory - Win32 SMBIOS instrumentation exists for Win32_AssociatedProcessorMemory, relating a Win32_Processor and its cache CIM_Container - Win32 instantiates a Mmemory container, with data from SMBIOS CIM_ElementSetting - Win32 subclasses exist associating dDevices and their sSettings, uUsers with dDesktops, and many other elements CIM_HostedService, CIM_HostedAccessPoint and their subclasses, CIM_ServiceServiceDependency, CIM_ServiceSAPDependency, CIM_SAPSAPDependency, CIM_ServiceAccessBySAP,  (All future) - Win32 classes represent the associations of OS drivers and sServices All associations defined in the Application Model - Win32 classes represent the MSI view of applications   CIM_ProductSoftwareFeatures - Win32 subclass defines the "product" under which an MSI Software Feature is installed  4) For the following classes s Subclassing and direct instantiation is not allowed - These are high level objects classes or objects classes that contain instances that are not "local" to the machine  For the following classes subclassing and direct instantiation is not allowed.  These are high level classes or classes that contain instances that are not "local" to the machine. Classes CIM_ManagedSystemElement and, CIM_LogicalElement (Subclasses addressed separately) CIM_System and, CIM_ComputerSystem (Subclasses addressed separately) CIM_LogicalDevice (Subclasses addressed separately) CIM_VirtualComputerSystem CIM_Cluster , CIM_ClusteringService Associations Association subclassing and direct instantiation not allowed - These are high level relationships or relationships that are not "local" to the machine CIM_ApplicationSystemSoftwareFeature CIM_ComponentCS CIM_HostedClusterService,  CIM_ClusterServiceAccessBySAP CIM_HostingCS  and CIM_ParticipatingCS CIM_DeviceAccessedByFile (N/A for Win32 environment) GENERAL NOTES Where CIM classes are included in the CimWin32 MOF, these classes reflect the CIM V2.21 Schema, released by the DMTF (Desktop Management Task Force) in September 1998.   Several areas where the CimWin32 MOF differs are discussed below: Qualifiers exist in CIM as versatile and user-definable meta-data for the Schema.  Creating new qualifiers is allowed by the CIM Specification.  Several examples of new qualifiers (like the "Dynamic" qualifier) can be found in the CimWin32 MOF.     Many of the CIM Schema keys (identified using the Key qualifier) are labeled as "propagated" and are meant for object identification in an enterprise environment.  These "propagated" keys are typically not needed in the CIMV2 namespace, which reflects the local platform.  In these cases, the keys are identified with the CIM_Key qualifier only.  If the CimWin32 MOF is exported, the CIM_Key qualifier can be directly replaced with the Key qualifier.  The data contained within the CIM_Key properties does not have to be modified.   Schema-specific properties and methods can be added to CIM classes.  This is allowed by the CIM Specification.  Microsoft uses this feature throughout the CimWin32 MOF, identifying additions as "Schema ("Win32")". CIM classes, with a few exceptions, are marked with the ABSTRACT qualifier throughout the CimWin32 MOF.  The "Abstract" qualifier states that there are no direct instances of the class.  (In other words, all instances are only instances of subclasses, and not the "Abstract" class itself.)  The use of the ABSTRACT qualifier disallows the installation of a Provider (declaring itself the instrumentation for the class).  At a CIM class level, a provider would have to be aware of the entire instance-level population, which is very unlikely.  In only a few cases does the Win32 Provider instrument CIM classes directly.  One example is the instrumentation of CIM_LogicalFile in the CIMV2 namespace.   The CimWin32 MOF does not consistently include an Override qualifier.  This will be corrected in the next release of the MOF.  Where property, method or reference names are duplicated in subclasses, these are actually overrides of the parent classes' constructs.   Where the Write qualifier is not explicitly listed for a property,  it is assumed that the qualifier is FALSE.  This is different than the CIM Schema definition (default value of TRUE).  Changing a qualifier's default value is allowed by the CIM Specification.   dhg#2 dhg#2 dhf#2 ~wpwb[w dhc#2 dh`#2 dhU#2 dhU#2 dhU#2 dhU#2 zse^se^s^W dhk#2 dha#2 dhV#2 dhl#2 dhc#2 dhc#2 dhW#2 zsleWPW dhX#2 dhX#2 dhX#2 dhX#2 slesZ dhX#2 dhX#2 dha#2 dha#2 dha#2 dha#2 dhY#2 {tf_V_O dh\#2 dh\#2 dhY#2 dha#2 dha#2 dha#2 dha#2 dha#2 dha#2 dhe#2 dh]#2 dh[#2 dh\#2 dhZ#2 dhn#2 dh^#2 yfyfSy dhb#2 dhb#2 dhb#2 dhb#2 dhb#2 dh`#2 dhb#2 dhb#2 pibpb[pT dh_#2 uhu[Hu B2&OJ B2&OJ B2&OJ dh`#2 dh`#2 dh_#2 $`'0* 2p5@8 CPF I Q`T0W $`'0* 2p5@8 CPF I Q`T0W $`'0* 2p5@8 CPF I Q`T0W B2&OJ B2&OJ B2&OJ $`'0* 2p5@8 CPF I Q`T0W
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\psstools\wbemdump\readme.txt ===
WBEMDUMP - Dumps the contents of the CIMOM database.

Syntax: wbemdump [switches] [Namespace [Class|ObjectPath] ]
        wbemdump /Q [switches] Namespace QueryLanguage Query

Where:  'Namespace' is the namespace to dump (defaults to root\default)
        'Class' is the name of a specific class to dump (defaults to none)
        'ObjectPath' is one instance (ex "SClassA.KeyProp=\"foobar\"")
        'QueryLanguage' is any WBEM supported query language (currently only
           "WQL" is supported).
        'Query' is a valid query for the specified language, enclosed in quotes
        'switches' is one of
           /S Recurse down the tree
           /S2 Recurse down Namespaces (implies /S)
           /E Show system classes and properties
           /E1 Like /E except don't show __SERVER or __PATH property
           /E2 Shows command lines for dumping instances (test mode)
           /D Don't show properties
           /G Do a GetObject on all enumerated instances
           /M Get Class MOFS instead of data values
           /M2 Get Instance MOFS instead of data values
           /M3 Produce instance template
           /B:<num> CreateEnum flags (SemiSync=16; Forward=32)
           /W  Prompt to continue on warning errors
           /WY Print warnings and continue
           /H:<name>:<value> Specify context object value (test mode)
           /T Print times on /Q queries
           /O:<file> File name for output (creates Unicode file)
           /C:<file> Command file containing multiple WBEMDUMP command lines
           /U:<UserID> UserID to connect with (default: NULL)
           /P:<Password> Password to connect with (default: NULL)
           /A:<Authority> Authority to connect with
           /I:<ImpLevel> - Anonymous=1 Identify=2 Impersonate=3(dflt) Delegate=4

Notes:  - You can redirect the output to a file using standard redirection.
        - If the /C switch is used, the namespace on the command line must
          be the same namespace that is used for each of the command lines.
          It is not possible to use different namespaces on the different lines
          in the command file.

EXAMPLES:

  WBEMDUMP /S /E root\default            - Dumps everthing in root\default
  WBEMDUMP /S /E /M /M2 root\default     - Dump all class & instance mofs
  WBEMDUMP root\default foo              - Dumps all instances of the foo class
  WBEMDUMP root\default foo.name=\"bar\" - Dumps one instance of the foo class
  WBEMDUMP /S2 /M root    - Dumps mofs for all non-system classes in all NS's
  WBEMDUMP /Q root\default WQL "SELECT * FROM Environment WHERE Name=\"Path\""

A sample response file for the /C switch for this command line:

	wbemdump root\cimv2 /c:test.cmd

might look like this:

	/m Win32_SystemOperatingSystem 
	/m2 Win32_SystemOperatingSystem 
	/q wql "select * from win32_bios"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\diskperfwbem\readme.txt ===
********************************************************************************
Diskperf Driver WMI Sample
********************************************************************************

The Windows 2000 Professional Beta 3 DDK contains a WMI driver sample called the
diskperf driver. This driver is also standard in a Windows 2000 Professional Beta 3
installation.  The driver produces instrumentation data using WMI.  The recommended
way of viewing/setting data produced using WMI is WBEM.

This sample driver was also present in the Windows 2000 Beta 2 DDK. While this
application may also work with Windows 2000 Beta 2 and the driver in the Windows 2000
Beta 2 DDK, it is highly recommended that Windows 2000 Beta 3 and the Windows 2000
Beta 3 DDK be used.

This directory contains a sample WBEM application that surfaces the data
produced by the diskperf sample driver within the DDK.

To use this sample, the following steps are required:

1) Install Windows 2000 Professional Beta 3 operating system.

2) Install the WMI SDK for Windows 2000 Professional Beta 3.

3) Use NMAKE to compile and link the sample application provided here to produce
   dpwbem.exe.

4) If desired, the diskperf driver in the Windows 2000 Professional Beta 3 DDK can
   replace the one from the operating system install.  To do so, compile the 
   diskperf driver in the DDK and substitute it for the standard one.

5) Open Device Manager.  Select Disk Drives and view properties via the Action
   menu. Choose the Advanced tab on the properties dialog and check Enable Disk
   Performace Counters.

6) Restart Windows 2000 Professional and run dpwbem.exe. You should now see
   instrumentation data produced by the diskperf driver visible via the WBEM
   application.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\incidenttracker\readme.txt ===
IncidentTracker Sample Application System

Copyright (c)1997-1999 Microsoft Corporation
---------------------------------------------

This application system demonstrates, among other things, the use of the
WMI Event System in a network monitoring situation.  The application is
divided into three layers: The managed node (which has no applications
associated with it, only instances of classes used to register with the
Server), the server application (which recieves events from any number of
managed nodes and adds information to forward on to the console layer) and
the console layer.  The console layer provides the primary user interface
for the system (a minimal UI is provided on the server for event
registration purposes).  From the console the operator can register to
monitor for perticular types of events on selected machines and observe
the consequences of those events.

INSTALLATION
-------------

Before running the Console application it is necessary to lauch the WMI
Object Browser.  This will insure the installation of several required
ActiveX controls.

To install the system first compile the console and server applications (See
Build Notes).  These will be the console and server respectively.  They
can be run on a wide variety of network setups as well as on a single
machine.

For sinlge machine operation run the file incident tracker.bat.  This
will create the necessary system settings and compile the required MOFs

If the two applications are to run on different machines msareg.mof
should be compiled on any machine runnng msa.exe (server) and mcareg.mof should
be compiled on any machine running mca.exe (console).  It is also suggested that
the file sampler.bat be run on each machine that will be involved (while
not all the information included in this file is required on each machine,
this will insure thatthe minimal amount required is there).

USING THE SYSTEM
-----------------

To use the demo function first select Options|Load Demo and follow the
instructions that are presented.  The demo will walk through a scenario
where an NT event shuts down and this event is picked up by the system.
THIS DEMO WILL ONLY FUNCTION ON A WINDOWSNT MACHINE (4.0 and up) RUNNING
IIS.

For general purpose usage incidents will enter the console in the incident
pane (upper right) and evidence of their arrival can be seen in the activity
pane (lower right).  Selecting a point in the activity pane will highlight
the coresponding items in the incident pane.  Double-clicing on an item in
the Incident pane will bring that object up as the focus of the Object
Browser/Viewer (left side).  From here associations can be queried, methods
executed and properties can be evaluated.  It is also posible to select from
several predefined queries in the Options|Query... menu item.  If these are
not adaquate a custom query can be defined using WQL syntax.

Registration to recieve event types and server registrations are handled
through the File menu items.

For the Server new event queries can be defined and new namespaces added
to the monitored list through the Configure option.

==================================================================
Build Notes
==================================================================
Things to remember when you're building your own WMI client app.

1. Define  _WIN32_DCOM so that CoInitializeSecurity() is available. 
	This call (in InitInstance()) is required to work around a 
	security problem when WBEMOM trying to call a Sink object but 
	won't identify itself. The CoInitializeSecurity() call turns 
	off the authentication requirement. Don't use _WIN32_WINNT to get
	this prototype since it won't compile under Windows 9x OSs.

2. WMI interface is defined in wbemidl.h.

3. Run MIDL with all the *.idl files in the wmi\include directory.

4. WMI interface CLSIDs are defined in wbemcli_i.c. If you get 
	unresolved externals in interfaces and CLSIDs, this is 
	what's missing. 

5. Don't forget to used mofcomp.exe on the cimwin32.mof file. This 
	action tells CIMOM what the schema is. Other classes used in 
	the samples such as security related classes are built into 
	CIMOM and don't have a MOF file, and others are static classes/
	instances created by the sample code.

6. You'll need to link with oleaut32.lib and ole32.lib to get the 
	COM stuff.

7. You must use 'Automatic Use of Precompiled Headers' due to wbemcli_i.c.

8. In the Link|Output settings, specify 'wWinMainCRTStartup' as the 
	entry point. This is per the Unicode programming instructions.

9. If you're using the makefiles, don't forget to set the VC vars. In
	VC++ 5.0, its VCVARS32.BAT.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\schema.doc ===
Microsoft Word Document MSWordDoc Word.Document.8CIMV2 Namespace Restrictions TitleCIMV2 Namespace Restrictions Andrea Westerinen Normal.dot Michael Maston Microsoft Word 9.0bjbjU CIMV2 Namespace Usage Aligns This document aligns with Win32 Logo Requirements, and MSI and SMBIOS MOF Additions as of  01/2510/99 and defines the proper usage of the classes defined in the CIMV2 namespace. Generally, one of four cases may apply, namely: CIM classes which can be freely subclassed. The only restriction being that instances must always apply to the local machine.  CIM classes that cannot be subclassed directly. All the instances of the CIM class are required to be instances known to the win32 instrumentation. As a result subclasses may only be added to the provided Win32 subclasses. CIM classes that can be subclassed even though Win32 classes exist. In this case the set of instances provided by the Win32 classes are not assumed to be complete   that is, the instrumentation supplied cannot detect all relevant instances. It is expected that subclasses of the CIM class will be provided that return instances that are not discovered by the Win32 subclass providers. CIM classes that cannot be subclassed. These are either classes that are at a level of abstraction that makes subclassing undesirable (such as CIM_ManagedSystemElement) or that are simply not relevant to the local environment (such as CIM_Cluster). Note it is never acceptable in the CIMV2 namespace for third parties to instrument CIM classes directly.  1) The following Objects cClasses may be freely subclassed.     Subclasses should only be added Only where the instances introduced are for objects local to the machine. Classes CIM_FRU,  CIM_SupportAccess, CIM_Configuration,  CIM_MonitorResolution, CIM_RedundancyGroup and its subclasses CIM_ManagementController CIM_Statistics and its subclasses CIM_StorageError Associations Associations freely subclassed   Only for relationships local to the machine All CIM_Product associations (Exception is the  CIM_ProductSoftwareFeatures association which is addressed in the section, "Win32 associations with specific meaning") All CIM_FRU and CIM_SupportAccess associations All CIM_Configuration associations  All CIM_Statistics associations CIM_Realizes and most associations of the Physical Model (Exception is the CIM_Container association which is addressed in the section 3, "Win32 associations with specific meaning"). CIM_DeviceSoftware  CIM_AssociatedSensor and its subclasses CIM_BIOSLoadedInNV CIM_StorageDefect CIM_RedundancyComponent and its subclasses CIM_ActsAsSpare CIM_CollectionOfSensors CIM_DeviceServiceImplementation n and CIM_DeviceSAPImplementation 2) Win32 subclasses are provided for the following classes. Only direct subclasses of Win32 objects classes can be added., Tthat is, the CIM classes should not be subclassed directly.   - All instances must should be known to the CIMV2 instrumentation.     Classes CIM_UnitaryComputerSystem CIM_OperatingSystem CIM_FileSystem and its subclasses (Future) CIM_LogicalFile and its subclasses CIM_Process  and CIM_Thread CIM_Printer CIM_Scanner (Future) CIM_NetworkAdapter and its subclasses CIM_Controller and most of its subclasses (e.g., Video, SCSI, Serial, Parallel, PCI - Future, PCMCIA, USB) CIM_POTSModem CIM_MediaAccessDevice and its subclasses (e.g., CIM_DisketteDrive, CIM_WORMDrive and CIM_MagnetoOpticalDrive   All future) CIM_UserDevice and its subclasses  CIM_SystemResource and its subclasses CIM_Job  and CIM_JobDestination (Future) Associations Only direct subclasses of Win32 associations - All instances should be known to the CIMV2 instrumentation  CIM_HostedJobDestination  and CIM_JobDestinationJobs (Future) CIM_OSProcess  and CIM_ProcessThread (Future)  CIM_FileStorage  and CIM_DirectoryContainsFile (Future)  CIM_OperatingSystemSoftwareFeature (Future)  CIM_HostedFileSystem  and CIM_BootOSFromFS (Future)  CIM_InstalledOS  and CIM_RunningOS (Future) CIM_ProcessExecutable CIM_AllocatedResource CIM_ResidesOnExtent (Future) CIM_ComputerSystemResource CIM_Export  and CIM_Mount (Future) 3) The following Win32 subclasses are instrumented to return a specific and limited set of instances. There may be instances relevant to the local machine that are not provided by the Win32 classes and as a result subclasses are permitted of both the Win32 and CIM classes with specific meaning - Direct subclassing of Win32 classes is allowed.    Other subclasses of the CIM classes are allowed for objects instances local to the machine and not already known to the Win32 providers the CIMWin32 and MSIProv providers  The following Win32 subclasses are instrumented to return a specific and limited set of instances. There may be instances relevant to the local machine that are not provided by the Win32 classes and as a result subclasses are permitted of both the Win32 and CIM classes.  Direct subclassing of Win32 classes is allowed. Other subclasses of the CIM classes are allowed for instances local to the machine and not already known to the Win32 providers. You must be careful not to return instances that are already returned by the Win32 providers. Classes CIM_Service and its subclasses (Excludes BootServices that are hosted on a network and ClusteringService) - Win32 classes represent  executable objects that are installed in a registry database maintained by the Service Control Manager SoftwareElement and its subclasses   Win32 classes represent system BIOS and virtual device drivers Battery   Win32 classes represent laptop or UPS (COM-port attached) batteries CIM Battery   Win32 classes represent laptop or UP (COM-port attached) batteries CIM_PowerSupply and CIM_UninterruptiblePowerSupply   COM-port attached UPSs are represented CIM_StorageExtent and its subclasses   Win32 classes represent logical disks (subclass of CIM_LogicalDisk), partitions (subclass of CIM_DiskPartition) and the logical view of SCSI/RAID-based media  (subclass of CIM_VolumeSet)  CIM_StorageExtent and its subclasses   Win32 classes represent logical disks (subclass of CIM_LogicalDisk), partitions (subclass of CIM_DiskPartition) and the logical view of SCSI/RAID-based media  (subclass of CIM_VolumeSet, Future)  CIM_Processor  - Win32 classes represent  a device capable of interpreting a sequence of machine instructions on a Win32 system CIM_PhysicalElement and its subclasses - Win32 classes representing data available from SMBIOS (for examplee.g., system slots, connectors and enclosures) CIM_Memory and its subclasses - SMBIOS data is available (for examplee.g., system memory arrays and cache) CIM_CoolingDevice and its subclasses - Win32 classes represent data available from SMBIOS (for examplee.g., fans and refrigeration elements) CIM_Sensor and its subclasses - Win32 classes represent data available from SMBIOS (for examplee.g., temperature and voltage sensors) CIM_Product - ComputerSystemProduct and software "products" (installed by the Microsoft Software Installer, MSI) are defined and instantiated  CIM_Setting - Many subclasses exist containing System Device, User, boot, MSI resource and other information CIM_Service, CIM_ServiceAccessPoint and their subclasses - Services represent functionality hosted on the System and OperatingSystem. All OS drivers and Services are instantiated by the CIMV2 instrumentation.   CIM_SoftwareFeature, CIM_SoftwareElement, CIM_Checks, CIM_Actions and their subclasses represent represent the MSI (Microsoft Software Installer) view of applications. oOther installation technologies and individual applications may choose to add other subclasses at the same level in the schema. Associations Win32 associations with specific meaning - Direct subclassing of Win32 associations allowed Other subclasses of the CIM associations allowed for relationships local to the machine and not already known to the CIMWin32 and MSIProv providers CIM_SystemComponent and its subclasses - Many subclasses exist associating dDevices, uUsers, software and other classes CIM_AssociatedBattery  and CIM_AssociatedCooling  CIM_DeviceConnection   Win32 classes are various types of  ControlledBy  associations CIM_BasedOn   Win32 classes reference subclasses of CIM_LogicalDisks based on CIM_DiskPartitions or CIM_VolumeSets (Future) CIM_MediaPresent   (Future) Win32 between classes for subclasses of CIM_VolumeSets or CIM_DiskPartitions  CIM_AssociatedMemory - Win32 SMBIOS instrumentation exists for Win32_AssociatedProcessorMemory, relating a Win32_Processor and its cache CIM_Container - Win32 instantiates a Mmemory container, with data from SMBIOS CIM_ElementSetting - Win32 subclasses exist associating dDevices and their sSettings, uUsers with dDesktops, and many other elements CIM_HostedService, CIM_HostedAccessPoint and their subclasses, CIM_ServiceServiceDependency, CIM_ServiceSAPDependency, CIM_SAPSAPDependency, CIM_ServiceAccessBySAP,  (All future) - Win32 classes represent the associations of OS drivers and sServices All associations defined in the Application Model - Win32 classes represent the MSI view of applications   CIM_ProductSoftwareFeatures - Win32 subclass defines the "product" under which an MSI Software Feature is installed  4) For the following classes s Subclassing and direct instantiation is not allowed - These are high level objects classes or objects classes that contain instances that are not "local" to the machine  For the following classes subclassing and direct instantiation is not allowed.  These are high level classes or classes that contain instances that are not "local" to the machine. Classes CIM_ManagedSystemElement and, CIM_LogicalElement (Subclasses addressed separately) CIM_System and, CIM_ComputerSystem (Subclasses addressed separately) CIM_LogicalDevice (Subclasses addressed separately) CIM_VirtualComputerSystem CIM_Cluster , CIM_ClusteringService Associations Association subclassing and direct instantiation not allowed - These are high level relationships or relationships that are not "local" to the machine CIM_ApplicationSystemSoftwareFeature CIM_ComponentCS CIM_HostedClusterService,  CIM_ClusterServiceAccessBySAP CIM_HostingCS  and CIM_ParticipatingCS CIM_DeviceAccessedByFile (N/A for Win32 environment) GENERAL NOTES Where CIM classes are included in the CimWin32 MOF, these classes reflect the CIM V2.21 Schema, released by the DMTF (Desktop Management Task Force) in September 1998.   Several areas where the CimWin32 MOF differs are discussed below: Qualifiers exist in CIM as versatile and user-definable meta-data for the Schema.  Creating new qualifiers is allowed by the CIM Specification.  Several examples of new qualifiers (like the "Dynamic" qualifier) can be found in the CimWin32 MOF.     Many of the CIM Schema keys (identified using the Key qualifier) are labeled as "propagated" and are meant for object identification in an enterprise environment.  These "propagated" keys are typically not needed in the CIMV2 namespace, which reflects the local platform.  In these cases, the keys are identified with the CIM_Key qualifier only.  If the CimWin32 MOF is exported, the CIM_Key qualifier can be directly replaced with the Key qualifier.  The data contained within the CIM_Key properties does not have to be modified.   Schema-specific properties and methods can be added to CIM classes.  This is allowed by the CIM Specification.  Microsoft uses this feature throughout the CimWin32 MOF, identifying additions as "Schema ("Win32")". CIM classes, with a few exceptions, are marked with the ABSTRACT qualifier throughout the CimWin32 MOF.  The "Abstract" qualifier states that there are no direct instances of the class.  (In other words, all instances are only instances of subclasses, and not the "Abstract" class itself.)  The use of the ABSTRACT qualifier disallows the installation of a Provider (declaring itself the instrumentation for the class).  At a CIM class level, a provider would have to be aware of the entire instance-level population, which is very unlikely.  In only a few cases does the Win32 Provider instrument CIM classes directly.  One example is the instrumentation of CIM_LogicalFile in the CIMV2 namespace.   The CimWin32 MOF does not consistently include an Override qualifier.  This will be corrected in the next release of the MOF.  Where property, method or reference names are duplicated in subclasses, these are actually overrides of the parent classes' constructs.   Where the Write qualifier is not explicitly listed for a property,  it is assumed that the qualifier is FALSE.  This is different than the CIM Schema definition (default value of TRUE).  Changing a qualifier's default value is allowed by the CIM Specification.   dhg#2 dhg#2 dhf#2 ~wpwb[w dhc#2 dh`#2 dhU#2 dhU#2 dhU#2 dhU#2 zse^se^s^W dhk#2 dha#2 dhV#2 dhl#2 dhc#2 dhc#2 dhW#2 zsleWPW dhX#2 dhX#2 dhX#2 dhX#2 slesZ dhX#2 dhX#2 dha#2 dha#2 dha#2 dha#2 dhY#2 {tf_V_O dh\#2 dh\#2 dhY#2 dha#2 dha#2 dha#2 dha#2 dha#2 dha#2 dhe#2 dh]#2 dh[#2 dh\#2 dhZ#2 dhn#2 dh^#2 yfyfSy dhb#2 dhb#2 dhb#2 dhb#2 dhb#2 dh`#2 dhb#2 dhb#2 pibpb[pT dh_#2 uhu[Hu B2&OJ B2&OJ B2&OJ dh`#2 dh`#2 dh_#2 $`'0* 2p5@8 CPF I Q`T0W $`'0* 2p5@8 CPF I Q`T0W $`'0* 2p5@8 CPF I Q`T0W B2&OJ B2&OJ B2&OJ $`'0* 2p5@8 CPF I Q`T0W
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\reindeerprov\readme.txt ===
This is a sample provider using the provider framework.
This code was generated using the WBEM cpp code generator wizard.

Note : this sample will build "release" by default. This is because it needs
to run with the provider framework code which is also built release. 
If you want to build it "debug", you will need a debug version of the framework 
for it.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\nondistrib\wbembrowser\readme.txt ===
========================================================================
       MICROSOFT FOUNDATION CLASS LIBRARY : WbemBrowser
========================================================================


AppWizard has created this WbemBrowser application for you.  This application
not only demonstrates the basics of using the Microsoft Foundation classes
but is also a starting point for writing your application.

This file contains a summary of what you will find in each of the files that
make up your WbemBrowser application.

WbemBrowser.h
    This is the main header file for the application.  It includes other
    project specific headers (including Resource.h) and declares the
    CWbemBrowserApp application class.

WbemBrowser.cpp
    This is the main application source file that contains the application
    class CWbemBrowserApp.

WbemBrowser.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Developer Studio.

res\WbemBrowser.ico
    This is an icon file, which is used as the application's icon.  This
    icon is included by the main resource file WbemBrowser.rc.

res\WbemBrowser.rc2
    This file contains resources that are not edited by Microsoft 
	Developer Studio.  You should place all resources not
	editable by the resource editor in this file.

WbemBrowser.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.

/////////////////////////////////////////////////////////////////////////////

For the main frame window:

MainFrm.h, MainFrm.cpp
    These files contain the frame class CMainFrame, which is derived from
    CFrameWnd and controls all SDI frame features.

res\Toolbar.bmp
    This bitmap file is used to create tiled images for the toolbar.
    The initial toolbar and status bar are constructed in the
    CMainFrame class.  Edit this toolbar bitmap along with the
    array in MainFrm.cpp to add more toolbar buttons.

/////////////////////////////////////////////////////////////////////////////

AppWizard creates one document type and one view:

WbemBrowserDoc.h, WbemBrowserDoc.cpp - the document
    These files contain your CWbemBrowserDoc class.  Edit these files to
    add your special document data and to implement file saving and loading
    (via CWbemBrowserDoc::Serialize).

WbemBrowserView.h, WbemBrowserView.cpp - the view of the document
    These files contain your CWbemBrowserView class.
    CWbemBrowserView objects are used to view CWbemBrowserDoc objects.



/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named WbemBrowser.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Developer Studio reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

If your application uses MFC in a shared DLL, and your application is 
in a language other than the operating system's current language, you
will need to copy the corresponding localized resources MFC40XXX.DLL
from the Microsoft Visual C++ CD-ROM onto the system or system32 directory,
and rename it to be MFCLOC.DLL.  ("XXX" stands for the language abbreviation.
For example, MFC40DEU.DLL contains resources translated to German.)  If you
don't do this, some of the UI elements of your application will remain in the
language of the operating system.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\html\jscript\placefil.txt ===
ajsservice1.htm	WMI_PSDK\Samples\Scripting\html\jscript\
jsservice1.htm	WMI_PSDK\Samples\Scripting\html\jscript\
jsservice2.htm	WMI_PSDK\Samples\Scripting\html\jscript\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\asp\vbscript\placefil.txt ===
vbsdiskinfo.asp	WMI_PSDK\Samples\Scripting\asp\vbscript\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\asp\jscript\placefil.txt ===
jsdiskinfo.asp	WMI_PSDK\Samples\Scripting\asp\jscript\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\html\vbscript\readme.txt ===
VBSCLASSBROWSER.HTM README


In order to run the VBCLASSBROWSER sample you must first ensure that 
the WMI Class Navigator and WMI Login ActiveX controls are installed 
on your system.  Failure to ensure this will result in the sample 
being unable to load the controls, and they will not appear on the page.

To install the WMI controls, run one of the WMI SDK tools (for example, CIM Studio).
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\html\vbscript\placefil.txt ===
avbsservice1.htm	WMI_PSDK\Samples\Scripting\html\vbscript\
vbsservice1.htm		WMI_PSDK\Samples\Scripting\html\vbscript\
vbsservice2.htm		WMI_PSDK\Samples\Scripting\html\vbscript\
calendar.htc		WMI_PSDK\Samples\Scripting\html\vbscript\Datetime
datetime.htc		WMI_PSDK\Samples\Scripting\html\vbscript\Datetime
datetime.hta		WMI_PSDK\Samples\Scripting\html\vbscript\Datetime
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\readme\placefil.txt ===
readme.txt	WMI_PSDK\Samples\Scripting\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\vb\vbinstance\placefil.txt ===
form1.frm	WMI_PSDK\Samples\Scripting\vb\VBInstance\
form1.frx	WMI_PSDK\Samples\Scripting\vb\VBInstance\
VBInstance.vbp	WMI_PSDK\Samples\Scripting\vb\VBInstance\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\vb\vblogdisk\placefil.txt ===
form1.frm	WMI_PSDK\Samples\Scripting\vb\VBLogDisk\
vblogdisk.vbp	WMI_PSDK\Samples\Scripting\vb\VBLogDisk\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\vb\vbprocess\placefil.txt ===
VBProcess.vbp	WMI_PSDK\Samples\Scripting\vb\VBProcess\
Form1.frm	WMI_PSDK\Samples\Scripting\vb\VBProcess\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\vb\readme\placefil.txt ===
VBSamples.htm	WMI_PSDK\Samples\Scripting\vb\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\vb\readme\readme.txt ===
WMI SDK Scripting VB Samples Summary by Subdirectory.

Each of the folowing subdirectories contains the VB 6.0 project files 
required to build the application.

Any additional controls required as described below on a per-sample basis.  
These controls are installed automatically as part of Visual Basic
Professional or Enterprise editions.

--------------------------------------------------------------------------
.\VBInstance

A Instance property graphing application.  This sample should be run
using 1024x768 (or higher) screen resolution. 


Requires:	MSCHRT20.OCX, MSFLXGRD.OCX

--------------------------------------------------------------------------
.\VBLogDisk

A Disk viewing application.

--------------------------------------------------------------------------
.\VBProcess

A Process viewing application.   

Requires:	MSCOMCTL.OCX, MSCOMCT2.OCX

--------------------------------------------------------------------------
.\VBService

A Service manager application.  This sample should be run using 
1024x768 (or higher) screen resolution.

Requires:	MSCOMCTL.OCX, MSCOMM32.OCX, COMDLG32.OCX
		COMCT332.OCX, MSCOMCT2.OCX
--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\vb\vbservice\placefil.txt ===
VBService.vbp	WMI_PSDK\Samples\Scripting\vb\VBService\
Form1.frm	WMI_PSDK\Samples\Scripting\vb\VBService\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\readme\readme.txt ===
WMI SDK Scripting Samples Summary by Subdirectory.

--------------------------------------------------------------------------
.\asp\VBScript

Shows how to use WMI Scripting from an ASP page, using VBScript.  

For NT4 the registry value

  HKEY_LOCAL_MACHINE\Software\Microsoft\WBEM\Scripting\Enable for ASP

must be set to 1 before running ASP pages containing WMI script. However
please consult the WMI SDK documentation for the other affects of setting
this value before proceeding.

For Windows 2000, ensure that Anonymous Access is disabled and Windows
Integrated Authentication is enabled for this file before running this 
ASP (this can be done by configuring the file properties using the IIS 
configuration snap-in).

--------------------------------------------------------------------------
.\asp\JScript

Shows how to use WMI Scripting from an ASP page, using JScript.  

For NT4 the registry value

  HKEY_LOCAL_MACHINE\Software\Microsoft\WBEM\Scripting\Enable for ASP

must be set to 1 before running ASP pages containing WMI script. However
please consult the WMI SDK documentation for the other affects of setting
this value before proceeding.

For Windows 2000, ensure that Anonymous Access is disabled and Windows
Integrated Authentication is enabled for this file before running this 
ASP (this can be done by configuring the file properties using the IIS 
configuration snap-in).

--------------------------------------------------------------------------
.\html\JScript

Shows how to use WMI Scripting from an HTML page, using JScript.

--------------------------------------------------------------------------
.\html\VBScript

Shows how to use WMI Scripting from an HTML page, using VBScript.

--------------------------------------------------------------------------
..\VB

Shows how to use WMI Scripting from a VB application.  

--------------------------------------------------------------------------
..\WSH\VBScript

Shows how to use WMI Scripting from Windows Scripting Host (WSH), using
VBScript.

--------------------------------------------------------------------------
..\WSH\JScript

Shows how to use WMI Scripting from Windows Scripting Host (WSH), using
JScript.

--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\registry\perl\placefil.txt ===
registry.htm	WMI_PSDK\Samples\Scripting\WSH\Perl\Registry\
registry.mof	WMI_PSDK\Samples\Scripting\WSH\Perl\Registry\
registry.pl	WMI_PSDK\Samples\Scripting\WSH\Perl\Registry\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\wsh\jscript\placefil.txt ===
arraytype.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
classenum.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
derivation.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
embprop.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
emptyarray.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
execmethod.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
instenum.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
methodex.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
methodset.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
nvs.js		WMI_PSDK\Samples\Scripting\wsh\jscript\
nvs2.js		WMI_PSDK\Samples\Scripting\wsh\jscript\
nvsarray.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
objpath.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
process.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
proparray.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
properties.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
property.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
putinstance.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
qualarray.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
qualifier.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
system.js	WMI_PSDK\Samples\Scripting\wsh\jscript\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\perfmon\perl\placefil.txt ===
perfmon.htm	WMI_PSDK\Samples\Scripting\WSH\Perl\Perfmon\
perfmon.mof	WMI_PSDK\Samples\Scripting\WSH\Perl\Perfmon\
perfmon.pl	WMI_PSDK\Samples\Scripting\WSH\Perl\Perfmon\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\perfmon\vbscript\placefil.txt ===
perfmon.htm	WMI_PSDK\Samples\Scripting\WSH\VBScript\Perfmon\
perfmon.mof	WMI_PSDK\Samples\Scripting\WSH\VBScript\Perfmon\
perfmon.vbs	WMI_PSDK\Samples\Scripting\WSH\VBScript\Perfmon\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\registry\vbscript\placefil.txt ===
registry.htm	WMI_PSDK\Samples\Scripting\WSH\VBScript\Registry\
registry.mof	WMI_PSDK\Samples\Scripting\WSH\VBScript\Registry\
registry.vbs	WMI_PSDK\Samples\Scripting\WSH\VBScript\Registry\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\wsh\perl\placefil.txt ===
backupeventlog.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
cimomid.pl		WMI_PSDK\Samples\Scripting\wsh\perl\
cleareventlog.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
datetime.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
deleteservice.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
derivation.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
disableDHCP.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
dnsdomainname.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
domainname.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
emptyarray.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
enableDHCP.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
errmsg.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
getappboost.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
getbootconfig.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
getnetworkadapterconfig.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
listeventlogfiles.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
listeventsbycode.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
listnetworkadapters.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
listnetworkprotocols.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
listservices.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
machinename.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
methodex.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
ntevent.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
nvsarray.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
objset.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
osinfo.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
pathbuild.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
pauseservice.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
printerstatus.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
printjobs.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
privilege.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
process.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
reboot.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
remotereboot.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
remoteshutdown.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
resumeservice.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
schema.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
service.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
servicestopped.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
shutdown.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
spawn.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
startservice.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
stopservice.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
system.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
viewpagefilesettings.pl	WMI_PSDK\Samples\Scripting\wsh\perl\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\scripting\automation\wsh\vbscript\placefil.txt ===
backupeventlog.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
cimomid.vbs		WMI_PSDK\Samples\Scripting\wsh\vbscript\
cleareventlog.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
datetime.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
deleteservice.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
derivation.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
disableDHCP.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
dnsdomainname.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
domainname.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
emptyarray.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
enableDHCP.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
errmsg.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
getappboost.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
getbootconfig.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
getnetworkadapterconfig.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
listeventlogfiles.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
listeventsbycode.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
listnetworkadapters.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
listnetworkprotocols.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
listservices.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
machinename.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
methodex.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
ntevent.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
nvsarray.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
objset.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
osinfo.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
pathbuild.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
pauseservice.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
printerstatus.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
printjobs.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
privilege.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
process.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
reboot.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
remotereboot.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
remoteshutdown.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
resettodefault.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
resumeservice.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
schema.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
service.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
servicestopped.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
shutdown.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
spawn.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
startservice.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
stopservice.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
system.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
viewpagefilesettings.vbs	WMI_PSDK\Samples\Scripting\wsh\vbscript\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\placefil.txt ===
AdvClient.cpp	WMI_PSDK\Samples\VC\AdvClient\
AdvClient.dsp	WMI_PSDK\Samples\VC\AdvClient\
AdvClient.h	WMI_PSDK\Samples\VC\AdvClient\
AdvClient.rc	WMI_PSDK\Samples\VC\AdvClient\
AdvClientDlg.cpp	WMI_PSDK\Samples\VC\AdvClient\
AdvClientDlg.h	WMI_PSDK\Samples\VC\AdvClient\
Client.htm	WMI_PSDK\Samples\VC\AdvClient\
OfficeDlg.cpp	WMI_PSDK\Samples\VC\AdvClient\
OfficeDlg.h	WMI_PSDK\Samples\VC\AdvClient\
OnAddEquipment.cpp	WMI_PSDK\Samples\VC\AdvClient\
OnAsync.cpp	WMI_PSDK\Samples\VC\AdvClient\
OnAsync.h	WMI_PSDK\Samples\VC\AdvClient\
OnConnect.cpp	WMI_PSDK\Samples\VC\AdvClient\
OnDiskDetails.cpp	WMI_PSDK\Samples\VC\AdvClient\
OnDiskPropsDescriptions.cpp	WMI_PSDK\Samples\VC\AdvClient\
OnEnumDisks.cpp	WMI_PSDK\Samples\VC\AdvClient\
OnEnumSvcs.cpp	WMI_PSDK\Samples\VC\AdvClient\
OnPerm.cpp	WMI_PSDK\Samples\VC\AdvClient\
OnRegister.cpp	WMI_PSDK\Samples\VC\AdvClient\
OnTemp.cpp	WMI_PSDK\Samples\VC\AdvClient\
OnTemp.h	WMI_PSDK\Samples\VC\AdvClient\
resource.h	WMI_PSDK\Samples\VC\AdvClient\
StdAfx.cpp	WMI_PSDK\Samples\VC\AdvClient\
StdAfx.h	WMI_PSDK\Samples\VC\AdvClient\
makefile	WMI_PSDK\Samples\VC\AdvClient\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\basichiperf\sampcli\placefil.txt ===
makefile	WMI_PSDK\Samples\VC\HiPerfClient\
RefClint.cpp	WMI_PSDK\Samples\VC\HiPerfClient\
RefClint.h	WMI_PSDK\Samples\VC\HiPerfClient\
SamplCli.cpp	WMI_PSDK\Samples\VC\HiPerfClient\
SamplCli.dsp	WMI_PSDK\Samples\VC\HiPerfClient\
SamplCli.html	WMI_PSDK\Samples\VC\HiPerfClient\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\basichiperf\src\placefil.txt ===
BasicHiPerf.cpp	WMI_PSDK\Samples\VC\HiPerfProvider\
BasicHiPerf.def	WMI_PSDK\Samples\VC\HiPerfProvider\
BasicHiPerf.dsp	WMI_PSDK\Samples\VC\HiPerfProvider\
BasicHiPerf.h	WMI_PSDK\Samples\VC\HiPerfProvider\
BasicHiPerf.html	WMI_PSDK\Samples\VC\HiPerfProvider\
BasicHiPerf.mof	WMI_PSDK\Samples\VC\HiPerfProvider\
Factory.cpp	WMI_PSDK\Samples\VC\HiPerfProvider\
Factory.h	WMI_PSDK\Samples\VC\HiPerfProvider\
makefile	WMI_PSDK\Samples\VC\HiPerfProvider\
server.cpp	WMI_PSDK\Samples\VC\HiPerfProvider\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\advclient\readme.txt ===
==================================================================
					WMI Client Sample
==================================================================
This sample demonstrates various ways to do use WMI features. 
Where multiple ways exist to do the same things, an effort was 
made to show each way. Use the following table of contexts to 
find the technique you want. The implementation of each 'button' 
is in a separate .cpp file to make it easier to deal with. Common
helper routines are in the SampDlg.cpp file itself. Class-wise, 
all WMI code is in the main dialog.

This app is a dialog-based app created by AppWizard and 
using MFC for simplicity. The code is designed to be easy to 
follow and doesn't necessarily show a good practice for building 
'real' WMI client apps. Concentrate on the steps and architect 
your app in a way that makes sense for you.

==================================================================
Build Notes
==================================================================
Things to remember when you're building your own WMI client app.

1. If you want your client to run on NT and non-DCOM versions of Win95, 
	manually load the ole32.dll and see if CoInitializeSecurity() exists. 
	This routine wont exist on win95 OS's that dont have DCOM installed 
	separately. If this routine doesn't exist, the async routines in 
	this sample wont work because of mismatched security level problems. 
	The synchronous techniques will still work.

2. If you dont care about non-DCOM versions of win95, you can define  
	_WIN32_DCOM so that CoInitializeSecurity() is available for implicit
	linking. Don't use _WIN32_WINNT to get this prototype since it 
	won't compile under Windows 9x OSs.

3. Either way, this call (in InitInstance()) is required to work around a 
	security problem when WMI trying to call a Sink object but 
	won't identify itself. The CoInitializeSecurity() call turns 
	off the authentication requirement. 

4.  WMI interfaces are defined in wbemcli.h and wbemprov.h found in 
	the wmi\include directory.  You may #include both these files by 
	including just wbemidl.h located in the same directory.

5. WMI interface CLSIDs are defined in wbemuuid.lib. If you get 
	unresolved externals in interfaces and CLSIDs, this is 
	what's missing. 

6. You'll need to link with oleaut32.lib and ole32.lib to get the 
	COM stuff.

7. In the Link|Output settings, specify 'wWinMainCRTStartup' as the 
	entry point. This is per the Unicode programming instructions.

8. If you're using the makefiles, don't forget to set the VC vars. In
	VC++ 5.0, its VCVARS32.BAT.

==================================================================
UI Summary
==================================================================
Button					File						Action
------					----						------
Connect					OnConnect.cpp				Connects to specified 
													namespace.

Exit					WBEMSampDlg.cpp				Exits the app.

Enum Disks				OnEnumDisks.cpp				lists the logical disks.

Get C: Disk Details		OnDiskDetails.cpp			lists C: disk properties.

Enum Services			OnEnumSvcs.cpp				lists the services.

Enum Services Async		OnAsync.cpp					lists the services.

Add Equipment			OnAddEquipment.cpp			adds to a list of office
													equipment.

Register Perm			OnPerm.cpp					registers/unregisters the 
													local-server event consumer 
													WbemPermConsumer.exe.

Register Temp			OnTemp.cpp					registers/unregisters the 
													in-proc event consumer; 
													CEventSink in OnTemp.*.

About Disk Properties   OnDiskPropsDescriptions.cpp lists the description of the 
													logical disk class, as well as
													descriptions of all its properties.
													Note that this information is
													localizable and will be displayed in
													the language that corresponds to the
													current user locale on the client 
													machine, as long as the server has 
													corresponding localized resources.

You can connect to remote machines by changing the namespace before 
connecting.

The results of actions show up in the upper listbox. Event related 
messages go in the lower listbox. The Permanent Event Consumer is 
a separate app that will start as needed.

On Windows 95, no services will list because win95 doesn't have 
services. This is normal.

==================================================================
Task: Connecting to a namespace
==================================================================
Implementations:
OnConnect.cpp shows how to connect to a namespace.  This will enable the
rest of the buttons because they all require the client to be connected.
\root\cimv2 is the most commonly used namespace since the win32 
schema classes are in it. \root\security is also built-in but it 
only contains security related classes. In this example, the '.' 
(dot) can be replaced with a remote machine's name to connect 
remotely. Dot is used for the local machine.

OnAddEquipment.cpp uses OpenNamespace() to connect to root\cimv2\office 
because its UNDER root\cimv2 and relative navigation is possible.

==================================================================
Task: Enumerating classes
==================================================================
Implementation:
OnEnumDisks.cpp creates an enumerator for all instances of disks then
walks the result list using the 'classic' OLE enumerator scheme. 
Properties are extracted for display.

==================================================================
Task: Enumerating properties
==================================================================
Implementation:
OnDiskDetails.cpp enumerates the properties for your C: drive. It uses 
GetNames() to get a SAFEARRAY of property names which is then using to 
Get() property values directly.

==================================================================
Task: Retrieving (amended) qualifiers
==================================================================
Implementation:
OnDiskPropsDescriptions.cpp lists class description and property descriptions
for Win32_LogicalDisk class. Note that description qualifiers can be quite lengthy
and are normally not retrieved, unless WBEM_FLAG_USE_AMENDED_QUALIFIERS flag 
is specified in IWbemServices::GetObject(). 

Object qualifiers are retieved by IWbemClassObject::GetQualifierSet(). 
Property qualifiers are retrieved by IWbemClassObject::GetPropertyQualifierSet() 
- you need to supply property name as a parameter.

Get() method on the IWbemQualifierSet retrives specific qualifier values - 
in this case, descriptions.

Amended qualifiers (such as descriptions) are localizable and 
will be displayed in the language that corresponds to the current user 
locale on the client machine, as long as the server is able to provide
appropriate localized resources.

==================================================================
Task: Using WQL for queries
==================================================================
Implementation:
OnEnumSvcs.cpp uses ExecQuery() to issue a WQL query to find all 
services running on the machine. It then uses the BeginEnumeration()/
Next()/EndEnumeration() scheme to walk through the properties for 
each service-- looking for the properties of interest. This is a 
contrived example for demo purposes only. This scheme is normally 
used for displaying ALL properties rather than looking for particular 
ones.

==================================================================
Task: Using WQL for asynchronous queries
==================================================================
Implementation:
OnAsync.cpp does exactly the same thing as OnEnumSvcs.cpp except it 
does it asychronously. ExecQueryAsync() is passed a CAsyncQuerySink 
COM object which implements an IWbemObjectSink. This object has it's 
Indicate() and SetStatus() called for the reesult of the query instead
of creating an enumerator.

==================================================================
Task: Creating user-defined classes
==================================================================
Implementation:
OnAddEquipment.cpp shows how to create classes and instances. After 
prompting for items in your office, the OfficeEquipment class is 
created if it already doesn't exist then a new instance of the class 
is created for the item you typed into the dialog box. Once the first
equipment is added, the special namespace will exist and the "Register"
buttons will enable since they get events from this namespace. The 
namespace must exist before you can register for its events.

==================================================================
Task: Creating instances
==================================================================
Implementations:
OnAddEquipment.cpp creates instances of the user-defined classes.

==================================================================
Task: Creating new namespaces
==================================================================
Implementation:
OnAddEquipment.cpp creates a namespace of root\cimv2\office to 
store the OfficeEquipment class and instances.

==================================================================
Task: Temporary Event Consumers
==================================================================
Implementation:
OnTemp.cpp registers and unregisters temporary events. CEventSink is
the interface that is called to handle those events. It hooks instances
of "OfficeEquipment" being created. This is the class defined/used by
OnAddEquipment.cpp. Temporary events are displayed in the lower listbox.

==================================================================
Task: Permanent Event Consumers
==================================================================
Implementation:
OnPerm.cpp registers and unregisters Permanent events. It hooks the
same events as OnTemp.cpp so that you can compare and contrast. The
events are handled by WBEMPermEvents.exe; a separate project under
wmi\samples\EventConsumer. Events are displayed in this separate 
app. The registry entries required to allow CIMOM to spawn a local 
server which displays to the user's desktop is documented in the 
RegisterServer() routine of that app. You must run 'mofcomp SampleViewer.mof'
to register the Event Consumer before the Register Perm function 
will work.

==================================================================
Task: Dealing With Security
==================================================================
When using temporary events, the CIMOM service calls back to the 
client app. The default security authentication setting doesn't 
allow this call to get through. The client app must lower its 
authentication setting for these callbacks to work. This is 
complicated by the fact that Windows 95 doesn't come with DCOM
which contains the CoInitializeSecurity() routine (OLE32.dll is 
updated when you install DCOM). The logic for dealing with this 
security issue is in CWbemSampleApp::InitSecurity() in WBEMSamp.cpp.

You also must call IClientSecurity::SetBlanket() for any IWbemServices
or IEnumWbemClassObject. See CWBEMSampleDlg::SetBlanket() in OnConnect.cpp
for this technique.

END readme.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\classprov\placefil.txt ===
CLASSFAC.CPP	WMI_PSDK\Samples\VC\ClassProv\
classprov.cpp	WMI_PSDK\Samples\VC\ClassProv\
classprov.DEF	WMI_PSDK\Samples\VC\ClassProv\
ClassProv.dsp	WMI_PSDK\Samples\VC\ClassProv\
ClassProv.htm	WMI_PSDK\Samples\VC\ClassProv\
classprov.MOF	WMI_PSDK\Samples\VC\ClassProv\
MAINDLL.CPP	WMI_PSDK\Samples\VC\ClassProv\
Makefile	WMI_PSDK\Samples\VC\ClassProv\
SAMPLE.H	WMI_PSDK\Samples\VC\ClassProv\
UTILS.CPP	WMI_PSDK\Samples\VC\ClassProv\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\classprov\readme.txt ===
This sample code creates a WMI Class Provider.

The instances are defined using an array named MyDefs which is 
declared in classprov.cpp.  The class is quite simple and consists of a 
string Key property and an integer property.

This sample does not support any updating.

To get the sample working, do the following;
1) Build using MAKEFILE. 

2) Make sure that the class is defined by using the MOF compiler.
Ex; c:\wbem\mofcomp classprov.mof

3) Register the DLL by using the self registration technique.
Ex; c:>regsvr32 classprov.dll

4) Using some sort of browser, get the instances of "ClassProvSamp" class, or
get the object 

ClassProvSamp.MyKey="a"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\res\placefil.txt ===
CmdLineConsumer.ico	WMI_PSDK\Samples\VC\CmdLineConsumer\res\
CmdLineConsumer.rc2	WMI_PSDK\Samples\VC\CmdLineConsumer\res\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\readme.txt ===
This is a generic event consumer that spawns another app
according to the logical consumer instance.

This consumer is registered by running "mofcomp cmdline.mof".

The logical consumer is defined as:

class CmdLineEventConsumer : __EventConsumer
{
    [key] string Name;
	[read, write]
    string cmdLine;
	[read, write]
	uint8 showWindow;
};

- Name is any convenient string.
- cmdLine is the command line you want to run when this
	consumer instance is called.
- showWindow is a value used to control the dos box in which
	the 'cmdLine' will be run. These values are defined by
	ShowWindow() in the win32 API. For reference, they are:

	#define SW_HIDE             0
	#define SW_SHOWNORMAL       1
	#define SW_NORMAL           1
	#define SW_SHOWMINIMIZED    2
	#define SW_SHOWMAXIMIZED    3
	#define SW_MAXIMIZE         3
	#define SW_SHOWNOACTIVATE   4
	#define SW_SHOW             5
	#define SW_MINIMIZE         6
	#define SW_SHOWMINNOACTIVE  7
	#define SW_SHOWNA           8
	#define SW_RESTORE          9
	#define SW_SHOWDEFAULT      10

	NOTE: Use the number; not the symbol.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\cmdlineconsumer\src\placefil.txt ===
cmdLine.mof	WMI_PSDK\Samples\VC\CmdLineConsumer\
CmdLineConsumer.cpp	WMI_PSDK\Samples\VC\CmdLineConsumer\
CmdLineConsumer.dsp	WMI_PSDK\Samples\VC\CmdLineConsumer\
CmdLineConsumer.h	WMI_PSDK\Samples\VC\CmdLineConsumer\
CmdLineConsumer.htm	WMI_PSDK\Samples\VC\CmdLineConsumer\
CmdLineConsumer.rc	WMI_PSDK\Samples\VC\CmdLineConsumer
CmdLineConsumerDlg.cpp	WMI_PSDK\Samples\VC\CmdLineConsumer\
CmdLineConsumerDlg.h	WMI_PSDK\Samples\VC\CmdLineConsumer\
Consumer.cpp	WMI_PSDK\Samples\VC\CmdLineConsumer\
Consumer.h	WMI_PSDK\Samples\VC\CmdLineConsumer\
factory.cpp	WMI_PSDK\Samples\VC\CmdLineConsumer\
factory.h	WMI_PSDK\Samples\VC\CmdLineConsumer\
makefile	WMI_PSDK\Samples\VC\CmdLineConsumer\
Provider.cpp	WMI_PSDK\Samples\VC\CmdLineConsumer\
Provider.h	WMI_PSDK\Samples\VC\CmdLineConsumer\
resource.h	WMI_PSDK\Samples\VC\CmdLineConsumer\
StdAfx.cpp	WMI_PSDK\Samples\VC\CmdLineConsumer\
StdAfx.h	WMI_PSDK\Samples\VC\CmdLineConsumer\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\placefil.txt ===
bar.cpp	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
bar.h	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
BarChart.cpp	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
BarChart.h	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
ColorEdit.cpp	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
ColorEdit.h	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
customview.mof	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
CustomViews.htm	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
DiskView.cpp	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
DiskView.h	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
makefile	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
ReadMe.txt	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
Resource.h	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
StdAfx.cpp	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
StdAfx.h	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
Win32LogicalDisk.cpp	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
Win32LogicalDisk.def	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
Win32LogicalDisk.dsp	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
Win32LogicalDisk.dsw	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
Win32LogicalDisk.h	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
Win32LogicalDisk.ico	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
Win32LogicalDisk.odl	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
Win32LogicalDisk.rc	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
Win32LogicalDisk.tlb	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
Win32LogicalDiskCtl.bmp	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
Win32LogicalDiskCtl.cpp	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
Win32LogicalDiskCtl.h	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
Win32LogicalDiskPpg.cpp	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
Win32LogicalDiskPpg.h	WMI_PSDK\Samples\VC\CustomViews\Win32LogicalDisk\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\customviews\win32logicaldisk\readme.txt ===
=======================================================================
Custom View OCX's for WMI Applications
=======================================================================


This file contains a description of the custom view	OCXs for WMI and the 
corresponding automation interface.  Custom views provide non-generic 
views of objects contained in the WMI database.  The WMI CIM Studio,
Object Browser, and other programs may use these custom views to display application
specific views of WMI objects.  For example, a custom view of a disk drive
might show the amount of free space in a bar chart, and so on.

Any number of views can be defined for each class stored in the
WMI database.  To add a custom view to the WMI database, it is necessary
to create a new instance of the "ClassView" class.  Below is an example
of a mof file that can be compiled to define a custom view for the 
Win32LogicalDisk class.  In this MOF file, the "id" property takes the form
of "ClassName.ViewName", so that custom views can be uniquely identified and
easily recognized.  

The WMI CIM Studio and Object Browser applications determine what custom views are 
available for a given class by querying for all instances of "ClassView" such 
that the "ClassName" property is equal to the current class being displayed.


		#pragma namespace("\\\\.\\root\\cimv2")


		class ClassView
		{
			[key] string id;
			string title;
			string ClassName;
			string classid;
			string codebase;
			string version;
		};


		instance of ClassView
		{
			id = "Win32_LogicalDisk.View1";
			title = "Custom View of Win32_LogicalDisk";
			ClassName = "Win32_LogicalDisk";
			classid = "{D5FF1886-0191-11D2-853D-00C04FD7BB08}";
			codebase = "";
			version = "1.0";
		};


To see a sample custom view in the WMI CIM Studio follow these steps:

	1. Build the sample found in the WMI SDK directory under samples\vc\customviews

	2. Use regsvr32 to register the resulting Win32LogicalDisk.ocx as shown below:
	
			regsvr32 Win32LogicalDisk.ocx

	3. Start the WMI CIM Studio application

	4. Use the MOF Compiler Wizard in WMI CIM Studio to compile the "CustomView.mof"
	   MOF file that is included with the sample

	5. In WMI CIM Studio, select the Win32_LogicalDisk class in the class tree.

	6. In the Object Viewer (right pane), click the "Instances" button to display all
	   instances of "Win32_LogicalDisk" on your local machine

	7. Double-click one of the instances to go to the single object view for
	   that instance. At this point, the custom view available for instances of this
	   class is recognized and the "Views" menu-option under the "Views" button
	   becomes enabled. 
	   
	8. Click the "Views" button and select "Views..." in the menu.
	   A dialog is displayed with a list of the available views for this object.
	   One of them is the "Custom View of Win32_LogicalDisk" which is implemented by
	   our sample ocx. Selecting this option and clicking "OK" displays the custom view
	   showing (in this example) the total vs free disk space on the current disk object.


	----------------
	TROUBLESHOOTING:
	----------------

	If you do not see the custom view title listed among the views or if the
	"Views..." menu option is not enabled under the "Views" button in the Object Viewer,
	please check the following :

	1. Check to make sure that you have an instance (not the class) of 
	   "Win32_LogicalDisk" selected in the WMI CIM Studio Object Viewer.  

	2. Verify that you registered the "Win32LogicalDisk.ocx" custom view control.

	3. Verify that you compiled the "CustomView.mof" file.



Win32LogicalDisk.ocx is a minimal implementation of a custom view.  It displays the
object path passed to it from the container along with the size/free-space bar chart.
The control uses the object path to get the WMI object and extract the required
property values for building the bar chart. Real-world custom views would probably
use the WMI interface to get similar and more in-depth information for display.

Custom views need not be limited to information contained in the selected class.
For example, a class view for a disk drive may provide information about how the 
space is being consumed, etc. The custom view control can use the full power of WMI
including associations, queries and events, for a more sophisticated and object-specific
display.



=======================================================================
Automation interface for the WMI custom object view OCXs
(Note : this information is also available in the .odl file that is
        included with this sample)
=======================================================================

//****************************************************************
// DEFINITIONS
//****************************************************************
Context Handles:
	Containers that use WMI custom views typically will want to 
	take a snapshot of the state of the custom view so that it is
	possible to go back to that state at a later time.  The container
	is only aware of context handles that the custom view returns to
	the container.  The container only sees context handles as long
	integers, thus custom views are free to define their own implementation
	of context saving.  


//****************************************************************
// Automation Properties
//****************************************************************
LPCTSTR NameSpace


//****************************************************************
// Automation Methods.
//****************************************************************
long QueryNeedsSave();
long AddContextRef(long lCtxtHandle);
long GetContext(long FAR* plCtxthandle);
long GetEditMode();
void ExternInstanceCreated(BSTR szObjectPath);
void ExternInstanceDeleted(BSTR szObjectPath);
long RefreshView();
long ReleaseContext(long lCtxtHandle);
long RestoreContext(long lCtxtHandle);
long SaveData();
void SetEditMode(long bCanEdit);
long SelectObjectByPath(BSTR szObjectPath);



//*****************************************************************
// Events that custom views can fire.
//*****************************************************************
void FireJumpToMultipleInstanceView(LPCTSTR szTitle, const VARIANT FAR& varPathArray);
void FireNotifyContextChanged();
void FireNotifySaveRequired();
void FireNotifyViewModified();
void FireGetIWbemServices(BSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel)


///////////////////////////////////////////////////////////////
// METHOD AND EVENT INTERFACE DESCRIPTIONS
///////////////////////////////////////////////////////////////


//**************************************************************
// QueryNeedsSave
//
// The container calls this method prior to destroying this 
// custom view.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			TRUE (1) if the selected object has been modified and needs to be
//			saved, FALSE (0) otherwise.
//
//
//**************************************************************
// AddContextRef
//
// This method is called to increment the reference count of the
// specified context handle.
//
// Parameters:
//		[in] long lCtxtHandle
//			The context handle who's reference count should be 
//			incremented.  
//
// Returns:
//		long
//			Always returns S_OK.
//
//
//**************************************************************
// GetContext
//
// This method causes the custom view to save its current state
// in a "context" and return a handle to it.  The definition of
// the "context" is left to the custom view.
//
// Parameters:
//		[out] long FAR* plCtxthandle
//			A pointer to the place to return the context handle.
//
// Returns:
//		long
//			S_OK if successful, otherwise E_FAIL.
//
//
//**************************************************************
// CWbemViewCtrl::GetEditMode
//
// The container calls this method to get the current edit mode.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			TRUE if the object can be edited, FALSE otherwise.
//
//**************************************************************
// ExternInstanceCreated
//
// The container calls this method to inform the custom view that
// it created a WMI object.
// is created.
//
// Parameters:
//		[in] BSTR szObjectPath
//			The object path of the object created.
//
// Returns:
//		None.
//
//**************************************************************
// ExternInstanceDeleted
//
// The container calls this method to inform the custom view that
// it deleted a WMI object.
//
// Parameters:
//		[in] BSTR szObjectPath
//			The path of the object that was deleted.
//
// Returns:
//		None.
//
//**************************************************************
// RefreshView
//
// The container calls this method when it believes that the custom
// view needs to refresh its data.  For example, this may be necessary
// if the container is notified that the WMI database has been
// modified by another view.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			S_OK if the view was refreshed, E_FAIL otherwise.
//
//**************************************************************
// ReleaseContext
//
// Decrement the reference count on the specified context handle.
// The context may be destroyed when the reference count goes to
// zero.
//
// Parameters:
//		[in] long lCtxtHandle
//			The context handle.
//
// Returns:
//		long
//			S_OK if the reference count was decremented, E_FAIL
//			otherwise.
//
//**************************************************************
// RestoreContext
//
// Restore the custom view to the state specified by the given
// context handle.
//
// Parameters:
//		[in] long lCtxtHandle
//			The context handle.
//
// Returns:
//		long
//			S_OK if the state was restored, E_FAIL
//			otherwise.
//
//**************************************************************
// SaveData
//
// The container calls this method when it wants the custom
// view to perform a "save".  For example, CIM Studio will
// call this method when the "save" button is clicked if QueryNeedsSave
// returned TRUE.
//
// Parameters:
//		None.
//
// Returns:
//		SCODE
//			S_OK if the save was successful, E_FAIL
//			otherwise.
//
//**************************************************************
// SetEditMode
//
// Set the edit mode.
//
// Parameters:
//		[in] long bCanEdit
//			TRUE if it is OK to edit the object, FALSE otherwise.
//
// Returns:
//		Nothing.
//
//**************************************************************
// SelectObjectByPath
//
// Select the specified WMI object.
//
// Parameters:
//		[in] BSTR szObjectPath
//			The WMI path to the object to select.
//
// Returns:
//		long
//			S_OK if the object was selected, E_FAIL
//			otherwise.
//
//**************************************************************




=================================================================
EVENTS FIRED FROM CUSTOM VIEWS
=================================================================

//**************************************************************
// FireJumpToMultipleInstanceView
//
// Custom views can fire this event to cause the container to 
// jump to a multiple instance view.
//
// Parameters:
//		BSTR szTitle
//			The view title.
//
//		const VARIANT FAR& varPathArray
//			An array of WMI object paths.
//
// Returns:
//		void.
//
//
//**************************************************************
// FireNotifyContextChanged
//
// Custom views should fire this event when its context has changed.
// This allows the container to get an updated context handle for
// the custom view.
//
// Parameters:
//		None.

//
// Returns:
//		void.
//
//**************************************************************
// FireNotifySaveRequired
//
// Custom views should fire this event when the selected object's data
// has been modifed and a save is required.  
//
// Parameters:
//		None.
//
// Returns:
//		void.
//
//**************************************************************
// FireGetIWbemServices
//
// Parameters:
//		BSTR szNamespace
//			The namespace to connect to.
//
//		VARIANT FAR* pvarUpdatePointer
//			This is a flag to indicate whether the container should returned a cached
//			IWbemServices pointer for the namespace or get a new one (and put up the
//			login dialog, etc.)  The variant that this parameter points to should be of
//			type VT_I4.  The value of the variant should be TRUE (non-zero) to request
//			a fresh pointer, or FALSE (zero) to request the cached pointer.  If IWbemServices
//			pointer for the namespace is not in the cache and the value is FALSE then
//			the container will attempt to get a fresh pointer by performing a login if
//			necessary.
//			
//
//		VARIANT FAR* pvarServices
//			The services pointer is returned in the variant that this parameter points to.
//
//		VARIANT FAR* pvarSc
//			The status code is returned to the custom view via this parameter.  If the container
//			catches and handles this event the type of pvarSc will be set to VT_I4 and the status
//			code will be returned in the lVal member.
//
//
//		 VARIANT FAR* pvarUserCancel
//			A flag indicating whether or not the user cancelled the login dialog is returned
//			via this parameter.  Its type will be set to VT_BOOL and the boolVal member will
//			be set to TRUE if the user cancelled the login, and FALSE if the user completed
//			the login.
//
//******************************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\diskperfwbem\readme.txt ===
********************************************************************************
Diskperf Driver WMI Sample
********************************************************************************

The Windows 2000 Professional Beta 3 DDK contains a WMI driver sample called the
diskperf driver. This driver is also standard in a Windows 2000 Professional Beta 3
installation.  The driver produces instrumentation data using WMI.  The recommended
way of viewing/setting data produced using WMI is WBEM.

This sample driver was also present in the Windows 2000 Beta 2 DDK. While this
application may also work with Windows 2000 Beta 2 and the driver in the Windows 2000
Beta 2 DDK, it is highly recommended that Windows 2000 Beta 3 and the Windows 2000
Beta 3 DDK be used.

This directory contains a sample WBEM application that surfaces the data
produced by the diskperf sample driver within the DDK.

To use this sample, the following steps are required:

1) Install Windows 2000 Professional Beta 3 operating system.

2) Install the WMI SDK for Windows 2000 Professional Beta 3.

3) Use NMAKE to compile and link the sample application provided here to produce
   dpwbem.exe.

4) If desired, the diskperf driver in the Windows 2000 Professional Beta 3 DDK can
   replace the one from the operating system install.  To do so, compile the 
   diskperf driver in the DDK and substitute it for the standard one.

5) Open Device Manager.  Select Disk Drives and view properties via the Action
   menu. Choose the Advanced tab on the properties dialog and check Enable Disk
   Performace Counters.

6) Restart Windows 2000 Professional and run dpwbem.exe. You should now see
   instrumentation data produced by the diskperf driver visible via the WBEM
   application.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\diskperfwbem\placefil.txt ===
diskperf.mof	WMI_PSDK\Samples\VC\DiskPerfWbem\
DiskPerfWbem.dsp	WMI_PSDK\Samples\VC\DiskPerfWbem\
DiskPerfWbem.htm	WMI_PSDK\Samples\VC\DiskPerfWbem\
dpdetail.cpp	WMI_PSDK\Samples\VC\DiskPerfWbem\
dpsetup.cmd	WMI_PSDK\Samples\VC\DiskPerfWbem\
dpwbem.cpp	WMI_PSDK\Samples\VC\DiskPerfWbem\
makefile	WMI_PSDK\Samples\VC\DiskPerfWbem\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\placefil.txt ===
Consumer.cpp	WMI_PSDK\Samples\VC\EventConsumer\
Consumer.h	WMI_PSDK\Samples\VC\EventConsumer\
EventConsumer.htm	WMI_PSDK\Samples\VC\EventConsumer\
factory.cpp	WMI_PSDK\Samples\VC\EventConsumer\
factory.h	WMI_PSDK\Samples\VC\EventConsumer\
makefile	WMI_PSDK\Samples\VC\EventConsumer\
PermEvents.cpp	WMI_PSDK\Samples\VC\EventConsumer\
PermEvents.dsp	WMI_PSDK\Samples\VC\EventConsumer\
PermEvents.h	WMI_PSDK\Samples\VC\EventConsumer\
PermEvents.rc	WMI_PSDK\Samples\VC\EventConsumer\
PermEventsDlg.cpp	WMI_PSDK\Samples\VC\EventConsumer\
PermEventsDlg.h	WMI_PSDK\Samples\VC\EventConsumer\
Provider.cpp	WMI_PSDK\Samples\VC\EventConsumer\
Provider.h	WMI_PSDK\Samples\VC\EventConsumer\
resource.h	WMI_PSDK\Samples\VC\EventConsumer\
SampleViewer.mof	WMI_PSDK\Samples\VC\EventConsumer\
StdAfx.cpp	WMI_PSDK\Samples\VC\EventConsumer\
StdAfx.h	WMI_PSDK\Samples\VC\EventConsumer\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventconsumer\readme.txt ===
==================================================================
			WMI Permanent Event Consumer
==================================================================

This tutorial demonstrates a permanent event consumer. Events are
generated from the clientSample app by adding equipment. This app 
shows how to implement a simple IWBEMUnboundObjectSink and its 
class factory. You should generate your own CLSID when building 
your permanent consumer.

The SampleViewer.mof uses a special namespace. You must run 'mofcomp 
SampleViewer.mof' to create the namespace and register this consumer
before running the clientSample app. 


==================================================================
Build Notes
==================================================================
Things to remember when you're building your own WMI consumer app.

1. If you want your client to run on NT and non-DCOM versions of Win95, 
	manually load the ole32.dll and see if CoInitializeSecurity() exists. 
	This routine wont exist on win95 OS's that dont have DCOM installed 
	separately. If this routine doesn't exist, the async routines in 
	this sample wont work because of mismatched security level problems. 
	The synchronous techniques will still work.

2. If you dont care about non-DCOM versions of win95, you can define  
	_WIN32_DCOM so that CoInitializeSecurity() is available for implicit
	linking. Don't use _WIN32_WINNT to get this prototype since it 
	won't compile under Windows 9x OSs.

3. Either way, this call (in InitInstance()) is required to work around a 
	security problem when WMI trying to call a Sink object but 
	won't identify itself. The CoInitializeSecurity() call turns 
	off the authentication requirement. 

4.  WMI interfaces are defined in wbemcli.h and wbemprov.h found in 
	the wmi\include directory.  You may #include both these files by 
	including just wbemidl.h located in the same directory.

5. WMI interface CLSIDs are defined in wbemuuid.lib. If you get 
	unresolved externals in WMI interfaces and CLSIDs, this is 
	what's missing. 

6. You'll need to link with oleaut32.lib and ole32.lib to get the 
	COM stuff.

7. In the Link|Output settings, specify 'wWinMainCRTStartup' as the entry 
	point if you're building a unicode project. This is per the 
	Unicode programming instructions.

8. Generate your own CLSID. Don't use the one in this sample.

==================================================================
Task: Handle an Event.
==================================================================
Implementations:
Consumer.cpp is the actual handler. The IndicateToConsumer() method
will be called with the event instance embedded. 

==================================================================
Task: creating the handler object.
==================================================================
Implementation:
factory.cpp creates the the sink object. It is a simple class factory.

==================================================================
Task: Registering the object & factory.
==================================================================
Implementation:
WBEMPermEvents.cpp registers the sink object with its class factory
in the InitInstance() routine. The registration is revoked in the 
ExitInstance().

==================================================================
Task: Self-registering an EXE
==================================================================
Implementation:
WBEMPermEvents.cpp has the RegisterServer() and UnregisterServer() 
routines to show self-registration of an EXE. It is not the same as 
a DLL. The 'AppID' and 'RunAs' values allow the spawned EXE to run 
on the user's desktop instead of the service's hidden desktop. 
Otherwise the Event Consumer would never appear.

END readme.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventprovider\placefil.txt ===
EventProvider.dsp	WMI_PSDK\Samples\VC\EventProvider\
EventProvider.htm	WMI_PSDK\Samples\VC\EventProvider\
evprov-alpha.def	WMI_PSDK\Samples\VC\EventProvider\
evprov.cpp	WMI_PSDK\Samples\VC\EventProvider\
evprov.def	WMI_PSDK\Samples\VC\EventProvider\
evprov.h	WMI_PSDK\Samples\VC\EventProvider\
evprov.mof	WMI_PSDK\Samples\VC\EventProvider\
makefile	WMI_PSDK\Samples\VC\EventProvider\
oahelp.inl	WMI_PSDK\Samples\VC\EventProvider\
olesrvr.cpp	WMI_PSDK\Samples\VC\EventProvider\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventprovider\readme.txt ===
Windows Management Instrumentation SDK Sample 

EventProvider

The EventProvider sample demonstrates a WMI event provider.  EventProvider generates a WMI event of class MyEvent every two seconds.  WMI applications can register to receive these events.  The TempConsumer sample provided with the WMI SDK is a simple example of an application that registers for and displays the MyEvent class events generated by this provider.

NOTE:  The EventProvider sample should be built and registered as indicated below prior to using the TempConsumer sample.  Without the EventProvider sample in place, there will be no events for TempConsumer to receive.  Please refer to the TempConsumer sample documentation for instructions on building and using the TempConsumer application.

Building the Provider DLL

The DLL can be built from the command line using NMAKE, or it can be built using Microsoft Visual C++.  From the command line: 

NMAKE /f "Makefile"

From Microsoft Visual C++: 

1. Select File + Open Workspace
2. Select the EventProvider.DSP file


Registering the DLL and Class

1. The DLL must be registered with COM. From the command line, type the following:

REGSVR32 evprov.dll

2. You must also compile the MOF in order to make the WMI CIMOM aware of the class.  From the command line type the following:

MOFCOMP evprov.mof

General Notes

Things to remember when you're building your own WMI provider:

1. WMI interfaces are defined in wbemcli.h and wbemprov.h found in the wmi\include directory.  You may #include both these files by including just wbemidl.h located in the same directory.

2. WMI interface CLSIDs are defined in wbemuuid.lib. If you get unresolved externals in interfaces and CLSIDs, this is what is missing. 

3. You'll need to link with oleaut32.lib and ole32.lib to get the needed COM support.

4. In the Link|Output settings, specify 'wWinMainCRTStartup' as the entry point. This is per the Unicode programming instructions.

5. If you're using the makefiles, don't forget to set the VC vars. In VC++ 5.0, it is VCVARS32.BAT.

(c) 1998-1999 Microsoft Corporation. All rights reserved.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\frameworkprov\readme.txt ===
This is a sample provider using the provider framework.
This code was generated using the WMI cpp code generator wizard.

Note : this sample will build "release" by default. This is because it needs
to run with the provider framework code which is also built release. 
If you want to build it "debug", you will need a debug version of the framework 
for it.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\frameworkprov\placefil.txt ===
VCSamples.htm	WMI_PSDK\Samples\VC\FrameworkProv\
FrameworkProv.CPP	WMI_PSDK\Samples\VC\FrameworkProv\
FrameworkProv.DEF	WMI_PSDK\Samples\VC\FrameworkProv\
FrameworkProv.dsp	WMI_PSDK\Samples\VC\FrameworkProv\
FrameworkProv.H		WMI_PSDK\Samples\VC\FrameworkProv\
FrameworkProv.htm	WMI_PSDK\Samples\VC\FrameworkProv\
makefile		WMI_PSDK\Samples\VC\FrameworkProv\
FrameworkProv.MOF	WMI_PSDK\Samples\VC\FrameworkProv\
MAINDLL.CPP	WMI_PSDK\Samples\VC\FrameworkProv\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\instprov\placefil.txt ===
CLASSFAC.CPP	WMI_PSDK\Samples\VC\InstProv\
instprov.cpp	WMI_PSDK\Samples\VC\InstProv\
INSTPROV.DEF	WMI_PSDK\Samples\VC\InstProv\
instprov.dsp	WMI_PSDK\Samples\VC\InstProv\
InstProv.htm	WMI_PSDK\Samples\VC\InstProv\
INSTPROV.MOF	WMI_PSDK\Samples\VC\InstProv\
MAINDLL.CPP	WMI_PSDK\Samples\VC\InstProv\
Makefile	WMI_PSDK\Samples\VC\InstProv\
SAMPLE.H	WMI_PSDK\Samples\VC\InstProv\
UTILS.CPP	WMI_PSDK\Samples\VC\InstProv\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\instprov\readme.txt ===
This sample code creates a WMI Instance Provider.

The instances are defined using an array named MyDefs which is 
declared in instprov.cpp.  The class is quite simple and consists of a 
string Key property and an integer property.

This sample does not support any updating.

To get the sample working, do the following;
1) Build using MAKEFILE. 

2) Make sure that the class is defined by using the MOF compiler.
Ex; c:\wmi\mofcomp instprov.mof

3) Register the DLL by using the self registration technique.
Ex; c:>regsvr32 instprov.dll

4) Using some sort of browser, get the instances of "InstProvSamp" class, or
get the object 

InstProvSamp.MyKey="a"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\methcli\placefil.txt ===
Makefile	WMI_PSDK\Samples\VC\MethCli\
METHCLI.CPP	WMI_PSDK\Samples\VC\MethCli\
MethCli.dsp	WMI_PSDK\Samples\VC\MethCli\
MethCli.htm	WMI_PSDK\Samples\VC\MethCli\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\methprov\readme.txt ===
Methods Provider
================ 
This sample demonstrates the framework necessary to implement a methods provider.
To get the sample working, do the following;
1) Build using NMAKE. 

2) Make sure that the classes used by the provider are defined by using the MOF compiler.
Ex; mofcomp methprov.mof

3) Register the DLL by using the self registration technique.
Ex; c:>regsvr32 methods.dll

What this provider supports
===========================

This provider supports methods for the class "TestMeth".  The only method 
supported in this sample is named Echo.  It takes an input string, copies 
it to the output and returns the length.  Note that the method is marked 
as "Static" and so it can be executed using a path to either an instance 
of the class, or the class path.  The mof definition is                               *

    [dynamic: ToInstance, provider("MethProv")]class MethProvSamp      
    {                                                                  
         [implemented, static]                                         
            uint32 Echo([IN]string sInArg="default", [out] string sOutArg);      
    };                                                                 




Using WbemTest application to execute the sample
================================================
To see the provider in action you must use wbemtest application to execute methods
using this provider. The following are directions on how to see the methods provider in
action.
1)type wbemtest at command prompt 
ex: c:>wbemtest
2)Connect to root\default
3)Click Execute Method Button
4)Type in the Object Path: In this case "MethProvSamp".
5)A default method should appear in the Method box named "Echo".
  Click on Edit-In-Parameters.
6)There should be one user-defined property, sInArg.  Enter a value to be
  echoed.
7)Click Execute!
8)The values should be returned in Edit-Out-Parameters.

Using the Method Client sample to execute the sample
====================================================
The method provider sample can also be called using the "MethCli" 
sample program.  Before running it, this provider should be setup first
using the steps listed above.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\methcli\readme.txt ===
Method Client
=============
This sample demonstrates the framework necessary to call a methods provider.
This code calls the "Echo" method as supported by that provider.  That method
is attached to the MethProvSamp class and it takes a string as input, returns
a copy and the length.  The class is defined in the METHPROV.MOF file which
is in the METHPROV sample.

To get the sample working, do the following;

1) Create the method provider sample "METHPROV" as outlined in the 
readme.txt file in that project.
2) Build using NMAKE. 
3) Run it.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\methprov\placefil.txt ===
classfac.cpp	WMI_PSDK\Samples\VC\MethProv\
maindll.cpp	WMI_PSDK\Samples\VC\MethProv\
makefile	WMI_PSDK\Samples\VC\MethProv\
METHPROV.CPP	WMI_PSDK\Samples\VC\MethProv\
methprov.def	WMI_PSDK\Samples\VC\MethProv\
MethProv.dsp	WMI_PSDK\Samples\VC\MethProv\
methprov.h	WMI_PSDK\Samples\VC\MethProv\
MethProv.htm	WMI_PSDK\Samples\VC\MethProv\
METHPROV.MOF	WMI_PSDK\Samples\VC\MethProv\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\objpathparser\placefil.txt ===
genlex.cpp	WMI_PSDK\Samples\VC\ObjPathParser\
genlex.h	WMI_PSDK\Samples\VC\ObjPathParser\
makefile	WMI_PSDK\Samples\VC\ObjPathParser\
objpath.cpp	WMI_PSDK\Samples\VC\ObjPathParser\
objpath.h	WMI_PSDK\Samples\VC\ObjPathParser\
ObjPathParser.dsp	WMI_PSDK\Samples\VC\ObjPathParser\
ObjPathParser.htm	WMI_PSDK\Samples\VC\ObjPathParser\
opathlex.cpp	WMI_PSDK\Samples\VC\ObjPathParser\
opathlex.h	WMI_PSDK\Samples\VC\ObjPathParser\
pathtest.cpp	WMI_PSDK\Samples\VC\ObjPathParser\
readme.txt	WMI_PSDK\Samples\VC\ObjPathParser\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\pingwbem\placefil.txt ===
main.cpp	WMI_PSDK\Samples\VC\PingWBEM\
makefile	WMI_PSDK\Samples\VC\PingWBEM\
PingWBEM.dsp	WMI_PSDK\Samples\VC\PingWBEM\
PingWbem.htm	WMI_PSDK\Samples\VC\PingWBEM\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\pathparser\readme.txt ===
Path Parser Sample
================ 
This sample demonstrates the use of the path parser.
To get the sample working, do the following;
1) Build using NMAKE. 


To execute the sample
====================================================
Go to the directory where the executable is placed, then 
execute it and pass it a path as an argument.  Alternatively, 
just type the name and it will dump out some examples.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\objpathparser\readme.txt ===
Object Path Parser Example

This example contains code which parses CIM-style object paths.  Its primary
use is in building providers, when implementing GetObjectAsync().  However,
it is generally useful when working with WMI in a variety of contexts.

The primary illustration is in PATHTEST.CPP.  The main() function
contains a complete example of how to parse an object path using
the C++ class CObjectPathParser.  The code of interest is:

    ParsedObjectPath* pOutput = 0;

    wchar_t *pPath = L"\\\\.\\root\\default:MyClass=\"keyval\"";

    CObjectPathParser p;
    int nStatus = p.Parse(pPath,  &pOutput);

    printf("Return code is %d\n", nStatus);

    if (nStatus != 0)
        return;

The rest of the code simply dumps the parsed output.

The other files in the project contain the sources for the lexer and
the parser.  These files require no other supporting files, and are not
dependent on flex, yacc, or other similar tools.  The code is self-contained.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\propprov\placefil.txt ===
CLASSFAC.CPP	WMI_PSDK\Samples\VC\PropProv
MAINDLL.CPP	WMI_PSDK\Samples\VC\PropProv
Makefile	WMI_PSDK\Samples\VC\PropProv
propprov.cpp	WMI_PSDK\Samples\VC\PropProv
propprov.def	WMI_PSDK\Samples\VC\PropProv
propprov.dsp	WMI_PSDK\Samples\VC\PropProv
PropProv.htm	WMI_PSDK\Samples\VC\PropProv
PROPPROV.MOF	WMI_PSDK\Samples\VC\PropProv
SAMPLE.H	WMI_PSDK\Samples\VC\PropProv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\propprov\readme.txt ===
This sample code creates a Dynamic Property Provider for WMI.  This is the
simplest provider type and this sample just returns some hard coded values.

To get the sample working, do the following;

1) build using MAKEFILE. 

2) Make sure that the class is defined by using the MOF compiler.
Ex; c:\propprov>mofcomp propprov.mof


3) Register the DLL by using the self registration technique.
Ex; c:>regsvr32 propprov.dll

4) Using some sort of browser, get the object, PropProvSamp="abc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\queryparser\readme.txt ===
Query Parser Sample
================ 
This sample demonstrates the use of the query parser.
To get the sample working, do the following;
1) Build using NMAKE. 


To execute the sample
====================================================
Go to the directory where the executable is placed, then 
execute it and pass it a query as an argument.  Alternatively, 
just type the name and it will dump out some examples.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\readme\placefil.txt ===
VCSamples.htm	WMI_PSDK\Samples\VC\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\security\placefil.txt ===
Makefile	WMI_PSDK\Samples\VC\Security\
Security.CPP	WMI_PSDK\Samples\VC\Security\
Security.dsp	WMI_PSDK\Samples\VC\Security\
Security.htm	WMI_PSDK\Samples\VC\Security\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\security\readme.txt ===
Security Client
=============
       WMI Client Security Sample.  This sample shows how various how to 
handle various DCOM security issues.  In particular, it shows how to call
CoSetProxyBlanket in order to deal with common situations.  The sample also
shows how to access the security descriptors that wmi uses to control
namespace access.

To get the sample working, do the following;

1) Build using NMAKE. 
2) Run it.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\simpleclient\res\placefil.txt ===
WbemClient.ico	WMI_PSDK\Samples\VC\SimpleClient\res\
WbemClient.rc2	WMI_PSDK\Samples\VC\SimpleClient\res\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\simpleclient\src\placefil.txt ===
makefile	WMI_PSDK\Samples\VC\SimpleClient\
Resource.h	WMI_PSDK\Samples\VC\SimpleClient\
SimpleClient.htm	WMI_PSDK\Samples\VC\SimpleClient\
StdAfx.cpp	WMI_PSDK\Samples\VC\SimpleClient\
StdAfx.h	WMI_PSDK\Samples\VC\SimpleClient\
WbemClient.cpp	WMI_PSDK\Samples\VC\SimpleClient\
WbemClient.dsp	WMI_PSDK\Samples\VC\SimpleClient\
WbemClient.h	WMI_PSDK\Samples\VC\SimpleClient\
WbemClient.rc	WMI_PSDK\Samples\VC\SimpleClient\
WbemClientDlg.cpp	WMI_PSDK\Samples\VC\SimpleClient\
WbemClientDlg.h	WMI_PSDK\Samples\VC\SimpleClient\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\simpleclient\src\readme.txt ===
This sample code is meant to accompany the tutorial article 
"Creating a WMI Application in MFC".

You can find this tutorial in the WMI SDK documentation.  
In this tutorial you create a simple WMI client application. 
You learn to create and connect to a WMI namespace, 
to find and display all instances of a class, and to display
the properties of a class instance.

The following text was created by the MFC Project Wizard:

========================================================================
       MICROSOFT FOUNDATION CLASS LIBRARY : WbemClient
========================================================================


AppWizard has created this WbemClient application for you.  This application
not only demonstrates the basics of using the Microsoft Foundation classes
but is also a starting point for writing your application.

This file contains a summary of what you will find in each of the files that
make up your WbemClient application.

WbemClient.h
    This is the main header file for the application.  It includes other
    project specific headers (including Resource.h) and declares the
    CWbemClientApp application class.

WbemClient.cpp
    This is the main application source file that contains the application
    class CWbemClientApp.

WbemClient.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Developer Studio.

res\WbemClient.ico
    This is an icon file, which is used as the application's icon.  This
    icon is included by the main resource file WbemClient.rc.

res\WbemClient.rc2
    This file contains resources that are not edited by Microsoft 
	Developer Studio.  You should place all resources not
	editable by the resource editor in this file.

WbemClient.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.


/////////////////////////////////////////////////////////////////////////////

AppWizard creates one dialog class:

WbemClientDlg.h, WbemClientDlg.cpp - the dialog
    These files contain your CWbemClientDlg class.  This class defines
    the behavior of your application's main dialog.  The dialog's
    template is in WbemClient.rc, which can be edited in Microsoft
	Developer Studio.


/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named WbemClient.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Developer Studio reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

If your application uses MFC in a shared DLL, and your application is 
in a language other than the operating system's current language, you
will need to copy the corresponding localized resources MFC40XXX.DLL
from the Microsoft Visual C++ CD-ROM onto the system or system32 directory,
and rename it to be MFCLOC.DLL.  ("XXX" stands for the language abbreviation.
For example, MFC40DEU.DLL contains resources translated to German.)  If you
don't do this, some of the UI elements of your application will remain in the
language of the operating system.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\placefil.txt ===
about.cpp	WMI_PSDK\Samples\VC\Snapin\
about.h		WMI_PSDK\Samples\VC\Snapin\
basesnap.cpp	WMI_PSDK\Samples\VC\Snapin\
basesnap.h	WMI_PSDK\Samples\VC\Snapin\
comp.cpp	WMI_PSDK\Samples\VC\Snapin\
comp.h		WMI_PSDK\Samples\VC\Snapin\
compdata.cpp	WMI_PSDK\Samples\VC\Snapin\
compdata.h	WMI_PSDK\Samples\VC\Snapin\
dataobj.cpp	WMI_PSDK\Samples\VC\Snapin\
dataobj.h	WMI_PSDK\Samples\VC\Snapin\
delebase.cpp	WMI_PSDK\Samples\VC\Snapin\
delebase.h	WMI_PSDK\Samples\VC\Snapin\
equipment.cpp	WMI_PSDK\Samples\VC\Snapin\
equipment.h	WMI_PSDK\Samples\VC\Snapin\
globals.h	WMI_PSDK\Samples\VC\Snapin\
guids.h		WMI_PSDK\Samples\VC\Snapin\
ico00001.ico	WMI_PSDK\Samples\VC\Snapin\
icon2.ico	WMI_PSDK\Samples\VC\Snapin\
lgbmp.bmp	WMI_PSDK\Samples\VC\Snapin\
lgicons.bmp	WMI_PSDK\Samples\VC\Snapin\
localres.h	WMI_PSDK\Samples\VC\Snapin\
makefile	WMI_PSDK\Samples\VC\Snapin\
mmccrack.cpp	WMI_PSDK\Samples\VC\Snapin\
registry.cpp	WMI_PSDK\Samples\VC\Snapin\
registry.h	WMI_PSDK\Samples\VC\Snapin\
resource.h	WMI_PSDK\Samples\VC\Snapin\
Resource.rc	WMI_PSDK\Samples\VC\Snapin\
SimpleArray.h	WMI_PSDK\Samples\VC\Snapin\
smbmp.bmp	WMI_PSDK\Samples\VC\Snapin\
smicons.bmp	WMI_PSDK\Samples\VC\Snapin\
smopen.bmp	WMI_PSDK\Samples\VC\Snapin\
snapin.def	WMI_PSDK\Samples\VC\Snapin\
snapin.dsp	WMI_PSDK\Samples\VC\Snapin\
snapin.htm	WMI_PSDK\Samples\VC\Snapin\
snapin.ico	WMI_PSDK\Samples\VC\Snapin\
statnode.cpp	WMI_PSDK\Samples\VC\Snapin\
statnode.h	WMI_PSDK\Samples\VC\Snapin\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\utillib\placefil.txt ===
wbemsec.H	WMI_PSDK\Samples\VC\UtilLib\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\tempconsumer\placefil.txt ===
consumer.cpp	WMI_PSDK\Samples\VC\TempConsumer\
makefile	WMI_PSDK\Samples\VC\TempConsumer\
oahelp.inl	WMI_PSDK\Samples\VC\TempConsumer\
TempConsumer.dsp	WMI_PSDK\Samples\VC\TempConsumer\
TempConsumer.htm	WMI_PSDK\Samples\VC\TempConsumer\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\wmidiskperf\placefil.txt ===
dpdetail.cpp	WMI_PSDK\Samples\VC\WMIDiskPerf\
makefile	WMI_PSDK\Samples\VC\WMIDiskPerf\
WMIDiskPerf.cpp	WMI_PSDK\Samples\VC\WMIDiskPerf\
WMIDiskPerf.dsp	WMI_PSDK\Samples\VC\WMIDiskPerf\
WMIDiskPerf.htm	WMI_PSDK\Samples\VC\WMIDiskPerf\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\placefil.txt ===
WMIScriptUtils.DLL    WMI_SDK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fminstprov\readme.txt ===
========================================================================
       DYNAMIC LINK LIBRARY : FMInstProv
========================================================================


AppWizard has created this FMInstProv DLL for you.  

This file contains a summary of what you will find in each of the files that
make up your FMInstProv application.

FMInstProv.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.

FMInstProv.cpp
    This is the main DLL source file.

	When created, this DLL does not export any symbols. As a result, it 
	will not produce a .lib file when it is built. If you wish this project
	to be a project dependency of some other project, you will either need to 
	add code to export some symbols from the DLL so that an export library 
	will be produced, or you can check the "doesn't produce lib" checkbox in 
	the Linker settings page for this project. 

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named FMInstProv.pch and a precompiled types file named StdAfx.obj.


/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_evecons\readme.txt ===
========================================================================
       DYNAMIC LINK LIBRARY : FMStocks_EveCons
========================================================================


AppWizard has created this FMStocks_EveCons DLL for you.  

This file contains a summary of what you will find in each of the files that
make up your FMStocks_EveCons application.

FMStocks_EveCons.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.

FMStocks_EveCons.cpp
    This is the main DLL source file.

	When created, this DLL does not export any symbols. As a result, it 
	will not produce a .lib file when it is built. If you wish this project
	to be a project dependency of some other project, you will either need to 
	add code to export some symbols from the DLL so that an export library 
	will be produced, or you can check the "doesn't produce lib" checkbox in 
	the Linker settings page for this project. 

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named FMStocks_EveCons.pch and a precompiled types file named StdAfx.obj.


/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_hiperfprovider\readme.txt ===
========================================================================
       DYNAMIC LINK LIBRARY : FMStocks_HiPerfProvider
========================================================================


AppWizard has created this FMStocks_HiPerfProvider DLL for you.  

This file contains a summary of what you will find in each of the files that
make up your FMStocks_HiPerfProvider application.

FMStocks_HiPerfProvider.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.

FMStocks_HiPerfProvider.cpp
    This is the main DLL source file.

	When created, this DLL does not export any symbols. As a result, it 
	will not produce a .lib file when it is built. If you wish this project
	to be a project dependency of some other project, you will either need to 
	add code to export some symbols from the DLL so that an export library 
	will be produced, or you can check the "doesn't produce lib" checkbox in 
	the Linker settings page for this project. 

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named FMStocks_HiPerfProvider.pch and a precompiled types file named StdAfx.obj.


/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\res.txt ===
#generic
WMISE_Cancel=Cancel
WMISE_Exception=Exception: {0}\n\rTrace: {1}
WMISE_SelectClassBtn=Sele&ct class...
WMISE_SubscribeBtn=Su&bscribe
WMISE_AddEventFilterCM=&Add event filter...
WMISE_AddEventFilterLabel=<Add event filter...>
WMISE_Seconds=seconds
WMISE_OK=OK
WMISE_Help=&Help
WMISE_NoDescr=No description
WMISE_InvalidPath=Invalid Object Path: {0}
WMISE_AdvancedBtn=&Advanced...


#AssocGroupComponent.cs
WMISE_AssocGroupClassPropertyDescr=The name of the class to which the child nodes belong
WMISE_AssocGroupRolePropertyDescr=The role of the child nodes in the relationship
WMISE_AssocGroupAssocPropertyDescr=The name of the relationship class

#ExecuteMethodDialog.cs
WMISE_ExecMethodDlg_Title=Execute Method {0}.{1}
WMISE_ExecMethodDlg_ServerName=Server: {0}
WMISE_ExecMethodDlg_NoInputParams=No Input Parameters
WMISE_ExecMethodDlg_Execute=Execute
WMISE_ExecMethodDlg_InputParameters=Input Parameters
WMISE_ExecMethodDlg_OutputParameters=Output Parameters


#EventQueryDialog.cs
WMISE_ExtrEventQueryDlg_Title=Build Management Event Query
WMISE_ExtrEventQueryDlg_EventClassLbl=Event class: 

#EventQueryNode.cs
WMISE_EventQueryStop=Sto&p
WMISE_EventQueryStart=S&tart
WMISE_EventQueryPurge=C&lear Event Traces

#EventSNode.cs
WMISE_EventNodeLbl=Management Events

#IntrinsicEventQueryDialog.cs
WMISE_IntrinsicEvent_Created=Created
WMISE_IntrinsicEvent_Modified=Modified
WMISE_IntrinsicEvent_Deleted=Deleted
WMISE_IntrinsicEvent_Operated=Created, Modified or Deleted

WMISE_IntrEventQueryDlg_Title=Build Object Operation Event Query
WMISE_IntrEventQueryDlg_EventClassLbl=Target class: 

WMISE_IntrEventQueryDlg_EventName=Raise event when instance is: 
WMISE_IntrEventQueryDlg_PollingInterval=Poll for events every: 

#IntrinsicEventNode.cs
WMISE_IntrinsicEventNodeLbl=Management Data Events

#SelectWMIClassTreeDialog.cs
WMISE_ClassSelectorLbl=Add Objects
WMISE_ClassSelectorLblSearch=&Find class containing:
WMISE_ClassSelectorBtnSearch=Find &Next
WMISE_ClassSelectorBtnAdd=&Add >>
WMISE_ClassSelectorBtnRemove=<< &Remove
WMISE_ClassSelectorSelClassesLbl=Se&lected classes:
WMISE_ClassSelectorAskViewAll=Do you want to add all classes in this namespace?
WMISE_ClassSelectorClassAlreadySelected=Class {0} is already selected
WMISE_ClassSelectorDlgHelp=This dialog allows you to select one or more Management classes. The objects belonging to these classes will be then added as nodes to the Server Explorer tree.
WMISE_Search_Failed=Search failed
WMISE_PleaseWait=Expanding {0}. Please wait...


#WMIClassesNode.cs
WMISE_ClassesNode_AddClass=&Add Objects...
WMISE_ClassesNode_AddClassLbl=<Add Objects...>
WMISE_ClassesNodeLbl=Management Data

#WMIClassNode.cs
WMISE_ClassNode_CreateNewInstance=Create &New Object...
WMISE_ClassNode_NewInstanceLbl=<New {0}>
WMISE_ClassNode_RemovePrompt=Are you sure you want to remove {0} from the view?

#WMIInstanceNode.cs
WMISE_InstNode_SaveNewInstanceCM=Save

#WMIObjectComponent.cs
WMISE_ObjComp_PutFailed=Could not save object {0}: {1}


#WMIObjectPropertyTable.cs
WMISE_PropTable_ColumnName=Name
WMISE_PropTable_ColumnType=Type
WMISE_PropTable_ColumnValue=Value
WMISE_PropTable_ColumnDescription=Description
WMISE_PropTable_ColumnComparison=Operator
WMISE_PropTable_ColumnIsKey=Key
WMISE_PropTable_ColumnIsLocal=Local

#namespace descriptions
WMISE_NSDescription_Root=The Root namespace is primarily designed to contain other namespaces. Typically, you should not use root to store your objects.
WMISE_NSDescription_Root_Default=The Default namespace is the default location where objects are stored if a namespace has not been specified.
WMISE_NSDescription_Root_Cimv2=The CIMV2 namespace contains the majority of information about the status and configuration of the local system.
WMISE_NSDescription_Root_Cimv2_Applications=The Applications namespace contains management objects for many applications installed on the local system.
WMISE_NSDescription_Root_Cimv2_Applications_MicrosoftIE=The MicrosoftIE namespace contains object for managing Internet Explorer on the local system.
WMISE_NSDescription_Root_Directory=The Directory namespace contains objects for directory services such as the Active Directory.
WMISE_NSDescription_Root_Directory_Ldap=The LDAP namespace contains Active Directory schema and data. You may use this namespace to browse the Active Directory information visible to the local machine.
WMISE_NSDescription_Root_Wmi=The WMI namespace contains detailed data supplied by Windows Driver Model (WDM) drivers installed on the local system.
WMISE_NSDescription_Root_MicrosoftSQLServer=The MicrosoftSQLServer namespace contains objects for managing SQL Server 7.0 and 2000 systems.

#EventQueryDialog.cs
WMISE_EventQueryDlg_SelectEventType=Select event type:
WMISE_EventQueryDlg_IntrinsicEvents=&Data Operation Events
WMISE_EventQueryDlg_ExtrinsicEvents=&Custom Events
WMISE_EventQueryDlg_AvailableClasses=Available classes:
WMISE_EventQueryDlg_IntrinsicEventComboLabel=Fire event when an object is:
WMISE_EventQueryDlg_PollingIntervalLabel=Poll for events every:
WMISE_EventQueryDlg_Title=Select Class



WMISE_QueryNameBase={0} Event Filter
WMISE_PropertyInResultset=In Resultset?
WMISE_ClassNode_GenerateWrapper=&Generate Managed Class
WMISE_Code_Generation_Failed=Code generation failed
WMISE_Could_Not_Add_File_to_Project=Could not add generated file to current project
WMISE_Could_Not_Instantiate_Management_Class=Could not instantiate management class
WMISE_Invalid_Project_Type_For_CodeGen=Managed classes can only be generated in the context of a VB of a CS project.
WMISE_Polling_Interval_Validation_Failed=Value "{0}" is not a valid polling interval. Please enter a valid floating-point number.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\res.txt ===
#generic
WMISE_Cancel=Cancel			
WMISE_Exception=Exception: {0}\n\rTrace: {1}
WMISE_SelectClassBtn=Sele&ct class...
WMISE_SubscribeBtn=Su&bscribe
WMISE_AddEventFilterCM=&Add event filter...
WMISE_AddEventFilterLabel=<Add event filter...>
WMISE_Seconds=seconds
WMISE_OK=OK
WMISE_NoDescr=No description
WMISE_InvalidPath=Invalid Object Path: {0}


#AssocGroupComponent.cs
WMISE_AssocGroupClassPropertyDescr=The name of the class to which the child nodes belong
WMISE_AssocGroupRolePropertyDescr=The role of the child nodes in the relationship
WMISE_AssocGroupAssocPropertyDescr=The name of the relationship class

#ExecuteMethodDialog.cs
WMISE_ExecMethodDlg_Title=Execute Method {0}.{1}
WMISE_ExecMethodDlg_ServerName=Server: {0}
WMISE_ExecMethodDlg_NoInputParams=No Input Parameters
WMISE_ExecMethodDlg_Execute=Execute
WMISE_ExecMethodDlg_InputParameters=Input Parameters
WMISE_ExecMethodDlg_OutputParameters=Output Parameters


#ExtrinsicEventQueryDialog.cs
WMISE_ExtrEventQueryDlg_Title=Build Management Event Query
WMISE_ExtrEventQueryDlg_EventClassLbl=Event class: 

#ExtrinsicEventQueryNode.cs
WMISE_EventQueryStop=Sto&p
WMISE_EventQueryStart=S&tart
WMISE_EventQueryPurge=P&urge

#ExtrinsicEventNode.cs
WMISE_ExtrinsicEventNodeLbl=Management Events

#IntrinsicEventQueryDialog.cs
WMISE_IntrinsicEvent_Created=Created
WMISE_IntrinsicEvent_Modified=Modified
WMISE_IntrinsicEvent_Deleted=Deleted
WMISE_IntrinsicEvent_Operated=Created, Modified or Deleted

WMISE_IntrEventQueryDlg_Title=Build Object Operation Event Query
WMISE_IntrEventQueryDlg_EventClassLbl=Target class: 

WMISE_IntrEventQueryDlg_EventName=Raise event when instance is: 
WMISE_IntrEventQueryDlg_PollingInterval=Poll for events every: 

#IntrinsicEventNode.cs
WMISE_IntrinsicEventNodeLbl=Management Data Events

#SelectWMIClassTreeDialog.cs
WMISE_ClassSelectorLbl=Add Objects
WMISE_ClassSelectorLblSearch=&Find class containing:
WMISE_ClassSelectorBtnSearch=Find &Next
WMISE_ClassSelectorBtnAdd=&Add  >>
WMISE_ClassSelectorBtnRemove=<<  &Remove
WMISE_ClassSelectorSelClassesLbl=Se&lected classes:
WMISE_ClassSelectorAskViewAll=Do you want to add all classes in this namespace?
WMISE_ClassSelectorClassAlreadySelected=Class {0} is already selected
WMISE_ClassSelectorDlgHelp=This dialog allows you to select one or more Management classes. The objects belonging to these classes will be then added as nodes to the Server Explorer tree.


#WMIClassesNode.cs
WMISE_ClassesNode_AddClass=&Add Objects...
WMISE_ClassesNode_AddClassLbl=<Add Objects...>
WMISE_ClassesNodeLbl=Management Data

#WMIClassNode.cs
WMISE_ClassNode_CreateNewInstance=Create &New Object...
WMISE_ClassNode_NewInstanceLbl=<New {0}>
WMISE_ClassNode_RemovePrompt=Are you sure you want to remove {0} from the view?

#WMIInstanceNode.cs
WMISE_InstNode_SaveNewInstanceCM=Save

#WMIObjectComponent.cs
WMISE_ObjComp_PutFailed=Could not save object {0}: {1}


#WMIObjectPropertyTable.cs
WMISE_PropTable_ColumnName=Name
WMISE_PropTable_ColumnType=Type
WMISE_PropTable_ColumnValue=Value
WMISE_PropTable_ColumnDescription=Description
WMISE_PropTable_ColumnComparison=Operator
WMISE_PropTable_ColumnIsKey=Key
WMISE_PropTable_ColumnIsLocal=Local

#namespace descriptions
WMISE_NSDescription_Root=The Root namespace is primarily designed to contain other namespaces. Typically, you should not use root to store your objects.
WMISE_NSDescription_Root_Default=The Default namespace is the default location where objects are stored if a namespace has not been specified.
WMISE_NSDescription_Root_Cimv2=The CIMV2 namespace contains the majority of information about the status and configuration of the local system.
WMISE_NSDescription_Root_Cimv2_Applications=The Applications namespace contains management objects for many applications installed on the local system.
WMISE_NSDescription_Root_Cimv2_Applications_MicrosoftIE=The MicrosoftIE namespace contains object for managing Internet Explorer on the local system.
WMISE_NSDescription_Root_Directory=The Directory namespace contains objects for directory services such as the Active Directory.
WMISE_NSDescription_Root_Directory_Ldap=The LDAP namespace contains Active Directory schema and data. You may use this namespace to browse the Active Directory information visible to the local machine.
WMISE_NSDescription_Root_Wmi=The WMI namespace contains detailed data supplied by Windows Driver Model (WDM) drivers installed on the local system.
WMISE_NSDescription_Root_Microsoft_SQLServer=The MicrosoftSQLServer namespace contains objects for managing SQL Server 7.0 and 2000 systems.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\misc\license\agreement.txt ===
Microsoft Windows Management Instrumentation Software Development Kit
END-USER LICENSE AGREEMENT FOR MICROSOFT SOFTWARE

IMPORTANT-READ CAREFULLY: This Microsoft End-User License Agreement ("EULA") is a legal agreement between you (either an individual or a single entity) and Microsoft Corporation for the Microsoft software product identified above, which includes computer software and may include associated media, printed materials, and "online" or electronic documentation ("SOFTWARE PRODUCT").  The SOFTWARE PRODUCT also includes any updates and supplements to the original SOFTWARE PRODUCT provided to you by Microsoft. Any software provided along with the SOFTWARE PRODUCT that is associated with a separate end-user license agreement is licensed to you under the terms of that license agreement. By installing, copying, downloading, accessing or otherwise using the SOFTWARE PRODUCT, you agree to be bound by the terms of this EULA. If you do not agree to the terms of this EULA, do not install or use the SOFTWARE PRODUCT.

SOFTWARE PRODUCT LICENSE
The SOFTWARE PRODUCT is protected by copyright laws and international copyright treaties, as well as other intellectual property laws and treaties. The SOFTWARE PRODUCT is licensed, not sold. 

1.	GRANT OF LICENSE. This EULA grants you the following rights:
* Software Product. You may install and use the SOFTWARE PRODUCT on an unlimited number of computers, including workstations, terminals or other digital electronic devices ("COMPUTERS") to design, develop, and test software application products that (a) utilize Microsoft Windows Management Instrumentation technology for Microsoft Windows NT version 4.0 and subsequent versions thereof, including Windows 2000, operating systems, and (b) utilize the CIMV2 schema as described in the \LICENSE\SCHEMA.TXT file ("Application").  

* Sample Code. You may modify the sample source code located in the SOFTWARE PRODUCT's "samples" directories ("Sample Code") to design, develop, and test your Application. You may also reproduce and distribute the Sample Code in object code form along with any modifications you make to the Sample Code, provided that you comply with the Distribution Terms described below. For purposes of this section, "modifications" shall mean enhancements to the functionality of the Sample Code.

* Redistributable Code.  Portions of the SOFTWARE PRODUCT are designated as "Redistributable Code".  The text file, \LICENSE\REDIST.TXT, lists the Redistributable code and describes distribution rights associated with the Redistributable Code, subject further to the Distribution Terms specified below.

* Distribution Terms. You may reproduce and distribute an unlimited number of copies of the Sample Code and/or Redistributable Code (collectively "REDISTRIBUTABLE COMPONENTS") as described above, provided that (a) you distribute the REDISTRIBUTABLE COMPONENTS only in conjunction with, and as a part of, your Application; (b) your Application adds significant and primary functionality to the REDISTRIBUTABLE COMPONENTS; (c) the REDISTRIBUTABLE COMPONENTS only operate in conjunction with Microsoft Windows NT version 4.0 and subsequent versions thereof, including Windows 2000; (d) you distribute your Application containing the REDISTRIBUTABLE COMPONENTS pursuant to an End-User License Agreement (which may be "break-the-seal", "click-wrap" or signed), with terms no less protective than those contained herein; (e) you do not permit further redistribution of the REDISTRIBUTABLE COMPONENTS by your end-user customers; (f) you do not use Microsoft's name, logo, or trademarks to market your Application; (g) you include a valid copyright notice on your Application; and (h) you agree to indemnify, hold harmless, and defend Microsoft from and against any claims or lawsuits, including attorneys' fees, that arise or result from the use or distribution of your Application.  Contact Microsoft for the applicable royalties due and other licensing terms for all other uses and/or distribution of the REDISTRIBUTABLE COMPONENTS.

2.	DESCRIPTION OF OTHER RIGHTS AND LIMITATIONS. 
* Limitations on Reverse Engineering, Decompilation, and Disassembly. You may not reverse engineer, decompile, or disassemble the SOFTWARE PRODUCT, except and only to the extent that such activity is expressly permitted by applicable law notwithstanding this limitation.

* Rental. You may not rent, lease or lend the SOFTWARE PRODUCT.

* Support Services. Microsoft may provide you with support services related to the SOFTWARE PRODUCT ("Support Services"). Use of Support Services is governed by the Microsoft polices and programs described in the user manual, in "on line" documentation and/or other Microsoft-provided materials. Any supplemental software code provided to you as part of the Support Services shall be considered part of the SOFTWARE PRODUCT and subject to the terms and conditions of this EULA. With respect to technical information you provide to Microsoft as part of the Support Services, Microsoft may use such information for its business purposes, including for product support and development. Microsoft will not utilize such technical information in a form that personally identifies you.

* Software Transfer. You may permanently transfer all of your rights under this EULA, provided you retain no copies, you transfer all of the SOFTWARE PRODUCT (including all component parts, the media and printed materials, any upgrades, this EULA, and, if applicable, the Certificate of Authenticity) and the recipient agrees to the terms of this EULA.  If the SOFTWARE PRODUCT is an upgrade, any transfer must include all prior versions of the SOFTWARE PRODUCT.

* Termination. Without prejudice to any other rights, Microsoft may terminate this EULA if you fail to comply with the terms and conditions of this EULA. In such event, you must destroy all copies of the SOFTWARE PRODUCT and all of its component parts.

3.	COPYRIGHT. All title and intellectual property rights in and to the SOFTWARE PRODUCT (including but not limited to any images, photographs, animations, video, audio, music, text, and "applets" incorporated into the SOFTWARE PRODUCT), the accompanying printed materials, and any copies of the SOFTWARE PRODUCT are owned by Microsoft or its suppliers. All title and intellectual property rights in and to the content which may be accessed through use of the SOFTWARE PRODUCT is the property of the respective content owner and may be protected by applicable copyright or other intellectual property laws and treaties.  This EULA grants you no rights to use such content. All rights not expressly granted are reserved by Microsoft.

 4.	U.S. GOVERNMENT RESTRICTED RIGHTS. All SOFTWARE PRODUCT provided to the U.S. Government pursuant to solicitations issued on or after December 1, 1995 is provided with the commercial license rights and restrictions described elsewhere herein.  All SOFTWARE PRODUCT provided to the U. S. Government pursuant to solicitations issued prior to December 1, 1995 is provided with "Restricted Rights" as provided for in FAR, 48 CFR 52.227-14 (JUNE 1987) or DFAR, 48 CFR 252.227-7013 (OCT 1988), as applicable.

5.	EXPORT RESTRICTIONS. You agree that you will not export or re-export the SOFTWARE PRODUCT, any part thereof, or any process or service that is the direct product of the SOFTWARE PRODUCT (the foregoing collectively referred to as the "Restricted Components"), to any country, person or entity subject to U.S. export restrictions.  You specifically agree not to export or re-export any of the Restricted Components: (i) to any country to which the U.S. has embargoed or restricted the export of goods or services, which currently include, but are not necessarily limited to Cuba, Iran, Iraq, Libya, North Korea, Sudan and Syria, or to any national of any such country, wherever located, who intends to transmit or transport the Restricted Components back to such country; (ii) to any person or entity who you know or have reason to know will utilize the Restricted Components in the design, development or production of nuclear, chemical or biological weapons; or (iii) to any person or entity who has been prohibited from participating in U.S. export transactions by any federal agency of the U.S. government.  You warrant and represent that neither the BXA nor any other U.S. federal agency has suspended, revoked or denied your export privileges.
MISCELLANEOUS
If you acquired this product in the United States, this EULA is governed by the laws of the State of Washington. 
If you acquired this product in Canada, this EULA is governed by the laws of the Province of Ontario, Canada. Each of the parties hereto irrevocably attorns to the jurisdiction of the courts of the Province of Ontario and further agrees to commence any litigation which may arise hereunder in the courts located in the Judicial District of York, Province of Ontario. 
If this product was acquired outside the United States, then local law may apply.
Should you have any questions concerning this EULA, or if you desire to contact Microsoft for any reason, please contact Microsoft, or write: Microsoft Sales Information Center/One Microsoft Way/Redmond, WA 98052-6399. 
NO WARRANTIES.
DISCLAIMER OF  WARRANTIES.  To the maximum extent permitted by applicable law, Microsoft and its suppliers provide the SOFTWARE PRODUCT and any (if any) Support Services AS IS AND WITH ALL FAULTS, and hereby disclaim all warranties and conditions, either express, implied or statutory, including, but not limited to, any (if any) implied warranties or conditions of merchantability, of fitness for a particular purpose, of lack of viruses, of accuracy or completeness of responses, of results, and of lack of negligence or lack of workmanlike effort, all with regard to the SOFTWARE PRODUCT, and the provision of or failure to provide Support Services.  ALSO, THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT, QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR NON-INFRINGEMENT, WITH REGARD TO THE SOFTWARE PRODUCT.  THE ENTIRE RISK AS TO THE QUALITY OF OR ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE PRODUCT AND SUPPORT SERVICES, IF ANY, REMAINS WITH YOU.
EXCLUSION OF INCIDENTAL, CONSEQUENTIAL AND CERTAIN OTHER DAMAGES.  TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL MICROSOFT OR ITS SUPPLIERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, BUT NOT LIMITED TO, DAMAGES FOR LOSS OF PROFITS OR CONFIDENTIAL OR OTHER INFORMATION, FOR BUSINESS INTERRUPTION, FOR PERSONAL INJURY, FOR LOSS OF PRIVACY, FOR FAILURE TO MEET ANY DUTY INCLUDING OF GOOD FAITH OR OF REASONABLE CARE, FOR NEGLIGENCE, AND FOR ANY OTHER PECUNIARY OR OTHER LOSS WHATSOEVER) ARISING OUT OF OR IN ANY WAY RELATED TO THE USE OF OR INABILITY TO USE THE SOFTWARE PRODUCT, THE PROVISION OF OR FAILURE TO PROVIDE SUPPORT SERVICES, OR OTHERWISE UNDER OR IN CONNECTION WITH ANY PROVISION OF THIS EULA, EVEN IN THE EVENT OF THE FAULT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY, BREACH OF CONTRACT OR BREACH OF WARRANTY OF MICROSOFT OR ANY SUPPLIER, AND EVEN IF MICROSOFT OR ANY SUPPLIER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 
LIMITATION OF LIABILITY AND REMEDIES. Notwithstanding any damages that you might incur for any reason whatsoever (including, without limitation, all damages referenced above and all direct or general damages), the entire liability of Microsoft and any of its suppliers under any provision of this EULA and your exclusive remedy for all of the foregoing shall be limited to the greater of the amount actually paid by you for the SOFTWARE PRODUCT or U.S.$5.00.  The foregoing limitations, exclusions and disclaimers shall apply to the maximum extent permitted by applicable law, even if any remedy fails its essential purpose.

Si vous avez acquis votre produit Microsoft au CANADA, la garantie limite suivante vous concerne :

RENONCIATION AUX GARANTIES. Dans toute la mesure permise par la lgislation en vigueur, Microsoft et ses fournisseurs fournissent le PRODUIT LOGICIEL et tous (selon le cas) Services d'assistance TELS QUELS ET AVEC TOUS LEURS DFAUTS, et par les prsentes excluent toute garantie ou condition, expresse ou implicite, lgale ou conventionnelle, crite ou verbale, y compris, mais sans limitation, toute (selon le cas) garantie ou condition implicite ou lgale de qualit marchande, de conformit  un usage particulier, d'absence de virus, d'exactitude et d'intgralit des rponses, de rsultats, d'efforts techniques et professionnels et d'absence de ngligence, le tout relativement au PRODUIT LOGICIEL et  la prestation ou  la non-prestation des Services d'assistance.  DE PLUS, IL N'Y A AUCUNE GARANTIE ET CONDITION DE TITRE, DE JOUISSANCE PAISIBLE, DE POSSESSION PAISIBLE, DE SIMILARIT  LA DESCRIPTION ET D'ABSENCE DE CONTREFAON RELATIVEMENT AU PRODUIT LOGICIEL.  Vous supportez tous les risques dcoulant de l'utilisation et de la performance du PRODUIT LOGICIEL et ceux dcoulant des Services d'assistance (s'il y a lieu).

EXCLUSION DES DOMMAGES INDIRECTS, ACCESSOIRES ET AUTRES.  Dans toute la mesure permise par la lgislation en vigueur, Microsoft et ses fournisseurs ne sont en aucun cas responsables de tout dommage spcial, indirect, accessoire, moral ou exemplaire quel qu'il soit (y compris, mais sans limitation, les dommages entrans par la perte de bnfices ou la perte d'information confidentielle ou autre, l'interruption des affaires, les prjudices corporels, la perte de confidentialit, le dfaut de remplir toute obligation y compris les obligations de bonne foi et de diligence raisonnable, la ngligence et toute autre perte pcuniaire ou autre perte de quelque nature que ce soit) dcoulant de, ou de toute autre manire li , l'utilisation ou l'impossibilit d'utiliser le PRODUIT LOGICIEL, la prestation ou la non-prestation des Services d'assistance ou autrement en vertu de ou relativement  toute disposition de cette convention, que ce soit en cas de faute, de dlit (y compris la ngligence), de responsabilit stricte, de manquement  un contrat ou de manquement  une garantie de Microsoft ou de l'un de ses fournisseurs, et ce, mme si Microsoft ou l'un de ses fournisseurs a t avis de la possibilit de tels dommages.

LIMITATION DE RESPONSABILIT ET RECOURS.  Malgr tout dommage que vous pourriez encourir pour quelque raison que ce soit (y compris, mais sans limitation, tous les dommages mentionns ci-dessus et tous les dommages directs et gnraux), la seule responsabilit de Microsoft et de ses fournisseurs en vertu de toute disposition de cette convention et votre unique recours en regard de tout ce qui prcde sont limits au plus lev des montants suivants:  soit (a) le montant que vous avez pay pour le PRODUIT LOGICIEL, soit (b) un montant quivalant  cinq dollars U.S. (5,00 $ U.S.).  Les limitations, exclusions et renonciations ci-dessus s'appliquent dans toute la mesure permise par la lgislation en vigueur, et ce mme si leur application a pour effet de priver un recours de son essence.

DROITS LIMITS DU GOUVERNEMENT AMRICAIN
Tout PRODUIT LOGICIEL fourni au gouvernement amricain conformment  des demandes mises le ou aprs le 1er dcembre 1995 est offert avec les restrictions et droits commerciaux dcrits ailleurs dans la prsente convention.  Tout PRODUIT LOGICIEL fourni au gouvernement amricain conformment  des demandes mises avant le 1er dcembre 1995 est offert avec des DROITS LIMITS tels que prvus dans le FAR, 48CFR 52.227-14 (juin 1987) ou dans le FAR, 48CFR 252.227-7013 (octobre 1988), tels qu'applicables.
Sauf lorsqu'expressment prohib par la lgislation locale, la prsente  convention est rgie par les lois en vigueur dans la province d'Ontario, Canada.  Pour tout diffrend qui pourrait dcouler des prsentes, vous acceptez la comptence des tribunaux fdraux et provinciaux sigeant  Toronto, Ontario.

Si vous avez des questions concernant cette convention ou si vous dsirez communiquer avec Microsoft pour quelque raison que ce soit, veuillez contacter la succursale Microsoft desservant votre pays, ou crire : Microsoft Sales Information Center, One Microsoft Way, Redmond, Washington 98052-6399.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\misc\docs\wmisetupspec.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Metro Information Services Title _PID_HLINKSa-bakulg Normal.dot Dragomir Todorov Microsoft Word 9.0$`'0* 2p5@8 CPF I Q`T0WPKj/VvP y"-dd Em| b ]5zL>T fcn(^cMicrosoft Excel Worksheet Biff8 Excel.Sheet.8Microsoft Sheet1 Sheet2 Sheet3 Worksheets _PID_GUIDMichael C. Maston Michael C. Maston Microsoft Excel"$"#,##0_);\("$"#,##0\) "$"#,##0_);[Red]\("$"#,##0\) "$"#,##0.00_);\("$"#,##0.00\) "$"#,##0.00_);[Red]\("$"#,##0.00\) _("$"* #,##0_);_("$"* \(#,##0\);_("$"* "-"_);_(@_) _(* #,##0_);_(* \(#,##0\);_(* "-"_);_(@_) _("$"* #,##0.00_);_("$"* \(#,##0.00\);_("$"* "-"??_);_(@_) _(* #,##0.00_);_(* \(#,##0.00\);_(* "-"??_);_(@_) Sheet1 Sheet2 Sheet3 Old Core/Old SNMP Command Line - No extra options Command Line w/SNMP option Old Core/No SNMP Current Core/No SNMP Current Core/Current SNMP Newer Core% Unchecked/"Install WMI SNMP Provider"+ Behavior:  Upgrade core, don't install SNMP% Behavior:  Upgrade core, install SNMP% Behavior:  Upgrade core, upgrade SNMP' Checked/"Reinstall WMI Core Components"/ Checked -Grayed out/"Upgrade WMI SNMP Provider"1 Checked -Grayed out/"Upgrade WMI Core Components" Core Option Box State/Text SNMP Option Box State/Text- Behavior:  Reinstall core, don't install SNMP) Behavior:  Reinstall core, reinstall SNMP' Unchecked/"Reinstall WMI SNMP Provider"' Behavior:  Reinstall core, install SNMP/ Behavior:  Reinstall core, don't reinstall SNMP Core newer than in WBEMCORE Make no changes MbP?_ Old Core/No SNMP Old Core/Old SNMP Current Core/No SNMP Current Core/Current SNMP Core newer than in WBEMCORE Core Option Box State/Text Checked -Grayed out/"Upgrade WMI Core Components" Checked -Grayed out/"Upgrade WMI Core Components" Checked/"Reinstall WMI Core Components" Checked/"Reinstall WMI Core Components" Make no changes SNMP Option Box State/Text Unchecked/"Install WMI SNMP Provider" Checked -Grayed out/"Upgrade WMI SNMP Provider" Unchecked/"Install WMI SNMP Provider" Unchecked/"Reinstall WMI SNMP Provider" Make no changes Command Line - No extra options Behavior:  Upgrade core, don't install SNMP Behavior:  Upgrade core, upgrade SNMP Behavior:  Reinstall core, don't install SNMP Behavior:  Reinstall core, don't reinstall SNMP Make no changes Command Line w/SNMP option Behavior:  Upgrade core, install SNMP Behavior:  Upgrade core, upgrade SNMP Behavior:  Reinstall core, install SNMP Behavior:  Reinstall core, reinstall SNMP Make no changes MbP?_ MbP?_bjbjU WMI SETUP SPEC. FOR M3.  TOC \o "1-3"  WMI SETUP SPEC. FOR M3.  PAGEREF _Toc459185686 \h  Revision History  PAGEREF _Toc459185687 \h  Clean Install Using WbemCore.EXE  PAGEREF _Toc459185688 \h  Installation Source Files  PAGEREF _Toc459185689 \h  EXE Name  PAGEREF _Toc459185690 \h  Files Being Installed  PAGEREF _Toc459185691 \h  Installed By  PAGEREF _Toc459185692 \h  Step By Step Wbemcore Setup Procedure  PAGEREF _Toc459185693 \h  Providers Installed On Various Platform OSs  PAGEREF _Toc459185694 \h  Registry Keys installed by Wbemcore.exe  PAGEREF _Toc459185695 \h  SNMP Provider installation scenario with Wbemcore.exe  PAGEREF _Toc459185696 \h  WBEM Files Interaction  PAGEREF _Toc459185697 \h  Clean Install Using In-The-Box W2K Install  PAGEREF _Toc459185698 \h  Files Being Installed By W2K For WBEM  PAGEREF _Toc459185699 \h  Files Being Installed By WBEMNT5.INF  PAGEREF _Toc459185700 \h  Files Being Removed By WBEMNT5.INF During Upgrade  PAGEREF _Toc459185701 \h  Actions Performed by WBEMNT5.INF SECTIONS  PAGEREF _Toc459185702 \h  Registry Keys installed during In-Box setup  PAGEREF _Toc459185703 \h  Clean Install Using In-The-Box Win98 Install  PAGEREF _Toc459185704 \h  Files Being Installed By W2K For WBEM  PAGEREF _Toc459185705 \h  Files Being Installed By WBEM.INF  PAGEREF _Toc459185706 \h  Files Being Removed By WBEM.INF During Upgrade  PAGEREF _Toc459185707 \h  Registry Keys installed during In-Box setup  PAGEREF _Toc459185708 \h  Registry Keys uninstalled (deleted) during In-Box setup (In case of upgrades)  PAGEREF _Toc459185709 \h  Registry Keys uninstalled (deleted) during WBEM uninstall (during Uninstalling WBEM)  PAGEREF _Toc459185710 \h  Actions Performed by WBEM.INF SECTIONS  PAGEREF _Toc459185711 \h  Important Win98 Setup Issues and Design.  PAGEREF _Toc459185712 \h  Various Upgrade Scenarios  PAGEREF _Toc459185713 \h  Wbemcore.exe To Wbemcore.exe  PAGEREF _Toc459185714 \h  Wbemcore.exe To In-The-Box W2K  PAGEREF _Toc459185715 \h  In-The-Box To In-The-Box W2K  PAGEREF _Toc459185716 \h  Win9x To In-the-Box W2K  PAGEREF _Toc459185717 \h  Common Known Issues  PAGEREF _Toc459185718 \h  Downgrading WBEM Problem  PAGEREF _Toc459185719 \h  Wbemcore.exe asking to RESTART  PAGEREF _Toc459185720 \h  Inconsistency Between Wbemcore.exe and In-The-Box W2K Install  PAGEREF _Toc459185721 \h  Upgrading From Win9x to In-The-Box W2K  PAGEREF _Toc459185722 \h  Platform Specific Issues  PAGEREF _Toc459185723 \h  Miscellaneous  PAGEREF _Toc459185724 \h  Adding Files To W2K  PAGEREF _Toc459185725 \h  Text Mode Setup vs INF Mode SETUP  PAGEREF _Toc459185726 \h  SDK Setup Files  PAGEREF _Toc459185727 \h  Installation Source Files  PAGEREF _Toc459185728 \h  EXE Name  PAGEREF _Toc459185729 \h  Files Being Installed  PAGEREF _Toc459185730 \h  Installed By  PAGEREF _Toc459185731 \h  Revision History Change Description Modified By Created 01\26\99 Bakul Gala Added one section and some comments 01\29\99 Bakul Gala Clean Install Using WbemCore.EXE Installation Source Files EXE Name Install Script File Name Include File Name Purpose Comments Wbemcore.exe Wbemcore.ipf Wbemmain.ipf Starts the execution thread Wbemmain.ipf Core.ipf Odbc.ipf Snmp.ipf Controls actual flow of the installation. Core.ipf Installs files and Registry and makes entries into uninstall log. Odbc.ipf Installs wbem odbc driver (wbemdr32.dll) and registers it and creates DSN. Cancel.ipf Called when user cancels installation. Deletes temp. install directory. Exit.ipf Called when the installation is exited. Cleans up temp. install directory. Snmp.ipf Installs wmi snmp provider. This was added back to wbemcore setup for DCR# 47620. Files Being Installed Installed By Installed File Name Installation Directory Comments Wbemcore.ipf Wbemmain.ipf WBEMSETUP.DLL Copied to temp directory and deleted after install completes. This is a Helper dll. WbemUpgd.DLL Copied to temp directory and deleted after install completes. This is a Helper dll. msvcrt.dll %SystemRoot%\System32 (Windows system directory) msvcirt.dll %SystemRoot% \System32(Windows system directory) mfc42.dll %SystemRoot% \System32(Windows system directory) mfc42u.dll %SystemRoot% \System32(Windows system directory) Ctl3d32.dll (based on platform and os) %SystemRoot% \system32 (Windows system directory) Psapi.dll  (based on platform and os) %SystemRoot%\System32 (Windows system directory) Filelist.txt Temp. dir (this file lists the files which are checked for being used from wbemseup dll api). uninst32.exe Wbem SDK dir. (this is used only if incompatible version of sdk is found which needs to be deleted). wbemstop.exe %SystemRoot%\System32\Wbem This is not installed anymore. Core.ipf cimwin32.dll (Ansi/Unicode) %SystemRoot%\System32\Wbem Ansi\Unicode For M3. DCR# 44628. cimw32ex.dll %SystemRoot%\System32\Wbem Removed from M3. DCR# 44629. fastprox.dll %SystemRoot%\System32\Wbem framedyn.dll %SystemRoot%\System32\Wbem stdprov.dll %SystemRoot%\System32\Wbem wbemcore.dll %SystemRoot%\System32\Wbem wbemess.dll %SystemRoot%\System32\Wbem wbemprox.dll %SystemRoot%\System32\Wbem wbemcomn.dll %SystemRoot%\System32\Wbem WinMgmtR.dll %SystemRoot%\System32\Wbem Wbemdisp.dll %SystemRoot%\System32\Wbem Wbemdisp.tlb %SystemRoot%\System32\Wbem secrcw32.dll %SystemRoot%\System32\Wbem Removed from M3. DCR# 45746. In-Box W2K will continue to install empty stub dll, though it will not be used. Wbemsvc.dll (depends on NT5 or not and DCOM available or not). %SystemRoot%\System32\Wbem Wbemmcp.dll (depends on DCOM available or not) %SystemRoot%\System32\Wbem Removed from M3 (DCR# 46652) Wbemmsp.dll(depends on DCOM available or not) %SystemRoot%\System32\Wbem Removed from M3 (DCR# 46652) ntevt.dll (only on NT) %SystemRoot%\System32\Wbem ntevt.mof (only on NT) %SystemRoot%\System32\Wbem ntevt.mof (only on NT) %SystemRoot%\System32\Wbem Cim32net.dll (only for x86) %SystemRoot%\System32\Wbem Cim16net.dll(only for x86) %SystemRoot%\System32\Wbem WinMgmt.exe %SystemRoot%\System32\Wbem Unsecapp.exe %SystemRoot%\System32\Wbem mofd.dll %SystemRoot%\System32\Wbem Mofcomp.exe %SystemRoot%\System32\Wbem smbios.sys (only on NT 4) %SystemRoot%\System32\Drivers Smbdpmi.exe (only on Win9x) %SystemRoot%\System32\Wbem Wbemtest.exe %SystemRoot%\System32\Wbem Wbemperm.exe (unicode or ansi based on os) %SystemRoot%\System32\Wbem Removed from M3. DCR# 47423 and 47548. Wbemcntl.exe %SystemRoot%\System32\Wbem Wmimofck.exe %SystemRoot%\System32\Wbem This is not installed any mroe Cimwin32.mof %SystemRoot%\System32\Wbem Cimwin32.mfl %SystemRoot%\System32\Wbem Regevent.mof %SystemRoot%\System32\Wbem secrcw32.mof %SystemRoot%\System32\Wbem secrcw32.mfl %SystemRoot%\System32\Wbem Custinst.mof %SystemRoot%\System32\Wbem Wbemuser.chm %SystemRoot%\HELP omc.chm %SystemRoot%\HELP Wmiprov.dll %SystemRoot%\System32\Wbem wmi.mof %SystemRoot%\System32\Wbem Viewtest.mof %SystemRoot%\System32\Wbem Viewprov.dll (unicode or ansi) %SystemRoot%\System32\Wbem Provthrd.dll (unicode or ansi) %SystemRoot%\System32\Wbem Dsprov.mof (only on W2K) %SystemRoot%\System32\Wbem Dsprov.dll (only on W2K) %SystemRoot%\System32\Wbem Msi.mof (on all platform if msi is installer) %SystemRoot%\System32\Wbem Msi.mfl (on all platforms if msi is installed) %SystemRoot%\System32\Wbem Msiprov.dll (on all platforms if msi is installed) %SystemRoot%\System32\Wbem Framedyu.dll (only on NT) %SystemRoot%\System32\Wbem Added to M3. DCR# 44628. Removed from M3. DCR#45686. Date 02/16/99. Smbdpmi.pif (Only for Win9x) %SystemRoot%\System32\Wbem Added for Bug# 48623. Msimeth.exe (only for NT4) %SystemRoot%\System32\Wbem Added for DCR#50850. msimethps.dll exe (only for NT4) %SystemRoot%\System32\Wbem Added for DCR#50933. Odbc.ipf WBEMDR32.dll (odbc driver) %SystemRoot%\System32 Cancel.ipf Exit.ipf Snmp.ipf snmpthrd.dll %SystemRoot%\System32\Wbem\snmpthrd.dll snmpcl.dll %SystemRoot%\System32\Wbem\snmpcl.dll wsnmp32.dll %SystemRoot%\System32\wsnmp32.dll Smi2smir.exe %SystemRoot%\System32\Wbem \SNMP\smi2smir.exe Snmpsmir.dll %SystemRoot%\System32\Wbem\snmpsmir.dll snmpsmir.dll %SystemRoot%\System32\Wbem \SNMP\snmpsmir.dll smierrsm.dll %SystemRoot%\System32\Wbem \SNMP\smierrsm.dll smierrsy.dll %SystemRoot%\System32\Wbem \SNMP\smierrsy.dll smimsgif.dll %SystemRoot%\System32\Wbem \SNMP\smimsgif.dll snmpincl.dll %SystemRoot%\System32\Wbem\snmpincl.dll snmptrap.exe %SystemRoot%\System32\snmptrap.exe wsnmp32.dll %SystemRoot%\System32\wsnmp32.dll snmpsmir.mof %SystemRoot%\System32\Wbem\snmpsmir.mof snmpreg.mof %SystemRoot%\System32\Wbem\snmpreg.mof SNMP-README.HTM %SystemRoot%\System32\Wbem Added for raid #44556. Note: Items marked in RED needs to be discussed and resolved for W2K In-The-Box for M3. Step By Step Wbemcore Setup Procedure STEP1: Check for Windows Version: If windows major version is less than or equal to 3 (Win3.1, Win3.11, Win NT3.5 etc.) then the setup will exit after displaying following message:  WMI Core components cannot be installed on this version of Windows. STEP2: Check for Processor Architecture If the processor architecture does not match with the image of the exe for which it is build then it will exit the installation after displaying following message:  This program is a valid NT image, but for a different processor architecture. STEP3: Check for Build Number If the build number contains   instead of proper integer value than the installation will exit after displaying following message:  Build number is invalid. STEP4: Check for Commandline Options If the commandline option consists /S or /s than the SILENTFLAG is set so that no UI diaog is displayed during installation. If commandline option consists /X or /x than the SMS Installer displays the files which are bundled in this EXE and allows to select and extrace any particular files. If commandline option consists of /? Then wbemcore commandline usage help is displayed. It reveals only /s since /x is undocumented switch. STEP5: Check for NT Admin Privileges  If the user does not have Administrator Privileges than the installation will exit after displaying following message :  You must have Adminstrative privileges to use this installation program. STEP5.1: Check if wbemcore.exe already running If wbemcore.exe is already running as another process than display following message and exit installation.  WMI Core Components setup is already running. Multiple copies of the WMI setup program cannot be run. STEP5.2: Check if Windows 2000 If wbemcore.exe is tried to run on a W2K system then it will display following message and exit installation.  WMI Core components cannot be installed on this version of Windows. STEP6: Check for Free Disk Space Install now checks for free disk space and if not enough disk space is there than SMS Installer displays default message and exists installation. STEP7: Installs System Dlls Installs msvcrt.dll, msvcirt.dll, mfc42.dll and mfc42u.dll into system32 directory if the existing files are of older versions. Installs ctl3d32.dll and psapi.dll based on the platform (x86/Alpha) and OS version. For W2K, psapi.dll goes into Wbem directory instead of system directory. STEP8: Check for WMI Already Exists If the already installed version id greater than the current installing version than it will exit installation after displaying following message :  Setup has detected that a newer version of WMI exists.  Click OK to end this installation. If the same version of WMI already exists than the install will display following message :  Setup has detected an existing WMI installation of the same version.  Would you like to continue with this installation anyway?  and ask user whether to continue with install or not. If the existing version is older than the currently being installed than it will display the following warning message  WMI Installer has detected an older version of WMI installed on this system. If you continue to install, the older version will be overwritten and will be upgraded by a newer verson. To upgrade WMI and continue the installation, click Yes.  To exit this installation now, click No.  and either continue or exit installation based on user input. STEP9: Check for DCOM on Win95 If the system is Win95 than check if DCOM is available. If DCOM is not available than installation will exit after displaying following message :  WMI runs only if DCOM is available, but DCOM was not found.  Please install DCOM and then restart setup. STEP10: Welcome Dialog Install now displays setup Welcome dialog. STEP11: Check for Files in-use If  there is already some version of Wmi installed on the system than check if any Wmi files are open which needs to be overwritten, if so than display following message and behave according to user action :  File is in use. You can choose to 'Abort' Setup, or close the application that is using this file and select 'Retry'. If you select 'Ignore', setup will attempt to update file at the next reboot.WARNING: If you select 'Ignore', WMI may not install properly.  Either continue or Exit installation based on user s input. STEP12: Check if SNMP installed If SNMP is installed and the existing core version is different from one being installed now than display following message :  Setup has detected an incompatible version of WMI SNMP.  Setup needs to remove WMI SNMP before it can install WMI.  You can download the correct version of WMI SNMP at:http://msdn.microsoft.com/developer/sdk/wmisdk. To remove WMI SNMP and continue with WMI Setup choose Yes.  To exit Setup choose No.  Depending upon user selection either exit setup or remove SNMP and continue with the setup. STEP13: Check WMI SDK dependency If installed version of WMI is not same as being installed now and if the installed version is less than or equal to 698 than display message :  WMI Installer has detected a version of the WMI SDK that is not compatible with this version.  In order for this utility to work, it will have to be deleted now, and you can download the correct version from the web site, at   HYPERLINK http://msdn.microsoft.com/developer/sdk/wbemsdk  http://msdn.microsoft.com/developer/sdk/wmisdk . To remove the WMI SDK and continue the installation, click Yes.  To exit this installation now, click No.  Depending upon user selection either exit installation or uninstall WMI SDK  and continue. Do the same thing if existing  SDK version is less than 700. STEP14: Install WMI Files Install all WMI files specified above in section 1.2 into WBEM directory. STEP15: Check for WMI ODBC Driver If the installed core version is less than 600 than unregister and remove WMI Odbc driver (Wbemdr32.dll). Install and register WMI Odbc driver. STEP16: Set Environment Path If the system is NT than set Environment Path for Wbem directory. STEP17: Perform Cleanup Incase of upgrades delete files which are not used anymore. STEP18: Register Files & OCXs Call SMS Installer script API to register all OCXs and Dlls which were installed. STEP19: Upgrade or Build Repository Repository is created or updated by calling UPGRADECORE function of Wbemupgd.dll. STEP20: Display Finish dialog Display Installation finish dialog at the end and AMS installer will automatically decide whether to ask for reboot or not, if required, it will ask user to reboot the system. In case of   option, user will not be asked to restart the system. Providers Installed On Various Platform OSs Provider Name Provider Files Installation Platform Oss Comments Win32 Provider Cimwin32.dll Cimwin32.mof Win95 | Win98 | WinNT351 | WinNT4 | Win2K Registry Event Provider Regevent.mof Win95 | WinNT351 | WinNT4 | Win2K NT Event Provider Ntevt.dll Ntevt.mof WinNT351 | WinNT4  | Win2K WMI Provider Wmiprov.dll Wmi.mof Win98 | Win2K Security Provider Secrcw32.dll Secrcw32.mof WinNT4 | Win2K DS Provider Dsprov.dll Dsprov.mof Win2K MSI Provider Msiprov.dll Msi.mof Win2k Perf Provider wbemperf.mof perfos.mof perfnet.mof perfproc.mof perfctrs.mof perfdisk.mof Win2K We don t install these as part of Wbemcore.exe or Win2k in-box. They gets installed by Win2k setup. We just compile them in our upgrade dll. Registry Keys installed by Wbemcore.exe Script File Name Registry Key Value Comments Wbemmain.ipf HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\Timeoutms 60000 Installed only on Win95 Wbemmain.ipf HKLM\SOFTWARE\Microsoft\WBEM\Usage Count Wbemmain.ipf HKLM\SOFTWARE\Microsoft\WBEM\Build Current installed build Wbemmain.ipf HKLM\SOFTWARE\Microsoft\WBEM\WMI Install Completed 0 or 1  WMI Install failed.  WMI Install  completed successfully. Core.ipf HKLM\System\CurrentControlSet\Services\smbios\DisplayName SMBIOS Installed on NT4 if SMBIOS does not already exists. Core.ipf HKLM\System\CurrentControlSet\Services\smbios\ErrorControl Installed on NT4 if SMBIOS does not already exists. Core.ipf HKLM\System\CurrentControlSet\Services\smbios\ImagePath SystemRoot\SYSTEM32\DRIVERS\smbios.sys Installed on NT4 if SMBIOS does not already exists. Core.ipf HKLM\System\CurrentControlSet\Services\smbios\Start Installed on NT4 if SMBIOS does not already exists. Core.ipf HKLM\System\CurrentControlSet\Services\smbios\Type Installed on NT4 if SMBIOS does not already exists. Core.ipf HKLM\SOFTWARE\Microsoft\WBEM\ Installation Directory % ROOTDIR% Core.ipf HKLM\SOFTWARE\Microsoft\WBEM\ MOF Self-Install Directory %ROOTDIR%\MOF Core.ipf HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Starting Db Size 200000 Core.ipf HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Repository Directory %ROOTDIR%\Repository Core.ipf HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Working Directory %ROOTDIR% Core.ipf HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Logging Core.ipf HKLM\SOFTWARE\Microsoft\WBEM\Providers\Default Core.ipf HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Autorecover MOFs (empty) Core.ipf HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Logging Directory %ROOTDIR%\Logs Core.ipf HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ SetupForDCOM Core.ipf HKLM\System\CurrentControlSet\Services\EventLog\Application\WinMgmt\ EventMessageFile %ROOTDIR%\winmgmtr.dll Installed only on NT Core.ipf HKLM\System\CurrentControlSet\Services\EventLog\Application\WinMgmt\ TypesSupported Installed only on NT Core.ipf HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents\WBEM\Installed Installed only on Memphis Core.ipf HKLM\SYSTEM\CurrentControlSet\Services\WinMgmt\ImagePath %ROOTDIR%\winmgmt.exe Installed only on NT Core.ipf HKEY_CLASSES_ROOT\AppID\WinMgmt.exe\APPID {8BC3F05E-D86B-11D0-A075-00C04FB68820} Added for DCR 48329. SNMP Provider installation scenario with Wbemcore.exe EMBED Excel.Sheet.8 WBEM Files Interaction File Type File Names Interact With Comments Winmgmt.exe All the core and provider components and clients. Winmgmt is a service which runs throughout. This service should be started to get WMI inforamtion. Client first calls into Winmgmt to request for WMI info. Winmgmt then checks if there is any static data is present in the repository, if not, it will look for a provider for the specified request from client and get the information from the provider and return it to client. For more help lookinto SDK documentation : WMI Architecture overview. Mofcomp.exe Interacts with Winmgmt and .MOF files to compile mofs and creates repository database. Wbemcntl.exe Application to set security permission. Wbemtest.exe Interacts with Winmgmt Client application to test WMI. Unsecapp.exe CORE DLLs wbemcore.dll I don t know about each individual files here but these are all core component files and they communicate information between client, winmgmt, repository and providers. wbemess.dll wbemprox.dll wbemcomn.dll WinMgmtR.dll Wbemdisp.dll Wbemdisp.tlb fastprox.dll Wbemsvc.dll  Wbemmcp.dll  Wbemmsp.dll Mofd.dll PROVIDER DLLS cimwin32.dll  This is called by Winmgmt whenever Win32 provider data is requested from the client. Win32 provider. All providers interact with winmgmt when winmgmt requests for data provided by specific provider on behalf of client. cimw32ex.dll Cim32net.dll  Cim16net.dll Framedyn.dll This is used by win32 provider (cimwin32.dll). Actually it is a wrapper for common framework of win32 provider. Win32 provider framework Stdprov.dll Secrcw32.dll Security provider This is not used any more since this has been merged into cimwin32 provider. Ntevt.dll  Event provider Wmiprov.dll WMI provider Viewprov.dll View Provider Provthrd.dll  Dsprov.dll DS Provider Msiprov.dll MSI provider Ntevt.mof All MOF files actually contains the schema representation of the classes and data. These mof files are compiled by the mof compiler to build the repository. Cimwin32.mof Regevent.mof secrcw32.mof Custinst.mof wmi.mof Viewtest.mof Dsprov.mof  Msi.mof  MFL Files Cimwin32.mfl All MFL files are language dependent mof files. secrcw32.mfl Msi.mfl  Ntevt.mfl Clean Install Using In-The-Box W2K Install Files Being Installed By W2K For WBEM Installed File Name File Present in W2K Setup Files Installation Directory Comments Mofcomp.exe DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Unsecapp.exe DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Wbemcntl.exe DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Wbemperm.exe DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Wbemtest.exe DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Winmgmt.exe DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Cimw32ex.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Cimwin32.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Dsprov.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Fastprox.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Framedyn.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Mofd.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Msiprov.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Ntevt.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Secrcw32.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Stdprov.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Viewprov.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Wbemads.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Wbemcomn.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Wbemcore.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Wbemdisp.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Wbemess.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Wbemperf.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Wbemprox.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Wbemsvc.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Wbemupgd.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Winmgmtr.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Wmiprov.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF SYSSETUP.IN_ %SystemRoot%\System32\Wbem Cimwin32.mof DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Dsprov.mof DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Ntevt.mof DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Perfctrs.mof DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Perfdisk.mof DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Perfnet.mof DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Perfos.mof DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Perfproc.mof DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Regevent.mof DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Secrcw32.mof DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Wbemperf.mof DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Wmi.mof DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Wbemads.tlb DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Wbemdisp.tlb DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\System32\Wbem Wemuser.chm DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\Help Omc.chm DOSNET.INF LAYOUT.INF TXTSETUP.SIF %SystemRoot%\Help ScrCons.exe %SystemRoot%\System32\Wbem Files Being Installed By WBEMNT5.INF Installed File Name File Present in W2K Setup Files Installation Directory Comments provthrd.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF WBEMNT5.INF %SystemRoot%\System32\Wbem viewprov.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF WBEMNT5.INF %SystemRoot%\System32\Wbem dsprov.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF WBEMNT5.INF %SystemRoot%\System32\Wbem dsprov.mof DOSNET.INF LAYOUT.INF TXTSETUP.SIF WBEMNT5.INF %SystemRoot%\System32\Wbem msiprov.dll DOSNET.INF LAYOUT.INF TXTSETUP.SIF WBEMNT5.INF %SystemRoot%\System32\Wbem Files Being Removed By WBEMNT5.INF During Upgrade  File Names Comments cimom.exe hmom.exe cimommc.dll hmomess.dll server2.dll hmomcore.dll hmmcli.dll hmmsvc.dll hmmsvc.tlb Frahmmo.dll Hmmwin32.dll hmmdeftr.dll Hmmwin32.mof cimwin33.dll wbemuser.exe wbemstop.exe snmpcl.dll snmpthrd.dll ntperf.dll wbemclean.exe wbemdiag.exe Smidpmi.exe Cim16net.dll Cim32net.dll Wbemperm.exe Removed from M3. DCR# 47423 and 47548. Actions Performed by WBEMNT5.INF SECTIONS [DefaultInstall] Identifies the additional sections in the INF file that contain installation information for the component. Defines sections such as CopyFiles, DelFiles, AddReg and DelReg. 2.4.2 [DefaultInstall.Services] This section contains the name of the section which contains the Service related information. This section is executed using Setupapi.dll API InstallHInfSection which is called via Rundll32.exe. To run this API data is stored in RunOnce key in the registry which gets executed at the end of the inf execution or after the m/c reboots. In anycase this will be run only once. Service is set to Start Type Manual so that it won t hog up the cpu during W2K install. 2.4.3 [DestinationDirs] This section specifies the destination directory for the files listed in each section listed in CopyFiles and DelFile section under DefaultInstall section. 2.4.4 [Strings] This section defines the string variables which can be used elsewhere in the inf file. [WBEM.DelReg] This section lists the registry keys which needs to be deleted during install. [WBEM.AddReg] This section lists registry entries which needs to be created during install. Registry Keys installed during In-Box setup Registry Key Value Comments HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\WBEM1 rundll32.exe setupapi.dll,InstallHinfSection InstallService 132 %17%\wbemnt5.inf This entry is used to call setupapi.dll API InstallHinfSection  to install winmgmt service and the registry key  gets deleted after it is run once. HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\WBEM2 %11%\WBEM\WinMgmt.exe -regserver This entry is used to call regserver on winmgmt once and gets deleted after it has run once. HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\WBEM3 %11%\WBEM\unsecapp.exe -regserver This entry is used to call regserver on unsecapp.exe once and gets deleted after it has run once. HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\WBEM4 rundll32.exe %11%\WBEM\wbemupgd.dll,RUNDLLENTRY" This entry is used to invoke upgrade dll for building/upgrading repository. This entry gets deleted after upgrade dll is invoked once. HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\WBEM.REG1 regsvr32 /s %11%\WBEM\viewprov.dll This entry is used to call regserver on viewprov.dll once and gets deleted after it has run once. HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\WBEM.REG2 regsvr32 /s %11%\WBEM\dsprov.dll This entry is used to call regserver on dsprov.dll once and gets deleted after it has run once. HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\WBEM.REG3 regsvr32 /s %11%\WBEM\msiprov.dll This entry is used to call regserver on msiprov.dll once and gets deleted after it has run once. HKLM\SOFTWARE\Microsoft\WBEM\Build Current installed build HKLM\SOFTWARE\Microsoft\WBEM\ Installation Directory %SystemRoot%\System32\WBEM HKLM\SOFTWARE\Microsoft\WBEM\ MOF Self-Install Directory %SystemRoot%\System32\WBEM\MOF HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Starting Db Size 200000 HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ EnableEvents HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ TimeOutMs 20000 HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Repository Directory %SystemRoot%\System32\WBEM\Repository HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Working Directory %SystemRoot%\System32\WBEM HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Logging HKLM\System\CurrentControlSet\Services\EventLog\Application\WinMgmt\ EventMessageFile WinMgmtR.dll HKLM\System\CurrentControlSet\Services\EventLog\Application\WinMgmt\ TypesSupported HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents\WBEM\Installed HKCR\CLSID\{74864DA1-0630-11D0-A5B6-00AA00680C3F} Microsoft WBEM Server HKCR\CLSID\{74864DA1-0630-11D0-A5B6-00AA00680C3F}\AppId {74864DA1-0630-11D0-A5B6-00AA00680C3F} HKCR\CLSID\{74864DA1-0630-11D0-A5B6-00AA00680C3F}\LocalServer32 %SystemRoot%\System32\WBEM\winmgmt.exe HKCR\CLSID\{74864DA1-0630-11D0-A5B6-00AA00680C3F}\LocalServer32\ThreadingModel HKCR\AppId\{74864DA1-0630-11D0-A5B6-00AA00680C3F} winmgmt.exe HKCR\AppId\winmgmt.exe\AppId {74864DA1-0630-11D0-A5B6-00AA00680C3F} HKCR\CLSID\{74864DA1-0630-11D0-A5B6-00AA00680C3F}\LocalService WinMgmt HKCR\CLSID\{74864DA1-0630-11D0-A5B6-00AA00680C3F}\ThreadingModel HKCR\AppId\{74864DA1-0630-11D0-A5B6-00AA00680C3F} WinMgmt HKCR\AppId\WinMgmt\AppId {74864DA1-0630-11D0-A5B6-00AA00680C3F} HKCR\CLSID\{E07D3492-32B5-11D0-B724-00AA0062CBB7} Microsoft WBEM Mailslot transport HKCR\CLSID\{E07D3492-32B5-11D0-B724-00AA0062CBB7}\InprocServer32 %SystemRoot%\System32\WBEM\WBEMSTUB.DLL HKCR\CLSID\{E07D3492-32B5-11D0-B724-00AA0062CBB7}\InprocServer32\ThreadingModel HKCR\CLSID\ {A4845882-333F-11D0-B724-00AA0062CBB7} Microsoft WBEM Anonymous pipe transport HKCR\CLSID\ {A4845882-333F-11D0-B724-00AA0062CBB7} \InprocServer32 %SystemRoot%\System32\WBEM\WBEMSTUB.DLL HKCR\CLSID\ {A4845882-333F-11D0-B724-00AA0062CBB7} \InprocServer32\ ThreadingModel Clean Install Using In-The-Box Win98 Install Files Being Installed By W2K For WBEM Refer to MasterFileList under VSS $\Release Management\Planning Docs\Master File List.xls. Files Being Installed By WBEM.INF Installed File Name Installation Directory Comments MOFCOMP.EXE %SystemRoot%\System32\Wbem CIM16NET.DLL  %SystemRoot%\System32\Wbem CIM32NET.DLL %SystemRoot%\System32\Wbem CIMWIN32.MOF %SystemRoot%\System32\Wbem FASTPROX.dll %SystemRoot%\System32\Wbem FRAMEDYN.dll %SystemRoot%\System32\Wbem MOFD.DLL %SystemRoot%\System32\Wbem REGEVENT.MOF %SystemRoot%\System32\Wbem STDPROV.dll %SystemRoot%\System32\Wbem UNSECAPP.EXE %SystemRoot%\System32\Wbem WBEMCOMN.DLL %SystemRoot%\System32\Wbem WBEMCORE.dll %SystemRoot%\System32\Wbem WBEMDISP.DLL %SystemRoot%\System32\Wbem WBEMDISP.TLB %SystemRoot%\System32\Wbem WBEMESS.dll %SystemRoot%\System32\Wbem WBEMPROX.dll %SystemRoot%\System32\Wbem WBEMSVC.dll %SystemRoot%\System32\Wbem WBEMTEST.EXE %SystemRoot%\System32\Wbem WMI.MOF %SystemRoot%\System32\Wbem WMIPROV.dll %SystemRoot%\System32\Wbem CIMWin32.dll %SystemRoot%\System32\Wbem CIMW32ex.dll %SystemRoot%\System32\Wbem WinMgmtR.dll %SystemRoot%\System32\Wbem WinMgmt.exe %SystemRoot%\System32\Wbem Wbemcntl.exe %SystemRoot%\System32\Wbem Wbemperm.exe %SystemRoot%\System32\Wbem Removed from M3. DCR# 47423 and 47548. Wbemstop.exe %SystemRoot%\System32\Wbem wmimofck.exe %SystemRoot%\System32\Wbem wbemupgd.dll %SystemRoot%\System32\Wbem Files Being Removed By WBEM.INF During Upgrade  File Names Comments frahmmod.dll hmmcli.dll hmmdeftr.dll hmmsvc.dll hmmsvc.tlb hmmwin32.dll hmmwin32.mof hmom.exe hmomcore.dll hmomess.dll server2.dll Wbemcpl.dll Wbemstub.dll Wbemcpl.exe CIMOM.EXE Wbemuser.exe Wbemihlp.exe Wbemperm.exe Removed from M3. DCR# 47423 and 47548. Registry Keys installed during In-Box setup Registry Key Value Comments HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents\WBEM Root key These keys are created for W98 setup to detect whether wbem is already installed or not since it is an optional component on W98. By default during the clean install option to install wbem is unchecked. HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents\WBEM\INF Wbem.inf Specifies the name of the inf which needs to be executed when wbem is checked to install. HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents\WBEM\Section Specifies the name of the section in the inf which needs to be executed while wbem option is checked to install wbem. HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents\WBEM\Installed By default this is set to 0 which unchecks the option to install wbem and W98 will assume that wbem is not installed. When user checks an option to install WBEM, this key is set to 1 during installation. HKLM\SOFTWARE\Microsoft\WBEM\ Installation Directory %SystemRoot%\System32\WBEM HKLM\SOFTWARE\Microsoft\WBEM\Build Current installed build HKLM\SOFTWARE\Microsoft\WBEM\ MOF Self-Install Directory %SystemRoot%\System32\WBEM\MOF HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Autorecover MOFs (empty) HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ EnableEvents HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ EnableDefaultRemoting HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Grow Db By 81920 HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Max Db Size HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Starting Db Size 245760 HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Logging HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ TimeOutMs 20000 HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Repository Directory %SystemRoot%\System32\WBEM\Repository HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\ Working Directory %SystemRoot%\System32\WBEM HKCR\CLSID\{74864DA1-0630-11D0-A5B6-00AA00680C3F} Microsoft WBEM Server HKCR\CLSID\{74864DA1-0630-11D0-A5B6-00AA00680C3F}\AppId {74864DA1-0630-11D0-A5B6-00AA00680C3F} HKCR\CLSID\ {d63a5850-8f16-11cf-9f47-00aa00bf345c} Microsoft WBEM Managed Object Provider HKCR\CLSID\ {d63a5850-8f16-11cf-9f47-00aa00bf345c}\InprocServer32 CIMWIN32.dll HKCR\CLSID\ {d63a5850-8f16-11cf-9f47-00aa00bf345c}\ InprocServer32\ThreadingModel HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ RegUNSECAPP %11%\WBEM\UNSECAPP.EXE /regserver This entry is used to call regserver on UNSECAPP.EXE once and gets deleted after it has run once. HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ Regwinmgmt %11%\WBEM\WinMgmt.exe  regserver This entry is used to call regserver on winmgmt once and gets deleted after it has run once. HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ RegFASTPROX %11%\regsvr32 /s %11%\WBEM\fastprox.dll Register fastprox.dll HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ RegWMIPROV %11%\regsvr32 /s %11%\WBEM\wmiprov.dll Register wmiprov.dll HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ RegSTDPROV %11%\regsvr32 /s %11%\WBEM\stdprov.dll Register stdprov.dll HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ RegWBEMCORE %11%\regsvr32 /s %11%\WBEM\WBEMcore.dll Register wbemcore.dll HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ RegWBEMDISP %11%\regsvr32 /s %11%\WBEM\WBEMDISP.dll Register wbemdisp.dll HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ RegWBEMESS %11%\regsvr32 /s %11%\WBEM\WBEMESS.dll Register wbemess.dll HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ RegWBEMPROX %11%\regsvr32 /s %11%\WBEM\WBEMPROX.dll Register wbemprox.dll HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ RegWBEMSVC %11%\regsvr32 /s %11%\WBEM\WBEMSVC.dll Register wbemsvc.dll HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ RegCIMWIN32 %11%\regsvr32 /s %11%\WBEM\CIMWIN32.dll Register cimwin32.dll HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ RegCIMW32EX %11%\regsvr32 /s %11%\WBEM\CIMW32EX.dll Register cimwin32ex.dll HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ RegWinMgmtr %11%\regsvr32 /s %11%\WBEM\WinMgmtr.dll Register winmgmtr.dll HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ RegWBEMComn %11%\regsvr32 /s %11%\WBEM\wbemcomn.dll Register wbemcomn.dll HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ Regmofd %11%\regsvr32 /s %11%\WBEM\mofd.dll Register mofd.dll HKLM\oftware\Microsoft\Windows\CurrentVersion\RunOnce\ WBEMUpgd rundll32.exe %11%\WBEM\wbemupgd.dll,RUNDLLENTRY Call upgrade dll API to build\upgrade repository. Registry Keys uninstalled (deleted) during In-Box setup (In case of upgrades) Registry Key Comments HKLM\SOFTWARE\Microsoft\Wbem\Cimom\ Database Directory HKLM\SOFTWARE\Microsoft\Wbem\Cimom\ LocalProtocolPref HKLM\SOFTWARE\Microsoft\Wbem\Cimom\ RemoteProtocolPref Registry Keys uninstalled (deleted) during WBEM uninstall (during Uninstalling WBEM) Registry Key Comments HKLM\SOFTWARE\Microsoft\Wbem Root and all subkeys under this root HKCR\AppId\Cimom.exe HKCR\APPId\ {74864DA1-0630-11D0-A5B6-00AA00680C3F} HKCR\CLSID\{74864DA1-0630-11D0-A5B6-00AA00680C3F} HKCR\CLSID\{d63a5850-8f16-11cf-9f47-00aa00bf345c} Actions Performed by WBEM.INF SECTIONS [DefaultInstall] Identifies the additional sections in the INF file that contain installation information for the component. Defines sections such as CopyFiles, DelFiles, AddReg and DelReg. In Wbem.inf  DefaultInstall  section essentially copies wbem.inf to the system and adds the registry for optional component install. This is because WBEM is an optional component on W98 and therefore the actual setup will run based on this registry key setting. This section also deletes obsolate files if present incase of upgrades. [Optional Components]  This section actually lists the section which needs to be executed when user selects option to install WBEM. In this case the section name to be executed is WBEM. [WBEM] This section actually does all the WBEM installation part. It is similar to  DefaultInstall  section and specifies sub sections such as CopyFiles, AddReg, DelReg, DelFiles, Uninstall etc. So the files under CopyFiles sub sections get copied during install and under DelFiles sub sections gets deleted during install. Also the registry entries under    AddReg  sections gets added and  DelReg  sections gets deleted.  Uninstall sections specifies files and registry keys which needs to be uninstalled while uninstalling WBEM through control panel Add\Remove program. 3.7.4 [DestinationDirs] This section specifies the destination directory for the files listed in each section listed in CopyFiles and DelFile section under DefaultInstall section. 3.7.5 [Strings] This section defines the string variables which can be used elsewhere in the inf file. 3.7.6      [WBEM.DelReg] This section lists the registry keys which needs to be deleted during install. 3.7.7     [WBEM.AddReg] This section lists registry entries which needs to be created during install. Important Win98 Setup Issues and Design. 3.8.1 Win98 clean Install Win98 Gold will install WBEM build 450 and Win98 OSR will install WBEM build 698 on a clean system. 3.8.2 Win98 - WBEM Optional Install WBEM is an optional install on Win98 and threfore on a clean system the option to install WBEM is unchecked by default. User can select (check) option to install WBEM. While upgrading Win98 with preexisting WBEM, the system will upgrade WBEM automatically if required. There is a issue here, look below section 3.8.4. 3.8. 3 Win98 - Upgrade If you upgrade Win98 Gold to Win98 OSR with WBEM already existing on the system then WBEM will also upgrdae from 450 to 698. 3.8. 4 Win98 Gold   Upgrade WBEM using WBEMCORE.EXE   Upgrade to Win98 OSR. If you install Win98 gold with option to install WBEM then WBEM build 450 is installed on the system and the registry entry under OptionalComponent is set to 1 to indicate that wbem is installed. Now if you upgrade to another heigher wbem build using Wbemcore.exe then the wbem build will be upgraded to that and the registry entry under  OptinalComponent  is reset to 0. This was reset to 0 because user has an option to uninstall WBEM on Win98 using controlpanel and if user upgrades to heigher wbem over 450 then while uninstalling he might actually uninstall this heigher version thinking that he is uninstalling wbem 450 and moreover we don t support uninstall with wbemcore.exe. Therefore reseting this value will make Win98 Os feel that WBEM is not installed and therefore no uninstall option in the control panel. Now if user upgrdes to Win98 OSR, the Win98 OSR setup will check this registry to see if WBEM is installed and whether it needs to be upgraded. Since the value was reset by wbemcore, win98 OSR setup will assume that wbem was not installed on the system and therefore while upgrading to OSR, it will not try to install WBEM  698. But after installing OSR, user can go to control panel and select option to install WBEM again which will actually upgrade to WBEM 698.  3.8.5  Win98 Setup checking For Buid > 450 While installing WBEM in-box with Win98, it will check if the existing version of WBEM is > 450 and if so then it will not install 450 (which will otherwise be called downgrading). This value 450 is hardcoded in win98 setup setupx.dll and therefore even with Win98 OSR which installs WBEM 698, during upgrades the Win98 setup checks for > 450 instead of > 698. This causes problem in the scenario listed in section 3.8.4. That is when you install Win98 gold with WBEM ,it installs WBEM 450. Now you upgrade wbem to say 575 using wbemcore.exe. Now you upgrade Win98 gold to Win98 OSR. System will not automatically upgrade wbem due to problem mentioned in section 3.8.4. Now go to control panel and check option to install WBEM, Win98 setup will say you already have newer version of wbem and it won t allow you to upgrade though you have wbem 575 and trying to upgrade to wbem 698 which is part of OSR. This is because win98 osr setup is still checking for wbem build > 450 and since 575 is > 450 it will pop up a message and will not let upgrade. Various Upgrade Scenarios Wbemcore.exe To Wbemcore.exe 3.1.1) Upgrade of Wbem core is not allowed using Wbemcore.exe if  the existing version of  Wbem core is greater than one being currently installed. 3.1.2) Upgrade of Wbem core from M1 to M2 will remove SDK if it exists on the system otherwise it won t install. 3.1.3) Upgrade of Wbemcore will remove SDK if try to install M2 and SDK version is older than build 700. Wbemcore.exe To In-The-Box W2K 3.2.1) While upgrading a system which has Wbem core installed using wbemcore.exe to W2K, it does not check for the existing Core version but all files individually are checked to see if the higher version is already installed and if so then they won t be replaced. There is a issue here and few files are getting downgraded (Look into issue section). 3.2.2) In-The-Box will upgrade to the version which comes with W2K install if the existing version is less than the embedded version. In-The-Box To In-The-Box W2K 3.2.3) There should not be any problems in upgrading W2K box as long as the newer version of W2K installs newer version of Wbem. Win9x In-the-Box W2K 3.4.1) Upgrading Win9x box containing wbem to W2K should first migrate Wbem from system directory to system32 directory and then the upgrade will be done based on the versions of all the files which gets copied during wbem installation. Also the path c:\windows\system\wbem should be migrated to c:\windows\system32\wbem. Though this is not happening now (look into issues section). Common Known Issues Downgrading WBEM Problem FASTPROX.DLL, WMIPROV.DLL and MOFCOMP.EXE exists in the DELETE list of W2K before the system is upgraded. Therefore these files gets deleted and installed again during Wbem installation of W2K as if they did not exists before. Therefore if the lower version is tried to install over existing higher version, no other files change except these three files. PROBLEM: This is causing the downgrade problem where if you have say higher version of Wbem (841) installed on W2K and now if you upgrade W2K (which officially installs 688), it will try to install 688 and all other files will not be replaced because the higher (841) version already exists but above 3 files gets installed with older version (688) becasue these files were deleted before the actual upgraded started. And due to this 3 files getting downgraded,  WinMgmt will fail to initialize becasue it uses FASTPROX.DLL and lots of other hidden errors. SOLUTION : The above mentioned files should be removed from DELETE list before upgrade process starts in W2K. Wbemcore.exe asking to RESTART Wbemcore.exe uses SMS Installer scripts for installation program and SMS Installer sets RESTART flag automatically whenever it finds it necessary. Therefore SMS Installer asks for restarting system automatically. Inconsistency Between Wbemcore.exe and In-The-Box W2K Install Wbemcore.exe is not suppose to be used to install Wbem core on W2K since W2K comes with Wbem core in-the-box. Therefore some files which needs to  be installed only on W2K might be present in the in-the-box installation but they might not be there in wbemcore.exe. If such files are there in Wbemcore.exe then they are just to help testing and it should not have any effect on NT4. Upgrading From Win9x to In-The-Box W2K The Windows\System\Wbem directory does not get migrated to Windows\System32\Wbem and therefore two Wbem directories exists after Win9x system is upgraded to W2K. This needs to be fixed by W2K team. Also the path C:\Windows\System\Wbem needs to be migrated to C:\Windows\System32\Wbem. Platform Specific Issues Miscellaneous  Adding Files To W2K 6.1.1) File a bug to request the addition of a file to W2K. This will probably require a bunch of justification. W2K release manager will have to approve this. 6.1.2) Get the bug approved. 6.1.3) Build team checks the file into W2K SLM tree, updates the W2K makefile (actually called SOURCES and BINPLACE.TXT) and adds a line in the W2K PLACEFIL.TXT file. The placefil.txt is used to make the files distribute out to \\ntbuilds\release.  4) Wait a day for the file to start distributing (to \\ntbuilds) 5) Request, from the W2K setup team, the addition of the file to setup. They will update the LAYOUT.INX file (this means that the file will get copied down when you begin your W2K setup, but not installed. Remember, W2K setup copies all of those files to a temp directory before it installs?). They will also either update their text mode setup (this actually installs the file) OR we will checkin our INF (this actually installs the file). At this time, we will need to give the setup team all the info about the files getting installed. This includes filename, size, justification, test pass verification, raid #, directory name it installs to, registry change info, platform type, etc. Everything described on the http://ntbld web page.  Text Mode Setup vs INF Mode SETUP Files can be copied in 2 ways :- 6.2.1) Textmode setup - The file will have the last 2 attribute in layout.inf as 0,0. This means that we move(for space efficiency) the file dur ing textmode setup from $win_nt$.~ls\i386 to the directory specified. 6.2.2) INF file - GUI mode runs the inf which uses setupapi to try and copy the file from $win_nt$.~ls\i386 to the location specified in the inf (DESTINATION_DIR). SDK Setup Files  Installation Source Files Sl. No EXE Name Install Script File Name Include File Name Purpose Comments Wmisdk.exe Files Being Installed Installed By Installed File Name Installation Directory Comments WBEMSETUP.DLL Copied to temp directory and deleted after install completes. This is a Helper dll. C:\Temp\ WBEMUPGD.DLL Copied to temp directory and deleted after install completes. This is a Helper dll. C:\Temp\ Msvcrt.dll %SystemRoot%\System32 (Windows system directory) Msvcirt.dll %SystemRoot%\System32 (Windows system directory) Mfc42.dll %SystemRoot%\System32 (Windows system directory) Mfc42u.dll %SystemRoot%\System32 (Windows system directory) Psapi.dll %SystemRoot%\System32 (Windows system directory) Ctl3d32.dll %SystemRoot%\System32 (Windows system directory) Agreement.txt %SDKDIR% Redist.txt Readme.htm Schema.txt Uninst32.exe Cimwin32.mof Secrcw32.mof Wbemtool.cab Wbemeventviewer.exe Eviewer.mof Studiotitle.gif Viewbanner.gif Browser.htm Classnav.htm Editor.htm Instnav.htm Studio.htm Studiobanner.htm Viewer.htm Viewerbanner.htm Eventregctl.htm Eventbanner.htm Eventreg.htm Eventbanner.gif Wbemcli.idl Wbemdisp.h Wbemdisp.idl Wbemidl.h Wbemprov.idl Wbemtran.idl Assertbreak.h Chptrarr.h Chstrarr.h Chstring.h Frquery.h Fwcommon.h Genlex.h Instance.h Methodcontext.h Objpath.h Opathlex.h Polarity.h Provider.h Refptrcollection.h Sql_1.h Stllock.h Threadbase.h Utillib.h Wbemglue.h Wbemtime.h Wbemtypes.h Wbemprov.h Wbemcli.h Wbemtran.h Wbemads.h Wbemads.idl Framedyn.lib Wbemuuid.lib Framedyd.lib Framedyd.dll Wbemdump.exe Vcsamples.htm Utillib sample Makefile Utillib.h Utils.cpp Wbemsec.h Wbemsec.cpp Utillib.htm Utillib.dsp Wbemdump sample Makefile Wbemdump.cpp Wbemdump.h Wbemdump.htm Wbemdump.dsp Wbemdump.dsw Instprov sample Classfac.cpp Instprov.cpp Instprov.def Maindll.cpp Makefile Instprov.htm Sample.h Utils.cpp Instprov.mof Instprov.dsp Client Sample Makefile Officedlg.cpp Officedlg.h Onaddequipment.cpp Onasync.cpp Onasync.h Onconnect.cpp Ondiskdetails.cpp Onenumdisks.cpp Onenumsvcs.cpp Onperm.cpp Onregister.cpp Ontemp.cpp Client.htm Resource.h Stdafx.cpp Stdafx.h Userinfo.cpp Userinfo.h Wbemsamp.cpp Wbemsamp.h Wbemsampdlg.cpp Wbemsampdlg.h Wbemsample.rc Ontemp.h Wbemsample.dsp Event Consumer sample Consumer.cpp Consumer.h Factory.cpp Factory.h Makefile Eventconsumer.htm Resource.h Stdafx.cpp Stdafx.h Wbempermevents.cpp Wbempermevents.h Wbempermevents.rc Wbempermeventsdlg.cpp Wbempermeventsdlg.h Sampleviewer.mof Provider.h Provider.cpp Wbempermevents.dsp Ping sample Main.cpp Makefile Pingwbem.htm Pingwbem.dsp Event provider sample Makefile Evprov.cpp Evprov.h Evprov.def Evprov.mof Oahelp.inl Olesrvr.cpp Evprov-alpha.def Eventprovider.htm Eventprovider.dsp Temporary Consumer sample Makefile Consumer.cpp Oahelp.inl Tempconsumer.htm Tempconsumer.dsp Methods provider sample Classfac.cpp Maindll.cpp Makefile Methprov.cpp Methprov.def Methprov.h Methprov.mof Methprov.htm Methodprov.dsp Cmdline consumer sample Cmdline.mof Consumer.cpp Consumer.h Provider.h Provider.cpp Factory.cpp Factory.h Makefile Cmdlineconsumer.htm Resource.h Stdafx.cpp Stdafx.h Cmdlineconsumer.cpp Cmdlineconsumer.h Cmdlineconsumerdlg.cpp Cmdlineconsumerdlg.h Cmdlineconsumer.ico Cmdlineconsumer.rc2 Cmdlineconsumer.dsp Reindeer sample Reindeerprov.mof Reindeerprov.cpp Reindeerprov.def Makefile Reindeerprov.h Maindll.cpp Frameworkprov.htm Reindeerprov.dsp Propprov sample Classfac.cpp Propprov.cpp Maindll.cpp Makefile Propprov.htm Propprov.def Sample.h Propprov.mof Propprov.dsp ObjPathParser sample Genlex.cpp Genlex.h Makefile Objpath.cpp Objpath.h Opathlex.cpp Opathlex.h Pathtest.cpp Objpathparser.htm Objpathparser.dsp CustomViews sample Bar.cpp Bar.h Barchart.cpp Barchart.h Coloredit.cpp Coloredit.h Customview.mof Diskview.cpp Diskview.h Makefile CustomViews.htm Resource.h Stdafx.cpp Stdafx.h Win32logicaldisk.cpp Win32logicaldisk.h Win32logicaldisk.def Win32logicaldisk.ico Win32logicaldisk.rc Win32logicaldiskctl.cpp Win32logicaldiskctl.h Win32logicaldiskppg.cpp Win32logicaldiskppg.h Win32logicaldiskctl.bmp Win32logicaldisk.odl Win32logicaldisk.dsp MethCli Methcli.cpp Methcli.htm Makefile Methcli.dsp Simple Client Makefile Simpleclient.cpp Resource.h Stdafx.cpp Stdafx.h Wbemclient.cpp Wbemclient.h Wbemclient.rc Wbemclientdlg.cpp Wbemclientdlg.h Wbemclient.ico Wbemclient.rc2 Readme.txt Jsdiskinfo.asp Vbsdiskinfo.asp Ajsservice1.htm Jsservice1.htm Jsservice2.htm Avbsservice1.htm Vbsservice1.htm Vbsservice2.htm Vbsclassbrowser.htm Installed different versions based on whether IIS is installed on the system or not. Readme.txt Installed only if IIS is not installed on the system. Readme.txt Vblogdisk.vbp Form1.frm vbprocess.vbp Form1.frm Vbservice.vbp Form1.frm Vbinstance.vbp Form1.frm Form1.frx Arraytype.js Classenum.js Derivation.js Embprop.js Emptyarray.js Execmethod.js Instenum.js Methodex.js Methodset.js Nvs.js Nvs2.js Nvsarray.js Objpath.js Process.js Proparray.js Properties.js Property.js Putinstance.js Qualarray.js Qualifier.js System.js Cimomid.vbs Derivation.vbs Emptyarray.vbs Errmsg.vbs Methodex.vbs Netevent.vbs Nvsarray.vbs Objset.vbs Pathbuiild.vbs Privilege.vbs Process.vbs Resettodefault.vbs Schema.vbs Servicestopped.vbs Spawn.vbs Service.vbs System.vbs Wbemsdk.chm Wbemsdk.chi Hhupd.exe Is installed in temp directory to execute and deleted before the install completes. Snmp\mibs\snmpv1\rfcs\*.* snmp\mofs\snmpv1\rfcs\*.* snmp\smir_mofs\snmpv1\rfcs\*.* $`'0* 2p5@8 CPF I Q`T0W
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\misc\license\wmieula.txt ===
SUPPLEMENTAL END USER LICENSE AGREEMENT FOR MICROSOFT SOFTWARE

IMPORTANT:  READ CAREFULLY - This Microsoft Corporation ("Microsoft") operating system component, including any "online" or electronic documentation ("OS Component") is subject to the terms and conditions of the agreement under which you have licensed Microsoft Windows 95, Microsoft Windows 98, Microsoft Windows NT Workstation 4.0, Microsoft Windows NT Server 4.0,  Microsoft Windows NT Server, Enterprise Edition 4.0, or Microsoft Windows NT Server 4.0, Terminal Server Edition (each an "End User License Agreement" or "EULA") and the terms and conditions of this Supplemental EULA.  BY INSTALLING, COPYING OR OTHERWISE USING THE OS COMPONENT, YOU AGREE TO BE BOUND BY THE TERMS AND CONDITIONS OF THE APPLICABLE EULA AND THIS SUPPLEMENTAL EULA.  IF YOU DO NOT AGREE TO THESE TERMS AND CONDITIONS, DO NOT INSTALL, COPY OR USE THE OS COMPONENT.

NOTE:  IF YOU DO NOT HAVE A VALIDLY LICENSED COPY OF MICROSOFT WINDOWS 95, MICROSOFT WINDOWS 98, MICROSOFT WINDOWS NT WORKSTATION 4.0, MICROSOFT WINDOWS NT SERVER 4.0, MICROSOFT WINDOWS NT SERVER, ENTERPRISE EDITION 4.0 OR MICROSOFT WINDOWS NT SERVER 4.0, TERMINAL SERVER EDITION (each a "Software Product"), YOU ARE NOT AUTHORIZED TO INSTALL, COPY OR OTHERWISE USE THE OS COMPONENT AND YOU HAVE NO RIGHTS UNDER THIS SUPPLEMENTAL EULA.

Capitalized terms used in this Supplemental EULA and not otherwise defined herein shall have the meanings assigned to them in the EULA.

General.  The OS Component is provided to you by Microsoft to update, supplement, or replace existing functionality of the applicable Software Product.  Microsoft grants you a license to use the OS Component under the terms and conditions of the applicable EULA (which are hereby incorporated by reference) and the terms and conditions set forth in this Supplemental EULA, provided that you comply with all such terms and conditions.  If the applicable Software Product is Microsoft Windows NT Server 4.0,  Microsoft Windows NT Server, Enterprise Edition 4.0, or Microsoft Windows NT Server 4.0, Terminal Server Edition then the OS Component shall be deemed to be "Server Software" under the applicable EULA.  To the extent that any terms in this Supplemental EULA conflict with terms in the applicable EULA, the terms of this Supplemental EULA control solely with respect to the OS Component.

Additional Rights and Limitations.  

*	For each validly licensed copy of the applicable Software Product, you also may reproduce one additional copy of the OS Component solely for archival purposes or reinstallation of the OS Component on the same computer(s) as the OS Component was previously installed.  Microsoft retains all right, title and interest in and to the OS Component.  All rights not expressly granted are reserved by Microsoft.

IF THE APPLICABLE SOFTWARE PRODUCT WAS LICENSED TO YOU BY MICROSOFT OR ANY OF ITS WHOLLY OWNED SUBSIDIARIES, THE LIMITED WARRANTY (IF ANY) INCLUDED IN THE EULA FOR THE APPLICABLE SOFTWARE PRODUCT APPLIES TO THE OS COMPONENT PROVIDED THE OS COMPONENT HAS BEEN LICENSED BY YOU WITHIN THE TERM OF THE LIMITED WARRANTY IN SUCH EULA.  HOWEVER, THIS SUPPLEMENTAL EULA DOES NOT EXTEND THE TIME PERIOD FOR WHICH THE LIMITED WARRANTY IS PROVIDED.

IF THE APPLICABLE SOFTWARE PRODUCT WAS LICENSED TO YOU BY AN ENTITY OTHER THAN MICROSOFT OR ANY OF ITS WHOLLY OWNED SUBSIDIARIES, MICROSOFT DISCLAIMS ALL WARRANTIES WITH RESPECT TO THE OS COMPONENT AS FOLLOWS:

DISCLAIMER OF  WARRANTIES.  TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, MICROSOFT AND ITS SUPPLIERS PROVIDE TO YOU THE OS COMPONENT, AND ANY (IF ANY) SUPPORT SERVICES RELATED TO THE OS COMPONENT ("SUPPORT SERVICES") AS IS AND WITH ALL FAULTS; AND MICROSOFT AND ITS SUPPLIERS HEREBY DISCLAIM WITH RESPECT TO THE OS COMPONENT AND SUPPORT SERVICES ALL WARRANTIES AND CONDITIONS, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, ANY (IF ANY) WARRANTIES OR CONDITIONS OF OR RELATED TO:  TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS OF RESPONSES, RESULTS, LACK OF NEGLIGENCE OR LACK OF WORKMANLIKE EFFORT, QUIET ENJOYMENT, QUIET POSSESSION, AND CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE OS COMPONENT AND ANY SUPPORT SERVICES REMAINS WITH YOU.

EXCLUSION OF INCIDENTAL, CONSEQUENTIAL AND CERTAIN OTHER DAMAGES.  TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL MICROSOFT OR ITS SUPPLIERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, BUT NOT LIMITED TO, DAMAGES FOR:  LOSS OF PROFITS, LOSS OF CONFIDENTIAL OR OTHER INFORMATION, BUSINESS INTERRUPTION, PERSONAL INJURY, LOSS OF PRIVACY, FAILURE TO MEET ANY DUTY (INCLUDING OF GOOD FAITH OR OF REASONABLE CARE), NEGLIGENCE, AND ANY OTHER PECUNIARY OR OTHER LOSS WHATSOEVER) ARISING OUT OF OR IN ANY WAY RELATED TO THE USE OF OR INABILITY TO USE THE OS COMPONENT OR THE SUPPORT SERVICES, OR THE PROVISION OF OR FAILURE TO PROVIDE SUPPORT SERVICES, OR OTHERWISE UNDER OR IN CONNECTION WITH ANY PROVISION OF THIS SUPPLEMENTAL EULA, EVEN IN THE EVENT OF THE FAULT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY, BREACH OF CONTRACT OR BREACH OF WARRANTY OF MICROSOFT OR ANY SUPPLIER, AND EVEN IF MICROSOFT OR ANY SUPPLIER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 

LIMITATION OF LIABILITY AND REMEDIES. NOTWITHSTANDING ANY DAMAGES THAT YOU MIGHT INCUR FOR ANY REASON WHATSOEVER (INCLUDING, WITHOUT LIMITATION, ALL DAMAGES REFERENCED ABOVE AND ALL DIRECT OR GENERAL DAMAGES), THE ENTIRE LIABILITY OF MICROSOFT AND ANY OF ITS SUPPLIERS UNDER ANY PROVISION OF THIS SUPPLEMENTAL EULA AND YOUR EXCLUSIVE REMEDY FOR ALL OF THE FOREGOING SHALL BE LIMITED TO THE GREATER OF THE AMOUNT ACTUALLY PAID BY YOU FOR THE OS COMPONENT OR U.S.$5.00.  THE FOREGOING LIMITATIONS, EXCLUSIONS AND DISCLAIMERS SHALL APPLY TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, EVEN IF ANY REMEDY FAILS ITS ESSENTIAL PURPOSE.

WBEM_Core_Addendum[Final].doc
4/22/99
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\misc\docs\wmi setup instructions doc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft WMI Setup Instructions Doc Title _PID_HLINKSWMI Setup Instructions Doc a-bakulg Normal a-bakulg Microsoft Word 9.0bjbjU WMI Setup Instructions Doc Setup File Location In VSS All the setup source files are located under $/Wbem 1.1 M3/Wbemsetup\. HTML Help : This folder contains the hhupd.exe which is used to install/update html help during wmi sdk installation. In-The-Box : This folder contains the NT drop instruction for in-the-box setup but this is very old document and have not been updated since long. Inf : This folder contains the inf files for in-the-box installation. Wbem.inf is used for win98 and win98 millennium and wbemnt5.inf is used for W2K. Utils : This folder contains the dlls used during setup process. Currently only wbemsetup.dll and wbemupgd.dll are used. Wbemsetup.dll provides all the functionality which is not provided by the sms installer and things specific to WMI. Wbemupgd.dll provides facility for mof compilation and repository building/upgrading. Docs : This folder has this doc and the setup spec doc. Pdf : This folder has the pdf files which were being used by sms installation of wmi. I don t think they are being used now and sms setup has their pdfs in their setup tree. Redist : Tjis folder has the files which are redistributed/installed during wmi setup which are not owned by wmi. Scripts : This folder consists of the sms installer scripts (.ipf) files and other dependent files which are needed for compiling and bundling the sms installer generated exe. Current folder has the link to all the files which are being used currently for different setups, namely, core, sdk, snmp and odbc. All the files which are linked are present in Common folder and its sub folder. License : This folder has the EULA for core and sdk. ODBC : I think this is a test project and not used any more. Each Setup and Files Involved Core Setups : Common Setup Files and their purpose  Wbem_loc.ini This file has all the strings which are used to display messages to the user. Only this file needs to be localized for localizing WMI. Langstr.ipf This ipf file loads the strings defined in wbem_loc.ini Wmicomnchk.ipf This file does the common checks which are to be done for core installation irrespective of the platform such as build numbers, wmi version etc. Wmipreinst.ipf This is used to do some common checks before the actual file installation starts. Wmicomndel.ipf This file is used to delete the old files in case of upgrades. Wmicomnreg.ipf This file is used to create registry for wmi. Wmipostinst.ipf This is used to do final clean up and mof compilation etc. after all the files are installed. Wmiwiz.ipf This file has all the UI wizard dialogs displayed during the installation. Cancel.ipf This file is used to clean up the installation and temporary directory/files created during installation if the user cancels the setup process in between without completing it. Exit.ipf This is used to do the final clean up of temporary dir/files etc. after the setup has completed or if the setup exited due to some reason. WMINT4.EXE Wmicorent4.ipf Main ipf file for wmint4.exe. Includes langstr.ipf, wmicomnchk.ipf and wmimainnt4.ipf. Wmimainnt4.ipf Does nt4 specific checks and includes wmiwiz.ipf, wmipreinst.ipf, wmicomndel.ipf, corent4.ipf and wmipostinst.ipf. Corent4.ipf This file actually installs all the wmi files and includes wmicomnreg.ipf. WMI9X.EXE Wmicore9x.ipf Main ipf file for wmi9x.exe. Includes langstr.ipf, wmicomnchk.ipf and wmimain9x.ipf. Wmimain9x.ipf Does Win9x specific checks and includes wmiwiz.ipf, wmipreinst.ipf, wmicomndel.ipf, core9x.ipf and wmipostinst.ipf. Core9x.ipf This file actually installs all the wmi files and includes wmicomnreg.ipf. WMICORE.EXE Wmicore9xnt4.ipf Main ipf file for wmicore.exe. Includes langstr.ipf, wmicomnchk.ipf and based on platform it includes wmimainnt4.ipf or wmimain9x.ipf. INTWMI.EXE Wmicoreall.ipf Main ipf file for intwmi.exe. Includes langstr.ipf, wmicomnchk.ipf and based on platform it includes wmimainnt4.ipf or wmimain9x.ipf or wmimainw2k.ipf.  In-The-Box Setups : Windows 2000 In-The-Box Wbemnt5.inf file has various sections which gets executed during w2k install in a particular order. Wbemnt5.inf file is executed during GUI mode setup of w2k install after copying all the wbem files to %SystemRoot%\wbem by dos mode setup. Wbemnt5.inf file deletes obsolete files and registry in case of upgrades and installs service and other registry for wmi. It also installs and registers some file for unknown reasons where as all other files are installed and registered by w2k setup. Wbemnt5.inf file then puts an entry into RUNONCE registry key to run wbemupgd.dll and compile all the mofs and build the repository. [DefaultInstall] Identifies the additional sections in the INF file that contain installation information for the component. Defines sections such as CopyFiles, DelFiles, AddReg and DelReg. [DefaultInstall.Services] This section contains the name of the section which contains the Service related information. This section is executed using Setupapi.dll API InstallHInfSection which is called via Rundll32.exe. To run this API data is stored in RunOnce key in the registry which gets executed at the end of the inf execution or after the m/c reboots. In anycase this will be run only once. Service is set to Start Type Manual so that it won t hog up the cpu during W2K install. [DestinationDirs] This section specifies the destination directory for the files listed in each section listed in CopyFiles and DelFile section under DefaultInstall section. [Strings] This section defines the string variables which can be used elsewhere in the inf file. [WBEM.DelReg] This section lists the registry keys which needs to be deleted during install. [WBEM.AddReg] This section lists registry entries which needs to be created during install. Windows 98 Millennium In-The-Box Wbem.inf file is used for Win98 Millennium in-the-box install. Procedure is pretty much same as w2k in-the-box install except that we install and register all the wmi files through wbem.inf unlike w2k setup where w2k setup installs and registers most of the wmi files. WMI SDK Setup : Setup Files and their purpose  Wbemsdk.ipf This is the main ipf file which starts the process of bundling installation files into an exe. Cppsamples.ipf This ipf installs the C++  samples if the user selects them. Called from wbemssdk.ipf. Vbsamples.ipf This ipf file installs the VB script samples if user selects them. Called from wbemssdk.ipf. Ui.ipf This file installs all the UI applications and htmls if the user selects to install them. Called from wbemssdk.ipf. Called from wbemssdk.ipf. Help.ipf This file installs the help files for sdk. Sdkdepnd.ipf Does the version checking and other checks can be added here. Called from wbemssdk.ipf. More Information can be found about Authoring INF files at   HYPERLINK "http://aicgweb/iexpress/old/guide.htm"  http://aicgweb/iexpress/old/guide.htm Miscellaneous  SMS Installer can be installed from   HYPERLINK "\\\\mermaid\\builds\\enu\\sms installer\\2_0\\"  \\mermaid\builds\enu\sms installer\2_0\ Build tree is copied daily shared to   HYPERLINK "\\\\smsx863\\NovaM3Root2\\Dist.Latest"  \\smsx863\NovaM3Root2\Dist.Latest  with the latest build released. File list can be found at $/Release Management/Planning Docs/WMI SDK FILE LIST.xls under VSS for all the setups and platforms.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\whistler wmi bvt.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Unassigned Microsoft Unassigned Title Version Distribution Component Feature Product Product Version Project Status Internal Unassigned Unassigned Quasar Quasar DraftUnassigned Jenny McCollum WBEM Specification Jenny McCollum Microsoft Word 9.0&v6_</l WDMHiPerf jennymc jennymcbjbjU The  Whistler BVT Spec Title The Whistler BVT   Build Verification Test Version  DOCPROPERTY "Version"  \* MERGEFORMAT  Distribution  FORMDROPDOWN  Component Feature area Feature scope Product  DOCPROPERTY "Product"  \* MERGEFORMAT  Product Version Whistler  DOCPROPERTY "Product Version"  \* MERGEFORMAT  Project Whistler Author  AUTHOR \* FirstCap \* MERGEFORMAT  Jenny McCollum Manager Nadir Ahmed Status  FORMDROPDOWN  Last Changed 4/18/2000 Revision Summary Version Author Changes 4/18/2000 Jenny Initial draft Overview This document outlines the list of test to be included in Whistler BVT for WMI.  There are two types of tests, these are: Build Verification Tests (BVT) The set of tests to verify the build has not broken any major  Functionality of WMI, the BVT will test only the minimum  Functionality of each WMI component:  Core, ESS, scripting, providers and adapters. Build Acceptance Tests (BAT)  An additional set of tests to run after the BVT has passed. Each BAT needs to run independently.  It is VERY important that  a limited scenario is tested so that the BAT can be reclassified  later until a different SBO without alteration. The BVT should run via command line as well as part of the test framework.   Each test will be numbered and completely isolated   to allow a specific test to be run.   BVT will be extensible, configurable so that it can be easily modified for adding new tests or modifying the namespace / class on which test is to be run.  The default values for a test may be changed in the BVT.INI.   The executable will print out the default BVT, along with the description of each test if requested. Before each test is executed, the test running, along with it s description, will be displayed on the screen and in the log file.  If a particular test fails, it should log the error to the error log file   with all parameters printed out. Security Scope of operating system support The BVT must run on the following platforms Logging support The command line version will log to BVT.LOG by default unless specified otherwise. The Framework version will log to Performance  The BVT should run between 15   40 minutes The BVT Tests The BVT project is structured in the following way: BVT/BAT The bvt subdirectory contains all of the code of the actual tests.  These tests are completely isolated, use common code, wrapped apis available via BVTAPI.LIB.  These tests should be callable as a simple function, so the shells can execute the tests by simply calling a function.  BVTAPI.LIB For the API tests, each call to WMI will be completely wrapped in a function that will log all parameters, should the call fail.  All of these wrapped calls are placed in the BVTAPI.LIB, and all tests must use these wrapped calls in order to ensure proper logging of parameters.  The BVTAPI.LIB also contains common utility code. Framework Shell The framework version will use the framework logging, tests will be executed according to command line parameters: The BVT executeable will have the following options: -TEST     [1,2,10...]        The requested tests to run.   Default: All tests are executed -INIFILE  inifilename         The name of the ini file. Default: BVT.INI -DEFAULT Writes out the default ini file. Default: BVT.INI -LOGFILE  logfilename        The name of the output log file.  Default: BVT.LOG. Command Line Shell The command line version will execute the default tests when executed without command line parameters. The BVT executeable will have the same options as specified in the Framework shell. To add a new test to the BVT.EXE, follow these steps: Write the test in a completely isolated way, it would be wise to use the BVTAPI.LIB to take advantage of the automatic logging of all parameters. Add a new test number to BVT.H. If desired, add default test information in BVTINI.CPP using the new test number, so the test will be automatically executed with the desired parameters. Add the new test number to the switch statement in BVTMAIN.CPP Recompile and execute. Scripts For the scripting test, there will be three types of scripts tested:  JS, VBS,  Each script will log the parameter information using a common scripting object.  The BVT executeable will simply spawn the script off, logging minimal information of when the script was launched, and the return code info.  The script will be responsible for producing detailed error logs. BVT/BAT Tests There are the following basic sections that will be tested via API and Script: Simple Repository Phase   Single threaded execution of tests Complex Repository Phase  Multithreaded execution of tests Provider Phase  Testing of CIMV2 Namespace Adapter Phase  Testing of the OLEDB Adapter Event Phase  Testing the event subsystem The Simple Repository Phase The Simple Repository Phase will conduct the following tests: Connecting to WMI  Namespace Creation Class Manipulation Instance Manipulation Fetching Objects Methods Queries Scopes/Collections Transactions The following sections outline each test, it s number, descripton of major functionality, and the phase the test falls under. BVT.INI format s Dynamically creation of classes format  [APITEST?] CLASSES  TestClass1, TestClass2 TESTCLASS1 Empty TESTCLASS2  = "Parent:TestClass1,    ClassQualifier:Dynamic:CIM_BOOLEAN:1,    Property:LaKey1:CIM_STRING:Key1,     PropertyQualifier:KEY:LaKey1:CIM_BOOLEAN:1 CLASSES  =  This is a list of the classes that we are working with.  Each name refers to the  name of the class as well as the key that is defined in this same section. TESTCLASS1 =  The name of the class. Empty A reserved word, and in this context means to create an empty  class. TESTCLASS2 = The name of the class. Parent This section up to the next comma is defining a parent class. TestClass1 The parent class to spawn a derived instance from. ClassQualifier This section up to the next comma defines a class qualifier. Dynamic The name of the qualifier CIM_BOOLEAN The data type of the qualifier The value of the qualifier Property This section up to the next comma is defining a property. LaKey1 This is the name of the property CIM_STRING This is the data type of the property This is the value to be added to the property PropertyQualifier This section up to the next comma defines a property qualifier. The name of the property qualifier LaKey1 The property this qualifier will be added to. CIM_BOOLEAN The data type of the property qualifier. The value of the property qualifier. A class can have more than one key, simply separate them by a comma.  A class can also have more than one property, simply separate them by a comma. The following data types are supported by the BVT CIM_UINT8 CIM_SINT8 CIM_BOOLEAN CIM_CHAR16 CIM_SINT16 CIM_UINT16 CIM_SINT32 CIM_UINT32 CIM_SINT64 CIM_UINT64 CIM_REAL64 CIM_DATETIME CIM_STRING CIM_REFERENCE Dynamically adding/deleting classes [APITEST?] CLASS_DEFINITION_SECTION = APITEST5 DELETE_ADD_CLASS_ORDER = Delete:TestClass2, Delete:TestClass9, Add:TestClass2,   Delete: TestClass7, Delete: TestClass6 Delete Means the following class name will be deleted from the namespace Means the following class name will be added to the namespace The program will look for the definitions of these classes as specified in the key  CLASS_DEFINITION_SECTION Connecting to WMI   Test # 1 - 3 Test1 - Basic connect using IWbemLocator to specified namespace. If the BVT.INI doesn t exist, the specified defaults will be added.  If the BVT.INI exists, then the test will use whatever values are specified. API Test Ini file defaults [APITEST1] NAMESPACE   =  ROOT\DEFAULT DESCRIPTION = "Basic connect using IWbemLocator to specified namespace. Interfaces used to accomplish this test Get namespace from the ini file. CoCreateInstance of IID_IWbemLocator ConnectServer to specified namespace   IID_IWbemServices. Release IWbemServices Release IWbemLocator. Script Test Ini file defaults [APITEST1] SCRIPT =  scripts\test1.vbs SCRIPT_DESCRIPTION = " Basic connect via SWbemLocator and SWbemLocator.ConnectServer Script apis used to accomplish this test Create a SwbemLocator object  Use SwbemLocator.ConnectServer to connect to the specified namespace Test2    Basic connect using IWbemConnection for all supported interfaces. If the BVT.INI doesn t exist, the specified defaults will be added.  If the BVT.INI exists, then the test will use whatever values are specified. API Test Ini file defaults [APITEST2] NAMESPACE    ROOT\DEFAULT CLASS               __NAMESPACE DESCRIPTION Basic connect using IWbemConnection for IWbemServices,                 IWbemServicesEx, IWbemClassObject" NOTES: NAMESPACE  = refers to the namespace to open CLASS = refers to the class to instantiate for IWbemClassObject Interfaces used to accomplish this test Get namespace from the ini file. CoCreateInstance of IID_IWbemConnection Open with IID_IWbemServices for specified namespace. Release pointer Open with IID_IWbemServicesEx for specified namespace. Release pointer. Open with IID_IWbemClassObject for specified class. Release pointer. Release IWbemConnection pointer. Script Test Ini file defaults [APITEST2] SCRIPT =  scripts\test2.vbs SCRIPT_DESCRIPTION = "Basic connect via SWbemLocatorEx and SWbemLocator.Open Script apis used to accomplish this test Create a SwbemLocatorEx object  Use SwbemLocator.Open to connect to the specified namespace Test3 - Basic async connect using IWbemConnection for all supported interfaces. If the BVT.INI doesn t exist, the specified defaults will be added.  If the BVT.INI exists, then the test will use whatever values are specified. API Test Ini file defaults [APITEST3] NAMESPACE    ROOT\DEFAULT CLASS               __NAMESPACE DESCRIPTION Basic async connect using IWbemConnection for IWbemServices,                 IWbemServicesEx, IWbemClassObject" NOTES: NAMESPACE  = refers to the namespace to open CLASS = refers to the class to instantiate for IWbemClassObject Interfaces used to accomplish this test Get namespace from the ini file. CoCreateInstance IID_IWbemConnection Create internal handler CSinkEx OpenAsync with IID_IWbemServices for specified namespace. Use handler to get the interface pointer   IWbemServices Release pointer OpenAsync with IID_IWbemServicesEx for specified namespace. Use handler to get the interface pointer   IWbemServicesEx Release pointer. OpenAsync with IID_IWbemClassObject for specified class. Use handler to get the interface pointer   IWbemClassObject Release pointer. Release internal handler Release IWbemConnection pointer. Script Test [APITEST3] SCRIPT =  scripts\test3.vbs       SCRIPT_DESCRIPTION = Test4 - Creation of a test namespace If the BVT.INI doesn t exist, the specified defaults will be added.  If the BVT.INI exists, then the test will use whatever values are specified. API Test Ini file defaults [APITEST4] NAMESPACE    ROOT\BVTAPITEST       PARENT_NAMESPACE  ROOT"       CLASSES __NAMESPACE"       __NAMESPACE = "Property:Name:CIM_STRING:BVTAPITEST"  DESCRIPTION Creation of a test namespace NOTES: NAMESPACE  = refers to the end result namespace desired PARENT_NAMESPACE = refers to the parent namespace of the new one to be created. CLASSES = refers to the class to get to create the namespace. __NAMESPACE = see BVT.INI format information for class definitions. Interfaces used to accomplish this test Get namespace from the ini file. CoCreateInstance IID_IWbemConnection Parse the namespace name to get the parent first, and open the parent (which must exist) via Open using IID_IWbemServices. Start looping through all child namespace names, use Open to see if namespace exists. Child namespace exists:   Release parent namespace pointer. Set this child as the new parent. Child namespace does not exist: Calling GetObject on  __NAMESPACE Get a new instance of this class by calling SpawnInstance. Set the new namespace's name by setting the Name property to the child namespace name and calling Put on the instance. Create the new namespace by calling PutInstance in the parent namespace. Release the parent namespace pointer Call Open, using IID_IWbemServices on the child namespace and set this as the new parent. Release class and instance pointers, continue looping to see if there are anymore child namespaces. Release parent, child namespace pointers. Release IWbemConnection pointer. Script Test [APITEST4] SCRIPT    scripts\test4.js SCRIPT_DESCRIPTION Test5 - Creates test classes in the test namespace If the BVT.INI doesn t exist, the specified defaults will be added.  If the BVT.INI exists, then the test will use whatever values are specified. Special notes on this test: In this test there must be class hierarchies at least to three levels. API Test Ini file defaults [APITEST5] Classes =  TestClass1,TestClass2,TestClass3,TestClass4,TestClass5, TestClass6,TestClass7,TestClass8,TestClass9,TestClass10" Script =  scripts\test5.vbs RUN_TESTS =  TestClass1 =  "Empty" // an abstract class, so 4 and 5 can define  // additional keys TestClass2 =  "Property:LaKey1:CIM_STRING:Key1,      PropertyQualifier:KEY:LaKey1:CIM_BOOLEAN:1,         Property:LaKey2:CIM_STRING:Key2,      PropertyQualifier:Key:LaKey2:CIM_BOOLEAN:1"  TestClass3 =   Property:KeyName1:CIM_SINT32:3,       PropertyQualifier:KEY:KeyName1:CIM_BOOLEAN:1,       Property:PropertyName3:CIM_UINT32:3,        Property:PropertyName3B:CIM_STRING:Test TestClass4 =  Parent:TestClass1,  Property:KeyName4:CIM_UINT32:4,      PropertyQualifier:KEY:KeyName4:CIM_BOOLEAN:1,  Property:PropertyName4:CIM_BOOLEAN:0 TestClass5 = Parent:TestClass1,  Property:KeyName5:CIM_STRING:Temp,  PropertyQualifier:KEY:KeyName5:CIM_BOOLEAN:1,  Property:PropertyName5:CIM_STRING:Value5 TestClass6 = Parent:TestClass5,   Property:PropertyName6:CIM_STRING:Value6" },     // no additional key can be defined TestClass7 = Parent:TestClass6,  Property:PropertyName7:CIM_BOOLEAN:1  // no additional key can be defined TestClass8 = Parent:TestClass7,  Property:PropertyName8:CIM_SINT32:2         // no additional key can be defined TestClass9 = Parent:TestClass8,Property:PropertyName9:CIM_STRING:Value9  // no additional key can be defined TestClass10 = Parent:TestClass9, Property:PropertyName10:CIM_BOOLEAN:0  // no additional key can be defined DESCRIPTION =  Creates test classes in the test namespace Interfaces used to accomplish this test Call the tests specified in RUNTESTS key. CoCreateInstance, IID_IWbemLocator Connect to the test namespace via ConnectServer for IWbemServices pointer. For each class, perform the following: Get the definition of the class. Get an empty class object to work with by calling GetObject with null name. Set parent class by calling InheritsFrom. Write properties by calling Put Set the key by setting the reserved name   qualifier. Call GetPropertyQualifierSet on class Call Put on the QualifierSet pointer. Put the class into the namespace Calling GetObject on the new class Get a new instance of this class by calling SpawnInstance. Set the property default values as specified in the BVT.INI Write the instance by calling PutInstance in the namespace. Release class and instance pointers. Release the Namespace pointer. Release the IWbemLocator pointer. Script Test Test6   Delete and recreate classes in the test namespace If the BVT.INI doesn t exist, the specified defaults will be added.  If the BVT.INI exists, then the test will use whatever values are specified. Special notes on this test: This test will automatically run tests 4 and 5, to create new test namespace and new test classes before executing the below. Class definitions will be looked for in the section specified by: CLASS_DEFINITION_SECTION Classes will be deleted as specified by the ini entry:  DELETE_CLASSES Classes will then be compared to what is expected to be left, by looking at the values in the ini entry:  CLASSES_AFTER_DELETE Classes to be added are then specified by the ini entry: ADD_CLASSES Classes will then be compared to what is expected to be left, by looking at the values in the ini entry:  CLASSES_AFTER_ADD Classes to be deleted and added in specified order: DELETE_ADD_CLASS_ORDER Expected results of the above operation CLASSES_AFTER_DELETE_ADD API Test Ini file defaults  [APITEST6] RUNTESTS =  CLASS_DEFINITION_SECTION = APITEST5 DELETE_CLASSES  =  TestClass1,TestClass3 CLASSES_AFTER_DELETE =  TestClass2 ADD_CLASSES =  TestClass1,TestClass3,TestClass4,TestClass5,TestClass6,                                             TestClass7, TestClass8, TestClass9, TestClass10 CLASSES_AFTER_ADD= TestClass1,TestClass2,TestClass3,TestClass4,TestClass5,     TestClass6,TestClass7, TestClass8, TestClass9, TestClass10 DELETE_ADD_CLASS_ORDER = Delete:TestClass2, Delete:TestClass9, Add:TestClass2,      Delete: TestClass7, Delete: TestClass6 CLASSES_AFTER_DELETE_ADD= TestClass1,TestClass2,TestClass3,TestClass4,TestClass5 DESCRIPTION =  Deletes and Creates the classes as defined in test 5 in the requested order. Interfaces used to accomplish this test Call the tests specified in RUNTESTS key. CoCreateInstance, IID_IWbemLocator Connect to the test namespace via ConnectServer for IWbemServices pointer. Delete each class specified in DELETE_CLASSES list by calling pNamespace->DeleteClass Enumerate all classes by calling pNamespace->CreateClassEnum and see if just the classes listed in the CLASSES_AFTER_DELETE list are there.  If not, error out. Add the classes specified in the ADD_CLASSES list by calling pNamespace->PutClass Enumerate all classes by calling pNamespace->CreateClassEnum and see if just the classes listed in the CLASSES_AFTER_ADD list are there.  If not, error out. Add/Delete the classes specified in the DELETE_ADD_CLASS_ORDER Enumerate all classes by calling pNamespace->CreateClassEnum and see if just the classes listed in CLASSES_AFTER_DELETE_ADD list are there.  If not, error out. Release the Namespace pointer. Release the IWbemServices pointer. Test7   Create some simple association classes If the BVT.INI doesn t exist, the specified defaults will be added.  If the BVT.INI exists, then the test will use whatever values are specified. Special notes on this test: This test will automatically run test 5 to create the test classes API Test Ini file defaults  [APITEST7] CLASS_DEFINITION_SECTION = APITEST7 RUNTESTS =  CLASSES =   Association1, Association2"  Association1 = "Property:FirstPoint:CIM_REFERENCE:Value,    PropertyQualifier:KEY:FirstPoint:CIM_BOOLEAN:1,  PropertyQualifier:CIMTYPE:FirstPoint:CIM_STRING:ref:Test1, Property:EndPoint:CIM_REFERENCE:Value, PropertyQualifier:CIMTYPE:EndPoint:CIM_STRING:ref:Test2,  PropertyQualifier:Key:EndPoint:CIM_BOOLEAN:1"  Association2 =  Property:AssocProp1:CIM_STRING:TestClass3,  PropertyQualifier:Key:AssocProp1:CIM_BOOLEAN:1,  Property:AssocProp2:CIM_STRING:TestClass4,  PropertyQualifier:Key:AssocProp2:CIM_BOOLEAN:1"  Interfaces used to accomplish this test Call the tests specified in RUNTESTS key. CoCreateInstance, IID_IWbemServices Connect to the test namespace via ConnectServer for IWbemServices pointer. Get the list of classes to create as specified in the CLASSES key. Create the class as specified in test5, after looking to see what section the class definitions are in, by looking at the CLASS_DEFINITION_SECTION key. Release the Namespace pointer. Release the IWbemLocator pointer. Test8   Query If the BVT.INI doesn t exist, the specified defaults will be added.  If the BVT.INI exists, then the test will use whatever values are specified. Special notes on this test: This test will automatically run test 5 to create the test classes API Test Ini file defaults  [APITEST8]  RUNTESTS   QUERY_LIST QUERY,ASSOCIATORS_QUERY, REFERENCES_QUERY  QUERY_RESULTS  QUERY ="select * from meta_class"   ASSOCIATORS_QUERY Associators of"   REFERENCES_QUERY References of"  Interfaces used to accomplish this test Call the tests specified in RUNTESTS key. CoCreateInstance, IID_IWbemServices Connect to the test namespace via ConnectServer for IWbemServices pointer. Get the list of queries as specified in the QUERY_LIST key. Execute the queries as requested via pNamespace->ExecQuery Release the Namespace pointer. Release the IWbemLocator pointer. NOTE:  Need to find the best way to compare results, should be a simple number of how many returned, or comparing class names? Test9   Creating instances If the BVT.INI doesn t exist, the specified defaults will be added.  If the BVT.INI exists, then the test will use whatever values are specified. Special notes on this test: API Test Ini file defaults  [APITEST9] INSTANCE_DEFINITION_SECTION =  APITEST9 RUN_TESTS =  INSTANCES =  TestClass2, TestClass3, TestClass5 INSTANCE_RESULTS =  Interfaces used to accomplish this test Call the tests as specified in RUN_TESTS key CoCreateInstance, IID_IWbemServices Connect to the test namespace via ConnectServer for IWbemServices pointer. Get the list of instances to create as specified in the INSTANCES key Create the instances by getting the definitions as specifiedin the INSTANCE_DEFINITION_SECTION key, by calling pNamespace->PutInstance Check the results Release the Namespace pointer. Release the IWbemLocator pointer. NOTE:  Need to find the best way to compare results, should be a simple number of how many returned, or comparing instances? Test10   Deleting instances If the BVT.INI doesn t exist, the specified defaults will be added.  If the BVT.INI exists, then the test will use whatever values are specified. Special notes on this test: API Test Ini file defaults  [APITEST10] RUN_TESTS =  DELETE_INSTANCES =  TestClass2, TestClass3, TestClass5 INSTANCE_RESULTS =  Interfaces used to accomplish this test Call the tests as specified in RUN_TESTS key CoCreateInstance, IID_IWbemServices Connect to the test namespace via ConnectServer for IWbemServices pointer. Get the list of instances to delete as specified in the DELETE_INSTANCES key Delete the instances by pNamespace->DeleteInstance Check the results Release the Namespace pointer. Release the IWbemLocator pointer. NOTE:  Need to find the best way to compare results, should be a simple number of how many returned, or comparing instances? Test11   Enumerating instances If the BVT.INI doesn t exist, the specified defaults will be added.  If the BVT.INI exists, then the test will use whatever values are specified. Special notes on this test: API Test Ini file defaults  [APITEST11] RUN_TESTS =  ENUMERATE_INSTANCES =  TestClass2, TestClass3, TestClass5 INSTANCE_RESULTS =  Interfaces used to accomplish this test Call the tests as specified in RUN_TESTS key CoCreateInstance, IID_IWbemServices Connect to the test namespace via ConnectServer for IWbemServices pointer. Get the list of instances to enumerate as specified in the ENUMERATE_INSTANCES key Enumerate  the instances by pNamespace->CreateInstanceEnum Check the results Release the Namespace pointer. Release the IWbemLocator pointer. NOTE:  Need to find the best way to compare results, should be a simple number of how many returned, or comparing instances? Test12   Creating Association instances If the BVT.INI doesn t exist, the specified defaults will be added.  If the BVT.INI exists, then the test will use whatever values are specified. Special notes on this test: This test uses the same interfaces/scripts as Test# 9, just with a different INI section. API Test Ini file defaults  [APITEST13] RUN_TESTS =  ASSOCIATION_INSTANCES =  TestClass2, TestClass3, TestClass5 INSTANCE_RESULTS =  Test13   Deleting Association instances If the BVT.INI doesn t exist, the specified defaults will be added.  If the BVT.INI exists, then the test will use whatever values are specified. Special notes on this test: This test uses the same interfaces/scripts as Test# 10, just with a different INI section. API Test Ini file defaults  [APITEST13] RUN_TESTS =  ASSOCIATION_INSTANCES =  TestClass2, TestClass3, TestClass5 INSTANCE_RESULTS =  Test14   Enumerating Association instances If the BVT.INI doesn t exist, the specified defaults will be added.  If the BVT.INI exists, then the test will use whatever values are specified. Special notes on this test: This test uses the same interfaces/scripts as Test# 11, just with a different INI section. API Test Ini file defaults  [APITEST14] RUN_TESTS =  ASSOCIATION_INSTANCES =  TestClass2, TestClass3, TestClass5 INSTANCE_RESULTS =  Test15   Ensure that deletion of the classes takes out all the instances of the class If the BVT.INI doesn t exist, the specified defaults will be added.  If the BVT.INI exists, then the test will use whatever values are specified. API Test Ini file defaults  [APITEST15] RUNTESTS =  CLASS_DEFINITION_SECTION = APITEST5 DELETE_CLASSES  =  TestClass1,TestClass3 DESCRIPTION =  Ensure that deletion of the classes takes out all the instances of the class Interfaces used to accomplish this test Call the tests specified in RUNTESTS key. CoCreateInstance, IID_IWbemLocator Connect to the test namespace via ConnectServer for IWbemServices pointer. Delete each class specified in DELETE_CLASSES list by calling pNamespace->DeleteClass Enumerate instances of the class, if there are instances, then error out. Release the Namespace pointer. Release the IWbemServices pointer. Test16   Fetching various objects Get the various types of objects (classes/instances) using the various types of paths accepted by WMI ( WMI path/ UMI path/ HTTP path) Test17   Getting a list of Methods for a class Test18   Getting a list of Methods for an instance Test19   Add objects to scope/collection using methods IWbemServicesEx interface Test20   Get the list of objects in a scope/collection using by getting enumerator of instances using IWbemServicesEx on the the scooping / parent object Test21   Open association endpoint as collection and enumerate, ensure that the results are correct Test22   Get a IWbemTransaction , start a transaction , add a class, an instance of that class and commit the transaction Test23    Start a transaction, delete a class and Abort the transaction and check if that class still exists in the namespace Complex Repository Phase Rerun the above set of tests with async calls Rerun the above set of tests in parallel from several threads in different namespaces. The Provider Phase CIMV2 Provider Phase : Testing on Cimv2 namespace Open CIMV2 namespace Get class enumerator for the namespace to get list of classes Get instance enumerator for simple classes Win32_logicalDisk, Win32_Process  Get classes/instances using path of the object Execute simple Select *  Queries Execute Association/Reference queries Enumerate methods for a class/instance. Execute a method on one of the instance say Terminate method on Win32_process and check if the instance is removed. Close the connection Run the above test with several threads in parallel WDM Provider Phase : Testing on ROOT/WMI namespace Open ROOT/WMI namespace Get class enumerator for the namespace to get list of classes Get instance enumerator for simple classes RegisteredGuids Get classes/instances using path of the object Execute Select *  Queries Enumerate methods for a class/instance   find the NDIS class Execute a method on one of the instance  Register for NDIS event Create Refresher on Object Create Refresher on Class Close the connection Run the above test with several threads in parallel Reverse Dredger Phase : Testing on ? What other providers should be included on this? The Event Phase Testing Events Creation, working, and cancellation of temporary subscriptions Creation, working, deletion, and recreation of permanent subscriptions Event providers (including Non-COM and Decoupled) participating in above Core (repository events) participating in above Polling participating in above Monitors (temporary and permanent): new feature Guarded filters (as part of (2)): new feature Policy provider access Forwarding of events to another machine Policy application The Adapter Phase OLEDB Adapter Create Rowset Create Row Object Read a row from Rowset Read a row from Row Object Write a row to Rowset Write a row to Row Object Execute a command Enumerate columns for a class Execute a method Bind to a row, rowset, datasource Set up a transaction What other adapters should be included in here? The Additional Scripting Phase Namespace creation Create a new test namespace by using SwbemObject.Put method for an instance of __Namespace and check if this namespace is available by connecting to the namespace Working with Classes Create a new class. This can be done by creating SwbemObject adding properties , setting properties and saving the class by SWbemObject:Put() Simple data types like String and SINT32 can be used for the different properties.  Check if the new class added exists in the repository by getting object with the path. Delete an existing Class. Ensure that the class is deleted by trying to get the class object with the path. Enumerate the classes in Namespace by using SWbemServices::SubClassesOf  Create some simple association classes Working with instances Create instances of the above class. Ensure that the instance is added by getting the object using the path of the object. Delete instances of the class. Ensure that the instance is deleted by trying to fetch the object with the path and this should result in error Get enumerator for the list of instances and check if instances added are present in the objects in the enumerator  Add instance to Association classes Get References of a instance Get Associators of a instances Fetching objects Get the various types of objects (classes/instances) using the various types of paths accepted by WMI ( WMI path/ UMI path/ HTTP path) Working with Methods Getting list of methods for a class/instance Working with Queries Execute simple select queries to get the list of instances of a class and test if the query returns the instances correctly Execute Association/Reference queries and test if it is executed successfully. Try to execute a invalid query to get an error Working with Scopes/Collections Add objects to scope/collection using methods SwbemServicesEx and  SWbemObjectEx interface. Get the list of objects in a scope/collection using by getting enumerator of instances using SWbemObjectEx on the the scooping / parent object Open association endpoint as collection and enumerate, ensure that the results are correct Add an object to container/scope and check if it is present in the scope/container by checking if this objects exists. Copy Objects from one container to another and check if it is copied properly Object paths Set a different types of path( as specified in the Object path design document of Scripting API) to sWbemObjectPathEx and check the different properties and methods(IsClass, Namespace,keys ) are returned correctly. Fetch the new properties Components and Parent . Construct a path with SwbemObjectPathComponents object Custom Interfaces Get a ADSI object which will be a aggregated ADSI extension object. Call method or fetch a property of the custom interface DateTime property Get a property of type CIM_DATETIME into a variable of type sWbemDateTime and check the different properties of the object to get the different parts of the datetime Add a static class with a property of CIM_DATETIME. Add an instance and set the datetime property using an object of sWbemDateTime. Interface Properties Set interface properties(like search preferences) for a SwbemServicesEx  object on a LDAP object using InterfaceProperties property and then execute a LDAP query. System Properties Fetch all the system properties for an existing object in a namespace ( Ex: an instance of Win32_logicaldisk) using SystemProperties  property of SwbemObjectEx Set a value to a system property and if the underlying provider allows this. Object Text :   Get an the object text as XML using GetText method of SwbemObjectEx and store it in file. Load an object from the XML file using SetFromText of SWBemObjectText and fetch all the properties to check if it is a valid object. Refreshing an object Refresh an object using SwbemObjectEx s Refresh function  Use Refresher object to refresh multiple object Object Security Create a class, an instance of that class and set the object security using SwbemServicesEx object s PutObjectSecurity Get the object security for the above object using SwbemServicesEx object s GetObjectSecurity Test setting and getting security descriptor with SwbemObjectEx methods Transactions Using SwbemTransaction on a SWbemServices start a transaction, add an instance of a class and commit the transaction Using SwbemTransaction on a SWbemServicesEx start a transaction, add an instance of a class and Rollback the transaction Do transactions processing with  SwbemTransaction or SwbemObjectEx  on a object  DATE  5/6/2000 Microsoft Confidential Page   PAGE  \* MERGEFORMAT   DOCPROPERTY "Product"  \* MERGEFORMAT   Specification   TITLE  \* MERGEFORMAT  Unassigned MICROSOFT CONFIDENTIAL Scripts The .vbs, .js scripts that are spawned from  BVTSCRIPT.CPP Command line Shell Code to wrap the tests so they run via command line Framework Shell Code to wrap the tests so they run in the framework. BVTAPI.LIB Contains all wrapped api calls BVT/BAT BVTREPOSIT.CPP, BVTCIMV2.CPP, BVTESS.CPP, BVTSCRIPT.cpp,  These are the actual tests.  These are coded independently, not tied to either framework or command line.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\readme.txt ===
LOCALIZATION STUDIO 4.2 PARSER

This DLL provides the ability to localize Amended qualifiers through Localization Studio 4.2.
To install the parser on a workstation already containing LocStudio 4.2, add the following registry entry:

HKLM\Software\Microsoft\LocStudio 4.2\Parsers\
\Parser99
  Description: REG_SZ : "MOF Parser"
  ExtensionList: REG_SZ : "MOF MFL"
  Help: REG_SZ : "WMI MOF files (*.mof, *.mfl")"
  Location: REG_SZ : "D:\M3\locstudioparser\retail\wmiparse.dll"
  ParserID : REG_DWORD : 0x63
\Parser99\File Types
\Parser99\File Types\File Type 1
  Description : REG_SZ : "MOF Parser"
  File Type : REG_DWORD : 0x1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\commands.txt ===
Sample Commands:
================
(1)wmic:root\cli>process get name
   Displays the name property of all the instances specified by process in the default
   (value) format.

(2)wmic:root\cli>process get name,caption  /value /all 
   Displays the name,caption properties of all the instances specified by process in the table
   format.Here eventhough both the getswitches are specified which indicates two diff.formats
   it will take the last one.

(3)wmic:root\cli>class win32_useraccount
   It will display the list of properties of all the instances of win32_useraccount.Eventhough
   there is no verb specified it will take default as GET. 

(4)wmic:root\cli>class win32_useraccount  get /interactive
   It will report an error because /interactive and /nointeractive are not allowed with GET,LIST
   and ASSOC.

(5)wmic:root\cli>path win32_process list
   It will report an error becuse list verb is not allowed with PATH and CLASS.

(6)wmic:root\cli>useraccount list brief /translate:Basicxml
   It will list the properties of the alias useraccount and translate the return
   values using the translation table Basicxml.
  
(7)wmic:root\cli>process call create notepad.exe
   It will create an instance of notepad.

(8)wmic:root\cli>process call create notepad.exe /interactive
   Itwill ask for the user response to create a notepad and creates according to 
   his response.  

(9)wmic:root\cli>/interactive process call create notepad.exe
   Itwill ask for the user response to create a notepad and creates according to 
   his response.Here /interactive is global level, so it will wait for the user response
   for subsequent commands also.

(10)wmic:root\cli>class win32_process assoc

(11)wmic:root\cli>class win32_process set caption="gjkvc"
   Sets the caption property to "gjkvc" of the instances of the class win32_process.

(12)wmic:root\cli>class win32_process set caption="gjkvc" /interactive
   It will ask for the user prompt before setting the property specified.If the user says
   'y'  then it will set the property otherwise it won't set the property.

(13)wmic:root\cli>class removetest00 create "p=100"
   Creates an instance of class Removetest00 with the property p=100.

(14)wmic:root\cli>path removetest00 where p=100 get
   Display the properties of the instance of class removetest00 which has the property p=100

(15)wmic:root\cli>path removetest00 where p=100 delete
   Deletes the instance of the class removetest00 which has property p=100.

(16)wmic:root\cli>class removetest00 delete
   Deletes the class removetest00.

(17)wmic:root\cli>process where handle=0 get
   Display the properties of the instance which satisfies the where expression.

(18)wmic:root\cli>process (0 "System Idle Process") get
   Display the properties of the instances which satisfies the alias parameters specified.

(19)wmic:root\cli>process path win32_process get
   The path specified by path expression(win32_process) and the alias(process) matched,
   that's why it will display the list of properties of all the instances of process.

(20)wmic:root\cli>process path win32_useraccount get
   Here the path specified by pathexpression (win32_useraccount) and the alias (process) doesn't
   match, then it will report an error.

(21)wmic:root\cli>process path win32_process where handle=0 list
  The path specified by path expression(win32_process) and the alias(process) matched,
  that's why it will list the properties of all the instances of process.  

(22)wmic:root\cli>process path win32_process.handle where handle=0 list
  Here it will report an error because when where is specified the path expression
  should be classpathexpression.

(23)wmic:root\cli>/namespace:\\root\default class netdiagnostics get
  It will connect to the namespace \\root\default and display the properties of the instances
  of the class netdiagnostics.

(24)wmic:root\cli>process where handle=0 call create notepad.exe
  It will report an error because create method of the class win32_process is not valid
  at the instance level.

(25)wmic:root\cli>/role:\\root\cimv2 process get
  It will change the role to \\root\cimv2 and try to execute the command.It will report an
  error because the class corresponding to alias(process) Microsoft_clialias is not there
  inthe \\root\cimv2 namespace.

(26)wmic:root\cli>/role:junk process get
  It will report an error while executing the command, becuse the specified namespace is not
  valid.

(27)wmic:root\cli>/node:vnraju,biplabm /user:"administrator" /password:"test2" proce
ss get
  If both the machines have the same password, then it will display the properties of the
  instances of process.If any one machine has different password then it will report the 
  error for that node and display the properties of the instances of the process for the
  other node.If both the systems have different password then it will report the error for
  both the nodes.

(28)wmic:root\cli>/node:vnraju /user:"administrator"
  It will prompt for the password, if the user enters the correct password then it will 
  connect to the node vnraju.

More commands:
=============
1.a)
wmic:root\cli>share call create "", "", 5, abcd, "", "C:\rams", 0
(CREATE A SHARE)

FYI: 
Create parameters are as follows:
a)Access(OBJECT)             
b)Description(STRING)
c)MaximumAllowed(UINT32)
d)Name(STRING)
e)Password(STRING)
f)Path(STRING)
g)Type(UINT32)

1.b) path win32_service where name='w3svc' get /value
(PATH and WHERE together)

2. process 0 "system idle process" get /value
(PWhere without parenthesis)

3. process (0 "system idle process") get /value
(PWhere with paranethesis)

4. process path win32_process where handle=0 get /value
(<alias> with PATH and WHERE)

5. /namespace:"\\root\cli" path Microsoft_CliAlias.FriendlyName='UPS'
 delete 
(Deleting an instance)

6. /node:ram, vivek /user:administrator /password:enterthedragon service get /value
(multiple nodes - GET)

7. /node:ram, vivek /user:administrator /password:enterthedragon process call create notepad.exe
(multiple nodes - CALL)

8. /node:ram /user:administrator /password:enterthedragon CLASS REMOVETEST00 create p=1
(creating an instance)
ATTN: run the sample vbscript - resettodefault.vbs for creating the class REMOVETEST00

9. diskdrive rmdir "d:\\share\\test"
(executing other command line utilities)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\wmic\xsl-mappings.xml ===
<XSLMAPPINGS>
<XSLFORMAT KEYWORD="TABLE">WmiCliTableFormat.xsl</XSLFORMAT>
<XSLFORMAT KEYWORD="VALUE">WmiCliValueFormat.xsl</XSLFORMAT>
<XSLFORMAT KEYWORD="MOF">WmiCliMofFormat.xsl</XSLFORMAT>
<XSLFORMAT KEYWORD="LIST">WmiCliValueFormat.xsl</XSLFORMAT>
<XSLFORMAT KEYWORD="TVLIST">TextValueList.xsl</XSLFORMAT>
</XSLMAPPINGS>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\bmc\readme.txt ===
README for the BMC PATROL Agent with WBEM adapter
Version 1.0.01 for Windows 2000
Copyright  1998 BMC Software, Inc.

------------------------------------------------
1. Pre-Installation
------------------------------------------------
1.  Install the WBEM SDK. 
     The download site is currently at http://msdn.microsoft.com/developer/sdk/wbemsdk/default.htm
2.  Due to a problem with the WMI install it is necessary to place the WMI core component directory in the path. This
     is usually in the system folder i.e. c:\winnt\system32\wbem.
3.  Ensure that the Windows Management service is started.
4.  Documentation may be found at www.bmc.com/initiatives/wbem

------------------------------------------------
2. Installation
------------------------------------------------

To install:

1.  To install the BMC Software PATROL Agent with WBEM adpater user must be a loacl account and 
     a member of the 'Administrators' group as well as have following seven rights:
		1.	Act as part of the operating system
		2.	Debug programs
		3.	Increase quotas
		4.	Log on as a service
		5.	Log on locally
		6.	Profile system performance
		7.	Replace a process level token

2.  If you wish to use the WBEM KM to monitor and manage cimom, you must install on a machine 
     running the PATROL NT console.
3.  Ensure that the WBEM tools are in the path and that you are logged on with WBEM administrator
     privileges.
4.  Stop the Windows Management service then restart it to ensure that the WMI providers are located properly.
5.  Test the installation by running WBEM CIM Studio or the WBEM CIM object browser and 
     enumerating the instances of the PATROL classes inheriting from PATROL_ManagedObject
     within the root/CIMV2 or root/patrol namespaces. The PATROL_KM_... classes will not
     have any instances until you create and register a KM-specific MOF file as described in
     the documentation.
6.  Restart your computer after install.

The files will be installed in the following location on the target computer, where <PATROL_HOME>
is the environment variable created during PATROL installation:

  <PATROL_HOME>\bin		 - InternalCommand.dll
				   PatrolAgent.dll
				   PACfg.exe
				   PatrolAgent.exe
				   PatrolPerf.exe
				   reinitagent.exe
  				   service.ini
				   inServ.ini
				   Uninst.dll
  <PATROL_HOME>\lib 		 - config.lic	 - license file
				   config.defaul - PATROL Agent's configuration file 

  <PATROL_HOME>\lib\knowledge	 - all_computers.km
				   BULL.km
				   DC-OSX.km
				   DG.km
				   HP.km
				   i386-SEQUENT.km
				   NT.km
				   OSF1.km
				   PATROL_NT.km
				   PATROLAGENT.km
				   RS6000.km
				   SCO.km
				   SGI.km
				   SINIX.km
				   SOLARIS.km
				   StdEvents.ctg
				   SUN4.km
				   SVR4-i386.km
				   SVR4-m88K.km
				   SVR4-SPARC.km
				   ULTRIX.km
				   VMS.km

  <PATROL_HOME>\lib\nls\C\1	 - 1.cat
				   2.cat
				   3.cat
				   4.cat
				   5.cat

  <PATROL_HOME>\lib\PSL		 - boot_collector.psl
				 - edit_inst_filter_lib.psl
				 - fs_edit_filter_list.psl
				 - fs_find_file_like.psl
				 - fs_manual_mount.psl
				 - fs_remove_file_like.psl
				 - fs_unmount_manual.psl
				 - get_700_nproc.psl
 				 - kernel.psl
				 - log_appl_config.psl
				 - make_preloaded_km_list.psl
				 - response_def_lib.lib
				 - SNMP_lib.lib
				 - SNMP_lib.psl
				 - SNMPReconfig.psl
				 - SNMPStart.psl
				 - SNMPStart_NT.psl
				 - uname_collector.psl
				 - unix_misc_lib.lib
				 - unix_misc_lib.psl
				 - unixkm_version.psl
				 - unixware_parm_filter.psl
				 - vms_startup.psl
				 - vms_vmssnmpstart.psl

  <PATROL_HOME>\lib\wbem\tools   - PATROL/WBEM executables and support files
				   Setupex.exe	 - WBEM Adapter install
                                   pwinstpr.dll  - Instance Provider
                                   evtprov.dll   - Event Provider
                                   pemsvr.exe    - PEM COM Server
                                   msgdll.dll    - Event Log DLL
                                   km2mof.exe    - KM to MOF Utility
                                   km2mof.res    - KM to MOF Resources
                                   pkmparser.dll - KMP COM Server
                                   pwbem.xpc     - PSL API Server
                                   msvcrt.dll    - MS Visual C runtime DLL
                                   msvcirt.dl    - MS Visual C DLL
                                   msvcp50.dll   - MS Visual C DLL
                                   mfc42.dll     - MFC 4.2 DLL
                                   msvbvm50.dll  - MS Visual Basic 5.0 DLL

  <PATROL_HOME>\lib\wbem\schemas - Standard Schemas
                                   patagent.mof
                                   patcimv2.mof
                                   patevent.mof
                                   patkm.mof
                                   patremot.mof

  <PATROL_HOME>\lib\wbem\doc    Documentation
                                   wbpi1000.pdf   - Installation Guide
                                   wbpnr100.pdf   - Release Notes

  <PATROL_HOME>\lib\knowledge    - PATROL Knowledge Modules
                                   wbem.kml
                                   wbem.km
                                   wbem_cimom.km
                                   wbem_namespace.km
                                   wbem_process.km
                                   wbem_provider.km

  <PATROL_HOME>\lib\msgs         - Message files
                                   wbem.msg
                                   util.msg

  <PATROL_HOME>\lib\psl          - PATROL libraries
                                   pwbemlib.lib
                                   utlutl.lib
                                   utmsgsl.lib
                                   utstdmsgl.lib
                                   utstrl.lib
                                   wbemutil.lib
                                   wbemcmdagentadd.psl
                                   wbemcmdagentdefaults.psl
                                   wbemcmdagentdelete.psl
                                   wbemcmdagentdetails.psl
                                   wbemcmdagentmodify.psl
                                   wbemcmdcimomstart.psl
                                   wbemcmdcimomstop.psl
                                   wbemcmdconfig.psl
                                   wbemcmdexport.psl
                                   wbemcmdkmdetails.psl
                                   wbemcmdloadkm.psl
                                   wbemcmdloadmof.psl
                                   wbemcmdprovdetails.psl
                                   wbemcmdquery.psl
                                   wbemcmdsysreport.psl
                                   wbemcmdunloadkm.psl
                                   wbemdiscovery.psl
                                   wbemprmproccoll.psl

  <PATROL_HOME>\lib\images       - PATROL icons
                                   addrspace_ok.bmp
                                   database_ok.bmp
                                   database_warn.bmp
                                   dbms_ok.bmp
                                   filesystem_ok.bmp
                                   filesystem_warn.bmp
                                   process_ok.bmp
                                   process_warn.bmp

The uninstall log file and uninstall extension dll will be copied to the System Root subdirectory.
  pwa_uninst.isu
  pwa_uninst.dll

------------------------------------------------
3.  Uninstallation
------------------------------------------------

NOTE:   Uninstalling PATROL will not completely uninstall the PATROL Adapter for WBEM.

To uninstall:

1.  Stop the PATROL agent to ensure that it is not using the WBEM Adapter tools:
        net stop patrolagent
2.  Stop CIMOM for the same reason:
        cimom /kill
3.  Select Start/Settings/Control Panel
4.  Double-click Add/Remove Programs
5.  Highlight PATROL Adapter for WBEM and click the Add/Remove pushbutton.
6.  The uninstall will verify that you do want to remove the product.
        Select Yes to uninstall.
5.  The uninstall will remove files, Registry entries and CIMOM updates.

---------------------------------------------------------
4.  Installation of the WBEM KM for the PATROL Console
---------------------------------------------------------

The Knowledge Module included with the PATROL Adapter for WBEM can
be installed separately on a computer that has the PATROL Console.
After the PATROL Adapter for WBEM is successfully installed on one
of the target systems the files listed above in the locations:

  <PATROL_HOME>\lib\knowledge    - PATROL Knowledge Modules
  <PATROL_HOME>\lib\msgs         - Message files
  <PATROL_HOME>\lib\psl          - PATROL libraries
  <PATROL_HOME>\lib\images       - PATROL icons

must be manually copied to the corresponding location on 
the computer with the PATROL Console. Then the PATROL Adapter for
WBEM installed on the target systems can be configured remotely
from the PATROL Console system using the PATROL Adapter
for WBEM Knowledge Module.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\bmc\credit.pdf ===
%PDF-1.2 3 0 obj /Linearized 1  /O 5  /H [ 1317 219 ]  /L 52255  /E 51842  /N 1  /T 52078  endobj                                                             xref 3 46  0000000016 00000 n 0000001264 00000 n 0000001536 00000 n 0000001748 00000 n 0000002006 00000 n 0000002208 00000 n 0000003281 00000 n 0000004359 00000 n 0000004570 00000 n 0000004592 00000 n 0000006394 00000 n 0000006416 00000 n 0000008214 00000 n 0000008236 00000 n 0000009987 00000 n 0000011066 00000 n 0000011282 00000 n 0000011304 00000 n 0000013124 00000 n 0000013146 00000 n 0000014562 00000 n 0000015635 00000 n 0000015842 00000 n 0000015959 00000 n 0000015981 00000 n 0000017360 00000 n 0000018436 00000 n 0000018655 00000 n 0000019736 00000 n 0000019945 00000 n 0000019967 00000 n 0000021577 00000 n 0000021599 00000 n 0000023240 00000 n 0000031671 00000 n 0000036449 00000 n 0000050908 00000 n 0000051023 00000 n 0000051138 00000 n 0000051248 00000 n 0000051359 00000 n 0000051552 00000 n 0000051627 00000 n 0000051703 00000 n 0000001317 00000 n 0000001515 00000 n trailer /Size 49 /Info 2 0 R  /Root 4 0 R  /Prev 52069  /ID[<2a671c3038777b189f25b369d968cb8d><2a671c3038777b189f25b369d968cb8d>] startxref %%EOF       4 0 obj /Type /Catalog  /Pages 1 0 R  endobj 47 0 obj << /S 36 /Filter /FlateDecode /Length 48 0 R >>  stream a``Ue b-(f` endstream endobj 48 0 obj endobj 5 0 obj /Type /Page  /Parent 1 0 R  /Resources 6 0 R  /Contents [ 12 0 R 14 0 R 16 0 R 20 0 R 22 0 R 27 0 R 33 0 R 35 0 R ]  /Rotate -90  /CropBox [ 425 0 1179 1179 ]  /MediaBox [ 0 0 1179 1179 ]  endobj 6 0 obj /ProcSet [ /PDF /Text /ImageC ]  /Font << /F10 17 0 R /F11 8 0 R /F12 30 0 R /F14 28 0 R /F15 25 0 R /F16 23 0 R  /F17 9 0 R >>  /XObject << /Im3 36 0 R /Im4 37 0 R /Im5 38 0 R >>  /ExtGState << /GS2 44 0 R /GS3 45 0 R /GS4 46 0 R >>  endobj 7 0 obj /Type /FontDescriptor  /Ascent 715  /CapHeight 690  /Descent -234  /Flags 34  /FontBBox [ -170 -240 996 935 ]  /FontName /TimesTen-Roman  /ItalicAngle 0  /StemV 88  /XHeight 470  endobj 8 0 obj /Type /Font  /Subtype /Type1  /Name /F11  /FirstChar 32  /LastChar 255  /Widths [ 250 333 500 500 500 1000 833 278 389 389 500 600 250 333 250 278  500 500 500 500 500 500 500 500 500 500 250 250 600 600 600 500  800 838 722 722 833 722 611 833 833 389 444 778 667 944 778 833  611 833 778 556 667 833 778 1000 778 778 722 333 278 333 600 500  278 500 556 444 556 500 333 500 556 278 278 556 278 833 556 556  556 556 389 389 333 556 500 722 500 500 444 333 222 333 600 250  838 838 722 722 778 833 833 500 500 500 500 500 500 444 500 500  500 500 278 278 278 278 556 556 556 556 556 556 556 556 556 556  500 400 500 500 500 500 600 556 800 800 990 278 278 0 1000 833 0  600 0 0 500 556 0 0 0 0 0 300 334 0 667 556 500 333 600 0 500 0  0 500 500 1000 250 838 838 833 1000 778 500 1000 500 500 278 278  600 0 500 778 167 500 333 333 556 556 500 250 278 500 1000 838 722  838 722 722 389 389 389 389 833 833 0 833 833 833 833 278 278 278  278 278 278 278 278 278 278 278 ]  /Encoding /MacRomanEncoding  /BaseFont /TimesTen-Roman  /FontDescriptor 7 0 R  endobj 9 0 obj /Type /Font  /Subtype /Type1  /Name /F17  /FirstChar 32  /LastChar 255  /Widths [ 333 333 500 660 667 1000 889 278 389 389 556 660 333 333 333 278  667 667 667 667 667 667 667 667 667 667 333 333 660 660 660 611  740 778 778 778 778 722 667 833 833 389 667 833 667 944 833 833  722 833 778 722 722 833 778 1000 778 778 722 389 278 389 660 500  333 667 667 667 667 667 389 667 667 333 333 667 333 1000 667 667  667 667 444 611 444 667 611 944 667 611 556 389 278 389 660 333  778 778 778 722 833 833 833 667 667 667 667 667 667 667 667 667  667 667 333 333 333 333 667 667 667 667 667 667 667 667 667 667  667 400 667 667 667 500 850 667 800 800 950 333 333 0 1000 833 0  660 0 0 667 667 0 0 0 0 0 400 400 0 1000 667 611 333 660 0 667 0  0 667 667 1000 333 778 778 833 1000 1000 500 1000 500 500 278 278  660 0 611 778 167 660 333 333 667 667 667 333 278 500 1000 778 722  778 722 722 389 389 389 389 833 833 0 833 833 833 833 333 333 333  333 333 333 333 333 333 333 333 ]  /Encoding /MacRomanEncoding  /BaseFont /Helvetica-Black  /FontDescriptor 10 0 R  endobj 10 0 obj /Type /FontDescriptor  /Ascent 720  /CapHeight 720  /Descent -178  /Flags 262176  /FontBBox [ -167 -232 1007 1013 ]  /FontName /Helvetica-Black  /ItalicAngle 0  /StemV 208  /XHeight 524  endobj 11 0 obj 1726  endobj 12 0 obj << /Filter /LZWDecode /Length 11 0 R >>  stream G#!AP 8k:Em #M21TU@ 5,3u@ &5`@5 ai!T8  UU8;Z Cm;RJ?Ulx) Ee6kj endstream endobj 13 0 obj 1722  endobj 14 0 obj << /Filter /LZWDecode /Length 13 0 R >>  stream cs|:D 3Z h^# _d%|PQ 5Ce,9 <sk;gO/8 endstream endobj 15 0 obj 1675  endobj 16 0 obj << /Filter /LZWDecode /Length 15 0 R >>  stream (.BFSY +KXQQ u%L3# Tu-OH SC:(3 "3/1/ ue%Kj 1unVK 9Ru6$ s`[L_, m%S@K endstream endobj 17 0 obj /Type /Font  /Subtype /Type1  /Name /F10  /FirstChar 32  /LastChar 255  /Widths [ 278 444 556 556 556 1000 833 278 389 389 556 600 278 389 278 389  556 556 556 556 556 556 556 556 556 556 278 278 600 600 600 500  800 778 722 722 833 722 667 833 833 444 500 778 667 944 778 833  667 833 778 556 667 778 778 944 722 667 722 389 389 389 600 500  278 556 556 444 556 444 333 500 556 333 333 556 333 833 556 556  556 556 389 389 333 556 500 722 500 500 444 333 222 333 600 278  778 778 722 722 778 833 778 556 556 556 556 556 556 444 444 444  444 444 333 333 333 333 556 556 556 556 556 556 556 556 556 556  556 400 556 556 556 500 620 556 800 800 1000 278 278 0 944 833 0  600 0 0 556 556 0 0 0 0 0 334 334 0 722 556 500 444 600 0 556 0  0 556 556 1000 278 778 778 833 1000 778 500 1000 556 556 278 278  600 0 500 667 167 556 278 278 556 556 556 278 278 556 1000 778 722  778 722 722 444 444 444 444 833 833 0 833 778 778 778 333 278 278  278 278 278 278 278 278 278 278 ]  /Encoding /MacRomanEncoding  /BaseFont /TimesTen-BoldItalic  /FontDescriptor 18 0 R  endobj 18 0 obj /Type /FontDescriptor  /Ascent 715  /CapHeight 690  /Descent -234  /Flags 262242  /FontBBox [ -174 -228 1051 951 ]  /FontName /TimesTen-BoldItalic  /ItalicAngle -15  /StemV 135  /XHeight 479  endobj 19 0 obj 1744  endobj 20 0 obj << /Filter /LZWDecode /Length 19 0 R >>  stream E\WT[" \W"Us @hq$% fRtiII IM2B3& sCRZ:n z7^jeV# u7/U? _m+E1 YI"/J> endstream endobj 21 0 obj 1340  endobj 22 0 obj << /Filter /LZWDecode /Length 21 0 R >>  stream B`c1p F)1XL ut/[1 Ox83` endstream endobj 23 0 obj /Type /Font  /Subtype /Type1  /Name /F16  /FirstChar 32  /LastChar 255  /Widths [ 250 333 500 500 500 1000 833 278 389 389 466 600 250 333 250 278  500 500 500 500 500 500 500 500 500 500 250 250 600 600 600 500  800 778 722 722 833 722 611 833 833 389 444 778 722 944 778 833  667 833 722 556 667 778 722 944 778 722 722 389 278 389 600 500  333 500 556 444 556 444 333 500 556 278 278 556 278 833 556 556  556 556 389 389 278 556 500 722 500 500 500 389 222 389 600 250  778 778 722 722 778 833 778 500 500 500 500 500 500 444 444 444  444 444 278 278 278 278 556 556 556 556 556 556 556 556 556 556  500 400 500 500 500 500 600 556 800 800 990 333 333 0 944 833 0  600 0 0 500 556 0 0 0 0 0 300 334 0 722 556 500 333 600 0 500 0  0 500 500 1000 250 778 778 833 944 722 500 1000 500 500 278 278  600 0 500 722 167 500 333 333 556 556 500 250 278 500 1000 778 722  778 722 722 389 389 389 389 833 833 0 833 778 778 778 278 333 333  333 333 333 333 333 333 333 333 ]  /Encoding /MacRomanEncoding  /BaseFont /TimesTen-Italic  /FontDescriptor 24 0 R  endobj 24 0 obj /Type /FontDescriptor  /Ascent 715  /CapHeight 690  /Descent -234  /Flags 98  /FontBBox [ -169 -225 1015 928 ]  /FontName /TimesTen-Italic  /ItalicAngle -15  /StemV 85  /XHeight 465  endobj 25 0 obj /Type /Font  /Subtype /Type1  /Name /F15  /Encoding /MacRomanEncoding  /BaseFont /Helvetica  endobj 26 0 obj 1303  endobj 27 0 obj << /Filter /LZWDecode /Length 26 0 R >>  stream KlOn: -M+iXN DJ3iA a,q1R s)<1h endstream endobj 28 0 obj /Type /Font  /Subtype /Type1  /Name /F14  /FirstChar 32  /LastChar 255  /Widths [ 250 333 250 500 500 833 667 250 333 333 500 500 250 333 250 278 500  500 500 500 500 500 500 500 500 500 250 250 500 500 500 500 800  556 556 556 611 500 444 611 611 278 444 556 500 778 611 611 556  611 611 556 500 611 556 833 556 556 500 333 250 333 500 500 333  444 500 444 500 444 278 500 500 222 222 444 222 778 500 500 500  500 333 444 278 500 444 667 444 444 389 274 250 274 500 250 556  556 556 500 611 611 611 444 444 444 444 444 444 444 444 444 444  444 222 222 222 222 500 500 500 500 500 500 500 500 500 500 500  400 500 500 500 333 440 500 800 800 750 333 333 0 833 611 0 500  0 0 500 500 0 0 0 0 0 300 300 0 667 500 500 333 500 0 500 0 0 500  500 1000 250 556 556 611 833 722 500 1000 389 389 222 222 500 0  444 556 167 500 278 278 500 500 500 250 222 389 1111 556 500 556  500 500 278 278 278 278 611 611 0 611 611 611 611 222 333 333 333  333 250 250 333 333 333 333 ]  /Encoding /MacRomanEncoding  /BaseFont /Helvetica-Condensed  /FontDescriptor 31 0 R  endobj 29 0 obj /Type /FontDescriptor  /Ascent 750  /CapHeight 750  /Descent -189  /Flags 262176  /FontBBox [ -169 -250 1091 991 ]  /FontName /Helvetica-Condensed-Bold  /ItalicAngle 0  /StemV 130  /XHeight 564  endobj 30 0 obj /Type /Font  /Subtype /Type1  /Name /F12  /FirstChar 32  /LastChar 255  /Widths [ 250 333 333 500 500 833 667 250 333 333 500 500 333 333 333 278 500  500 500 500 500 500 500 500 500 500 278 278 500 500 500 500 833  556 556 556 611 500 500 611 611 278 444 556 500 778 611 611 556  611 611 556 500 611 556 833 556 556 500 333 250 333 500 500 333  500 500 444 500 500 278 500 500 278 278 444 278 778 500 500 500  500 333 444 278 500 444 667 444 444 389 274 250 274 500 250 556  556 556 500 611 611 611 500 500 500 500 500 500 444 500 500 500  500 278 278 278 278 500 500 500 500 500 500 500 500 500 500 500  400 500 500 500 420 550 500 830 830 860 333 333 0 778 611 0 500  0 0 500 500 0 0 0 0 0 300 300 0 722 500 500 333 500 0 500 0 0 500  500 1000 250 556 556 611 833 722 500 1000 500 500 278 278 500 0  444 556 167 500 278 278 500 500 500 333 278 500 1111 556 500 556  500 500 278 278 278 278 611 611 0 611 611 611 611 278 333 333 333  333 333 333 333 333 333 333 ]  /Encoding /MacRomanEncoding  /BaseFont /Helvetica-Condensed-Bold  /FontDescriptor 29 0 R  endobj 31 0 obj /Type /FontDescriptor  /Ascent 750  /CapHeight 750  /Descent -189  /Flags 32  /FontBBox [ -174 -250 1071 990 ]  /FontName /Helvetica-Condensed  /ItalicAngle 0  /StemV 79  /XHeight 556  endobj 32 0 obj 1534  endobj 33 0 obj << /Filter /LZWDecode /Length 32 0 R >>  stream C8l0@m jm#Ohu7<%. UeO"+ 6_7ohs1 yK#R7n vhhkc!s ~DcH-Q $CJ[Ki= endstream endobj 34 0 obj 1565  endobj 35 0 obj << /Filter /LZWDecode /Length 34 0 R >>  stream Pa;SM rG#}xp(;Xo V4b@85. k-)c; endstream endobj 36 0 obj << /Type /XObject /Subtype /Image /Name /Im3 /Width 220 /Height 153  /BitsPerComponent 8 /ColorSpace /DeviceRGB /Length 8249 /Filter /DCTDecode >>  stream Adobe #"""#'''''''''' !! !!'''''''''' 7GWgw 8HXhx )9IYiy *:JZjz 'dtU7 8HXhx 9IYiy *:JZjz 3Ajnf u{IY&f c~B?D UPV7eV {oZOM mdFYC cYcW<x|J Y\Mg1 =W#7^` _Ux}V L$K}T &nnjI Qob_Q q;0<Z4 6l(vl 6l)vF ZWl~l u*}N~M $D}"C z+u?. {)+rA %\QUT E3GN% be#VI r5s{. gZO#a 6l)vl kkq5X ^AJ;Z  mH[#XMlm mlY@, W9~lU W9~lU W9~lU endstream endobj 37 0 obj << /Type /XObject /Subtype /Image /Name /Im4 /Width 125 /Height 104  /BitsPerComponent 8 /ColorSpace /DeviceRGB /Length 4596 /Filter /DCTDecode >>  stream Adobe #"""#'''''''''' !! !!'''''''''' 7GWgw 8HXhx )9IYiy *:JZjz 'dtU7 8HXhx 9IYiy *:JZjz Fn@-) V~`(: ZgyC;< i^4gX 2O@9: -<k#G% ms|C\ D7cJ# HiDgP Y[Ewm ?FHz|2 |U P= (#nt" khZVz )D$%cE dYZh$ {g?=> endstream endobj 38 0 obj << /Type /XObject /Subtype /Image /Name /Im5 /Width 222 /Height 179  /BitsPerComponent 8 /ColorSpace /DeviceRGB /Length 14276 /Filter /DCTDecode >>  stream Adobe #"""#'''''''''' !! !!'''''''''' 7GWgw 8HXhx )9IYiy *:JZjz 'dtU7 8HXhx 9IYiy *:JZjz qu<hq ie^knM8 $lac' ORWDN6  tc"! $xbd; IQRJ|. (&- %J =1{/8G: B*|(p!C Djw2n~ =}0G:v )E Wzf f}5[g,j s,p\C 3C_rF2 %{}8u- 8Cacq &'`OJ 4invw UZ^s3 1[JmB]3[ "zeO" )a^K" #s"7( O#nve UcW)* B%7qR `6?,. .",mm -=$@8 BopM$ *rp.ZBS Xgi4P~ RIREyR m>9n&2L bs$Zw iz=EA B\KV.* 2)Z/& >Aynd\# {n(kL [)^,dB SjWl1 }nnb{  $n~  J)j|E Dg*(CF u+Y!g5 M~>)V> #[$%U <>}!"y WtnL*I endstream endobj 39 0 obj /Type /Halftone  /HalftoneType 1  /Frequency 63.246  /Angle 161.565  /SpotFunction /Round  endobj 40 0 obj /Type /Halftone  /HalftoneType 1  /Frequency 63.246  /Angle 108.435  /SpotFunction /Round  endobj 41 0 obj /Type /Halftone  /HalftoneType 1  /Frequency 66.667  /Angle 90  /SpotFunction /Round  endobj 42 0 obj /Type /Halftone  /HalftoneType 1  /Frequency 70.711  /Angle 135  /SpotFunction /Round  endobj 43 0 obj /Type /Halftone  /HalftoneType 5  /Red 39 0 R  /Green 40 0 R  /Blue 41 0 R  /Gray 42 0 R  /Cyan 39 0 R  /Magenta 40 0 R  /Yellow 41 0 R  /Black 42 0 R  /Default 42 0 R  endobj 44 0 obj /Type /ExtGState  /SA false  /OP true  /HT 43 0 R  endobj 45 0 obj /Type /ExtGState  /SA false  /OP false  /HT 43 0 R  endobj 46 0 obj /Type /ExtGState  /SA true  /OP false  /HT 43 0 R  endobj 1 0 obj /Type /Pages  /Kids [ 5 0 R ]  /Count 1  endobj 2 0 obj /CreationDate (D:19981218111910) /Producer (Acrobat Distiller 3.01 for Power Macintosh) /Author (Mike) /Creator (QuarkXPress\252 4.04: PSPrinter 8.3) /Title (9590.2 CoverWrap) /ModDate (D:19990104122042) endobj 0000000000 65535 f 0000051778 00000 n 0000051842 00000 n trailer /Size 3 /ID[<2a671c3038777b189f25b369d968cb8d><2a671c3038777b189f25b369d968cb8d>] startxref %%EOF %%EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\ca\setup.ini ===
[Startup]
AppName=Real World Interface for Windows 2000
FreeDiskSpace=542
EnableLangDlg=Y
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\compuware\setup.ini ===
[Startup]
AppName=EcoTOOLS Windows2000 Instruments
FreeDiskSpace=509
EnableLangDlg=Y
[ISUPDATE]
UpdateURL=http://
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\hp\localized\alphaenglish\setup\setup.ini ===
[Startup]
AppName=ManageX
FreeDiskSpace=1986
EnableLangDlg=Y
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\hp\localized\alphafrench\setup\setup.ini ===
[Startup]
AppName=ManageX
FreeDiskSpace=2007
EnableLangDlg=Y
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\bmc\wbprn1000.pdf ===
%PDF-1.2 1 0 obj /Type /XObject /Subtype /Image /Name /Im1 /Width 324 /Height 165 /BitsPerComponent 1 /ColorSpace /DeviceGray /Length 871 /Filter /CCITTFaxDecode /DecodeParms << /K -1 /Columns 324>> stream kaDDA endstream endobj 2 0 obj /Type /XObject /Subtype /Image /Name /Im2 /Width 151 /Height 167 /BitsPerComponent 8 /ColorSpace /DeviceRGB /Length 10661 /Filter /DCTDecode stream Adobe #"""#'''''''''' !! !!'''''''''' 7GWgw 8HXhx )9IYiy *:JZjz 'dtU7 8HXhx 9IYiy *:JZjz +YyB[}N {?.+XZ r>|G{uR \K nM `Fy;; Dtho0 9sNY$y KVSFV `~Dgw 0bGx; G<RA2 ?MchZ ILcvbI TfVtGVN` t)^D{dg 'n]>oh s6@?/ Jq`!f G^Ny# 4>F[+^7W 5+/3j^c ufPv*~ O-Yi:w Fy!9x YXmTn9 x"qN9I ;xX^:t, ~ZySU bdyDH QDr=P 5Y|#; G@".7 h@uo% s<h"G q{O-Oy j;zly /uk}v pT)%~ &\Y}q yWKL# :l91m! NaXru! S22i0 EqPds 1@{dgY< qrp~b>/. (h~%m A$b}V 0i7>q T}9~z %oM@_ endstream endobj 4 0 obj /Length 3125 /Filter /FlateDecode stream EKj$Q eFsq-, Gj0\^ !vr$(+xW 7ot(8 4E6ta A[g#4 8c&5J iZ+SUnD BKR']0C x$&2? 94fEB wPdp/M kIO6,] Y9\?_ %>J)a >TKn" y-wWa vMRh~ q83+j endstream endobj 5 0 obj /ProcSet [/PDF /Text /ImageB /ImageC ] /Font << /F1 6 0 R /F2 7 0 R /F3 8 0 R /F4 9 0 R /F5 10 0 R /F6 11 0 R /F7 12 0 R /F8 13 0 R /XObject << /Im1 1 0 R /Im2 2 0 R /ExtGState << /GS1 14 0 R endobj 17 0 obj /Length 2021 /Filter /FlateDecode stream U30W]le_ >eVs(&9 Z/iYf %fAp`u+\- @ljuh ^twO2 FDF&uD,J SFr^ 5 @YY 2K endstream endobj 18 0 obj /ProcSet [/PDF /Text ] /Font << /F1 6 0 R /F3 8 0 R /F4 9 0 R /F5 10 0 R /F6 11 0 R /ExtGState << /GS1 14 0 R endobj 20 0 obj /Length 2864 /Filter /FlateDecode stream eXf$5-L NO$`m hJ ZA Lx/1o 7\;)K c4vM_ NH0G1R -rJtd }+o^K .c=J~D$Ur m?2dr Gpggm+ f-My  4Hs$3 D4U03 endstream endobj 21 0 obj /ProcSet [/PDF /Text ] /Font << /F1 6 0 R /F2 7 0 R /F3 8 0 R /F5 10 0 R /F6 11 0 R /F9 22 0 R /ExtGState << /GS1 14 0 R endobj 24 0 obj /Length 2417 /Filter /FlateDecode stream >$%Y" 0{zk8 +#Q:1cl~ ;aPaT z?B8~H XjWV2 *~1>. #?NFV endstream endobj 25 0 obj /ProcSet [/PDF /Text ] /Font << /F1 6 0 R /F2 7 0 R /F5 10 0 R /F6 11 0 R /F9 22 0 R /ExtGState << /GS1 14 0 R endobj 27 0 obj /Length 2836 /Filter /FlateDecode stream mEOn- hKuaA n/|Vp ojwSv !?FaH yNkY2 ;rlhY\ {]+fV WT!+- 1bcbO DrrD(f 162'n@ R?am& C%eVBD *]HG4 endstream endobj 28 0 obj /ProcSet [/PDF /Text ] /Font << /F1 6 0 R /F3 8 0 R /F4 9 0 R /F5 10 0 R /F6 11 0 R /F7 12 0 R /F9 22 0 R /ExtGState << /GS1 14 0 R endobj 30 0 obj /Length 2526 /Filter /FlateDecode stream csa3l :&SW_ F'+@x P*3.gCO  A~P[Jd ~@'8}8 61C2- 8ce3} IaYlh '*Eps Is~M! XZnQ9 E#G=/{. endstream endobj 31 0 obj /ProcSet [/PDF /Text ] /Font << /F1 6 0 R /F3 8 0 R /F5 10 0 R /F8 13 0 R /F9 22 0 R /ExtGState << /GS1 14 0 R endobj 32 0 obj /Type /Halftone /HalftoneType 1 /HalftoneName (Default) /Frequency 60 /Angle 45 /SpotFunction /Round endobj 14 0 obj /Type /ExtGState /SA false /OP false /HT /Default endobj 6 0 obj /Type /Font /Subtype /Type1 /Name /F1 /BaseFont /Helvetica endobj 7 0 obj /Type /Font /Subtype /Type1 /Name /F2 /Encoding 33 0 R /BaseFont /Helvetica endobj 8 0 obj /Type /Font /Subtype /Type1 /Name /F3 /BaseFont /Times-Roman endobj 9 0 obj /Type /Font /Subtype /Type1 /Name /F4 /Encoding 33 0 R /BaseFont /Times-Roman endobj 10 0 obj /Type /Font /Subtype /Type1 /Name /F5 /BaseFont /Helvetica-Bold endobj 11 0 obj /Type /Font /Subtype /Type1 /Name /F6 /Encoding 33 0 R /BaseFont /Helvetica-Bold endobj 12 0 obj /Type /Font /Subtype /Type1 /Name /F7 /BaseFont /Times-Italic endobj 13 0 obj /Type /Font /Subtype /Type1 /Name /F8 /BaseFont /Times-Bold endobj 22 0 obj /Type /Font /Subtype /Type1 /Name /F9 /BaseFont /Courier endobj 33 0 obj /Type /Encoding /Differences [ 0/grave/acute/circumflex/tilde/macron/breve/dotaccent/dieresis /ring/cedilla/hungarumlaut/ogonek/caron/dotlessi/fi/fl /Lslash/lslash/Zcaron/zcaron/minus 39/quotesingle 96/grave 130/quotesinglbase /florin/quotedblbase/ellipsis/dagger/daggerdbl/circumflex/perthousand/Scaron /guilsinglleft/OE 145/quoteleft/quoteright/quotedblleft/quotedblright/bullet/endash /emdash/tilde/trademark/scaron/guilsinglright/oe 159/Ydieresis 164/currency  166/brokenbar 168/dieresis/copyright/ordfeminine 172/logicalnot/hyphen/registered/macron /degree/plusminus/twosuperior/threesuperior/acute/mu 183/periodcentered/cedilla /onesuperior/ordmasculine 188/onequarter/onehalf/threequarters 192/Agrave/Aacute/Acircumflex /Atilde/Adieresis/Aring/AE/Ccedilla/Egrave/Eacute/Ecircumflex /Edieresis/Igrave/Iacute/Icircumflex/Idieresis/Eth/Ntilde/Ograve /Oacute/Ocircumflex/Otilde/Odieresis/multiply/Oslash/Ugrave/Uacute /Ucircumflex/Udieresis/Yacute/Thorn/germandbls/agrave/aacute/acircumflex /atilde/adieresis/aring/ae/ccedilla/egrave/eacute/ecircumflex /edieresis/igrave/iacute/icircumflex/idieresis/eth/ntilde/ograve /oacute/ocircumflex/otilde/odieresis/divide/oslash/ugrave/uacute /ucircumflex/udieresis/yacute/thorn/ydieresis endobj 3 0 obj /Type /Page /Parent 15 0 R /Resources 5 0 R /Contents 4 0 R endobj 16 0 obj /Type /Page /Parent 15 0 R /Resources 18 0 R /Contents 17 0 R endobj 19 0 obj /Type /Page /Parent 15 0 R /Resources 21 0 R /Contents 20 0 R endobj 23 0 obj /Type /Page /Parent 15 0 R /Resources 25 0 R /Contents 24 0 R endobj 26 0 obj /Type /Page /Parent 15 0 R /Resources 28 0 R /Contents 27 0 R endobj 29 0 obj /Type /Page /Parent 15 0 R /Resources 31 0 R /Contents 30 0 R endobj 15 0 obj /Type /Pages /Kids [3 0 R 16 0 R 19 0 R 23 0 R 26 0 R 29 0 R] /Count 6 /MediaBox [0 0 612 792] endobj 34 0 obj /Type /Catalog /Pages 15 0 R endobj 35 0 obj /CreationDate (D:19990407103727) /Producer (\376\377\000A\000c\000r\000o\000b\000a\000t\000 \000D\000i\000s\000t\000i\000l\000l\000e\000r\000 \0003\000.\0000\0002) /Creator (Windows NT 4.0) /Title (Untitled Document) endobj 0000000000 65535 f 0000000017 00000 n 0000001125 00000 n 0000031660 00000 n 0000011980 00000 n 0000015185 00000 n 0000029514 00000 n 0000029602 00000 n 0000029708 00000 n 0000029798 00000 n 0000029906 00000 n 0000030000 00000 n 0000030112 00000 n 0000030204 00000 n 0000029434 00000 n 0000032209 00000 n 0000031749 00000 n 0000015429 00000 n 0000017531 00000 n 0000031841 00000 n 0000017684 00000 n 0000020629 00000 n 0000030294 00000 n 0000031933 00000 n 0000020794 00000 n 0000023292 00000 n 0000032025 00000 n 0000023446 00000 n 0000026363 00000 n 0000032117 00000 n 0000026540 00000 n 0000029147 00000 n 0000029301 00000 n 0000030381 00000 n 0000032334 00000 n 0000032391 00000 n trailer /Size 36 /Root 34 0 R /Info 35 0 R /ID [<db325bfcc6c73d2ceb850bd8d5585b79><db325bfcc6c73d2ceb850bd8d5585b79>] startxref 32638 %%EOF %%EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\hp\localized\alphaspanish\setup\setup.ini ===
[Startup]
AppName=ManageX
FreeDiskSpace=1999
EnableLangDlg=Y
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\hp\localized\alphagerman\setup\setup.ini ===
[Startup]
AppName=ManageX
FreeDiskSpace=2005
EnableLangDlg=Y
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\hp\localized\alphajapanese\setup\setup.ini ===
[Startup]
AppName=ManageX
FreeDiskSpace=1994
EnableLangDlg=Y
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\hp\localized\x86french\setup\setup.ini ===
[Startup]
AppName=ManageX
FreeDiskSpace=1323
EnableLangDlg=Y
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\hp\localized\x86english\setup\setup.ini ===
[Startup]
AppName=ManageX
FreeDiskSpace=1302
EnableLangDlg=Y
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\hp\localized\x86german\setup\setup.ini ===
[Startup]
AppName=ManageX
FreeDiskSpace=1322
EnableLangDlg=Y
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\hp\localized\x86japanese\setup\setup.ini ===
[Startup]
AppName=ManageX
FreeDiskSpace=1297
EnableLangDlg=Y
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\hp\setup\setup.ini ===
[Startup]
AppName=ManageX
FreeDiskSpace=1302
EnableLangDlg=Y
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\netiq\i386\setup.ini ===
[Startup]
AppName=NetIQ WMI Agent
FreeDiskSpace=2360
EnableLangDlg=Y
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\hp\localized\x86spanish\setup\setup.ini ===
[Startup]
AppName=ManageX
FreeDiskSpace=1315
EnableLangDlg=Y
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\tivoli\setup.ini ===
[Startup]
AppName=Tivoli Management Agent
FreeDiskSpace=1352
16on16=N
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\tivoli\setup.log ===
[InstallShield Silent]
Version=v3.00.000
File=Log File
[Application]
Name=Lcfd
Version=4
Company=Tivoli
[ResponseResult]
ResultCode=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\tivoli\w32-ix86.txt ===
----------------------------------------------------------------------------

 Tivoli Management Environment (TME 10) Endpoint*

				   for

                       Microsoft Windows NT 3.5x,4.0 and Windows 2000*

----------------------------------------------------------------------------



TME 10 Endpoint (LCF) is a lightweight client framework which allows limited invocation

of methods within the Tivoli Framework.  LCF consists of the LCFd (a long

running daemon-like NT service) and the LCF software development kit

(a collection of libraries and headers for development of LCF methods).



Firewall support:



The TME10 Endpoint client will not work correctly through firewalls.

Most firewall software products (like SOCKS4 and SOCKS5) allow you to

configure the client to bypass the firewall when interacting with machines

local to the client.  Please consult the documentation for your firewall

software for more details.



----------------------------------------------------------------------------

* TME 10 and LCF are trademarks of Tivoli Systems, a division of IBM Corp.

  Windows is a trademark of Microsoft Corp.

----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\valuadd\agents\bmc\wbpi1000.pdf ===
%PDF-1.2 1162 0 obj /Linearized 1  /O 1167  /H [ 1392 822 ]  /L 453726  /E 219060  /N 31  /T 430366  endobj                                                   xref 1162 36  0000000016 00000 n 0000001075 00000 n 0000001260 00000 n 0000001293 00000 n 0000001349 00000 n 0000002214 00000 n 0000002394 00000 n 0000002464 00000 n 0000002578 00000 n 0000002691 00000 n 0000002893 00000 n 0000003087 00000 n 0000003202 00000 n 0000003345 00000 n 0000003498 00000 n 0000003654 00000 n 0000003836 00000 n 0000003964 00000 n 0000004094 00000 n 0000004285 00000 n 0000004411 00000 n 0000004546 00000 n 0000004680 00000 n 0000004798 00000 n 0000004985 00000 n 0000005116 00000 n 0000005236 00000 n 0000005424 00000 n 0000005481 00000 n 0000005785 00000 n 0000007092 00000 n 0000007206 00000 n 0000007286 00000 n 0000008337 00000 n 0000001392 00000 n 0000002191 00000 n trailer /Size 1198 /Info 1156 0 R  /Root 1163 0 R  /Prev 430354  /ID[<fb4ff55abc4d4c26d4effc98fdceefb9><fb4ff55abc4d4c26d4effc98fdceefb9>] startxref %%EOF 1163 0 obj /Type /Catalog  /Pages 1158 0 R  /Outlines 1168 0 R  /Threads 1164 0 R  /Names 1166 0 R  /OpenAction [ 1167 0 R /XYZ null null null ]  /PageMode /UseOutlines  endobj 1164 0 obj 1165 0 R  endobj 1165 0 obj /I << /Title (A)>>  /F 2 0 R  endobj 1166 0 obj /Dests 1155 0 R  endobj 1196 0 obj << /S 562 /T 755 /O 844 /E 860 /Filter /FlateDecode /Length 1197 0 R >>  stream GzM7Te {sBhR $z;^< endstream endobj 1197 0 obj endobj 1167 0 obj /Type /Page  /Parent 1157 0 R  /Resources 1188 0 R  /Contents 1190 0 R  /CropBox [ 53 72 558 720 ]  /Thumb 263 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 1168 0 obj /Count 19  /First 1169 0 R  /Last 1170 0 R  endobj 1169 0 obj /Title (Contents) /Dest [ 9 0 R /XYZ null 711 null ]  /Parent 1168 0 R  /Next 1177 0 R  endobj 1170 0 obj /Title (Index) /Dest [ 117 0 R /XYZ null 689 null ]  /Parent 1168 0 R  /Prev 1171 0 R  endobj 1171 0 obj /Title (PATROL Adapter for WBEM Installation) /Dest [ 69 0 R /XYZ null 711 null ]  /Parent 1168 0 R  /Prev 1172 0 R  /Next 1170 0 R  /First 1173 0 R  /Last 1174 0 R  /Count 4  endobj 1172 0 obj /Title (Preinstallation Requirements) /Dest [ 50 0 R /XYZ null 711 null ]  /Parent 1168 0 R  /Prev 1177 0 R  /Next 1171 0 R  /First 1178 0 R  /Last 1179 0 R  /Count 5  endobj 1173 0 obj /Title (Overview) /Dest [ 76 0 R /XYZ null 810 null ]  /Parent 1171 0 R  /Next 1176 0 R  endobj 1174 0 obj /Title (Uninstalling on a Windows NT System) /Dest [ 111 0 R /XYZ null 810 null ]  /Parent 1171 0 R  /Prev 1175 0 R  endobj 1175 0 obj /Title (Windows NT Installation Files) /Dest [ 101 0 R /XYZ null 678 null ]  /Parent 1171 0 R  /Prev 1176 0 R  /Next 1174 0 R  endobj 1176 0 obj /Title (Installing on a Windows NT System) /Dest [ 76 0 R /XYZ null 710 null ]  /Parent 1171 0 R  /Prev 1173 0 R  /Next 1175 0 R  endobj 1177 0 obj /Title (About This Guide) /Dest [ 28 0 R /XYZ null 711 null ]  /Parent 1168 0 R  /Prev 1169 0 R  /Next 1172 0 R  /First 1183 0 R  /Last 1184 0 R  /Count 5  endobj 1178 0 obj /Title (Installation Overview) /Dest [ 58 0 R /XYZ null 810 null ]  /Parent 1172 0 R  /Next 1180 0 R  endobj 1179 0 obj /Title (Installation Components) /Dest [ 62 0 R /XYZ null 704 null ]  /Parent 1172 0 R  /Prev 1180 0 R  endobj 1180 0 obj /Title (Installation Requirements) /Dest [ 58 0 R /XYZ null 697 null ]  /Parent 1172 0 R  /Prev 1178 0 R  /Next 1179 0 R  /First 1181 0 R  /Last 1182 0 R  /Count 2  endobj 1181 0 obj /Title (System Requirements) /Dest [ 58 0 R /XYZ null 588 null ]  /Parent 1180 0 R  /Next 1182 0 R  endobj 1182 0 obj /Title (PATROL Component Requirement) /Dest [ 62 0 R /XYZ null 810 null ]  /Parent 1180 0 R  /Prev 1181 0 R  endobj 1183 0 obj /Title (How This Guide Is Organized) /Dest [ 31 0 R /XYZ null 810 null ]  /Parent 1177 0 R  /Next 1185 0 R  endobj 1184 0 obj /Title (Conventions) /Dest [ 44 0 R /XYZ null 810 null ]  /Parent 1177 0 R  /Prev 1185 0 R  endobj 1185 0 obj /Title (Related Documentation) /Dest [ 31 0 R /XYZ null 615 null ]  /Parent 1177 0 R  /Prev 1183 0 R  /Next 1184 0 R  /First 1186 0 R  /Last 1187 0 R  /Count 2  endobj 1186 0 obj /Title (Online and Printed Books) /Dest [ 31 0 R /XYZ null 496 null ]  /Parent 1185 0 R  /Next 1187 0 R  endobj 1187 0 obj /Title (Release Notes) /Dest [ 41 0 R /XYZ null 686 null ]  /Parent 1185 0 R  /Prev 1186 0 R  endobj 1188 0 obj /ProcSet [ /PDF /Text /ImageC /ImageI ]  /Font << /F2 1192 0 R >>  /XObject << /Im1 1195 0 R >>  /ExtGState << /GS1 1193 0 R >>  /ColorSpace << /CS1 1189 0 R >>  endobj 1189 0 obj /Indexed /DeviceRGB 255 1194 0 R  endobj 1190 0 obj << /Length 228 /Filter /FlateDecode >>  stream $KlZY 8V_S= endstream endobj 1191 0 obj /Type /Encoding  /Differences [ 39 /quotesingle 96 /grave 128 /Adieresis /Aring /Ccedilla /Eacute  /Ntilde /Odieresis /Udieresis /aacute /agrave /acircumflex /adieresis  /atilde /aring /ccedilla /eacute /egrave /ecircumflex /edieresis  /iacute /igrave /icircumflex /idieresis /ntilde /oacute /ograve  /ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex /udieresis  /dagger /.notdef 164 /section /bullet /paragraph /germandbls /registered  /copyright /trademark /acute /dieresis /.notdef /AE /Oslash 177  /.notdef /.notdef /.notdef /yen 182 /.notdef /.notdef /.notdef /.notdef  /.notdef /ordfeminine /ordmasculine /.notdef /ae /oslash /questiondown  /exclamdown /logicalnot /.notdef /florin /.notdef /.notdef /guillemotleft  /guillemotright /ellipsis /.notdef /Agrave /Atilde /Otilde /OE /oe  /endash /emdash /quotedblleft /quotedblright /quoteleft /quoteright  216 /ydieresis /Ydieresis /fraction /currency /guilsinglleft /guilsinglright  /fi /fl /daggerdbl /periodcentered /quotesinglbase /quotedblbase  /perthousand /Acircumflex /Ecircumflex /Aacute /Edieresis /Egrave  /Iacute /Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex 241  /Ograve /Uacute /Ucircumflex /Ugrave 246 /circumflex /tilde /macron  /breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron ]  endobj 1192 0 obj /Type /Font  /Subtype /Type1  /Name /F2  /Encoding 1191 0 R  /BaseFont /Helvetica-Bold  endobj 1193 0 obj /Type /ExtGState  /SA false  /OP false  /HT /Default  endobj 1194 0 obj << /Filter /ASCII85Decode /Length 973 >>  stream z!%@mJHN4&B!!'D,#S6tA+TMe]!"],1&>]@JJcI*J!%<?t.BNS&IfMJ/!($Yc;S<'6 !!$d7!/(=PMuWjk!!iQ)#QR0s!/q0p[0Roe#a><##QPDA]au#Q&/aRA.CB^AKFflX &2Enj9"bd.rt&AR&6eN6>5o.ZbRgTN&?PpL!!!iI(`4),(ch=-8kKqArtp+G(l[;g XT03`!$M=B+Xni`6N834rulI`+a`r,K_HXCrumoX+e8!ESGsbG!%26;.0'W&3NX`p s!bqf0`V2.+W)pWhD$b10iG\>;ZAJ9pG&N=0s1I1[/_qhs"V4]1!]MJf(V0Z3B::+ 3ElGCHd4X1;E;Gj3QD(Zec7_n!'YRq64a,`3@R9Tej<!S6@8GnXnP0-s$G9:6Jh`/ mf5r[!(nC78h'L,1&jj+@nK'S8kRr4;RK,#;G*eB9%FPGk5\C?!)d"O;If/nF+dG< pJQ[@;N0I1V2S=/!)i7c>%;>OA$oL!mom`f@p7GnHcBQ[X^dmiA*3i-!!$e$!,Gb9 CMVL:V<;o8@rlGKF.BXZkO3K\!..<<HZOO\F6@n'kBiH^HcDn/k5]klkBl[dKE)"* 0`Zl)0naUGKR95BK]e#Q`e9lNKWVq@^$gX;Xb>m+K^Snop[=&E!/u:!N/[4aP`1Qt mu4ZoN:.=:n'6md!0$rkN;pn^Pjaj,Pa(XfS=H+>V;@`=n!q):SAt#fpAh#i!2Zg" V;CsCn+Wrdn#amdXmZ7lp\2&q!4@I[[=jLHPQ8+n[C*]U[Ct/)HN:a43PD81^!=p: f&"+'!6,!=`aatIS3k5l>/m[B`jKm-]nFD=N6W7?cBL'/X]j#PF3_1?cFnSM]q!Bn `m3EacJIa8V#])K;V&OGf$9f:cE5[K^"2'7hF]fbcCEbB`noRthXBpr!!)2P+m5sV kNC^jPQ:0K!:S4Yn*f`>!!r<!)#(_Orr<'!V#^Ot!<<*!~> endstream endobj 1195 0 obj << /Type /XObject /Subtype /Image /Name /Im1 /Width 862 /Height 1100  /BitsPerComponent 8 /ColorSpace 1189 0 R /Length 210351 /Filter /FlateDecode >>  stream mL\^Z /++&+gk(a mvt%h 6}z(c U|9fk puB1Ju  NOzl u]&#o WWs+1 SDN!C K"KE,* ACYz7 8mEWH e-6N'I- ANq6'R "/A{O- zHiHZUF (!DZw1 GJU"S 9\Nk%+!_ T\Rjs !Xvn%Z ?~{).,P !q%p- hRIuk jD(cc W8w=_9V lQ*Dl0 ]8qmc @Yj6Dc ^}xqq ola<V $&c:l *e-O< g)[i*4[.] rA\4U [7(-,] zs5>/;` dC6XA w~Hk&[ HICMq I\IJo$ VC7"Sx dHx1a jhW9H #]RU%P #*cKW^ -a5T)C ^3<`l R"!>- [24c< byAwB k?Rj> [> PNhB ,;c+O4 )3Y70eV a#4A7 "2vXW _d0k/4 [{zq(4) (*[;R 7?u:LC XEX1K eOV_J 3W)u+ 3c|ua, 5KiXhH +K`Y* 9~\t!g ]&!qK ]RV.g hTV+" dIkEJ^ AwB4[^ #y]o~ h.O^hwv hxx||y .a.$w c(<I[4 lqs!a- ndO+S *YK~I Kf_/. k,DX[B .M8v+ nY&=;: Al)wM "w]J#[ Qn^)) [8?hwR A8vX\l. zHZG{ U7V7K 6MyBq Zt6Q,l Wo%Ciz. nnnV?` lECyC{I =/|zf I@31>> #^v<Yl !{4>mO ;/51\ @\ZX\ PVL]ir x)9x} U}6/g )XESfhq ii1Ag Q]9bk B\13! jP!5v \>'[d LkwM]m) 0_,!J `m(qA [qV1\y5 $wa2,JJ!tw x<[Dq fvP?< hwmk9 @WA?8 X"q1y ^2,d  IR2$wA <_][n \Em<. 4;;=;== @bv+p mw[C % TIJhh0U q8lL^~ Zj<{G U@^1A h-tW* Ms-ew {7/?y TXPi0 atr22zntb !_W(M $iHL#a b2d`9 $IZ;@ t!Y8i) %69vo p!Pj  :)8N{ L0{%P^ H}{hM9z M,1x- .(?KH {%b#I {)];[ PKRq%cM m.Zd% TDl8f xjjqqqy zwyyyqjq PyLHuu Bt|@D T.U|B, Zt`2zs kL^Mw% V+//OM &Z`.5 T*ULc )#A"tg 1c.3z| Fe?KXe qswIX ^/V/< JA6Jml `+Gl] xpqwm Z&AEk KR:-O i8ptQq 8fW*u ]][)##xz 5pt![ 0vWow //eD:d U`!.= \ozay X3,OM 2Dw%' <y~?] \(Xv> a+b1u Bp9`ep n*l;+ J/NNJw k261K >5./[8Po6 .l`(0 R1&{XZ6 #44<<, uRW;Z lu5=v {nZkz huwp] Tk4j+ *]M0R- mk]N. ycB}G S\5(/r 66D\\ \.c?& vD|%: Ax,vA h28[Zz Qp9Bv [rSVu ZH$qF h>*=- w9]\[ s?(}N*k yQ]6X" aX%s9 MEUn* ]aY&/V_^ `R[jz ]^uQ!~ pm-Wk .lr!3 KP=IZ Y+_*h ]R)K2 m_kssS I1[ pY ZLDBa z]^hC Bz[!SU^ Yboeu VXVbu ZxM72& LH,oM _0p4l; #];{@ 08!_P \:al}A" V][[pS _*WK% %J%PX ]htyu  !afa` RK[k< @HP$[` D0Dqa EPLB. ,Isar 9\gI& Yh|FB mn/#Y VS0/`v (eEePQu!x #H^_, )-~ydf 9pWyG &ePY{ <X%$u aEAgi*9P x|rpj %&#]A tIsCg qpm.3 &#bx]w [iCW5 `_[k'> 93|s>kd @Wn89 Q8Hp! y_^>Z aoMLJ `ZUmQq 3FKv! pcvt{b q;w^w=w mw}=# ix,Ysx$< 'N~c! v4F"upE Q|svU p]uMP VZG0D cuhIo]}i0 YZ(1OB\ <Ag,^ Y3ZR? <$~rw f`N[M 0\B}OQ2 MHk>7 Fs!Z3 i?i]xJ  os0x xBD-) 4S]Ft.:7 6kMU)`[\V jpJguz <X>5V',6i w_su9 `.*b: .=%R!T mS])s5 EvWC  VUU)] E1PnP M+Byp QQz"f w/~>) r-.@6\ ^0|s5 tA^sO55*Y 1w=_wx "jP'T giuiz ]iix.k LCkv<xs ?zkl, aiH7B B]GV1W 2fW7d ZZzT.. hCMCC seAQ4 Aa@J%k "E +> o7`qm $D]|F E1*?. BVIiK"! kk7.W. 5:zft%] )nJ^l] dk23P[[ !jmdh)< xPzU[ W,.<7u fdPTH [,\!Z 9W#b. HlXM* n}(la L'Gu! H2jPa Pz2T' #Bc.) Nhu1a A^]Z^ PGU>W| hlI-, Jf4K?I ,7Htm| Tq@]* 6u,-@% +@,$l p=4l[ t"_)U 1xj5- ryj!"= E>rCg 2_b|% BLm*DJC b&33tpD4bP [SipWC ]}@e(v  [A!bZY6 ,.BNV k4B?| |vgqnrl !V~#`(e@ &bc^& ],/2a:U r<jZa`CT `,;dT !.>~O 3!y+y<9N T/%S' WK;E6 gbcmB uq}sP 7~8<~i !j<D& .jdPW lex{l t-]K\q ;. l@ kVW}Ks 2zFcu z[Z`.y T*YCG %%\/^ WSPZ: 6{w/K <{Wl< .0wa) !9ZGc 6cjIU ke-:OD0t :zr^p yP3|i 3t]7Dt `J3!.- lWuM3 |5\]] @h;-B1 yF7r(\) u1Z. & "*XY7 .NM-y 1zUrh[ zwMz.}! &lm{S7. N%%.&E7 zsG+%=Zsw @."a1 `1;KA0o `,]GC" M!$R^ WF=L{0lR _N{I2NEX' *,qv^ uy;\{ uuV0$:  E|)V>tX^ TdCq[ UvVf% ;<zA  r^$CX  lS@V<B V6.<,Y joL>7KEr ,,d3F C<mmZDD=-b  [#NE U,]Fnc%O PAVRU CUM(N 23e3  Z(?[- }C+]M {8v=6 ?i;]_ 'gyHZ 455;; 2>$p2z !5Dyz .l];w 74dH!C |(zQf+Cp ( 4ho Z>OD2 RRHsv [x-ojyM ?KW|6 tC<U! yBiD F ]x JP @t|vn tBQh\R 'p(g0 C_7DW [MNFNY xux[c; d$LF8 _B]6[ i&g!7q v,RLG8n #^3GW M-]nw N6WG& w(jQf D8"<D (FI.E1 #4kfB|p2 H5#lX yxU\u5 WV"}ii) Y="C$@ X\(.p E@+Kq |/yaP z$D}K EjG?UdCU\ g22ZW |}X(c2, /kQh+ \k+V} $PUD*} uw_y8 H lTX bE6SF hG.hM nmoks _e<|uoT W]|:@ `rYJq ]K,I7Br! E6$w} =}_`# 5/CeH O[YYY; U0_v& u_V-f {LC6t pdD%C N`75i nd^oU A eCR 6Jz);e A4.i[ y0'_'ei ]R"L' 6(JDd ) tig l(tai -.Q*c& ,<7ic  HK[- 7u>U* A&lpP -j]#Q j@OS6 urWR0 ZYY}7f i|u%* wh\oe 77oR3,2!j xHXW< J$m$_ wQF@3 Vo8r4 u>L0$ DvQ3T) :DWu4Q 3%YN& .FG$CL] ]PU'f t:m4W C@V2+ 7O`@D V0h_v} A2D00bj}|]( fsYQ  @@+Uu{ {F@^j BE!X6 JBGfY H9&Z%h9 2]Y*WA t@[x1 j6&Dj_ wiTn`g <=ia2\ u`18- C`#.' ,h]+# (8Ot= *=rf= ,i[{. Hh#]C B"1E] ve2B_Q :`T`3 joa/R |xq|< ($Q#u ;QWIp5=y cc:"Z Rly!_ Nx!_. "|e;l V\)B2 A0\\$W a)k|1 ^`s><i m<6ts @u5DC bvRK| eYkSB,@ 9/x0> g_-we K*u+M ZZf|Y =3VN( aXh0R @06&Q ;aY/@ $;-&m ]3y!o,b<4 TH8b1L Mi*%K| (j_rF *eBqg{ Dt%D*d 5OtIC Wu<.R z'uT& uMT4X rTo}@ {N|M} f~a3U CXaQ3 |l-.Y uJ~)yA a82)L "b{4ke \LWM' 'MY!> }sk5p 3W^ , \WVVV FfV$]; d;_ae,: Y$T]+ bD|-f Jd(jt WrfwWwICU H\@+w) aE'sk ;!Q;8 |%&{, @a7uh oEBbkr2LtQ2l \he8$ Nm>uW (0N$. s$a[#s C<AO# ..bkhf uEwv$\ 766VW7 Wb#_jS '[4/' DR?cW 3<fD2 tQ8\YF. W&hOP yxA[9Q FquB\* Rp+o}2 St&jWy@f !O[@+ j5]Uy= *\MZW V(ssN *`j8y 9P)Nf O;c5& GLeBZ Ze&W*U +Ah%b 29)O<YE w:VVV kO|-XE GA=Kt Mb;dF kks{s #TV!> ?l\88^ Y<?#$I 0* y^GYA "EEs* i5qk? p8:Vn Wf-c"aF K<L[mh g8*tI p)]]l= Q5mZj* tW2|5T Wju]  77UO2 Z".?R (vm-*D KaO{Y( 2)|N/ar| bw9tIw9t |>)2" :HtU< U<,w=h \MyvO] &''X] `DI\b [`pLo 7EB;UV\ _lBd`X[ j<O|=> HM1)/ /C{/z 'QF~$ Ae mU VtMHw! Z!_dw7 ayy(#N apMOM YDkmss ad (z tDJg/ m7u+hX }mmA>< bacQk} \Hxa6 tiJ1$ K"i9l%m ^*,2iQ jA $s)- eBYJI< C!,Ah Jd-bKfl hB!@(![; Lx%Zl6 xlQCkQ IO XcL_c P] -\ <*l)m GQ(b{ ,90~R {(b!J /g96! gw}y#G FBW[Q< DMHd6 ZXhM< @U&Al% .{gkgs nTK$* Aa({]6 LQ MJ2 uKEBj\ ']7f+ ri'-| eI2$E e=uQ* tR')> CjI./u RQQovrR K [N*m {yxyc~M[K hA[Ih+ ElY`J bVjR%C {W6Ew -$7>z !QfBa  .B+F ?Ef:Oo %Kd@I Xhl0Y M2[<! W#)== M&$Z2 9R$F: 5.&qHrG1 hXQMK -B8TB `l``p CdCj_ 63k/m |=~M1 Z}v _ DkKkK o1PQ-(r e'aA_9 ,Z\o& p{XPV FL2F& _v!mfy .#_R_ DmXxkk#y $QaC  }>_(  )j[RW =xqKS =->Y * MK5b- 1{U.g ipmxhjSNE AhMx< %.]HN COuH<m V*IU+9 -8kpb G[E4, vl>dD 3QjEC E.ZZ$ L\cW= FO3cE -g?={ AIkm> t.1o2^ i-Xk<B n!q+a fs;eL u[3!% GxTykd j0_I*^ [{WR$C Q(tr"T mC/*^ !1l(= QUXZcR 6_,?{ KeCK]f 6M!L]r 4Q`+9yW0 hx+v' w[|=[ a'_Gu<l>z ZKO2# |)c]:uV 4wec7 -\X~X A]:fIT YIak$6 +c.cj VR{+U $O"!. 2X.L7 EgYh1 &Zq>=XR o)qxoI 4{kf"%uK +\!TU E6/-_ X+Sgk 1_{ui \%ChA /41$0 f(X+<V  jrH;S e2l7E^ zWw=U> *Nbal b3`+6ik j(ym${ "C-s! 1XI6t f kjx4c K'Ch0 ]5kjNu 5p:kg,s +!K_i E(.Hs 6;;+c `kbnF 9l5k"*6 p[Xrd& jFa)rW i~eYd? %iR09 3Nm*F Iuuc} %V.[5w/ "h^XEs }{iji l5]K` nAZ@+ |XaaU Z[[#g e3\.` )#ADG K@ Xm  _d>" u%eeBoI +6D}+ t$*-X V4z?6M ^n!<F sb>l?z f'Eq/e Q*$mE \{!_< *Ij"m wqY#w x;c;R CfkO}u }{M(Tv 9PAEt cGLdD b{-#  x.s`2<d 4eP8,$ A^pW& kP_.{Q q!'g}Y5 TYZ^} VwWbYY (Q%T(  3o}g5 h\ K( u7(K6 I@U3- V$|P} 3wMG#J6 wTpRd cU76q qeAPB q|*DY kAWiXkN !'a4 h] |%?_c Et1^L }E"b/ ^~a@^ 1R5T 2U"0J R+EUa )6$sk +=-I(AH blLcG W/ECN 8v.f+ *?To1^6& U`KK Y FDx!f#LV: m4!^|mz ;]._~} ![j*7 ->466y aXt/n^. t]lmihih8 c~bF$ zZO_7 /iCVC xN`&X !OTr, Q^Ilo &G_r3" 0E+JXN pnm.l^ wXv+] h9D,,6 5;[&y pX,NO ,.`k$92 )^S3S P`K 2 ObxI4 0)N#j pjd$9 7008$ D"a)R E)^P' SEJ_@`U PT:Qw t0Yh<. z@$[Gnh v|TMo 5QDy!\ /.uuvvr !\.~0 d8A~n ]p/r*, [ydkle V4_/> QtW/~ kkUbl I]83d kR8,y@ ak.AV J![9\ 1]yn]` D]Wfp &Z%d"^ U*.6]u Za$m+P 1u+&q K4${q DIH.Tu+ 0N}.^ ^(.,_ h8Ywa "/(-u [E\^1& h.38&y 5{2[b b|ikE _^(!\ "l*5f Zk4z5 .a+o^ qR%.ZK (hJ32 lrv/_ AElM8 h9+uxM] 39i:)S Wokpm 1B:_[ 7a3:1 \V]{B I*4W8 >vra^ 6hQ&L Ihyj-nq :Dl"l _}$|R [\.=. WIy_m o^PUma+ [V-l|-m E$LY[ w#g.i[$ vd9qI .*]$. eX[>d ruK^Ho!,g $]I1Z}_I* B0R`x AF,jGQ x-sP@ ZElQ$, >*\{YC9 nVEWW #]+mq(C 2Z(Cm] 'BbKR \#bq) 5!^3s =3w5>b jQ)la$, $Bb+k jw.-Bs p=<}z Du]}. Wua0\,W v8t{Sd X\ghY skY]W **US  -Ho^] -2"nlt P\pVOv BoA$$ v-pMa l5:4. Bdf5,5 k*33w dKc2D k"33w ^,pMdf uKGh1 endstream endobj 1 0 obj /Type /Page  /Parent 1157 0 R  /Resources 3 0 R  /Contents 4 0 R  /CropBox [ 53 72 558 720 ]  /B [ 2 0 R ]  /Thumb 265 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 2 0 obj /T 1165 0 R  /P 1 0 R  /R [ 81 94 513 657 ]  /V 261 0 R  /N 222 0 R  endobj 3 0 obj /ProcSet [ /PDF /Text /ImageC ]  /Font << /F2 1192 0 R /F4 221 0 R >>  /XObject << /Im2 5 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 4 0 obj << /Length 312 /Filter /FlateDecode >>  stream X Sa\ 5{ulrl 4+kmY- LPR"q endstream endobj 5 0 obj << /Type /XObject /Subtype /Image /Name /Im2 /Width 61 /Height 77 /BitsPerComponent 8  /ColorSpace /DeviceRGB /Length 2412 /Filter /DCTDecode >>  stream Adobe #"""#'''''''''' !! !!'''''''''' 7GWgw 8HXhx )9IYiy *:JZjz 'dtU7 8HXhx 9IYiy *:JZjz {d/6P .)N6/ L}\#a >>=?h GI!2t endstream endobj 6 0 obj /Type /Page  /Parent 1157 0 R  /Resources 7 0 R  /Contents 8 0 R  /CropBox [ 53 72 558 720 ]  /B [ 222 0 R ]  /Thumb 267 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 7 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F6 223 0 R /F8 224 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 8 0 obj << /Length 1569 /Filter /FlateDecode >>  stream `,DO_N 3`04! sip3u Q4U-r &f`X& sy*R2R Z>W8j mze~T? oJ^lq endstream endobj 9 0 obj /Type /Page  /Parent 1157 0 R  /Resources 23 0 R  /Contents 24 0 R  /CropBox [ 53 72 558 720 ]  /Annots [ 10 0 R 11 0 R 12 0 R 13 0 R 14 0 R 15 0 R 16 0 R 17 0 R 18 0 R 19 0 R  20 0 R 21 0 R 22 0 R ]  /B [ 225 0 R ]  /Thumb 269 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 10 0 obj /Dest (G4.8620) /Type /Annot  /Subtype /Link  /Rect [ 108 494 522 505 ]  /Border [ 0 0 0 ]  endobj 11 0 obj /Dest (G5.2951) /Type /Annot  /Subtype /Link  /Rect [ 108 468 522 479 ]  /Border [ 0 0 0 ]  endobj 12 0 obj /Dest (G5.7195) /Type /Annot  /Subtype /Link  /Rect [ 108 454 522 466 ]  /Border [ 0 0 0 ]  endobj 13 0 obj /Dest (G5.7203) /Type /Annot  /Subtype /Link  /Rect [ 108 441 522 453 ]  /Border [ 0 0 0 ]  endobj 14 0 obj /Dest (G5.7208) /Type /Annot  /Subtype /Link  /Rect [ 108 428 522 440 ]  /Border [ 0 0 0 ]  endobj 15 0 obj /Dest (G5.7243) /Type /Annot  /Subtype /Link  /Rect [ 108 415 522 427 ]  /Border [ 0 0 0 ]  endobj 16 0 obj /Dest (G5.7253) /Type /Annot  /Subtype /Link  /Rect [ 108 402 522 414 ]  /Border [ 0 0 0 ]  endobj 17 0 obj /Dest (G6.25958) /Type /Annot  /Subtype /Link  /Rect [ 108 377 522 388 ]  /Border [ 0 0 0 ]  endobj 18 0 obj /Dest (G6.28379) /Type /Annot  /Subtype /Link  /Rect [ 108 363 522 375 ]  /Border [ 0 0 0 ]  endobj 19 0 obj /Dest (G6.28399) /Type /Annot  /Subtype /Link  /Rect [ 108 350 522 362 ]  /Border [ 0 0 0 ]  endobj 20 0 obj /Dest (G6.28449) /Type /Annot  /Subtype /Link  /Rect [ 108 337 522 349 ]  /Border [ 0 0 0 ]  endobj 21 0 obj /Dest (G6.30407) /Type /Annot  /Subtype /Link  /Rect [ 108 324 522 336 ]  /Border [ 0 0 0 ]  endobj 22 0 obj /Dest (G7.7608) /Type /Annot  /Subtype /Link  /Rect [ 108 299 522 310 ]  /Border [ 0 0 0 ]  endobj 23 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 24 0 obj << /Length 730 /Filter /FlateDecode >>  stream >PC"N 0VPelF .[a`I WDTk" $G_9r !"O.=# endstream endobj 25 0 obj /Type /Page  /Parent 1157 0 R  /Resources 26 0 R  /Contents 27 0 R  /CropBox [ 53 72 558 720 ]  /B [ 226 0 R ]  /Thumb 271 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 26 0 obj /ProcSet [ /PDF /Text ]  /Font << /F4 221 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 27 0 obj << /Length 295 /Filter /FlateDecode >>  stream (i8_3 endstream endobj 28 0 obj /Type /Page  /Parent 1157 0 R  /Resources 29 0 R  /Contents 30 0 R  /CropBox [ 53 72 558 720 ]  /B [ 227 0 R ]  /Thumb 273 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 29 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 30 0 obj << /Length 638 /Filter /FlateDecode >>  stream `HB%2& S!|%l mFhQe T2HsAy endstream endobj 31 0 obj /Type /Page  /Parent 1157 0 R  /Resources 36 0 R  /Contents 37 0 R  /CropBox [ 53 72 558 720 ]  /Annots [ 32 0 R 33 0 R 34 0 R 35 0 R ]  /B [ 228 0 R ]  /Thumb 275 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 32 0 obj /Dest (M5.9.35135.ChapterTitle.1.Preinstallation.Requirements) /Type /Annot  /Subtype /Link  /Rect [ 212 560 310 573 ]  /Border [ 0 0 0 ]  endobj 33 0 obj /Dest (M5.9.35135.ChapterTitle.1.Preinstallation.Requirements) /Type /Annot  /Subtype /Link  /Rect [ 212 549 272 560 ]  /Border [ 0 0 0 ]  endobj 34 0 obj /Dest (M6.9.15043.ChapterTitle.2.PATROL.WBEM.Adapter.Installation) /Type /Annot  /Subtype /Link  /Rect [ 212 532 310 545 ]  /Border [ 0 0 0 ]  endobj 35 0 obj /Dest (M6.9.15043.ChapterTitle.2.PATROL.WBEM.Adapter.Installation) /Type /Annot  /Subtype /Link  /Rect [ 212 521 293 532 ]  /Border [ 0 0 0 ]  endobj 36 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 37 0 obj << /Length 1198 /Filter /FlateDecode >>  stream 2((0V@ -"yi% }l/lM endstream endobj 38 0 obj /Type /Page  /Parent 1157 0 R  /Resources 39 0 R  /Contents 40 0 R  /CropBox [ 53 72 558 720 ]  /B [ 229 0 R ]  /Thumb 277 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 39 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R /F8 224 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 40 0 obj << /Length 1412 /Filter /FlateDecode >>  stream `0]x1 1N#D  Dh+;K endstream endobj 41 0 obj /Type /Page  /Parent 1157 0 R  /Resources 42 0 R  /Contents 43 0 R  /CropBox [ 53 72 558 720 ]  /B [ 230 0 R ]  /Thumb 279 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 42 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R /F8 224 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 43 0 obj << /Length 780 /Filter /FlateDecode >>  stream "X~J Pl endstream endobj 44 0 obj /Type /Page  /Parent 1157 0 R  /Resources 45 0 R  /Contents 46 0 R  /CropBox [ 53 72 558 720 ]  /B [ 231 0 R ]  /Thumb 281 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 45 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R /F8 224 0 R /F10 232 0 R /F12 233 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 46 0 obj << /Length 1509 /Filter /FlateDecode >>  stream nUKyH <N%y! 6m;SPYS a{"R!E. fK}C] uT5]G 0]8L( 7~9Vk -on+|0k l1x<MU endstream endobj 47 0 obj /Type /Page  /Parent 1159 0 R  /Resources 48 0 R  /Contents 49 0 R  /CropBox [ 53 72 558 720 ]  /B [ 234 0 R ]  /Thumb 283 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 48 0 obj /ProcSet [ /PDF /Text ]  /Font << /F4 221 0 R /F6 223 0 R /F8 224 0 R /F10 232 0 R /F12 233 0 R /F14 235 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 49 0 obj << /Length 871 /Filter /FlateDecode >>  stream 21U\~ ,#0B{o* endstream endobj 50 0 obj /Type /Page  /Parent 1159 0 R  /Resources 56 0 R  /Contents 57 0 R  /CropBox [ 53 72 558 720 ]  /Annots [ 51 0 R 52 0 R 53 0 R 54 0 R 55 0 R ]  /B [ 236 0 R ]  /Thumb 285 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 51 0 obj /Dest [ 58 0 R /XYZ null 810 null ]  /Type /Annot  /Subtype /Link  /Rect [ 198 428 513 440 ]  /Border [ 0 0 0 ]  endobj 52 0 obj /Dest [ 58 0 R /XYZ null 697 null ]  /Type /Annot  /Subtype /Link  /Rect [ 198 415 513 427 ]  /Border [ 0 0 0 ]  endobj 53 0 obj /Dest [ 62 0 R /XYZ null 704 null ]  /Type /Annot  /Subtype /Link  /Rect [ 198 376 513 388 ]  /Border [ 0 0 0 ]  endobj 54 0 obj /Dest [ 58 0 R /XYZ null 588 null ]  /Type /Annot  /Subtype /Link  /Rect [ 216 402 513 414 ]  /Border [ 0 0 0 ]  endobj 55 0 obj /Dest [ 62 0 R /XYZ null 810 null ]  /Type /Annot  /Subtype /Link  /Rect [ 216 389 513 401 ]  /Border [ 0 0 0 ]  endobj 56 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 57 0 obj << /Length 653 /Filter /FlateDecode >>  stream IS?(e "aI13 i]Yw}^U RUP;W@ r8.Fh ySUM  endstream endobj 58 0 obj /Type /Page  /Parent 1159 0 R  /Resources 60 0 R  /Contents 61 0 R  /CropBox [ 53 72 558 720 ]  /Annots [ 59 0 R ]  /B [ 237 0 R ]  /Thumb 287 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 59 0 obj /Dest [ 58 0 R /XYZ null 525 null ]  /Type /Annot  /Subtype /Link  /Rect [ 246 394 291 407 ]  /Border [ 0 0 0 ]  endobj 60 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 61 0 obj << /Length 1165 /Filter /FlateDecode >>  stream rlIF^q Jc<]= endstream endobj 62 0 obj /Type /Page  /Parent 1159 0 R  /Resources 64 0 R  /Contents 65 0 R  /CropBox [ 53 72 558 720 ]  /Annots [ 63 0 R ]  /B [ 238 0 R ]  /Thumb 289 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 63 0 obj /Dest [ 62 0 R /XYZ null 636 null ]  /Type /Annot  /Subtype /Link  /Rect [ 210 508 255 520 ]  /Border [ 0 0 0 ]  endobj 64 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R /F10 232 0 R /F12 233 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 65 0 obj << /Length 1407 /Filter /FlateDecode >>  stream k'"c& v]:W/ r.-nh  FG25mFB& WY<6\ W~V#kP $cH^M endstream endobj 66 0 obj /Type /Page  /Parent 1159 0 R  /Resources 67 0 R  /Contents 68 0 R  /CropBox [ 53 72 558 720 ]  /B [ 239 0 R ]  /Thumb 291 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 67 0 obj /ProcSet [ /PDF /Text ]  /Font << /F4 221 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 68 0 obj << /Length 295 /Filter /FlateDecode >>  stream XX|WY endstream endobj 69 0 obj /Type /Page  /Parent 1159 0 R  /Resources 74 0 R  /Contents 75 0 R  /CropBox [ 53 72 558 720 ]  /Annots [ 70 0 R 71 0 R 72 0 R 73 0 R ]  /B [ 240 0 R ]  /Thumb 293 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 70 0 obj /Dest [ 76 0 R /XYZ null 810 null ]  /Type /Annot  /Subtype /Link  /Rect [ 207 391 522 403 ]  /Border [ 0 0 0 ]  endobj 71 0 obj /Dest [ 76 0 R /XYZ null 710 null ]  /Type /Annot  /Subtype /Link  /Rect [ 207 378 522 390 ]  /Border [ 0 0 0 ]  endobj 72 0 obj /Dest [ 101 0 R /XYZ null 678 null ]  /Type /Annot  /Subtype /Link  /Rect [ 207 365 522 377 ]  /Border [ 0 0 0 ]  endobj 73 0 obj /Dest [ 111 0 R /XYZ null 810 null ]  /Type /Annot  /Subtype /Link  /Rect [ 207 352 528 364 ]  /Border [ 0 0 0 ]  endobj 74 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 75 0 obj << /Length 693 /Filter /FlateDecode >>  stream dBGW'0n [*4{(; endstream endobj 76 0 obj /Type /Page  /Parent 1159 0 R  /Resources 77 0 R  /Contents 78 0 R  /CropBox [ 53 72 558 720 ]  /B [ 241 0 R ]  /Thumb 295 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 77 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R /F8 224 0 R /F12 233 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 78 0 obj << /Length 1314 /Filter /FlateDecode >>  stream }4$|B >!E@u bZl$<R %\\-?/9 endstream endobj 79 0 obj /Type /Page  /Parent 1159 0 R  /Resources 80 0 R  /Contents 81 0 R  /CropBox [ 53 72 558 720 ]  /B [ 242 0 R ]  /Thumb 297 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 80 0 obj /ProcSet [ /PDF /Text /ImageC /ImageI ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R /F8 224 0 R >>  /XObject << /Im3 82 0 R >>  /ExtGState << /GS1 1193 0 R >>  /ColorSpace << /CS3 243 0 R >>  endobj 81 0 obj << /Length 786 /Filter /FlateDecode >>  stream ue=DW 2;"_5 v!7]p ozg;/ ENM[' [oH#+ Yp-W(? endstream endobj 82 0 obj << /Type /XObject /Subtype /Image /Name /Im3 /Width 636 /Height 433  /BitsPerComponent 8 /ColorSpace 243 0 R /Length 11811 /Filter /FlateDecode >>  stream ?5`OBv Q|GaPx WFz.6 G&&.OL FcvyAxE '4fL0H ~lgv& m0~c4 |"Q(< pldmmM /Ew /( t!QH' P|7?> =A8b:aF NaQQn. x{oDRe M2bl6 MM`o~ $Icsi 9}'OB _21a  azZ5'O ,R}`O(" j.*Xua ?N`y0 ]*gn\{; %Dr}B MynX5 yhzBO oojj( 1[V6v R.YE9D 5l{I#}8 ID{/NV I`R%^ p'^s"| L({'kod >7Xca *^(8E OX{P|A= fSU415i Ox{/q boN{( i@tEC 15999 ^4### 'OvGN mW2ut Ls/Y/p oA>PX U8^S6 `pT:; endstream endobj 83 0 obj /Type /Page  /Parent 1159 0 R  /Resources 86 0 R  /Contents 87 0 R  /CropBox [ 53 72 558 720 ]  /Annots [ 84 0 R 85 0 R ]  /B [ 245 0 R ]  /Thumb 299 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 84 0 obj /Dest [ 101 0 R /XYZ null 810 null ]  /Type /Annot  /Subtype /Link  /Rect [ 452 247 504 259 ]  /Border [ 0 0 0 ]  endobj 85 0 obj /Dest [ 101 0 R /XYZ null 810 null ]  /Type /Annot  /Subtype /Link  /Rect [ 90 234 257 247 ]  /Border [ 0 0 0 ]  endobj 86 0 obj /ProcSet [ /PDF /Text /ImageC /ImageI ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R /F8 224 0 R >>  /XObject << /Im4 88 0 R >>  /ExtGState << /GS1 1193 0 R >>  /ColorSpace << /CS4 246 0 R >>  endobj 87 0 obj << /Length 932 /Filter /FlateDecode >>  stream $F.f> p/N|;4r \Tf:^ endstream endobj 88 0 obj << /Type /XObject /Subtype /Image /Name /Im4 /Width 636 /Height 433  /BitsPerComponent 8 /ColorSpace 246 0 R /Length 12067 /Filter /FlateDecode >>  stream +wx b Bc~9 n1 v-{rr" %WJ7e q?9pO XtXMf DrNW( Zm{sqz 5uvv: ^f~>MO JDOdwR Gh=7F[ ;rY{) s]k'\ Qmmmi0 u6)){Q PW0QD 7668% ZX{'$ *]v{t =?::z (v<W@ $^1+L J4{kGU (XYrj {^<{) F5^Qk] i/H/- <pW)B* iovN' +X.AG# Oegk0> lN4Rf W`:gj MXHdK 3}'_] A$U-Nu PP'w8l 2Qe4;U $54p* zQFFF {:r,e fsbb. =RJK{ endstream endobj 89 0 obj /Type /Page  /Parent 1159 0 R  /Resources 90 0 R  /Contents 91 0 R  /CropBox [ 53 72 558 720 ]  /B [ 248 0 R ]  /Thumb 301 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 90 0 obj /ProcSet [ /PDF /Text /ImageC /ImageI ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R /F8 224 0 R >>  /XObject << /Im5 92 0 R >>  /ExtGState << /GS1 1193 0 R >>  /ColorSpace << /CS3 243 0 R >>  endobj 91 0 obj << /Length 646 /Filter /FlateDecode >>  stream :E6dQ Rn$Zy\ :vsRCzh 9VLpS endstream endobj 92 0 obj << /Type /XObject /Subtype /Image /Name /Im5 /Width 636 /Height 433  /BitsPerComponent 8 /ColorSpace 243 0 R /Length 11629 /Filter /FlateDecode >>  stream !>ut" 2{My_J aOKZ?%R wCdW/ ^L:x4 !5~C- ?9yer mnzshh P]sIq#+[s%; )CSx~ slltl sf}u' >Q|7O LM=_} 922:z:vz FOKGg T&5ST*n 7/#3/ lm,No5O y{')I jIMMMi0 9{SP{ %x/o/n{ z'l2t .wGI/^{X kK} o RTa-z ~0J>@ i<u]w s\|<SG%A ;nNQx Umu0_9 kAzVO $1r;x( !Qj4:] !g>=T{ rC{4k w/SF$F. &Yuds ^<SSS ';S'] OP.R._ ?b6$Q]= ,iNi( sOQ(9ki endstream endobj 93 0 obj /Type /Page  /Parent 1160 0 R  /Resources 94 0 R  /Contents 95 0 R  /CropBox [ 53 72 558 720 ]  /B [ 249 0 R ]  /Thumb 303 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 94 0 obj /ProcSet [ /PDF /Text /ImageC /ImageI ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R /F8 224 0 R >>  /XObject << /Im6 96 0 R >>  /ExtGState << /GS1 1193 0 R >>  /ColorSpace << /CS4 246 0 R >>  endobj 95 0 obj << /Length 755 /Filter /FlateDecode >>  stream $hT07 eO.+z |D:,= endstream endobj 96 0 obj << /Type /XObject /Subtype /Image /Name /Im6 /Width 636 /Height 433  /BitsPerComponent 8 /ColorSpace 246 0 R /Length 12324 /Filter /FlateDecode >>  stream !1uu#$$ cI){J ~O:y( -GaAo x&'/NNV~ .73{}n oqqq~ Fcv1 ?# lvs3K i77w6 7'-=' A^}U" Tl/aIZ{" 2[z}U n*gK&[ SnNm( zP{Q{ a{q$I IR{,>v &[{Ng(4 KlO49 w^6{PvW Cl vb Rd>G: 6/U0UaE goe%= b_0:0 %BED3 Qb:Hf8_ IdloY %-5T@W #]]i; cusz( #s"U? %c{qf .a_0k IR5Z| tOWOO ao!?w +*b_X laouB ,aoc#Fj#, >P6fs- O-@oc6 "wF/et u3bO[ vq;{P [%j+{`<S +lG[y# 1#soY $l5w= [+_Kh endstream endobj 97 0 obj /Type /Page  /Parent 1160 0 R  /Resources 98 0 R  /Contents 99 0 R  /CropBox [ 53 72 558 720 ]  /B [ 250 0 R ]  /Thumb 305 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 98 0 obj /ProcSet [ /PDF /Text /ImageC /ImageI ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R /F8 224 0 R >>  /XObject << /Im7 100 0 R >>  /ExtGState << /GS1 1193 0 R >>  /ColorSpace << /CS4 246 0 R >>  endobj 99 0 obj << /Length 910 /Filter /FlateDecode >>  stream #3|II PcQ;. endstream endobj 100 0 obj << /Type /XObject /Subtype /Image /Name /Im7 /Width 636 /Height 433  /BitsPerComponent 8 /ColorSpace 246 0 R /Length 11018 /Filter /FlateDecode >>  stream K>@+.5 s,A{@ UUmO( `H\hL Zwqt9 w83VmI iqq{4 /_1wXz 8b[ZZ ,/ndr 5db{I >lo_d -uu^:/% lQ|c| *.TW4U T#z"eE XYct8 "|0tugkS \sOL, 8m}T  q94"G :q$'nz n:oN_ <o{tx ]3Sva GQ}<s eW}OQ^ 4lU@;A{(`/ l a[HA1 [Z[[{ .j?4G n`s21G" ]0{O: K${:m/H/.W [==9OmatoS i*[[[.?<w sVMEFU Y]YYY E$\h\ mnFJm 4rL.nb ixqox ^oiiC gt6Y] 5c|yJ `'Y)\ {dBc! endstream endobj 101 0 obj /Type /Page  /Parent 1160 0 R  /Resources 103 0 R  /Contents 104 0 R  /CropBox [ 53 72 558 720 ]  /Annots [ 102 0 R ]  /B [ 251 0 R ]  /Thumb 307 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 102 0 obj /Dest [ 101 0 R /XYZ null 602 null ]  /Type /Annot  /Subtype /Link  /Rect [ 359 578 404 590 ]  /Border [ 0 0 0 ]  endobj 103 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R /F8 224 0 R /F12 233 0 R /F16 252 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 104 0 obj << /Length 1288 /Filter /FlateDecode >>  stream TucOp t-Se6 :mT}8 )k:Nn +F5J{ endstream endobj 105 0 obj /Type /Page  /Parent 1160 0 R  /Resources 106 0 R  /Contents 107 0 R  /CropBox [ 53 72 558 720 ]  /B [ 253 0 R ]  /Thumb 309 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 106 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F12 233 0 R /F16 252 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 107 0 obj << /Length 1269 /Filter /FlateDecode >>  stream $hn}8>'h _[>RjDp 3QuyR bI.kV o~5cL endstream endobj 108 0 obj /Type /Page  /Parent 1160 0 R  /Resources 109 0 R  /Contents 110 0 R  /CropBox [ 53 72 558 720 ]  /B [ 254 0 R ]  /Thumb 311 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 109 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F12 233 0 R /F16 252 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 110 0 obj << /Length 897 /Filter /FlateDecode >>  stream 5jI$D VcM09 <a UDc endstream endobj 111 0 obj /Type /Page  /Parent 1160 0 R  /Resources 112 0 R  /Contents 113 0 R  /CropBox [ 53 72 558 720 ]  /B [ 255 0 R ]  /Thumb 313 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 112 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R /F8 224 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 113 0 obj << /Length 1204 /Filter /FlateDecode >>  stream :v,v< R2%Wv &F'K`e endstream endobj 114 0 obj /Type /Page  /Parent 1160 0 R  /Resources 115 0 R  /Contents 116 0 R  /CropBox [ 53 72 558 720 ]  /B [ 256 0 R ]  /Thumb 315 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 115 0 obj /ProcSet [ /PDF /Text ]  /Font << /F4 221 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 116 0 obj << /Length 296 /Filter /FlateDecode >>  stream endstream endobj 117 0 obj /Type /Page  /Parent 1160 0 R  /Resources 143 0 R  /Contents 144 0 R  /CropBox [ 53 72 558 720 ]  /Annots [ 118 0 R 119 0 R 120 0 R 121 0 R 122 0 R 123 0 R 124 0 R 125 0 R 126 0 R  127 0 R 128 0 R 129 0 R 130 0 R 131 0 R 132 0 R 133 0 R 134 0 R  135 0 R 136 0 R 137 0 R 138 0 R 139 0 R 140 0 R 141 0 R 142 0 R  /B [ 257 0 R 258 0 R ]  /Thumb 317 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 118 0 obj /Dest (I6.1.32172) /Type /Annot  /Subtype /Link  /Rect [ 263 440 306 453 ]  /Border [ 0 0 0 ]  endobj 119 0 obj /Dest (I5.1.7252) /Type /Annot  /Subtype /Link  /Rect [ 223 377 306 390 ]  /Border [ 0 0 0 ]  endobj 120 0 obj /Dest (I6.1.32167) /Type /Annot  /Subtype /Link  /Rect [ 233 364 306 377 ]  /Border [ 0 0 0 ]  endobj 121 0 obj /Dest (I6.1.32166) /Type /Annot  /Subtype /Link  /Rect [ 194 275 306 288 ]  /Border [ 0 0 0 ]  endobj 122 0 obj /Dest (I6.1.32168) /Type /Annot  /Subtype /Link  /Rect [ 250 249 306 262 ]  /Border [ 0 0 0 ]  endobj 123 0 obj /Dest (I6.1.32169) /Type /Annot  /Subtype /Link  /Rect [ 233 236 306 249 ]  /Border [ 0 0 0 ]  endobj 124 0 obj /Dest (I5.1.7512) /Type /Annot  /Subtype /Link  /Rect [ 222 223 306 236 ]  /Border [ 0 0 0 ]  endobj 125 0 obj /Dest (I6.1.32173) /Type /Annot  /Subtype /Link  /Rect [ 263 160 306 173 ]  /Border [ 0 0 0 ]  endobj 126 0 obj /Dest (I6.1.32178) /Type /Annot  /Subtype /Link  /Rect [ 162 147 306 160 ]  /Border [ 0 0 0 ]  endobj 127 0 obj /Dest (I5.1.7510) /Type /Annot  /Subtype /Link  /Rect [ 370 493 522 506 ]  /Border [ 0 0 0 ]  endobj 128 0 obj /Dest (I5.1.7252) /Type /Annot  /Subtype /Link  /Rect [ 417 417 522 430 ]  /Border [ 0 0 0 ]  endobj 129 0 obj /Dest (I6.1.29329) /Type /Annot  /Subtype /Link  /Rect [ 380 404 522 417 ]  /Border [ 0 0 0 ]  endobj 130 0 obj /Dest (I6.1.32164) /Type /Annot  /Subtype /Link  /Rect [ 421 391 522 404 ]  /Border [ 0 0 0 ]  endobj 131 0 obj /Dest (I5.1.7481) /Type /Annot  /Subtype /Link  /Rect [ 388 378 522 391 ]  /Border [ 0 0 0 ]  endobj 132 0 obj /Dest (I5.1.7242) /Type /Annot  /Subtype /Link  /Rect [ 506 365 522 378 ]  /Border [ 0 0 0 ]  endobj 133 0 obj /Dest (I5.1.7202) /Type /Annot  /Subtype /Link  /Rect [ 405 352 522 365 ]  /Border [ 0 0 0 ]  endobj 134 0 obj /Dest (I6.1.33246) /Type /Annot  /Subtype /Link  /Rect [ 399 339 522 352 ]  /Border [ 0 0 0 ]  endobj 135 0 obj /Dest (I5.1.7199) /Type /Annot  /Subtype /Link  /Rect [ 406 326 522 339 ]  /Border [ 0 0 0 ]  endobj 136 0 obj /Dest (I5.1.7507) /Type /Annot  /Subtype /Link  /Rect [ 396 263 522 276 ]  /Border [ 0 0 0 ]  endobj 137 0 obj /Dest (I6.1.32181) /Type /Annot  /Subtype /Link  /Rect [ 386 250 522 263 ]  /Border [ 0 0 0 ]  endobj 138 0 obj /Dest (I6.1.32182) /Type /Annot  /Subtype /Link  /Rect [ 383 237 522 250 ]  /Border [ 0 0 0 ]  endobj 139 0 obj /Dest (I6.1.32188) /Type /Annot  /Subtype /Link  /Rect [ 372 174 522 187 ]  /Border [ 0 0 0 ]  endobj 140 0 obj /Dest (I6.1.32180) /Type /Annot  /Subtype /Link  /Rect [ 373 161 522 174 ]  /Border [ 0 0 0 ]  endobj 141 0 obj /Dest (I6.1.32189) /Type /Annot  /Subtype /Link  /Rect [ 394 148 522 161 ]  /Border [ 0 0 0 ]  endobj 142 0 obj /Dest (I6.1.32186) /Type /Annot  /Subtype /Link  /Rect [ 376 135 522 148 ]  /Border [ 0 0 0 ]  endobj 143 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 144 0 obj << /Length 871 /Filter /FlateDecode >>  stream B'{,p7 P=Gd: }ZaJw endstream endobj 145 0 obj /Type /Page  /Parent 1160 0 R  /Resources 204 0 R  /Contents 205 0 R  /CropBox [ 53 72 558 720 ]  /Annots [ 146 0 R 147 0 R 148 0 R 149 0 R 150 0 R 151 0 R 152 0 R 153 0 R 154 0 R  155 0 R 156 0 R 157 0 R 158 0 R 159 0 R 160 0 R 161 0 R 162 0 R  163 0 R 164 0 R 165 0 R 166 0 R 167 0 R 168 0 R 169 0 R 170 0 R  171 0 R 172 0 R 173 0 R 174 0 R 175 0 R 176 0 R 177 0 R 178 0 R  179 0 R 180 0 R 181 0 R 182 0 R 183 0 R 184 0 R 185 0 R 186 0 R  187 0 R 188 0 R 189 0 R 190 0 R 191 0 R 192 0 R 193 0 R 194 0 R  195 0 R 196 0 R 197 0 R 198 0 R 199 0 R 200 0 R 201 0 R 202 0 R  203 0 R ]  /B [ 259 0 R ]  /Thumb 319 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 146 0 obj /Dest (I6.1.32186) /Type /Annot  /Subtype /Link  /Rect [ 376 135 522 148 ]  /Border [ 0 0 0 ]  endobj 147 0 obj /Dest (I6.1.32187) /Type /Annot  /Subtype /Link  /Rect [ 150 655 288 668 ]  /Border [ 0 0 0 ]  endobj 148 0 obj /Dest (I6.1.32185) /Type /Annot  /Subtype /Link  /Rect [ 139 642 288 655 ]  /Border [ 0 0 0 ]  endobj 149 0 obj /Dest (I6.1.32190) /Type /Annot  /Subtype /Link  /Rect [ 154 579 288 592 ]  /Border [ 0 0 0 ]  endobj 150 0 obj /Dest (I6.1.32191) /Type /Annot  /Subtype /Link  /Rect [ 158 566 288 579 ]  /Border [ 0 0 0 ]  endobj 151 0 obj /Dest (I6.1.32192) /Type /Annot  /Subtype /Link  /Rect [ 154 553 288 566 ]  /Border [ 0 0 0 ]  endobj 152 0 obj /Dest (I6.1.32193) /Type /Annot  /Subtype /Link  /Rect [ 144 540 288 553 ]  /Border [ 0 0 0 ]  endobj 153 0 obj /Dest (I6.1.32194) /Type /Annot  /Subtype /Link  /Rect [ 156 527 288 540 ]  /Border [ 0 0 0 ]  endobj 154 0 obj /Dest (I5.1.7508) /Type /Annot  /Subtype /Link  /Rect [ 191 514 288 527 ]  /Border [ 0 0 0 ]  endobj 155 0 obj /Dest (I6.1.32179) /Type /Annot  /Subtype /Link  /Rect [ 146 501 288 514 ]  /Border [ 0 0 0 ]  endobj 156 0 obj /Dest (I6.1.32183) /Type /Annot  /Subtype /Link  /Rect [ 157 488 288 501 ]  /Border [ 0 0 0 ]  endobj 157 0 obj /Dest (I5.1.7506) /Type /Annot  /Subtype /Link  /Rect [ 201 462 288 475 ]  /Border [ 0 0 0 ]  endobj 158 0 obj /Dest (I5.1.7509) /Type /Annot  /Subtype /Link  /Rect [ 155 449 288 462 ]  /Border [ 0 0 0 ]  endobj 159 0 obj /Dest (I6.1.32201) /Type /Annot  /Subtype /Link  /Rect [ 161 436 288 449 ]  /Border [ 0 0 0 ]  endobj 160 0 obj /Dest (I6.1.32200) /Type /Annot  /Subtype /Link  /Rect [ 162 423 288 436 ]  /Border [ 0 0 0 ]  endobj 161 0 obj /Dest (I6.1.32184) /Type /Annot  /Subtype /Link  /Rect [ 147 410 288 423 ]  /Border [ 0 0 0 ]  endobj 162 0 obj /Dest (I6.1.32210) /Type /Annot  /Subtype /Link  /Rect [ 154 397 288 410 ]  /Border [ 0 0 0 ]  endobj 163 0 obj /Dest (I6.1.32177) /Type /Annot  /Subtype /Link  /Rect [ 148 384 288 397 ]  /Border [ 0 0 0 ]  endobj 164 0 obj /Dest (I6.1.32199) /Type /Annot  /Subtype /Link  /Rect [ 142 321 288 334 ]  /Border [ 0 0 0 ]  endobj 165 0 obj /Dest (I6.1.32167) /Type /Annot  /Subtype /Link  /Rect [ 157 308 288 321 ]  /Border [ 0 0 0 ]  endobj 166 0 obj /Dest (I6.1.32174) /Type /Annot  /Subtype /Link  /Rect [ 258 295 288 308 ]  /Border [ 0 0 0 ]  endobj 167 0 obj /Dest (I5.1.7242) /Type /Annot  /Subtype /Link  /Rect [ 213 269 288 282 ]  /Border [ 0 0 0 ]  endobj 168 0 obj /Dest (I5.1.7499) /Type /Annot  /Subtype /Link  /Rect [ 142 256 288 269 ]  /Border [ 0 0 0 ]  endobj 169 0 obj /Dest (I5.1.7505) /Type /Annot  /Subtype /Link  /Rect [ 131 193 288 206 ]  /Border [ 0 0 0 ]  endobj 170 0 obj /Dest (I5.1.7499) /Type /Annot  /Subtype /Link  /Rect [ 187 180 288 193 ]  /Border [ 0 0 0 ]  endobj 171 0 obj /Dest (I6.1.29335) /Type /Annot  /Subtype /Link  /Rect [ 403 612 504 625 ]  /Border [ 0 0 0 ]  endobj 172 0 obj /Dest (I6.1.33246) /Type /Annot  /Subtype /Link  /Rect [ 374 599 504 612 ]  /Border [ 0 0 0 ]  endobj 173 0 obj /Dest (I5.1.7511) /Type /Annot  /Subtype /Link  /Rect [ 388 586 504 599 ]  /Border [ 0 0 0 ]  endobj 174 0 obj /Dest (I6.1.32209) /Type /Annot  /Subtype /Link  /Rect [ 346 573 504 586 ]  /Border [ 0 0 0 ]  endobj 175 0 obj /Dest (I6.1.32211) /Type /Annot  /Subtype /Link  /Rect [ 348 560 504 573 ]  /Border [ 0 0 0 ]  endobj 176 0 obj /Dest (I6.1.32212) /Type /Annot  /Subtype /Link  /Rect [ 359 547 504 560 ]  /Border [ 0 0 0 ]  endobj 177 0 obj /Dest (I6.1.32213) /Type /Annot  /Subtype /Link  /Rect [ 368 534 504 547 ]  /Border [ 0 0 0 ]  endobj 178 0 obj /Dest (I6.1.32214) /Type /Annot  /Subtype /Link  /Rect [ 347 521 504 534 ]  /Border [ 0 0 0 ]  endobj 179 0 obj /Dest (I6.1.32203) /Type /Annot  /Subtype /Link  /Rect [ 355 458 504 471 ]  /Border [ 0 0 0 ]  endobj 180 0 obj /Dest (I6.1.32202) /Type /Annot  /Subtype /Link  /Rect [ 358 445 504 458 ]  /Border [ 0 0 0 ]  endobj 181 0 obj /Dest (I6.1.32208) /Type /Annot  /Subtype /Link  /Rect [ 359 432 504 445 ]  /Border [ 0 0 0 ]  endobj 182 0 obj /Dest (I6.1.32204) /Type /Annot  /Subtype /Link  /Rect [ 393 419 504 432 ]  /Border [ 0 0 0 ]  endobj 183 0 obj /Dest (I6.1.32205) /Type /Annot  /Subtype /Link  /Rect [ 411 406 504 419 ]  /Border [ 0 0 0 ]  endobj 184 0 obj /Dest (I6.1.32206) /Type /Annot  /Subtype /Link  /Rect [ 395 393 504 406 ]  /Border [ 0 0 0 ]  endobj 185 0 obj /Dest (I6.1.32207) /Type /Annot  /Subtype /Link  /Rect [ 401 380 504 393 ]  /Border [ 0 0 0 ]  endobj 186 0 obj /Dest (I6.1.32216) /Type /Annot  /Subtype /Link  /Rect [ 415 367 504 380 ]  /Border [ 0 0 0 ]  endobj 187 0 obj /Dest (I6.1.32217) /Type /Annot  /Subtype /Link  /Rect [ 434 354 504 367 ]  /Border [ 0 0 0 ]  endobj 188 0 obj /Dest (I6.1.32218) /Type /Annot  /Subtype /Link  /Rect [ 425 341 504 354 ]  /Border [ 0 0 0 ]  endobj 189 0 obj /Dest (I6.1.32219) /Type /Annot  /Subtype /Link  /Rect [ 427 328 504 341 ]  /Border [ 0 0 0 ]  endobj 190 0 obj /Dest (I6.1.32220) /Type /Annot  /Subtype /Link  /Rect [ 432 315 504 328 ]  /Border [ 0 0 0 ]  endobj 191 0 obj /Dest (I6.1.32221) /Type /Annot  /Subtype /Link  /Rect [ 424 302 504 315 ]  /Border [ 0 0 0 ]  endobj 192 0 obj /Dest (I6.1.32222) /Type /Annot  /Subtype /Link  /Rect [ 424 289 504 302 ]  /Border [ 0 0 0 ]  endobj 193 0 obj /Dest (I6.1.32223) /Type /Annot  /Subtype /Link  /Rect [ 403 276 504 289 ]  /Border [ 0 0 0 ]  endobj 194 0 obj /Dest (I6.1.32224) /Type /Annot  /Subtype /Link  /Rect [ 417 263 504 276 ]  /Border [ 0 0 0 ]  endobj 195 0 obj /Dest (I6.1.32225) /Type /Annot  /Subtype /Link  /Rect [ 408 250 504 263 ]  /Border [ 0 0 0 ]  endobj 196 0 obj /Dest (I6.1.32226) /Type /Annot  /Subtype /Link  /Rect [ 412 237 504 250 ]  /Border [ 0 0 0 ]  endobj 197 0 obj /Dest (I6.1.32227) /Type /Annot  /Subtype /Link  /Rect [ 424 224 504 237 ]  /Border [ 0 0 0 ]  endobj 198 0 obj /Dest (I6.1.32228) /Type /Annot  /Subtype /Link  /Rect [ 400 211 504 224 ]  /Border [ 0 0 0 ]  endobj 199 0 obj /Dest (I6.1.32229) /Type /Annot  /Subtype /Link  /Rect [ 420 198 504 211 ]  /Border [ 0 0 0 ]  endobj 200 0 obj /Dest (I6.1.32230) /Type /Annot  /Subtype /Link  /Rect [ 398 185 504 198 ]  /Border [ 0 0 0 ]  endobj 201 0 obj /Dest (I6.1.32231) /Type /Annot  /Subtype /Link  /Rect [ 410 172 504 185 ]  /Border [ 0 0 0 ]  endobj 202 0 obj /Dest (I6.1.32215) /Type /Annot  /Subtype /Link  /Rect [ 367 159 504 172 ]  /Border [ 0 0 0 ]  endobj 203 0 obj /Dest (I6.1.32197) /Type /Annot  /Subtype /Link  /Rect [ 375 146 504 159 ]  /Border [ 0 0 0 ]  endobj 204 0 obj /ProcSet [ /PDF /Text ]  /Font << /F2 1192 0 R /F4 221 0 R /F6 223 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 205 0 obj << /Length 955 /Filter /FlateDecode >>  stream D6%76g >C`2PS u:eEZ 0p8nU endstream endobj 206 0 obj /Type /Page  /Parent 1160 0 R  /Resources 216 0 R  /Contents 217 0 R  /CropBox [ 53 72 558 720 ]  /Annots [ 207 0 R 208 0 R 209 0 R 210 0 R 211 0 R 212 0 R 213 0 R 214 0 R 215 0 R  /B [ 260 0 R ]  /Thumb 321 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 207 0 obj /Dest (I6.1.32197) /Type /Annot  /Subtype /Link  /Rect [ 375 146 504 159 ]  /Border [ 0 0 0 ]  endobj 208 0 obj /Dest (I6.1.32198) /Type /Annot  /Subtype /Link  /Rect [ 178 655 306 668 ]  /Border [ 0 0 0 ]  endobj 209 0 obj /Dest (I6.1.32196) /Type /Annot  /Subtype /Link  /Rect [ 178 642 306 655 ]  /Border [ 0 0 0 ]  endobj 210 0 obj /Dest (I6.1.32195) /Type /Annot  /Subtype /Link  /Rect [ 180 629 306 642 ]  /Border [ 0 0 0 ]  endobj 211 0 obj /Dest (I5.1.7199) /Type /Annot  /Subtype /Link  /Rect [ 172 616 306 629 ]  /Border [ 0 0 0 ]  endobj 212 0 obj /Dest (I6.1.32164) /Type /Annot  /Subtype /Link  /Rect [ 179 603 306 616 ]  /Border [ 0 0 0 ]  endobj 213 0 obj /Dest (I6.1.29329) /Type /Annot  /Subtype /Link  /Rect [ 201 590 306 603 ]  /Border [ 0 0 0 ]  endobj 214 0 obj /Dest (I6.1.28454) /Type /Annot  /Subtype /Link  /Rect [ 226 577 306 590 ]  /Border [ 0 0 0 ]  endobj 215 0 obj /Dest (I6.1.29335) /Type /Annot  /Subtype /Link  /Rect [ 191 564 306 577 ]  /Border [ 0 0 0 ]  endobj 216 0 obj /ProcSet [ /PDF /Text ]  /Font << /F4 221 0 R /F6 223 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 217 0 obj << /Length 386 /Filter /FlateDecode >>  stream Z9LHT endstream endobj 218 0 obj /Type /Page  /Parent 1161 0 R  /Resources 219 0 R  /Contents 220 0 R  /CropBox [ 53 72 558 720 ]  /B [ 261 0 R ]  /Thumb 323 0 R  /MediaBox [ 0 0 612 792 ]  /Rotate 0  endobj 219 0 obj /ProcSet [ /PDF /Text ]  /Font << /F4 221 0 R >>  /ExtGState << /GS1 1193 0 R >>  endobj 220 0 obj << /Length 296 /Filter /FlateDecode >>  stream ^H'Zw7V 4,^_0 endstream endobj 221 0 obj /Type /Font  /Subtype /Type1  /Name /F4  /Encoding 1191 0 R  /BaseFont /Helvetica  endobj 222 0 obj /P 6 0 R  /R [ 81 405 513 683 ]  /V 2 0 R  /N 225 0 R  /T 1165 0 R  endobj 223 0 obj /Type /Font  /Subtype /Type1  /Name /F6  /Encoding 1191 0 R  /BaseFont /Times-Roman  endobj 224 0 obj /Type /Font  /Subtype /Type1  /Name /F8  /Encoding 1191 0 R  /BaseFont /Times-Bold  endobj 225 0 obj /P 9 0 R  /R [ 99 126 531 665 ]  /V 222 0 R  /N 226 0 R  /T 1165 0 R  endobj 226 0 obj /P 25 0 R  /R [ 81 126 513 675 ]  /V 225 0 R  /N 227 0 R  /T 1165 0 R  endobj 227 0 obj /P 28 0 R  /R [ 99 126 531 665 ]  /V 226 0 R  /N 228 0 R  /T 1165 0 R  endobj 228 0 obj /P 31 0 R  /R [ 99 126 531 675 ]  /V 227 0 R  /N 229 0 R  /T 1165 0 R  endobj 229 0 obj /P 38 0 R  /R [ 99 126 531 675 ]  /V 228 0 R  /N 230 0 R  /T 1165 0 R  endobj 230 0 obj /P 41 0 R  /R [ 81 126 513 675 ]  /V 229 0 R  /N 231 0 R  /T 1165 0 R  endobj 231 0 obj /P 44 0 R  /R [ 99 126 531 675 ]  /V 230 0 R  /N 234 0 R  /T 1165 0 R  endobj 232 0 obj /Type /Font  /Subtype /Type1  /Name /F10  /Encoding 1191 0 R  /BaseFont /Times-Italic  endobj 233 0 obj /Type /Font  /Subtype /Type1  /Name /F12  /Encoding 262 0 R  /BaseFont /Courier  endobj 234 0 obj /P 47 0 R  /R [ 81 126 513 675 ]  /V 231 0 R  /N 236 0 R  /T 1165 0 R  endobj 235 0 obj /Type /Font  /Subtype /Type1  /Name /F14  /Encoding 1191 0 R  /BaseFont /Times-BoldItalic  endobj 236 0 obj /P 50 0 R  /R [ 99 126 531 665 ]  /V 234 0 R  /N 237 0 R  /T 1165 0 R  endobj 237 0 obj /P 58 0 R  /R [ 81 126 513 675 ]  /V 236 0 R  /N 238 0 R  /T 1165 0 R  endobj 238 0 obj /P 62 0 R  /R [ 99 126 531 675 ]  /V 237 0 R  /N 239 0 R  /T 1165 0 R  endobj 239 0 obj /P 66 0 R  /R [ 81 126 513 675 ]  /V 238 0 R  /N 240 0 R  /T 1165 0 R  endobj 240 0 obj /P 69 0 R  /R [ 108 126 540 665 ]  /V 239 0 R  /N 241 0 R  /T 1165 0 R  endobj 241 0 obj /P 76 0 R  /R [ 81 126 513 675 ]  /V 240 0 R  /N 242 0 R  /T 1165 0 R  endobj 242 0 obj /P 79 0 R  /R [ 99 126 531 675 ]  /V 241 0 R  /N 245 0 R  /T 1165 0 R  endobj 243 0 obj /Indexed /DeviceRGB 255 244 0 R  endobj 244 0 obj << /Filter /ASCII85Decode /Length 908 >>  stream !!!#=_o@@]K`D)Ps82frJqO,LHN8&4!,63S;.Bk[@gFK(!%<1"/:.@FKE*]Q!%_U[ ATIioEr[=m!$H=_+DV6*@gFJu#V^o;0Ur+sPQ2h0#U!:V31Kt7HN50d#U!#;8ItlE CBua`#T-/_*"XPY3@R'o0i_^]D4ClWHN5IY0i:Pa9d'd:V$L3r#XK$0ceaVX]o8PZ F-<%kEI5+)est473L5ngVTrtOc3Qka`oHgEli5i=s7c9fV7Ot'e*h)DXU$%A8mP%< D#aPi[Cso\>*a4aD.?1#+\H;_&4oIo36#-1>.)Drf)PbsP-o@NCB,cA8jta<8LZ*G (^Osq!%=rm=e%2p&.iOUs53jQZN#lPrr=Hg>"L.t;%N^]XVd@6#\@L#D%LJs+TNLH !'$fQR`:T`mn2JQ+kK?TZM+>AHT<c/3B.k?E?P<A[409B!58F5VFm].pCK/9+[JFu NYhaMV#Wg4[J0\$7BJ:aF5H*K.7m,37E0C_8cUQ869$\C3&+#s63&]m.4?Vo0I]ms ;O!&!&8>nsA^19A]d[MbXfeeWn+R)bmg*4E`gT4SER'f_3>cW5#\j=/F\5h;8o(:@ Xh(pcVK3o@kH0b[+Wqrkhbo]Q(s^kj!/?/RH$]MkKM"g.CXXGREFZ,BEr[cJ!*0%! 8aiLIS,d!t!-.bH^&S.9[6d/>!(jj((o@94!!$HQ!5?.C3#DX@KY7?c!+!SE=jB>n 3K/]6V4Npsa1[^pH^&ec`kK.Chq#ff]qq<Z;Gg&_VOW<bF.APLp\4EiY,.YSN%$.u ]t1Vb[]Q[7SF>e,kNC]lSs9!<mqZW@Pa7PuNeBDP0t"Hl]tV1^Whkr?N/WXIKSFi# H#n=PF78#3]s=..;8rSYXT03?!"bt,zzzzzzzzzzzzzzzzz~> endstream endobj 245 0 obj /P 83 0 R  /R [ 81 126 513 675 ]  /V 242 0 R  /N 248 0 R  /T 1165 0 R  endobj 246 0 obj /Indexed /DeviceRGB 255 247 0 R  endobj 247 0 obj << /Filter /ASCII85Decode /Length 908 >>  stream !!!#=_o@@]K`D)Ps82frJqO,LHN8&4!,63S;.Bk[@gFK(!%<1"/:.@FKE*]Q!%_U[ ATIioEr[=m!$H=_+DV6*@gFJu#V^o;0Ur+sPQ2h0#U!:V31Kt7HN50d#U!#;8ItlE CBua`#T-/_*"XPY3@R'o0i_^]D4ClWHN5IY0i:Pa9d'd:V$L3r#XK$0ceaVX]o8PZ F-<%kEI5+)est473L5ngVTrtOc3Qka`oHgEli5i=s7c9fV7Ot'e*h)DXU$%A8mP%< D#aPi[Cso\>*a4aD.?1#+\H;_&4oIo36#-1>.)Drf)PbsP-o@NCB,cA8jta<8LZ*G (^Osq!%=rm=e%2p&.iOUs53jQZN#lPrr=Hg>"L.t;%N^]XVd@6#\@L#D%LJs+TNLH !'$fQR`:T`mn2JQ+kK?TZM+>AHT<c/3B.k?E?P<A[409B!58F5VFm].pCK/9+[JFu NYhaMV#Wg4[J0\$7BJ:aF5H*K.7m,37E0C_8cUQ869$\C3&+#s63&]m.4?Vo0I]ms ;O!&!&8>nsA^19A]d[MbXfeeWn+R)bmg*4E`gT4SER'f_3>cW5#\j=/F\5h;8o(:@ Xh(pcVK3o@kH0b[+Wqrkhbo]Q(s^kj!/?/RH$`.T8o)m!HZ<PtSoXl_h>gRU!(lXU St#dhrr@'5]tOIH=g^R^3<2Xa!#VR4rr<%-c2bSlV)T:lH%`j2!!$<E!*RT63&uqP F/>ImcH!V_ML1S5A&c6rhVZo(a1\=@N)EMFV5Bc9H#oLAK_P68[B??rQAd7@+hbIp ]sb&FY+4tHkND$bS=Yu>n*b%+>*P>;P`CDW3&.hLXhDH^XfA4^Nf8pSKS5),H[0[Z EHCU+cFpNR!!%ZP;8rSYXT03?!"bt,zzzzzzzzzzzzzzzzz~> endstream endobj 248 0 obj /P 89 0 R  /R [ 99 126 531 675 ]  /V 245 0 R  /N 249 0 R  /T 1165 0 R  endobj 249 0 obj /P 93 0 R  /R [ 81 126 513 675 ]  /V 248 0 R  /N 250 0 R  /T 1165 0 R  endobj 250 0 obj /P 97 0 R  /R [ 99 126 531 675 ]  /V 249 0 R  /N 251 0 R  /T 1165 0 R  endobj 251 0 obj /P 101 0 R  /R [ 81 126 513 675 ]  /V 250 0 R  /N 253 0 R  /T 1165 0 R  endobj 252 0 obj /Type /Font  /Subtype /Type1  /Name /F16  /Encoding 262 0 R  /BaseFont /Courier-Bold  endobj 253 0 obj /P 105 0 R  /R [ 99 126 531 675 ]  /V 251 0 R  /N 254 0 R  /T 1165 0 R  endobj 254 0 obj /P 108 0 R  /R [ 81 126 513 675 ]  /V 253 0 R  /N 255 0 R  /T 1165 0 R  endobj 255 0 obj /P 111 0 R  /R [ 99 126 531 675 ]  /V 254 0 R  /N 256 0 R  /T 1165 0 R  endobj 256 0 obj /P 114 0 R  /R [ 81 126 513 675 ]  /V 255 0 R  /N 257 0 R  /T 1165 0 R  endobj 257 0 obj /P 117 0 R  /R [ 99 126 315 665 ]  /V 256 0 R  /N 258 0 R  /T 1165 0 R  endobj 258 0 obj /P 117 0 R  /R [ 315 126 531 513 ]  /V 257 0 R  /N 259 0 R  /T 1165 0 R  endobj 259 0 obj /P 145 0 R  /R [ 81 126 513 675 ]  /V 258 0 R  /N 260 0 R  /T 1165 0 R  endobj 260 0 obj /P 206 0 R  /R [ 99 126 531 675 ]  /V 259 0 R  /N 261 0 R  /T 1165 0 R  endobj 261 0 obj /P 218 0 R  /R [ 81 126 513 675 ]  /V 260 0 R  /N 2 0 R  /T 1165 0 R  endobj 262 0 obj /Type /Encoding  /Differences [ 39 /quotesingle 96 /grave 128 /Adieresis /Aring /Ccedilla /Eacute  /Ntilde /Odieresis /Udieresis /aacute /agrave /acircumflex /adieresis  /atilde /aring /ccedilla /eacute /egrave /ecircumflex /edieresis  /iacute /igrave /icircumflex /idieresis /ntilde /oacute /ograve  /ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex /udieresis  /dagger /.notdef 164 /section /bullet /paragraph /germandbls /registered  /copyright /trademark /acute /dieresis /.notdef /AE /Oslash 177  /.notdef /.notdef /.notdef /yen 182 /.notdef /.notdef /.notdef /.notdef  /.notdef /ordfeminine /ordmasculine /.notdef /ae /oslash /questiondown  /exclamdown /logicalnot /.notdef /florin /.notdef /.notdef /guillemotleft  /guillemotright /ellipsis /.notdef /Agrave /Atilde /Otilde /OE /oe  /endash /emdash /quotedblleft /quotedblright /quoteleft /quoteright  216 /ydieresis /Ydieresis /fraction /currency /guilsinglleft /guilsinglright  /fi /fl /daggerdbl /periodcentered /quotesinglbase /quotedblbase  /perthousand /Acircumflex /Ecircumflex /Aacute /Edieresis /Egrave  /Iacute /Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex 241  /Ograve /Uacute /Ucircumflex /Ugrave 246 /circumflex /tilde /macron  /breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron ]  endobj 263 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 264 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So%n#SRu47H774jDI+$O@SA/L`e$=(6ck8;OM'u >pu&^V@ttSWX0i=8EWp>jDHD2TMT<$3YDSu7&&).<4Y.tR89b\Bb`\*<ilh0enPqG j`\=EYZP^B4!g+,&I<p(,>bo:,!,gc_W2<bdd;1ggrEo$:!e%p#Qfah]1&4r'YTOs =M),.!$i0pDPRpo5_G<EhD/0uGh1Y-"cZuW]MLs3GUEJK6:)/cm?cI2ZIb##.gM`c C%>dG!BY^j!#\<S^)n'?$-MUPR4M1H4_rI"YubdCoLZ_@jh_.>[F_aOn)_=f)jorf D[#QOr%*"R8>Kl3Q!X\>4]^-6r7TbU=BJ8K&M9algo_(,FP%%@O[`=bAK[N/]&KBQ ;AEek)Bb+a&-s;,+eXEL1(/+N]='=7JgV'4,NdLm%KimKRIO+T!J#b-!qQ`8nK@q- CRZpW]HTHb;3)<2N>@1u;,gPG@F,&uJ8=?Q'odds/J5f/.!GD#O_Iou)T?0V0Y\35 n,Y9K?kNI,`-=gb0!%H5bJ$f"+"rn4)$N0]`E9?EJ;%83l[UO3N%tA5$pqNu%(h<Q J-3aV&f#H_>!W`G&A0P%!LR+-RM6II!/ecNQq)[7!!l)tJ/oO/]Mt)u)3onY>!rog ]f%DB+`Ls-e4!M2!LUYGN7CIm,4d?_iWr*i1#\YD6kuL</jWEh#[:\'YIdbD%hsQa <43KVM.bKa9l!$qV.B<q>@f6a=r*1@87hi+0ND)9J^E&nfn'Kj8?roJ6Tbq`(q_L+ @qFq8<)BCu;2&BX9KrZHq_'s11UYh#?<"$"86:HN!+Q%A2GRa!`Lmpq!+cn$*X@ET .7\o3GiSiuO1ZrB)ScM0L'>t%N%^+JWJiV<KqJW+<B.e1V@:P='1^J)Glp>IA-IVd CW._+:Dh"e-'SSk:gPed\n)4Ml!`_BS%*9^5Woin/*p8d&W>dOm%V94$"fm0?a]CB VW4[o>Ep*>!$ldi]^*%u\l'5S0X3bK+>=W7(rH!t(UPKd84<c8(E:nBJ^KE3Ka)(R ;AP@j"ChtThfM05L,TMoJR^C:&dUiY?5i@FU+)&@^_g;j"WY?J<Kq&:4\g>*^g&FE `]"A2nDa3DVJt9c(lAsW+957U_/S(9HA5fQ#nTJg#!RcmFZ:0J^%4S\eiQA'^uuTI !+#eY@2&\A-qF[f<rbK&Wt,1JRK-uF(15^H$;]on5X8Z!"eZ6G6(-+#TX&l7Qt6DP 4<u\uQiOsIM/&+p(l1.f)TFaC&"pEu^$#B."$?_fDO<54:hgf+&JGC:*(Pb$`lfFp NI_'J.KElu)$9^u$Ni-$QmW@P6MNBZOG1V>Jg:d-+B/lgLc-JsF:&.q4:D3\)a?:D ,!\t8&`Sf<\77e_J\X,NiFF_P5\_'@!+eQ-4=:IZ:agi*!<N8ce]CZ0'SL];MW5_b )Ag0t6$rfk?n<tB.*P(JR">kM3*-(\Qjj$$(']gGjG$L.k/;M*%&,jPLo:7RA,M(D !5:l63H>O8=J?<-5oYMZ)%=H&0+/m26%C[0!91N.#*P3([\.m?U,-L-J?26K0Ff-- &<@&p4ljX[a:uR;;[)(j5(Go>$\MQBB]488`+GAC,2D2Y!['uPf^p%"A0Z4Mc78sX VATD_%KKr2Ce]H$pO`0$$gnuU0:3Fu`-!42TE#`t)4pca`3oj@a=3$=jSo3&CCIQ2 f=5<WpkYaL#6Ap'Lu?:e>\%mU^q'CLqH$P5XY(!t:5R)c"rbB)>RM\$)Lr.6!U1%r &^E'O!5MdH']=hEPoc4n5ncB>fT)QPl-]Y0E[.RIC9@O;e@-PG!J85EK,#;\cRG,A WeCtT@LbOqJNYDPTX1[bNi]b;C]T./?@qgLQ;37f;<g#.Ic<IUJ3uXl!T7"]+uh(Y if)=@r##kS?Eo@/)`e)>nu1&#.>"c0+rqg@%+T*EL_3`36pQ;(JBdIC^p#!cG\[;D XA2H_72k>XQj-PGUI:7j%g(s02-,e=0i8#!@I)\P_@!51F\i8oL!I+,]KoM2m14'\ 4KBYG4TGJ^'o'D&&LA>'K1U38^q`&7(I%"ed6C8N`.t]/0E>%udM7A<!#:)2.gj0n ;1WZnY9AubLk#ci!rtHs+Zq3-/5&-V0IS,r=9\cJ66epdNtu?+7#.G;DhVZN$P%Cc ")+hH!PegM67W)m*"X@PR1sjh,:6Xr&o*#sf2"@sUBd*a3^Y"m!J'Ye$U?F/W/UFm KM?3cTb7CFR#/<3*(8aO!%S8(?VBO[<]%:CRmSS,Q,:lk<_9OULmjhF8a&\")guZ/ )[^"=!smq<Y11>hM@9h3!!#+a!<=,1T$>S:6X[.d7PIjR=uZKf0EI/"I\KM',Zb9P fJ0ZMq3RAK)JAcETO>[M&7UGG?[OC>^]8p"_-9iRh&\;&5dV.B\2FUe,U00L=/m0X M*l-&?:+F;^7l$$>N$*s>StZn_C/muc',HNB!2s&%5s$3s.BX`K<I<H6&"Z>KJ[Ao 'OXR)LnKmFp\9gcS"q;:i69Xa4BL6i*!D7M)?N/i'd-947-WlU"onXT`n9#p59S4c G;fNWmOKHg5n?PC;&1:%495n>j]FI)SAO5b0=g4Za2N"N(#'s`02?SaW)dCO>Vq"R 6*CIc[Jbiq!kaJ0Cu]\`MA="'J+N)$4#OPT,3#qpo$RXTPLLBV$=<_]5mH9/V]QLU kX#W=NR-=NBa:1>Q#SDsdGM'Oim6sT^L#==2]hqc)G@/BTWu/41d'nC!Vt*1/'%Nf OjY6R`fWs;m^"L.#*3i4G:B0#hCkJW"@g&f0#MG94+uo@Mq.=&+l@OJ@eB-J_><%l kD5uq'p>CdMa)@-KH6"LW`1^U_,_e0(on'\ZrMqNM=Qq2ALJf,~> endstream endobj 264 0 obj 2933  endobj 265 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 266 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE<[.O?jF+)%8u)-^757;Rp>0 1G+a)V@tsXQ>IS09]kmpbdM^[S]tg^3[GQ$8#0$s<4ZX!SPQ1`C/m<k<in9P<U3Yr j`\=EYZP^B4!g3;B=(P%2Oe9dh/Bf.DHAorf'O8^1[<3f\j7OeWX?^^FfI`O;c[:p m:;)@VH,3=)Y`SdSYDINTN.D[Wm,1F<`N+Ulg#hY]O]NQ/Tu]iKUsGE0)If.Oob~> endstream endobj 266 0 obj endobj 267 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 268 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H71_2`jE<[.O@W2&R3\(7,*YT.d^`mT ;_OM3+k%;r?8jd27jYLPFQRuqSks(+q#(PZ/##pRYhE':O&)]?k*6j]%\#\Ae`AYl j@VdFPK59dWa1Y0'q<nD<kDqOh/Bf.DHAoqliD=C?>ioWjnATPQIP?43XqD^CopgD obg^IASRi6WR-Ip0.i?]jmBRGI3T\;V,aR8Rf7W^'@P"11HGZ*=%p`u[+cFX)DRe; C[4%;Q#erhfPgMRhBs,!a5h8d>eXi0SHXOo~> endstream endobj 268 0 obj endobj 269 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 270 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@R(3p<\5,F`1p.b`-*dQO?k);W>pX[*g?XMdWnN0 ="fq7AlC^cenm@9:1mM9jS"!dTMT6@g*E\EJYZ1X</MA2QVTlqC/m<k<ioH):[/\+ j`\=5XOq-mq^!T.@C"U&dVDjkTkBj!Y#QEodcYMV?1/S6jnA:lY0X<fg[r5cC;8`n pfUoQbDaM/m+EAU="Tc_Aoh+fk'&t\ctIN)4XQJUEhH9P>.JK_"/a^e?m#~> endstream endobj 270 0 obj endobj 271 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 272 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE<[.O@Wn[3@'nb-^757;Rp>H >q_R=AlC^cenm@9:1mM9jS"!dTMT<$3[GQ$8#0$s<4ZX!SPQ1`C/m<k<ioH)<bk^H j`\=EYY(!84!g3;Aqbae<kDqOh/Bf.D@ij3f'RXbhJ2Nk~> endstream endobj 272 0 obj endobj 273 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 274 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@R(3p<\5,F`1p.b`-*dQO?k*FW3h:R*g?XMdMY`) ="fq7AlC^cenm@9:1mM9jS"!dTMT6@g*E\EJYZ1X<4ZWbI8-Y>-ri=)<ioH)<bh:G j`[CX5h;CsqXp/@-F6li[OL%4dqlO!DHAorf'R[o?>ioWjnAY&^gM+`4=1jRLW!YA =M/6)*KS9PE`5VR-@nV0AnAGu%So6?J:I~> endstream endobj 274 0 obj endobj 275 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 276 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE;GmO@Wn[3@'nR-^757;Rp<N 9.uZ+A9!HZ[V[sn7_fSWgoLN@TMT<$3[GQ$7>oK#<2iS5SPQ1].5GQZ!bGFu`bNpm /T.guLK&(j3^d/b<3t3=FfDGLdqXuaWK<%.jp-$]>O?O%-2,H(^gM+`49`U<KZ%>2 (i2)\*KS9//f76!7kFqfjmuWfk&poe\EC5%D$Ddd)UdkZqOIh^/ZctXU:Hh\f,%QD DKf0!L<!r?g2?[j4sq/+a5fb`[(H&jTaK^K\NN-Qg&_~> endstream endobj 276 0 obj endobj 277 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 278 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE<5.O@Wn[3@'2>-^757:h_Jh >q_>_k"uG<enlUhc-S7,jS"!dTE$B>3[GPrf9!E(e@I27F\e/s.Sr`k<cM'2<NB!m Kd*orXAl7kqXm=q4gS;M'[('rh++kXDH0o+f'O*Te1U<lrK_;I^gM%<qDFS(KVDDK 2;AnCq`i#0D>;n^T,/isk%F9)->Pc:Yh8Rd3L3uoUl+1i)S)F%=g*eKVRm;5ZXpJs _e)!$k4T0eaCMec0Eu/E^>s<D0G"~> endstream endobj 278 0 obj endobj 279 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 280 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE<)*O@Wn[3@'naJW<=`;MatR >q_R=@e.'7b&')-8nO9tUum(1SkrthqBZo:8#+CE'Y7j6SHY]dA9@X48jcRZ<aaHl ']ur0YZP^<.cjhg6F#6]<kDqOh/Bf.DHAorf'R[o?>ioWjnAY&^gM+`4=1jR$Eq<s (qaH>*KS9PE`jANQ:m"WAmiss~> endstream endobj 280 0 obj endobj 281 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 282 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE;GmO@Wn[#kXEW-^757;+Vb9 >q\Ick#4:9,%3F"[H)>l`7B?$TMT+u$7-II8#";)P_s#nKeo5uC,*kJ<ioH!e*C#F j?BhDV+=e_qD;BPB;nsD2Mpe#a`"7aY#d\b_S]im!%c^Cc-h)e^eui<3DKX@A&D_" =3P4CpPd'in2WNV7kG\"gF&DYDI5=ScY./ub_D!.UpOUlRVcZFK;d;b[M&O^T1cSa C?q?Pf&M1ni,EOXg%J@(<m,E+>eX`L!W~> endstream endobj 282 0 obj endobj 283 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 284 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE<)*O@Wn[3@'nb+H=M);FpGg >q_R4,kDjXY&,MS:1mM87,7r-TMT;uH1_q?6_mUi'P_0QPt7e"Re-B(!_$+j<b=.F eTSV>W7*9gRggFZB<56L[Y]Ztfl+B*DHAorf'R[o?>ioWjnAY&^gM+`4=1jRLW!YA =M*sT(')EdE`kN%="Tc^6EO-jAp6BHJ:I~> endstream endobj 284 0 obj endobj 285 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 286 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@R(3p<\5,F`1p.b`-*dQO?k,=BG?Us+d'cJnnC4( ;]_7KAlC^cenm@9:1mM9jS"!dTMT<$3NTrR!2(HK<4ZX!SPQ1^VDT9g<hVp_<bk^H j`\<uX&s1:F:E[(:M\L^f"5H6`D3ksD79><7ccJ<hJ'AZe`Q<X^>H-gbRN//LW!YA =M/6)*KS9PE`kN%="Tc_Aoh+fk'&t\[GPXsI3t7e6d]R)=dTH~> endstream endobj 286 0 obj endobj 287 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 288 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE;;iO@Wn[3?eYj-^757;408D -REQMAlC]0C2#Vs9I8/tAEJ;$Sks*"3[GQ$8#/O#o867#SK4QVB!hBi9!)'a<N>SG c!n@nYZP^=\s8<#B7e^8;0u9bd;Q&7DA6I^f'R[o?>ioDo_8GcT\f0?45KUOJ"Tdr '7+U!ObCed0[ktcMZ]*c?Rcc6XHKo?K&`g*SL*/@D3/#aHAkU;=eLdjj>s88_\K#r m5J7_k4a;=i,ED]\5qXLUkNWnHnK%i]`A~> endstream endobj 288 0 obj endobj 289 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 290 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE;GmO@Wn[3@'nR-^753kSWrX >q_O%jO1$'6=Dg89VrE$`3O/CTMT<$3[GQ$7to9%ZhdY\O\_oJBsfsK?E#0Jen\,$ ]RmV"YX3jU4!g3;B=(iYZ&*E$B3tXD/QY$1WnAPI>\\=aXnM^5X%@0Yg8q%AGc0Hh =)8;/#@55VnlED>Nus%Fb-2Wu/fug9_bR8bS=Z&8NgS5$\nnI+0;#sk+PH,\N\@HT l1#]eXSP`*P#1lj/_7O\Lm7&q:bDr^257eFG^'-o=0:*@G'dN/kBFVsn)5[c5:09` ip_8B<(I8~> endstream endobj 290 0 obj endobj 291 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 292 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE<[.O@Wn[3@'nb-^757;Rp>H >q_R=AlC^cenm@9:1mM9jS"!dTMT<$3[GQ$8#0$s<4ZX!SPQ1`C/m<k<ioH)<bk^H j`\=EYY(!84!g3;Aqbae<kDqOh/Bf.D@ij3f'RXbhJ2Nk~> endstream endobj 292 0 obj endobj 293 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 294 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@R(3p<\5,F`1p.b`-*dQO?k,=BG?Us+d'cJnnC4( ;]_7KAlC^cenm@9:1mM9jS"!dTMT<$3NTrR!2-!!<4ZX!SPQ1Xl4l@V:5N%feS1;) 'l'(?YZP^B4!g3;3NlV$1n+ZGZYHC3X*/ideff"Ch60nl/`Q_'PMbk#)s#$EJ&9BJ pZtX6*KS9PE`kN%="Tc_Aoh+fk'&t\ctIN(C_[;<VpnB&fXb+E?(c^u~> endstream endobj 294 0 obj endobj 295 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 296 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE;;iO@WnZkp2Qh-^754dOA_8 >q_L6-5/D8c;cfn:1mM9jS"!:Ra>ZOWYH:V5GV1gFD>@+Pq&NWl;]fkNNY^L<bkOs %;rjRYXg:m>7DK0AZj\HQARi*DeuAl/es:db$fG*?>=uujnAY&^K'W&$mkn>F.6L= =G`hd)0Ehcm5Z'P(G1ut?uhD*$k"/:c,?m`*@*tRT>]u0Q<dP#%o(Yl@CgkU4(YnV 5jU2;cM)b$KkL-B4s]Ot~> endstream endobj 296 0 obj endobj 297 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 298 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE<5.O@Wn[3@'nb,)aR<d^`ns >q_R2jUHJtWbWlIc=^(dUu$MaSks)t8Xtff5,$D=;X+,9QVXPZA!C/6<bj.ae>lTZ NEX"=Y#oL@3dS*VB=(iZ<kDqOcOU&,XuA8PcK#%Bgoe,E^"WF5^g34ZBRRK%LVt\S 3)g?Z)eR.MZ.V6o;^I^QA?_0]0K:Nm$Knc7+K_.6XOHG,)Ojh2=_l">'\XS)HYoIu .CVCODX2Y^<c>K-4=[["(#![fqHQfT*Q?b)G1h>A8$/*Cfs>YP2Lng`gZ\I%D/VM. S3Z:UTKchbCW#'-INL`if/:n^[D>*mfiOF.X_9KF.jQen'ZN:$87hi'!F+F14"q<j eM5t`#faJi@ljO>&F:=`4O/"WmP\pg:-B-h>MKHC%J0f!50a!\Ku7:#(;Z66'9K[i a<SdD`,O++d%hof!^K7QA$YC3&o4l6J`I,<Z\;8uY0TKgCkEWh+E1@ZY[q@,l*jAt @2@*!_sld4O9Dku95%6<oa9_E^d<SrX/?92m!@lP3/lmVc_*SVrWIc\r7nZRcoYdl JNua="+dVFcV)!96t\MV@&U4bd0%aojAB\])`XNA1Sj8,N.i3FeKn_E=gjN@&QBne Rr;TA"Z1&I2`6!7;GF37:BXaagmqL!NkJk+f%,c*&kt4-0c8Wi*M.o;<pamE1GW7S ZR1X#>pZmX$b:0/2Ymj6?5JU_H/=mim<G_!c1QMBQg1HOh8s6sJ`)nIka^Q;`VkMLQdPp~> endstream endobj 298 0 obj endobj 299 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 300 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*j;A%?KV2jQp:QD[-^726'"M7R =YH.9A.prXSnU-R:1mDfN4*ppTMT%]as@g_8#0$s<4X>?"p1^PC)&dp<iK0$<bc"J Keg>KYU_6(ARYgGA@#Gjp01h"fkS$$mT/W:<#cXc?10_1%JGig]ARSZ41u9OL8*Yo R#GW1*H_VFni(req^l94X"[\h*P4IOcs1YcX0(H(HbAJ/fF,!h"pk=2"aSfE!!.r2 J.OeZeg?<cgMa7):f%Q7X=E<h>@(kk=:T*JL4GSucL5;uBWZ]PQL`/u;f?KB0WM?" &.%h[>e:M/.P*)#'Slg>(EJD2Dm@'GDIb4%J-*%#5`c-uY1C:DqcFTKO<FTh)XG") \[4&c[*kE)@r><Y"^DNB.+$a.%6:[<IhJ^*HfAgk&:>Z/^Q6#")*_rS**+glbEW42 c?X#8LBI;q"L)dnN=/;g+^/ZCAKYdlaH%lsVEM_6'Eise0_5)ld*$I<2UBQa`C+N@ +M/A]QkBCR1*f.7WH,$Fg.:_'m*ISj)c6`5$;BO+7PkNd5s1*qrlIs=F#)#sPH68r Xt&fOeP]8@/O;k5b\W$^CpS#^dLnn%gX4<a[nWQ\lRmuPQ#0f.eeO0U="$ZR9S"S! b#qp"Q0j!,,ZVg+@FjZ(M.>0qrHi'Wp,.b>=r**oAQ^p&RZ1M$eYcVS2Vl&bUGg8A E$smua`H8S%@Dk#GAZ/[ed,9oT3XCXm<bbp#Q~> endstream endobj 300 0 obj endobj 301 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 302 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE<[.LoVe!3@'nb-^756E:=\O >1]*7A[=C]enI(4:0!!]I&_TZTIUR0e-`HT6DIF,oNGNIR7aDVl;[$'oiMq9K<#`U h.fCZ<`gmg)\nCN,QM"Y<gt*>*C?o0Y#cJ](.EDB?1,26e`qEu<`XeEbT7$?6,Z>H d+U@t*HJ+/.ChR$;ZD]kKgfK$eRL[r`8YcUaVABi"4RB@G>#raq0CV.Ufi*iZNf"b !5Td4?5GmUK1_$B'A<\H6DA1F,;9*_<HM.>.V`i1/-1q75q'?9?Bcqk#_Y</>k\1b 5gf=&2]Dd#!%ZTP[J+PJpLAR<6DRVaP?rE1TM-8'm%B75d%6KEaTD^.":5'Z.kIbI l,$6=')dn`+BJO]lGLoc4YP6d#6ffbG#goqJr6fsEGOpR6HDJ]haWLa5+ohJ]@I3* ijd>h&>2Roa?%KGR$j[`WrUHg6)abcJMFH.M`D/mG-$6[8.YlSXFsps54\V\K>1fm *\34*d.Ae]cSA3E7kp5@\^$:q.6+I$)sYbqMVN+Pa`FQITe*7GWBDB/RgDNad[D[9 Z')d(#dTZ+,mh[e`;`Q7l6O0u9Jm8EmAe[t2`s..`@FT]CJ6.\..fn8;cMt,fj!&C c#m=DQ-)C"fG4f;"e]g?NFUWW9pK0hp0F5%fle++M-:[sTkW6eIB@A?.,DFNgG]S\ ESQ@=QttA6/_,"![f)J7?5JU_H/=mim<d_,c1QMBQgOa$i"jl!F5%Gt%>3USeYduS p^S="hP^\~> endstream endobj 302 0 obj endobj 303 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 304 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE<[.LT;[u3@'nb-^756;#hF? >;)=:AeR1henI(1X!/1UjS"!_OK"M$'kI`/7\\8o1jW.GSP?%]-Xfhj<ioB&eYHRZ &-BMGY#m3?)[1E"-_8e)<D-n(77=W+mM)^]f'.CXKC,#*Xn$skP1jc_3it1I9>jcu oST2Of2n/=0G9<U3EQ@dJCT7`A^<M[cs=!P)P+Jq$<@m[\NHH`X9ojI>1q'#$Fu&4 e9<c!%C'"H#R#9-NFi8B'a'?DMF7J/h079=1d*9ooH)U7+BmuK>*Z9jins5t<!i`M .mPu]Zj<8h)8-Bbm&Im"YJ6Cs7&QGMPiu0=]g/TRMRn[D8d_b`6MB]XWDb9LRc2(\ #QZGbK`X1E]6^K-#.Xq=#/Eb@XZn4lp5lCaE"rrb_1S?]1eAVVWXrR2&cdY<U_s%r d6e2U^hBM!"$R*%ZH,G5gj4_jO\C6I]rm<eL6[\PXOYEA%$rG8dW@8gZ#UhKnB?_7 a!j&j6t8*t-qqdj0CkPL0K3k$!=PkY\t_?PK!a6b:%Sc8Y>CH8%7AMW9bfu?'Q"j\ U*L,RCXQ1a/PFP,bqb=.<5g"Ve.iE];5!RK9iKL(rB4%YQ#0f.U=D\D:8AVq2-<op asgOrPbiM(f9K'[@G$A^,_9&U9oDfsem4hZg(o[EC"elT8S$K;<>TN,QL,6;>8D(X ESQm1-@gU~> endstream endobj 304 0 obj endobj 305 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 306 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE<S8O@Wn[3@'n^+-T<.;HWS" 4Y)mlA^`Y-Jn[06:1mL='ZOu5SPX!!3+VlF-_aLH[!FjCR67<FC/m;k!j,P*<bh#J "_t_RW_R:%37X&2@@bk^2>^snh-76kDDl9qf'R[o?=G$2(^g(e^Yc5^/-ZUeLVmS? \(H]8"P:\%1-%I_="0KY`"e]Qk'&t\ctIN(][?p4%b']c)MYi.9WUMF[MpfY^MC11 D)YUo?rp:@e8R:V4sq":WoRqORiL<AB?fQ1H6!IWTHC0!osfBUk'o4bjRP1?IjX@[ \C^d?5.,$&/"G1UGWie0f@ph\l.XbY8?Yq]\k[VUk<P+:GjCW&:hBk3,-/$G50i2K #8Mbc+Uc'1;qUZYD:CW'3)=4h<J=kC*<8D[POR$%cT)%AMSc:lCP&]+!<TiO*!68U dCMYBTKmlJ'XVcQ.Ou6r+Tae<#S_%G6^!*c.5gOo>9jA`A:POhng%1i5:p)75S+J( FWAF849Yh=UIhTnO<J!T#KtQl)V?n-&J.?^"=OHW_c!<7.(lee;H\a*:_3c:nf6r` 7;YS-2$!\B!;T9o<7=RQ06=E+d;IDoo<WQ_=K=uU1rWJ:oH^>94caZ7h`(1M*mV\= AAo6];;HWJ56YU_@F;KqMb)Gu1co9qD;BhS:9?*t?Hj7UH"YEtfi]Rc:@#Z,foI\H =?R,TTeA&iRcpHIpMJ`1/LrT-FP`@dm"V/U~> endstream endobj 306 0 obj endobj 307 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 308 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE;SqO@UKl)'kMB-^72418siR >q_R=Al+=pVJRlPc=^(c9\t1^5fT`9q;iBO8#0$s<4Z'>SM$g:l'4<*:8:m\<FrRq jT`,"YZ!'[l,WqNB=(iZ<kDqC02;L=li7AU[dA:O79g<A*0nEk^#1R3)r+KaLW!?_ pF&2EI4`CuDYUfe(EGE#A@#=LUkTVNWDTga*4AmVS((oAdVSo;2lY<iA5Jg$1Ej!I m&ZT.Nk]S&h/)$(=sRa1^t%\BS5!VQO,8bOn$5V6%g1@soP]/lYB.D5n9=e49K,20 ac^F`]Pf\QK=%]!]tWr*V@h%Ar4[BIY7#UJUCZ,SMPUipYkC=TCIn]GN?Yld_(COj l+YM\/ITH&JcY~> endstream endobj 308 0 obj endobj 309 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 310 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE<5.O@Wn[3@'2>$33\0;Rp>H >q_L4jKgZK!_Xo"!%/?2K_BgXM`>=53ZEdgiM9?8/f:tpSPPKoVXSl=&uRgE<GKr3 `1jjlW*!XHp`/S@3N^ir[OYn./MjK^A<qHdC5I%cfrl/qD>*X0^Y[s/C)iiDIApK: QRMPKgHiAIBmD`s,+01@k&S#6huc!/ctDr.]QJtnJ\5]5=IC2M,9am/YBm<.^=@AX lo'3l'L,Hmg/IY@fG=dH'qoMU1p!iYR7G\FVn0u-k7qOl:\#/oG$CTqn7<ft/J"2i kKWXG1@CuZ%><S=4afK%hhu]Lr9S]h<0thU]hd'Ul61(tdYtt;A*Q=QO>HCY\;%X/ QFLfX-FY2'Hg]L\E4T*D^!4JTNC2&4(>H[L/4gJ`k^/Kl]<R8HMFEYD,9*`QlXLj3 $R>N!`tAf7+ioI;!W~> endstream endobj 310 0 obj endobj 311 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 312 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE<)*O@Wn[3?eYj$33\0;Rp>H >q_M_jKgZK!_Xo"!%/?"K_BgYR7O#mBr)Sd5GV1g1`6`4MaiWQW`/,^J\t9X\8';- eT/9,Xk.$i4!_D*,D8oE'6ppNh(#bP,o4%]maH?D>OC$u,jP11]jBama>L!^6FPfg QPhV-%>VK'EE+Q%7gkEcA?p<IY%@iu[DoOu9HDSJ=OCgRRTb/i0o_snW#EouT3Hf^ mP)7)Sc8T!JaYP&9;]<UWSpN,\a?dlA')&o,`l>Kdui"EoWXljXCndkjlO#*%_mJO g<VYRQqEF.=lI;FqKrb`dt@(Rm^N3la61gf4D[+%pHB(^?NIgcK4+@;mdp:O^<hfb $,Ve*/ITH-bV]j=%=?%/61,X#%lr"t9bYJX637~> endstream endobj 312 0 obj endobj 313 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 314 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE;GmO@Wn[3@'nb,EGH.;Rp&( >q_Db-;c4Fenm456`/:'bk?HLKun!AWHA]18#0$l'=q_o/PN!?C/m8nM?Q_U80_+! V09NcXOlf>4!S(6Aus'i[^o21MeomnD"d*NU4mU";sotKc1_)X[9]tZHi=d0K:Utq 3':5"Q[t`<Z<9/s""fk`AodWX^2#m"]j`<+8ds:GT@@Uu=hQ.$75rfaG$@(/VLbf' DKdn,7ale#K>9_~> endstream endobj 314 0 obj endobj 315 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 316 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE<[.O@Wn[3@'nb-^757;Rp>H >q_R=AlC^cenm@9:1mM9jS"!dTMT<$3[GQ$8#0$s<4ZX!SPQ1`C/m<k<ioH)<bk^H j`\=EYY(!84!g3;Aqbae<kDqOh/Bf.D@ij3f'RXbhJ2Nk~> endstream endobj 316 0 obj endobj 317 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 318 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@R(3p<\5,F`1p.b`-*dQO?k,<BXELg*g?XMdMY`= ="fq7AlC^cenm@9:1mM9jS"!dTMT5ug*E\P8#0$s#T@83"%n5FWO3)0<ioGZe>\^j jY"/(Vq9jm)\hkNB=$9"FfR*gVeVRO/iLn,Ibe4ih<pT@h:Cb8\)/kTS+Q^K=2W._ <\.Q,h1`p@0U:E68e60Tj(>h!NC,4IK&UB&r6o"5S]>-s>(&eS5HWN!0q)7"dp]_: AFUV<?BUjFZtm(=M>%73=l4%nP[7u\>?p3.qHZ+O"9~> endstream endobj 318 0 obj endobj 319 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 320 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE;;iO@Wn:,Reu,,*C!D;Rp=% ;';1KAl.0.^+CY!c=W8Ce@KETMpLT#fp)%f6D;dLoI2'>PmjNZVtBeU,,J4odA(f? 'iM^[XB4ah$Oll7.'_K9(!2,XSQiDRWqQ54>30_*>3[p0[,1Cu]%\YkS(p'XJ<eo/ fR-.GYCa47Z5)*=3`VB[je@"!hG5Gbc/E_G9S?>!BTqVd3fP/D)1L3'@9O+^Vb(.H >'4&>h9Q73hsWJ6)K(m+\Cb/5:n?JrM9<*q3Sclq(Jhu%J3.&NkBFVsn9B="5/0ak kO`Y"+9~> endstream endobj 320 0 obj endobj 321 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 322 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE;GmO@WnZke)dHJW`W:;+Wm1 ="fq-V6UDd:1lGS:0R6L%-eWkP>A,S\cea_8#0$s<4ZX!SPQ1`C/m<k<ioH)<bk^H j`\=EYZP^B4!g3;B=(iZ<kDqOh/Bf.DHAorf'R[ld:\[$"nqnE^gM+`4=1Q52nWU8O:V~> endstream endobj 322 0 obj endobj 323 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Width 63 /Height 81 /ColorSpace 327 0 R  /BitsPerComponent 8 /Length 324 0 R >>  stream J2Q7]3$]7K#D>EP:q1$o*=mro@So+\<\5,H7Uo<*jE<[.O@Wn[3@'nb-^757;Rp>H >q_R=AlC^cenm@9:1mM9jS"!dTMT<$3[GQ$8#0$s<4ZX!SPQ1`C/m<k<ioH)<bk^H j`\=EYY(!84!g3;Aqbae<kDqOh/Bf.D@ij3f'RXbhJ2Nk~> endstream endobj 324 0 obj endobj 325 0 obj endobj 326 0 obj << /Filter [ /ASCII85Decode /LZWDecode ] /Length 325 0 R >>  stream J,g]g+e/h_!_gCtO=0f)$P%cIi8Zdfc5&3j_8$7g.@L`YKUJNGBP\poR=_;Dl'P(T (7Boo^^S:71(MN]ZQX/+Cbu.lK"p74pe1T%s.DY%&\1TdJhr54.M9au6>79n6`Q:4 PbLSZTLEE(8E@'*1mg_*eTnN*;*'V3+gm-EEetX%;Bo$ur2ss*N`.-!.kG_q6GDD' dKoL!8Ka#EV,@V!\j8ZFbp6EE<9cn=N6j<M8Q?[#7"dq'1>0nf;(&;QU6bUD')c@\ 9-d\DA=cZ0Q>gIM$$;cd2O@&a;X,Nn_a<?V-PVE%?Sf]idH6WRZqHGq]Zm<uCi"]? Stg(<gV-H9NB<SA\T=sN)Il%(BDIak7/H&mV!kmDUo4X;8;]V>P(]I1aRc(K1^ue> gF/(+GaKo$qneLWDrQ#;5\S(\$q'4Q,85`-8;S(=Z"WSBOV*FM)4,?B],R<gbPN=# OmIK<a:\o8+ioO-!W~> endstream endobj 327 0 obj /Indexed /DeviceRGB 255 326 0 R  endobj 328 0 obj /D [ 1167 0 R /XYZ null 11 null ]  endobj 329 0 obj /D [ 1167 0 R /XYZ null 34 null ]  endobj 330 0 obj /D [ 1167 0 R /XYZ null null null ]  endobj 331 0 obj /D [ 1167 0 R /XYZ null null null ]  endobj 332 0 obj /D [ 1167 0 R /XYZ null null null ]  endobj 333 0 obj /D [ 1 0 R /XYZ null 777 null ]  endobj 334 0 obj /D [ 1 0 R /XYZ null 755 null ]  endobj 335 0 obj /D [ 1 0 R /XYZ null 597 null ]  endobj 336 0 obj /D [ 1 0 R /XYZ null 455 null ]  endobj 337 0 obj /D [ 1 0 R /XYZ null 443 null ]  endobj 338 0 obj /D [ 1 0 R /XYZ null 733 null ]  endobj 339 0 obj /D [ 1 0 R /XYZ null null null ]  endobj 340 0 obj /D [ 6 0 R /XYZ null 534 null ]  endobj 341 0 obj /D [ 6 0 R /XYZ null 514 null ]  endobj 342 0 obj /D [ 6 0 R /XYZ null 497 null ]  endobj 343 0 obj /D [ 6 0 R /XYZ null 483 null ]  endobj 344 0 obj /D [ 6 0 R /XYZ null 473 null ]  endobj 345 0 obj /D [ 6 0 R /XYZ null 463 null ]  endobj 346 0 obj /D [ 6 0 R /XYZ null 444 null ]  endobj 347 0 obj /D [ 6 0 R /XYZ null 427 null ]  endobj 348 0 obj /D [ 6 0 R /XYZ null 336 null ]  endobj 349 0 obj /D [ 6 0 R /XYZ null 416 null ]  endobj 350 0 obj /D [ 6 0 R /XYZ null 407 null ]  endobj 351 0 obj /D [ 6 0 R /XYZ null 398 null ]  endobj 352 0 obj /D [ 6 0 R /XYZ null 389 null ]  endobj 353 0 obj /D [ 6 0 R /XYZ null 380 null ]  endobj 354 0 obj /D [ 6 0 R /XYZ null 371 null ]  endobj 355 0 obj /D [ 6 0 R /XYZ null 362 null ]  endobj 356 0 obj /D [ 6 0 R /XYZ null 353 null ]  endobj 357 0 obj /D [ 6 0 R /XYZ null 416 null ]  endobj 358 0 obj /D [ 6 0 R /XYZ null 407 null ]  endobj 359 0 obj /D [ 6 0 R /XYZ null 398 null ]  endobj 360 0 obj /D [ 6 0 R /XYZ null 389 null ]  endobj 361 0 obj /D [ 6 0 R /XYZ null 380 null ]  endobj 362 0 obj /D [ 6 0 R /XYZ null 371 null ]  endobj 363 0 obj /D [ 6 0 R /XYZ null 362 null ]  endobj 364 0 obj /D [ 6 0 R /XYZ null 813 null ]  endobj 365 0 obj /D [ 6 0 R /XYZ null 798 null ]  endobj 366 0 obj /D [ 6 0 R /XYZ null 783 null ]  endobj 367 0 obj /D [ 6 0 R /XYZ null 758 null ]  endobj 368 0 obj /D [ 6 0 R /XYZ null 743 null ]  endobj 369 0 obj /D [ 6 0 R /XYZ null 728 null ]  endobj 370 0 obj /D [ 6 0 R /XYZ null 703 null ]  endobj 371 0 obj /D [ 6 0 R /XYZ null 689 null ]  endobj 372 0 obj /D [ 6 0 R /XYZ null 679 null ]  endobj 373 0 obj /D [ 6 0 R /XYZ null 666 null ]  endobj 374 0 obj /D [ 6 0 R /XYZ null 656 null ]  endobj 375 0 obj /D [ 6 0 R /XYZ null 646 null ]  endobj 376 0 obj /D [ 6 0 R /XYZ null 636 null ]  endobj 377 0 obj /D [ 6 0 R /XYZ null 621 null ]  endobj 378 0 obj /D [ 6 0 R /XYZ null null null ]  endobj 379 0 obj /D [ 6 0 R /XYZ null null null ]  endobj 380 0 obj /D [ 9 0 R /XYZ null 266 null ]  endobj 381 0 obj /D [ 9 0 R /XYZ null 250 null ]  endobj 382 0 obj /D [ 9 0 R /XYZ null 821 null ]  endobj 383 0 obj /D [ 9 0 R /XYZ null 793 null ]  endobj 384 0 obj /D [ 9 0 R /XYZ null 697 null ]  endobj 385 0 obj /D [ 9 0 R /XYZ null 641 null ]  endobj 386 0 obj /D [ 9 0 R /XYZ null 615 null ]  endobj 387 0 obj /D [ 9 0 R /XYZ null 601 null ]  endobj 388 0 obj /D [ 9 0 R /XYZ null 588 null ]  endobj 389 0 obj /D [ 9 0 R /XYZ null 575 null ]  endobj 390 0 obj /D [ 9 0 R /XYZ null 562 null ]  endobj 391 0 obj /D [ 9 0 R /XYZ null 549 null ]  endobj 392 0 obj /D [ 9 0 R /XYZ null 524 null ]  endobj 393 0 obj /D [ 9 0 R /XYZ null 510 null ]  endobj 394 0 obj /D [ 9 0 R /XYZ null 497 null ]  endobj 395 0 obj /D [ 9 0 R /XYZ null 484 null ]  endobj 396 0 obj /D [ 9 0 R /XYZ null 471 null ]  endobj 397 0 obj /D [ 9 0 R /XYZ null 446 null ]  endobj 398 0 obj /D [ 9 0 R /XYZ null null null ]  endobj 399 0 obj /D [ 9 0 R /XYZ null null null ]  endobj 400 0 obj /D [ 9 0 R /XYZ null 647 null ]  endobj 401 0 obj /D [ 9 0 R /XYZ null 621 null ]  endobj 402 0 obj /D [ 9 0 R /XYZ null 608 null ]  endobj 403 0 obj /D [ 9 0 R /XYZ null 595 null ]  endobj 404 0 obj /D [ 9 0 R /XYZ null 582 null ]  endobj 405 0 obj /D [ 9 0 R /XYZ null 569 null ]  endobj 406 0 obj /D [ 9 0 R /XYZ null 556 null ]  endobj 407 0 obj /D [ 9 0 R /XYZ null 530 null ]  endobj 408 0 obj /D [ 9 0 R /XYZ null 517 null ]  endobj 409 0 obj /D [ 9 0 R /XYZ null 504 null ]  endobj 410 0 obj /D [ 9 0 R /XYZ null 491 null ]  endobj 411 0 obj /D [ 9 0 R /XYZ null 478 null ]  endobj 412 0 obj /D [ 9 0 R /XYZ null 452 null ]  endobj 413 0 obj /D [ 25 0 R /XYZ null 266 null ]  endobj 414 0 obj /D [ 25 0 R /XYZ null 250 null ]  endobj 415 0 obj /D [ 25 0 R /XYZ null null null ]  endobj 416 0 obj /D [ 25 0 R /XYZ null null null ]  endobj 417 0 obj /D [ 28 0 R /XYZ null 266 null ]  endobj 418 0 obj /D [ 28 0 R /XYZ null 250 null ]  endobj 419 0 obj /D [ 28 0 R /XYZ null 821 null ]  endobj 420 0 obj /D [ 28 0 R /XYZ null 793 null ]  endobj 421 0 obj /D [ 28 0 R /XYZ null 697 null ]  endobj 422 0 obj /D [ 28 0 R /XYZ null 640 null ]  endobj 423 0 obj /D [ 28 0 R /XYZ null 578 null ]  endobj 424 0 obj /D [ 28 0 R /XYZ null null null ]  endobj 425 0 obj /D [ 28 0 R /XYZ null null null ]  endobj 426 0 obj /D [ 31 0 R /XYZ null 266 null ]  endobj 427 0 obj /D [ 31 0 R /XYZ null 250 null ]  endobj 428 0 obj /D [ 31 0 R /XYZ null 799 null ]  endobj 429 0 obj /D [ 31 0 R /XYZ null 772 null ]  endobj 430 0 obj /D [ 31 0 R /XYZ null 737 null ]  endobj 431 0 obj /D [ 31 0 R /XYZ null 604 null ]  endobj 432 0 obj /D [ 31 0 R /XYZ null 582 null ]  endobj 433 0 obj /D [ 31 0 R /XYZ null 556 null ]  endobj 434 0 obj /D [ 31 0 R /XYZ null 543 null ]  endobj 435 0 obj /D [ 31 0 R /XYZ null 530 null ]  endobj 436 0 obj /D [ 31 0 R /XYZ null 487 null ]  endobj 437 0 obj /D [ 31 0 R /XYZ null 463 null ]  endobj 438 0 obj /D [ 31 0 R /XYZ null 380 null ]  endobj 439 0 obj /D [ 31 0 R /XYZ null 354 null ]  endobj 440 0 obj /D [ 31 0 R /XYZ null 724 null ]  endobj 441 0 obj /D [ 31 0 R /XYZ null 724 null ]  endobj 442 0 obj /D [ 31 0 R /XYZ null 724 null ]  endobj 443 0 obj /D [ 31 0 R /XYZ null 706 null ]  endobj 444 0 obj /D [ 31 0 R /XYZ null 707 null ]  endobj 445 0 obj /D [ 31 0 R /XYZ null 707 null ]  endobj 446 0 obj /D [ 31 0 R /XYZ null 678 null ]  endobj 447 0 obj /D [ 31 0 R /XYZ null 679 null ]  endobj 448 0 obj /D [ 31 0 R /XYZ null 679 null ]  endobj 449 0 obj /D [ 31 0 R /XYZ null null null ]  endobj 450 0 obj /D [ 38 0 R /XYZ null 266 null ]  endobj 451 0 obj /D [ 38 0 R /XYZ null 250 null ]  endobj 452 0 obj /D [ 38 0 R /XYZ null 803 null ]  endobj 453 0 obj /D [ 38 0 R /XYZ null 777 null ]  endobj 454 0 obj /D [ 38 0 R /XYZ null 708 null ]  endobj 455 0 obj /D [ 38 0 R /XYZ null 609 null ]  endobj 456 0 obj /D [ 38 0 R /XYZ null 582 null ]  endobj 457 0 obj /D [ 38 0 R /XYZ null 527 null ]  endobj 458 0 obj /D [ 38 0 R /XYZ null 479 null ]  endobj 459 0 obj /D [ 38 0 R /XYZ null 453 null ]  endobj 460 0 obj /D [ 38 0 R /XYZ null 427 null ]  endobj 461 0 obj /D [ 38 0 R /XYZ null 401 null ]  endobj 462 0 obj /D [ 38 0 R /XYZ null 362 null ]  endobj 463 0 obj /D [ 38 0 R /XYZ null 336 null ]  endobj 464 0 obj /D [ 38 0 R /XYZ null 310 null ]  endobj 465 0 obj /D [ 38 0 R /XYZ null null null ]  endobj 466 0 obj /D [ 41 0 R /XYZ null 803 null ]  endobj 467 0 obj /D [ 41 0 R /XYZ null 759 null ]  endobj 468 0 obj /D [ 41 0 R /XYZ null 733 null ]  endobj 469 0 obj /D [ 41 0 R /XYZ null 677 null ]  endobj 470 0 obj /D [ 41 0 R /XYZ null 649 null ]  endobj 471 0 obj /D [ 41 0 R /XYZ null 610 null ]  endobj 472 0 obj /D [ 41 0 R /XYZ null 597 null ]  endobj 473 0 obj /D [ 41 0 R /XYZ null 571 null ]  endobj 474 0 obj /D [ 41 0 R /XYZ null null null ]  endobj 475 0 obj /D [ 44 0 R /XYZ null 799 null ]  endobj 476 0 obj /D [ 44 0 R /XYZ null 772 null ]  endobj 477 0 obj /D [ 44 0 R /XYZ null 746 null ]  endobj 478 0 obj /D [ 44 0 R /XYZ null 690 null ]  endobj 479 0 obj /D [ 44 0 R /XYZ null 639 null ]  endobj 480 0 obj /D [ 44 0 R /XYZ null 574 null ]  endobj 481 0 obj /D [ 44 0 R /XYZ null 523 null ]  endobj 482 0 obj /D [ 44 0 R /XYZ null 475 null ]  endobj 483 0 obj /D [ 44 0 R /XYZ null 423 null ]  endobj 484 0 obj /D [ 44 0 R /XYZ null 371 null ]  endobj 485 0 obj /D [ 44 0 R /XYZ null 319 null ]  endobj 486 0 obj /D [ 44 0 R /XYZ null null null ]  endobj 487 0 obj /D [ 47 0 R /XYZ null 803 null ]  endobj 488 0 obj /D [ 47 0 R /XYZ null 712 null ]  endobj 489 0 obj /D [ 47 0 R /XYZ null 686 null ]  endobj 490 0 obj /D [ 47 0 R /XYZ null 608 null ]  endobj 491 0 obj /D [ 47 0 R /XYZ null 569 null ]  endobj 492 0 obj /D [ 47 0 R /XYZ null null null ]  endobj 493 0 obj /D [ 47 0 R /XYZ null null null ]  endobj 494 0 obj /D [ 50 0 R /XYZ null 266 null ]  endobj 495 0 obj /D [ 50 0 R /XYZ null 250 null ]  endobj 496 0 obj /D [ 50 0 R /XYZ null 817 null ]  endobj 497 0 obj /D [ 50 0 R /XYZ null 793 null ]  endobj 498 0 obj /D [ 50 0 R /XYZ null 697 null ]  endobj 499 0 obj /D [ 50 0 R /XYZ null 640 null ]  endobj 500 0 obj /D [ 50 0 R /XYZ null 601 null ]  endobj 501 0 obj /D [ 50 0 R /XYZ null 575 null ]  endobj 502 0 obj /D [ 50 0 R /XYZ null 562 null ]  endobj 503 0 obj /D [ 50 0 R /XYZ null 549 null ]  endobj 504 0 obj /D [ 50 0 R /XYZ null 536 null ]  endobj 505 0 obj /D [ 50 0 R /XYZ null 523 null ]  endobj 506 0 obj /D [ 50 0 R /XYZ null 510 null ]  endobj 507 0 obj /D [ 50 0 R /XYZ null 500 null ]  endobj 508 0 obj /D [ 50 0 R /XYZ null null null ]  endobj 509 0 obj /D [ 50 0 R /XYZ null null null ]  endobj 510 0 obj /D [ 50 0 R /XYZ null 711 null ]  endobj 511 0 obj /D [ 50 0 R /XYZ null 711 null ]  endobj 512 0 obj /D [ 58 0 R /XYZ null 266 null ]  endobj 513 0 obj /D [ 58 0 R /XYZ null 250 null ]  endobj 514 0 obj /D [ 58 0 R /XYZ null 798 null ]  endobj 515 0 obj /D [ 58 0 R /XYZ null 770 null ]  endobj 516 0 obj /D [ 58 0 R /XYZ null 685 null ]  endobj 517 0 obj /D [ 58 0 R /XYZ null 661 null ]  endobj 518 0 obj /D [ 58 0 R /XYZ null 579 null ]  endobj 519 0 obj /D [ 58 0 R /XYZ null 555 null ]  endobj 520 0 obj /D [ 58 0 R /XYZ null 519 null ]  endobj 521 0 obj /D [ 58 0 R /XYZ null 496 null ]  endobj 522 0 obj /D [ 58 0 R /XYZ null 496 null ]  endobj 523 0 obj /D [ 58 0 R /XYZ null 479 null ]  endobj 524 0 obj /D [ 58 0 R /XYZ null 479 null ]  endobj 525 0 obj /D [ 58 0 R /XYZ null 468 null ]  endobj 526 0 obj /D [ 58 0 R /XYZ null 451 null ]  endobj 527 0 obj /D [ 58 0 R /XYZ null 451 null ]  endobj 528 0 obj /D [ 58 0 R /XYZ null 434 null ]  endobj 529 0 obj /D [ 58 0 R /XYZ null 434 null ]  endobj 530 0 obj /D [ 58 0 R /XYZ null 406 null ]  endobj 531 0 obj /D [ 58 0 R /XYZ null null null ]  endobj 532 0 obj /D [ 58 0 R /XYZ null 810 null ]  endobj 533 0 obj /D [ 58 0 R /XYZ null 810 null ]  endobj 534 0 obj /D [ 58 0 R /XYZ null 697 null ]  endobj 535 0 obj /D [ 58 0 R /XYZ null 697 null ]  endobj 536 0 obj /D [ 58 0 R /XYZ null 588 null ]  endobj 537 0 obj /D [ 58 0 R /XYZ null 588 null ]  endobj 538 0 obj /D [ 58 0 R /XYZ null 810 null ]  endobj 539 0 obj /D [ 58 0 R /XYZ null 588 null ]  endobj 540 0 obj /D [ 58 0 R /XYZ null 525 null ]  endobj 541 0 obj /D [ 58 0 R /XYZ null 525 null ]  endobj 542 0 obj /D [ 58 0 R /XYZ null 777 null ]  endobj 543 0 obj /D [ 58 0 R /XYZ null 697 null ]  endobj 544 0 obj /D [ 62 0 R /XYZ null 266 null ]  endobj 545 0 obj /D [ 62 0 R /XYZ null 250 null ]  endobj 546 0 obj /D [ 62 0 R /XYZ null 801 null ]  endobj 547 0 obj /D [ 62 0 R /XYZ null 777 null ]  endobj 548 0 obj /D [ 62 0 R /XYZ null 692 null ]  endobj 549 0 obj /D [ 62 0 R /XYZ null 668 null ]  endobj 550 0 obj /D [ 62 0 R /XYZ null 630 null ]  endobj 551 0 obj /D [ 62 0 R /XYZ null 597 null ]  endobj 552 0 obj /D [ 62 0 R /XYZ null 597 null ]  endobj 553 0 obj /D [ 62 0 R /XYZ null 580 null ]  endobj 554 0 obj /D [ 62 0 R /XYZ null 580 null ]  endobj 555 0 obj /D [ 62 0 R /XYZ null 563 null ]  endobj 556 0 obj /D [ 62 0 R /XYZ null 563 null ]  endobj 557 0 obj /D [ 62 0 R /XYZ null 535 null ]  endobj 558 0 obj /D [ 62 0 R /XYZ null 535 null ]  endobj 559 0 obj /D [ 62 0 R /XYZ null 518 null ]  endobj 560 0 obj /D [ 62 0 R /XYZ null 518 null ]  endobj 561 0 obj /D [ 62 0 R /XYZ null 479 null ]  endobj 562 0 obj /D [ 62 0 R /XYZ null 479 null ]  endobj 563 0 obj /D [ 62 0 R /XYZ null 462 null ]  endobj 564 0 obj /D [ 62 0 R /XYZ null 462 null ]  endobj 565 0 obj /D [ 62 0 R /XYZ null 434 null ]  endobj 566 0 obj /D [ 62 0 R /XYZ null 434 null ]  endobj 567 0 obj /D [ 62 0 R /XYZ null 406 null ]  endobj 568 0 obj /D [ 62 0 R /XYZ null 406 null ]  endobj 569 0 obj /D [ 62 0 R /XYZ null null null ]  endobj 570 0 obj /D [ 62 0 R /XYZ null 810 null ]  endobj 571 0 obj /D [ 62 0 R /XYZ null 810 null ]  endobj 572 0 obj /D [ 62 0 R /XYZ null 704 null ]  endobj 573 0 obj /D [ 62 0 R /XYZ null 704 null ]  endobj 574 0 obj /D [ 62 0 R /XYZ null 586 null ]  endobj 575 0 obj /D [ 62 0 R /XYZ null 569 null ]  endobj 576 0 obj /D [ 62 0 R /XYZ null 541 null ]  endobj 577 0 obj /D [ 62 0 R /XYZ null 524 null ]  endobj 578 0 obj /D [ 62 0 R /XYZ null 485 null ]  endobj 579 0 obj /D [ 62 0 R /XYZ null 468 null ]  endobj 580 0 obj /D [ 62 0 R /XYZ null 440 null ]  endobj 581 0 obj /D [ 62 0 R /XYZ null 412 null ]  endobj 582 0 obj /D [ 62 0 R /XYZ null 636 null ]  endobj 583 0 obj /D [ 62 0 R /XYZ null 636 null ]  endobj 584 0 obj /D [ 62 0 R /XYZ null 704 null ]  endobj 585 0 obj /D [ 62 0 R /XYZ null 810 null ]  endobj 586 0 obj /D [ 66 0 R /XYZ null null null ]  endobj 587 0 obj /D [ 66 0 R /XYZ null null null ]  endobj 588 0 obj /D [ 69 0 R /XYZ null 266 null ]  endobj 589 0 obj /D [ 69 0 R /XYZ null 250 null ]  endobj 590 0 obj /D [ 69 0 R /XYZ null 817 null ]  endobj 591 0 obj /D [ 69 0 R /XYZ null 793 null ]  endobj 592 0 obj /D [ 69 0 R /XYZ null 697 null ]  endobj 593 0 obj /D [ 69 0 R /XYZ null 616 null ]  endobj 594 0 obj /D [ 69 0 R /XYZ null 564 null ]  endobj 595 0 obj /D [ 69 0 R /XYZ null 538 null ]  endobj 596 0 obj /D [ 69 0 R /XYZ null 525 null ]  endobj 597 0 obj /D [ 69 0 R /XYZ null 512 null ]  endobj 598 0 obj /D [ 69 0 R /XYZ null 499 null ]  endobj 599 0 obj /D [ 69 0 R /XYZ null 489 null ]  endobj 600 0 obj /D [ 69 0 R /XYZ null null null ]  endobj 601 0 obj /D [ 69 0 R /XYZ null 711 null ]  endobj 602 0 obj /D [ 69 0 R /XYZ null 711 null ]  endobj 603 0 obj /D [ 76 0 R /XYZ null 266 null ]  endobj 604 0 obj /D [ 76 0 R /XYZ null 250 null ]  endobj 605 0 obj /D [ 76 0 R /XYZ null 798 null ]  endobj 606 0 obj /D [ 76 0 R /XYZ null 770 null ]  endobj 607 0 obj /D [ 76 0 R /XYZ null 698 null ]  endobj 608 0 obj /D [ 76 0 R /XYZ null 670 null ]  endobj 609 0 obj /D [ 76 0 R /XYZ null 631 null ]  endobj 610 0 obj /D [ 76 0 R /XYZ null 605 null ]  endobj 611 0 obj /D [ 76 0 R /XYZ null 592 null ]  endobj 612 0 obj /D [ 76 0 R /XYZ null 553 null ]  endobj 613 0 obj /D [ 76 0 R /XYZ null 471 null ]  endobj 614 0 obj /D [ 76 0 R /XYZ null 397 null ]  endobj 615 0 obj /D [ 76 0 R /XYZ null 358 null ]  endobj 616 0 obj /D [ 76 0 R /XYZ null 319 null ]  endobj 617 0 obj /D [ 76 0 R /XYZ null 293 null ]  endobj 618 0 obj /D [ 76 0 R /XYZ null 710 null ]  endobj 619 0 obj /D [ 76 0 R /XYZ null 810 null ]  endobj 620 0 obj /D [ 76 0 R /XYZ null 810 null ]  endobj 621 0 obj /D [ 76 0 R /XYZ null 710 null ]  endobj 622 0 obj /D [ 76 0 R /XYZ null 710 null ]  endobj 623 0 obj /D [ 79 0 R /XYZ null 266 null ]  endobj 624 0 obj /D [ 79 0 R /XYZ null 250 null ]  endobj 625 0 obj /D [ 79 0 R /XYZ null 803 null ]  endobj 626 0 obj /D [ 79 0 R /XYZ null 764 null ]  endobj 627 0 obj /D [ 79 0 R /XYZ null 738 null ]  endobj 628 0 obj /D [ 79 0 R /XYZ null 712 null ]  endobj 629 0 obj /D [ 79 0 R /XYZ null 686 null ]  endobj 630 0 obj /D [ 79 0 R /XYZ null 660 null ]  endobj 631 0 obj /D [ 79 0 R /XYZ null 621 null ]  endobj 632 0 obj /D [ 79 0 R /XYZ null 595 null ]  endobj 633 0 obj /D [ 79 0 R /XYZ null 628 null ]  endobj 634 0 obj /D [ 83 0 R /XYZ null 803 null ]  endobj 635 0 obj /D [ 83 0 R /XYZ null 751 null ]  endobj 636 0 obj /D [ 83 0 R /XYZ null 446 null ]  endobj 637 0 obj /D [ 83 0 R /XYZ null 420 null ]  endobj 638 0 obj /D [ 83 0 R /XYZ null 355 null ]  endobj 639 0 obj /D [ 83 0 R /XYZ null 303 null ]  endobj 640 0 obj /D [ 83 0 R /XYZ null 453 null ]  endobj 641 0 obj /D [ 83 0 R /XYZ null 310 null ]  endobj 642 0 obj /D [ 89 0 R /XYZ null 803 null ]  endobj 643 0 obj /D [ 89 0 R /XYZ null 505 null ]  endobj 644 0 obj /D [ 89 0 R /XYZ null 427 null ]  endobj 645 0 obj /D [ 89 0 R /XYZ null 401 null ]  endobj 646 0 obj /D [ 89 0 R /XYZ null null null ]  endobj 647 0 obj /D [ 89 0 R /XYZ null 408 null ]  endobj 648 0 obj /D [ 93 0 R /XYZ null 803 null ]  endobj 649 0 obj /D [ 93 0 R /XYZ null 505 null ]  endobj 650 0 obj /D [ 93 0 R /XYZ null 466 null ]  endobj 651 0 obj /D [ 93 0 R /XYZ null 427 null ]  endobj 652 0 obj /D [ 93 0 R /XYZ null 388 null ]  endobj 653 0 obj /D [ 93 0 R /XYZ null 349 null ]  endobj 654 0 obj /D [ 93 0 R /XYZ null null null ]  endobj 655 0 obj /D [ 93 0 R /XYZ null 473 null ]  endobj 656 0 obj /D [ 93 0 R /XYZ null 434 null ]  endobj 657 0 obj /D [ 93 0 R /XYZ null 395 null ]  endobj 658 0 obj /D [ 97 0 R /XYZ null 803 null ]  endobj 659 0 obj /D [ 97 0 R /XYZ null 738 null ]  endobj 660 0 obj /D [ 97 0 R /XYZ null 712 null ]  endobj 661 0 obj /D [ 97 0 R /XYZ null 643 null ]  endobj 662 0 obj /D [ 97 0 R /XYZ null 582 null ]  endobj 663 0 obj /D [ 97 0 R /XYZ null 556 null ]  endobj 664 0 obj /D [ 97 0 R /XYZ null null null ]  endobj 665 0 obj /D [ 101 0 R /XYZ null 803 null ]  endobj 666 0 obj /D [ 101 0 R /XYZ null 764 null ]  endobj 667 0 obj /D [ 101 0 R /XYZ null 738 null ]  endobj 668 0 obj /D [ 101 0 R /XYZ null 666 null ]  endobj 669 0 obj /D [ 101 0 R /XYZ null 638 null ]  endobj 670 0 obj /D [ 101 0 R /XYZ null 603 null ]  endobj 671 0 obj /D [ 101 0 R /XYZ null 596 null ]  endobj 672 0 obj /D [ 101 0 R /XYZ null 573 null ]  endobj 673 0 obj /D [ 101 0 R /XYZ null 573 null ]  endobj 674 0 obj /D [ 101 0 R /XYZ null 555 null ]  endobj 675 0 obj /D [ 101 0 R /XYZ null 537 null ]  endobj 676 0 obj /D [ 101 0 R /XYZ null 537 null ]  endobj 677 0 obj /D [ 101 0 R /XYZ null 520 null ]  endobj 678 0 obj /D [ 101 0 R /XYZ null 520 null ]  endobj 679 0 obj /D [ 101 0 R /XYZ null 503 null ]  endobj 680 0 obj /D [ 101 0 R /XYZ null 503 null ]  endobj 681 0 obj /D [ 101 0 R /XYZ null 475 null ]  endobj 682 0 obj /D [ 101 0 R /XYZ null 475 null ]  endobj 683 0 obj /D [ 101 0 R /XYZ null 458 null ]  endobj 684 0 obj /D [ 101 0 R /XYZ null 458 null ]  endobj 685 0 obj /D [ 101 0 R /XYZ null 441 null ]  endobj 686 0 obj /D [ 101 0 R /XYZ null 441 null ]  endobj 687 0 obj /D [ 101 0 R /XYZ null 424 null ]  endobj 688 0 obj /D [ 101 0 R /XYZ null 424 null ]  endobj 689 0 obj /D [ 101 0 R /XYZ null 407 null ]  endobj 690 0 obj /D [ 101 0 R /XYZ null 407 null ]  endobj 691 0 obj /D [ 101 0 R /XYZ null 389 null ]  endobj 692 0 obj /D [ 101 0 R /XYZ null 371 null ]  endobj 693 0 obj /D [ 101 0 R /XYZ null 371 null ]  endobj 694 0 obj /D [ 101 0 R /XYZ null 354 null ]  endobj 695 0 obj /D [ 101 0 R /XYZ null 354 null ]  endobj 696 0 obj /D [ 101 0 R /XYZ null 337 null ]  endobj 697 0 obj /D [ 101 0 R /XYZ null 337 null ]  endobj 698 0 obj /D [ 101 0 R /XYZ null 320 null ]  endobj 699 0 obj /D [ 101 0 R /XYZ null 320 null ]  endobj 700 0 obj /D [ 101 0 R /XYZ null 303 null ]  endobj 701 0 obj /D [ 101 0 R /XYZ null 303 null ]  endobj 702 0 obj /D [ 101 0 R /XYZ null null null ]  endobj 703 0 obj /D [ 101 0 R /XYZ null 810 null ]  endobj 704 0 obj /D [ 101 0 R /XYZ null 810 null ]  endobj 705 0 obj /D [ 101 0 R /XYZ null 543 null ]  endobj 706 0 obj /D [ 101 0 R /XYZ null 526 null ]  endobj 707 0 obj /D [ 101 0 R /XYZ null 509 null ]  endobj 708 0 obj /D [ 101 0 R /XYZ null 481 null ]  endobj 709 0 obj /D [ 101 0 R /XYZ null 464 null ]  endobj 710 0 obj /D [ 101 0 R /XYZ null 447 null ]  endobj 711 0 obj /D [ 101 0 R /XYZ null 678 null ]  endobj 712 0 obj /D [ 101 0 R /XYZ null 430 null ]  endobj 713 0 obj /D [ 101 0 R /XYZ null 413 null ]  endobj 714 0 obj /D [ 101 0 R /XYZ null 377 null ]  endobj 715 0 obj /D [ 101 0 R /XYZ null 360 null ]  endobj 716 0 obj /D [ 101 0 R /XYZ null 343 null ]  endobj 717 0 obj /D [ 101 0 R /XYZ null 678 null ]  endobj 718 0 obj /D [ 101 0 R /XYZ null 678 null ]  endobj 719 0 obj /D [ 101 0 R /XYZ null 326 null ]  endobj 720 0 obj /D [ 101 0 R /XYZ null 602 null ]  endobj 721 0 obj /D [ 101 0 R /XYZ null 602 null ]  endobj 722 0 obj /D [ 101 0 R /XYZ null 602 null ]  endobj 723 0 obj /D [ 101 0 R /XYZ null 309 null ]  endobj 724 0 obj /D [ 105 0 R /XYZ null 763 null ]  endobj 725 0 obj /D [ 105 0 R /XYZ null 745 null ]  endobj 726 0 obj /D [ 105 0 R /XYZ null 745 null ]  endobj 727 0 obj /D [ 105 0 R /XYZ null 717 null ]  endobj 728 0 obj /D [ 105 0 R /XYZ null 717 null ]  endobj 729 0 obj /D [ 105 0 R /XYZ null 689 null ]  endobj 730 0 obj /D [ 105 0 R /XYZ null 689 null ]  endobj 731 0 obj /D [ 105 0 R /XYZ null 661 null ]  endobj 732 0 obj /D [ 105 0 R /XYZ null 661 null ]  endobj 733 0 obj /D [ 105 0 R /XYZ null 633 null ]  endobj 734 0 obj /D [ 105 0 R /XYZ null 633 null ]  endobj 735 0 obj /D [ 105 0 R /XYZ null 615 null ]  endobj 736 0 obj /D [ 105 0 R /XYZ null 597 null ]  endobj 737 0 obj /D [ 105 0 R /XYZ null 597 null ]  endobj 738 0 obj /D [ 105 0 R /XYZ null 580 null ]  endobj 739 0 obj /D [ 105 0 R /XYZ null 580 null ]  endobj 740 0 obj /D [ 105 0 R /XYZ null 552 null ]  endobj 741 0 obj /D [ 105 0 R /XYZ null 552 null ]  endobj 742 0 obj /D [ 105 0 R /XYZ null 524 null ]  endobj 743 0 obj /D [ 105 0 R /XYZ null 524 null ]  endobj 744 0 obj /D [ 105 0 R /XYZ null 506 null ]  endobj 745 0 obj /D [ 105 0 R /XYZ null 488 null ]  endobj 746 0 obj /D [ 105 0 R /XYZ null 488 null ]  endobj 747 0 obj /D [ 105 0 R /XYZ null 470 null ]  endobj 748 0 obj /D [ 105 0 R /XYZ null 452 null ]  endobj 749 0 obj /D [ 105 0 R /XYZ null 452 null ]  endobj 750 0 obj /D [ 105 0 R /XYZ null 435 null ]  endobj 751 0 obj /D [ 105 0 R /XYZ null 435 null ]  endobj 752 0 obj /D [ 105 0 R /XYZ null 417 null ]  endobj 753 0 obj /D [ 105 0 R /XYZ null 399 null ]  endobj 754 0 obj /D [ 105 0 R /XYZ null 399 null ]  endobj 755 0 obj /D [ 105 0 R /XYZ null 382 null ]  endobj 756 0 obj /D [ 105 0 R /XYZ null 382 null ]  endobj 757 0 obj /D [ 105 0 R /XYZ null 365 null ]  endobj 758 0 obj /D [ 105 0 R /XYZ null 365 null ]  endobj 759 0 obj /D [ 105 0 R /XYZ null 348 null ]  endobj 760 0 obj /D [ 105 0 R /XYZ null 348 null ]  endobj 761 0 obj /D [ 105 0 R /XYZ null 331 null ]  endobj 762 0 obj /D [ 105 0 R /XYZ null 331 null ]  endobj 763 0 obj /D [ 105 0 R /XYZ null 314 null ]  endobj 764 0 obj /D [ 105 0 R /XYZ null 314 null ]  endobj 765 0 obj /D [ 105 0 R /XYZ null 296 null ]  endobj 766 0 obj /D [ 105 0 R /XYZ null null null ]  endobj 767 0 obj /D [ 105 0 R /XYZ null 751 null ]  endobj 768 0 obj /D [ 105 0 R /XYZ null 723 null ]  endobj 769 0 obj /D [ 105 0 R /XYZ null 695 null ]  endobj 770 0 obj /D [ 105 0 R /XYZ null 667 null ]  endobj 771 0 obj /D [ 105 0 R /XYZ null 639 null ]  endobj 772 0 obj /D [ 105 0 R /XYZ null 603 null ]  endobj 773 0 obj /D [ 105 0 R /XYZ null 586 null ]  endobj 774 0 obj /D [ 105 0 R /XYZ null 558 null ]  endobj 775 0 obj /D [ 105 0 R /XYZ null 530 null ]  endobj 776 0 obj /D [ 105 0 R /XYZ null 494 null ]  endobj 777 0 obj /D [ 105 0 R /XYZ null 458 null ]  endobj 778 0 obj /D [ 105 0 R /XYZ null 441 null ]  endobj 779 0 obj /D [ 105 0 R /XYZ null 405 null ]  endobj 780 0 obj /D [ 105 0 R /XYZ null 388 null ]  endobj 781 0 obj /D [ 105 0 R /XYZ null 371 null ]  endobj 782 0 obj /D [ 105 0 R /XYZ null 354 null ]  endobj 783 0 obj /D [ 105 0 R /XYZ null 337 null ]  endobj 784 0 obj /D [ 105 0 R /XYZ null 320 null ]  endobj 785 0 obj /D [ 108 0 R /XYZ null 323 null ]  endobj 786 0 obj /D [ 108 0 R /XYZ null 764 null ]  endobj 787 0 obj /D [ 108 0 R /XYZ null 764 null ]  endobj 788 0 obj /D [ 108 0 R /XYZ null 747 null ]  endobj 789 0 obj /D [ 108 0 R /XYZ null 747 null ]  endobj 790 0 obj /D [ 108 0 R /XYZ null 729 null ]  endobj 791 0 obj /D [ 108 0 R /XYZ null 711 null ]  endobj 792 0 obj /D [ 108 0 R /XYZ null 711 null ]  endobj 793 0 obj /D [ 108 0 R /XYZ null 694 null ]  endobj 794 0 obj /D [ 108 0 R /XYZ null 694 null ]  endobj 795 0 obj /D [ 108 0 R /XYZ null 677 null ]  endobj 796 0 obj /D [ 108 0 R /XYZ null 677 null ]  endobj 797 0 obj /D [ 108 0 R /XYZ null 660 null ]  endobj 798 0 obj /D [ 108 0 R /XYZ null 660 null ]  endobj 799 0 obj /D [ 108 0 R /XYZ null 643 null ]  endobj 800 0 obj /D [ 108 0 R /XYZ null 643 null ]  endobj 801 0 obj /D [ 108 0 R /XYZ null 626 null ]  endobj 802 0 obj /D [ 108 0 R /XYZ null 626 null ]  endobj 803 0 obj /D [ 108 0 R /XYZ null 609 null ]  endobj 804 0 obj /D [ 108 0 R /XYZ null 609 null ]  endobj 805 0 obj /D [ 108 0 R /XYZ null 592 null ]  endobj 806 0 obj /D [ 108 0 R /XYZ null 592 null ]  endobj 807 0 obj /D [ 108 0 R /XYZ null 575 null ]  endobj 808 0 obj /D [ 108 0 R /XYZ null 575 null ]  endobj 809 0 obj /D [ 108 0 R /XYZ null 558 null ]  endobj 810 0 obj /D [ 108 0 R /XYZ null 558 null ]  endobj 811 0 obj /D [ 108 0 R /XYZ null 541 null ]  endobj 812 0 obj /D [ 108 0 R /XYZ null 541 null ]  endobj 813 0 obj /D [ 108 0 R /XYZ null 524 null ]  endobj 814 0 obj /D [ 108 0 R /XYZ null 524 null ]  endobj 815 0 obj /D [ 108 0 R /XYZ null 507 null ]  endobj 816 0 obj /D [ 108 0 R /XYZ null 507 null ]  endobj 817 0 obj /D [ 108 0 R /XYZ null 490 null ]  endobj 818 0 obj /D [ 108 0 R /XYZ null 490 null ]  endobj 819 0 obj /D [ 108 0 R /XYZ null 473 null ]  endobj 820 0 obj /D [ 108 0 R /XYZ null 473 null ]  endobj 821 0 obj /D [ 108 0 R /XYZ null 456 null ]  endobj 822 0 obj /D [ 108 0 R /XYZ null 456 null ]  endobj 823 0 obj /D [ 108 0 R /XYZ null 439 null ]  endobj 824 0 obj /D [ 108 0 R /XYZ null 439 null ]  endobj 825 0 obj /D [ 108 0 R /XYZ null 422 null ]  endobj 826 0 obj /D [ 108 0 R /XYZ null 422 null ]  endobj 827 0 obj /D [ 108 0 R /XYZ null 405 null ]  endobj 828 0 obj /D [ 108 0 R /XYZ null 405 null ]  endobj 829 0 obj /D [ 108 0 R /XYZ null 388 null ]  endobj 830 0 obj /D [ 108 0 R /XYZ null 388 null ]  endobj 831 0 obj /D [ 108 0 R /XYZ null 371 null ]  endobj 832 0 obj /D [ 108 0 R /XYZ null 371 null ]  endobj 833 0 obj /D [ 108 0 R /XYZ null 354 null ]  endobj 834 0 obj /D [ 108 0 R /XYZ null 354 null ]  endobj 835 0 obj /D [ 108 0 R /XYZ null null null ]  endobj 836 0 obj /D [ 108 0 R /XYZ null 770 null ]  endobj 837 0 obj /D [ 108 0 R /XYZ null 753 null ]  endobj 838 0 obj /D [ 108 0 R /XYZ null 717 null ]  endobj 839 0 obj /D [ 108 0 R /XYZ null 700 null ]  endobj 840 0 obj /D [ 108 0 R /XYZ null 683 null ]  endobj 841 0 obj /D [ 108 0 R /XYZ null 666 null ]  endobj 842 0 obj /D [ 108 0 R /XYZ null 649 null ]  endobj 843 0 obj /D [ 108 0 R /XYZ null 632 null ]  endobj 844 0 obj /D [ 108 0 R /XYZ null 615 null ]  endobj 845 0 obj /D [ 108 0 R /XYZ null 598 null ]  endobj 846 0 obj /D [ 108 0 R /XYZ null 581 null ]  endobj 847 0 obj /D [ 108 0 R /XYZ null 564 null ]  endobj 848 0 obj /D [ 108 0 R /XYZ null 547 null ]  endobj 849 0 obj /D [ 108 0 R /XYZ null 530 null ]  endobj 850 0 obj /D [ 108 0 R /XYZ null 513 null ]  endobj 851 0 obj /D [ 108 0 R /XYZ null 496 null ]  endobj 852 0 obj /D [ 108 0 R /XYZ null 479 null ]  endobj 853 0 obj /D [ 108 0 R /XYZ null 462 null ]  endobj 854 0 obj /D [ 108 0 R /XYZ null 445 null ]  endobj 855 0 obj /D [ 108 0 R /XYZ null 428 null ]  endobj 856 0 obj /D [ 108 0 R /XYZ null 411 null ]  endobj 857 0 obj /D [ 108 0 R /XYZ null 394 null ]  endobj 858 0 obj /D [ 108 0 R /XYZ null 377 null ]  endobj 859 0 obj /D [ 108 0 R /XYZ null 360 null ]  endobj 860 0 obj /D [ 111 0 R /XYZ null 798 null ]  endobj 861 0 obj /D [ 111 0 R /XYZ null 774 null ]  endobj 862 0 obj /D [ 111 0 R /XYZ null 722 null ]  endobj 863 0 obj /D [ 111 0 R /XYZ null 709 null ]  endobj 864 0 obj /D [ 111 0 R /XYZ null 683 null ]  endobj 865 0 obj /D [ 111 0 R /XYZ null 644 null ]  endobj 866 0 obj /D [ 111 0 R /XYZ null 605 null ]  endobj 867 0 obj /D [ 111 0 R /XYZ null 579 null ]  endobj 868 0 obj /D [ 111 0 R /XYZ null 553 null ]  endobj 869 0 obj /D [ 111 0 R /XYZ null 527 null ]  endobj 870 0 obj /D [ 111 0 R /XYZ null 501 null ]  endobj 871 0 obj /D [ 111 0 R /XYZ null 475 null ]  endobj 872 0 obj /D [ 111 0 R /XYZ null 449 null ]  endobj 873 0 obj /D [ 111 0 R /XYZ null 410 null ]  endobj 874 0 obj /D [ 111 0 R /XYZ null 367 null ]  endobj 875 0 obj /D [ 111 0 R /XYZ null 319 null ]  endobj 876 0 obj /D [ 111 0 R /XYZ null null null ]  endobj 877 0 obj /D [ 111 0 R /XYZ null 781 null ]  endobj 878 0 obj /D [ 111 0 R /XYZ null 810 null ]  endobj 879 0 obj /D [ 111 0 R /XYZ null 810 null ]  endobj 880 0 obj /D [ 111 0 R /XYZ null 810 null ]  endobj 881 0 obj /D [ 114 0 R /XYZ null null null ]  endobj 882 0 obj /D [ 114 0 R /XYZ null null null ]  endobj 883 0 obj /D [ 117 0 R /XYZ null 266 null ]  endobj 884 0 obj /D [ 117 0 R /XYZ null 250 null ]  endobj 885 0 obj /D [ 117 0 R /XYZ null 820 null ]  endobj 886 0 obj /D [ 117 0 R /XYZ null 793 null ]  endobj 887 0 obj /D [ 117 0 R /XYZ null 768 null ]  endobj 888 0 obj /D [ 117 0 R /XYZ null 675 null ]  endobj 889 0 obj /D [ 117 0 R /XYZ null 613 null ]  endobj 890 0 obj /D [ 117 0 R /XYZ null 588 null ]  endobj 891 0 obj /D [ 117 0 R /XYZ null 550 null ]  endobj 892 0 obj /D [ 117 0 R /XYZ null 525 null ]  endobj 893 0 obj /D [ 117 0 R /XYZ null 512 null ]  endobj 894 0 obj /D [ 117 0 R /XYZ null 474 null ]  endobj 895 0 obj /D [ 117 0 R /XYZ null 449 null ]  endobj 896 0 obj /D [ 117 0 R /XYZ null 436 null ]  endobj 897 0 obj /D [ 117 0 R /XYZ null 410 null ]  endobj 898 0 obj /D [ 117 0 R /XYZ null 384 null ]  endobj 899 0 obj /D [ 117 0 R /XYZ null 371 null ]  endobj 900 0 obj /D [ 117 0 R /XYZ null 333 null ]  endobj 901 0 obj /D [ 117 0 R /XYZ null 308 null ]  endobj 902 0 obj /D [ 117 0 R /XYZ null 295 null ]  endobj 903 0 obj /D [ 117 0 R /XYZ null 641 null ]  endobj 904 0 obj /D [ 117 0 R /XYZ null 603 null ]  endobj 905 0 obj /D [ 117 0 R /XYZ null 578 null ]  endobj 906 0 obj /D [ 117 0 R /XYZ null 565 null ]  endobj 907 0 obj /D [ 117 0 R /XYZ null 552 null ]  endobj 908 0 obj /D [ 117 0 R /XYZ null 539 null ]  endobj 909 0 obj /D [ 117 0 R /XYZ null 526 null ]  endobj 910 0 obj /D [ 117 0 R /XYZ null 513 null ]  endobj 911 0 obj /D [ 117 0 R /XYZ null 500 null ]  endobj 912 0 obj /D [ 117 0 R /XYZ null 487 null ]  endobj 913 0 obj /D [ 117 0 R /XYZ null 474 null ]  endobj 914 0 obj /D [ 117 0 R /XYZ null 436 null ]  endobj 915 0 obj /D [ 117 0 R /XYZ null 411 null ]  endobj 916 0 obj /D [ 117 0 R /XYZ null 398 null ]  endobj 917 0 obj /D [ 117 0 R /XYZ null 385 null ]  endobj 918 0 obj /D [ 117 0 R /XYZ null 347 null ]  endobj 919 0 obj /D [ 117 0 R /XYZ null 322 null ]  endobj 920 0 obj /D [ 117 0 R /XYZ null 309 null ]  endobj 921 0 obj /D [ 117 0 R /XYZ null 296 null ]  endobj 922 0 obj /D [ 117 0 R /XYZ null 283 null ]  endobj 923 0 obj /D [ 117 0 R /XYZ null null null ]  endobj 924 0 obj /D [ 117 0 R /XYZ null 625 null ]  endobj 925 0 obj /D [ 117 0 R /XYZ null 625 null ]  endobj 926 0 obj /D [ 117 0 R /XYZ null 625 null ]  endobj 927 0 obj /D [ 117 0 R /XYZ null 625 null ]  endobj 928 0 obj /D [ 117 0 R /XYZ null 625 null ]  endobj 929 0 obj /D [ 117 0 R /XYZ null 625 null ]  endobj 930 0 obj /D [ 117 0 R /XYZ null 595 null ]  endobj 931 0 obj /D [ 117 0 R /XYZ null 562 null ]  endobj 932 0 obj /D [ 117 0 R /XYZ null 562 null ]  endobj 933 0 obj /D [ 117 0 R /XYZ null 562 null ]  endobj 934 0 obj /D [ 117 0 R /XYZ null 562 null ]  endobj 935 0 obj /D [ 117 0 R /XYZ null 532 null ]  endobj 936 0 obj /D [ 117 0 R /XYZ null 519 null ]  endobj 937 0 obj /D [ 117 0 R /XYZ null 486 null ]  endobj 938 0 obj /D [ 117 0 R /XYZ null 486 null ]  endobj 939 0 obj /D [ 117 0 R /XYZ null 430 null ]  endobj 940 0 obj /D [ 117 0 R /XYZ null 404 null ]  endobj 941 0 obj /D [ 117 0 R /XYZ null 391 null ]  endobj 942 0 obj /D [ 117 0 R /XYZ null 378 null ]  endobj 943 0 obj /D [ 117 0 R /XYZ null 345 null ]  endobj 944 0 obj /D [ 117 0 R /XYZ null 345 null ]  endobj 945 0 obj /D [ 117 0 R /XYZ null 315 null ]  endobj 946 0 obj /D [ 117 0 R /XYZ null 302 null ]  endobj 947 0 obj /D [ 117 0 R /XYZ null 648 null ]  endobj 948 0 obj /D [ 117 0 R /XYZ null 615 null ]  endobj 949 0 obj /D [ 117 0 R /XYZ null 615 null ]  endobj 950 0 obj /D [ 117 0 R /XYZ null 615 null ]  endobj 951 0 obj /D [ 117 0 R /XYZ null 615 null ]  endobj 952 0 obj /D [ 117 0 R /XYZ null 615 null ]  endobj 953 0 obj /D [ 117 0 R /XYZ null 615 null ]  endobj 954 0 obj /D [ 117 0 R /XYZ null 615 null ]  endobj 955 0 obj /D [ 117 0 R /XYZ null 615 null ]  endobj 956 0 obj /D [ 117 0 R /XYZ null 572 null ]  endobj 957 0 obj /D [ 117 0 R /XYZ null 559 null ]  endobj 958 0 obj /D [ 117 0 R /XYZ null 546 null ]  endobj 959 0 obj /D [ 117 0 R /XYZ null 533 null ]  endobj 960 0 obj /D [ 117 0 R /XYZ null 520 null ]  endobj 961 0 obj /D [ 117 0 R /XYZ null 507 null ]  endobj 962 0 obj /D [ 117 0 R /XYZ null 494 null ]  endobj 963 0 obj /D [ 117 0 R /XYZ null 481 null ]  endobj 964 0 obj /D [ 117 0 R /XYZ null 448 null ]  endobj 965 0 obj /D [ 117 0 R /XYZ null 448 null ]  endobj 966 0 obj /D [ 117 0 R /XYZ null 448 null ]  endobj 967 0 obj /D [ 117 0 R /XYZ null 448 null ]  endobj 968 0 obj /D [ 117 0 R /XYZ null 418 null ]  endobj 969 0 obj /D [ 117 0 R /XYZ null 405 null ]  endobj 970 0 obj /D [ 117 0 R /XYZ null 392 null ]  endobj 971 0 obj /D [ 117 0 R /XYZ null 359 null ]  endobj 972 0 obj /D [ 117 0 R /XYZ null 359 null ]  endobj 973 0 obj /D [ 117 0 R /XYZ null 359 null ]  endobj 974 0 obj /D [ 117 0 R /XYZ null 359 null ]  endobj 975 0 obj /D [ 117 0 R /XYZ null 329 null ]  endobj 976 0 obj /D [ 117 0 R /XYZ null 316 null ]  endobj 977 0 obj /D [ 117 0 R /XYZ null 303 null ]  endobj 978 0 obj /D [ 117 0 R /XYZ null 290 null ]  endobj 979 0 obj /D [ 145 0 R /XYZ null 266 null ]  endobj 980 0 obj /D [ 145 0 R /XYZ null 250 null ]  endobj 981 0 obj /D [ 145 0 R /XYZ null 803 null ]  endobj 982 0 obj /D [ 145 0 R /XYZ null 790 null ]  endobj 983 0 obj /D [ 145 0 R /XYZ null 752 null ]  endobj 984 0 obj /D [ 145 0 R /XYZ null 727 null ]  endobj 985 0 obj /D [ 145 0 R /XYZ null 714 null ]  endobj 986 0 obj /D [ 145 0 R /XYZ null 701 null ]  endobj 987 0 obj /D [ 145 0 R /XYZ null 688 null ]  endobj 988 0 obj /D [ 145 0 R /XYZ null 675 null ]  endobj 989 0 obj /D [ 145 0 R /XYZ null 662 null ]  endobj 990 0 obj /D [ 145 0 R /XYZ null 649 null ]  endobj 991 0 obj /D [ 145 0 R /XYZ null 636 null ]  endobj 992 0 obj /D [ 145 0 R /XYZ null 623 null ]  endobj 993 0 obj /D [ 145 0 R /XYZ null 610 null ]  endobj 994 0 obj /D [ 145 0 R /XYZ null 597 null ]  endobj 995 0 obj /D [ 145 0 R /XYZ null 584 null ]  endobj 996 0 obj /D [ 145 0 R /XYZ null 571 null ]  endobj 997 0 obj /D [ 145 0 R /XYZ null 558 null ]  endobj 998 0 obj /D [ 145 0 R /XYZ null 545 null ]  endobj 999 0 obj /D [ 145 0 R /XYZ null 532 null ]  endobj 1000 0 obj /D [ 145 0 R /XYZ null 494 null ]  endobj 1001 0 obj /D [ 145 0 R /XYZ null 469 null ]  endobj 1002 0 obj /D [ 145 0 R /XYZ null 456 null ]  endobj 1003 0 obj /D [ 145 0 R /XYZ null 443 null ]  endobj 1004 0 obj /D [ 145 0 R /XYZ null 430 null ]  endobj 1005 0 obj /D [ 145 0 R /XYZ null 417 null ]  endobj 1006 0 obj /D [ 145 0 R /XYZ null 404 null ]  endobj 1007 0 obj /D [ 145 0 R /XYZ null 366 null ]  endobj 1008 0 obj /D [ 145 0 R /XYZ null 341 null ]  endobj 1009 0 obj /D [ 145 0 R /XYZ null 328 null ]  endobj 1010 0 obj /D [ 145 0 R /XYZ null 798 null ]  endobj 1011 0 obj /D [ 145 0 R /XYZ null 773 null ]  endobj 1012 0 obj /D [ 145 0 R /XYZ null 760 null ]  endobj 1013 0 obj /D [ 145 0 R /XYZ null 747 null ]  endobj 1014 0 obj /D [ 145 0 R /XYZ null 734 null ]  endobj 1015 0 obj /D [ 145 0 R /XYZ null 721 null ]  endobj 1016 0 obj /D [ 145 0 R /XYZ null 708 null ]  endobj 1017 0 obj /D [ 145 0 R /XYZ null 695 null ]  endobj 1018 0 obj /D [ 145 0 R /XYZ null 682 null ]  endobj 1019 0 obj /D [ 145 0 R /XYZ null 669 null ]  endobj 1020 0 obj /D [ 145 0 R /XYZ null 631 null ]  endobj 1021 0 obj /D [ 145 0 R /XYZ null 606 null ]  endobj 1022 0 obj /D [ 145 0 R /XYZ null 593 null ]  endobj 1023 0 obj /D [ 145 0 R /XYZ null 580 null ]  endobj 1024 0 obj /D [ 145 0 R /XYZ null 567 null ]  endobj 1025 0 obj /D [ 145 0 R /XYZ null 554 null ]  endobj 1026 0 obj /D [ 145 0 R /XYZ null 541 null ]  endobj 1027 0 obj /D [ 145 0 R /XYZ null 528 null ]  endobj 1028 0 obj /D [ 145 0 R /XYZ null 515 null ]  endobj 1029 0 obj /D [ 145 0 R /XYZ null 502 null ]  endobj 1030 0 obj /D [ 145 0 R /XYZ null 489 null ]  endobj 1031 0 obj /D [ 145 0 R /XYZ null 476 null ]  endobj 1032 0 obj /D [ 145 0 R /XYZ null 463 null ]  endobj 1033 0 obj /D [ 145 0 R /XYZ null 450 null ]  endobj 1034 0 obj /D [ 145 0 R /XYZ null 437 null ]  endobj 1035 0 obj /D [ 145 0 R /XYZ null 424 null ]  endobj 1036 0 obj /D [ 145 0 R /XYZ null 411 null ]  endobj 1037 0 obj /D [ 145 0 R /XYZ null 398 null ]  endobj 1038 0 obj /D [ 145 0 R /XYZ null 385 null ]  endobj 1039 0 obj /D [ 145 0 R /XYZ null 372 null ]  endobj 1040 0 obj /D [ 145 0 R /XYZ null 359 null ]  endobj 1041 0 obj /D [ 145 0 R /XYZ null 346 null ]  endobj 1042 0 obj /D [ 145 0 R /XYZ null 333 null ]  endobj 1043 0 obj /D [ 145 0 R /XYZ null 320 null ]  endobj 1044 0 obj /D [ 145 0 R /XYZ null 307 null ]  endobj 1045 0 obj /D [ 145 0 R /XYZ null 294 null ]  endobj 1046 0 obj /D [ 145 0 R /XYZ null 810 null ]  endobj 1047 0 obj /D [ 145 0 R /XYZ null 797 null ]  endobj 1048 0 obj /D [ 145 0 R /XYZ null 764 null ]  endobj 1049 0 obj /D [ 145 0 R /XYZ null 764 null ]  endobj 1050 0 obj /D [ 145 0 R /XYZ null 764 null ]  endobj 1051 0 obj /D [ 145 0 R /XYZ null 764 null ]  endobj 1052 0 obj /D [ 145 0 R /XYZ null 764 null ]  endobj 1053 0 obj /D [ 145 0 R /XYZ null 764 null ]  endobj 1054 0 obj /D [ 145 0 R /XYZ null 734 null ]  endobj 1055 0 obj /D [ 145 0 R /XYZ null 721 null ]  endobj 1056 0 obj /D [ 145 0 R /XYZ null 708 null ]  endobj 1057 0 obj /D [ 145 0 R /XYZ null 695 null ]  endobj 1058 0 obj /D [ 145 0 R /XYZ null 682 null ]  endobj 1059 0 obj /D [ 145 0 R /XYZ null 669 null ]  endobj 1060 0 obj /D [ 145 0 R /XYZ null 656 null ]  endobj 1061 0 obj /D [ 145 0 R /XYZ null 643 null ]  endobj 1062 0 obj /D [ 145 0 R /XYZ null 617 null ]  endobj 1063 0 obj /D [ 145 0 R /XYZ null 604 null ]  endobj 1064 0 obj /D [ 145 0 R /XYZ null 591 null ]  endobj 1065 0 obj /D [ 145 0 R /XYZ null 578 null ]  endobj 1066 0 obj /D [ 145 0 R /XYZ null 565 null ]  endobj 1067 0 obj /D [ 145 0 R /XYZ null 552 null ]  endobj 1068 0 obj /D [ 145 0 R /XYZ null 539 null ]  endobj 1069 0 obj /D [ 145 0 R /XYZ null 506 null ]  endobj 1070 0 obj /D [ 145 0 R /XYZ null 506 null ]  endobj 1071 0 obj /D [ 145 0 R /XYZ null 506 null ]  endobj 1072 0 obj /D [ 145 0 R /XYZ null 506 null ]  endobj 1073 0 obj /D [ 145 0 R /XYZ null 476 null ]  endobj 1074 0 obj /D [ 145 0 R /XYZ null 463 null ]  endobj 1075 0 obj /D [ 145 0 R /XYZ null 450 null ]  endobj 1076 0 obj /D [ 145 0 R /XYZ null 424 null ]  endobj 1077 0 obj /D [ 145 0 R /XYZ null 411 null ]  endobj 1078 0 obj /D [ 145 0 R /XYZ null 378 null ]  endobj 1079 0 obj /D [ 145 0 R /XYZ null 378 null ]  endobj 1080 0 obj /D [ 145 0 R /XYZ null 348 null ]  endobj 1081 0 obj /D [ 145 0 R /XYZ null 335 null ]  endobj 1082 0 obj /D [ 145 0 R /XYZ null 810 null ]  endobj 1083 0 obj /D [ 145 0 R /XYZ null 810 null ]  endobj 1084 0 obj /D [ 145 0 R /XYZ null 810 null ]  endobj 1085 0 obj /D [ 145 0 R /XYZ null 810 null ]  endobj 1086 0 obj /D [ 145 0 R /XYZ null 767 null ]  endobj 1087 0 obj /D [ 145 0 R /XYZ null 754 null ]  endobj 1088 0 obj /D [ 145 0 R /XYZ null 741 null ]  endobj 1089 0 obj /D [ 145 0 R /XYZ null 728 null ]  endobj 1090 0 obj /D [ 145 0 R /XYZ null 715 null ]  endobj 1091 0 obj /D [ 145 0 R /XYZ null 702 null ]  endobj 1092 0 obj /D [ 145 0 R /XYZ null 689 null ]  endobj 1093 0 obj /D [ 145 0 R /XYZ null 676 null ]  endobj 1094 0 obj /D [ 145 0 R /XYZ null 643 null ]  endobj 1095 0 obj /D [ 145 0 R /XYZ null 643 null ]  endobj 1096 0 obj /D [ 145 0 R /XYZ null 643 null ]  endobj 1097 0 obj /D [ 145 0 R /XYZ null 643 null ]  endobj 1098 0 obj /D [ 145 0 R /XYZ null 613 null ]  endobj 1099 0 obj /D [ 145 0 R /XYZ null 600 null ]  endobj 1100 0 obj /D [ 145 0 R /XYZ null 587 null ]  endobj 1101 0 obj /D [ 145 0 R /XYZ null 574 null ]  endobj 1102 0 obj /D [ 145 0 R /XYZ null 561 null ]  endobj 1103 0 obj /D [ 145 0 R /XYZ null 548 null ]  endobj 1104 0 obj /D [ 145 0 R /XYZ null 535 null ]  endobj 1105 0 obj /D [ 145 0 R /XYZ null 522 null ]  endobj 1106 0 obj /D [ 145 0 R /XYZ null 509 null ]  endobj 1107 0 obj /D [ 145 0 R /XYZ null 496 null ]  endobj 1108 0 obj /D [ 145 0 R /XYZ null 483 null ]  endobj 1109 0 obj /D [ 145 0 R /XYZ null 470 null ]  endobj 1110 0 obj /D [ 145 0 R /XYZ null 457 null ]  endobj 1111 0 obj /D [ 145 0 R /XYZ null 444 null ]  endobj 1112 0 obj /D [ 145 0 R /XYZ null 431 null ]  endobj 1113 0 obj /D [ 145 0 R /XYZ null 418 null ]  endobj 1114 0 obj /D [ 145 0 R /XYZ null 405 null ]  endobj 1115 0 obj /D [ 145 0 R /XYZ null 392 null ]  endobj 1116 0 obj /D [ 145 0 R /XYZ null 379 null ]  endobj 1117 0 obj /D [ 145 0 R /XYZ null 366 null ]  endobj 1118 0 obj /D [ 145 0 R /XYZ null 353 null ]  endobj 1119 0 obj /D [ 145 0 R /XYZ null 340 null ]  endobj 1120 0 obj /D [ 145 0 R /XYZ null 327 null ]  endobj 1121 0 obj /D [ 145 0 R /XYZ null 314 null ]  endobj 1122 0 obj /D [ 145 0 R /XYZ null 301 null ]  endobj 1123 0 obj /D [ 206 0 R /XYZ null 266 null ]  endobj 1124 0 obj /D [ 206 0 R /XYZ null 250 null ]  endobj 1125 0 obj /D [ 206 0 R /XYZ null 803 null ]  endobj 1126 0 obj /D [ 206 0 R /XYZ null 790 null ]  endobj 1127 0 obj /D [ 206 0 R /XYZ null 777 null ]  endobj 1128 0 obj /D [ 206 0 R /XYZ null 764 null ]  endobj 1129 0 obj /D [ 206 0 R /XYZ null 751 null ]  endobj 1130 0 obj /D [ 206 0 R /XYZ null 738 null ]  endobj 1131 0 obj /D [ 206 0 R /XYZ null 725 null ]  endobj 1132 0 obj /D [ 206 0 R /XYZ null 712 null ]  endobj 1133 0 obj /D [ 206 0 R /XYZ null 810 null ]  endobj 1134 0 obj /D [ 206 0 R /XYZ null 797 null ]  endobj 1135 0 obj /D [ 206 0 R /XYZ null 784 null ]  endobj 1136 0 obj /D [ 206 0 R /XYZ null 771 null ]  endobj 1137 0 obj /D [ 206 0 R /XYZ null 758 null ]  endobj 1138 0 obj /D [ 206 0 R /XYZ null 745 null ]  endobj 1139 0 obj /D [ 206 0 R /XYZ null 732 null ]  endobj 1140 0 obj /D [ 206 0 R /XYZ null 719 null ]  endobj 1141 0 obj /D [ 218 0 R /XYZ null null null ]  endobj 1142 0 obj /Limits [ (F1)(G3.1741)]  /Names [ (F1)331 0 R (F2)339 0 R (F3)399 0 R (F4)425 0 R (F5)509 0 R (F6)600 0 R  (F7)923 0 R (G1.997409)328 0 R (G1.997434)329 0 R (G2.154)377 0 R  (G2.3664)336 0 R (G2.3665)337 0 R (G2.3716)364 0 R (G2.3732)370 0 R  (G2.3733)371 0 R (G2.3734)372 0 R (G2.3735)373 0 R (G2.3736)374 0 R  (G2.3737)375 0 R (G2.3738)376 0 R (G2.4084)338 0 R (G2.4328)365 0 R  (G2.4333)366 0 R (G2.4402)334 0 R (G2.4406)335 0 R (G2.4411)333 0 R  (G2.4842)367 0 R (G2.4850)368 0 R (G2.4851)369 0 R (G2.5130)340 0 R  (G2.5131)341 0 R (G2.5132)342 0 R (G2.5133)343 0 R (G2.5134)344 0 R  (G2.5135)345 0 R (G2.5136)346 0 R (G2.5142)349 0 R (G2.5143)350 0 R  (G2.5144)351 0 R (G2.5145)352 0 R (G2.5146)353 0 R (G2.5147)354 0 R  (G2.5148)355 0 R (G2.5149)356 0 R (G2.5150)357 0 R (G2.5151)358 0 R  (G2.5152)359 0 R (G2.5153)360 0 R (G2.5154)361 0 R (G2.5155)362 0 R  (G2.5156)363 0 R (G2.5157)347 0 R (G2.5158)348 0 R (G3.1721)385 0 R  (G3.1723)386 0 R (G3.1725)387 0 R (G3.1727)388 0 R (G3.1729)389 0 R  (G3.1731)390 0 R (G3.1733)391 0 R (G3.1735)392 0 R (G3.1737)393 0 R  (G3.1739)394 0 R (G3.1741)395 0 R ]  endobj 1143 0 obj /Limits [ (G3.1743)(G4.8080)]  /Names [ (G3.1743)396 0 R (G3.1745)397 0 R (G3.283)383 0 R (G3.437)384 0 R  (G3.729)413 0 R (G3.739)414 0 R (G3.768)380 0 R (G3.774)381 0 R  (G3.782)382 0 R (G4.10161)454 0 R (G4.10171)455 0 R (G4.10290)433 0 R  (G4.10291)434 0 R (G4.10333)467 0 R (G4.10353)452 0 R (G4.10354) 453 0 R (G4.10361)438 0 R (G4.10362)439 0 R (G4.10413)480 0 R (G4.10434) 481 0 R (G4.10553)456 0 R (G4.10554)457 0 R (G4.10555)458 0 R (G4.10556) 459 0 R (G4.10557)460 0 R (G4.10558)461 0 R (G4.10559)462 0 R (G4.10560) 463 0 R (G4.10561)464 0 R (G4.10562)466 0 R (G4.10591)426 0 R (G4.10598) 427 0 R (G4.10605)450 0 R (G4.10612)451 0 R (G4.10624)417 0 R (G4.10631) 418 0 R (G4.10632)419 0 R (G4.10737)423 0 R (G4.10795)491 0 R (G4.5383) 420 0 R (G4.7151)431 0 R (G4.7262)469 0 R (G4.7263)470 0 R (G4.7264) 471 0 R (G4.7265)472 0 R (G4.7266)473 0 R (G4.7292)475 0 R (G4.7294) 478 0 R (G4.7295)479 0 R (G4.7296)482 0 R (G4.7297)483 0 R (G4.7980) 428 0 R (G4.7981)429 0 R (G4.7984)440 0 R (G4.7986)441 0 R (G4.7988) 442 0 R (G4.7990)443 0 R (G4.7995)444 0 R (G4.7997)445 0 R (G4.7999) 446 0 R (G4.8004)447 0 R (G4.8006)448 0 R (G4.8034)430 0 R (G4.8080) 488 0 R ]  endobj 1144 0 obj /Limits [ (G4.8082)(G5.7444)]  /Names [ (G4.8082)490 0 R (G4.8095)484 0 R (G4.8096)489 0 R (G4.8106)485 0 R  (G4.8129)476 0 R (G4.8554)436 0 R (G4.8582)432 0 R (G4.8585)435 0 R  (G4.8620)421 0 R (G4.8621)422 0 R (G4.9398)477 0 R (G4.9402)487 0 R  (G4.9509)468 0 R (G4.9602)437 0 R (G5.2849)497 0 R (G5.2951)498 0 R  (G5.6087)499 0 R (G5.6604)501 0 R (G5.6608)502 0 R (G5.6612)505 0 R  (G5.7118)503 0 R (G5.7123)504 0 R (G5.7128)506 0 R (G5.7129)500 0 R  (G5.7195)514 0 R (G5.7200)515 0 R (G5.7203)516 0 R (G5.7204)517 0 R  (G5.7208)518 0 R (G5.7212)519 0 R (G5.7219)520 0 R (G5.7223)521 0 R  (G5.7225)522 0 R (G5.7227)523 0 R (G5.7229)524 0 R (G5.7230)525 0 R  (G5.7232)526 0 R (G5.7234)527 0 R (G5.7236)528 0 R (G5.7238)529 0 R  (G5.7243)546 0 R (G5.7247)547 0 R (G5.7253)548 0 R (G5.7257)549 0 R  (G5.7295)550 0 R (G5.7324)507 0 R (G5.7383)551 0 R (G5.7385)552 0 R  (G5.7387)553 0 R (G5.7389)554 0 R (G5.7391)555 0 R (G5.7399)556 0 R  (G5.7401)557 0 R (G5.7403)558 0 R (G5.7408)559 0 R (G5.7413)560 0 R  (G5.7415)561 0 R (G5.7417)562 0 R (G5.7419)563 0 R (G5.7421)564 0 R  (G5.7424)565 0 R (G5.7426)566 0 R (G5.7428)567 0 R (G5.7444)568 0 R  endobj 1145 0 obj /Limits [ (G5.7814)(G6.30356)]  /Names [ (G5.7814)512 0 R (G5.7824)513 0 R (G5.7831)544 0 R (G5.7837)545 0 R  (G5.7853)494 0 R (G5.7859)495 0 R (G5.7867)496 0 R (G5.7979)530 0 R  (G6.19804)591 0 R (G6.25958)592 0 R (G6.28379)605 0 R (G6.28399) 607 0 R (G6.28405)608 0 R (G6.28418)626 0 R (G6.28419)627 0 R (G6.28439) 631 0 R (G6.28444)667 0 R (G6.28449)668 0 R (G6.28451)669 0 R (G6.28456) 671 0 R (G6.28460)672 0 R (G6.28462)673 0 R (G6.28465)674 0 R (G6.28470) 675 0 R (G6.28472)676 0 R (G6.28475)677 0 R (G6.28477)678 0 R (G6.28480) 679 0 R (G6.28482)680 0 R (G6.28485)681 0 R (G6.28487)682 0 R (G6.28490) 683 0 R (G6.28492)684 0 R (G6.28493)670 0 R (G6.28500)866 0 R (G6.28504) 867 0 R (G6.28505)872 0 R (G6.28867)599 0 R (G6.29063)595 0 R (G6.29064) 596 0 R (G6.29065)597 0 R (G6.29066)598 0 R (G6.29137)606 0 R (G6.29488) 665 0 R (G6.29513)632 0 R (G6.29559)643 0 R (G6.29560)644 0 R (G6.29561) 645 0 R (G6.29584)642 0 R (G6.29610)648 0 R (G6.29621)649 0 R (G6.29688) 650 0 R (G6.29689)651 0 R (G6.29700)652 0 R (G6.29824)593 0 R (G6.29832) 594 0 R (G6.30103)609 0 R (G6.30261)615 0 R (G6.30273)625 0 R (G6.30274) 617 0 R (G6.30303)634 0 R (G6.30304)635 0 R (G6.30342)638 0 R (G6.30356) 636 0 R ]  endobj 1146 0 obj /Limits [ (G6.30357)(G6.31247)]  /Names [ (G6.30357)637 0 R (G6.30379)639 0 R (G6.30407)860 0 R (G6.30475)785 0 R  (G6.30513)692 0 R (G6.30515)693 0 R (G6.30630)689 0 R (G6.30632) 690 0 R (G6.30634)687 0 R (G6.30636)688 0 R (G6.30638)685 0 R (G6.30640) 686 0 R (G6.30697)691 0 R (G6.30730)700 0 R (G6.30732)701 0 R (G6.30734) 698 0 R (G6.30736)699 0 R (G6.30738)696 0 R (G6.30740)697 0 R (G6.30742) 694 0 R (G6.30744)695 0 R (G6.30746)733 0 R (G6.30748)734 0 R (G6.30750) 731 0 R (G6.30752)732 0 R (G6.30754)729 0 R (G6.30756)730 0 R (G6.30758) 727 0 R (G6.30760)728 0 R (G6.30762)725 0 R (G6.30766)724 0 R (G6.30856) 726 0 R (G6.30903)742 0 R (G6.30905)743 0 R (G6.30907)740 0 R (G6.30909) 741 0 R (G6.30911)738 0 R (G6.30913)739 0 R (G6.30915)736 0 R (G6.30917) 737 0 R (G6.30919)735 0 R (G6.30966)750 0 R (G6.30982)744 0 R (G6.31050) 745 0 R (G6.31052)746 0 R (G6.31058)747 0 R (G6.31062)748 0 R (G6.31064) 749 0 R (G6.31109)759 0 R (G6.31111)760 0 R (G6.31113)757 0 R (G6.31115) 758 0 R (G6.31117)755 0 R (G6.31119)756 0 R (G6.31121)753 0 R (G6.31123) 754 0 R (G6.31125)752 0 R (G6.31215)763 0 R (G6.31217)764 0 R (G6.31219) 761 0 R (G6.31221)762 0 R (G6.31243)788 0 R (G6.31245)789 0 R (G6.31247) 786 0 R ]  endobj 1147 0 obj /Limits [ (G6.31249)(G6.32839)]  /Names [ (G6.31249)787 0 R (G6.31251)765 0 R (G6.31302)793 0 R (G6.31304)794 0 R  (G6.31306)791 0 R (G6.31308)792 0 R (G6.31310)790 0 R (G6.31355) 833 0 R (G6.31357)834 0 R (G6.31359)831 0 R (G6.31361)832 0 R (G6.31363) 829 0 R (G6.31365)830 0 R (G6.31367)827 0 R (G6.31369)828 0 R (G6.31371) 825 0 R (G6.31373)826 0 R (G6.31375)823 0 R (G6.31377)824 0 R (G6.31379) 821 0 R (G6.31381)822 0 R (G6.31383)819 0 R (G6.31385)820 0 R (G6.31387) 817 0 R (G6.31389)818 0 R (G6.31391)815 0 R (G6.31393)816 0 R (G6.31395) 813 0 R (G6.31397)814 0 R (G6.31399)811 0 R (G6.31401)812 0 R (G6.31403) 809 0 R (G6.31405)810 0 R (G6.31407)807 0 R (G6.31409)808 0 R (G6.31411) 805 0 R (G6.31413)806 0 R (G6.31415)803 0 R (G6.31417)804 0 R (G6.31419) 801 0 R (G6.31421)802 0 R (G6.31423)799 0 R (G6.31425)800 0 R (G6.31427) 797 0 R (G6.31429)798 0 R (G6.31431)795 0 R (G6.31433)796 0 R (G6.31568) 751 0 R (G6.31831)869 0 R (G6.31832)868 0 R (G6.31865)871 0 R (G6.31872) 870 0 R (G6.31921)865 0 R (G6.32246)616 0 R (G6.32312)630 0 R (G6.32452) 661 0 R (G6.32491)662 0 R (G6.32567)653 0 R (G6.32570)658 0 R (G6.32748) 875 0 R (G6.32776)873 0 R (G6.32777)874 0 R (G6.32838)659 0 R (G6.32839) 660 0 R ]  endobj 1148 0 obj /Limits [ (G6.32867)(G7.26228)]  /Names [ (G6.32867)663 0 R (G6.32868)666 0 R (G6.32904)628 0 R (G6.32913)629 0 R  (G6.32967)861 0 R (G6.32986)864 0 R (G6.32999)862 0 R (G6.33005) 863 0 R (G6.33913)603 0 R (G6.33923)604 0 R (G6.33930)623 0 R (G6.33936) 624 0 R (G6.33952)588 0 R (G6.33958)589 0 R (G6.33966)590 0 R (G6.34176) 610 0 R (G6.34216)612 0 R (G6.34339)613 0 R (G6.34343)614 0 R (G6.34361) 611 0 R (G7.2439)886 0 R (G7.26136)889 0 R (G7.26140)890 0 R (G7.26142) 891 0 R (G7.26145)892 0 R (G7.26147)893 0 R (G7.26149)894 0 R (G7.26151) 895 0 R (G7.26152)896 0 R (G7.26154)897 0 R (G7.26156)898 0 R (G7.26158) 899 0 R (G7.26160)900 0 R (G7.26162)901 0 R (G7.26164)902 0 R (G7.26166) 903 0 R (G7.26168)904 0 R (G7.26173)905 0 R (G7.26174)906 0 R (G7.26176) 907 0 R (G7.26178)908 0 R (G7.26180)909 0 R (G7.26182)910 0 R (G7.26184) 911 0 R (G7.26186)912 0 R (G7.26188)913 0 R (G7.26190)914 0 R (G7.26193) 915 0 R (G7.26195)916 0 R (G7.26197)917 0 R (G7.26199)918 0 R (G7.26202) 919 0 R (G7.26204)920 0 R (G7.26206)921 0 R (G7.26208)922 0 R (G7.26210) 981 0 R (G7.26212)982 0 R (G7.26214)983 0 R (G7.26218)984 0 R (G7.26220) 985 0 R (G7.26222)986 0 R (G7.26224)987 0 R (G7.26226)988 0 R (G7.26228) 989 0 R ]  endobj 1149 0 obj /Limits [ (G7.26230)(G7.26356)]  /Names [ (G7.26230)990 0 R (G7.26232)991 0 R (G7.26234)992 0 R (G7.26235)993 0 R  (G7.26237)994 0 R (G7.26239)995 0 R (G7.26241)996 0 R (G7.26243) 997 0 R (G7.26245)998 0 R (G7.26247)999 0 R (G7.26249)1000 0 R (G7.26252) 1001 0 R (G7.26254)1002 0 R (G7.26256)1003 0 R (G7.26258)1004 0 R  (G7.26259)1005 0 R (G7.26261)1006 0 R (G7.26263)1007 0 R (G7.26265) 1008 0 R (G7.26267)1009 0 R (G7.26269)1010 0 R (G7.26272)1011 0 R  (G7.26273)1012 0 R (G7.26275)1013 0 R (G7.26277)1014 0 R (G7.26279) 1015 0 R (G7.26281)1016 0 R (G7.26283)1017 0 R (G7.26285)1018 0 R  (G7.26287)1019 0 R (G7.26289)1020 0 R (G7.26292)1021 0 R (G7.26294) 1022 0 R (G7.26296)1023 0 R (G7.26298)1024 0 R (G7.26300)1025 0 R  (G7.26302)1026 0 R (G7.26304)1027 0 R (G7.26306)1028 0 R (G7.26308) 1029 0 R (G7.26310)1030 0 R (G7.26312)1031 0 R (G7.26314)1032 0 R  (G7.26316)1033 0 R (G7.26318)1034 0 R (G7.26320)1035 0 R (G7.26322) 1036 0 R (G7.26324)1037 0 R (G7.26326)1038 0 R (G7.26328)1039 0 R  (G7.26330)1040 0 R (G7.26332)1041 0 R (G7.26334)1042 0 R (G7.26336) 1043 0 R (G7.26338)1044 0 R (G7.26340)1045 0 R (G7.26342)1125 0 R  (G7.26344)1126 0 R (G7.26346)1127 0 R (G7.26348)1128 0 R (G7.26350) 1129 0 R (G7.26352)1130 0 R (G7.26354)1131 0 R (G7.26356)1132 0 R  endobj 1150 0 obj /Limits [ (G7.7607)(I6.1.32181)]  /Names [ (G7.7607)887 0 R (G7.7608)888 0 R (G7.8309)979 0 R (G7.8319)980 0 R  (G7.8326)1123 0 R (G7.8332)1124 0 R (G7.8348)883 0 R (G7.8354)884 0 R  (G7.8362)885 0 R (I3.1.1720)400 0 R (I3.1.1722)401 0 R (I3.1.1724) 402 0 R (I3.1.1726)403 0 R (I3.1.1728)404 0 R (I3.1.1730)405 0 R  (I3.1.1732)406 0 R (I3.1.1734)407 0 R (I3.1.1736)408 0 R (I3.1.1738) 409 0 R (I3.1.1740)410 0 R (I3.1.1742)411 0 R (I3.1.1744)412 0 R  (I5.1.6843)511 0 R (I5.1.7199)542 0 R (I5.1.7202)543 0 R (I5.1.7242) 585 0 R (I5.1.7252)584 0 R (I5.1.7336)533 0 R (I5.1.7338)535 0 R  (I5.1.7339)537 0 R (I5.1.7341)571 0 R (I5.1.7345)573 0 R (I5.1.7481) 538 0 R (I5.1.7499)539 0 R (I5.1.7505)574 0 R (I5.1.7506)575 0 R  (I5.1.7507)576 0 R (I5.1.7508)577 0 R (I5.1.7509)578 0 R (I5.1.7510) 579 0 R (I5.1.7511)580 0 R (I5.1.7512)581 0 R (I5.1.7946)583 0 R  (I5.1.7985)541 0 R (I6.1.28378)620 0 R (I6.1.28448)718 0 R (I6.1.28454) 720 0 R (I6.1.28455)722 0 R (I6.1.29329)711 0 R (I6.1.29335)878 0 R  (I6.1.30337)704 0 R (I6.1.32164)618 0 R (I6.1.32166)633 0 R (I6.1.32167) 640 0 R (I6.1.32168)641 0 R (I6.1.32169)647 0 R (I6.1.32172)655 0 R  (I6.1.32173)656 0 R (I6.1.32174)657 0 R (I6.1.32177)705 0 R (I6.1.32178) 706 0 R (I6.1.32179)707 0 R (I6.1.32180)708 0 R (I6.1.32181)709 0 R  endobj 1151 0 obj /Limits [ (I6.1.32182)(I7.1.26153)]  /Names [ (I6.1.32182)710 0 R (I6.1.32183)712 0 R (I6.1.32184)713 0 R (I6.1.32185) 714 0 R (I6.1.32186)715 0 R (I6.1.32187)716 0 R (I6.1.32188)719 0 R  (I6.1.32189)723 0 R (I6.1.32190)767 0 R (I6.1.32191)768 0 R (I6.1.32192) 769 0 R (I6.1.32193)770 0 R (I6.1.32194)771 0 R (I6.1.32195)772 0 R  (I6.1.32196)773 0 R (I6.1.32197)774 0 R (I6.1.32198)775 0 R (I6.1.32199) 776 0 R (I6.1.32200)777 0 R (I6.1.32201)778 0 R (I6.1.32202)779 0 R  (I6.1.32203)780 0 R (I6.1.32204)781 0 R (I6.1.32205)782 0 R (I6.1.32206) 783 0 R (I6.1.32207)784 0 R (I6.1.32208)836 0 R (I6.1.32209)837 0 R  (I6.1.32210)838 0 R (I6.1.32211)839 0 R (I6.1.32212)840 0 R (I6.1.32213) 841 0 R (I6.1.32214)842 0 R (I6.1.32215)843 0 R (I6.1.32216)844 0 R  (I6.1.32217)845 0 R (I6.1.32218)846 0 R (I6.1.32219)847 0 R (I6.1.32220) 848 0 R (I6.1.32221)849 0 R (I6.1.32222)850 0 R (I6.1.32223)851 0 R  (I6.1.32224)852 0 R (I6.1.32225)853 0 R (I6.1.32226)854 0 R (I6.1.32227) 855 0 R (I6.1.32228)856 0 R (I6.1.32229)857 0 R (I6.1.32230)858 0 R  (I6.1.32231)859 0 R (I6.1.32237)622 0 R (I6.1.32239)880 0 R (I6.1.32254) 602 0 R (I6.1.33246)877 0 R (I7.1.26137)925 0 R (I7.1.26138)927 0 R  (I7.1.26139)929 0 R (I7.1.26141)930 0 R (I7.1.26143)932 0 R (I7.1.26144) 934 0 R (I7.1.26146)935 0 R (I7.1.26148)936 0 R (I7.1.26150)938 0 R  (I7.1.26153)939 0 R ]  endobj 1152 0 obj /Limits [ (I7.1.26155)(I7.1.26276)]  /Names [ (I7.1.26155)940 0 R (I7.1.26157)941 0 R (I7.1.26159)942 0 R (I7.1.26161) 944 0 R (I7.1.26163)945 0 R (I7.1.26165)946 0 R (I7.1.26167)947 0 R  (I7.1.26169)949 0 R (I7.1.26170)951 0 R (I7.1.26171)953 0 R (I7.1.26172) 955 0 R (I7.1.26175)956 0 R (I7.1.26177)957 0 R (I7.1.26179)958 0 R  (I7.1.26181)959 0 R (I7.1.26183)960 0 R (I7.1.26185)961 0 R (I7.1.26187) 962 0 R (I7.1.26189)963 0 R (I7.1.26191)965 0 R (I7.1.26192)967 0 R  (I7.1.26194)968 0 R (I7.1.26196)969 0 R (I7.1.26198)970 0 R (I7.1.26200) 972 0 R (I7.1.26201)974 0 R (I7.1.26203)975 0 R (I7.1.26205)976 0 R  (I7.1.26207)977 0 R (I7.1.26209)978 0 R (I7.1.26211)1046 0 R (I7.1.26213) 1047 0 R (I7.1.26215)1049 0 R (I7.1.26216)1051 0 R (I7.1.26217)1053 0 R  (I7.1.26219)1054 0 R (I7.1.26221)1055 0 R (I7.1.26223)1056 0 R (I7.1.26225) 1057 0 R (I7.1.26227)1058 0 R (I7.1.26229)1059 0 R (I7.1.26231)1060 0 R  (I7.1.26233)1061 0 R (I7.1.26236)1062 0 R (I7.1.26238)1063 0 R (I7.1.26240) 1064 0 R (I7.1.26242)1065 0 R (I7.1.26244)1066 0 R (I7.1.26246)1067 0 R  (I7.1.26248)1068 0 R (I7.1.26250)1070 0 R (I7.1.26251)1072 0 R (I7.1.26253) 1073 0 R (I7.1.26255)1074 0 R (I7.1.26257)1075 0 R (I7.1.26260)1076 0 R  (I7.1.26262)1077 0 R (I7.1.26264)1079 0 R (I7.1.26266)1080 0 R (I7.1.26268) 1081 0 R (I7.1.26270)1083 0 R (I7.1.26271)1085 0 R (I7.1.26274)1086 0 R  (I7.1.26276)1087 0 R ]  endobj 1153 0 obj /Limits [ (I7.1.26278)(M7.8.newlink.A)]  /Names [ (I7.1.26278)1088 0 R (I7.1.26280)1089 0 R (I7.1.26282)1090 0 R (I7.1.26284) 1091 0 R (I7.1.26286)1092 0 R (I7.1.26288)1093 0 R (I7.1.26290)1095 0 R  (I7.1.26291)1097 0 R (I7.1.26293)1098 0 R (I7.1.26295)1099 0 R (I7.1.26297) 1100 0 R (I7.1.26299)1101 0 R (I7.1.26301)1102 0 R (I7.1.26303)1103 0 R  (I7.1.26305)1104 0 R (I7.1.26307)1105 0 R (I7.1.26309)1106 0 R (I7.1.26311) 1107 0 R (I7.1.26313)1108 0 R (I7.1.26315)1109 0 R (I7.1.26317)1110 0 R  (I7.1.26319)1111 0 R (I7.1.26321)1112 0 R (I7.1.26323)1113 0 R (I7.1.26325) 1114 0 R (I7.1.26327)1115 0 R (I7.1.26329)1116 0 R (I7.1.26331)1117 0 R  (I7.1.26333)1118 0 R (I7.1.26335)1119 0 R (I7.1.26337)1120 0 R (I7.1.26339) 1121 0 R (I7.1.26341)1122 0 R (I7.1.26343)1133 0 R (I7.1.26345)1134 0 R  (I7.1.26347)1135 0 R (I7.1.26349)1136 0 R (I7.1.26351)1137 0 R (I7.1.26353) 1138 0 R (I7.1.26355)1139 0 R (I7.1.26357)1140 0 R (L1)332 0 R (L2) 379 0 R (L3)416 0 R (L4)493 0 R (L5)587 0 R (L6)882 0 R (L7)1141 0 R  (M5.9.10319.TableTitle.Table.12.Installation.Components)582 0 R  (M5.9.15272.3Head.System.Requirements)536 0 R (M5.9.15361.TableTitle.Table.21.System.Requirements) 540 0 R (M5.9.17383.3Head.PATROL.Component.Requirement)570 0 R (M5.9.22091.2Head.Installation.Overview) 532 0 R (M5.9.30235.2Head.Installation.Components)572 0 R (M5.9.35135.ChapterTitle.1.Preinstallation.Requirements) 510 0 R (M5.9.41466.2Head.Installation.Requirements)534 0 R (M6.9.10200.2Head.Uninstalling.on.a.Windows.NT.System) 879 0 R (M6.9.13696.2Head.Installing.on.a.Windows.NT.System)621 0 R  (M6.9.15043.ChapterTitle.2.PATROL.WBEM.Adapter.Installation)601 0 R  (M6.9.16557.2Head.Windows.NT.Installation.Files)717 0 R (M6.9.19401.TableTitle.Table.31.Windows.NT.Installation.Files) 721 0 R (M6.9.25882.ChapterTitle.3.Windows.NT.Installation)619 0 R  (M6.9.34790.CheckN1.Step.10.To.complete.the.setup.process.click.Finish) 703 0 R (M7.8.newlink.A)928 0 R ]  endobj 1154 0 obj /Limits [ (M7.8.newlink.B)(P.x)]  /Names [ (M7.8.newlink.B)931 0 R (M7.8.newlink.C)933 0 R (M7.8.newlink.D)937 0 R  (M7.8.newlink.E)943 0 R (M7.8.newlink.F)948 0 R (M7.8.newlink.G) 950 0 R (M7.8.newlink.H)952 0 R (M7.8.newlink.I)954 0 R (M7.8.newlink.J) 964 0 R (M7.8.newlink.K)966 0 R (M7.8.newlink.L)971 0 R (M7.8.newlink.M) 973 0 R (M7.8.newlink.N)1048 0 R (M7.8.newlink.Numerics)926 0 R  (M7.8.newlink.O)1050 0 R (M7.8.newlink.P)1052 0 R (M7.8.newlink.Q) 1069 0 R (M7.8.newlink.R)1071 0 R (M7.8.newlink.S)1078 0 R (M7.8.newlink.Symbols) 924 0 R (M7.8.newlink.T)1082 0 R (M7.8.newlink.U)1084 0 R (M7.8.newlink.V) 1094 0 R (M7.8.newlink.W)1096 0 R (P.1)508 0 R (P.10)835 0 R (P.11) 876 0 R (P.12)881 0 R (P.2)531 0 R (P.3)569 0 R (P.4)586 0 R (P.5) 646 0 R (P.6)654 0 R (P.7)664 0 R (P.8)702 0 R (P.9)766 0 R (P.i) 330 0 R (P.ii)378 0 R (P.iii)398 0 R (P.iv)415 0 R (P.ix)486 0 R  (P.v)424 0 R (P.vi)449 0 R (P.vii)465 0 R (P.viii)474 0 R (P.x)492 0 R  endobj 1155 0 obj /Kids [ 1142 0 R 1143 0 R 1144 0 R 1145 0 R 1146 0 R 1147 0 R 1148 0 R 1149 0 R  1150 0 R 1151 0 R 1152 0 R 1153 0 R 1154 0 R ]  endobj 1156 0 obj /CreationDate (D:19990309142307) /Producer (Acrobat Distiller Command 3.01 for HP-UX A.09.01 and later \(HPPA\)) /Creator (FrameMaker xm5.5P4f) /Title (PATROL Adapter for WBEM Installation Guide) /Subject () /Author () /Keywords (WBEM, ADAPTER, INSTALL) /DCTMObjectId (0900320180066902) /#23DCTMObjectTitle (PATROL Adapter for WBEM Installation Guide) /#23DCTMRequestedBy (dmadmin) /DCTMDocbaseId (12801) /#23DCTMDocbaseName (dmprod1) /#23DCTMSourceContentType (mbook) /ModDate (D:19990309142302) endobj 1157 0 obj /Type /Pages  /Kids [ 1167 0 R 1 0 R 6 0 R 9 0 R 25 0 R 28 0 R 31 0 R 38 0 R 41 0 R 44 0 R  /Count 10  /Parent 1158 0 R  endobj 1158 0 obj /Type /Pages  /Kids [ 1157 0 R 1159 0 R 1160 0 R 1161 0 R ]  /Count 31  endobj 1159 0 obj /Type /Pages  /Kids [ 47 0 R 50 0 R 58 0 R 62 0 R 66 0 R 69 0 R 76 0 R 79 0 R 83 0 R 89 0 R  /Count 10  /Parent 1158 0 R  endobj 1160 0 obj /Type /Pages  /Kids [ 93 0 R 97 0 R 101 0 R 105 0 R 108 0 R 111 0 R 114 0 R 117 0 R 145 0 R  206 0 R ]  /Count 10  /Parent 1158 0 R  endobj 1161 0 obj /Type /Pages  /Kids [ 218 0 R ]  /Count 1  /Parent 1158 0 R  endobj 0 1162  0000000000 65535 f 0000218875 00000 n 0000219060 00000 n 0000219152 00000 n 0000219305 00000 n 0000219690 00000 n 0000222281 00000 n 0000222468 00000 n 0000222598 00000 n 0000224241 00000 n 0000224535 00000 n 0000224651 00000 n 0000224767 00000 n 0000224883 00000 n 0000224999 00000 n 0000225115 00000 n 0000225231 00000 n 0000225347 00000 n 0000225464 00000 n 0000225581 00000 n 0000225698 00000 n 0000225815 00000 n 0000225932 00000 n 0000226048 00000 n 0000226179 00000 n 0000226983 00000 n 0000227173 00000 n 0000227279 00000 n 0000227648 00000 n 0000227838 00000 n 0000227969 00000 n 0000228681 00000 n 0000228912 00000 n 0000229075 00000 n 0000229238 00000 n 0000229405 00000 n 0000229572 00000 n 0000229703 00000 n 0000230976 00000 n 0000231166 00000 n 0000231309 00000 n 0000232796 00000 n 0000232986 00000 n 0000233129 00000 n 0000233983 00000 n 0000234173 00000 n 0000234342 00000 n 0000235926 00000 n 0000236116 00000 n 0000236285 00000 n 0000237230 00000 n 0000237468 00000 n 0000237605 00000 n 0000237742 00000 n 0000237879 00000 n 0000238016 00000 n 0000238153 00000 n 0000238284 00000 n 0000239011 00000 n 0000239221 00000 n 0000239358 00000 n 0000239489 00000 n 0000240729 00000 n 0000240939 00000 n 0000241076 00000 n 0000241233 00000 n 0000242715 00000 n 0000242905 00000 n 0000243011 00000 n 0000243380 00000 n 0000243611 00000 n 0000243748 00000 n 0000243885 00000 n 0000244023 00000 n 0000244161 00000 n 0000244292 00000 n 0000245059 00000 n 0000245249 00000 n 0000245405 00000 n 0000246794 00000 n 0000246984 00000 n 0000247203 00000 n 0000248063 00000 n 0000260056 00000 n 0000260273 00000 n 0000260411 00000 n 0000260548 00000 n 0000260767 00000 n 0000261773 00000 n 0000274022 00000 n 0000274212 00000 n 0000274431 00000 n 0000275151 00000 n 0000286962 00000 n 0000287152 00000 n 0000287371 00000 n 0000288200 00000 n 0000300706 00000 n 0000300896 00000 n 0000301116 00000 n 0000302100 00000 n 0000313301 00000 n 0000313515 00000 n 0000313654 00000 n 0000313824 00000 n 0000315188 00000 n 0000315381 00000 n 0000315527 00000 n 0000316872 00000 n 0000317065 00000 n 0000317211 00000 n 0000318183 00000 n 0000318376 00000 n 0000318520 00000 n 0000319800 00000 n 0000319993 00000 n 0000320100 00000 n 0000320471 00000 n 0000320888 00000 n 0000321008 00000 n 0000321127 00000 n 0000321247 00000 n 0000321367 00000 n 0000321487 00000 n 0000321607 00000 n 0000321726 00000 n 0000321846 00000 n 0000321966 00000 n 0000322085 00000 n 0000322204 00000 n 0000322324 00000 n 0000322444 00000 n 0000322563 00000 n 0000322682 00000 n 0000322801 00000 n 0000322921 00000 n 0000323040 00000 n 0000323159 00000 n 0000323279 00000 n 0000323399 00000 n 0000323519 00000 n 0000323639 00000 n 0000323759 00000 n 0000323879 00000 n 0000324011 00000 n 0000324957 00000 n 0000325634 00000 n 0000325754 00000 n 0000325874 00000 n 0000325994 00000 n 0000326114 00000 n 0000326234 00000 n 0000326354 00000 n 0000326474 00000 n 0000326594 00000 n 0000326713 00000 n 0000326833 00000 n 0000326953 00000 n 0000327072 00000 n 0000327191 00000 n 0000327311 00000 n 0000327431 00000 n 0000327551 00000 n 0000327671 00000 n 0000327791 00000 n 0000327911 00000 n 0000328031 00000 n 0000328151 00000 n 0000328270 00000 n 0000328389 00000 n 0000328508 00000 n 0000328627 00000 n 0000328747 00000 n 0000328867 00000 n 0000328986 00000 n 0000329106 00000 n 0000329226 00000 n 0000329346 00000 n 0000329466 00000 n 0000329586 00000 n 0000329706 00000 n 0000329826 00000 n 0000329946 00000 n 0000330066 00000 n 0000330186 00000 n 0000330306 00000 n 0000330426 00000 n 0000330546 00000 n 0000330666 00000 n 0000330786 00000 n 0000330906 00000 n 0000331026 00000 n 0000331146 00000 n 0000331266 00000 n 0000331386 00000 n 0000331506 00000 n 0000331626 00000 n 0000331746 00000 n 0000331866 00000 n 0000331986 00000 n 0000332106 00000 n 0000332226 00000 n 0000332346 00000 n 0000332466 00000 n 0000332586 00000 n 0000332718 00000 n 0000333748 00000 n 0000334027 00000 n 0000334147 00000 n 0000334267 00000 n 0000334387 00000 n 0000334507 00000 n 0000334626 00000 n 0000334746 00000 n 0000334866 00000 n 0000334986 00000 n 0000335106 00000 n 0000335225 00000 n 0000335686 00000 n 0000335879 00000 n 0000335986 00000 n 0000336357 00000 n 0000336465 00000 n 0000336558 00000 n 0000336668 00000 n 0000336777 00000 n 0000336872 00000 n 0000336968 00000 n 0000337064 00000 n 0000337160 00000 n 0000337256 00000 n 0000337352 00000 n 0000337448 00000 n 0000337560 00000 n 0000337666 00000 n 0000337762 00000 n 0000337878 00000 n 0000337974 00000 n 0000338070 00000 n 0000338166 00000 n 0000338262 00000 n 0000338359 00000 n 0000338455 00000 n 0000338551 00000 n 0000338606 00000 n 0000339591 00000 n 0000339687 00000 n 0000339742 00000 n 0000340727 00000 n 0000340823 00000 n 0000340919 00000 n 0000341015 00000 n 0000341112 00000 n 0000341223 00000 n 0000341320 00000 n 0000341417 00000 n 0000341514 00000 n 0000341611 00000 n 0000341708 00000 n 0000341806 00000 n 0000341903 00000 n 0000342000 00000 n 0000342095 00000 n 0000343401 00000 n 0000346493 00000 n 0000346516 00000 n 0000346941 00000 n 0000346963 00000 n 0000347427 00000 n 0000347449 00000 n 0000347869 00000 n 0000347891 00000 n 0000348231 00000 n 0000348253 00000 n 0000348648 00000 n 0000348670 00000 n 0000349142 00000 n 0000349164 00000 n 0000349621 00000 n 0000349643 00000 n 0000350030 00000 n 0000350052 00000 n 0000350513 00000 n 0000350535 00000 n 0000350930 00000 n 0000350952 00000 n 0000351363 00000 n 0000351385 00000 n 0000351847 00000 n 0000351869 00000 n 0000352374 00000 n 0000352396 00000 n 0000352736 00000 n 0000352758 00000 n 0000353175 00000 n 0000353197 00000 n 0000353646 00000 n 0000353668 00000 n 0000354635 00000 n 0000354657 00000 n 0000355592 00000 n 0000355614 00000 n 0000356588 00000 n 0000356610 00000 n 0000357517 00000 n 0000357539 00000 n 0000358472 00000 n 0000358494 00000 n 0000359070 00000 n 0000359092 00000 n 0000359739 00000 n 0000359761 00000 n 0000360362 00000 n 0000360384 00000 n 0000360827 00000 n 0000360849 00000 n 0000361189 00000 n 0000361211 00000 n 0000361682 00000 n 0000361704 00000 n 0000362207 00000 n 0000362229 00000 n 0000362592 00000 n 0000362614 00000 n 0000362954 00000 n 0000362976 00000 n 0000362998 00000 n 0000363583 00000 n 0000363638 00000 n 0000363698 00000 n 0000363758 00000 n 0000363820 00000 n 0000363882 00000 n 0000363944 00000 n 0000364002 00000 n 0000364060 00000 n 0000364118 00000 n 0000364176 00000 n 0000364234 00000 n 0000364292 00000 n 0000364351 00000 n 0000364409 00000 n 0000364467 00000 n 0000364525 00000 n 0000364583 00000 n 0000364641 00000 n 0000364699 00000 n 0000364757 00000 n 0000364815 00000 n 0000364873 00000 n 0000364931 00000 n 0000364989 00000 n 0000365047 00000 n 0000365105 00000 n 0000365163 00000 n 0000365221 00000 n 0000365279 00000 n 0000365337 00000 n 0000365395 00000 n 0000365453 00000 n 0000365511 00000 n 0000365569 00000 n 0000365627 00000 n 0000365685 00000 n 0000365743 00000 n 0000365801 00000 n 0000365859 00000 n 0000365917 00000 n 0000365975 00000 n 0000366033 00000 n 0000366091 00000 n 0000366149 00000 n 0000366207 00000 n 0000366265 00000 n 0000366323 00000 n 0000366381 00000 n 0000366439 00000 n 0000366497 00000 n 0000366555 00000 n 0000366614 00000 n 0000366673 00000 n 0000366731 00000 n 0000366789 00000 n 0000366847 00000 n 0000366905 00000 n 0000366963 00000 n 0000367021 00000 n 0000367079 00000 n 0000367137 00000 n 0000367195 00000 n 0000367253 00000 n 0000367311 00000 n 0000367369 00000 n 0000367427 00000 n 0000367485 00000 n 0000367543 00000 n 0000367601 00000 n 0000367659 00000 n 0000367717 00000 n 0000367776 00000 n 0000367835 00000 n 0000367893 00000 n 0000367951 00000 n 0000368009 00000 n 0000368067 00000 n 0000368125 00000 n 0000368183 00000 n 0000368241 00000 n 0000368299 00000 n 0000368357 00000 n 0000368415 00000 n 0000368473 00000 n 0000368531 00000 n 0000368589 00000 n 0000368648 00000 n 0000368707 00000 n 0000368767 00000 n 0000368827 00000 n 0000368886 00000 n 0000368945 00000 n 0000369004 00000 n 0000369063 00000 n 0000369122 00000 n 0000369181 00000 n 0000369240 00000 n 0000369300 00000 n 0000369360 00000 n 0000369419 00000 n 0000369478 00000 n 0000369537 00000 n 0000369596 00000 n 0000369655 00000 n 0000369714 00000 n 0000369773 00000 n 0000369832 00000 n 0000369891 00000 n 0000369950 00000 n 0000370009 00000 n 0000370068 00000 n 0000370127 00000 n 0000370186 00000 n 0000370245 00000 n 0000370304 00000 n 0000370363 00000 n 0000370422 00000 n 0000370481 00000 n 0000370540 00000 n 0000370599 00000 n 0000370658 00000 n 0000370717 00000 n 0000370777 00000 n 0000370836 00000 n 0000370895 00000 n 0000370954 00000 n 0000371013 00000 n 0000371072 00000 n 0000371131 00000 n 0000371190 00000 n 0000371249 00000 n 0000371308 00000 n 0000371367 00000 n 0000371426 00000 n 0000371485 00000 n 0000371544 00000 n 0000371603 00000 n 0000371662 00000 n 0000371722 00000 n 0000371781 00000 n 0000371840 00000 n 0000371899 00000 n 0000371958 00000 n 0000372017 00000 n 0000372076 00000 n 0000372135 00000 n 0000372194 00000 n 0000372254 00000 n 0000372313 00000 n 0000372372 00000 n 0000372431 00000 n 0000372490 00000 n 0000372549 00000 n 0000372608 00000 n 0000372667 00000 n 0000372726 00000 n 0000372785 00000 n 0000372844 00000 n 0000372903 00000 n 0000372963 00000 n 0000373022 00000 n 0000373081 00000 n 0000373140 00000 n 0000373199 00000 n 0000373258 00000 n 0000373318 00000 n 0000373378 00000 n 0000373437 00000 n 0000373496 00000 n 0000373555 00000 n 0000373614 00000 n 0000373673 00000 n 0000373732 00000 n 0000373791 00000 n 0000373850 00000 n 0000373909 00000 n 0000373968 00000 n 0000374027 00000 n 0000374086 00000 n 0000374145 00000 n 0000374204 00000 n 0000374264 00000 n 0000374324 00000 n 0000374383 00000 n 0000374442 00000 n 0000374501 00000 n 0000374560 00000 n 0000374619 00000 n 0000374678 00000 n 0000374737 00000 n 0000374796 00000 n 0000374855 00000 n 0000374914 00000 n 0000374973 00000 n 0000375032 00000 n 0000375091 00000 n 0000375150 00000 n 0000375209 00000 n 0000375268 00000 n 0000375327 00000 n 0000375386 00000 n 0000375445 00000 n 0000375504 00000 n 0000375563 00000 n 0000375623 00000 n 0000375682 00000 n 0000375741 00000 n 0000375800 00000 n 0000375859 00000 n 0000375918 00000 n 0000375977 00000 n 0000376036 00000 n 0000376095 00000 n 0000376154 00000 n 0000376213 00000 n 0000376272 00000 n 0000376331 00000 n 0000376390 00000 n 0000376449 00000 n 0000376508 00000 n 0000376567 00000 n 0000376626 00000 n 0000376685 00000 n 0000376744 00000 n 0000376803 00000 n 0000376862 00000 n 0000376921 00000 n 0000376980 00000 n 0000377039 00000 n 0000377098 00000 n 0000377157 00000 n 0000377216 00000 n 0000377275 00000 n 0000377334 00000 n 0000377393 00000 n 0000377452 00000 n 0000377511 00000 n 0000377570 00000 n 0000377629 00000 n 0000377688 00000 n 0000377747 00000 n 0000377806 00000 n 0000377866 00000 n 0000377925 00000 n 0000377984 00000 n 0000378043 00000 n 0000378102 00000 n 0000378161 00000 n 0000378220 00000 n 0000378279 00000 n 0000378338 00000 n 0000378397 00000 n 0000378456 00000 n 0000378515 00000 n 0000378574 00000 n 0000378633 00000 n 0000378692 00000 n 0000378751 00000 n 0000378810 00000 n 0000378870 00000 n 0000378930 00000 n 0000378989 00000 n 0000379048 00000 n 0000379107 00000 n 0000379166 00000 n 0000379225 00000 n 0000379284 00000 n 0000379343 00000 n 0000379402 00000 n 0000379461 00000 n 0000379520 00000 n 0000379579 00000 n 0000379638 00000 n 0000379698 00000 n 0000379757 00000 n 0000379816 00000 n 0000379875 00000 n 0000379934 00000 n 0000379993 00000 n 0000380052 00000 n 0000380111 00000 n 0000380170 00000 n 0000380229 00000 n 0000380288 00000 n 0000380347 00000 n 0000380406 00000 n 0000380465 00000 n 0000380524 00000 n 0000380583 00000 n 0000380642 00000 n 0000380701 00000 n 0000380760 00000 n 0000380819 00000 n 0000380878 00000 n 0000380937 00000 n 0000380996 00000 n 0000381055 00000 n 0000381114 00000 n 0000381173 00000 n 0000381232 00000 n 0000381291 00000 n 0000381350 00000 n 0000381409 00000 n 0000381468 00000 n 0000381527 00000 n 0000381586 00000 n 0000381645 00000 n 0000381704 00000 n 0000381763 00000 n 0000381822 00000 n 0000381881 00000 n 0000381940 00000 n 0000381999 00000 n 0000382058 00000 n 0000382117 00000 n 0000382176 00000 n 0000382235 00000 n 0000382294 00000 n 0000382353 00000 n 0000382413 00000 n 0000382472 00000 n 0000382531 00000 n 0000382590 00000 n 0000382649 00000 n 0000382708 00000 n 0000382767 00000 n 0000382826 00000 n 0000382886 00000 n 0000382945 00000 n 0000383004 00000 n 0000383063 00000 n 0000383122 00000 n 0000383181 00000 n 0000383240 00000 n 0000383299 00000 n 0000383358 00000 n 0000383417 00000 n 0000383477 00000 n 0000383537 00000 n 0000383597 00000 n 0000383657 00000 n 0000383717 00000 n 0000383777 00000 n 0000383837 00000 n 0000383897 00000 n 0000383957 00000 n 0000384017 00000 n 0000384077 00000 n 0000384137 00000 n 0000384197 00000 n 0000384257 00000 n 0000384317 00000 n 0000384377 00000 n 0000384437 00000 n 0000384497 00000 n 0000384557 00000 n 0000384617 00000 n 0000384677 00000 n 0000384737 00000 n 0000384797 00000 n 0000384857 00000 n 0000384917 00000 n 0000384977 00000 n 0000385037 00000 n 0000385097 00000 n 0000385157 00000 n 0000385217 00000 n 0000385277 00000 n 0000385337 00000 n 0000385397 00000 n 0000385457 00000 n 0000385517 00000 n 0000385577 00000 n 0000385637 00000 n 0000385697 00000 n 0000385758 00000 n 0000385818 00000 n 0000385878 00000 n 0000385938 00000 n 0000385998 00000 n 0000386058 00000 n 0000386118 00000 n 0000386178 00000 n 0000386238 00000 n 0000386298 00000 n 0000386358 00000 n 0000386418 00000 n 0000386478 00000 n 0000386538 00000 n 0000386598 00000 n 0000386658 00000 n 0000386718 00000 n 0000386778 00000 n 0000386838 00000 n 0000386898 00000 n 0000386958 00000 n 0000387018 00000 n 0000387078 00000 n 0000387138 00000 n 0000387198 00000 n 0000387258 00000 n 0000387318 00000 n 0000387378 00000 n 0000387438 00000 n 0000387498 00000 n 0000387558 00000 n 0000387618 00000 n 0000387678 00000 n 0000387738 00000 n 0000387798 00000 n 0000387858 00000 n 0000387918 00000 n 0000387978 00000 n 0000388038 00000 n 0000388098 00000 n 0000388158 00000 n 0000388218 00000 n 0000388278 00000 n 0000388338 00000 n 0000388398 00000 n 0000388458 00000 n 0000388518 00000 n 0000388578 00000 n 0000388638 00000 n 0000388698 00000 n 0000388758 00000 n 0000388818 00000 n 0000388878 00000 n 0000388938 00000 n 0000388998 00000 n 0000389058 00000 n 0000389118 00000 n 0000389178 00000 n 0000389238 00000 n 0000389298 00000 n 0000389358 00000 n 0000389418 00000 n 0000389478 00000 n 0000389538 00000 n 0000389599 00000 n 0000389659 00000 n 0000389719 00000 n 0000389779 00000 n 0000389839 00000 n 0000389899 00000 n 0000389959 00000 n 0000390019 00000 n 0000390079 00000 n 0000390139 00000 n 0000390199 00000 n 0000390259 00000 n 0000390319 00000 n 0000390379 00000 n 0000390439 00000 n 0000390499 00000 n 0000390559 00000 n 0000390619 00000 n 0000390679 00000 n 0000390739 00000 n 0000390799 00000 n 0000390859 00000 n 0000390919 00000 n 0000390979 00000 n 0000391039 00000 n 0000391099 00000 n 0000391159 00000 n 0000391219 00000 n 0000391279 00000 n 0000391339 00000 n 0000391399 00000 n 0000391459 00000 n 0000391519 00000 n 0000391579 00000 n 0000391639 00000 n 0000391699 00000 n 0000391759 00000 n 0000391819 00000 n 0000391879 00000 n 0000391939 00000 n 0000391999 00000 n 0000392059 00000 n 0000392119 00000 n 0000392179 00000 n 0000392239 00000 n 0000392299 00000 n 0000392359 00000 n 0000392419 00000 n 0000392479 00000 n 0000392539 00000 n 0000392599 00000 n 0000392659 00000 n 0000392719 00000 n 0000392779 00000 n 0000392839 00000 n 0000392899 00000 n 0000392959 00000 n 0000393019 00000 n 0000393079 00000 n 0000393139 00000 n 0000393199 00000 n 0000393259 00000 n 0000393319 00000 n 0000393379 00000 n 0000393439 00000 n 0000393499 00000 n 0000393559 00000 n 0000393619 00000 n 0000393679 00000 n 0000393740 00000 n 0000393800 00000 n 0000393860 00000 n 0000393920 00000 n 0000393980 00000 n 0000394040 00000 n 0000394100 00000 n 0000394160 00000 n 0000394220 00000 n 0000394280 00000 n 0000394340 00000 n 0000394400 00000 n 0000394460 00000 n 0000394520 00000 n 0000394580 00000 n 0000394640 00000 n 0000394700 00000 n 0000394760 00000 n 0000394820 00000 n 0000394880 00000 n 0000394940 00000 n 0000395000 00000 n 0000395060 00000 n 0000395120 00000 n 0000395180 00000 n 0000395240 00000 n 0000395300 00000 n 0000395360 00000 n 0000395420 00000 n 0000395480 00000 n 0000395540 00000 n 0000395600 00000 n 0000395660 00000 n 0000395720 00000 n 0000395780 00000 n 0000395840 00000 n 0000395900 00000 n 0000395960 00000 n 0000396020 00000 n 0000396080 00000 n 0000396140 00000 n 0000396201 00000 n 0000396261 00000 n 0000396321 00000 n 0000396381 00000 n 0000396441 00000 n 0000396502 00000 n 0000396563 00000 n 0000396623 00000 n 0000396683 00000 n 0000396743 00000 n 0000396803 00000 n 0000396863 00000 n 0000396923 00000 n 0000396983 00000 n 0000397043 00000 n 0000397103 00000 n 0000397163 00000 n 0000397223 00000 n 0000397283 00000 n 0000397343 00000 n 0000397403 00000 n 0000397463 00000 n 0000397523 00000 n 0000397583 00000 n 0000397643 00000 n 0000397703 00000 n 0000397763 00000 n 0000397823 00000 n 0000397883 00000 n 0000397943 00000 n 0000398003 00000 n 0000398063 00000 n 0000398123 00000 n 0000398183 00000 n 0000398243 00000 n 0000398303 00000 n 0000398363 00000 n 0000398423 00000 n 0000398483 00000 n 0000398543 00000 n 0000398603 00000 n 0000398663 00000 n 0000398723 00000 n 0000398783 00000 n 0000398843 00000 n 0000398903 00000 n 0000398963 00000 n 0000399024 00000 n 0000399084 00000 n 0000399144 00000 n 0000399204 00000 n 0000399264 00000 n 0000399324 00000 n 0000399384 00000 n 0000399444 00000 n 0000399504 00000 n 0000399564 00000 n 0000399624 00000 n 0000399684 00000 n 0000399744 00000 n 0000399804 00000 n 0000399864 00000 n 0000399924 00000 n 0000399984 00000 n 0000400044 00000 n 0000400104 00000 n 0000400164 00000 n 0000400224 00000 n 0000400284 00000 n 0000400344 00000 n 0000400404 00000 n 0000400464 00000 n 0000400524 00000 n 0000400584 00000 n 0000400644 00000 n 0000400704 00000 n 0000400764 00000 n 0000400824 00000 n 0000400884 00000 n 0000400944 00000 n 0000401004 00000 n 0000401064 00000 n 0000401124 00000 n 0000401184 00000 n 0000401244 00000 n 0000401304 00000 n 0000401364 00000 n 0000401424 00000 n 0000401484 00000 n 0000401544 00000 n 0000401604 00000 n 0000401664 00000 n 0000401724 00000 n 0000401784 00000 n 0000401844 00000 n 0000401904 00000 n 0000401964 00000 n 0000402024 00000 n 0000402084 00000 n 0000402144 00000 n 0000402204 00000 n 0000402264 00000 n 0000402324 00000 n 0000402384 00000 n 0000402444 00000 n 0000402504 00000 n 0000402564 00000 n 0000402624 00000 n 0000402684 00000 n 0000402744 00000 n 0000402804 00000 n 0000402864 00000 n 0000402924 00000 n 0000402984 00000 n 0000403044 00000 n 0000403104 00000 n 0000403164 00000 n 0000403224 00000 n 0000403284 00000 n 0000403344 00000 n 0000403404 00000 n 0000403464 00000 n 0000403524 00000 n 0000403584 00000 n 0000403645 00000 n 0000403706 00000 n 0000403767 00000 n 0000403828 00000 n 0000403889 00000 n 0000403950 00000 n 0000404011 00000 n 0000404072 00000 n 0000404133 00000 n 0000404194 00000 n 0000404255 00000 n 0000404316 00000 n 0000404377 00000 n 0000404438 00000 n 0000404499 00000 n 0000404560 00000 n 0000404621 00000 n 0000404682 00000 n 0000404743 00000 n 0000404804 00000 n 0000404865 00000 n 0000404926 00000 n 0000404987 00000 n 0000405048 00000 n 0000405109 00000 n 0000405170 00000 n 0000405231 00000 n 0000405292 00000 n 0000405353 00000 n 0000405414 00000 n 0000405475 00000 n 0000405536 00000 n 0000405597 00000 n 0000405658 00000 n 0000405719 00000 n 0000405780 00000 n 0000405841 00000 n 0000405902 00000 n 0000405963 00000 n 0000406024 00000 n 0000406085 00000 n 0000406146 00000 n 0000406207 00000 n 0000406268 00000 n 0000406329 00000 n 0000406390 00000 n 0000406451 00000 n 0000406512 00000 n 0000406573 00000 n 0000406634 00000 n 0000406695 00000 n 0000406756 00000 n 0000406817 00000 n 0000406878 00000 n 0000406939 00000 n 0000407000 00000 n 0000407061 00000 n 0000407122 00000 n 0000407183 00000 n 0000407244 00000 n 0000407305 00000 n 0000407366 00000 n 0000407427 00000 n 0000407488 00000 n 0000407549 00000 n 0000407610 00000 n 0000407671 00000 n 0000407732 00000 n 0000407793 00000 n 0000407854 00000 n 0000407915 00000 n 0000407976 00000 n 0000408037 00000 n 0000408098 00000 n 0000408159 00000 n 0000408220 00000 n 0000408281 00000 n 0000408342 00000 n 0000408403 00000 n 0000408464 00000 n 0000408525 00000 n 0000408586 00000 n 0000408647 00000 n 0000408708 00000 n 0000408769 00000 n 0000408830 00000 n 0000408891 00000 n 0000408952 00000 n 0000409013 00000 n 0000409074 00000 n 0000409135 00000 n 0000409196 00000 n 0000409257 00000 n 0000409318 00000 n 0000409379 00000 n 0000409440 00000 n 0000409501 00000 n 0000409562 00000 n 0000409623 00000 n 0000409684 00000 n 0000409745 00000 n 0000409806 00000 n 0000409867 00000 n 0000409928 00000 n 0000409989 00000 n 0000410050 00000 n 0000410111 00000 n 0000410172 00000 n 0000410233 00000 n 0000410294 00000 n 0000410355 00000 n 0000410416 00000 n 0000410477 00000 n 0000410538 00000 n 0000410599 00000 n 0000410660 00000 n 0000410721 00000 n 0000410782 00000 n 0000410843 00000 n 0000410904 00000 n 0000410965 00000 n 0000411026 00000 n 0000411087 00000 n 0000411148 00000 n 0000411209 00000 n 0000411270 00000 n 0000411331 00000 n 0000411392 00000 n 0000411453 00000 n 0000411514 00000 n 0000411575 00000 n 0000411636 00000 n 0000411697 00000 n 0000411758 00000 n 0000411819 00000 n 0000411880 00000 n 0000411941 00000 n 0000412002 00000 n 0000412063 00000 n 0000412124 00000 n 0000412185 00000 n 0000412247 00000 n 0000413382 00000 n 0000414578 00000 n 0000415751 00000 n 0000416981 00000 n 0000418220 00000 n 0000419459 00000 n 0000420697 00000 n 0000421992 00000 n 0000423302 00000 n 0000424675 00000 n 0000426082 00000 n 0000428047 00000 n 0000429031 00000 n 0000429186 00000 n 0000429709 00000 n 0000429859 00000 n 0000429957 00000 n 0000430108 00000 n 0000430267 00000 n trailer /Size 1162 /ID[<fb4ff55abc4d4c26d4effc98fdceefb9><fb4ff55abc4d4c26d4effc98fdceefb9>] startxref %%EOF %%EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\service.txt ===
SERVICE.TXT

This document contains information on how to use the CNtService class to 
produce a Win32 Service Executable. (6/24/96 a-davj)

This is a simplified version of the CService class which was originally 
done by Ray McCollum.  It is simpler chiefly because it is now the 
responsibility of the class user to manage their threads and the 
class does not rely on any SMS diagnostics.

=========================================================================

1.1  A minimal conversion

To produce a service from a normal EXE with the minimum work, you must
derive a new class from CNtService and override the WorkerThread() and Stop()
virtual functions:

class MyService : public CNtService
{
public:
   virtual void WorkerThread();    // Your component goes here
   virtual void Stop();            // Your component goes here
};

void MyService::WorkerThread()
{
   ...loop doing useful work until signaled by the Stop function.
}

void MyService::Stop()
{
   ...Signal the thread running in WorkerThread to return from that
   ...routine
}

The WorkerThread() function is the entry point for your code.  You can
branch out to normal non-object functions, or whatever.  It is the job of
your Stop() function to signal the thread running in the WorkerFunction 
to return and when that thread returns, the service will terminate properly.  

Execution of the service is begun by using the Service Control Manager
APIs in another program, the Control Panel or else using NET START/NET STOP/
NET PAUSE/NET CONTINUE from a DOS box.  When the user types

     NET START MYSERVICE

...your service will attempt to start.

Note that you must have added your service to the SCM (Service Control 
Manager) data base before you can start it.  There are various ways to add a
service though I found the SC.EXE to be quite useful and it can be found
via MSDN.

Your main() entry point might be rewritten along the following
lines:

void main()
{
    MyService Sample;
    Sample.Run(TRUE, "MYSERVICE");      // TRUE = run as a Service,
                                        // FALSE = run as a normal EXE
}

When Run() is called, you can make the decision as to whether you are
running as a normal EXE or a service via the first argument.  The
second argument is the service name.  This can be any length and is not
related to the .EXE name itself.

After Run() is invoked, then WorkerThread() is called to actually do
the work of the service.  [Run() and WorkerThread() are actually separate
threads at this point, although Run() will not return until the service
stops.]

When the user types NET STOP MYSERVICE, then the Stop() function 
is called and it signals for the WorkerThread() function to 
return which then results in the service being stopped.

=========================================================================

1.2 Supporting Pause, Continue, and  custom control codes.

If you want to support suspending your service by NET PAUSE MYSERVICE and 
resuming it by NET CONTINUE MYSERVICE, then you must override the Pause()
and Continue() virtual functions and call the SetPauseContinue()
function with a TRUE argument.  

It is the job of your Pause() and Continue() functions to do whatever is 
right for your service.  In some cases that might mean actually suspending 
and resuming threads, or it could mean that the threads will just not perform 
certain functions.

User codes can be accepted by overriding the UserCode() function.  
The UserCode() function is only valid if the program controlling
the service has been coded to send user-defined control codes to the
service.  The command-line based NET functions have no facility for this.
Basically, a specially coded control program can send codes other than
STOP, PAUSE, CONTINUE or START. These codes must fall in the subrange
128..255 and the code being sent is in the DWORD argument.
The meaning is user-defined.  Since there is no response mechanism
back to the sending process, this does not seem terribly useful.  These
codes are ignored if UserCode() is not overridden.

Note that the original CService class did handle some specific UserCodes
and this class does NOT.

===========================================================================

1.3  Logging support.

The service wrapper code only logs unexpected errors.  By default, it adds
them to the NT event log when running as a service and to stdio when running
as an executable.  It does this through a virtual function named Log() which
can be used for your code, or can be overridden if there is some other logging
mechanism that is desired.

=========================================================================

1.4  Timing Issues.

Functions such as Pausing, Continuing and Stopping must complete in 
under 20 seconds.  A delinquent Pause or Continue isn't too serious since
that will only cause a error for the NET xyx command.  However, the system
will kill any service that is too slow in stopping.

The Initialize() function is called during NET START, but before your
worker thread begins execution.   Again, this must return within 20
seconds.  In most cases, you will not need this and can do initializations
in WorkerThread itself.  Any command-line arguments passed in to the
service are available from the parameters.   These are only valid if the EXE
is executing as a service;  if you are executing as a normal EXE, then process
the command line arguments from main() instead, since these will be NULL.

In general, the command line arguments don't tend to be terribly useful for
services.

========================================================================

1.5  Non-service EXE execution.

If Run() is called with FALSE, then the service behaves as a normal
multi-threaded EXE.   The behavior is still basically the same as for a
service:  WorkerThread() should be the effective entry point for the work
to get done.  However, there will be no NET STOP, PAUSE , User Codes, or
CONTINUE requests coming in, so your Pause(), Continue(), Initialize(),
UserCode and Stop() functions will never be called.

=========================================================================

1.6  Service Names

Service names can contain any characters if you use the Win32 APIs or
service control classes.  However, the NET commands only support normal
filename type characters.  It is best to use alphanumeric characters with
optional underscores.

=========================================================================

1.7 An additional example and debugging hints.

This sample uses the command line arguments to determine if the program
should run as a service.  It also handles Pause and Continue and it uses
Initialize.  

This sample is also setup to INTENTIONALLY CAUSE A BREAK!  The WorkerThread
routine has some logic where by an INT 3 is caused 2 minutes into the run.
This brings up an exception box which gives you the oportunity to debug the
service even if it was automatically started by the system.  Naturally you 
still need to be running a debug build.

This code is a bit simplistic in that it uses simple variables
to communicate pause and stop and a real production program would probably
protect these variable via Mutex or use Signal(s).


class MyService : public CNtService{
public:
    MyService();
    DWORD WorkerThread();
    void Stop(){bRun = FALSE;return;};
    void Pause(){bContinue = FALSE;return;};
    void Continue(){bContinue = TRUE;return;};
    BOOL bRun, bContinue;
};

int main(int argc, char ** argv)
{
    MyService svc;
    svc.SetPauseContinue(TRUE);
    if(argc > 1 && _stricmp(argv[1],"/EXE") == 0)
    {
        // run as console app.  Note that Initialize will get the /EXE arg

        svc.Initialize(argc, argv);
        svc.Run("doesntMatter!", FALSE); 
    }
    else
        svc.Run("MyService", TRUE); 
    return 0;
}

MyService::MyService()
{
    bRun = bContinue = TRUE;
}

DWORD MyService::WorkerThread()
{
    int nCount = 0;
    while(bRun) 
    {
        if(bContinue)
        {
            MessageBeep(0);
        }
        Sleep(3000);
        if(nCount == 40)
             _asm int 3;
         nCount++;
    }
    return 0;
}


=========================================================================

2.1  LIMITATIONS on the current implementation.

A.  Only one service is supported per .EXE.  This limitation can be removed,
    however any having more than one service per EXE would require the 
    service to run only in the Local Service account which is generally
    not acceptable.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\ctrtest\ctrtest.ini ===
[main]
NumObjects=1
NumThreads=10
LoopCount=1
Random=1
CycleCount=1000000
Object0=tcpip
Object1=perfnet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\evilperf.ini ===
[info]
drivername=EVILPERF
symbolfile=genctrnm.h

[languages]
009=English
015=Piglatin

[objects]
EVIL_OBJ1_009_NAME=Evil Object 1
EVIL_OBJ2_009_NAME=Evil Object 2
EVIL_OBJ3_009_NAME=Evil Object 3
EVIL_OBJ4_009_NAME=Evil Object 4
EVIL_OBJ5_009_NAME=Evil Object 5
EVIL_OBJ1_015_NAME=Vileay Bjectoay 1
EVIL_OBJ2_015_NAME=Vileay Bjectoay 2
EVIL_OBJ3_015_NAME=Vileay Bjectoay 3
EVIL_OBJ4_015_NAME=Vileay Bjectoay 4
EVIL_OBJ5_015_NAME=Vileay Bjectoay 5

[text]
EVIL_OBJ1_009_NAME=Evil Signal Generator 1
EVIL_OBJ1_009_HELP=It really does nothing at all (It would make a good programmer!)
EVIL_OBJ2_009_NAME=Evil Signal Generator 2
EVIL_OBJ2_009_HELP=It really does nothing at all (It would make a good programmer!)
EVIL_OBJ3_009_NAME=Evil Signal Generator 3
EVIL_OBJ3_009_HELP=It really does nothing at all (It would make a good programmer!)
EVIL_OBJ4_009_NAME=Evil Signal Generator 4
EVIL_OBJ4_009_HELP=It really does nothing at all (It would make a good programmer!)
EVIL_OBJ5_009_NAME=Evil Signal Generator 5
EVIL_OBJ5_009_HELP=It really does nothing at all (It would make a good programmer!)

EVIL_COUNTER1_009_NAME=Counter1
EVIL_COUNTER1_009_HELP=This is the description of Counter1.
EVIL_COUNTER2_009_NAME=Counter2
EVIL_COUNTER2_009_HELP=This is the description of Counter2.
EVIL_COUNTER3_009_NAME=Counter3
EVIL_COUNTER3_009_HELP=This is the description of Counter3.
EVIL_COUNTER4_009_NAME=Counter4
EVIL_COUNTER4_009_HELP=This is the description of Counter4.

EVIL_OBJ1_015_NAME=Vileay Ignalsay Eneratorgay 1
EVIL_OBJ1_015_HELP=Tiay eallyray oesday othingnay taay llaay (Tiay ouldway akemay aay oodgay rogrammerpay!)
EVIL_OBJ2_015_NAME=Vileay Ignalsay Eneratorgay 2
EVIL_OBJ2_015_HELP=Tiay eallyray oesday othingnay taay llaay (Tiay ouldway akemay aay oodgay rogrammerpay!)
EVIL_OBJ3_015_NAME=Vileay Ignalsay Eneratorgay 3
EVIL_OBJ3_015_HELP=Tiay eallyray oesday othingnay taay llaay (Tiay ouldway akemay aay oodgay rogrammerpay!)
EVIL_OBJ4_015_NAME=Vileay Ignalsay Eneratorgay 4
EVIL_OBJ4_015_HELP=Tiay eallyray oesday othingnay taay llaay (Tiay ouldway akemay aay oodgay rogrammerpay!)
EVIL_OBJ5_015_NAME=Vileay Ignalsay Eneratorgay 5
EVIL_OBJ5_015_HELP=Tiay eallyray oesday othingnay taay llaay (Tiay ouldway akemay aay oodgay rogrammerpay!)

EVIL_COUNTER1_015_NAME=Ountercay1
EVIL_COUNTER1_015_HELP=Histay siay hetay escriptionday foay Ountercay1.
EVIL_COUNTER2_015_NAME=Ountercay2
EVIL_COUNTER2_015_HELP=Histay siay hetay escriptionday foay Ountercay2.
EVIL_COUNTER3_015_NAME=Ountercay3
EVIL_COUNTER3_015_HELP=Histay siay hetay escriptionday foay Ountercay3.
EVIL_COUNTER4_015_NAME=Ountercay4
EVIL_COUNTER4_015_HELP=Histay siay hetay escriptionday foay Ountercay4.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\readme.txt ===
Using the Signal Generator Performance DLL

Overview:

The Signal Generator performance DLL provides 3 waveforms at 5
different periods for use with the Performance Monitor to provide
data at a known rate and value. This can be useful in testing
applications that use performance data and need predictable values to
test against.


Building and Installing:

The DLL must be built from the source code using the Windows NT build
Utilities and then installed on the target system using the following
steps:

    1. Copy the PerfGen.DLL that was built to the %systemroot%\system32 
    directory.

    2. load the driver entries into the registry using the following
    command line:

        REGEDIT PERFGEN.REG

    3. load the performance names into the registry using the command
    line:

        LODCTR PERFGEN.INI

At this point all the software is installed and it ready to use.
Start Perfmon and select the "Signal Generator" object to select the
desired wave form and period.

NOTE: The system may need to be restarted after these instructions 
are completed for this object to be seen by remote computers.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\readme.txt ===
========================================================================
       MICROSOFT FOUNDATION CLASS LIBRARY : ShowPerfLib
========================================================================


AppWizard has created this ShowPerfLib application for you.  This application
not only demonstrates the basics of using the Microsoft Foundation classes
but is also a starting point for writing your application.

This file contains a summary of what you will find in each of the files that
make up your ShowPerfLib application.

ShowPerfLib.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.

ShowPerfLib.h
    This is the main header file for the application.  It includes other
    project specific headers (including Resource.h) and declares the
    CShowPerfLibApp application class.

ShowPerfLib.cpp
    This is the main application source file that contains the application
    class CShowPerfLibApp.

ShowPerfLib.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Visual C++.

ShowPerfLib.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.

res\ShowPerfLib.ico
    This is an icon file, which is used as the application's icon.  This
    icon is included by the main resource file ShowPerfLib.rc.

res\ShowPerfLib.rc2
    This file contains resources that are not edited by Microsoft 
	Visual C++.  You should place all resources not editable by
	the resource editor in this file.




/////////////////////////////////////////////////////////////////////////////

AppWizard creates one dialog class:

ShowPerfLibDlg.h, ShowPerfLibDlg.cpp - the dialog
    These files contain your CShowPerfLibDlg class.  This class defines
    the behavior of your application's main dialog.  The dialog's
    template is in ShowPerfLib.rc, which can be edited in Microsoft
	Visual C++.


/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named ShowPerfLib.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Visual C++ reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

If your application uses MFC in a shared DLL, and your application is 
in a language other than the operating system's current language, you
will need to copy the corresponding localized resources MFC42XXX.DLL
from the Microsoft Visual C++ CD-ROM onto the system or system32 directory,
and rename it to be MFCLOC.DLL.  ("XXX" stands for the language abbreviation.
For example, MFC42DEU.DLL contains resources translated to German.)  If you
don't do this, some of the UI elements of your application will remain in the
language of the operating system.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\perfsrv\readme.txt ===
To build the perfsrv project:

1. Open the PerfSrv workspace and build both the PerfSrv and PerfCli projects.  PerfSrv will 
	automatically be registered.

2. Run perfcli.exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\egg\egg.txt ===
WBEMTEAM
The Microsoft WBEM Team

--------------------
General Manager
--------------------
Rob Wight

--------------------
Program Management
--------------------
Simon Towers 

J. Patrick Thompson
Stephen Todd
Dilip Naik
Jon Evans
Tim Kraus

--------------------
Software Development
--------------------
Irena Hudis 

Alan Boshier
Andrew Sinclair
Brad Shantz
Corina Feuerstein
Dave Johnson
David Callahan 
David Wohlferd
Howard Hance
Jenny McCollum
Judy Powell
Kevin Hintergardt 
Larry French
Lev Novik
Mick Healy
Nadir Ahmed
Paul Allen
Rajeev Byrisetty
Rajesh Rao
Ray McCollum
Roger Booth
Sai Wong
Sanjeev Surati
Steve Menzies

--------------------
Test
--------------------
Kelly Altom

Airi Taniguchi
Andrew George
Bob Papasian
Chad Allred
Chris Chantrill
Dave Natsuhara
Delvon Bouwhuis
Don Bui
Eric Maple
F. Chung Wei
Idemudia Sanni
Jae Choi
Jay Herbison
John Quel
Jonathan Liu
Ken Webb
Marco Antonio
Mark Wirkus
Min Suk Song
Noelle Mramor
Patricia Bong
Stephen Barnes
Tewfik Zeghmi
Travis Muhlestein

--------------------
Marketing
--------------------
Victor Raisys

Michael Emanuel
Matthew McGinnis
David Hamilton

--------------------
Build
--------------------
Jeff Stewart

--------------------
Developer Documentation
--------------------
Jim Glass 

Susan Dernbach
Gary McGinnis
Lynne Wasson
Howard Hilliker
Rob Cook
Laurence Smith
Gary McGinnis
Bob Burns
Mary Browning
Brett Zalkan
Dave Baldwin
Cristina Chapman
Patrick Ngo
Scott Pickle
Andy Blinn

-----------------------
Support Team
-----------------------

Scot Boyd
Angela Carter
Fadi Andari
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\decisions.txt ===
1) Updates to provider registrations may interrupt the flow of events from that
    provider, no matter how small the change.
2) Updates to binding parameters can interrupt the flow of events through the
    binding.
*3) Updates to class defintions shall be treated as deletions and creations. 
    Thus, changing a class definition will interrupt the flow of affected
    events. 
*4) In light of (3), we will not take on any atmicity obligations in terms of
    delivering events when registration-affecting changes are taking place. 
    Another justification for it is that since the database supports no 
    transactioning, we can retrieve different definitions for a class during 
    our compilation, placing the ESS into an inconsistent state.  There is no 
    solution to this short of ESS implementing transactioned view of the DB.

5? What are we going to do about class definitions changing while providers
    (say instance providers) are holding them?
6) Reentrancy: while an update is in progress, no participant of that update 
    may initiate another update that affects any of the objects affected by the
    first update.  ESS will detect and reject by recording the thread id in the
    locks.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\design.txt ===
In addition to the single ESS object, there will be namespace representation 
objects, containing:
----------------------------------------------------------------------------

- namespace pointer
- update lock
- binding table
- poller
- provider cache
- consumer provider cache
- tree for database event filtering

The main ESS object is left with:
- searchable list of namespace representation objects
- the thread pool
- the timer 
- the event log



There are several types of operations that affect event registrations;
----------------------------------------------------------------------

1) Creation and deletion of event filters.
2) Creation and deletion of bindings.
3) Creation and deletion of event provider registrations.
4) Creation, deletion and modification of class definitions.
5) Creation and deletion of consumer provider registrations.


These operations will affect the following updatable objects:
-------------------------------------------------------------

1) Event filters (CEventFilter): creation, deletion, binding list change, 
    activation, deactivation.
2) Event Consumers (CPermanentConsumer): creation, deletion, consumer provider 
    reference.
3) Provider pods: filter tree updates in proxies.


The following objects can only be created or deleted, not modified in an update:
--------------------------------------------------------------------------------

1) Bindings (CBinding)
2) Polling instructions.



Implementation of each one of these operations will proceed as follows:
-----------------------------------------------------------------------
a) the namespace object is locked for update and the thread is marked as 
    updating this namespace
b) The current state of the object in question (__EventFilter, 
    __FilterToConsumerBinding, __Provider, __EventProviderRegistration, 
    __EventConsumerProviderRegistrastion instance, or the class definition) 
    is retrieved. The operation is modified to reflect the current state.
c) All the updatable and deletable objects listed above that may be affected by
    this change are locked for update. Creatable objects are created and locked.
    Notice that this can hang if some of
    these objects are participating in an ongoing update. This will leave the
    entire namespace locked for update until the ongoing one completes --- by 
    design.  Note: the act of locking will AddRef the objects.
d) The namespace object is unlocked.
e) All the objects are instructed to perform the changes
f) Update lock is released.  This has the affect of releasing the objects, so 
    those of them that have been deleted will go away at this time.
g) The thread is "unmarked".

Re-entrancy issues --- two possibilities:
-----------------------------------------
- no reentrancy: any marked thread attempting an update shall fail
- limited reentrancy: any marked thread attempting to lock an object for an
    update shall fail if the object is locked by this thread, or block if the
    object is locked by another thread.

Sequence of update lock acquisitioins:
--------------------------------------

1) Namespace object
2) Filters
3) Consumers
4) 


Category (1): Event Filter creation
-----------------------------------

Affected objects:
    - Provider records whose definition queries intersect with this one.
    Non-exclusive changes:
        - Activate provider, call NewQuery, inform proxies of the change
        Note: the proxy will get exclusive lock while actually updating the 
            tree.  However, this lock will not be held while the proxy is 
            talking to the stub.
    Exclusive changes:
        - update the list of filters.
Created objects:
    - Event Filter
    - Polling instruction 
    - Aggregating instruction

Activating a filter
-------------------

When a filter is activated, the update lock is held on the filter and all the
provider pods whose registration queries intersect with the filter. No exclusive
locks are held. The tasks are: registering with all the provider pods and 
creating the appropriate polling instructions.  Throughout these operations, 
a recording meta-data access point will be used to record the list of class 
names that were accessed. This list will be used to see if re-activation is 
needed when a class definition changes.

Activation and polling selection mechanisms will not be changed in M3, despite
their shortcomings.

Aggregator for this filter is not separately protected.

Exclusive lock on CEventFilter will be held only while the activation state
is changed.

Deactivating a filter
---------------------

Update locks are held on the filter, all the affected provider pods, and the
polling instruction for this filter.

Category (4): Class definition change
-------------------------------------

Note that since separate events are fired by the core for all the children of
the class being changed, it is safe to only update the objects directly affected
by this class.  In particular, a filter is considered affected by a change to 
class A if this class was accessed during construction of the tree for this 
filter. 

Affected objects:
    - non
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\esslock.txt ===
CEssNamespace Locks
===================

There are two namespace locks : level1 and level2.  

Level1 is supposed to be a lightweight lock and guards members like 
the current state of the namespace and members that must be accessed when 
signaling events ( such as the deferred event queue ).  Because of the last 
point, very little should be done while holding this lock.

Level2 is the heavy handed lock and guards all of the changes to the 
provider cache and to the subscription objects ( e.g. binding.h ).  

Level2 must always be aquired before level1 if both are needed.  

Level2 or Level1 can never be held when making calls to the providers.  
This is problematic because level2 is aquired at the top level and the calls 
to the providers occur down deep in the provider cache.  To handle this, all 
calls to providers are scheduled on a Postponed list associatated with the 
threads.  After the level2 is released, then the provider calls can be made
and the postponed operations are executed.  Note that these calls must occur
on the same control path as the one that scheduled them so they cannot be 
asynchronously executed.  

Level2 can never be held when signaling an event.  This is because some 
subscriptions can be synchronous and the action taken on notification could
be to call back into ess ( say to cancel a subscription or something ).  The
other reason is that it is possible to aquire the level2 when holding a 
filter proxy lock and we must avoid the reverse scenario to avoid a deadlock.


ESS Sink Lock
==================

This is a shared lock whose only purpose is to facilitate shutdown of ESS.   
Since all public access to ESS is performed through the esssink, this is 
where the ess shutdown check is.  

Each entry point except shutdown() will ... 

1 ) enter the esssink lock with shared access, 
2 ) check to see if shutdown has been performed, if so then goto (4)
3 ) perform the op
4 ) then release it.

Shutdown will .. 

1 ) aquires the lock for exclusive access
2 ) set shutdown
3 ) release lock

Since the shared lock handles writer starvation, the shutdown op waits for 
all current ops to finish, but does not allow any new ones to procede until
it has executed.    



Filter Proxy Lock
==================

PURPOSE : To synchronize the signaling of an event through the proxy with 
disconnecting the proxy.  When disconneting the proxy from the stub, we want 
to ensure that all calls currently executing through that proxy are complete.
( We could have used CoDisconnectObject on the stub for the same functionality,
 but this would only work when the proxy was in a separate process/apartment 
from the stub which is not always the case ). 

TYPE : This is a CWbemCriticalSection ( but should be a shared lock so that 
the signaling threads requests shared access and the Disconnect() thread was
exclusive access. ) 

RULES :

Must be aquired before Namespace Level2 Lock.  Reason is that the lock MUST 
be held across the signaling of an event, for reasons described above.  Since
we support synchronous delivery, there is nothing stopping a consumer from
turning around and issuing a request that will grab the level2 lock in the 
same namespace.  Because of this, we must always ensure that the proxy lock
is aquired BEFORE acquiring the level2 namespace lock.       



Provider Exec Line 
=========================

PURPOSE : 

This is a different sort of sync mechanism.  Its really a queue more than 
a lock. It allows the user to place requests in a queue and then to execute
them later.  The major difference between this and a normal queue is in the 
way that requests are fetched from the queue and executed.   The exec line 
allows multiple threads to fetch requests from the queue and execute them 
while still preserving the logical ordering of the requests in the queue.  

For example, lets say that there are the following requests placed in the 
queue ... 

A, B, C <-- rear

Lets say that T1 placed A and B in the queue and T2 placed C in the queue.  
Then both threads try to service their requests.  This structure would ensure
that A and B completed before C could execute.  

The reason for such a sync structure is that we do not make calls to a provider
while holding the namespace lock.  So we 'postpone' the requests to the 
provider.  Later, after releasing the namespace lock, we execute the 
'postponed' operations.  This structure ensures that execution of those 
postponed operations occurs in the same logical order as the namespace 
operations.  

e.g. If Namespace Op N1 causes Postponed Operation P1.  And N2 
causes Postponed Operation P2.  Then P1 will be executed before P2 even if
the thread handling N2 tries to execute its postponed operations first.     

This is the following protocol used with this sync mechanism 

1 ) Get In Line - this reserves a place in the line, called a Turn.  A turn
    is associated with a postponed request. The turn is returned from this
    step.

2 ) Wait For Turn - once obtained, the request can be executed.

3 ) End Turn - after the request is executed, the turn is ended thereby 
    allowing the next turn to execute.


Each provider record has an associated exec line.  

RULES : It is illegal to obtain a proxy lock when holding one or more turns 
in any exec line.  The reason is that is possible that when holding the 
proxy lock that we could wait for a turn.  ( Just as it is possible when 
holding a proxy lock to obtain the namespace lock ).   For this reason, if 
we allowed waiting for the proxy lock while holding a turn then we'd have 
a deadlock issue.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\readme.txt ===
Pseudo Provider ReadMe
a-hhance, 06-30-1999


===================
RELEASED COMPONENTS
===================
PseudoProvider.MOF
PseuProx.DLL
PseudoProv.DLL
PseudoSink.DLL


==================
SETUP REQUIREMENTS
==================
Register all three DLLs with RegSvr32
MofComp MOF
dependency: PulsComn.DLL, WinMgmt

===
API
===
See 'Pseudo Provider Programming Guide' somewhere in VSS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\programming guide.txt ===
WMI Pseudo Provider Programming Guide
=====================================

All information contained herein is Copyrighted by Microsoft 
Corporation.  This is preliminary documentation and subject 
to change without notice.  It will be superceded by the
SDK documentation when published.

 Introduction
 ============
The Pseudo Provider has been designed to allow an Event 
Provider to be decoupled from Windows Management.  When an 
Event Provider has been implemented to use the Pseudo 
Provider, Windows Management will not start the Event 
Provider in response to a query for the events provided by 
the Event Provider.  The Event Provider may start, execute, 
provide events, and shut down all without direct interaction 
with Windows Management.  The Event Provider does not even 
need to support any CoCreate-able objects.  
Requirements

In addition to the Windows Management requirements, the 
Pseudo Provider requires that three DLLs be installed and 
registered with RegSvr32.  The DLLs are PseuProx.DLL (proxy); 
PseudoProv.DLL (In Proc to Windows Management); and 
PseudoSink.DLL (In Proc to the provider). 

 Limitations
 ===========
The Pseudo Provider can handle up to 256 different Event 
Providers all providing the same event class in the same 
namespace.  Note that Windows Management is unaware that 
multiple providers are involved, therefor all calls that 
would go to one provider (e.g. AccessCheck()) will go to all 
providers registered for that class in that namespace.

 Programming Interface
 =====================
The Event Provider must provide a MOF that registers its 
event class and provider.   The event class is derived from 
__ExtrinsicEvent.  The provider is declared as an instance of 
Win32PseudoProvider, the Class ID (CLSID) for the provider is 
defaulted by the base class and must not be overridden.   An 
instance of __EventProviderRegistration associates the 
Win32PseudoProvider and Event classes.

The Win32PseudoProvider class has a DACL property that can be 
used to limit who may publish events.  The property is an 
array of bytes which is a representation of an Access Control 
List (ACL.)  A Pseudo Provider must be running under a 
context which has GENERIC_WRITE access allowed by the DACL 
property in order to raise events.  If the DACL property is 
left NULL, then any user is allowed to raise events.

In general, the Event Provider will obtain the 
IWBemDecoupledEventSink interface via CoCreateInstance, then 
call Connect to obtain the sink; call Indicate for each 
instance of the event; and call Disconnect when finished 
providing events.  The Pseudo Provider will forward the 
events on to Windows Management if a query is currently 
active for those events.

The methods for IWbemDecoupledEventSink, in vtable order:

HRESULT Connect(/* [string][in] */ LPCWSTR wszNamespace,     
                /* [string][in] */ LPCWSTR wszProviderName,
                /* [in] */ long lFlags,                    
                /* [out] */ IWbemObjectSink** ppSink,      
                /* [out] */ IWbemServices** ppNamespace);  

        
HRESULT SetProviderServices(/* [in] */ IUnknown* pProviderServices, 
                            /* [in] */ long lFlags);               

        
HRESULT Disconnect(void);

 API Reference
 =============

HRESULT IWbemDecoupledEventSink::Connect(/* [string][in] */ LPCWSTR wszNamespace,      
                                         /* [string][in] */ LPCWSTR wszProviderName, 
                                         /* [in] */ long lFlags,                     
                                         /* [out] */ IWbemObjectSink** ppSink,       
                                         /* [out] */ IWbemServices** ppNamespace);   


Connects the Event Provider to the Pseudo Provider, and the 
Pseudo Provider to Windows Management.  This method must be 
called prior to any other method on this interface.  This 
call should always be paired with a corresponding Disconnect 
call.

Calls can not be nested; multiple calls to Connect without an 
intervening Disconnect call will result in a memory leak in 
your process.

Arguments:
wszNamespace, wszProviderName - identify the namespace 
and the provider as registered in the MOF.  This may be 
in any valid format "root\default", "\\.\root\default", 
or "\\MyComputer\root\default"

lFlags - unused in this release, should be zero to 
ensure compatibility with future releases.

ppSink - pointer to an IWbemObjectSink*, this is the 
sink to which events must be indicated.   The pointer 
returned is AddRef'd: you must call Release() when you 
are finished with it.

ppNamespace - pointer to an IWbemServices*, from this 
interface the Event Provider may obtain the class 
object to spawn instances of the Event Object. The 
pointer returned is AddRef'd: you must call Release 
when you are finished with it.

Returns:
	WBEM_S_NO_ERROR  (0) 		on successful connection
	WBEM_E_FAILED 			    general failure
	WBEM_E_ACCESS_DENIED		if the user's context is 
                                not allowed by the DACL
						        supplied in the 
                                Win32PseudoProvider instance.
	WBEM_E_OUT_OF_MEMORY 		if an allocation fails
	WBEM_E_ALREADY_EXISTS 		upon attempt to connect 
                                the 257th identical provider
	WBEM_E_INVALID_PARAMETER	if unrecognized flags 
                                were passed in,
						        or if the format of the 
                                namespace is incorrect.
	WBEM_E_INVALID_PROVIDER_REGISTRATION
						        If the Win32PseudoProvider 
                                instance is invalid
	CO_E_WRONG_SERVER_IDENTITY 	if application is not 
                                properly registered

	As well as the documented returns from 
    IWbemLocator::ConnectServer


HRESULT IWbemDecoupledEventSink::Disconnect(void);

Call this to disconnect the sink from Windows Management.  
You may then call Connect again should you decide to start 
providing events.  If you neglect to call Disconnect, You 
should call Release() on the Sink retrieved from the Connect 
call at the same time.

Arguments:

Returns:
    WBEM_S_NO_ERROR

HRESULT IWbemDecoupledEventSink::SetProviderServices(
                               /* [in] */ IUnknown* pProviderServices
                               /* [in] */ long lFlags);

This call is optional, you may call it any time after calling 
Connect.  It allows you more communication with Windows 
Management via the IWbemEventProviderQuerySink,  
IWbemEventProviderSecurity, and IWbemEventProvider 
interfaces.   If you support any of those interfaces, use 
SetProviderServices to pass it to Windows Management.  The 
IUnknown you pass in will be AddRef'd and held by the Pseudo 
Provider, it will not be released until you call Disconnect.     

Before this call returns, you will receive calls to NewQuery 
on the IWbemEventProviderQuerySink interface; AccessCheck on 
the IWbemEventProviderSecurity and/or ProvideEvents on the 
IWbemEventProvider interface if there are any consumers 
currently interested in your events. 

The Pseudo Provider supports a specialized version of the 
IWbemEventProvider interface.  If you expose this interface, 
the ProvideEvents method will be called with one of two 
flags: WBEM_FLAG_START_PROVIDING when WinMgmt receives a 
request for any event supplied by your provider; and 
WBEM_FLAG_STOP_PROVIDING when the last query is cancelled.   
You may use these notifications to optimize your application 
by controlling the generation of events.  

Arguments:
pProviderServices an IUnknown that should be QI-able 
for any or all of IWbemEventProviderQuerySink, 
IWbemEventProviderSecurity, and IWbemEventProvider.

lFlags controls the calls to the interfaces.  May be a 
combination of:
                WBEM_FLAG_NOTIFY_START_STOP		
                To receive ProvideEvents notifications

                WBEM_FLAG_NOTIFY_QUERY_CHANGE
	            To receive NewQuery notifications

                WBEM_FLAG_CHECK_SECURITY
	            To receive AccessCheck inquiries

Returns:
	WBEM_S_NO_ERROR  (0) 		on successful connection
	WBEM_E_FAILED 			    general failure
	WBEM_E_OUT_OF_MEMORY 		if an allocation fails
	WBEM_E_INVALID_PARAMETER	if unrecognized flags 
                                were passed in
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\noncom\testapps\noncomtest\documentation\noncomeventtest.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Nadir Ahmed Microsoft NonCOM Event test application Title _PID_HLINKS Version Distribution Component Feature Product Product Version Project Status Internal Unassigned Unassigned Unassigned Unassigned DraftNonCOM Event test application Marius Sutara WBEM Specification.dot Marius Sutara Microsoft Word 9.0C1IDATx^ Su:+3o sePjCr9F k'Z]F|x [y*R* mhnl6 xTmI-Z W|m{LC ~`GTU & lM0 mhnI;TO_5/P. B)l-e /#z7bq3F L) lM ?A~['< rvv6E rNNNjU4+M[B zp9?? Ql]&f L' lMg w5mCh~ pHlJm }.QoK rbSZS lBCCh8?? L, lM NB3z> zZ5]vLC u<6quw @ueI%t 5MV}Y D+fGQ U ,+a 5iKJ9 '<kQ& _+|@3j _xqAsQS }1=gk ' l-n . le'V . le'V . le'V . le'V . le'V . le'V . le'V . le'V }ak/=; @x?Zz [GaW) e(dke: ?ak5C [aKL`+KW uIDATx^ {FWRw Z-]<| ?sOs} 5U^4c O86zl`_ w-=&:S"5 qW)<P% h5@<U "P]zj9 Q)q{g^ ?~@`L u1fIo/K<u ]Jh)a #Vzh$ 3k3W_ -bGzJ Y<%*H SzmQ8 VObU4 8HOau [+".6 =OzX] .~f3W &`.Y*) pEdFGLh X'L)L r4Y!, #Q@`0 @z8C  |IDATx^ kkk3}a R{_ ~ #{_|x "7a,;{  e 0% E\rb{ m :sy i.h4Z }1o,U 8 });?x _y\i#f K'gF,<D_ #rGd+ *F&L@Q_L Y[#JOg bT&<PN# '=WJH &L@Q_ /nz27i f+X'7! H'PnF _DaRF c#1BZ *Eg(C J`e}} [_IDATx^ uwipY8==z mO/&~ _m^|\O dkn+> Z=;[] ;6"#@ ltcU# <>{F* CiMMFR @#{fCiYM 2b}@J +;[7; HyVo=] Mln]. :7<7. USUM* ER?Lq :dQCD T#YTMU V+#%N Uoj:D >[{%[C Rc<7N fftvQ< ehoyF lJt)N h}=j  F|l3=+j B=i"x l-@{v lk50HB$@ Jt-f5 "czA-\v wy4F% }vRs. |3C%P V3C%P V3C%P V3C%P V3C%P V3C%P V3C%P V3C%P CvvydE +}qk4l H8%=1 QSgMx /%C/+;5 T>YOVI \F dZ S5}Y\y Lf*+3 kd%{A FY&[izs _bT3R 7"p+;[72 <:b#@ Z_gYCz 39c/34MH^ "Q?-/ 8T0YB b^`>h YsnWIe+ ;5}lh. {7UjT&a h~gkM X#`gk (`gkG\U jg+lA gg+<' V>+?( bmi/z gg+.rq PxdDB +koTe F{'LD Ubd\2 ,.S>+ ?n/&s Kx{'s __gYCz B[e0! O)'Fo <AV:8 8Un]l I%eGF w%x4, v(}OGd+ rffc4 lm2F*!@ ?F"$@ wMG79 ^Wed1 3IDATx^ ?wVF;r [/<./ *.VP; uKyAI ?)R(S 6s8kOn 16}B * $g;/}C| c!0J` *xtKh :+{tv URkZl $db=b5 wks#F o_Qa% IDATx^ 6!pqqq jhoD! ZAbgp |pk^w P4W"% %PSykA h%s&/ =\qTLA` {!`>P k*j'z -aaMy DWw>$F n?k-j eN.s~  pqqQ_y Xot,C +7UJ? [>3z@  PAya =(CU5 JwF?;Microsoft Word Picture MSWordDoc Word.Picture.8Microsoft Corp. TitleMarius Sutara Normal.dot Marius Sutara Microsoft Word 9.0_[Ef_[EbjbjU C1IDATx^ Su:+3o sePjCr9F k'Z]F|x [y*R* mhnl6 xTmI-Z W|m{LC ~`GTU & lM0 mhnI;TO_5/P. B)l-e /#z7bq3F L) lM ?A~['< rvv6E rNNNjU4+M[B zp9?? Ql]&f L' lMg w5mCh~ pHlJm }.QoK rbSZS lBCCh8?? L, lM NB3z> zZ5]vLC u<6quw @ueI%t 5MV}Y D+fGQ U ,+a 5iKJ9 '<kQ& _+|@3j _xqAsQS }1=gk ' l-n . le'V . le'V . le'V . le'V . le'V . le'V . le'V . le'V }ak/=; @x?Zz [GaW) e(dke: ?ak5C [aKL`+KWbjbjU Spec Title NonCOM Event Test application 4Version  DOCPROPERTY "Version"  \* MERGEFORMAT  Distribution  FORMDROPDOWN  Component  DOCPROPERTY "Component"  \* MERGEFORMAT  Unassigned Feature area  DOCPROPERTY "Feature"  \* MERGEFORMAT  Unassigned Feature scope Unassigned  FORMDROPDOWN  Product  DOCPROPERTY "Product"  \* MERGEFORMAT  Product Version Project  DOCPROPERTY "Project"  \* MERGEFORMAT  Unassigned Author  AUTHOR  \* MERGEFORMAT  Marius Sutara  HYPERLINK "mailto:a-marius@microsoft.com"  a-marius@microsoft.com Manager  DOCPROPERTY "Manager"  \* MERGEFORMAT  Nadir Ahmed HYPERLINK "mailto:nadira@microsoft.com" nadira@microsoft.com Status  FORMDROPDOWN  Last Changed  TIME \@ "M/d/yyyy"  5/12/2000 Revision Summary Version Author Changes  DATE  \* MERGEFORMAT  5/12/2000 Sutara Marius  Initial draft  TOC \o "1-3" \h \z   HYPERLINK \l "_Toc482780095"  Common Information  PAGEREF _Toc482780095 \h   HYPERLINK \l "_Toc482780096"  Overview  PAGEREF _Toc482780096 \h   HYPERLINK \l "_Toc482780097"  Goals & Objectives  PAGEREF _Toc482780097 \h   HYPERLINK \l "_Toc482780098"  Executive Summary  PAGEREF _Toc482780098 \h   HYPERLINK \l "_Toc482780099"  Scope of operating system support  PAGEREF _Toc482780099 \h   HYPERLINK \l "_Toc482780100"  Pre Requirement  PAGEREF _Toc482780100 \h   HYPERLINK \l "_Toc482780101"  Self instrumentation  PAGEREF _Toc482780101 \h   HYPERLINK \l "_Toc482780102"  NonCOM Event commonly  PAGEREF _Toc482780102 \h   HYPERLINK \l "_Toc482780103"  Implementation stuff  PAGEREF _Toc482780103 \h   HYPERLINK \l "_Toc482780104"  Design  PAGEREF _Toc482780104 \h   HYPERLINK \l "_Toc482780105"  Test modules  PAGEREF _Toc482780105 \h   HYPERLINK \l "_Toc482780106"  6.2.1 Valid arguments  PAGEREF _Toc482780106 \h   HYPERLINK \l "_Toc482780107"  6.2.2 Module for scalar testing  PAGEREF _Toc482780107 \h   HYPERLINK \l "_Toc482780108"  6.2.3 Module for array testing  PAGEREF _Toc482780108 \h   HYPERLINK \l "_Toc482780109"  6.2.4 Module for generic event testing  PAGEREF _Toc482780109 \h   HYPERLINK \l "_Toc482780110"  Common gui application  PAGEREF _Toc482780110 \h   HYPERLINK \l "_Toc482780111"  What should be done later.  PAGEREF _Toc482780111 \h   HYPERLINK \l "_Toc482780112"  Error description  PAGEREF _Toc482780112 \h   HYPERLINK \l "_Toc482780113"  How to run binaries and necessary registration  PAGEREF _Toc482780113 \h   HYPERLINK \l "_Toc482780114"  References  PAGEREF _Toc482780114 \h  Common Information Overview The focus of this document is to describe the functional definition of the NonCOM Event test application. This application enables to test functionality of NonCOM Event provider thru API s it exposes. Goals & Objectives The goal of this document is to describe the set of features that are exposed from the test application. Further it describes the procedure of implementation of those features, and set of arguments it supports to test too. Executive Summary The test creates independent GUI application running binary with proper argument. This could server like common test tool for each NonCOM event provider properly compiled into system. The application is able to cooperate with existing framework. It exposes couple of out-of-proc COM objects for that reason. It serves similar like stress modules in framework. The resultant component will allow developers to test theirs NonCOM event providers before real use of them. (I mean GUI part of test tool.) It also could test functionality of WMI part of NonCOM event provider schema described below. Scope of operating system support The adapter will work on all operating systems where WMI Whistler is correctly installed and running. The application will not need to identify the platform when performing an internal processing. Pre Requirement  The operation of the test is dependant on the WMI service being actually run on the platform. This will mean that the WMI service is currently installed and running. There is also requirement of WMI part of NonCOM event provider is properly installed too. This requirement belongs to ability to connect into WMI and WMI part of NonCOM event provider. Rest prequirements belongs to NonCOM Event specification. See   HYPERLINK  \l "ref1"  reference [1]  for more information. Self instrumentation The operation of the test will require user configuration. This requirement consists of setting arguments for framework testing (described below). NonCOM Event commonly Exact information about NonCOM Event provider and its using should be found in   HYPERLINK  \l "ref1"  reference [1] . Here is just short description of NonCOM Event model and specification of basic use of this technology. It consists of two main parts, part exposing Windows API functions and WMI provider, which working is based on technology of WMI event provider. Those parts are connected using named pipe, which serves like transport layer for firing events. Developer who would like to implement WMI NonCOM Event provider then implements his own application using exported API s functions and is able to fire events only when WMI event consumer is waiting for them. NonCOM Event application has a couple of possibilities how to work. First of all it has to open connection, which creates named pipe between NonCOMObjAPI.dll and WMI provider for sending data. There exists couple of ways of creating connection. There is also lot of ways how to create Event object itself, like WmiCreateObject, WmiCreateObjectWithFormat and WmiCreateObjectWithProps. Everything is specified and described in   HYPERLINK  \l "ref1"  reference [1] . Event object then  fires  event, it is transported across named pipe until event consumer will catch it. Implementation stuff Design The test will consist of two main modules. First one, implements GUI application for common testing of each NonCOM Event provider and events it implements. The second is set of modules for existing test framework, so it is designed to be out-of-process COM server, and it serves for main testing. For close information take a look at   HYPERLINK  \l "ref2"  reference [2] Test modules  There is a couple ways how to interact with NonCOM event provider as described above. Those test modules have to be designed and implemented to test as much as possible combination of creation and firing events at least. NonCOM Event provider supports some set of data types so those data has to be tested at all. To do this easily I have designed my NonCOM event provider, which has to be compiled into CIMOM before real testing is going to be done. #pragma namespace ("\\\\.\\root\\cimv2") ////////////////////////////////////////////////////////////////////////////// // Events with all possible data types. class MSFT_NonCOMTest_SINT8_Event : __ExtrinsicEvent sint8 Sint8_Prop; class MSFT_NonCOMTest_UINT8_Event : __ExtrinsicEvent uint8 Uint8_Prop; class MSFT_NonCOMTest_SINT16_Event : __ExtrinsicEvent sint16 Sint16_Prop; class MSFT_NonCOMTest_UINT16_Event : __ExtrinsicEvent uint16 Uint16_Prop; class MSFT_NonCOMTest_SINT32_Event : __ExtrinsicEvent sint32 Sint32_Prop; class MSFT_NonCOMTest_UINT32_Event : __ExtrinsicEvent uint32 Uint32_Prop; class MSFT_NonCOMTest_SINT64_Event : __ExtrinsicEvent sint64 Sint64_Prop; class MSFT_NonCOMTest_UINT64_Event : __ExtrinsicEvent uint64 Uint64_Prop; class MSFT_NonCOMTest_REAL32_Event : __ExtrinsicEvent real32 Real32_Prop; class MSFT_NonCOMTest_REAL64_Event : __ExtrinsicEvent real64 Real64_Prop; class MSFT_NonCOMTest_BOOLEAN_Event : __ExtrinsicEvent boolean Boolean_Prop; class MSFT_NonCOMTest_STRING_Event : __ExtrinsicEvent string String_Prop; class MSFT_NonCOMTest_CHAR16_Event : __ExtrinsicEvent char16 Char16_Prop; class MSFT_NonCOMTest_DATETIME_Event : __ExtrinsicEvent datetime Datetime_Prop; class MSFT_NonCOMTest_REFERENCE_Event : __ExtrinsicEvent object ref Reference_Prop; class MSFT_NonCOMTest_OBJECT_Event : __ExtrinsicEvent object Object_Prop; class MSFT_NonCOMTest_SINT8_ARRAY_Event : __ExtrinsicEvent sint8 Sint8_ARRAY_Prop[]; class MSFT_NonCOMTest_UINT8_ARRAY_Event : __ExtrinsicEvent uint8 Uint8_ARRAY_Prop[]; class MSFT_NonCOMTest_SINT16_ARRAY_Event : __ExtrinsicEvent sint16 Sint16_ARRAY_Prop[]; class MSFT_NonCOMTest_UINT16_ARRAY_Event : __ExtrinsicEvent uint16 Uint16_ARRAY_Prop[]; class MSFT_NonCOMTest_SINT32_ARRAY_Event : __ExtrinsicEvent sint32 Sint32_ARRAY_Prop[]; class MSFT_NonCOMTest_UINT32_ARRAY_Event : __ExtrinsicEvent uint32 Uint32_ARRAY_Prop[]; class MSFT_NonCOMTest_SINT64_ARRAY_Event : __ExtrinsicEvent sint64 Sint64_ARRAY_Prop[]; class MSFT_NonCOMTest_UINT64_ARRAY_Event : __ExtrinsicEvent uint64 Uint64_ARRAY_Prop[]; class MSFT_NonCOMTest_REAL32_ARRAY_Event : __ExtrinsicEvent real32 Real32_ARRAY_Prop[]; class MSFT_NonCOMTest_REAL64_ARRAY_Event : __ExtrinsicEvent real64 Real64_ARRAY_Prop[]; class MSFT_NonCOMTest_BOOLEAN_ARRAY_Event : __ExtrinsicEvent boolean Boolean_ARRAY_Prop[]; class MSFT_NonCOMTest_STRING_ARRAY_Event : __ExtrinsicEvent string String_ARRAY_Prop[]; class MSFT_NonCOMTest_CHAR16_ARRAY_Event : __ExtrinsicEvent char16 Char16_ARRAY_Prop[]; class MSFT_NonCOMTest_DATETIME_ARRAY_Event : __ExtrinsicEvent datetime Datetime_ARRAY_Prop[]; class MSFT_NonCOMTest_REFERENCE_ARRAY_Event : __ExtrinsicEvent object ref Reference_ARRAY_Prop[]; class MSFT_NonCOMTest_OBJECT_ARRAY_Event : __ExtrinsicEvent object Object_ARRAY_Prop[]; class MSFT_NonCOMTest_SCALAR_Event : __ExtrinsicEvent sint8 Sint8_Prop; uint8 Uint8_Prop; sint16 Sint16_Prop; uint16 Uint16_Prop; sint32 Sint32_Prop; uint32 Uint32_Prop; sint64 Sint64_Prop; uint64 Uint64_Prop; real32 Real32_Prop; real64 Real64_Prop; boolean Boolean_Prop; string String_Prop; char16 Char16_Prop; datetime Datetime_Prop; object ref Reference_Prop; object Object_Prop; class MSFT_NonCOMTest_ARRAY_Event : __ExtrinsicEvent sint8 Sint8_ARRAY_Prop[]; uint8 Uint8_ARRAY_Prop[]; sint16 Sint16_ARRAY_Prop[]; uint16 Uint16_ARRAY_Prop[]; sint32 Sint32_ARRAY_Prop[]; uint32 Uint32_ARRAY_Prop[]; sint64 Sint64_ARRAY_Prop[]; uint64 Uint64_ARRAY_Prop[]; real32 Real32_ARRAY_Prop[]; real64 Real64_ARRAY_Prop[]; boolean Boolean_ARRAY_Prop[]; string String_ARRAY_Prop[]; char16 Char16_ARRAY_Prop[]; datetime Datetime_ARRAY_Prop[]; object ref Reference_ARRAY_Prop[]; object Object_ARRAY_Prop[]; ////////////////////////////////////////////////////////////////////////////// // Non-COM event provider registration.  Use the value of Name when connecting  // to the API via WmiEventSourceConnect. instance of MSFT_WMI_NonCOMEventProvider as $P1 Name = "NonCOMTest Event Provider"; instance of __EventProviderRegistration Provider = $P1; EventQueryList =  "select * from MSFT_NonCOMTest_SINT8_Event", "select * from MSFT_NonCOMTest_UINT8_Event", "select * from MSFT_NonCOMTest_SINT16_Event", "select * from MSFT_NonCOMTest_UINT16_Event", "select * from MSFT_NonCOMTest_SINT32_Event", "select * from MSFT_NonCOMTest_UINT32_Event", "select * from MSFT_NonCOMTest_SINT64_Event", "select * from MSFT_NonCOMTest_UINT64_Event", "select * from MSFT_NonCOMTest_REAL32_Event", "select * from MSFT_NonCOMTest_REAL64_Event", "select * from MSFT_NonCOMTest_BOOLEAN_Event", "select * from MSFT_NonCOMTest_STRING_Event", "select * from MSFT_NonCOMTest_CHAR16_Event", "select * from MSFT_NonCOMTest_DATETIME_Event", "select * from MSFT_NonCOMTest_REFERENCE_Event", "select * from MSFT_NonCOMTest_OBJECT_Event", "select * from MSFT_NonCOMTest_SINT8_ARRAY_Event", "select * from MSFT_NonCOMTest_UINT8_ARRAY_Event", "select * from MSFT_NonCOMTest_SINT16_ARRAY_Event", "select * from MSFT_NonCOMTest_UINT16_ARRAY_Event", "select * from MSFT_NonCOMTest_SINT32_ARRAY_Event", "select * from MSFT_NonCOMTest_UINT32_ARRAY_Event", "select * from MSFT_NonCOMTest_SINT64_ARRAY_Event", "select * from MSFT_NonCOMTest_UINT64_ARRAY_Event", "select * from MSFT_NonCOMTest_REAL32_ARRAY_Event", "select * from MSFT_NonCOMTest_REAL64_ARRAY_Event", "select * from MSFT_NonCOMTest_BOOLEAN_ARRAY_Event", "select * from MSFT_NonCOMTest_STRING_ARRAY_Event", "select * from MSFT_NonCOMTest_CHAR16_ARRAY_Event", "select * from MSFT_NonCOMTest_DATETIME_ARRAY_Event", "select * from MSFT_NonCOMTest_REFERENCE_ARRAY_Event", "select * from MSFT_NonCOMTest_OBJECT_ARRAY_Event", "select * from MSFT_NonCOMTest_SCALAR_Event", "select * from MSFT_NonCOMTest_ARRAY_Event", "select * from MSFT_WMI_GenericNonCOMEvent" As you can see each data type supported by WMI NonCOM Event provider has it s own event specified here. There also event having every scalar data types exists as well as event having each data type like an array. As described previously ways of creation and firing of events are different so three test modules exist. Valid arguments As was described above there could be those ways to create event object and fire event: WmiCreateObject WmiCreateObjectWithFormat WmiCreateObjectWithProps WmiCommitObject WmiSetAndCommitObject WmiReportEvent s forgive about WmiReportEvent for now. We can see combination like: WmiCreateObject + WmiCommitObject WmiCreateObject + WmiSetAndCommitObject WmiCreateObjectWithFormat + WmiCommitObject WmiCreateObjectWithFormat + WmiSetAndCommitObject WmiCreateObjectWithProps + WmiCommitObject WmiCreateObjectWithProps + WmiSetAndCommitObject From that we can easily associate numbers like 1-6 to those combinations. There are also 16 data types supported by WMI NonCOM Event provider (see mof file above). Valid arguments for modules then could look like /11 /110 /216, where the first sign following slash is number of combination, and the rest is number of data type tested. For example: combination 1 WmiCreateObject + WmiCommitObject data type 1 data type CIM_SINT8 combination 4 WmiCreateObjectWithFormat + WmiSetAndCommitObject data type 16 data type CIM_OBJECT Module for scalar testing Modules.ini description of test part: CompTitle=NonCOMEvent SCALARDATA CLSID={C8817A18-0425-40c9-A393-D09413F608D2} EXE=NonCOMEvent.exe Params= LoggingLevel=8 Author=Marius Sutara (a-marius) Description=Non COM Event Test for scalar event object UILogLevel=2 LSLogLevel=2 Closer information about fields should be found in   HYPERLINK  \l "ref2"  reference [2] . This module shows name  NonCOMEvent SCALARDATA  in the framework window. When chosen and no parameters specified into PARAMS field no action is done. Valid arguments (translation of argument described above) for PARAMS filed are: /11/12/13/14/15/16/17/18/19/110/111/112/113/114/115/116 /21/22/23/24/25/26/27/28/29/210/211/212/213/214/215/216 /31/32/33/34/35/36/37/38/39/310/311/312/313/314/315/316 /41/42/43/44/45/46/47/48/49/410/411/412/413/414/415/416 /51/52/53/54/55/56/57/58/59/510/511/512/513/514/515/516 /61/62/63/64/65/66/67/68/69/610/611/612/613/614/615/616 /1 /2 /3 /4 /5 /6 have special meaning. They are associated with combinations of creation and fire as expected and described above, but no number following means they are used against global event containing all scalar data types (MSFT_NonCOMTest_SCALAR_Event). Module for array testing Modules.ini description of test part: CompTitle= NonCOMEvent ARRAYDATA CLSID={5B147A8F-29B7-4a09-A9E4-020BB9DFB035} EXE=NonCOMEvent.exe Params= LoggingLevel=8 Author=Marius Sutara (a-marius) Description= Non COM Event Test for array event object UILogLevel=2 LSLogLevel=2 Closer information about fields should be found in   HYPERLINK  \l "ref2"  reference [2] . This module shows name  NonCOMEvent ARRAYDATA  in the framework window. When chosen and no parameters specified into PARAMS field no action is done. Valid arguments (translation of argument described above) for PARAMS filed are: /11/12/13/14/15/16/17/18/19/110/111/112/113/114/115/116 /21/22/23/24/25/26/27/28/29/210/211/212/213/214/215/216 /31/32/33/34/35/36/37/38/39/310/311/312/313/314/315/316 /41/42/43/44/45/46/47/48/49/410/411/412/413/414/415/416 /51/52/53/54/55/56/57/58/59/510/511/512/513/514/515/516 /61/62/63/64/65/66/67/68/69/610/611/612/613/614/615/616 /1 /2 /3 /4 /5 /6 have special meaning. They are associated with combinations of creation and fire as expected and described above, but no number following means they are used against global event containing all arrays of supported data types (MSFT_NonCOMTest_ARRAY_Event). Module for generic event testing Modules.ini description of test part: CompTitle= NonCOMEvent GenericEVENT CLSID= {14B9287A-1E99-466f-995F-5870E8D9E996} EXE=NonCOMEvent.exe Params= LoggingLevel=8 Author=Marius Sutara (a-marius) Description= Non COM Event Test for generic event object UILogLevel=2 LSLogLevel=2 Closer information about fields should be found in   HYPERLINK  \l "ref2"  reference [2] . This module shows name  NonCOMEvent Generic DATA  in the framework window. It serves as testing module for special case of NonCOM event provider. When chosen and no parameters specified into PARAMS field no action is done. Valid arguments (translation of argument described above) for PARAMS filed are: /1/2/3 and they have special meaning. They are not associated with combinations of creation and fire as expected, but with previously forgotten WmiReportEvent function. The first one is reporting each scalar data types at once to generic event, the second one serves for arrays of data and the third works like stress module for repetition of both actions until stopped. They are used against global event containing all types of supported data types (MSFT_WMI_GenericNonCOMEvent). Common gui application GUI application is implemented like dialog application using ATL. The Application has the main dialog, that enables connect into each NonCOM Event provider properly registered in WMI CIMOM. After clicking connect button connect dialog, that serves for setting up each connect properties is displayed.  EMBED Word.Picture.8   As noted above, dialog is able to setup each combination of connect properties we can expect. It instead of choosing name enables find out every provider registered in WMI. Here is sample of each NonCOM Event provider registered on the computer under the namespace  root\cimv2 . It was obtained by clicking   button right of the provider edit box. Selecting and pushing button OK confirmed new choice of course. Right know we have application running, there is each event supported by selected provider displayed in the left combo box. Clicking the set of Create buttons you ll choose which API is going to be used for creation of event object. The button Copy select serves for easy copying of select necessary to run your WMI event consumer. There is button set property enabled after clicking one of the Create button. Property dialog appears after pushing that. Two sets of properties actually exists in the event class. The one containing array flag and the one without it. Tester has to use   delimiter filling more than one item into array. This disables using of | character in string arrays, application takes it like another item. It is by design. Check box serves for setting value each change of index when enabled, otherwise button OK has to be used. After finishing setting of properties, button OK has to be pushed, it enables commit button in the main dialog. Only one property should be set at least, others are automatic set to be NULL after pushing Commit button of the main dialog. I recommend using of WMI test for event consumer. It could be found in scratch of WMI. It displays events really simply and nicely. What should be done later. Connection Using of WmiCreateRestricted Connection is not tested yet. It expects EventQuery list. Provider then activates only connections to consumer specified. Creation of Event Object Couple of ways, how to create event object, are not tested yet. WmiCreateObjectFromBuffer, WmiDuplicateObject belongs to them. The one WmiCreateObjectSubset for testing of subset of properties is not tested too. Blob means way of decoding data already sent across named pipe. This technology requires write down in-proc-com object for handling data and create appropriate data structure. Anyway sending data works fine without using of blob decoder too. Security Setting up of security is not tested at all yet. It means WmiSetConnectionSecurity and WmiSetObjectSecurity are not used. Error description NonCOM Event provider usually returns TRUE, FALSE values only. It is hard to find out what causes failure, so only common information about return value is displayed back to framework. More information about error states should be found in specification of WMI NonCOM Event Provider where all states causing failure are described.   HYPERLINK  \l "ref1"  Reference [1] How to run binaries and necessary registration NonCOMEvent.exe When run as is serves like out-of- proc COM server for test framework. It should be run only with switch for registration purposes.  SWITCH: RegServer/UnregServer is for registration of out-of-proc server. NonCOMEvent.exe /GUI Runs common GUI application test tool for testing each NonCOM Event provider registered properly into system. Useful for looking out if NonCOM Event provider works before some stress testing. References NonCOM Event Provider Specification Test Framework Specification Non COM Event test Page   PAGE  Microsoft CONfidental  PAGE   NUMPAGES   DATE \@ "M/d/yyyy"  5/12/2000 Created by   AUTHOR  Marius Sutara WMI Event Consumer Firing WMI events. NonCOM Event Application Using named pipe for communication. WMI Event provider NonCOMObjAPI.dll Exposes API s functions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\scrcons\readme.txt ===
Scripting Consumer ReadMe
a-hhance, 06-30-1999


===================
RELEASED COMPONENTS
===================
ScrCons.MOF
ScrCons.EXE


==================
SETUP REQUIREMENTS
==================
Register executable with /REGSERVER
MofComp MOF
dependency: PulsComn.DLL, WinMgmt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\smtpcons\readme.txt ===
SMTP Consumer ReadMe
a-hhance, 06-30-1999


===================
RELEASED COMPONENTS
===================
SMTPCons.MOF
SMTPCons.DLL


==================
SETUP REQUIREMENTS
==================
Register DLL with RegSvr32
MofComp MOF
dependency: PulsComn.DLL, WinMgmt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\stdcons\wbemcons\readme.txt ===
Standard Consumers ReadMe
a-hhance, 06-30-1999


===================
RELEASED COMPONENTS
===================
WbemCons.DLL
WbemCons.MOF


==================
SETUP REQUIREMENTS
==================
Register DLL with RegSvr32
MofComp MOF
dependency: PulsComn.DLL, WinMgmt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\wqlquery.txt ===
select * from __InstanceModificationEvent 
where TargetInstance isa "Win32_CurrentTime" 
and TargetInstance.Year=1999 
and TargetInstance.Month=10 
and TargetInstance.Day=14
and TargetInstance.Hour=15 
and TargetInstance.Minute=30 
and TargetInstance.Second=0
and TargetInstance.Interval=1
and TargetInstance.UTCOffset=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\timeprov\wqlquerysupport.txt ===
Given the state of the Win32_CurrentEvent class:

  class Win32_CurrentTime
  {
    uint32 Year;
    uint32 Month;
    uint32 Day;
    uint32 DayOfWeek;
    uint32 WeekInMonth;
    uint32 Quarter;
    uint32 Hour;
    uint32 Minute;
    uint32 Second;
    [key] sint32 UTCOffset;
  };

Currently we can form queries for a specific point in time 
in the future.  The basic form of a query is:

  select * from __InstanceModificationEvent 
    where TargetInstance isa "Win32_CurrentTime" 
    and TargetInstance.Year=1999 
    and TargetInstance.Month=10 
    and TargetInstance.Day=4 
    and TargetInstance.Hour=11 
    and TargetInstance.Minute=0 
    and TargetInstance.Second=0

This query specifies a single point in time, irrespective
of the time at which it is to be evaluated, at which an
event should be generated.  If the time specified is in
the past at the time it is evaluated, then no event will
occur.

In order to be a valid, a query must have each of the following 
properties:

1. A query must be specific enough to define the complete set
   of all times for which an event is to be generated.

2. Each time the expression is evaluated, it must be possible 
   to specify unambiguously the closest point after the current 
   time when the next event will occur.  

   f(<WQL expression>, <current time>) -> <next event time>

3. The frequency of events must not be such that it may overwhelm
   the system under a normal load.

The following, I believe, are the four most likely scenarios
for which a user will ask for time events:

1. They want timer events to be generated indefinitely at
   a specified periodic interval.

2. They want a single event to be generated at some specified
   time in the future. (alarm functionality)

3. They want a single event to be generated at some time
   in the future relative to the time at which the query is
   made.  (timer functionality)

4. They want one or more events to be generated based on some
   algebraic criteria.

A single query may embody one or more of the above scenarios.

An example of the first scenario could be the following:

  select * from __InstanceModificationEvent
    where TargetInstance isa "Win32_CurrentTime"
    and TargetInstance.Year=1999
    and TargetInstance.Month=10
    and TargetInstance.Day=4
    and TargetInstance.Hour=11
    and TargetInstance.Second % 30 = 0

This specifies that we want an event every thirty seconds
on the minute and half minute boundaries for the eleventh
hour on the date 10/4/99.  With the current approach we 
cannot completely capture the functionality of the first
scenario.  For example, we could not specify a timer to
generate an event exactly seven seconds apart.  If, however,
we add a field to Win32_CurrentTime that is the equivalent
file time (64 bit number) rounded to seconds that represents
the same time as the system time fields, it then becomes 
possible:

  select * from __InstanceModificationEvent
    where TargetInstance isa "Win32_CurrentTime"
    and TargetInstance.Year=1999
    and TargetInstance.Month=10
    and TargetInstance.Day=4
    and TargetInstance.Hour=11
    and TargetInstance.TimeInSeconds % 30 = 0

This is equivalent to the above statement but uses the total
time in seconds instead of just seconds.  By changing '30' to
'7' we get an event every seven seconds.  Note that by omitting 
a field we are signifying that it is a wildcard.

For this type of query we will introduce a reserved symbol that
evaluates to the current time when the expression is evaluated.
There is a reserved symbol for each field in Win32_CurrentTime.
Thus, to say "generate an event 45 seconds from now" we could
write:

  select * from __InstanceModificationEvent
    where TargetInstance isa "Win32_CurrentTime"
    and TargetInstance.TimeInSeconds = %CurrentTimeInSeconds% + 45

Fundamentally, WQL statements are patterns, not program 
expressions that can save state as part of their evaluation. It 
is valid to have algebraic expressions within WQL as long as they 
ultimately evaluate to a constant and there is no concept of 
assignment.  The symbol %CurrentTimeInSeconds% is actually a 
macro that is replaced by the parser with the current time in 
seconds when it is encountered.  Thus, the above statement will
only generate one event and not an event every 45 seconds.

Each of the examples above are by definition examples of time
specification based on algebraic criteria.  Here is an example
that does not fall into any of the first three categories:

  select * from __InstanceModificationEvent
    where TargetInstance isa "Win32_CurrentTime"
    and TargetInstance.Year=1999
    and TargetInstance.Month=10
    and TargetInstance.Day=10
    and TargetInstance.Hour <= 12
    and TargetInstance.Minute = TargetInstance.Day

This says to generate an event once an hour for the first half
of the day when the minute in the current hour is equal to the
day of the month.  This is only to occur on the date 10/10/99.

The following is an excerpt from the WQL1 grammar that has
been modified to allow support for queries containing simple
algebraic expressions:

<parse> ::= SELECT * FROM <class_name> WHERE <expr>;

<property_name> ::= IDENTIFIER <property_name_2>;
<property_name_2> ::= <>;
<property_name_2> ::= DOT IDENTIFIER <property_name_2>;

<class_name> ::= IDENTIFIER;

<expr> ::= <term> <expr2>;
<expr2> ::= OR <term> <expr2>;
<expr2> ::= <>;

<term> ::= <simple_expr> <term2>;
<term2> ::= AND <simple_expr> <term2>;
<term2> ::= <>;

<operand> ::= <property_name>
<operand> ::= <typed_constant>

<simple_expr> ::= <algebraic_expr> <rel_operator> <algebraic_expr>;

<algebraic_expr> ::= <operand>
<algebraic_expr> ::= <algebraic_expr> <arithmetic_operator> <algebraic_expr>
<algebraic_expr> ::= OPEN_PAREN <algebraic_expr> CLOSE_PAREN;

<typed_constant> ::= VARIANT; // VT_R8, VT_I4, VT_BSTR
<typed_constant> ::= TRUE; 
<typed_constant> ::= FALSE; 
<typed_constant> ::= <macro_constant>; 

<macro_constant> ::= PERCENT IDENTIFIER PERCENT ;

<rel_operator> ::= <equiv_operator>;
<rel_operator> ::= <comp_operator>;

<equiv_operator> ::= EQUIVALENT_OPERATOR; // =, !=, <>
<comp_operator> ::=  COMPARE_OPERATOR;  // <=, >=, <, >, like, isa
<arithmetic_operator> ::= ARITHMETIC_OPERATOR; // +, -, *, /, %


**** INSERT SECTION ON HOW TO DECOMPOSE A WQL STATEMENT TO A
     SERIES OF TIME PATTERNS TO MATCH AGAINST (DNF)

Solution to the Problem of Finding a Closest Date in the Future 
to Current Time:

First, let's impose a few key constraints that do not detract from 
the fundamental problem but allow us to more clearly illustrate the
solution.  

1. Limit the problem to finding the next date within the current year.
   This is reasonable because if a suitable date cannot be found 
   within the remainder of the current year, find the first matching
   date from midnight January 1st of next year.

2. Limit ourselves to those fields of date that do not have overlaping
   meaning and exactly contain each other.  For our Win32_CurrentTime
   structure those fields are: Year, Month, Day, Hour, Minute, Second.
   Week and any representation dependent on week violates this 
   criteria because years and months do not, in general, start and
   stop on week boundaries.  This means that weeks are not countable
   w.r.t. any larger unit of time.  

Given these constraints, it becomes possible to perform addition with
carry on a given date with intervals expressed in any of the above 
units quickly.

Now, our problem is one of finding the first date beyond the current
time that matches a specific pattern provided by a WQL query.  Because 
of the 2nd constraint, we can find a matching time incrementally by 
working our way from seconds to years finding the next matching pattern 
for each.  When complete, we will have found the next closest date to
the current time matching the pattern.

From the parsing phase we derived a set of date "patterns" which can
be used to find matching future dates.  Each such pattern is 
represented by an object that contains matching criteria for each
date field.  For each of second, minute, hour, day and month we 
represent the set of valid times as members of a set.  

The pattern object looks like:

DatePattern
{
  VALIDMATCH Year;          // integer
  VALIDMATCH Month;         // [1..12]
  VALIDMATCH Day;           // [1..31] *varies with month
  VALIDMATCH DayOfWeek;     // [1..7]
  VALIDMATCH WeekInMonth;   // [1..5]
  VALIDMATCH Quarter;       // [1..4]
  VALIDMATCH Hour;          // [1..24]
  VALIDMATCH Minute;        // [1..60]
  VALIDMATCH Second;        // [1..60]
}

The comment following each field indicates the valid
range of values.

The matching criteria VALIDMATCH looks like:

VALIDMATCH
{
  unsigned UpperBound;
  unsigned LowerBound;
  unsigned Modulus;
  unsigned CountNotMatching;
  unsigned *NotMatching;
}

Because, for each field above except year, the set of valid values 
is finite, we can collectively represent all of the limiting 
criteria within a VALIDMATCH object as a set containing matching 
members.  The set described is a finite set on which there is a 
total ordering of its members.  This can be represented by a bit
field with each bit identifying one potential member.  If a member
is present in a given set its bit is set to one otherwise it is 
zero.  

With this arrangement, given any value within the range of the
set we can find immediately whether or not that value is, in fact,
a member of the set or, if not, what is the next set value. The
following function outlines this task:

typedef Set __int64; // Set is a bitfield with 1 represented by
                     // leftmost bit

BOOL FindNextElement(int &iCurrentValue, Set ValidValues) 
{
  BOOL Carry = FALSE;
  Set CurrentValue = 0x80000000000000000 >> iCurrentValue;

  while(! (CurrentValue & ValidValues))
  {
    iCurrentValue >> 1;
    CurrentValue++;

    if(CurrentValue == 0x0)
    {
      CurrentValue = 0x8000000000000000;
      iCurrentValue = 1;
      Carry = TRUE;
    }
  }

  return Carry;
}

Note: this function assumes ValidValues is not empty.  

FindNextElement() takes a value as a member of a Set object
and finds the next greater member of the set ValidValues or 
the first member encountered in case of roleover.  Roleover is
indicated by the carry flag.  The first member encountered is
returned in CurrentValue.

Now, applying this to a complete date pattern consisting of year,
month, day, hour, minute and second would involve applying this
function using the method described above with the following special
cases.  First, if it was found that there was a carry on a month,
then we would need to go back and ensure that the new day is less 
than or equal to the last day of the new month.  If not, then keep 
adding months until a month is found where this is true.  Second, 
if there is a carry on months, then we have crossed a year boundary.
In this case we need to obtain the information for a new calendar 
year.

To address the additional fields WeekInMonth, DayOfWeek and Quarter,
we will use a technique based on the notion that these are just 
alternative ways to specify the pattern for the day field.  For each
for each of these fields create a bitfield representing the days of
the current month.  In each such field set those bits to one that
represent those days in the month that match for each of WeekInMonth,
DayOfWeek and Quarter.  And each of these together and to that of
days.  The resultant bitfield is the total number of days for the
current month that match all criteria.  This implies that the 
problem reduces to that of addition with carry as described above.

  Day = Day & WeekInMonth & DayOfWeek & Quarter

There is the additional problem of how to handle addition operations
that cross month boundaries.  This will occur when imcrementing the
day field results in a carry over to the next month.  When this 
happens we need to generate the composite Day field for the next 
valid month.  

To generate the bitfields for each of Day, WeekInMonth, DayOfWeek 
and Quarter w.r.t. some month we need to know how many days there 
are in the month, what month it is in the year and what day of the 
week is the first day of the month.  The month information can be 
generated using the system functions SystemTimeToFileTime() and 
FileTimeToSystemTime().  Given a month and year we can build these
four bitfields as follows:

1. Populate a SYSTEMTIME structure with date of the start of the
   month of interest at midnight of the first day of that month.
   <month>/1/<year> 0:0:0

2. Convert the SYSTEMTIME to a FILETIME and back to a SYSTEMTIME.
   Now SYSTEMTIME::wDayOfWeek will contain the day of the week
   for the first day of the month. Note: we will save this 
   FILETIME for later use below.

3. Determine the FILETIME for the beginning of the month following
   the one we are interested as in step 1 and 2 above.

4. Subtract the second FILETIME from the first and convert the 
   result to days.  This is the number of days in the month.

5. Using the sets from each field of the DatePattern structure 
   we can now construct the bitfields for the current month 
   corresponding to each of the four fields above.

6. Combine the bitfields with the Day bitfield using logical and
   to obtain the desired composite bitfield.

This functionality can be encapsulated into a single function that
takes a desired month and year plus a DatePattern structure and
returns the desired composite bitfield:

  Set GetDaysInMonth(DatePattern *, int year, int month)

First, lets modify the DatePattern structure defined above to 
fields for each member that represents it in terms of sets as
follows:

DatePattern
{
  VALIDMATCH Year;          // integer
  VALIDMATCH Month;         // [1..12]
  Set        MonthSet;
  VALIDMATCH Day;           // [1..31] *varies with month
  Set        DaySet;
  VALIDMATCH DayOfWeek;     // [1..7]
  Set        DayOfWeekSet;
  VALIDMATCH WeekInMonth;   // [1..5]
  Set        WeekInMonthSet;
  VALIDMATCH Quarter;       // [1..4]
  VALIDMATCH Hour;          // [1..24]
  Set        HourSet;
  VALIDMATCH Minute;        // [1..60]
  Set        MinuteSet;
  VALIDMATCH Second;        // [1..60]
  Set        SecondSet;
}

By providing a separate pattern for each of DayOfWeek and WeekInMonth,
we can optimize calculations of the composite field Day.

The current date is a collection of integers from SYSTEMTIME including
wYear, wMonth, wDay, wHour, wMinute and wSecond.  Here, then, is the
algorithm for finding the closest next firing time to the current time:

Let Pattern = DatePattern object 
Let Date = SYSTEMTIME object
Let Carry = BOOL object

GetSystemTime(&Date);

Carry = FindNextElement(&Date.wSecond, Pattern.SecondSet);
if(Carry) Date.wMinute++;

Carry = FindNextElement(&Date.wMinute, Pattern.MinuteSet);
if(Carry) Date.wHour++;

Carry = FindNextElement(&Date.wHour, Pattern.HourSet);
if(Carry) Date.wDay++;

do
{
  Carry = FindNextElement(&Date.wDay, Pattern.DaySet);
  if(Carry) 
  {
    do
    {
      Date.wMonth++;
      Carry2 = FindNextElement(&Date.wMonth, Pattern.MonthSet);
      if(Carry2) 
      {
        Date.wYear += 1;

        <find next matching Date.wYear against Pattern.Year using
         numerical methods>
      }
      Pattern.MonthSet = GetDaysInMonth(&Pattern, Date.wYear, Date.wMonth);
    } 
    while(0x0 == Pattern.MonthSet);
  }
}
while(Carry);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\cyrillic.txt ===
0 x 4 0 0   =    
 
 0 x 4 0 1   =   
 
 0 x 4 0 2   =   
 
 0 x 4 0 3   =   
 
 0 x 4 0 4   =   
 
 0 x 4 0 5   =   
 
 0 x 4 0 6   =   
 
 0 x 4 0 7   =   
 
 0 x 4 0 8   =   
 
 0 x 4 0 9   =   	
 
 0 x 4 0 A   =   

 
 0 x 4 0 B   =   
 
 0 x 4 0 C   =   
 
 0 x 4 0 D   =   

 
 0 x 4 0 E   =   
 
 0 x 4 0 F   =   
 
 0 x 4 1 0   =   
 
 0 x 4 1 1   =   
 
 0 x 4 1 2   =   
 
 0 x 4 1 3   =   
 
 0 x 4 1 4   =   
 
 0 x 4 1 5   =   
 
 0 x 4 1 6   =   
 
 0 x 4 1 7   =   
 
 0 x 4 1 8   =   
 
 0 x 4 1 9   =   
 
 0 x 4 1 A   =   
 
 0 x 4 1 B   =   
 
 0 x 4 1 C   =   
 
 0 x 4 1 D   =   
 
 0 x 4 1 E   =   
 
 0 x 4 1 F   =   
 
 0 x 4 2 0   =    
 
 0 x 4 2 1   =   !
 
 0 x 4 2 2   =   "
 
 0 x 4 2 3   =   #
 
 0 x 4 2 4   =   $
 
 0 x 4 2 5   =   %
 
 0 x 4 2 6   =   &
 
 0 x 4 2 7   =   '
 
 0 x 4 2 8   =   (
 
 0 x 4 2 9   =   )
 
 0 x 4 2 A   =   *
 
 0 x 4 2 B   =   +
 
 0 x 4 2 C   =   ,
 
 0 x 4 2 D   =   -
 
 0 x 4 2 E   =   .
 
 0 x 4 2 F   =   /
 
 0 x 4 3 0   =   0
 
 0 x 4 3 1   =   1
 
 0 x 4 3 2   =   2
 
 0 x 4 3 3   =   3
 
 0 x 4 3 4   =   4
 
 0 x 4 3 5   =   5
 
 0 x 4 3 6   =   6
 
 0 x 4 3 7   =   7
 
 0 x 4 3 8   =   8
 
 0 x 4 3 9   =   9
 
 0 x 4 3 A   =   :
 
 0 x 4 3 B   =   ;
 
 0 x 4 3 C   =   <
 
 0 x 4 3 D   =   =
 
 0 x 4 3 E   =   >
 
 0 x 4 3 F   =   ?
 
 0 x 4 4 0   =   @
 
 0 x 4 4 1   =   A
 
 0 x 4 4 2   =   B
 
 0 x 4 4 3   =   C
 
 0 x 4 4 4   =   D
 
 0 x 4 4 5   =   E
 
 0 x 4 4 6   =   F
 
 0 x 4 4 7   =   G
 
 0 x 4 4 8   =   H
 
 0 x 4 4 9   =   I
 
 0 x 4 4 A   =   J
 
 0 x 4 4 B   =   K
 
 0 x 4 4 C   =   L
 
 0 x 4 4 D   =   M
 
 0 x 4 4 E   =   N
 
 0 x 4 4 F   =   O
 
 0 x 4 5 0   =   P
 
 0 x 4 5 1   =   Q
 
 0 x 4 5 2   =   R
 
 0 x 4 5 3   =   S
 
 0 x 4 5 4   =   T
 
 0 x 4 5 5   =   U
 
 0 x 4 5 6   =   V
 
 0 x 4 5 7   =   W
 
 0 x 4 5 8   =   X
 
 0 x 4 5 9   =   Y
 
 0 x 4 5 A   =   Z
 
 0 x 4 5 B   =   [
 
 0 x 4 5 C   =   \
 
 0 x 4 5 D   =   ]
 
 0 x 4 5 E   =   ^
 
 0 x 4 5 F   =   _
 
 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\docs\decoupled.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Ray McCollum Microsoft Decoupled provider architecture Title Version Distribution Component Feature Product Product Version Project Status Internal Decoupled providers Provider Subsystem Whistler DraftDecoupled provider architecture Functional and design document Steve Menzies WBEM Specification.dot Steve Menzies Microsoft Word 9.0w>|7,@ 3R+jp dBQ&ijD TITLE  \* MERGEFORMAT  Decoupled provider architecture Spec Title  TITLE  \* MERGEFORMAT  Decoupled provider architecture Version  DOCPROPERTY "Version"  \* MERGEFORMAT  Distribution  FORMDROPDOWN  Component  DOCPROPERTY "Component"  \* MERGEFORMAT  Decoupled providers Feature area  DOCPROPERTY "Feature"  \* MERGEFORMAT  Provider Subsystem Feature scope  FORMDROPDOWN   FORMDROPDOWN  Product  DOCPROPERTY "Product"  \* MERGEFORMAT  Whistler Product Version  FORMDROPDOWN  Project  DOCPROPERTY "Project"  \* MERGEFORMAT  Author  AUTHOR \* FirstCap \* MERGEFORMAT  Steve Menzies Manager  DOCPROPERTY "Manager"  \* MERGEFORMAT  Ray McCollum Status  FORMDROPDOWN  Last Changed  SAVEDATE \@ "M/d/yy" \* MERGEFORMAT  4/12/00 Revision Summary Version Author Changes 3/30/98  AUTHOR  \* MERGEFORMAT  Steve Menzies Initial draft Overview The existing Nova WMI provider infrastructure supports the hosting of component services using a tightly coupled pull technology.  The requirement is to create a de-coupled provider-hosting infrastructure to meet the requirements of application and service management. Goals & Objectives The goal of the document is to describe the interface design and lifetime control of the decoupled provider architecture. The document details the minimal API design to allow useful application and service management. The document also describes a simple extension to the API to allow simplified event provision.  It is a requirement that the de-coupled provider architecture runs against both the existing Nova M3 architecture and the new Whistler architecture. It is therefore a requirement that the architecture share the same registration and API design.  This document does not cover the modeling issues relating to aggregated/distributed models i.e. how an application schema relates multiple distinct instances of an application and it s associated management data. An example often described is the ability to enumerate all copies of SQL Server 7.0 and the set of repositories being hosted by that particular instance of the application, here each copy of SQL Server 7.0 registers as a servicing component for a particular instance __Win32provider or at least a variation of this, this results in WMI requesting, in turn, the services of each copy of SQL Server 7.0 for a given client request, it is possible for each copy of SQL Server 7.0 to return non-unique instances of a class under enumeration, or worst still, handle the execution of a Put, Delete or ExecMethod when in fact the invocation was actually meant for another copy of SQL Server 7.0. We will defer the scoping of the request to the provider implementation who will perform the necessary scoping checks. Further where it would be applicable, we will not perform any analysis checks to validate key uniqueness. Executive Summary The existing Nova WMI provider infrastructure supports the hosting of component services using a tightly coupled pull technology. The strategy for dispatching requests from clients is to load a given provider component upon receipt of the first associated service request. The lifetime of the COM server providing such instrumentation services is directly controlled by the provider subsystem. This strategy works well for OS system style instrumentation, where typically a single non RPC API call will return the required instrumentation information. This strategy however does not work well with application management style instrumentation, since the application is generally running in the context of a separate process from the provider and some private RPC mechanism needs to be performed to extract the required data. More importantly however, where the application and the provider share the same executable image, the lifetime of the provider should be bounded by the lifetime of the application. It is required that WMI does not invoke the services of a provider before the application host process has registered its intention to service provider requests, further when the application host process de-registers its intention to service provider requests, WMI will discontinue forwarding requests to the provider component.  This document describes the feature set needed to meet these requirements. Files The de-coupled provider subsystem will be located in binary dll WmiDeCp.dll, with it s associated mof WmiDeCp.mof Provider functional support The following provider types will be supported by the de-coupled provider architecture :- Instance provider Method provider Event provider Event consumer Note that class and property providers will not be supported. Scope of operating system support The component will be required to work on Windows 95 SPn ( ?? )  , Windows 98 ( SP ?? ), Windows NT4 SP6, Windows 2000, Millennium and Whistler. ( this is a ridiculous matrix, who really wants to perform application management of anything but NT and Windows 2000  ? ). The components implementations will take into account the ANSI/UNICODE differences of each platform, by performing compile time platform checks. This allows the binaries to run un-impeded on their respective platforms. This means that their will be two binary executions files, one for Ansi and one for Unicode, however they will share the same name. Provider registration The de-coupled provider subsystem will use a registration broker to handle the dispatching of requests to specific instances of a running de-coupled provider . Each de-coupled provider will register by creating an instance of MSFT_DecoupledProvider specified below. Each instance of MSFT_DecoupledProvider will be required to specify the Name and Decoupled_CLSID properties and optionality specify the Decoupled_PerLocaleInitialization and Decoupled_SecurityDescriptor properties. In addition the provider writer will be expected to create instances of __InstanceProviderRegistration, __MethodProviderRegistration, __EventProviderRegistration and __EventConsumerProviderRegistration to indicate the level of functional support for the de-coupled provider. The decoupled provider subsystem implementation will use the provider registration information to determine the functional support for the given de-coupled provider and forward or reject the client-derived request as needed. class MSFT_DecoupledProvider : __Win32Provider Description ( "Decoupled provider CLSID, do not change. Do not override" ) , Override("Clsid") String Clsid = "{54D8502C-527D-43F7-A506-A9DA075E229C}" ; Description ( "Hosting Model, provides compatibility with Whistler. Do not override." ) , Override("HostingModel") string HostingModel = "Decoupled"; Description ( "SecurityDescriptor , secures registration of a decoupled provider during the Register phase of execution. " ) , Override("SecurityDescriptor") string SecurityDescriptor; Logging support The de-coupled provider subsystem will use a hybrid implementation of the core logging and provider-logging infrastructure.  Details to be added. Self instrumentation No specific instrumentation is supported. Interface design overview IWbemDecoupledRegistrar is a CoCreatable object interface that allows a provider to register participation in the provision of WMI functionality for a given provider role. Existing providers implemented provider functionaliy by registering a COM server and associating the by role of the provider via a number of schema elements, specifically __Win32Provider, __InstanceProviderRegistration, __EventProviderRegistration, __EventConsumerProviderRegistration and __MethodProviderRegistration. The existing provider architecture invoked a particular COM server implementation via a the COM activation mechanism ( e.g. CoCreateInstance ), it s activation being totally controlled by WMI. There are a number of typical management scenarios that require the lifetime of the provider to be defined by a given hosting process ( application ). In this respect it is necessary to allow the hosting process to register it s willingness to interoperate with WMI if and only if it is already activated. IWbemDecoupledRegistrar allows a process hosted provider to define the interoptability lifetime. Once a provider has registered with an object registration and an associated request against the provider has been identified, the object interface will be QI d for IWbemProviderInit. At this time the provider will receive an IWbemProviderInit :: Initialize call , allowing the provider to extract a valid pointer to an IWbemServices object. On successful completion of this call the object interface will again be QI d for a given interface specific to the request. If for example the provider is registered to send events, the provider subsystem will QI IWbemEventProvidr and call ProvideEvents, thus allowing the provider so send events to an event sink. Interface requirements WMI may QI on the IUnKnown for the following interface identifiers in anticipation of executing some client derived request. Iunknown  IwbemProviderInit IwbemServices IwbemServicesEx IwbemEventProvider IwbemEventProviderQuerySink IwbemEventProviderSecurity IwbemProviderIdentity IwbemEventConsumerProviderEx IwbemShutdown IwbemStatus Decoupling of provider and winmgmt lifetimes Is it a requirement to de-couple the lifetimes of the provider and winmgmt. This implies that Winmgmt will not attempt to instantiate the provider, instead the provider will register that it is capable of servicing requests from winmgmt. If the de-coupled provider has not registered to receive requests, then winmgmt will not be able to forward calls to the associated de-coupled provider, in this case it will return WBEM_E_PROVIDER_NOT_REGISTERED whenever a call is made to the associated provider. The de-coupled provider will advertise its willingness to respond to service requests by calling IWbemDecoupledRegistrar :: Register. This activation will place a marshaled stream into the registry so that the de-coupled provider subsystem can locate the actively running object, much the same way that the COM Running Object table does. On activation of the de-coupled provider subsystem via a call by a client request, the provider subsystem will interrogate the registry to determine whether there is a corresponding active de-coupled provider that is capable of servicing the request, if there is, the call will be forwarded, otherwise as already stated, WBEM_E_PROVIDER_NOT_REGISTERED will be returned. By definition a provider will not activate Winmgmt since it only places information within the registry, all other interaction are done via the callback interfaces specified above. Hosting requirements It is required that the process hosting the provider call CoInitializeSecurity such that it is possible for a caller to successfully execute. Of course the hosting process can specifically specify the set of user identities that can call into the process with the intent to restrict access to management data. Registry format On receipt of a call to Register the de-coupled provider subsystem will create an entry within the registry location HKEY_LOCAL_MACHINE\SOFTWARE\MICROSOFT\WBEM\TRANSPORTS\DECOUPLED with the name specified by the argument a_Name passed into IWbemDecoupledRegistrar :: Register. This key will be created with a security descriptor with an associated DACL with GENERIC_ALL access allowed ACEs of OWNER SID and LOCALSYSTEM, this will allow the creating process and winmgmt to retrieve the required registration information. Underneath this key the Register function will create a key identifying the process identifier of the hosting process. Under here the Register function will create the following registry values Value CreationTime REG_SZ Time the process was created ProcessIdentifier REG_DWORD Process Identifier of registered process. REG_SZ Identity of process creator Locale REG_SZ Locale specified in registeration. Scope REG_SZ Scope specified in registration. MarshaledProxy REG_BINARY Byte array representing the marshaled interface of the Iunknown specified in the Register function The CreationTime registry value will be used to determine whether on registry read, the registry key for each registration is still valid. It can do this by determining if the process identifier is still valid and if the CreationTime specified in the registry is equivalent to the CreationTime of the currently executing process with the associated process identifier, if they are not equivalent, the entry is defined as invalid. If the registry entry is invalid, the entry will be deleted. On call to IWbemDecoupledRegistrar :: DeRegister or when the object represented by IWbemDecoupledProvider is finally released the associated registry entry will be deleted. The User registry value will be used to filter the set of requests that originate with a specific User identifier. If User is NULL then the requests will be forwarded irrespective of the identity of the originating management request. The Locale registry value will be used to filter the set of requests that originate with a specific Locale identifier. If Locale is NULL then the requests will be forwarded irrespective of the locale of the originating management request, however no specific locale processing will be performed. The Scope registry value will be used to filter the set of requests that originate from a specific namespace.. If the Scope value is NULL, then the provider will accept requests from all namespaces, otherwise the provider will accept requests from the namespace specified. The MarshaledProxy value will be used to identify the Iunknown interface proxy passed into Register. This value will be read from the registry and then un-marshaled by the de-coupled provider subsystem when it is first activated. This allows the de-coupled provider subsystem to determine that a provider is ready to accept service requests. IWbemDecoupledRegistrar::Register HRESULT Register (  [in] long a_Flags , [in] IWbemContext *a_Context , [in] LPCWSTR a_User, [in] LPCWSTR a_Locale, [in] LPCWSTR a_Scope , [in] LPCWSTR a_Registration , [in] IUnknown *a_Unknown Semantics Description Registers an object interface with WMI, indicating the registration object that applies to the object interface.  Concurrency and Threading Fully concurrent access permitted. Blocking Call returns once the registration is established.  Misc. Justification Need to declare registration mechanism so that provider can participate in provider servicing. Limitations and Restrictions Discussion: The Register method binds a provider to a specific instance of a provider registration object. The provider subsystem will use the object for all requests associated with the provider registration. There may be multiple processes that call the Register function against the same provider registration object, in these circumstances the provider dec-coupled subsystem will call each de-coupled provider in turn using the same interface method. This may result in multiple objects with the same key being returned for a given method invocation. If this is the case, the provider subsystem will use the first object it received for a given key. The provider should be architectured so that multiple keys are not returned for the same request. Parameters A_Flags Currently no flag values defined. A_Context Optional context. Currently no context values defined A_Registration The name of the provider being registered. tHe name corresponds to the identity of the provider specified by A_Registration. __Win32Provider   handle servicing for the given provider registration A_Scope An object path representing the binding to a WMI provider registration object in a specified namespace. The scope object can be null, indicating that the provider will support of functionality for all namespaces. A_User A User string identifying the USER that this specific registration will surface. If the provider registration object identified by the class MSFT_Win32Provider has the property Decoupled_USERInitialization set to true, then WMI will attempt to identify the specifc iunknown passed into register with the associated provider name and Name as specified within the client call to IWbemServices :: ConnectServer, if no such match is found, WMI will return WBEM_E_PROVIDER_NOT_REGISTERED to the calling client. Otherwise WMI will use all IUNKNOWN s with an associated a_USER that was specified as NULL A_Locale A locale string identifying the locale that this specific registration will surface. If the provider registration object identified by the class MSFT_Win32Provider has the property Decoupled_PerLocaleInitialization set to true, then WMI will attempt to identify the specifc iunknown passed into register with the associated provider name and locale as specified within the client call to IWbemServices :: ConnectServer, if no such match is found, WMI will return WBEM_E_PROVIDER_NOT_REGISTERED to the calling client. Otherwise WMI will use all IUNKNOWN s with an associated a_Locale that was specified as NULL. A_Unknown An IUnknown pointer indicating the object interface for a particular provider registration. This interface will be QI d to determine the interface support that the object is capable of servicing. Return Values WBEM_S_NO_ERROR Success WBEM_E_ALREADY_REGISTERED Object has already been registered. WBEM_E_ACCESS_DENIED WBEM_E_NOT_FOUND WBEM_E_TIMED_OUT WBEM_E_OUT_OF_MEMORY WBEM_E_CRITICAL_ERROR Internal error IWbemDecoupledRegistrar::UnRegister HRESULT UnRegister () ; Semantics Description Deregisters an object interface with WMI. Concurrency and Threading Fully concurrent access permitted. Blocking Call returns once the registration is established.  Misc. Justification Need to declare registration mechanism so that provider can cancel participation in provider servicing. Limitations and Restrictions Discussion: The UnRegister function removes the binding between the provider registration object and the provider object implementation. On return the provider object will no longer receive calls into it s incoming methods. Parameters None. Return Values WBEM_S_NO_ERROR Success WBEM_E_NOT_REGISTERED Object was never registrered. WBEM_E_ACCESS_DENIED WBEM_E_NOT_FOUND WBEM_E_TIMED_OUT WBEM_E_OUT_OF_MEMORY WBEM_E_CRITICAL_ERROR Internal error Samples Interface IWbemDecoupledBasicEventProvider Overview IWbemDecoupledBasicEventProvider is a CoCreatable object interface that allows a provider to register participation in the provision of WMI event functionality. The object created should be passed into the a_Unknown argument of IWbemDecoupledRegistrar :: Register. The provider can immediately call into GetService to obtain an interface to IwbemServices so that it can retrieve further WMI objects. The provider should call GetSink to retrieve a sink that is used to send events to WMI. The sink will forward the events to WMI, via Indicate, if and only if there is at least one event registration in effect. The sink will return WBEM_E_NOT_AVAILABLE from indicate, if there are no registrations in effect. When a registration takes effect, the sink will become begin to forward the events to WMI for analysis. The implementation of IwbemDecoupledBasicEventProvider will use the services of the IwbemDecoupledRegistrar implementation for object registration, the previous section should be referred to for additional details. IWbemDecoupledBasicEventProvider::Register HRESULT Register (  [in] long a_Flags , [in] IWbemContext *a_Context , [in] LPCWSTR a_User, [in] LPCWSTR a_Locale, [in] LPCWSTR a_Scope , [in] LPCWSTR a_Registration , [in] IUnknown *a_Unknown Semantics Description Registers an object interface with WMI, indicating the registration object that applies to the object interface.  Concurrency and Threading Fully concurrent access permitted. Blocking Call returns once the registration is established.  Misc. Justification Need to declare registration mechanism so that provider can participate in provider servicing. Limitations and Restrictions Discussion: The Initialize method binds a provider to a specific instance of a provider registration object. The provider subsystem will use the object for all requests associated with the provider registration. There may be multiple processes that call the Initialize function against the same provider registration object, under these circumstances the de-coupled provider subsystem might receive duplicate event instances from each provider instance. In any case the de-coupled provider subsystem will forward all received events. The provider should be architectured so that duplicate events are not forwarded for the same event registration. The a_Unknown parameter argument is used by the de-coupled provider subsystem for execution of the following associated event provider interfaces  IwbemEventProviderQuerySink IwbemEventProviderSecurity If the a_Unknown argument is NULL when the Initialize function is called, the de-coupled provider subsystem will quietly ignore the calls from the WMI core subsystem. Parameters A_Flags Currently no flag values defined. A_Context Optional context. Currently no context values defined A_Registration The name of the provider being registered. tHe name corresponds to the identity of the provider specified by A_Registration. __Win32Provider   handle servicing for the given provider registration A_Scope An object path representing the binding to a WMI provider registration object in a specified namespace. The scope object can be null, indicating that the provider will support of functionality for all namespaces. A_User A User string identifying the USER that this specific registration will surface. If the provider registration object identified by the class MSFT_Win32Provider has the property Decoupled_USERInitialization set to true, then WMI will attempt to identify the specifc iunknown passed into register with the associated provider name and Name as specified within the client call to IWbemServices :: ConnectServer, if no such match is found, WMI will return WBEM_E_PROVIDER_NOT_REGISTERED to the calling client. Otherwise WMI will use all IUNKNOWN s with an associated a_USER that was specified as NULL A_Locale A locale string identifying the locale that this specific registration will surface. If the provider registration object identified by the class MSFT_Win32Provider has the property Decoupled_PerLocaleInitialization set to true, then WMI will attempt to identify the specifc iunknown passed into register with the associated provider name and locale as specified within the client call to IWbemServices :: ConnectServer, if no such match is found, WMI will return WBEM_E_PROVIDER_NOT_REGISTERED to the calling client. Otherwise WMI will use all IUNKNOWN s with an associated a_Locale that was specified as NULL. A_Unknown An IUnknown pointer indicating the object interface for a particular provider registration. This interface will be QI d to determine the interface support that the object is capable of servicing. Return Values WBEM_S_NO_ERROR Success WBEM_E_ALREADY_REGISTERED Object has already been registered. WBEM_E_ACCESS_DENIED WBEM_E_NOT_FOUND WBEM_E_TIMED_OUT WBEM_E_OUT_OF_MEMORY WBEM_E_CRITICAL_ERROR Internal error IWbemDecoupledBasicEventProvider::GetService HRESULT GetService ( [in] long a_Flags , [in] IWbemContext *a_Context , [out] IWbemService *a_Service Semantics Description Retrieves an IwbemServices object to be used to call back into WMI. Concurrency and Threading Fully concurrent access permitted. Blocking Call returns once the IWbemService object has been established or failure has occured.  Misc. Justification Provider needs IWbemServices  to obtain related execution context. Limitations and Restrictions Discussion: The GetService method retrieves a pointer to an IwbemServices Object. This object can be used to call back into WMI. It is undecided whether the object returned is an actual connectable object or whether it is just a stub that becomes valid, once the de-coupled provider subsystem has initialized it internally. Parameters A_Flags Currently no flag values defined. A_Context Optional context. Currently no context values defined A_Service An interface pointer to an IwbemServices object that can be used to retrieve information from WMI. Return Values WBEM_S_NO_ERROR Success WBEM_E_ACCESS_DENIED WBEM_E_NOT_FOUND WBEM_E_TIMED_OUT WBEM_E_OUT_OF_MEMORY WBEM_E_CRITICAL_ERROR Internal error IWbemDecoupledBasicEventProvider::GetSink HRESULT GetSink ( [in] long a_Flags , [in] IWbemContext *a_Context , [out] IWbemObjectSink *a_Sink Semantics Description Returns an object sink for event forwarding. Concurrency and Threading Fully concurrent access permitted. Blocking Call returns on creation of object sink or on FAILURE condition. Misc. Justification Provider needs to forward event instances into WMI. Limitations and Restrictions Discussion: The GetSink method returns an object sink. The object sink is used to forward event objects to WMI. The IwbemObjectSink :: Indicate method will return WBEM_E_NOT_AVAILABLE if there are no associated event filters bound to the provider, otherwise Indicate will forward an event object to WMI. Parameters A_Flags Currently no flag values defined. A_Context Optional context. Currently no context values defined A_Sink An interface pointer to an IwbemSink object that can be used to forward information to WMI. Return Values WBEM_S_NO_ERROR Success WBEM_E_NOT_REGISTERED Object was never registrered. WBEM_E_ACCESS_DENIED WBEM_E_NOT_FOUND WBEM_E_TIMED_OUT WBEM_E_OUT_OF_MEMORY WBEM_E_CRITICAL_ERROR Internal error Samples References  DATE  1/8/2001 Microsoft Confidential Page   PAGE  \* MERGEFORMAT   DOCPROPERTY "Product"  \* MERGEFORMAT  Whistler  Specification   TITLE  \* MERGEFORMAT  Decoupled provider architecture MICROSOFT CONFIDENTIAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sql\scripts\sqlerrs.txt ===
raiserror 99100 'Scoping object has not been defined.'
raiserror 99101 'Parent class has not been defined.'
raiserror 99102 'This class already exists and cannot be modified.'
raiserror 99103 'This class/instance has been locked and cannot be modified.'
raiserror 99104 'This class/instance has not been defined.'
raiserror 99105 'This class/instance has been deleted.'
raiserror 99106 'Invalid lock value.'
raiserror 99107 'Invalid CIM Flag'
raiserror 99108 'Invalid CIM Datatype'
raiserror 99109 'Object Path cannot be blank.'
raiserror 99110 'This property/qualifier/method already exists on this class.'
raiserror 99111 'This property/qualifier/method has not been defined.'
raiserror 99112 'This enumeration element has not been defined.'
raiserror 99113 'This instance has already been defined.'
raiserror 99114 'This property is not indexed.'
raiserror 99115 'Image data cannot be queried.'
raiserror 99116 'Deleting key properties is not supported.'
raiserror 99117 'This is a class, delete using sp_DeleteClass.'
raiserror 99118 'This is an instance, delete using sp_DeleteInstance.'
raiserror 99119 'Cannot delete system objects, classes and properties.'
raiserror 99120 'Cannot add instances to abstract class.'
raiserror 99121 'Cannot add more than one instance to a singleton class.'
raiserror 99122 'Cannot add a key property to an unkeyed class.'
raiserror 99123 'Only namespaces can be hidden.'
raiserror 99124 'Invalid instance flags.'
raiserror 99125 'Cannot insert: This object already exists.'
raiserror 99126 'Cannot update: This object does not exist.'
raiserror 99127 'Conversion not allowed.'
raiserror 99128 'Class has instances.'
raiserror 99129 'Parent class would cause a loop.'
raiserror 99130 'Keyholes can only be created on numbers and strings.'
raiserror 99131 'Cannot add not_null property with no default to a class with instances.'
raiserror 99132 'This property/qualifier/method already exists on a derived class.'
raiserror 99133 'Cannot delete not_null property.'
raiserror 99134 'This instance has already been defined as a different class.'
raiserror 99999 'The #Deleted table does not exist.'
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\specs\notificationsinkmarshalling.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Title _PID_GUID _PID_HLINKSa-davj Sanjeev J. Surati Microsoft Word 8.0Changes to  Prepared By a-davj & a-sanjes Status: Custom marshalling of IWbemObjectSink Created 7-29-98 Version docproperty "LatestVersion"  \* Mergeformat  Error! Unknown document property name. Copyright 1998   by Microsoft Corporation. All Rights Reserved MICROSOFT CONFIDENTIAL - FOR INTERNAL DISTRIBUTION ONLY Revision History Version Author Change a-davj & a-sanjes 7/29/98 First version Introduction One of the potential bottle-necks in WBEM performance is the size of instance objects.  A typical instance object could be around 1K in size.  A class with thousands of instances, would consume considerable resources both transmitting the data and storing the instances in the clients memory.   Most of the memory usage for an instance is used in storing the class portion of the data.  Since all the instances in an enumeration have identical class portions, a lot of memory can be saved by just transmitting and storing the class portion just once no matter how many instances are being enumerated.  Currently, this is just being done for asynchronous enumerations though similar techniques could be used in other cases. In order to support this feature, a custom proxy stub set has been written for the IWbemObjectSink interface.  The proxy ensures that the class part is only sent once, and the stub ensures that the many instances can share a single copy of the class information. This specification has two parts;  the first deals with the changes to the IWbemObjectSink marshalling code and the second part has the details about how the class and instance parts of objects are split apart and later shared. 0 Custom Proxy and Stub Code In order to support the separation of instance and class data, we created our own proxy/stub pair for the IWbemObjectSink interface.  This will be referred to as the  new style  proxy/stub.  The current, or old style proxy/stub pair for this interface is created using the files automatically generated by MIDL and which are part of WBEMSVC.DLL.   For the foreseeable future, both the old style proxy/stub pair (in WBEMSVC.DLL) and the new style proxy/stub pair (in FASTPROX.DLL) will be used.  The old pair is used in order to support remote access to older releases, establish versioning and also as a convenient way to handle the SetStatus function.   To support the new proxy/stub code, the files SINKMRSH.H and SINKMRSH.CPP have been added to the FASTPROX project.  Together, they declare and define three classes.  First,  CSinkFactoryBuffer  is a proxy/stub factory.  There are also two classes named  CSinkProxyBuffer  and   CSinkStubBuffer  which contain the proxy and stub code.   Since both proxy/stub pairs are present, it is important to make sure that the HKCR\INTERFACE\IID_IWbemObjectSink |ProxyStub32 points to FASTPROX.DLL and not to WBEMSVC.DLL.  Since the automatically generated code that goes into wbemsvc.dll would normally put itself into that value during self-registration, we created a replacement named dlldata2.c.  Since dlldata2.c is not automatically generated by MIDL, it will have to be manually updated should there be and additional IDL files. During the initialization of the proxy, the IRpcProxyBuffer::Connect(IRpcChannelBuffer * pChannel) function is called.  During that function, the proxy does an AddRef on the channel buffer pointer not released until the IrpcProxyBuffer::Disconnect() function is called.  Additionally, the Connect function also gets a pointer to the old style IwbemObjectSink proxy, which is also released during the Disconnect function. In a Similar manner, the stub code gets a pointer to the old style stub code, which it holds until it is disconnected.  The Indicate function is complicated by the fact that the proxy does not initially know what sort of stub it is communicating with.  To determine that, it always sends the first object using the old style proxy.  When the new style stub gets the first indicate, it expects the data in the old format, but will replace the return code with WBEM_S_NEW_STYLE value.  When the new style proxy gets back the result of the first indicate, it checks for that value and if it detects it, then all subsequent indicates will be done using our custom marshalling and unmarshalling code.   The advantage of this approach is that the proxy and stub are responsible for determing what version they are talking to.  We considered updating the proxy/stub code for the IWbemServices interface and using CallAs functions which would somehow signal the IWbemObjectSink proxy/stub that it was working with a new style interface.  However that would be more complicated and has the following potential hole in it.  Because the IWbemObjectSink can be marshaled from one machine to another one, it could potentially be marshaled from a machine with new code to a machine with old code, causing versioning difficulties for the IWbemObjectSink Proxy/Stub Code, if it were informed by IWbemServices to function one way or the other.. 0 Wbem Data Packet Format During the custom marshaling, we need to transmit data between the proxy and the stub.  The data is laid out in a specific format as outlined below. WBEM Data Packet Header The basic layout of the packet is a structure WBEM_DATAPACKET_HEADER, followed by binary data that contains further packet specific information.  The important thing is that ALL data packets are prepended by the header described below.  This header is intended to act as a generic header that can be used to describe many different types of data, should we later decide to implement other marshalling.  As data formats change the version information should be updated accordingly. typedef struct tagWBEM_DATAPACKET_HEADER DWORD dwByteOrdering; abSignature[WBEM_DATAPACKET_SIZEOFSIGNATURE]; DWORD dwSizeOfHeader; DWORD dwDataSize; DWORD dwFlags; bVersion; bPacketType; } WBEM_DATAPACKET_HEADER; The values in this header are as follows: dwByteOrdering   This describes the byte ordering in use by the entire packet, including the data in the header.  Possible values for this are: WBEM_DATAPACKET_LITTLEENDIAN 0x00000000 WBEM_DATAPACKET_BIGENDIAN 0xFFFFFFFF abSignature   This is an 8-byte signature that is in all packets prepended by a WBEM_DATAPACKET_HEADER structure.  The 8-byte signature is as follows: WBEM_DATAPACKET_SIGNATURE { 0x57, 0x42, 0x45, 0x4D, 0x44, 0x41,  0x54, 0x41 } dwSizeOfHeader   This contains the size of the header.  This allows for code to quickly jump to the end of the header to process data, even if the header changes from one version to the next. dwDataSize   This is the size of the data following the header.  The total size of the data packet is dwDataSize + dwSizeOfHeader. dwFlags   This field can be used to describe various other attributes of the header and/or following data.  Currently no values are supported, however it could easily be used to indicate if the following data is compressed or encrypted. bVersion   This is the version of the protocol currently being run.  If a data packet containing a newer version is received, we will most likely drop the connection with an appropriate error. bPacketType   This is the type of packet that the WBEM_DATAPACKET_HEADER precedes.  The packet type must be one recognized by the header.  Currently, the supported values are: typedef enum WBEM_DATAPACKETYPE_FIRST = 0, WBEM_DATAPACKETTYPE_OBJECTSINK_INDICATE = 0, WBEM_DATAPACKETTYPE_LAST } WBEM_DATAPACKETTYPE; In cases where we need to check a block of data to determine if it is a valid packet header, we check that the size is at least that of the header, that the first 12 bytes of the packet consist of one of the valid byte ordering values followed by the known signature, the version is not greater than the current version and that the packet type is a recognized packet type.  When adding packet types, there probably isn t any need to bump up the version, since prior WBEM_DATAPACKET_HEADER code will toss the packet anyway, but if an existing packet type is changed, that would then be an appropriate time to bump up the version. INDICATE Packet When an IWbemObjectSink::Indicate() method is called, the WBEM_DATAPACKET_HEADER will be filled out with a bPacketType value of: WBEM_DATAPACKETTYPE_OBJECTSINK_INDICATE.  Following is the format of the Indicate Packet. typedef struct tagWBEM_DATAPACKET_OBJECTSINK_INDICATE DWORD dwSizeOfHeader; DWORD dwDataSize; lObjectCount; } WBEM_DATAPACKET_OBJECTSINK_INDICATE; dwSizeOfHeader   This contains the size of the header.  This allows for code to quickly jump to the end of the header to process data, even if the header changes from one version to the next. dwDataSize   This is the size of the data following the header.  The total size of the data packet is dwDataSize + dwSizeOfHeader. lObjectCount   This is the number of Objects that will immediately follow this packet. OBJECT Packets When we need to write out object packets, they are written out using the following format. typedef struct tagWBEM_DATAPACKET_OBJECT_HEADER DWORD dwSizeOfHeader; DWORD dwSizeOfData; bObjectType; } WBEM_DATAPACKET_OBJECT_HEADER; dwSizeOfHeader   This contains the size of the header.  This allows for code to quickly jump to the end of the header to process data, even if the header changes from one version to the next. dwDataSize   This is the size of the data following the header.  The total size of the data packet is dwDataSize + dwSizeOfHeader. bObjectType   This is one of the following values: typedef enum WBEMOBJECT_FIRST WBEMOBJECT_NONE WBEMOBJECT_CLASS_FULL WBEMOBJECT_INSTANCE_FULL WBEMOBJECT_INSTANCE_NOCLASS WBEMOBJECT_LAST } WBEMOBJECT_PACKETTYPE; WBEMOBJECT_CLASS_FULL   Describes a complete class object. WBEMOBJECT_INSTANCE_FULL   Describes a complete instance object. WBEMOBJECT_INSTANCE_NOCLASS   Describes an instance object without its class data. Class Object Packet Class Objects are always prepended by a WBEM_DATAPACKET_OBJECT_HEADER. typedef struct tagWBEM_DATAPACKET_CLASS_HEADER DWORD dwSizeOfHeader; // Size Of Header DWORD dwSizeOfData; // Size Of Data following Header } WBEM_DATAPACKET_CLASS_HEADER; dwSizeOfHeader   This contains the size of the header.  This allows for code to quickly jump to the end of the header to process data, even if the header changes from one version to the next. dwDataSize   This is the size of the data following the header.  The total size of the data packet is dwDataSize + dwSizeOfHeader. Instance Object Packet Instance Objects are always prepended by a WBEM_DATAPACKET_OBJECT_HEADER.  The following header prepends all Instance Objects, regardless of whether or not they contain instance data. typedef struct tagWBEM_DATAPACKET_INSTANCE_HEADER DWORD dwSizeOfHeader; DWORD dwSizeOfData; guidClassId; } WBEM_DATAPACKET_INSTANCE_HEADER; dwSizeOfHeader   This contains the size of the header.  This allows for code to quickly jump to the end of the header to process data, even if the header changes from one version to the next. dwDataSize   This is the size of the data following the header.  The total size of the data packet is dwDataSize + dwSizeOfHeader. guidClassId   This is a GUID assigned to the packet by the sender.  The receiver interprets the GUID based on the type of instance data that follows this header. WBEM Data Packet Support classes In order to centralize the handling of the previously documented structures, a series of classes have been created in FASTPROX.DLL.  These classes are where changes and/or additions to processing logic should be added. The classes are: CWbemDataPacket CWbemObjSinkIndicatePacket CWbemObjectPacket CWbemClassPacket CWbemInstancePacket CWbemClasslessInstancePacket CWbemObjSinkIndicatePacket is derived from CWbemDataPacket.  Any more major packet types we wish to add should also be derived from CWbemDataPacket. CWbemObjectPacket provides standard processing for IWbemClassObject.  CWbemClassPacket and CWbemInstancePacket derive from CWbemObjectPacket.  CWbemClasslessInstancePacket Derives from CWbemInstancePacket.  These classes are not dependent on CWbemObjSinkIndicatePacket or CWbemDataPacket and are intended to provide standalone help for transferring objects to and from byte streams. Determination and usage of Class ID GUIDs Why We Used GUIDs The GUIDs that we use to identify classes used by Instance objects are determined as follows. On the sending  (proxy) side, for each instance object passed to us, we get the name of the class and look for the class in a map that is stored on a per proxy instance basis.  If the class is not found, we assume this is the first time we are sending an instance of this particular class.  At that point a new GUID is generated and associated with the class.  Subsequent lookups for this class will result in the previously generated GUID being returned. We chose to use GUIDs, because the proxy for IWbemObjectSink, can itself be marshaled between threads or to other machines, yet still point to the same Stub Instance.  With this in mind, since classes of the same name but with different definitions may exist in multiple name spaces, or on multiple machines, by using a GUID generated on a per proxy basis, the stub is protected from hooking an instance up to the wrong class definition. On the receiving (stub) side, the GUID assigned by the Proxy is read from the instance object s packet data.  If the instance object is a complete instance, the GUID and the instance object are added to a cache that relates GUIDs to IWbemClassObjects.  If the instance is a classless instance, we look up the GUID in the cache and merge the class in the returned object with the classless object.  The object that is merged with the classless object is AddRefed by the classless object, and is also AddRefed by the cache.  The cache is destroyed when the stub object is destroyed, at which time the objects in the cache are Released.  The instance object all the other objects are merged with is destroyed only after all the objects referencing it release it. Support Classes Two classes were written in order to support the GUIDs on each side of the Proxy/Stub architecture. CWbemClassToIdMap is used by the Proxy in order to generate and retrieve GUIDs as needed for sending. CWbemClassCache keeps a cache of GUID to IWbemClassObject relationships for retrieval on the Stub side of the Marshaling model. Each of these classes implements an Add/Get set of methods which take appropriate parameters.  The intention here is that the underlying data structures can be modified as needed without the interface to those structures having to change. DCR Number Subject CIMOM Security for Nova Developer RayMcc Document Date Introduction Functionality Change Expose object ACLs? based logon Cached credentials Kerberos What happens if certain properties are denied? Do we tag with qualifiers? |yvsp |yvspm ~{xurol  @  @@ @` @ @@ @@@@@`@@ `@ `@@`@``@ IDATx 4_xZI%{ s:6z@ wD>GIN% $i m- MqC+s YnR&E JeHWU oNq`ke!G vC@[. p}]/3 hnEs7 '`eMnn Y'qC  p+oDIG IY-jD 4x12} U&VmP 3"OY$ $@7If e+:]7B d=#L~ h$?n(W D3hb q> ~em4>??_ YIFlD `Aoy" gje&& {.={f 2jSUkT YQN/' mKm\h WYF)/` N_}$K] 1N8*: e?bx% U(R|g #|eE|uh dF&j{ M5|El pIDAT <y/[{ .*m?{*K( &E.QP{?Z >''"; =yk)Q uxJ7#Y2l} J'9Z~y <tX/l+ os&`W 8cbsnX PAMQG f?PXC BcIGPU w~1jeV {;MFJ
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\specs\faq\faq.txt ===
Q: Why am I getting WBEM_E_PROVIDER_LOAD_FAILURE when I try to access my  provider?
A: 1) Check the logs --- wbemcore.log and wbemess.log for errors
   2) Make sure your CLSID is registered under HKLM, not HKCR (which is not 
        visible to services like WinMgmt)

Q: I am trying to use CLSID_WbemAdministrativeLocator in my client code, but I 
    am getting an error
A: This CLSID can only be used by in-process providers of WinMgmt to avoid 
    unnecessary authentication.  It cannot be used by out-of-process components,
    since authentication *is* necessary in those cases.

Q: I call Indicate in my in-process event provider, and the call hangs.
A: Make sure your event provider COM object is registered as "Both" or "Free" 
    threaded, not "Apartment" or "Single".  Doing otherwise deadlocks the
    system.

Q: What does exception 6f4 (or some other number) mean?
A: Most likely, the answer can be found by looking up 80070<exception> in the 
    MSDEV error lookup tool.  E.g. 800706f4: A null reference pointer was 
    passed to the stub. 

Q: I get WBEM_E_ACCESS_DENIED whenever I try to get anything out of the 
    providers. 
A: Most providers require that they be granted the right to impersonate the
    client before they will accept any requests.  There are two ways to ensure
    that this right is properly granted:
    a) Call CoInitializeSecurity with RPC_C_IMP_LEVEL_IMPERSONATE.  This only
        works in builds 975+. This must be done immediately after COM is 
        first initialized *in the process*.
    b) If (a) is impossible or undesirable, the client must
    modify security settings on all the IWbemService, IEnumWbemClassObject,
    and IWbemCallResult pointers before using them.  This can be 
    accomplished by using CoSetProxyBlanket call, e.g.

    CoSetProxyBlanket(pServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, 
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, 0);

Q: WMI does not allow me to set the value of an array property, or pass an
    array parameter to a method.
A: Arrays in WMI are repsesented by SAFEARRAYS of the type derived from the
    type of the property.  For instance, if the type of the property is
    CIM_SINT32 | CIM_FLAG_ARRAY, then the value of the property must be a
    SAFEARRAY of VT_I4.  While WMI will attempt to coerce similar types, 
    SAFEARRAY of VARIANT is *never* acceptable.

Q: I call GetMethod on an instance of a class that I know has this method,
    but it returns WBEM_E_ILLEGAL_OPERATION
A: GetMethod may only be called on class definitions, not instances.  You can
    retrieve the class definition by examining the __CLASS property of the 
    instance, and calling IWbemServices::GetObject to retrieve the class.

Q: I am confused now.  How do I execute a method on an object?
A:  1) Get the class definition (IWbemServices::GetObject).
    2) Call IWbemClassObject::GetMethod to obtain the in-signature.
    3) Span an instance of in-signature and fill in the in-parameters. 
    4) Call IWbemServices::ExecMethod with the path to the object in question
        and the in-signature instances you have constructed in (3)
    5) Read out-parameters from the returned out-signature instances.

Q: Can I have two instances providers for the same class?
A: No.  But you can accomplish what you want by deriving two classes from the
    class in question, and attaching one provider to each class.  This 
    modification should not affect existing clients of the base class.

Q: I may need to add more properties to my class in version 2 of my product.
    What is the recommended procedure?
A: It is technically legal to add properties to your class in version 2, as 
    long as you do not remove or change properties, or alter their semantics.
    However, this leaves clients unsure whether they are getting objects of
    the old class, or the new class.  Suggested solution for this problem is
    to derive a new class from the old class, add your properties there, move
    your provider to provide instances of the new class, and mark the old one
    as abstract.  Note: you can only do that if you are sure that nobody else
    derived a class from your original one.  In particular, you can always do
    that with event classes.

Q: Can I use Decoupled Event Provider technique (Pseudo Provider) with Nova
    M1 or M2 (pre-900 builds)
A: No. But you can install M3 (900 builds) on any platform.

Q: Why am I getting SetStatus with WBEM_E_CALL_CANCELLED called on my sink, 
    even though I never cancelled the call?
A: WinMgmt will call WBEM_E_CALL_CANCELLED whenever the operation is cancelled,
    regardless of who cancelled it.  In particular, WinMgmt will abort any 
    asynchronous call if the call to Indicate returned an RPC return code
    (e.g. RPC_E_SERVERFAULT, or RPC_E_SERVER_UNAVAILABLE).

Q: What is the relationship between what my DLL has in its registry 
    ThreadingModel value, and how I must initialize my threads 
    (CoInitializeEx)?
A: These are completely separate issues.  The ThreadingModel is a setting of
    your COM object.  The thread initialization is a property of the thread 
    that you create.  There is no connection between the thread and the object
    except that they are backed by the code in the same DLL, but that's 
    entirely irrelevant.
    ThreadingModel defines what kinds of (other people's) threads can create 
    and access your COM object directly.  Thread initialization decides what 
    (other people's) COM objects will your thread be able to create and access
    directly.  As you can see, these are apples and oranges.

Q: What is the difference between "hi-perf" classes and "normal" classes?
A: If you are a client, there are no differences.  You can use IWbemServices
    methods to access the instances of any class. You can use IWbemRefresher
    methods to access the instances of any class.  The implementation and, 
    therefore, efficiency, of these access methods is different for different
    classes --- see provider documentation for details.  

Q: I am trying to retrieve the impersonation level of the client, but the 
    pImpLevel parameter of CoQueryClientBlanket returns garbage.
A: pImpLevel parameter must be NULL.  You cannot retrieve the client's 
    impersonation level this way.  You must impersonate the client 
    (CoImpersonationClient), open the thread token (OpenThreadToken), and 
    retrieve the impersonation level of the token (GetTokenInformation).

Q: I have released all my pointers to IUnsecuredApartment, but unsecap.exe is
    still running. 
A: In addition to IUnsecuredApartment pointers, unsecapp also returns the "stub"
    pointers from GetObjectStub.  If any of these are alive, unsecapp.exe will
    not terminate.  Remember that since these are mostly used for giving out to
    other processes (like WinMgmt), unsecapp will not go away until all those
    processes you have given its stubs to release them.

Q1: __EventDroppedEvent etc seem like intrinsic events. Why are they derived 
    from __ExtrinsicEvent, then?
Q2: I want to provider instance modification events for the instances of my 
    class.  How can I do that, since those events are intrinsic?
A: Definition: intrinsic events are events that reflect a change in the state
    of the world as modelled by the schema.  That is, intrinsic events are 
    namespace, class, and instance operation events.  Intrinsic events can be
    provided by the system (static classes) or providers (dynamic classes). 
    Extrinsic events can be provided by the system (__EventDroppedEvent) or 
    providers (RegistryTreeChangeEvent). There is no relationship between an 
    event being intrinsic or extrinsic and how it is provided.

Q: If I delete a class, will I get instance deletion events? What if I delete
    a namespace?
A: a) When you delete a namespace, you get a namespace deletion event, and no
    events for the classes and instances that were in the namespace.
   b) When you delete a class, you get class deletion events for the class that
    was deleted and all its children, but no instance deletion events.
   This behavior is by design.

Q: I cannot subscribe to receive registry notification events for the 
    HKEY_CURRENT_USER hive. 
A: Indeed. HKEY_CURRENT_USER hive does not make sense in the context of a 
    service.  This is by design.

Q: I want to return more extensive error information from my instance provider.
A: Define your own error class (derived from __ExtendedStatus).  Then, whenever
    an error occurs, spawn an instance of this class and send it back to WinMgmt
    in your call to SetStatus.  Don't forget to release it afterwards.

Q: My temporary consumer is receiving events from a remote machine.  How can I
    tell if that machines crashes or reboots?
A: If WinMgmt shuts down gracefully, your IWbemObjectSink interface will be 
    immediately Released.  If the machine crashes, your IWbemObjectSink interface
    will be Released in about two minutes by DCOM infrastructure.

Q: I have registered an instance provider for a class, but it doesn't get called.
A: Did you forget to designate a key?  Dynamic classes without keys cannot be
    supported.

Q: Why doesn't WMI allow me to provide events when instances of my dynamically 
    provided class change?
A: What the $##^ do you mean??!! Of course WMI allows you to do that!!! Read the
    @#$% manual on providing intrinsic events --- you register your provider like
    this: 
    select * from __InstanceOperationEvent where TargetInstance isa "MyClass"
    and off you go pushing events any time you want!

Q: When WMI polls a data provider to fake up intrinsic events, is every piece of
    data sent across the wire?
A: Not at all.  Polling is done locally by WinMgmt, and only when changes are 
    detected, and those change pass the tests specified in the query, is an event
    actually sent to the client (across the wire).

Q: What is the difference between having WinMgmt poll for me (using WITHIN clause)
    and doing it myself?
A: See the two questions above. First, WinMgmt polls extremely close to the source
    (closer than even an in-proc component can).  Second, if the provider ever 
    decides to provide those events, WinMgmt will automatically stop polling in 
    favor of much cheaper "real events" with no changes in the client.

Q: If I enumerate the instances of a base class that has some children, how can
    I "up-cast" the instances to find out what class they really are?
A: You don't need to.  When you enumerate the instances of a base class that has
    children, the instances of the children will come to use as instances of the
    children --- the right __CLASS value and all the properties.

Q: If I set SlowdownProvider property of my event consumer registration to TRUE,
    am I guaranteed that no events will be dropped.
A: No. We will slow down event providers if your queue gets too large, but if no
    amount of slowing down helps, we will eventually start dropping events.  This
    feature is intended to guarantee that all events are delivered if temporary
    or reasonable speed differentials exist.

Q: Can I specify WITHIN in event registrations that receive events from event
    providers?
A: Certainly.

Q: What is the difference between DEEP and SHALLOW enumerations of instances?
A: DEEP enumerates all instances of the class.  SHALLOW enumerates all instances
    of the class that are not instances of any of its children.

Q: Can I have NULLs embedded in my arrays, either in properties or in qualifiers?
    Can they start at an index other than 0?
A: No, and no.

Q: I am getting "The procedure entry point '...' could not be located in the 
    dynamic link library '...'" when I try to run WMI (mofcomp, etc). 
A: You have a build mismatch.  Do a search of your path (or your entire hard 
    drive) for the DLL and the EXE in question.  If you have more than one copy
    of either, get rid of the irrelevant one (WMI is installed into 
    %windir%\system32\wbem).  If not, compare their dates.  

Q: What if I register a WITHIN-style event query, but a poll takes longer than 
    the specified interval?
A: WMI will ignore any polling 'ticks' that occur while the previous poll is
    in progress (for the same registration, that is).

Q: My GetObject (ExecMethod) call crashes.  Why?
A: Check to make sure that you initialize all the paramters declared as 
    [out, OPTIONAL] in the IDL file to NULL.  This includes ppObject in
    GetObject and ppOutParams in ExecMethod.  The reason this must be done is 
    that OPTIONAL resolves to [in] (long story).

Q: Why am getting 0x80070776 from an asynchronous remote call?
A: DCOM uses fully qualifier DNS names to connect.  In this situation, the 
    server needs to connect back to the client.  You need to make sure that
    the fully qualified DNS name of the client machine is pingable from the 
    server (has to be fully qualified!).  If it is not, fix your DNS server and
    try again.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiperf\wmiperf.ini ===
[info]
drivername=winmgmt
symbolfile=genctrnm.h

[languages]
009=English

[text]
WMI_OBJECT_009_NAME=WINMGMT Counters
WMI_OBJECT_009_HELP=Self instrumentation counters for WINMGMT.
CNT_USER_009_NAME=Users
CNT_USER_009_HELP=Number of users connected
CNT_CONNECTION_009_NAME=Connections
CNT_CONNECTION_009_HELP=Number of current connectins
CNT_TASKSINPROG_009_NAME=Tasks In Progress
CNT_TASKSINPROG_009_HELP=Tasks in Progress
CNT_TASKSWAITING_009_NAME=Tasks Waiting
CNT_TASKSWAITING_009_HELP=Tasks Waiting
CNT_DELIVERYBACK_009_NAME=Delivery Backup (Bytes)
CNT_DELIVERYBACK_009_HELP=Delivery Backup (Bytes)
CNT_TOTALAPICALLS_009_NAME=Total API calls
CNT_TOTALAPICALLS_009_HELP=Total API calls
CNT_INTOBJECT_009_NAME=Internal Objects
CNT_INTOBJECT_009_HELP=Internal Objects
CNT_INTSINKS_009_NAME=Internal Sinks
CNT_INTSINKS_009_HELP=Internal Sinks

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiperf\readme.txt ===
Using the wmiperf Performance DLL

Overview:

The wmiperf data for the class MSFT_WmiCoreStatus as defined in 
the system.mof file.


Installing:

The DLL can be built using standard build utilities and then installed on the 
target system using the following steps:

    1. Copy the wmiperf.DLL that was built to the %systemroot%\system32 
    directory.

    2. load the driver entries into the registry using the following
    command line:  (NOTE, this will be put into self registration later on)

        REGEDIT WMIPERF.REG

    3. load the performance names into the registry using the command
    line:

        LODCTR WMIPERF.INI

At this point all the software is installed and it ready to use.
Start Perfmon and select the "WMI Counters" object to display 
the data.

NOTE: The system may need to be restarted after these instructions 
are completed for this object to be seen by remote computers.

To add new counters;
1) run unloadctr on wmiperf.ini
2) bump up the MAXVALUES constant
3) Add new types in genctrnm.h
4) Extend the RegDataDefinition declaration in datagen.c
5) add new defs for wmiperf.ini
6) Make sure entry is zeroed out
7) In the coredll, update the coresvc.h file to add contants and expand local array

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wql\misc.txt ===
//
//Requirements:
//    GROUP BY
//    HAVING
//    ORDER BY
//    ALL
//    DISTINCT
//    LIKE
//    MAX (?)
//    MIN (?)

//Notes on joins
//(1) Aliases are enforced once used for any given table
//(2) Alias can be used for some tables, but not others
//
//New style:
//    select * from t1 cross join t2
//    select * from t1 cross join t2 where t1.x = t2.x
//    [Note:CROSS JOIN allows a where clause, other JOIN ops do not, but require ON]
//     
//    LEFT OUTER JOIN <on>
//    RIGHT OUTER JOIN <on>
//    FULL OUTER JOIN <on>
//    JOIN <on>
//    CROSS JOIN <where>
//
//
//
//<select [all|distinct] <select_list> from <> where <>
//    [group by] [having] [order by]



//OUTPUT:
//(1) General complexity flags
//    A. BOOLEAN: JOIN
//    B. BOOLEAN: OLD JOIN
//    C. BOOLEAN: NEW JOIN
//    D. BOOLEAN: ON Clause
//    F. BOOLEAN: SELF-JOIN OCCURS
//    G: INT: NUMBER OF TABLES JOINED
//    E. BOOLEAN: UNARY Query
//    F. BOOLEAN: WBEM Refs/Assocs
//
//    F. BOOLEAN: ALIASES
//    D. BOOLEAN: WQL 1.0 provider compatible simple query
//    F. BOOLEAN: WQL Temporal/Event extension
//    E. BOOLEAN: ORDER BY
//    F. BOOLEAN: GROUP BY
//    G. BOOLEAN: HAVING
//    H. SQL-89 COMPATIBLE
//    I. SQL-92 COMPATIBLE
//    F: DISTINCT
//    G: EQUIJOIN   
//    H: THETA-JOIN <non equijoin>
//
//  (2) Get number & list of classes/tables (NULL separated)   
//  (3) Get list of selected column references in the output
//  (4) Get list of column names used in ON
//  (5) Get list of column names used in WHERE
    
//(2) Select column list

    
//(3) Add *= and =* operators


//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\testclient\readme.txt ===
========================================================================
       WIN32 APPLICATION : WClient
========================================================================


AppWizard has created this WClient application for you.  

This file contains a summary of what you will find in each of the files that
make up your WClient application.

WClient.cpp
    This is the main application source file.

WClient.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.
	

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named WClient.pch and a precompiled types file named StdAfx.obj.


/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\tests\classd.xml ===
<?xml version="1.0" ?><CIM CIMVERSION="2.0" DTDVERSION="2.0" ><DECLARATION><DECLGROUP><VALUE.OBJECT><CLASS NAME="MyClass2"><PROPERTY NAME="MyProp" TYPE="string"><QUALIFIER NAME="CIMTYPE" TYPE="string" TOINSTANCE="true"><VALUE>string</VALUE></QUALIFIER><QUALIFIER NAME="key" TYPE="boolean" OVERRIDABLE="false" TOINSTANCE="true"><VALUE>TRUE</VALUE></QUALIFIER></PROPERTY></CLASS></VALUE.OBJECT></DECLGROUP></DECLARATION></CIM>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\tests\classp.xml ===
<?xml version="1.0" ?><CIM CIMVERSION="2.0" DTDVERSION="2.0" ><DECLARATION><DECLGROUP.WITHPATH><VALUE.OBJECTWITHPATH><CLASSPATH><NAMESPACEPATH><HOST>.</HOST><LOCALNAMESPACEPATH><NAMESPACE NAME="ROOT"/><NAMESPACE NAME="DEFAULT"/></LOCALNAMESPACEPATH></NAMESPACEPATH><CLASSNAME NAME="MyClass2"/></CLASSPATH><CLASS NAME="MyClass2"><PROPERTY NAME="MyProp" TYPE="string"><QUALIFIER NAME="CIMTYPE" TYPE="string" TOINSTANCE="true"><VALUE>string</VALUE></QUALIFIER><QUALIFIER NAME="key" TYPE="boolean" OVERRIDABLE="false" TOINSTANCE="true"><VALUE>TRUE</VALUE></QUALIFIER></PROPERTY></CLASS></VALUE.OBJECTWITHPATH></DECLGROUP.WITHPATH></DECLARATION></CIM>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\tests\classn.xml ===
<?xml version="1.0" ?><CIM CIMVERSION="2.0" DTDVERSION="2.0" ><DECLARATION><DECLGROUP.WITHNAME><VALUE.NAMEDOBJECT><CLASS NAME="MyClass2"><PROPERTY NAME="MyProp" TYPE="string"><QUALIFIER NAME="CIMTYPE" TYPE="string" TOINSTANCE="true"><VALUE>string</VALUE></QUALIFIER><QUALIFIER NAME="key" TYPE="boolean" OVERRIDABLE="false" TOINSTANCE="true"><VALUE>TRUE</VALUE></QUALIFIER></PROPERTY></CLASS></VALUE.NAMEDOBJECT></DECLGROUP.WITHNAME></DECLARATION></CIM>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\tests\instd.xml ===
< ? x m l   v e r s i o n = " 1 . 0 "   ? > < C I M   C I M V E R S I O N = " 2 . 0 "   D T D V E R S I O N = " 2 . 0 "   > < D E C L A R A T I O N > < D E C L G R O U P > < V A L U E . O B J E C T > < I N S T A N C E   C L A S S N A M E = " M y C l a s s 2 " > < P R O P E R T Y   N A M E = " M y P r o p "   T Y P E = " s t r i n g " > < V A L U E > a b c < / V A L U E > < / P R O P E R T Y > < / I N S T A N C E > < / V A L U E . O B J E C T > < V A L U E . O B J E C T > < I N S T A N C E   C L A S S N A M E = " M y C l a s s 2 " > < P R O P E R T Y   N A M E = " M y P r o p "   T Y P E = " s t r i n g " > < V A L U E > d e f < / V A L U E > < / P R O P E R T Y > < / I N S T A N C E > < / V A L U E . O B J E C T > < / D E C L G R O U P > < / D E C L A R A T I O N > < / C I M > 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\tests\instn.xml ===
< ? x m l   v e r s i o n = " 1 . 0 "   ? > < C I M   C I M V E R S I O N = " 2 . 0 "   D T D V E R S I O N = " 2 . 0 "   > < D E C L A R A T I O N > < D E C L G R O U P . W I T H N A M E > < V A L U E . N A M E D O B J E C T > < I N S T A N C E N A M E   C L A S S N A M E = " M y C l a s s 2 " > < K E Y B I N D I N G     N A M E = " M y P r o p " > < K E Y V A L U E   V A L U E T Y P E = " s t r i n g " > a b c < / K E Y V A L U E > < / K E Y B I N D I N G > < / I N S T A N C E N A M E > < I N S T A N C E   C L A S S N A M E = " M y C l a s s 2 " > < P R O P E R T Y   N A M E = " M y P r o p "   T Y P E = " s t r i n g " > < V A L U E > a b c < / V A L U E > < / P R O P E R T Y > < / I N S T A N C E > < / V A L U E . N A M E D O B J E C T > < V A L U E . N A M E D O B J E C T > < I N S T A N C E N A M E   C L A S S N A M E = " M y C l a s s 2 " > < K E Y B I N D I N G     N A M E = " M y P r o p " > < K E Y V A L U E   V A L U E T Y P E = " s t r i n g " > d e f < / K E Y V A L U E > < / K E Y B I N D I N G > < / I N S T A N C E N A M E > < I N S T A N C E   C L A S S N A M E = " M y C l a s s 2 " > < P R O P E R T Y   N A M E = " M y P r o p "   T Y P E = " s t r i n g " > < V A L U E > d e f < / V A L U E > < / P R O P E R T Y > < / I N S T A N C E > < / V A L U E . N A M E D O B J E C T > < / D E C L G R O U P . W I T H N A M E > < / D E C L A R A T I O N > < / C I M > 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\tests\instp.xml ===
< ? x m l   v e r s i o n = " 1 . 0 "   ? > < C I M   C I M V E R S I O N = " 2 . 0 "   D T D V E R S I O N = " 2 . 0 "   > < D E C L A R A T I O N > < D E C L G R O U P . W I T H P A T H > < V A L U E . O B J E C T W I T H P A T H > < I N S T A N C E P A T H > < N A M E S P A C E P A T H > < H O S T > . < / H O S T > < L O C A L N A M E S P A C E P A T H > < N A M E S P A C E   N A M E = " R O O T " / > < N A M E S P A C E   N A M E = " D E F A U L T " / > < / L O C A L N A M E S P A C E P A T H > < / N A M E S P A C E P A T H > < I N S T A N C E N A M E   C L A S S N A M E = " M y C l a s s 2 " > < K E Y B I N D I N G     N A M E = " M y P r o p " > < K E Y V A L U E   V A L U E T Y P E = " s t r i n g " > a b c < / K E Y V A L U E > < / K E Y B I N D I N G > < / I N S T A N C E N A M E > < / I N S T A N C E P A T H > < I N S T A N C E   C L A S S N A M E = " M y C l a s s 2 " > < P R O P E R T Y   N A M E = " M y P r o p "   T Y P E = " s t r i n g " > < V A L U E > a b c < / V A L U E > < / P R O P E R T Y > < / I N S T A N C E > < / V A L U E . O B J E C T W I T H P A T H > < V A L U E . O B J E C T W I T H P A T H > < I N S T A N C E P A T H > < N A M E S P A C E P A T H > < H O S T > . < / H O S T > < L O C A L N A M E S P A C E P A T H > < N A M E S P A C E   N A M E = " R O O T " / > < N A M E S P A C E   N A M E = " D E F A U L T " / > < / L O C A L N A M E S P A C E P A T H > < / N A M E S P A C E P A T H > < I N S T A N C E N A M E   C L A S S N A M E = " M y C l a s s 2 " > < K E Y B I N D I N G     N A M E = " M y P r o p " > < K E Y V A L U E   V A L U E T Y P E = " s t r i n g " > d e f < / K E Y V A L U E > < / K E Y B I N D I N G > < / I N S T A N C E N A M E > < / I N S T A N C E P A T H > < I N S T A N C E   C L A S S N A M E = " M y C l a s s 2 " > < P R O P E R T Y   N A M E = " M y P r o p "   T Y P E = " s t r i n g " > < V A L U E > d e f < / V A L U E > < / P R O P E R T Y > < / I N S T A N C E > < / V A L U E . O B J E C T W I T H P A T H > < / D E C L G R O U P . W I T H P A T H > < / D E C L A R A T I O N > < / C I M > 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\samples\diskviewer\description.txt ===
CIM Disk Viewer

Files:
Multiple.htm
controls.htm
results.htm
summary.xsl
wmimof.xsl
property-table.xsl
value-table.xsl
raw-xml.xsl
diska.xml
diskc.xml
diskd.xml
diske.xml
diskf.xml
magnify.wmf

Description:
This demo allows the user to select different instances of Win32_LogicalDisk 
that have been persisted as CIM XML documents and apply different XSL stylesheets 
to those documents.  Choose an XML document and a XSL stylesheet on the left and display
the data on the right.

This demo is a good example of using XSL to offer different views on XML.  Many times, the 
web designer will want to display different data to different consumers.  Through XSL this can 
be done without altering the original XML document or the HTML page used to load that document.


Compatibility/Platform Compatibility:
You must be running Microsoft Internet Explorer 5 or greater on Win32 or Unix platforms to view this demo.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\samples\xmltest\description.txt ===
CIM Disk Viewer

Files:
Multiple.htm
controls.htm
results.htm
summary.xsl
wmimof.xsl
property-table.xsl
value-table.xsl
raw-xml.xsl
diska.xml
diskc.xml
diskd.xml
diske.xml
diskf.xml
magnify.wmf

Description:
This demo allows the user to select different instances of Win32_LogicalDisk 
that have been persisted as CIM XML documents and apply different XSL stylesheets 
to those documents.  Choose an XML document and a XSL stylesheet on the left and display
the data on the right.

This demo is a good example of using XSL to offer different views on XML.  Many times, the 
web designer will want to display different data to different consumers.  Through XSL this can 
be done without altering the original XML document or the HTML page used to load that document.


Compatibility/Platform Compatibility:
You must be running Microsoft Internet Explorer 5 or greater on Win32 or Unix platforms to view this demo.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\samples\diskviewer\diskd.xml ===
< ? x m l   v e r s i o n = " 1 . 0 "   ? > < C I M   C I M V E R S I O N = " 2 . 0 "   D T D V E R S I O N = " 2 . 0 "   > < D E C L A R A T I O N > < D E C L G R O U P > < V A L U E . O B J E C T > < I N S T A N C E   C L A S S N A M E = " W i n 3 2 _ L o g i c a l D i s k " > < Q U A L I F I E R   N A M E = " d y n a m i c "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > T R U E < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " L o c a l e "   P R O P A G A T E D = " t r u e "   T Y P E = " s i n t 3 2 "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > 1 0 3 3 < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " p r o v i d e r "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > C I M W i n 3 2 < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " U U I D "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > { 8 5 0 2 C 4 B 7 - 5 F B B - 1 1 D 2 - A A C 1 - 0 0 6 0 0 8 C 7 8 B C 7 } < / V A L U E > < / Q U A L I F I E R > < P R O P E R T Y   N A M E = " A c c e s s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " A v a i l a b i l i t y "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " B l o c k S i z e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C a p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > D : < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C o m p r e s s e d "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < V A L U E > F A L S E < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r U s e r C o n f i g "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > W i n 3 2 _ L o g i c a l D i s k < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > L o c a l   F i x e d   D i s k < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " k e y "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n "   O V E R R I D A B L E = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > T R U E < / V A L U E > < / Q U A L I F I E R > < V A L U E > D : < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " D r i v e T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 3 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " E r r o r C l e a r e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " E r r o r D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " E r r o r M e t h o d o l o g y "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " F i l e S y s t e m "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > N T F S < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " F r e e S p a c e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 3 2 9 2 1 4 3 6 1 6 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " I n s t a l l D a t e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " d a t e t i m e " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > d a t e t i m e < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " L a s t E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " M a x i m u m C o m p o n e n t L e n g t h "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 2 5 5 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " M e d i a T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 1 2 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " N a m e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > D : < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " N u m b e r O f B l o c k s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " P N P D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y . A R R A Y   N A M E = " P o w e r M a n a g e m e n t C a p a b i l i t i e s "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y . A R R A Y > < P R O P E R T Y   N A M E = " P o w e r M a n a g e m e n t S u p p o r t e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " P r o v i d e r N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " P u r p o s e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S i z e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 6 9 5 0 3 5 9 0 4 0 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S t a t u s "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S t a t u s I n f o "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S u p p o r t s F i l e B a s e d C o m p r e s s i o n "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < V A L U E > T R U E < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S y s t e m C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > W i n 3 2 _ C o m p u t e r S y s t e m < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S y s t e m N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > A L A N B O S 2 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " V o l u m e N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > C h a r i b d y s < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " V o l u m e S e r i a l N u m b e r "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > 3 C 8 F 9 3 1 E < / V A L U E > < / P R O P E R T Y > < / I N S T A N C E > < / V A L U E . O B J E C T > < / D E C L G R O U P > < / D E C L A R A T I O N > < / C I M > 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\samples\diskviewer\diskc.xml ===
< ? x m l   v e r s i o n = " 1 . 0 "   ? > < C I M   C I M V E R S I O N = " 2 . 0 "   D T D V E R S I O N = " 2 . 0 "   > < D E C L A R A T I O N > < D E C L G R O U P > < V A L U E . O B J E C T > < I N S T A N C E   C L A S S N A M E = " W i n 3 2 _ L o g i c a l D i s k " > < Q U A L I F I E R   N A M E = " d y n a m i c "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > T R U E < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " L o c a l e "   P R O P A G A T E D = " t r u e "   T Y P E = " s i n t 3 2 "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > 1 0 3 3 < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " p r o v i d e r "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > C I M W i n 3 2 < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " U U I D "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > { 8 5 0 2 C 4 B 7 - 5 F B B - 1 1 D 2 - A A C 1 - 0 0 6 0 0 8 C 7 8 B C 7 } < / V A L U E > < / Q U A L I F I E R > < P R O P E R T Y   N A M E = " A c c e s s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " A v a i l a b i l i t y "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " B l o c k S i z e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C a p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > C : < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C o m p r e s s e d "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < V A L U E > F A L S E < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r U s e r C o n f i g "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > W i n 3 2 _ L o g i c a l D i s k < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > L o c a l   F i x e d   D i s k < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " k e y "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n "   O V E R R I D A B L E = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > T R U E < / V A L U E > < / Q U A L I F I E R > < V A L U E > C : < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " D r i v e T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 3 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " E r r o r C l e a r e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " E r r o r D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " E r r o r M e t h o d o l o g y "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " F i l e S y s t e m "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > F A T < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " F r e e S p a c e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 8 2 4 4 4 2 8 8 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " I n s t a l l D a t e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " d a t e t i m e " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > d a t e t i m e < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " L a s t E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " M a x i m u m C o m p o n e n t L e n g t h "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 2 5 5 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " M e d i a T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 1 2 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " N a m e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > C : < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " N u m b e r O f B l o c k s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " P N P D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y . A R R A Y   N A M E = " P o w e r M a n a g e m e n t C a p a b i l i t i e s "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y . A R R A Y > < P R O P E R T Y   N A M E = " P o w e r M a n a g e m e n t S u p p o r t e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " P r o v i d e r N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " P u r p o s e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S i z e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 2 1 4 6 4 6 7 8 4 0 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S t a t u s "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S t a t u s I n f o "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S u p p o r t s F i l e B a s e d C o m p r e s s i o n "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < V A L U E > F A L S E < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S y s t e m C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > W i n 3 2 _ C o m p u t e r S y s t e m < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S y s t e m N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > A L A N B O S 2 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " V o l u m e N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > S C Y L L A < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " V o l u m e S e r i a l N u m b e r "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > C C 8 D B 3 1 B < / V A L U E > < / P R O P E R T Y > < / I N S T A N C E > < / V A L U E . O B J E C T > < / D E C L G R O U P > < / D E C L A R A T I O N > < / C I M > 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\samples\diskviewer\diska.xml ===
< ? x m l   v e r s i o n = " 1 . 0 "   ? > < C I M   C I M V E R S I O N = " 2 . 0 "   D T D V E R S I O N = " 2 . 0 "   > < D E C L A R A T I O N > < D E C L G R O U P > < V A L U E . O B J E C T > < I N S T A N C E   C L A S S N A M E = " W i n 3 2 _ L o g i c a l D i s k " > < Q U A L I F I E R   N A M E = " d y n a m i c "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > T R U E < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " L o c a l e "   P R O P A G A T E D = " t r u e "   T Y P E = " s i n t 3 2 "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > 1 0 3 3 < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " p r o v i d e r "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > C I M W i n 3 2 < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " U U I D "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > { 8 5 0 2 C 4 B 7 - 5 F B B - 1 1 D 2 - A A C 1 - 0 0 6 0 0 8 C 7 8 B C 7 } < / V A L U E > < / Q U A L I F I E R > < P R O P E R T Y   N A M E = " A c c e s s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " A v a i l a b i l i t y "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " B l o c k S i z e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C a p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > A : < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C o m p r e s s e d "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < V A L U E > F A L S E < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r U s e r C o n f i g "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > W i n 3 2 _ L o g i c a l D i s k < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > 3   1 / 2   I n c h   F l o p p y   D r i v e < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " k e y "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n "   O V E R R I D A B L E = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > T R U E < / V A L U E > < / Q U A L I F I E R > < V A L U E > A : < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " D r i v e T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 2 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " E r r o r C l e a r e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " E r r o r D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " E r r o r M e t h o d o l o g y "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " F i l e S y s t e m "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > F A T < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " F r e e S p a c e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 1 4 1 0 5 6 0 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " I n s t a l l D a t e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " d a t e t i m e " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > d a t e t i m e < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " L a s t E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " M a x i m u m C o m p o n e n t L e n g t h "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 2 5 5 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " M e d i a T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 5 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " N a m e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > A : < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " N u m b e r O f B l o c k s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " P N P D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y . A R R A Y   N A M E = " P o w e r M a n a g e m e n t C a p a b i l i t i e s "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y . A R R A Y > < P R O P E R T Y   N A M E = " P o w e r M a n a g e m e n t S u p p o r t e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " P r o v i d e r N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " P u r p o s e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S i z e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 1 4 5 7 6 6 4 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S t a t u s "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S t a t u s I n f o "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S u p p o r t s F i l e B a s e d C o m p r e s s i o n "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < V A L U E > F A L S E < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S y s t e m C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > W i n 3 2 _ C o m p u t e r S y s t e m < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S y s t e m N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > A L A N B O S 2 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " V o l u m e N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " V o l u m e S e r i a l N u m b e r "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < / I N S T A N C E > < / V A L U E . O B J E C T > < / D E C L G R O U P > < / D E C L A R A T I O N > < / C I M > 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\samples\diskviewer\diskf.xml ===
< ? x m l   v e r s i o n = " 1 . 0 "   ? > < C I M   C I M V E R S I O N = " 2 . 0 "   D T D V E R S I O N = " 2 . 0 "   > < D E C L A R A T I O N > < D E C L G R O U P > < V A L U E . O B J E C T > < I N S T A N C E   C L A S S N A M E = " W i n 3 2 _ L o g i c a l D i s k " > < Q U A L I F I E R   N A M E = " d y n a m i c "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > T R U E < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " L o c a l e "   P R O P A G A T E D = " t r u e "   T Y P E = " s i n t 3 2 "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > 1 0 3 3 < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " p r o v i d e r "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > C I M W i n 3 2 < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " U U I D "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > { 8 5 0 2 C 4 B 7 - 5 F B B - 1 1 D 2 - A A C 1 - 0 0 6 0 0 8 C 7 8 B C 7 } < / V A L U E > < / Q U A L I F I E R > < P R O P E R T Y   N A M E = " A c c e s s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " A v a i l a b i l i t y "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " B l o c k S i z e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C a p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > f : < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C o m p r e s s e d "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r U s e r C o n f i g "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > W i n 3 2 _ L o g i c a l D i s k < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > N e t w o r k   C o n n e c t i o n < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " k e y "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n "   O V E R R I D A B L E = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > T R U E < / V A L U E > < / Q U A L I F I E R > < V A L U E > f : < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " D r i v e T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 4 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " E r r o r C l e a r e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " E r r o r D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " E r r o r M e t h o d o l o g y "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " F i l e S y s t e m "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " F r e e S p a c e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " I n s t a l l D a t e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " d a t e t i m e " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > d a t e t i m e < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " L a s t E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " M a x i m u m C o m p o n e n t L e n g t h "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " M e d i a T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 0 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " N a m e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > f : < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " N u m b e r O f B l o c k s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " P N P D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y . A R R A Y   N A M E = " P o w e r M a n a g e m e n t C a p a b i l i t i e s "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y . A R R A Y > < P R O P E R T Y   N A M E = " P o w e r M a n a g e m e n t S u p p o r t e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " P r o v i d e r N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > \ \ a l a n b o s 3 \ d $ < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " P u r p o s e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S i z e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S t a t u s "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S t a t u s I n f o "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S u p p o r t s F i l e B a s e d C o m p r e s s i o n "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S y s t e m C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > W i n 3 2 _ C o m p u t e r S y s t e m < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S y s t e m N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > A L A N B O S 2 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " V o l u m e N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " V o l u m e S e r i a l N u m b e r "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < / I N S T A N C E > < / V A L U E . O B J E C T > < / D E C L G R O U P > < / D E C L A R A T I O N > < / C I M > 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\samples\xmltest\diska.xml ===
< ? x m l   v e r s i o n = " 1 . 0 "   ? > 
 
 < C I M   C I M V E R S I O N = " 2 . 0 "   D T D V E R S I O N = " 2 . 0 "   > 
 
 < D E C L A R A T I O N > 
 
 < D E C L G R O U P > 
 
 < I N S T A N C E   C L A S S N A M E = " W i n 3 2 _ L o g i c a l D i s k " > 
 
 < Q U A L I F I E R   N A M E = " d y n a m i c "   L O C A L = " f a l s e "   T Y P E = " b o o l e a n "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > T R U E < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " L o c a l e "   L O C A L = " f a l s e "   T Y P E = " s i n t 3 2 "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > 1 0 3 3 < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " p r o v i d e r "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ C I M W i n 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " U U I D "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ { 8 5 0 2 C 4 B 7 - 5 F B B - 1 1 D 2 - A A C 1 - 0 0 6 0 0 8 C 7 8 B C 7 } ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < P R O P E R T Y   N A M E = " A c c e s s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " A v a i l a b i l i t y "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " B l o c k S i z e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C a p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ a : ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C o m p r e s s e d "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > F A L S E < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r U s e r C o n f i g "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ W i n 3 2 _ L o g i c a l D i s k ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ 3   1 / 2   I n c h   F l o p p y   D r i v e ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " k e y "   L O C A L = " f a l s e "   T Y P E = " b o o l e a n "   O V E R R I D A B L E = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > T R U E < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ a : ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " D r i v e T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 2 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " E r r o r C l e a r e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " E r r o r D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " E r r o r M e t h o d o l o g y "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " F i l e S y s t e m "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ F A T ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " F r e e S p a c e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 4 5 0 5 6 0 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " I n s t a l l D a t e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " d a t e t i m e " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ d a t e t i m e ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " L a s t E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " M a x i m u m C o m p o n e n t L e n g t h "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 2 5 5 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " M e d i a T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 5 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " N a m e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ a : ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " N u m b e r O f B l o c k s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " P N P D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y . A R R A Y   N A M E = " P o w e r M a n a g e m e n t C a p a b i l i t i e s "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y . A R R A Y > 
 
 < P R O P E R T Y   N A M E = " P o w e r M a n a g e m e n t S u p p o r t e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " P r o v i d e r N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " P u r p o s e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S i z e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 1 4 5 7 6 6 4 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S t a t u s "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S t a t u s I n f o "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S u p p o r t s F i l e B a s e d C o m p r e s s i o n "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > F A L S E < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S y s t e m C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ W i n 3 2 _ C o m p u t e r S y s t e m ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S y s t e m N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ W B E M _ T E C R A _ 2 ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " V o l u m e N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " V o l u m e S e r i a l N u m b e r "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ 0 0 0 0 0 0 0 0 ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < / I N S T A N C E > 
 
 < / D E C L G R O U P > < / D E C L A R A T I O N > < / C I M > 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\samples\diskviewer\diske.xml ===
< ? x m l   v e r s i o n = " 1 . 0 "   ? > < C I M   C I M V E R S I O N = " 2 . 0 "   D T D V E R S I O N = " 2 . 0 "   > < D E C L A R A T I O N > < D E C L G R O U P > < V A L U E . O B J E C T > < I N S T A N C E   C L A S S N A M E = " W i n 3 2 _ L o g i c a l D i s k " > < Q U A L I F I E R   N A M E = " d y n a m i c "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > T R U E < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " L o c a l e "   P R O P A G A T E D = " t r u e "   T Y P E = " s i n t 3 2 "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > 1 0 3 3 < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " p r o v i d e r "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > C I M W i n 3 2 < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " U U I D "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > { 8 5 0 2 C 4 B 7 - 5 F B B - 1 1 D 2 - A A C 1 - 0 0 6 0 0 8 C 7 8 B C 7 } < / V A L U E > < / Q U A L I F I E R > < P R O P E R T Y   N A M E = " A c c e s s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " A v a i l a b i l i t y "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " B l o c k S i z e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C a p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > e : < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C o m p r e s s e d "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < V A L U E > F A L S E < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r U s e r C o n f i g "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > W i n 3 2 _ L o g i c a l D i s k < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > C D - R O M   D i s c < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < Q U A L I F I E R   N A M E = " k e y "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n "   O V E R R I D A B L E = " f a l s e "   T O I N S T A N C E = " t r u e " > < V A L U E > T R U E < / V A L U E > < / Q U A L I F I E R > < V A L U E > e : < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " D r i v e T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 5 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " E r r o r C l e a r e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " E r r o r D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " E r r o r M e t h o d o l o g y "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " F i l e S y s t e m "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > C D F S < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " F r e e S p a c e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 0 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " I n s t a l l D a t e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " d a t e t i m e " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > d a t e t i m e < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " L a s t E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " M a x i m u m C o m p o n e n t L e n g t h "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 2 2 1 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " M e d i a T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " u i n t 3 2 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 3 2 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 1 1 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " N a m e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > e : < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " N u m b e r O f B l o c k s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " P N P D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y . A R R A Y   N A M E = " P o w e r M a n a g e m e n t C a p a b i l i t i e s "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y . A R R A Y > < P R O P E R T Y   N A M E = " P o w e r M a n a g e m e n t S u p p o r t e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " P r o v i d e r N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " P u r p o s e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S i z e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   T Y P E = " u i n t 6 4 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 6 4 < / V A L U E > < / Q U A L I F I E R > < V A L U E > 0 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S t a t u s "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S t a t u s I n f o "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   P R O P A G A T E D = " t r u e "   T Y P E = " u i n t 1 6 " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > u i n t 1 6 < / V A L U E > < / Q U A L I F I E R > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S u p p o r t s F i l e B a s e d C o m p r e s s i o n "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " b o o l e a n " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > b o o l e a n < / V A L U E > < / Q U A L I F I E R > < V A L U E > F A L S E < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S y s t e m C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > W i n 3 2 _ C o m p u t e r S y s t e m < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " S y s t e m N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > A L A N B O S 2 < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " V o l u m e N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > A u d i o   C D < / V A L U E > < / P R O P E R T Y > < P R O P E R T Y   N A M E = " V o l u m e S e r i a l N u m b e r "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   T Y P E = " s t r i n g " > < Q U A L I F I E R   N A M E = " C I M T Y P E "   P R O P A G A T E D = " t r u e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > < V A L U E > s t r i n g < / V A L U E > < / Q U A L I F I E R > < V A L U E > 0 2 1 E 3 B F F < / V A L U E > < / P R O P E R T Y > < / I N S T A N C E > < / V A L U E . O B J E C T > < / D E C L G R O U P > < / D E C L A R A T I O N > < / C I M > 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\samples\xmltest\diskd.xml ===
< ? x m l   v e r s i o n = " 1 . 0 "   ? > 
 
 < C I M   C I M V E R S I O N = " 2 . 0 "   D T D V E R S I O N = " 2 . 0 "   > 
 
 < D E C L A R A T I O N > 
 
 < D E C L G R O U P > 
 
 < I N S T A N C E   C L A S S N A M E = " W i n 3 2 _ L o g i c a l D i s k " > 
 
 < Q U A L I F I E R   N A M E = " d y n a m i c "   L O C A L = " f a l s e "   T Y P E = " b o o l e a n "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > T R U E < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " L o c a l e "   L O C A L = " f a l s e "   T Y P E = " s i n t 3 2 "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > 1 0 3 3 < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " p r o v i d e r "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ C I M W i n 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " U U I D "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ { 8 5 0 2 C 4 B 7 - 5 F B B - 1 1 D 2 - A A C 1 - 0 0 6 0 0 8 C 7 8 B C 7 } ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < P R O P E R T Y   N A M E = " A c c e s s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " A v a i l a b i l i t y "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " B l o c k S i z e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C a p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ d : ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C o m p r e s s e d "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > F A L S E < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r U s e r C o n f i g "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ W i n 3 2 _ L o g i c a l D i s k ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ L o c a l   F i x e d   D i s k ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " k e y "   L O C A L = " f a l s e "   T Y P E = " b o o l e a n "   O V E R R I D A B L E = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > T R U E < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ d : ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " D r i v e T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 3 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " E r r o r C l e a r e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " E r r o r D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " E r r o r M e t h o d o l o g y "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " F i l e S y s t e m "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ N T F S ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " F r e e S p a c e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 8 8 8 3 2 4 0 9 6 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " I n s t a l l D a t e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " d a t e t i m e " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ d a t e t i m e ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " L a s t E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " M a x i m u m C o m p o n e n t L e n g t h "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 2 5 5 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " M e d i a T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 1 2 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " N a m e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ d : ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " N u m b e r O f B l o c k s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " P N P D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y . A R R A Y   N A M E = " P o w e r M a n a g e m e n t C a p a b i l i t i e s "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y . A R R A Y > 
 
 < P R O P E R T Y   N A M E = " P o w e r M a n a g e m e n t S u p p o r t e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " P r o v i d e r N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " P u r p o s e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S i z e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 3 9 4 8 1 0 1 6 3 2 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S t a t u s "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S t a t u s I n f o "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S u p p o r t s F i l e B a s e d C o m p r e s s i o n "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > T R U E < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S y s t e m C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ W i n 3 2 _ C o m p u t e r S y s t e m ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S y s t e m N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ W B E M _ T E C R A _ 2 ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " V o l u m e N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " V o l u m e S e r i a l N u m b e r "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ 8 0 4 E 4 4 2 F ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < / I N S T A N C E > 
 
 < / D E C L G R O U P > < / D E C L A R A T I O N > < / C I M > 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\samples\xmltest\diskf.xml ===
< ? x m l   v e r s i o n = " 1 . 0 "   ? > 
 
 < C I M   C I M V E R S I O N = " 2 . 0 "   D T D V E R S I O N = " 2 . 0 "   > 
 
 < D E C L A R A T I O N > 
 
 < D E C L G R O U P > 
 
 < I N S T A N C E   C L A S S N A M E = " W i n 3 2 _ L o g i c a l D i s k " > 
 
 < Q U A L I F I E R   N A M E = " d y n a m i c "   L O C A L = " f a l s e "   T Y P E = " b o o l e a n "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > T R U E < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " L o c a l e "   L O C A L = " f a l s e "   T Y P E = " s i n t 3 2 "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > 1 0 3 3 < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " p r o v i d e r "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ C I M W i n 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " U U I D "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ { 8 5 0 2 C 4 B 7 - 5 F B B - 1 1 D 2 - A A C 1 - 0 0 6 0 0 8 C 7 8 B C 7 } ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < P R O P E R T Y   N A M E = " A c c e s s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " A v a i l a b i l i t y "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " B l o c k S i z e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C a p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ f : ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C o m p r e s s e d "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > F A L S E < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r U s e r C o n f i g "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ W i n 3 2 _ L o g i c a l D i s k ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ C D - R O M   D i s c ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " k e y "   L O C A L = " f a l s e "   T Y P E = " b o o l e a n "   O V E R R I D A B L E = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > T R U E < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ f : ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " D r i v e T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 5 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " E r r o r C l e a r e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " E r r o r D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " E r r o r M e t h o d o l o g y "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " F i l e S y s t e m "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ C D F S ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " F r e e S p a c e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 0 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " I n s t a l l D a t e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " d a t e t i m e " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ d a t e t i m e ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " L a s t E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " M a x i m u m C o m p o n e n t L e n g t h "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 2 2 1 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " M e d i a T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 1 1 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " N a m e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ f : ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " N u m b e r O f B l o c k s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " P N P D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y . A R R A Y   N A M E = " P o w e r M a n a g e m e n t C a p a b i l i t i e s "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y . A R R A Y > 
 
 < P R O P E R T Y   N A M E = " P o w e r M a n a g e m e n t S u p p o r t e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " P r o v i d e r N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " P u r p o s e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S i z e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 1 9 0 4 8 4 4 8 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S t a t u s "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S t a t u s I n f o "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S u p p o r t s F i l e B a s e d C o m p r e s s i o n "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > F A L S E < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S y s t e m C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ W i n 3 2 _ C o m p u t e r S y s t e m ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S y s t e m N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ W B E M _ T E C R A _ 2 ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " V o l u m e N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ C D _ R O M ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " V o l u m e S e r i a l N u m b e r "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ 0 B 1 9 6 7 A 2 ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < / I N S T A N C E > 
 
 < / D E C L G R O U P > < / D E C L A R A T I O N > < / C I M > 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\samples\xmltest\diskc.xml ===
< ? x m l   v e r s i o n = " 1 . 0 "   ? > 
 
 < C I M   C I M V E R S I O N = " 2 . 0 "   D T D V E R S I O N = " 2 . 0 "   > 
 
 < D E C L A R A T I O N > 
 
 < D E C L G R O U P > 
 
 < I N S T A N C E   C L A S S N A M E = " W i n 3 2 _ L o g i c a l D i s k " > 
 
 < Q U A L I F I E R   N A M E = " d y n a m i c "   L O C A L = " f a l s e "   T Y P E = " b o o l e a n "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > T R U E < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " L o c a l e "   L O C A L = " f a l s e "   T Y P E = " s i n t 3 2 "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > 1 0 3 3 < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " p r o v i d e r "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ C I M W i n 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " U U I D "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ { 8 5 0 2 C 4 B 7 - 5 F B B - 1 1 D 2 - A A C 1 - 0 0 6 0 0 8 C 7 8 B C 7 } ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < P R O P E R T Y   N A M E = " A c c e s s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " A v a i l a b i l i t y "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " B l o c k S i z e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C a p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ C : ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C o m p r e s s e d "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > F A L S E < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r U s e r C o n f i g "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ W i n 3 2 _ L o g i c a l D i s k ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ L o c a l   F i x e d   D i s k ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " k e y "   L O C A L = " f a l s e "   T Y P E = " b o o l e a n "   O V E R R I D A B L E = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > T R U E < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ C : ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " D r i v e T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 3 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " E r r o r C l e a r e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " E r r o r D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " E r r o r M e t h o d o l o g y "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " F i l e S y s t e m "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ F A T ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " F r e e S p a c e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 2 8 9 4 7 2 5 1 2 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " I n s t a l l D a t e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " d a t e t i m e " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ d a t e t i m e ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " L a s t E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " M a x i m u m C o m p o n e n t L e n g t h "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 2 5 5 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " M e d i a T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 1 2 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " N a m e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ C : ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " N u m b e r O f B l o c k s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " P N P D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y . A R R A Y   N A M E = " P o w e r M a n a g e m e n t C a p a b i l i t i e s "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y . A R R A Y > 
 
 < P R O P E R T Y   N A M E = " P o w e r M a n a g e m e n t S u p p o r t e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " P r o v i d e r N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " P u r p o s e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S i z e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 2 1 4 6 4 6 7 8 4 0 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S t a t u s "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S t a t u s I n f o "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S u p p o r t s F i l e B a s e d C o m p r e s s i o n "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > F A L S E < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S y s t e m C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ W i n 3 2 _ C o m p u t e r S y s t e m ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S y s t e m N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ W B E M _ T E C R A _ 2 ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " V o l u m e N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " V o l u m e S e r i a l N u m b e r "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ 2 6 6 A 1 7 D C ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < / I N S T A N C E > 
 
 < / D E C L G R O U P > < / D E C L A R A T I O N > < / C I M > 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\setup.txt ===
This file describes installation of the WMI XML/HTTP server on Win2k Server and
on (Win2KProfessional + IIS)

The description below uses the term WBEM Directory to refer to the directory in which the WMI Core files are installed. This is typically c:\winnt\system32\wbem


1. Create a subdirectory call xml under the WBEM directory
2. Place the DLLs wmixmlop.dll and wmi2xml.dll in the xml directory and run regsvr32 on them.
3. Create a subdirectory call iis under the above xml directory. Place the DLLs wmiisapi.dll and wmifilt.dll in this directory.
4. Register the DLL wmifilt.dll as an ISAPI filter with IIS under the name WMI XML Filter. 
5. Create a virtual directory in the IIS metabase for the path /cimhttp. 
6. Map this virtual directory to the physical directory $WBEM/xml/iis and set the following attributes on this virtual directory
	Run out-of-proc (most isolation) to IIS
	Enable Execute permissions 
	Enable Windows NT/Challenge Response authentication
	Disable all other forms of authentication
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\samples\xmltest\diske.xml ===
< ? x m l   v e r s i o n = " 1 . 0 "   ? > 
 
 < C I M   C I M V E R S I O N = " 2 . 0 "   D T D V E R S I O N = " 2 . 0 "   > 
 
 < D E C L A R A T I O N > 
 
 < D E C L G R O U P > 
 
 < I N S T A N C E   C L A S S N A M E = " W i n 3 2 _ L o g i c a l D i s k " > 
 
 < Q U A L I F I E R   N A M E = " d y n a m i c "   L O C A L = " f a l s e "   T Y P E = " b o o l e a n "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > T R U E < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " L o c a l e "   L O C A L = " f a l s e "   T Y P E = " s i n t 3 2 "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > 1 0 3 3 < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " p r o v i d e r "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ C I M W i n 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " U U I D "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O S U B C L A S S = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ { 8 5 0 2 C 4 B 7 - 5 F B B - 1 1 D 2 - A A C 1 - 0 0 6 0 0 8 C 7 8 B C 7 } ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < P R O P E R T Y   N A M E = " A c c e s s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " A v a i l a b i l i t y "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " B l o c k S i z e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C a p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ e : ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C o m p r e s s e d "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > F A L S E < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C o n f i g M a n a g e r U s e r C o n f i g "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ W i n 3 2 _ L o g i c a l D i s k ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ L o c a l   F i x e d   D i s k ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < Q U A L I F I E R   N A M E = " k e y "   L O C A L = " f a l s e "   T Y P E = " b o o l e a n "   O V E R R I D A B L E = " f a l s e "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > T R U E < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ e : ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " D r i v e T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 3 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " E r r o r C l e a r e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " E r r o r D e s c r i p t i o n "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " E r r o r M e t h o d o l o g y "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " F i l e S y s t e m "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ F A T ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " F r e e S p a c e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 1 2 8 3 7 8 4 7 0 4 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " I n s t a l l D a t e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " d a t e t i m e " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ d a t e t i m e ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " L a s t E r r o r C o d e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " M a x i m u m C o m p o n e n t L e n g t h "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 2 5 5 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " M e d i a T y p e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 3 2 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 3 2 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 1 2 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " N a m e "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ e : ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " N u m b e r O f B l o c k s "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " P N P D e v i c e I D "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y . A R R A Y   N A M E = " P o w e r M a n a g e m e n t C a p a b i l i t i e s "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y . A R R A Y > 
 
 < P R O P E R T Y   N A M E = " P o w e r M a n a g e m e n t S u p p o r t e d "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " P r o v i d e r N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " P u r p o s e "   C L A S S O R I G I N = " C I M _ S t o r a g e E x t e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S i z e "   C L A S S O R I G I N = " C I M _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " u i n t 6 4 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 6 4 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > 2 0 9 7 1 1 9 2 3 2 < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S t a t u s "   C L A S S O R I G I N = " C I M _ M a n a g e d S y s t e m E l e m e n t "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S t a t u s I n f o "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " u i n t 1 6 " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ u i n t 1 6 ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S u p p o r t s F i l e B a s e d C o m p r e s s i o n "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " b o o l e a n " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ b o o l e a n ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > F A L S E < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S y s t e m C r e a t i o n C l a s s N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ W i n 3 2 _ C o m p u t e r S y s t e m ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " S y s t e m N a m e "   C L A S S O R I G I N = " C I M _ L o g i c a l D e v i c e "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ W B E M _ T E C R A _ 2 ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " V o l u m e N a m e "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < P R O P E R T Y   N A M E = " V o l u m e S e r i a l N u m b e r "   C L A S S O R I G I N = " W i n 3 2 _ L o g i c a l D i s k "   L O C A L = " t r u e "   T Y P E = " s t r i n g " > 
 
 < Q U A L I F I E R   N A M E = " C I M T Y P E "   L O C A L = " f a l s e "   T Y P E = " s t r i n g "   T O I N S T A N C E = " t r u e " > 
 
 < V A L U E > < ! [ C D A T A [ s t r i n g ] ] > < / V A L U E > 
 
 < / Q U A L I F I E R > 
 
 < V A L U E > < ! [ C D A T A [ 3 2 4 C 1 7 D C ] ] > < / V A L U E > 
 
 
 
 < / P R O P E R T Y > 
 
 < / I N S T A N C E > 
 
 < / D E C L G R O U P > < / D E C L A R A T I O N > < / C I M > 
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmixmlop\todo.txt ===
1. ReadClient call to get large data in request

2. HTTP Header Processing

3. CIM Header Processing

4. Chunked Encoding

5. Keeping TCP connections open

6. Memory leaks - Check whether streams need to be close()ed. See if they are released

7. Clean up the Set* functions in wmi2xml.cpp and header

8. Encode appropriate error objects

9. What to do if the call to load() fails in cim2xml.cpp

10. Stylesheets for everything except Raw XML fails when you do a 
References of {Win32_Processor.DeviceID="CPU0"}

11. Need to bulletproof Parse() functions when some of the element have null string values. For example,
If GetProperty operation is invoked on a class rather than an instance, there's a crash in IIS.
On a similar line, the every fuction in the wmixmlt.cpp returns with WBEM_E_INVALID_PARAMETER if one of the 
parameters is NULL. Before returning we should ensure that the contents of the headers stream are written to 
the socket.

12. Implement Logging for easy debugging

13. In wmixmlt.cpp function SavePrefixAndBodyToIISSocket(), see if the 2 SaveToStream() calls can be coalesced
into one.

14. Get rid of precomp.h and directly include the headers

15. In the function CXmlToWmi::MapContextObject(), we currently map only PROPERTY and PROPERTY.ARRAY elements.
We also need to map PROPERTY.OBJECT and PROPERTY.OBJECTARRAY elements since these can be properties in 
an IWbemContext object.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\schema\readme.txt ===
Files in this directory:

wmi.xsd
=======

Defines the WMI-specific productions for schemas

wmisoap.xsd 
===========

Contains the schema descriptions of the operations without any WSDL or binding pieces.

wmisoapwsdl.xml 
===============

The abstract WSDL definition i.e. the WSDL minus any URI-specific service/transport bindings).

Win32_NTLogEvent.xsd
Win32_NTLogEvent.xml
cim.xsd
=======

Examples of WMI class and instance.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\schema\win32_ntlogevent.xml ===
<?xml version="1.0" encoding="utf-8"?>
<Win32_NTLogEvent xmlns="" xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance">
  <Category>0</Category>
  <CategoryString xsi:null="true"/>
  <ComputerName>ALANBOS6</ComputerName>
  <EventCode>37</EventCode>
  <EventIdentifier>3221225509</EventIdentifier>
  <Logfile>Application</Logfile>
  <Message>WMI ADAP was unable to load the infoctrs.dll performance library due to an unknown problem within the library: 0x0</Message>
  <RecordNumber>755</RecordNumber>
  <SourceName>WinMgmt</SourceName>
  <TimeGenerated>20001122084323.000000-480</TimeGenerated>
  <TimeWritten>20001122084323.000000-480</TimeWritten>
  <Type>error</Type>
  <User xsi:null="true"/>
</Win32_NTLogEvent>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\schema\standard\soapencoding.xml ===
<?xml version='1.0'?>
<!-- XML Schema for SOAP v 1.1 Encoding -->

<!-- Copyright 2000 DevelopMentor, International Business Machines Corporation,
     Lotus Development Corporation, Microsoft, UserLand Software -->

<schema xmlns='http://www.w3.org/1999/XMLSchema'
        xmlns:tns='http://schemas.xmlsoap.org/soap/encoding/'
        targetNamespace='http://schemas.xmlsoap.org/soap/encoding/'>
        
 <!-- 'root' can be used to distinguish serialization roots from other
       elements that are present in a serialization but are not roots of
       a serialized value graph. -->

 <attribute name='root' default='0'>
    <simpleType base='boolean'>
      <pattern value='0|1'/>
    </simpleType>
 </attribute>
  
  <!-- Attributes common to all elements that function as accessors or 
       represent independent (multi-ref) values.  The href attribute is
       intended to be used in a manner like CONREF.  That is, the element
       content should be empty iff the href attribute appears. -->      
        
  <attributeGroup name='commonAttributes'>
    <attribute name='id' type='ID'/>
    <attribute name='href' type='uriReference'/>
    <anyAttribute namespace='##other'/>
  </attributeGroup>

  <!-- Global Attributes.  The following attributes are intended 
       to be usable via qualified attribute names on any complex type
       referencing them. -->
       
  <!-- Array attributes. Needed to give the type and dimensions of an array's
       contents, and the offset for partially-transmitted arrays. -->
   
  <simpleType name='arrayCoordinate' base='string'/>
          
  <attribute name='arrayType' type='string'/>
  <attribute name='offset' type='tns:arrayCoordinate'/>
  
  <attributeGroup name='arrayAttributes'>
    <attribute ref='tns:arrayType' minOccurs='1' />
    <attribute ref='tns:offset'/>
  </attributeGroup>    
  
  <attribute name='position' type='tns:arrayCoordinate'/> 
  
  <attributeGroup name='arrayMemberAttributes'>
    <attribute ref='tns:position'/>
  </attributeGroup>    
  
  <!-- 'Array' is a complex type for accessors identified by position.
   -->
   
  <element name='Array' type='tns:Array'/>
  <group name='Array'>
    <any minOccurs='0' maxOccurs='*'/>
  </group>
  <complexType name='Array' content='elementOnly'>
    <group ref='Array' minOccurs='0' maxOccurs='1'/>
    <attributeGroup ref='tns:arrayAttributes'/>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType> 
    
  <!-- 'Struct' is a complex type for accessors identified by name. 
       Constraint: No element may be have the same name as any other,
       nor may any element have a maxOccurs > 1. -->
   
  <element name='Struct' type='tns:Struct'/>
  <group name='Struct'>
      <any minOccurs='0' maxOccurs='*'/>
  </group>
  <complexType name='Struct'>
    <group ref='Struct' minOccurs='0' maxOccurs='1'/>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType> 

  <!-- 'Base64' can be used to serialize binary data using base64 encoding
       as defined in RFC2045 but without the MIME line length limitation. -->

  <simpleType name='base64' base='binary'>
    <encoding value='base64'/>
  </simpleType>

 <!-- Element declarations corresponding to each of the simple types in the 
      XML Schemas Specification. -->
  
  <element name='string' type='tns:string'/>
  <complexType name='string' base='string' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='boolean' type='tns:boolean'/>
  <complexType name='boolean' base='boolean' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='float' type='tns:float'/>
  <complexType name='float' base='float' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='double' type='tns:double'/>
  <complexType name='double' base='double' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='decimal' type='tns:decimal'/>
  <complexType name='decimal' base='decimal' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='timeDuration' type='tns:timeDuration'/>
  <complexType name='timeDuration' base='timeDuration' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='recurringDuration' type='tns:recurringDuration'/>
  <complexType name='recurringDuration' base='recurringDuration' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='binary' type='tns:binary'/>
  <complexType name='binary' base='binary' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='uriReference' type='tns:uriReference'/>
  <complexType name='uriReference' base='uriReference' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='ID' type='tns:ID'/>
  <complexType name='ID' base='ID' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='IDREF' type='tns:IDREF'/>
  <complexType name='IDREF' base='IDREF' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='ENTITY' type='tns:ENTITY'/>
  <complexType name='ENTITY' base='ENTITY' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='NOTATION' type='tns:NOTATION'/>
  <complexType name='NOTATION' base='NOTATION' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='QName' type='tns:QName'/>
  <complexType name='QName' base='QName' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='language' type='tns:language'/>
  <complexType name='language' base='language' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='IDREFS' type='tns:IDREFS'/>
  <complexType name='IDREFS' base='IDREFS' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='ENTITIES' type='tns:ENTITIES'/>
  <complexType name='ENTITIES' base='ENTITIES' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='NMTOKEN' type='tns:NMTOKEN'/>
  <complexType name='NMTOKEN' base='NMTOKEN' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='NMTOKENS' type='tns:NMTOKENS'/>
  <complexType name='NMTOKENS' base='NMTOKENS' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='Name' type='tns:Name'/>
  <complexType name='Name' base='Name' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='NCName' type='tns:NCName'/>
  <complexType name='NCName' base='NCName' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='integer' type='tns:integer'/>
  <complexType name='integer' base='integer' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='nonPositiveInteger' type='tns:nonPositiveInteger'/>
  <complexType name='nonPositiveInteger' base='nonPositiveInteger' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='negativeInteger' type='tns:negativeInteger'/>
  <complexType name='negativeInteger' base='negativeInteger' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='long' type='tns:long'/>
  <complexType name='long' base='long' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='int' type='tns:int'/>
  <complexType name='int' base='int' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='short' type='tns:short'/>
  <complexType name='short' base='short' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='byte' type='tns:byte'/>
  <complexType name='byte' base='byte' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='nonNegativeInteger' type='tns:nonNegativeInteger'/>
  <complexType name='nonNegativeInteger' base='nonNegativeInteger' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='unsignedLong' type='tns:unsignedLong'/>
  <complexType name='unsignedLong' base='unsignedLong' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='unsignedInt' type='tns:unsignedInt'/>
  <complexType name='unsignedInt' base='unsignedInt' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='unsignedShort' type='tns:unsignedShort'/>
  <complexType name='unsignedShort' base='unsignedShort' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='unsignedByte' type='tns:unsignedByte'/>
  <complexType name='unsignedByte' base='unsignedByte' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='positiveInteger' type='tns:positiveInteger'/>
  <complexType name='positiveInteger' base='positiveInteger' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='timeInstant' type='tns:timeInstant'/>
  <complexType name='timeInstant' base='timeInstant' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='time' type='tns:time'/>
  <complexType name='time' base='time' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='timePeriod' type='tns:timePeriod'/>
  <complexType name='timePeriod' base='timePeriod' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='date' type='tns:date'/>
  <complexType name='date' base='date' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='month' type='tns:month'/>
  <complexType name='month' base='month' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='year' type='tns:year'/>
  <complexType name='year' base='year' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='century' type='tns:century'/>
  <complexType name='century' base='century' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='recurringDate' type='tns:recurringDate'/>
  <complexType name='recurringDate' base='recurringDate' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>

  <element name='recurringDay' type='tns:recurringDay'/>
  <complexType name='recurringDay' base='recurringDay' content='textOnly'>
    <attributeGroup ref='tns:commonAttributes'/>
  </complexType>
  
 <!-- Element declarations and types corresponding to the ur-type in the 
      W3C XML Schemas Specification. This is the 
      soap representation for the type described as the ur-Type in the W3C 
      schema specification.  This type will be dropped from the SOAP 
      specification or modified appropriately if the W3C schema's workgroup 
      can give us a proper xsd:ur-Type name soon enough for us to use, 
      or else deprecated. -->
  
  <element name='ur-type'/>
  <complexType name='ur-type'/>

</schema>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\schema\standard\soapenvelope.xml ===
<?xml version='1.0'?>
<!-- XML Schema for SOAP v 1.1 Envelope -->

<!-- Copyright 2000 DevelopMentor, International Business Machines Corporation,
     Lotus Development Corporation, Microsoft, UserLand Software -->

<schema xmlns='http://www.w3.org/1999/XMLSchema'
        xmlns:tns='http://schemas.xmlsoap.org/soap/envelope/'
        targetNamespace='http://schemas.xmlsoap.org/soap/envelope/'>
     
  <!-- SOAP envelope, header and body -->
  
  <element name="Envelope" type="tns:Envelope"/>
  <complexType name='Envelope'>
    <element ref='tns:Header' minOccurs='0'/>
    <element ref='tns:Body' minOccurs='1'/>
    <any minOccurs='0' maxOccurs='*'/>
    <anyAttribute/>
  </complexType>
          
  <element name="Header" type="tns:Header"/>
  <complexType name='Header'>
    <any minOccurs='0' maxOccurs='*'/>
    <anyAttribute/>
  </complexType>
  
  <element name="Body" type="tns:Body"/>
  <complexType name='Body'>
    <any minOccurs='0' maxOccurs='*'/>
    <anyAttribute/>
  </complexType>
       
  <!-- Global Attributes.  The following attributes are intended 
       to be usable via qualified attribute names on any complex type
       referencing them.  -->
 
  <attribute name='mustUnderstand' default='0'>
    <simpleType base='boolean'>
      <pattern value='0|1'/>
    </simpleType>
  </attribute>
      
  <attribute name='actor' type='uri-reference'/>
 
  <!-- 'encodingStyle' indicates any canonicalization conventions followed
       in the contents of the containing element.  For example, the value
       'http://schemas.xmlsoap.org/soap/encoding/' indicates 
       the pattern described in SOAP specification. -->  
         
  <simpleType name='encodingStyle' base='uri-reference' derivedBy='list' />
  <attributeGroup name='encodingStyle'>
    <attribute name='encodingStyle' type='tns:encodingStyle'/>
  </attributeGroup>

  <!-- SOAP fault reporting structure -->
  <complexType name='Fault' final='extension'>
    <element name='faultcode' type='qname'/>
    <element name='faultstring' type='string'/>
    <element name='faultactor' type='uri-reference' minOccurs='0'/>
    <element name='detail' type='tns:detail' minOccurs='0'/>
  </complexType>

  <complexType name='detail'>
    <any minOccurs='0' maxOccurs='*'/>
    <anyAttribute/> 
  </complexType>

</schema>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\schema\wmisoapwsdl.xml ===
<?xml version="1.0" ?>

<!-- **********************************************************************	-->
<!--																		-->
<!-- Copyright (c) 2000-2001 Microsoft Corporation							-->
<!--																		-->
<!-- This file defines the WSDL abstract definitions for the WMI SOAP		-->
<!-- service. Note that specific service bindings are not defined here.		-->
<!--																		-->
<!--	TODO:																-->
<!--		- The other calls												-->
<!--																		-->
<!-- **********************************************************************	-->

<documentation xmlns="http://schemas.xmlsoap.org/wsdl/">

</documentation>

<definitions name="WMISOAP"
	targetNamespace="http://www.microsoft.com/wmi/soap/1.0/wsdl"
	xmlns:tns="http://www.microsoft.com/wmi/soap/1.0/wsdl"
	xmlns:wmi="http://www.microsoft.com/wmi/soap/1.0"
	xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
	xmlns="http://schemas.xmlsoap.org/wsdl/">

	<import namespace="http://www.microsoft.com/wmi/soap/1.0"
			location="http://www.microsoft.com/wmi/soap/1.0"/>
			
	<message name="DeleteClass">
		<part name="body" element="wmi:DeleteClass"/>
	</message>
	
	<message name="DeleteClassResponse">
		<part name="body" element="wmi:DeleteClassResponse"/>
	</message>
	
	<portType name="DeleteClassPortType">
		<operation name="DeleteClass">
			<input message="tns:DeleteClass"/>
			<output message="tns:DeleteClassResponse"/>
		</operation>
	</portType>
</definitions>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\server\todo.txt ===
>> NB: look for "TODO" in the source code for other issues.

1. Should we have a configurable value that states whether M-POST and/or POST are allowed?

2. Use thread pool? - DONE

3. Use STA or MTA threads? Probably better if we use MTA but we need the "hack" wrapper
code for the SAX parser if we do. After switching to the thread pool, I use STA threads. 

4. Do context parser implementation (i.e. build an IWbemContext from a SOAP serialization)

5. <Fault>-generation code using extended error objects

6. Semisync operations

7. Async operations

8. When calling the WMIXMLConverter, just pass in the WMI namespace URI as the
    encoder should by default know how to append classnames onto the end of that
	to build schema location values.

9. Logging!

10. Connection cache

11. Chunking support in responses

12. Better URL cracking code (for handling schema GETs) required.

13. Deserializer: This is the code that converts XML to WMI on the server side by 
talking to the local WinMgmt service. I have started work on this in dserlzer.cpp
and the work is around 20% done. This code has 2 more uses besides the SOAP server
side:
	a) Use by the core team to move objects between XML and DCOM transports.
	b) If we ever write an XML Schema compiler, without implementing the SOAP
	server and client, then we can use this piece of code to compile XML Schema
	to WMI using DCOM.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\tools\readme.txt ===
This directory contains the conversion tools necessary to transform our
DTDs into XSD (XML Schema Documents) suitable for integration into the
VS7 XML editing environment.

Please be aware that currently this is a non-automated process. The steps
you need to carry out to do this are as follows:


1) If you haven't done so, install MSXML 2.6 on your host; this is needed
   for the final stage of the conversion.  The msxmlwr.exe included in
   this folder contains the latest (March 2000) web preview release of
   MXSML. You'll need to run this to install MSXML.

2) If a DTD file has changed, you will need to check out the following
   files from the .\DTD subdirectory

		<dtdname>.xdr
		<dtdname>.xds

   where <dtdname> is the DTD file prefix (e.g. CIM20, WMI20).

3) Run the dtd2schema.exe utility on the DTD, to generate the XDR file.

	dtd2schema -o ..\dtd\<dtdname>.xdr ..\dtd\<dtdname>.dtd

4) Hand-edit the .XDR file produced so that the following changes are
   made:

	- Wherever a DTD production of the form 

		<!ELEMENT FOO (BAR, BAR+)>

	  occurs (currently only the MULTIREQ and MULTIRSP elements fit
          this pattern), change the output in the XDR file from

	<ElementType name="FOO" content="eltOnly">
		<group order="seq">
			<element type="BAR"/>
			<element type="BAR"/>
		</group>
	</ElementType>

          to

	<ElementType name="FOO" content="eltOnly">
		<group order="seq">
			<element type="BAR"/>
			<element type="BAR" maxOccurs="*"/>
		</group>
	</ElementType>

5) Then run the convert.js utility on the XDR to generate the XDS file.

	cscript convert.js ..\dtd\<dtdname>.xdr ..\dtd\<dtdname>.xds

6) Hand-edit the XDS file generated to include the correct VS7 intellisense
   annotations. At the time of writing these are known to include

	1) Change the opening lines of the file

		<!--
		   [XDR-XDS] This schema automatically updated from an IE5-compatible XDR schema to W3C
		   XML Schema.
		-->
		<!DOCTYPE schema SYSTEM "xsd.dtd">
		<schema xmlns="http://www.w3.org/1999/XMLSchema" version="1.0">

	   to


		<?xml version='1.0' ?>
		<schema targetNamespace='http://schemas.microsoft.com/Schemas/WMI20Ex'
		        xmlns='http://www.w3.org/1999/XMLSchema' version="1.0"
		      	xmlns:wmi='http://schemas.microsoft.com/Schemas/WMI20Ex'>

	   but note in the above the following DTD-specific content in xmlns:wmi declaration

		WMI20Ex, WMI20 or CIM20		- use this as last component of URL depending on DTD


	2) All ref attributes on <element> which address CIM/WMI DTD items should
 	   have their values prefixed with "wmi:" e.g.

		<element ref="CLASSPATH">

	   becomes

		<element ref="wmi:CLASSPATH">

	3) All elements of the form

		<any namespace="##other"/>

	   should be removed.
		

7) Check in the modified XDR and XDS files.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\soap\test\scripts\get.xml ===
<xsd:schema xmlns:xsd = 'http://www.w3.org/2000/10/XMLSchema'  xmlns = 'http://alanbos6/wmi/soap?path=root/cimv2'   xmlns:wmi = 'http://www.microsoft.com/wmi/soap'  targetNamespace = 'http://alanbos6/wmi/soap?path=root/cimv2' ><xsd:include schemaLocation = 'http://alanbos6/wmi/soap?path=root/cimv2:CIM_LogicalDisk'/><xsd:import namespace = 'http://www.microsoft.com/wmi/soap' schemaLocation = 'http://www.microsoft.com/wmi/soap/wmi.xsd' /><xsd:element name = 'Win32_LogicalDisk' type = 'Win32_LogicalDisk'/><xsd:complexType name = 'Win32_LogicalDisk'><xsd:annotation><xsd:appinfo><wmi:qualifier name = 'dynamic' type = 'boolean' array='False' value = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'Locale' type = 'uint32' array='False' value = '1033'  toInstance = 'True'  /><wmi:qualifier name = 'provider' type = 'string' array='False' value = 'CIMWin32'  toInstance = 'True'  /><wmi:qualifier name = 'UUID' type = 'string' array='False' value = '{8502C4B7-5FBB-11D2-AAC1-006008C78BC7}'  toInstance = 'True'  /><wmi:property name = 'Access' type='xsd:unsignedShort'></wmi:property><wmi:property name = 'Availability' type='xsd:unsignedShort'></wmi:property><wmi:property name = 'BlockSize' type='xsd:unsignedLong'></wmi:property><wmi:property name = 'Caption' type='xsd:string'></wmi:property><wmi:property name = 'Compressed' type='xsd:boolean'><wmi:qualifier name = 'CIMTYPE' type = 'string' array='False' value = 'boolean'  toSubclass = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'MappingStrings' type = 'string' array='True' value = '&amp;lt;MappingStrings arrayType=&amp;apos;string&amp;apos; &amp;gt; &amp;lt;arrayElement&amp;gt;Win32API|File System Functions|GetVolumeInformation|FS_VOL_IS_COMPRESSED&amp;lt;/arrayElement&amp;gt;&amp;lt;/MappingStrings&amp;gt;'  toSubclass = 'True'  /><wmi:qualifier name = 'read' type = 'boolean' array='False' value = 'True'  toSubclass = 'True'  /></wmi:property><wmi:property name = 'ConfigManagerErrorCode' type='xsd:unsignedShort'></wmi:property><wmi:property name = 'ConfigManagerUserConfig' type='xsd:boolean'></wmi:property><wmi:property name = 'CreationClassName' type='xsd:string'></wmi:property><wmi:property name = 'Description' type='xsd:string'></wmi:property><wmi:property name = 'DeviceID' type='xsd:string'><wmi:qualifier name = 'CIMTYPE' type = 'string' array='False' value = 'string'  toSubclass = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'key' type = 'boolean' array='False' value = 'True'  toSubclass = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'MappingStrings' type = 'string' array='True' value = '&amp;lt;MappingStrings arrayType=&amp;apos;string&amp;apos; &amp;gt; &amp;lt;arrayElement&amp;gt;WMI&amp;lt;/arrayElement&amp;gt;&amp;lt;/MappingStrings&amp;gt;'  toSubclass = 'True'  /><wmi:qualifier name = 'Override' type = 'string' array='False' value = 'DeviceId'  toSubclass = 'True'  /><wmi:qualifier name = 'read' type = 'boolean' array='False' value = 'True'  toSubclass = 'True'  /></wmi:property><wmi:property name = 'DriveType' type='xsd:unsignedShort'><wmi:qualifier name = 'CIMTYPE' type = 'string' array='False' value = 'uint32'  toSubclass = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'MappingStrings' type = 'string' array='True' value = '&amp;lt;MappingStrings arrayType=&amp;apos;string&amp;apos; &amp;gt; &amp;lt;arrayElement&amp;gt;Win32API|FileFunctions|GetDriveType&amp;lt;/arrayElement&amp;gt;&amp;lt;/MappingStrings&amp;gt;'  toSubclass = 'True'  /><wmi:qualifier name = 'read' type = 'boolean' array='False' value = 'True'  toSubclass = 'True'  /></wmi:property><wmi:property name = 'ErrorCleared' type='xsd:boolean'></wmi:property><wmi:property name = 'ErrorDescription' type='xsd:string'></wmi:property><wmi:property name = 'ErrorMethodology' type='xsd:string'></wmi:property><wmi:property name = 'FileSystem' type='xsd:string'><wmi:qualifier name = 'CIMTYPE' type = 'string' array='False' value = 'string'  toSubclass = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'MappingStrings' type = 'string' array='True' value = '&amp;lt;MappingStrings arrayType=&amp;apos;string&amp;apos; &amp;gt; &amp;lt;arrayElement&amp;gt;Win32API|File System Functions|GetVolumeInformation&amp;lt;/arrayElement&amp;gt;&amp;lt;/MappingStrings&amp;gt;'  toSubclass = 'True'  /><wmi:qualifier name = 'read' type = 'boolean' array='False' value = 'True'  toSubclass = 'True'  /></wmi:property><wmi:property name = 'FreeSpace' type='xsd:unsignedLong'></wmi:property><wmi:property name = 'InstallDate' type='wmi:datetime'></wmi:property><wmi:property name = 'LastErrorCode' type='xsd:unsignedShort'></wmi:property><wmi:property name = 'MaximumComponentLength' type='xsd:unsignedShort'><wmi:qualifier name = 'CIMTYPE' type = 'string' array='False' value = 'uint32'  toSubclass = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'MappingStrings' type = 'string' array='True' value = '&amp;lt;MappingStrings arrayType=&amp;apos;string&amp;apos; &amp;gt; &amp;lt;arrayElement&amp;gt;Win32API|File System Functions|GetVolumeInformation&amp;lt;/arrayElement&amp;gt;&amp;lt;/MappingStrings&amp;gt;'  toSubclass = 'True'  /><wmi:qualifier name = 'read' type = 'boolean' array='False' value = 'True'  toSubclass = 'True'  /></wmi:property><wmi:property name = 'MediaType' type='xsd:unsignedShort'><wmi:qualifier name = 'CIMTYPE' type = 'string' array='False' value = 'uint32'  toSubclass = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'MappingStrings' type = 'string' array='True' value = '&amp;lt;MappingStrings arrayType=&amp;apos;string&amp;apos; &amp;gt; &amp;lt;arrayElement&amp;gt;Win32API|Device Input and Output Functions|DeviceIoControl&amp;lt;/arrayElement&amp;gt;&amp;lt;/MappingStrings&amp;gt;'  toSubclass = 'True'  /><wmi:qualifier name = 'read' type = 'boolean' array='False' value = 'True'  toSubclass = 'True'  /></wmi:property><wmi:property name = 'Name' type='xsd:string'></wmi:property><wmi:property name = 'NumberOfBlocks' type='xsd:unsignedLong'></wmi:property><wmi:property name = 'PNPDeviceID' type='xsd:string'></wmi:property><wmi:property name = 'PowerManagementCapabilities' type='xsd:unsignedShort'></wmi:property><wmi:property name = 'PowerManagementSupported' type='xsd:boolean'></wmi:property><wmi:property name = 'ProviderName' type='xsd:string'><wmi:qualifier name = 'CIMTYPE' type = 'string' array='False' value = 'string'  toSubclass = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'MappingStrings' type = 'string' array='True' value = '&amp;lt;MappingStrings arrayType=&amp;apos;string&amp;apos; &amp;gt; &amp;lt;arrayElement&amp;gt;Win32API|Windows Networking Functions|WNetGetConnection&amp;lt;/arrayElement&amp;gt;&amp;lt;/MappingStrings&amp;gt;'  toSubclass = 'True'  /><wmi:qualifier name = 'read' type = 'boolean' array='False' value = 'True'  toSubclass = 'True'  /></wmi:property><wmi:property name = 'Purpose' type='xsd:string'></wmi:property><wmi:property name = 'Size' type='xsd:unsignedLong'></wmi:property><wmi:property name = 'Status' type='xsd:string'></wmi:property><wmi:property name = 'StatusInfo' type='xsd:unsignedShort'></wmi:property><wmi:property name = 'SupportsFileBasedCompression' type='xsd:boolean'><wmi:qualifier name = 'CIMTYPE' type = 'string' array='False' value = 'boolean'  toSubclass = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'MappingStrings' type = 'string' array='True' value = '&amp;lt;MappingStrings arrayType=&amp;apos;string&amp;apos; &amp;gt; &amp;lt;arrayElement&amp;gt;Win32API|File System Functions|GetVolumeInformation|FS_FILE_COMPRESSION&amp;lt;/arrayElement&amp;gt;&amp;lt;/MappingStrings&amp;gt;'  toSubclass = 'True'  /><wmi:qualifier name = 'read' type = 'boolean' array='False' value = 'True'  toSubclass = 'True'  /></wmi:property><wmi:property name = 'SystemCreationClassName' type='xsd:string'></wmi:property><wmi:property name = 'SystemName' type='xsd:string'></wmi:property><wmi:property name = 'VolumeName' type='xsd:string'><wmi:qualifier name = 'CIMTYPE' type = 'string' array='False' value = 'string'  toSubclass = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'MappingStrings' type = 'string' array='True' value = '&amp;lt;MappingStrings arrayType=&amp;apos;string&amp;apos; &amp;gt; &amp;lt;arrayElement&amp;gt;Win32API|File System Functions|GetVolumeInformation&amp;lt;/arrayElement&amp;gt;&amp;lt;/MappingStrings&amp;gt;'  toSubclass = 'True'  /><wmi:qualifier name = 'read' type = 'boolean' array='False' value = 'True'  toSubclass = 'True'  /><wmi:qualifier name = 'write' type = 'boolean' array='False' value = 'True'  toSubclass = 'True'  /></wmi:property><wmi:property name = 'VolumeSerialNumber' type='xsd:string'><wmi:qualifier name = 'CIMTYPE' type = 'string' array='False' value = 'string'  toSubclass = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'MappingStrings' type = 'string' array='True' value = '&amp;lt;MappingStrings arrayType=&amp;apos;string&amp;apos; &amp;gt; &amp;lt;arrayElement&amp;gt;Win32API|File System Functions|GetVolumeInformation&amp;lt;/arrayElement&amp;gt;&amp;lt;/MappingStrings&amp;gt;'  toSubclass = 'True'  /><wmi:qualifier name = 'read' type = 'boolean' array='False' value = 'True'  toSubclass = 'True'  /></wmi:property><wmi:method name = 'SetPowerState' ><wmi:parameter name = 'PowerState' type = 'uint16' ><wmi:qualifier name = 'CIMTYPE' type = 'string' array='False' value = 'uint16'  toSubclass = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'ID' type = 'uint32' array='False' value = '0'  toInstance = 'True'  /><wmi:qualifier name = 'IN' type = 'boolean' array='False' value = 'True'  /></wmi:parameter><wmi:parameter name = 'Time' type = 'wmi:datetime' ><wmi:qualifier name = 'CIMTYPE' type = 'string' array='False' value = 'datetime'  toSubclass = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'ID' type = 'uint32' array='False' value = '1'  toInstance = 'True'  /><wmi:qualifier name = 'IN' type = 'boolean' array='False' value = 'True'  /></wmi:parameter><wmi:returnval name='ReturnValue' type = 'uint16'><wmi:qualifier name = 'CIMTYPE' type = 'string' array='False' value = 'uint32'  toSubclass = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'out' type = 'boolean' array='False' value = 'True'  /></wmi:returnval></wmi:method><wmi:method name = 'Reset' ><wmi:returnval name='ReturnValue' type = 'uint16'><wmi:qualifier name = 'CIMTYPE' type = 'string' array='False' value = 'uint32'  toSubclass = 'True'  toInstance = 'True'  /><wmi:qualifier name = 'out' type = 'boolean' array='False' value = 'True'  /></wmi:returnval></wmi:method></xsd:appinfo></xsd:annotation><xsd:complexContent> <xsd:extension base = 'CIM_LogicalDisk'><xsd:group>
<xsd:all><xsd:element name = 'Compressed' type = 'xsd:boolean' minOccurs = '0' maxOccurs = '1' /><xsd:element name = 'DriveType' type = 'xsd:unsignedShort' minOccurs = '0' maxOccurs = '1' /><xsd:element name = 'FileSystem' type = 'xsd:string' minOccurs = '0' maxOccurs = '1' /><xsd:element name = 'MaximumComponentLength' type = 'xsd:unsignedShort' minOccurs = '0' maxOccurs = '1' /><xsd:element name = 'MediaType' type = 'xsd:unsignedShort' minOccurs = '0' maxOccurs = '1' /><xsd:element name = 'ProviderName' type = 'xsd:string' minOccurs = '0' maxOccurs = '1' /><xsd:element name = 'SupportsFileBasedCompression' type = 'xsd:boolean' minOccurs = '0' maxOccurs = '1' /><xsd:element name = 'VolumeName' type = 'xsd:string' minOccurs = '0' maxOccurs = '1' /><xsd:element name = 'VolumeSerialNumber' type = 'xsd:string' minOccurs = '0' maxOccurs = '1' /></xsd:all>
</xsd:group><xsd:anyAttribute/></xsd:extension>
</xsd:complexContent></xsd:complexType></xsd:schema>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\debug.txt ===
Q: How do i build the boot loader for debugging?

A: There are several things you must do.

First, you must set the ENABLE_LOADER_DEBUG environment variable
in your build window.  The var must be set to a string that specifies
the necessary debug settings for the machine that will be debugged.

Example: ENABLE_LOADER_DEBUG=debugport=com1##debugbaudrate=115200

Note the use of the '##' character.  The NT make files replace all
spaces in macro definitions with new lines, so you must use the
'##' character to specify that you REALLY want a space.  The above
example enables the kernel debugger in the boot loader and sets the
debug port to COM1 and the speed of the debug port to a baud rate
of 115200.

Another thing you must consider is the resulting size of the loader
binary.  The file must be kept below the 256k size or the loader will
hang your machine.  One may that you can expload the file size is
my disabling optimizations during compilation.  When you clean build
the BOOT directory your MSC_OPTIMIZATION variable must be set to
nothing.  This enables optimizations and results in the smallest file
size possible.  If you need to disable optimizations because of
debugging, you must do it selectivly.  This means clean building the
boot loader with optimizations enabled and then set MSC_OPTIMIZATION=/Odi
for the compilation of selective files.  Just be caureful to not
build to much of the boot loader this way or it will quickly grow
too large.

If you want to build the loader as a "free" build, but also get full
symbolic information for the debugger then use the following build
settings:

    set NTDEBUG=ntsdnodbg
    set NTDEBUGTYPE=windbg
    set MSC_OPTIMIZATION=
    set NTDBGFILES=1
    set ENABLE_LOADER_DEBUG=debugport=com1##debugbaudrate=115200

This will result in a free loader, with a dbg file containing full
symbolic information that can be used by i386kd/alphakd or even
by windbg for full source level debugging.

Addendum:

The following setting tells the loader to stop after loading symbols.

set ENABLE_LOADER_DEBUG=debugport=com1##debugbaudrate=115200##DEBUGSTOP


DbgPrint?

To get the loader to link, you need to also build ntos\rtl with the
ENABLE_LOADER_DEBUG flag set, otherwise DbgPrint will be unresolved.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\dbcs.txt ===
This file describes the nature of DBCS support in ntldr/setupldr.bin for x86.

On non-x86 machines we do nothing for now. The firmware is in control of the video
and thus the firmware is supposed to support displaying characters deemed necessary
by the system designer.

The x86 loaders operate using either standard 80x25 vga text mode or standard
640x480 graphics mode. In the latter case the loader display system paints
characters to simulate a console-type environment. Text mode is the default.

Early in initialization, the loader attempts to open a file called BOOTFONT.BIN
on the root of the drive from which boot is occurring (ie, in the same place where
it later expects to find ntdetect.com, boot.ini, etc). If that file is found and
is deemed valid, the display subsystem switches to graphics mode and is thus able
to display arbitrary glyphs. The font file gives such details as the dbcs lead byte
ranges, and so support in the loader display system is not dependent on any
particular codepage.

Thus we achieve single-binary and the ability to fully localize ntldr and
setupldr.bin for any locale.

See boot\lib\i386\bootfont.h for the format of the bootfont.bin file.

Note that Setup will install bootfont.bin. If this file becomes corrupt or the
user deletes it, the ntldr will fall back to sbcs support via vga text mode.
For this reason, it may be desirable to include English message resources
(as well as the ones for the particular localization) in ntldr so at least
the boot selection screens will be readable in English and not just display
as garbage.

Still to do some day, issues, problems, etc:

    - If non-x86 machines' firmware starts to support DBCS we should be able to
      extend support to these machines orthoganally since the x86 implementation
      is entirely 'hidden' in the ARC emulation layer. The only thing we would need
      is a mechanism to 'trigger' dbcs mode, which is performed by the presence of
      bootfont.bin on x86 machines.

    - The ARC console is driven by control sequences that are introduced with 0x9b.
      Unfortunately this is a valid lead byte char in several Far East code pages.
      In Japan this doesn't bite us because we don't actually use any characters that
      lead with 0x9b. The fix is to replace use of 0x9b with ESC[ (escape-left bracket)
      which is a synonym. However we don't know if all ARC firmware out there
      supports that as a synonym, so #ifdef _X86_ would probably be necessary
      (that would be ok since we are not enabling dbcs for non-x86 machines anyway).

- tedm, 7/11/95, Tokyo

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\spcrtest\readme.txt ===
This test will determine the existence and validity of an ACPI Serial Port Console Redirection (SPCR) table.  The test will attempt to detect this table, and if a valid table is discovered, several additional steps will be taken.

1. Several of the significant settings will be displayed.
2. The settings will be used to attempt initialization of a UART.

It is important to note that this test must be run in real-mode.  No OS support is required.  For that reason, the test poses as an OS loader and executes when the machines BIOS attempts to boot from media (putting the test on a floppy works very well).  The following steps should be used to prepare the test:

1. Format a floppy so that a boot sector gets written to it (this happens automatically under NT/Windows2000/Whistler).
2. Copy the test to the floppy, carefully renaming it "ntldr".
3. reboot the machine and allow it to boot from this floppy.



1. If no valid SPCR table is detected, a brief message is displayed on the system console informing the user.
2. Assuming a valid SPCR is found, several of the significant settings will be displayed.  The UART is then initialized and tested for authenticity (the data given in the SPCR table may not be pointing to a valid UART).
3. If the UART is deemed to be valid (a standard loopback test is used), then a validation message will be displayed.
4. If the UART is deemed to be valid, then a random string is generated.  The random string is then sent through the UART.  The test will then wait for the user to enter the string back.  The results of the users input are then tested against the original random string to ensure they match.
5. If the strings match, the user will see a confirmation message.
6. If the strings do *not* match, the user will see a confirmation message.
7. Once the test has completed, the test will create a file on the boot media called "spcrtest.txt".  A pass/failure message will be written to the logfile.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootfont\readme.txt ===
NOTE: To build bootfont.bin files, you MUST install and enable the language
support for the target language of the bootfont.bin you need to build.


To generate bootfont.bin files, you can build genfont.exe (in the genfont
directory).  Care should be taken to retrieve the proper fonttable.h file
*before* building genfont.exe.  The fonttable.h files for chs, cht, jpn,
and kor can be found on these directories.  Just drop these header files
into the genfont directory, then build and run genfont.exe.
To build the japanese bootfont.bin file using this method, you would:
1. start intl.cpl
2. Select "Japanese" language.  You might be required to have these support
   files installed from your installation media.
3. cd \nt\base\boot\bootfont\genfont
4. copy ..\jpn\fonttable.h .
5. build -cZP
6. obj\i386\genfont.exe .\bootfont.bin

To build a CHS, CHT, or KOR bootfont.bin file, just use the respective
fonttable.h files from those directories.
 


There is another way to build bootfont.bin files too.  You can
run convfont.exe, taking as input a legacy (circa build 2195) bootfont.bin
file and convfont.exe will convert this file into the new format.
To build the japanese bootfont.bin file using this method, you would:
1. start intl.cpl
2. Select "Japanese" language.  You might be required to have these support
   files installed from your installation media.
3. cd \nt\base\boot\bootfont\convert
5. build -cZP
6. obj\i386\convfont.exe ..\jpn\win2k_ver\bootfont.bin ..\jpn\bootfont.bin

To build any of the other bootfont.bin files, you must reset the language
via intl.cpl, reboot, then rerun convfont.exe on the target bootfont.bin file.


Here is a list of the current bootfont.bin files along with some other useful
data.

Locale Abbreviation         Locale                         Country Code     Locale String
===================         ======                         ============     =============      
BR                          Portuguese (Brazilian)         416              portuguese-brazilian
CHS                         Chinese PRC (simplified)       804              chinese-simplified
CHT                         Chinese Tiawan (traditional)   404              chinese-traditional
cS                          Czech                          405              czech
DA                          Danish                         406              danish
EL                          Greek                          408              greek
ES                          Spanish (default)              C0A              spanish
FI                          Finnish                        40B              finnish
FR                          French                         40C              french
GER                         German                         407              german
HU                          Hungarian                      40E              hungarian
IT                          Italian                        410              italian
JPN                         Japanese                       411              japanese
KOR                         Korean                         412              korean
NL                          Dutch (Netherlands)            413              dutch
NO                          Norwegian Bokmal               414              norwegian
PL                          Polish                         415              polish
PT                          Portuguese (default)           816              portuguese
RU                          Russian                        419              russian
SV                          Swedish                        41D              swedish
TR                          Turkish                        41F              turkish





-matth
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootfont\btgen\readme.txt ===
btgen is a tool that the localization team has used to generate bootfont.bin formany languages.  Note that it uses a different process than the genfont.exe tool.

it's unclear where the source code for btgen is now located, but the executable is checked in for safekeeping.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\lib\amd64\amd64.txt ===
The AMD64 kernel is loaded with an X86 loader.  This is to enable a single
loader to dual-boot either an i386 or Amd64 build.  The remainder of this 
text refers to only the i386 version of the loader.

There are two new AMD64-specific exports in boot.lib:

    ARC_STATUS
    BlAmd64CheckForLongMode(
        IN     ULONG LoadDeviceId,
        IN OUT PCHAR KernelPath,
        IN     PCHAR KernelFileName
        );
    
    extern BOOLEAN BlAmd64UseLongMode;

BlAmd64CheckForLongMode() is called from the loader.  If an AMD64 kernel 
image is found, then the global BlAmd64UseLongMode is set to TRUE.  From
this point forward, all images are expected to be AMD64 images.

Almost all of the code specific to AMD64 support is found in 
boot\lib\amd64.  At present, the contents of this directory is available to 
only a few people.  However the loader, obviously, must build for 
everybody.

To facilitate this, _X86AMD64_ is defined while building the boot\lib 
directory if files within the amd64 directory are present on the build 
machine.  If they are not present, then a stub version of 
BlAmd64CheckForLongMode() is created.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\acpienab\acpienab.txt ===
;
; Strings Section
;

[Strings]
MSFT="Microsoft"
GUID="ClassGUID"
SERVICE="Service"
REG_SZ=0x00000000
REG_DWORD=0x00010001


; ACPI CriticalDeviceDatabase Entry
CDD_ACPI="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0C08"
ACPI_GUID="{4D36E97D-E325-11CE-BFC1-08002BE10318}"
ACPI_SERVICE="acpi"

; Keyboard CriticalDeviceDatabase Entries
CDD_*PNP0300="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0300"
CDD_*PNP0301="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0301"
CDD_*PNP0302="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0302"
CDD_*PNP0303="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0303"
CDD_*PNP0304="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0304"
CDD_*PNP0305="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0305"
CDD_*PNP0306="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0306"
CDD_*PNP0309="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0309"
CDD_*PNP030A="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP030A"
CDD_*PNP030B="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP030B"
CDD_*PNP0320="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0320"
CDD_*CPQA0D7="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*CPQA0D7"
KEYBOARD_GUID="{4D36E96B-E325-11CE-BFC1-08002BE10318}"
KEYBOARD_SERVICE="i8042prt"

; Mouse CriticalDeviceDatabase Entries
CDD_*PNP0F00="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F00"
CDD_*PNP0F01="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F01"
CDD_*PNP0F02="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F02"
CDD_*PNP0F03="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F03"
CDD_*PNP0F08="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F08"
CDD_*PNP0F09="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F09"
CDD_*PNP0F0A="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F0A"
CDD_*PNP0F0B="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F0B"
CDD_*PNP0F0C="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F0C"
CDD_*PNP0F0D="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F0D"
CDD_*PNP0F0E="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F0E"
CDD_*PNP0F0F="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F0F"
CDD_*PNP0F11="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F11"
CDD_*PNP0F12="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F12"
CDD_*PNP0F13="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F13"
CDD_*PNP0F15="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F15"
CDD_*PNP0F1E="SYSTEM\CurrentControlSet\Control\CriticalDeviceDatabase\*PNP0F1E"
MOUSE_GUID="{4D36E96F-E325-11CE-BFC1-08002BE10318}"
MOUSE_SERVICE="i8042prt"

; ACPI Control Key
ACPI_KEY="SYSTEM\CurrentControlSet\Services\ACPI"
START="Start"
ACPI_ENABLE_VALUE=0
ACPI_DISABLE_VALUE=4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\dochange.txt ===
History of ASL/AML grammar changes in the ACPI Specification

Date        Description of Changes
----        ----------------------
11/23/98    In section 16.2.4.4, change:
                Data1 := ComputationalData
                Data2 := ComputationalData
              to:
                Data1 := TermArg=>ComputationalData
                Data2 := TermArg=>ComputationalData
            Clarification of the note in section 15.2.3.6.2, titled
              "Package - Declare Package Object".
            Added Object type 16 as the DebugObj type in section 15.2.3.4.2.28.
            Added clarification in section 15.2.3.4.2.30, titled
              "RefOf - Reference Of" to state the purpose of RefOf.
            Added clarification in section 15.2.3.3.1.12, titled
              "Mutex - Declare Synchronization Mutex Object" to state the
              default SyncLevel of various mutexes.
            Changed the AML grammar of DefPackage in section 16.2.4.4 to allow
              NameString as an package element.
            Added top level AML grammar definitions.
            Changed the AML grammar of UserTerm so that it returns DataObject
              instead of ComputationalData.
            Added the IfElse Term to the AML grammar that parallels the ASL
              grammar section.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\grammar.doc ===
Microsoft Word Document MSWordDoc Word.Document.8microsoft System Power Management Interface  Title _PID_GUIDSystem Power Management Interface  Annie Pearson Normal Michael Tsang Microsoft Word 8.08"+D8 qs\,&U6 8ntG4 jpQM4 @\\RED-PRN-01\26N/3MC CORP0092 172.31.224.252 Ne03: HP LaserJet 4Si/4Si MX PS HP LaserJet 4Si/4Si MX PS \\RED-PRN-01\26N/3MC CORP0092 1 Letter \\RED-PRN-01\26N/3MC CORP0092 1 LetterWr{O{~/ Iwkeq5 WjspWD:\toosday\kenr\ken.doc OLE_LINK14D:\toosday\kenr\ken.doc OLE_LINK14D:\toosday\kenr\ken.doc OLE_LINK14VISIO 4 Drawing VISIO 4.0 Shapes Visio.Drawing.4 Arial "System  Arial Command Address Slave Addressjames kardachVisio (TM) Drawing  Arial) s New Ro gPJ?@ |cb4u4 K/]/o/ _IO[O +.5,c F?2o~U03NVb 0Mf~[ pM___q_  2|ei)d lo~e# Si PS -  Custo m page 1 WINSPO HP 5S i PS - N \\SCSO FFLAN001 \sc9-2e1 ] z] r] j] bJ] Z] R] \!B] U:] 2] *] "] U 0fO*?  M?_0 Uj?|5 EP!O3OEO lave Add resso 'mAo]ooo2 mmandc ;0{%0 T_f_xS  +/=/O/ _M?_?q? O)O;OMO_OqO J_\_n_ 0bCa9oKeq /0/B/T/f/ /7?{_[? f8OJO\OnO Y_k_}_ o1oCoUo V/h/z/ ?_?9? O#O5O3 LO^OpO ra_s_ BE/W/i/[?m? OU_C? _-_@S?Q_ o%o7m Xojo|o Page-1 k fill White Greeun Yellow  dash1 Hairq Short Arial c top le T/imes ] r] d] U ] G] <] -] VISIO 4 Drawing VISIO 4.0 Shapes Visio.Drawing.4 Arial "System  Arial Slave Address (A6-A0)  Arialjames kardachVisio (TM) Drawing  Arial) s New Ro gPJ?@ |cb4u4 K/]/o/ _IO[O +.5,c F?2o~U03NVb 0Mf~[ pM___q_  2|ei)d lo~e# Si PS -  Custo m page 1 WINSPO HP 5S i PS - N \\SCSO FFLAN001 \sc9-2e1 9"L!L ?x$?6?H12 p5Py? M%\~o>O Slave A ddress ( A6-A0) _H1h1Z 5/G/Y,U, ;0{}  X3G>W< Efx?x .O>/, ON/*O *?<?N?`?r? 2EP;OMO_O-_ 8oJo\o Page-1 k fill White Greeun Yellow  dash1 Hairq Short Arial c top le T/imes ] r] d] U ] G] <] -] ACPI Source Language (ASL) Reference  XE "ACPI Source Language (ASL)"   XE "ASL"  This section formally defines the ACPI Control Method Source Language (ASL). ASL is a source language for writing ACPI control methods. OEMs and BIOS developers write control methods in ASL and then use a translator tool (compiler) to generate ACPI Machine Language (AML) versions of the control methods. For a formal definition of AML, see the ACPI Control Method Machine Language (AML) Specification, section 16. AML and ASL are different languages though they are closely related. Every ACPI-compatible OSes must support AML. A given user can define some arbitrary source language (to replace ASL) and write a tool to translate it to AML.  An OEM or BIOS vendor needs to write ASL and be able to single step AML for debugging. (Debuggers and similar tools are expected to be AML level tools, not source level tools.) An ASL translator implementer must understand how to read ASL and generate AML. An AML interpreter author must understand how to execute AML. This section has two parts: The ASL grammar, which is the formal ASL specification and also serves as a quick reference. A full ASL reference, which repeats the ASL term syntax and adds information about the semantics of the language. ASL Language Grammar  XE "ASL:grammer"  The purpose of this section is to state unambiguously the grammar rules used by the syntax checker of an ASL compiler.  ASL statements declare objects.  Each object has three parts, two of which can be null. Object := ObjectType  FixedList  VariableList FixedList refers to a list, of known length, that supplies data that all instances of a given ObjectType must have. A fixed list is written as ( a , b , c ,   ) where the number of arguments depends on the specific ObjectType, and some elements can be nested objects, that is (a, b, (q, r, s, t), d). Arguments to a FixedList can have default values, in which case they can be skipped.  Thus, (a,,c) will cause the default value for the second argument to be used. Some ObjectTypes can have a null FixedList, which is simply omitted. Trailing arguments of some object types can be left out of a fixed list, in which case the default value is used. VariableList refers to a list, not of predetermined length, of child objects that help define the parent.  It is written as { x, y, z, aa, bb, cc } where any argument can be a nested object. ObjectType determines what terms are legal elements of the VariableList. Some ObjectTypes may have a null variable list, which is simply omitted. Other rules for writing ASL statements are the following: Multiple blanks are the same as one.  Blank, (, ),   and newline are all token separators. // marks the beginning of a comment, which continues from the // to the end of the line. /* marks the beginning of a comment, which continues from the /* to the next */.  surround an ASCII string. Numeric constants can be written in two ways: ordinary decimal, or hexadecimal, using the notation 0xdd nothing indicates  an empty item. For example { nothing } is equivalent to {} ASL Grammar Notation The notation used to express the ASL grammar is specified in the following table. Table 15-1  ASL Grammar Notation Notation Convention Description Example Term := Term Term  The term to the left of := can be expanded into the sequence of terms on the right. aterm := bterm cterm means that aterm can be expanded into the two-term sequence of bterm followed by cterm. Angle brackets (< > ) Used to group items. <a b> | <c d> means either  a b or c d.  Bar symbol ( | ) Separates alternatives. aterm := bterm | <cterm dterm> means the following constructs are possible:    bterm     cterm dterm aterm := <bterm | cterm> dterm means the following constructs are possible:    bterm dterm    cterm dterm Term Term Term Terms separated from each other by spaces form an ordered list. Word in bold. Denotes the name of a term in the ASL grammar, representing any instance of such a term. In the following ASL term definition: ThermalZone (ZoneName)                       {NamedObjectList} the item in bold is the name of the term.           Word in italics Names of arguments to objects that are replaced for a given instance. In the following ASL term definition: ThermalZone (ZoneName)                       {NamedObjectList} the italicized item is an argument. The item that is not bolded or italicized is defined elsewhere in the ASL grammar. Single quotes ( Indicate constant characters. Refers to a byte value expressed as 2 hexadecimal digits. 0x21 means a value of hexadecimal 21, or decimal 37. Note that a value expressed in hexadecimal must start with a leading zero (0).  Dash character ( - ) Indicates a range. 1-9 means a single digit in the range 1 to 9 inclusive. ASL Names  XE "ASL Names"  LeadNameChar NameChar  | LeadNameChar RootChar NameSeg := <LeadNameChar NameChar NameChar NameChar> | <LeadNameChar NameChar NameChar> | <LeadNameChar NameChar> | <LeadNameChar> NameString := <RootChar NamePath> | <PrefixPath NamePath> PrefixPath := Nothing | <  PrefixPath> NamePath := Nothing | <NameSeg NamePathTail> NamePathTail := Nothing | <  NameSeg NamePathTail> ASL Language and Terms  XE "ASL Language and Terms"  ASLCode := DefinitionBlockTerm DefinitionBlockTerm := DefinitionBlock( AMLFileName, //String TableSignature, //String ComplianceRevision, //ByteConst OEMID, //String TableID, //String OEMRevision //DWordConst ) {TermList} TermList := Nothing | <Term TermList> := Object | Type1Opcode | Type2Opcode CompilerDirective := IncludeTerm | ExternalTerm ObjectList := Nothing | <Object ObjectList> Object := CompilerDirective | NamedObject | NameSpaceModifier | UserTerm DataObject := BufferTerm | PackageTerm | LiteralData | DataMacros LiteralData := Integer | String | ConstTerm ComputationalData := Integer | String | BufferTerm DataMacros := EISAIDTerm | ResourceTemplateTerm NamedObject := BankFieldTerm | CreateBitFieldTerm | CreateByteFieldTerm | CreateDWordFieldTerm | CreateFieldTerm | CreateWordFieldTerm | DeviceTerm | EventTerm | FieldTerm | IndexFieldTerm | MethodTerm | MutexTerm | OpRegionTerm | PowerResTerm | ProcessorTerm | ThermalZoneTerm NameSpaceModifier := AliasTerm | NameTerm | ScopeTerm UserTerm := NameString( //NameString=>MethodTerm ArgList ) => DataObject ArgList := Nothing | <TermArg ArgListTail> ArgListTail := Nothing | <  TermArg ArgListTail> TermArg := Type2Opcode | DataObject | UserTerm | ArgTerm | LocalTerm Type1Opcode := BreakTerm | BreakPointTerm | FatalTerm | IfElseTerm | LoadTerm | NoOpTerm | NotifyTerm | ReleaseTerm | ResetTerm | ReturnTerm | SignalTerm | SleepTerm | StallTerm | UnloadTerm | WhileTerm // A Type1OpCode term can only be used standing alone on a // line of ASL code; because these types of terms do not // return a value so they cannot be used as a term in an // expression. Type2Opcode := AcquireTerm | AddTerm | AndTerm | ConcatTerm | CondRefOfTerm | DecTerm | DerefOfTerm | DivideTerm | FindSetLeftBitTerm | FindSetRightBitTerm | FromBCDTerm | IncTerm | IndexTerm | LAndTerm | LEqualTerm | LGreaterTerm | LGreaterEqualTerm | LLessTerm | LLessEqualTerm | LNotTerm | LNotEqualTerm | LOrTerm | MatchTerm | MultiplyTerm | NAndTerm | NOrTerm | NotTerm | ObjectTypeTerm | OrTerm | RefOfTerm | ShiftLeftTerm | ShiftRightTerm | SizeOfTerm | StoreTerm | SubtractTerm | ToBCDTerm | WaitTerm | XorTerm // A Type2Opcode term returns a value that can be used in // an expression. IncludeTerm := Include( IncFilePathName //String ExternalTerm := External( ObjName, //NameString ObjType //Nothing | ObjectTypeKeyword BankFieldTerm := BankField( RegionName, //NameString BankName, //NameString BankValue, //TermArg=>DWordConst AccessType, //AccessTypeKeyword LockRule, //LockRuleKeyword UpdateRule //UpdateRuleKeyword ) {FieldUnitList} FieldUnitList := Nothing | <FieldUnit FieldUnitListTail> FieldUnitListTail := Nothing | <  FieldUnit FieldUnitListTail> FieldUnit := FieldUnitEntry | OffsetTerm | AccessAsTerm FieldUnitEntry := <Nothing | NameSeg>   Integer OffsetTerm := Offset( ByteOffset //Integer AccessAsTerm := AccessAs( AccessType, //AccessTypeKeyword AccessAttribute //Nothing | ByteConst CreateBitFieldTerm := CreateBitField( SourceBuffer, //TermArg=>BufferTerm BitIndex, //TermArg=>Integer BitFieldName //NameString CreateByteFieldTerm := CreateByteField( SourceBuffer, //TermArg=>BufferTerm ByteIndex, //TermArg=>Integer ByteFieldName //NameString CreateDWordFieldTerm := CreateDWordField( SourceBuffer, //TermArg=>BufferTerm ByteIndex, //TermArg=>Integer DWordFieldName //NameString CreateFieldTerm := CreateField( SourceBuffer, //TermArg=>BufferTerm BitIndex, //TermArg=>Integer NumBits, //TermArg=>Integer FieldName //NameString CreateWordFieldTerm := CreateWordField( SourceBuffer, //TermArg=>BufferTerm ByteIndex, //TermArg=>Integer WordFieldName //NameString DeviceTerm := Device( DeviceName //NameString ) {ObjectList} EventTerm := Event( EventName //NameString FieldTerm := Field( RegionName, //NameString AccessType, //AccessTypeKeyword LockRule, //LockRuleKeyword UpdateRule //UpdateRuleKeyword ) {FieldUnitList} IndexFieldTerm := IndexField( IndexName, //NameString DataName, //NameString AccessType, //AccessTypeKeyword LockRule, //LockRuleKeyword UpdateRule //UpdateRuleKeyword ) {FieldUnitList} MethodTerm := Method( MethodName, //NameString NumArgs, //Nothing | ByteConst SerializeRule //Nothing | //SerializeRuleKeyword ) {TermList} MutexTerm := Mutex( MutexName, //NameString SyncLevel //ByteConst OpRegionTerm := OperationRegion( RegionName, //NameString RegionSpace, //RegionSpaceKeyword Offset, //TermArg=>DWordConst Length //TermArg=>DWordConst PowerResTerm := PowerResource( ResourceName, //NameString SystemLevel, //ByteConst ResourceOrder //WordConst ) {ObjectList} ProcessorTerm := Processor( ProcessorName, //NameString ProcessorID, //ByteConst PBlockAddress, //DWordConst PblockLength //ByteConst ) {ObjectList} ThermalZoneTerm := ThermalZone( ThermalZoneName //NameString ) {ObjectList} AliasTerm := Alias( SourceObject, //NameString AliasObject //NameString NameTerm := Name( ObjectName, //NameString Object //DataObject ScopeTerm := Scope( Location //NameString ) {ObjectList} BreakTerm := Break BreakPointTerm := BreakPoint FatalTerm := Fatal( Type, //ByteConst Code, //DWordConst //TermArg=>Integer IfElseTerm := IfTerm ElseTerm IfTerm := If( Predicate //TermArg=>Integer ) {TermList} ElseTerm := Nothing | <Else {TermList}> LoadTerm := Load( Object, //NameString DDBHandle //SuperName NoOpTerm := Noop NotifyTerm := Notify( Object, //SuperName NotificationValue //TermArg=>ByteConst ReleaseTerm := Release( SyncObject //SuperName ResetTerm := Reset( SyncObject //SuperName ReturnTerm := Return( //TermArg=>DataObject SignalTerm := Signal( SyncObject //SuperName SleepTerm := Sleep( MilliSecs //TermArg=>Integer StallTerm := Stall( MicroSecs //TermArg=>Integer UnloadTerm := Unload( DDBHandle //SuperName WhileTerm := While( Predicate //TermArg=>Integer ) {TermList} AcquireTerm := Acquire( SyncObject, //SuperName TimeoutValue //WordConst ) => Boolean //Ones means timed-out AddTerm := Add( Addend1, //TermArg=>Integer Addend2, //TermArg=>Integer Result //Nothing | SuperName ) => Integer AndTerm := And( Source1, //TermArg=>Integer Source2, //TermArg=>Integer Result //Nothing | SuperName ) => Integer ConcatTerm := Concatenate( Source1, //TermArg=>ComputationalData Source2, //TermArg=>ComputationalData Result //Nothing | SuperName ) => ComputationalData CondRefOfTerm := CondRefOf( Source, //SuperName Destination //SuperName ) => Boolean DecTerm := Decrement( Addend //SuperName ) => Integer DerefOfTerm := DerefOf( Source //TermArg=>ObjectReference //ObjectReference is an object //produced by terms such as //Index, RefOf or CondRefOf. ) => ObjectReference DivideTerm := Divide( Dividend, //TermArg=>Integer Divisor, //TermArg=>Integer Remainder, //Nothing | SuperName Result //Nothing | SuperName ) => Integer //returns Result FindSetLeftBitTerm := FindSetLeftBit( Source, //TermArg=>Integer Result //Nothing | SuperName ) => Integer FindSetRightBitTerm := FindSetRightBit( Source, //TermArg=>Integer Result //Nothing | SuperName ) => Integer FromBCDTerm := FromBCD( BCDValue, //TermArg=>Integer Result //Nothing | SuperName ) => Integer IncTerm := Increment( Addend //SuperName ) => Integer IndexTerm := Index( Source, //TermArg=> //<BufferTerm | PackageTerm> Index, //TermArg=>Integer Destination //Nothing | SuperName ) => ObjectReference LAndTerm := LAnd( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean LEqualTerm := LEqual( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean LGreaterTerm := LGreater( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean LGreaterEqualTerm := LGreaterEqual( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean LLessTerm := LLess( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean LLessEqualTerm := LLessEqual( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean LNotTerm := LNot( Source, //TermArg=>Integer ) => Boolean LNotEqualTerm := LNotEqual( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean LOrTerm := LOr( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean MatchTerm := Match( SearchPackage, //TermArg=>Package //MatchOpKeyword MatchObject1, //TermArg=>Integer //MatchOpKeyword MatchObject2, //TermArg=>Integer StartIndex //TermArg=>Integer ) => Ones | Integer MultiplyTerm := Multiply( Multiplicand, //TermArg=>Integer Multiplier, //TermArg=>Integer Result //Nothing | SuperName ) => Integer NAndTerm := NAnd( Source1, //TermArg=>Integer Source2 //TermArg=>Integer Result //Nothing | SuperName ) => Integer NOrTerm := NOr( Source1, //TermArg=>Integer Source2 //TermArg=>Integer Result //Nothing | SuperName ) => Integer NotTerm := Not( Source, //TermArg=>Integer Result //Nothing | SuperName ) => Integer ObjectTypeTerm := ObjectType( Object //SuperName ) => Integer OrTerm := Or( Source1, //TermArg=>Integer Source2 //TermArg=>Integer Result //Nothing | SuperName ) => Integer RefOfTerm := RefOf( Object //SuperName ) => ObjectReference ShiftLeftTerm := ShiftLeft( Source, //TermArg=>Integer ShiftCount //TermArg=>Integer Result //Nothing | SuperName ) => Integer ShiftRightTerm := ShiftRight( Source, //TermArg=>Integer ShiftCount //TermArg=>Integer Result //Nothing | SuperName ) => Integer SizeOfTerm := SizeOf( DataObject //SuperName=>DataObject ) => Integer StoreTerm := Store( Source, //TermArg=>DataObject Destination //SuperName ) => DataObject SubtractTerm := Subtract( Addend1, //TermArg=>Integer Addend2, //TermArg=>Integer Result //Nothing | SuperName ) => Integer ToBCDTerm := ToBCD( Value, //TermArg=>Integer Result //Nothing | SuperName ) => Integer WaitTerm := Wait( SyncObject, //SuperName TimeoutValue //TermArg=>Integer ) => Boolean XOrTerm := XOr( Source1, //TermArg=>Integer Source2 //TermArg=>Integer Result //Nothing | SuperName ) => Integer ObjectTypeKeyword := UnknownObj | IntObj | StrObj | BuffObj | PkgObj | FieldUnitObj | DeviceObj | EventObj | MethodObj | MutexObj | OpRegionObj | PowerResObj | ThermalZoneObj | BuffFieldObj | DDBHandleObj AcessTypeKeyword := AnyAcc | ByteAcc | WordAcc | DWordAcc | BlockAcc | SMBSendRecvAcc | SMBQuickAcc LockRuleKeyword := Lock | NoLock UpdateRuleKeyword := Preserve | WriteAsOnes | WriteAsZeros RegionSpaceKeyword := UserDefRegionSpace | SystemIO | SystemMemory | PCI_Config | EmbeddedControl | SMBus UserDefRegionSpace := 0x80-0xff SerializeRuleKeyword := Serialized | NotSerialized MatchOpKeyword := MTR | MEQ | MLE | MLT | MGE | MGT DMATypeKeyword := Compatibility | TypeA | TypeB | TypeF BusMasterKeyword := BusMaster | NotBusMaster XferTypeKeyword := Transfer8 | Transfer16 | Transfer8_16 ResourceTypeKeyword := ResourceConsumer | ResourceProducer MinKeyword := MinFixed | MinNotFixed MaxKeyword := MaxFixed | MaxNotFixed DecodeKeyword := SubDecode | PosDecode RangeTypeKeyword := ISAOnlyRanges | NonISAOnlyRanges | EntireRange MemTypeKeyword := Cacheable | WriteCombining | Prefetchable | NonCacheable ReadWriteKeyword := ReadWrite | ReadOnly InterruptTypeKeyword := Edge | Level InterruptLevel := ActiveHigh | ActiveLow ShareTypeKeyword := Shared | Exclusive IODecodeKeyword := Decode16 | Decode10 SuperName := NameString | ArgTerm | LocalTerm | DebugTerm | IndexTerm ArgTerm := Arg0 | Arg1 | Arg2 | Arg3 | Arg4 | Arg5 | Arg6 LocalTerm := Local0 | Local1 | Local2 | Local3 | Local4 | Local5 | Local6 | Local7 DebugTerm := Debug Integer := ByteConst | WordConst | DWordConst ByteConst := 0x00-0xff WordConst := 0x0000-0xffff DWordConst := 0x00000000-0xffffffff String  AsciiCharList  AsciiCharList := Nothing | <AsciiChar AsciiCharList> AsciiChar := 0x01-0x7f NullChar := 0x00 ConstTerm := Zero | One | Ones | Revision Boolean := True | False := Ones False := Zero BufferTerm := Buffer( BuffSize //Nothing | //TermArg=>Integer ) {String | ByteList} ByteList := Nothing | <ByteConst ByteListTail> ByteListTail := Nothing | <  ByteConst ByteListTail> DWordList := Nothing | <DWordConst DWordListTail> DWordListTail := Nothing | <  DWordConst DWordListTail> PackageTerm := Package( NumElements //Nothing | //ByteConst ) {PackageList} PackageList := Nothing | <PackageElement PackageListTail> PackageListTail := Nothing | <  PackageElement PackageListTail> PackageElement := DataObject | NameString EISAIDTerm := EISAID( EISAIDString //String ) => DWordConst ResourceTemplateTerm := ResourceTemplate() {ResourceMacroList} => BufferTerm ResourceMacroList := Nothing | <ResourceMacroTerm ResourceMacroList> ResourceMacroTerm := DMATerm | DWordIOTerm | DWordMemoryTerm | EndDependentFnTerm | FixedIOTerm | InterruptTerm | IOTerm | IRQNoFlagsTerm | IRQTerm | Memory24Term | Memory32FixedTerm | Memory32Term | QWordIOTerm | QWordMemoryTerm | StartDependentFnTerm | StartDependentFnNoPriTerm | VendorLongTerm | VendorShortTerm | WordBusNumberTerm | WordIOTerm DMATerm := DMA( DMAType, //DMATypeKeyword (_TYP) BusMaster, //BusMasterKeyword (_BM) XferType, //XferTypeKeyword (_SIZ) ResourceTag //Nothing | NameString ) {ByteList} //List of channels (0-17) DWordIOTerm := DWORDIO( ResourceType, //Nothing (ResourceConsumer)| //ResourceTypeKeyword MinType, //Nothing (MinNotFixed) | //MinKeyword (_MIF) MaxType, //Nothing (MaxNotFixed) | //MaxKeyword (_MAF) Decode, //Nothing (PosDecode) | //DecodeKeyword (_DEC) RangeType, //Nothing (EntireRange) | //RangeTypeKeyword (_RNG) AddressGranularity, //DWordConst (_GRA) MinAddress, //DWordConst (_MIN) MaxAddress, //DWordConst (_MAX) Translation, //DWordConst (_TRA) AddressLen, //DWordConst (_LEN) ResSourceIndex, //Nothing | ByteConst ResSource, //Nothing | String ResourceTag //Nothing | NameString DWordMemoryTerm := DWORDMemory( ResourceType, //Nothing (ResourceConsumer)| //ResourceTypeKeyword Decode, //Nothing (PosDecode) | //DecodeKeyword (_DEC) MinType, //Nothing (MinNotFixed) | //MinKeyword (_MIF) MaxType, //Nothing (MaxNotFixed) | //MaxKeyword (_MAF) MemType, //Nothing (NonCacheable) | //MemTypeKeyword (_MEM) ReadWriteType, //ReadWriteKeyword (_RW) AddressGranularity, //DWordConst (_GRA) MinAddress, //DWordConst (_MIN) MaxAddress, //DWordConst (_MAX) Translation, //DWordConst (_TRA) AddressLen, //DWordConst (_LEN) ResSourceIndex, //Nothing | ByteConst ResSource, //Nothing | String ResourceTag //Nothing | NameString EndDependentFnTerm := EndDependentFn() FixedIOTerm := FixedIO( AddressBase, //WordConst (_BAS) RangeLen, //ByteConst (_LEN) ResourceTag //Nothing | NameString InterruptTerm := Interrupt( ResourceType, //Nothing (ResourceConsumer)| //ResourceTypeKeyword InterruptType, //InterruptTypeKeyword //(_LL, _HE) InterruptLevel, //InterruptLevelKeyword //(_LL, _HE) ShareType, //Nothing (Exclusive) //ShareTypeKeyword (_SHR) ResSourceIndex, //Nothing | ByteConst ResSource, //Nothing | String ResourceTag //Nothing | NameString ) {DWordList} //list of interrupts (_INT) IOTerm := IO( IODecode, //IODecodeKeyword (_DEC) MinAddress, //WordConst (_MIN) MaxAddress, //WordConst (_MAX) Alignment, //ByteConst (_ALN) RangeLen, //ByteConst (_LEN) ResourceTag //Nothing | NameString IRQNoFlagsTerm := IRQNoFlags( ResourceTag //Nothing | NameString ) {ByteList} //list of interrupts (0-15) IRQTerm := IRQ( InterruptType, //InterruptTypeKeyword //(_LL, _HE) InterruptLevel, //InterruptLevelKeyword //(_LL, _HE) ShareType, //Nothing (Exclusive) //ShareTypeKeyword (_SHR) ResourceTag //Nothing | NameString ) {ByteList} //list of interrupts (0-15) Memory24Term := Memory24( ReadWriteType, //ReadWriteKeyword (_RW) MinAddress[23:8], //WordConst (_MIN) MaxAddress[23:8], //WordConst (_MAX) Alignment, //WordConst (_ALN) RangeLen, //WordConst (_LEN) ResourceTag //Nothing | NameString Memory32FixedTerm := Memory32Fixed( ReadWriteType, //ReadWriteKeyword (_RW) AddressBase, //DWordConst (_BAS) RangeLen, //DWordConst (_LEN) ResourceTag //Nothing | NameString Memory32Term := Memory32( ReadWriteType, //ReadWriteKeyword (_RW) MinAddress, //DWordConst (_MIN) MaxAddress, //DWordConst (_MAX) Alignment, //DWordConst (_ALN) RangeLen, //DWordConst (_LEN) ResourceTag //Nothing | NameString QWordIOTerm := QWORDIO( ResourceType, //Nothing (ResourceConsumer)| //ResourceTypeKeyword MinType, //Nothing (MinNotFixed) | //MinKeyword (_MIF) MaxType, //Nothing (MaxNotFixed) | //MaxKeyword (_MAF) Decode, //Nothing (PosDecode) | //DecodeKeyword (_DEC) RangeType, //Nothing (EntireRange) | //RangeTypeKeyword (_RNG) AddressGranularity, //QWordConst (_GRA) MinAddress, //QWordConst (_MIN) MaxAddress, //QWordConst (_MAX) Translation, //QWordConst (_TRA) AddressLen, //QWordConst (_LEN) ResSourceIndex, //Nothing | ByteConst ResSource, //Nothing | String ResourceTag //Nothing | NameString QWordMemoryTerm := QWORDMemory( ResourceType, //Nothing (ResourceConsumer)| //ResourceTypeKeyword Decode, //Nothing (PosDecode) | //DecodeKeyword (_DEC) MinType, //Nothing (MinNotFixed) | //MinKeyword (_MIF) MaxType, //Nothing (MaxNotFixed) | //MaxKeyword (_MAF) MemType, //Nothing (NonCacheable) | //MemTypeKeyword (_MEM) ReadWriteType, //ReadWriteKeyword (_RW) AddressGranularity, //QWordConst (_GRA) MinAddress, //QWordConst (_MIN) MaxAddress, //QWordConst (_MAX) Translation, //QWordConst (_TRA) AddressLen, //QWordConst (_LEN) ResSourceIndex, //Nothing | ByteConst ResSource, //Nothing | String ResourceTag //Nothing | NameString StartDependentFnTerm := StartDependentFn( CompatPriority, //ByteConst (0-2) PerfRobustPriority //ByteConst (0-2) ) {ResourceMacroList} StartDependentFnNoPriTerm :=StartDependentFnNoPri() {ResourceMacroList} VendorLongTerm := VendorLong( ResourceTag //Nothing | NameString ) {ByteList} VendorShortTerm := VendorShort( ResourceTag //Nothing | NameString ) {ByteList} //up to 7 bytes WordBusNumberTerm := WordBusNumber( ResourceType, //Nothing (ResourceConsumer)| //ResourceTypeKeyword MinType, //Nothing (MinNotFixed) | //MinKeyword (_MIF) MaxType, //Nothing (MaxNotFixed) | //MaxKeyword (_MAF) Decode, //Nothing (PosDecode) | //DecodeKeyword (_DEC) AddressGranularity, //WordConst (_GRA) MinAddress, //WordConst (_MIN) MaxAddress, //WordConst (_MAX) Translation, //WordConst (_TRA) AddressLen, //WordConst (_LEN) ResSourceIndex, //Nothing | ByteConst ResSource, //Nothing | String ResourceTag //Nothing | NameString WordIOTerm := WordIO( ResourceType, //Nothing (ResourceConsumer)| //ResourceTypeKeyword MinType, //Nothing (MinNotFixed) | //MinKeyword (_MIF) MaxType, //Nothing (MaxNotFixed) | //MaxKeyword (_MAF) Decode, //Nothing (PosDecode) | //DecodeKeyword (_DEC) RangeType, //Nothing (EntireRange) | //RangeTypeKeyword (_RNG) AddressGranularity, //WordConst _GRA) MinAddress, //WordConst (_MIN) MaxAddress, //WordConst (_MAX) Translation, //WordConst (_TRA) AddressLen, //WordConst (_LEN) ResSourceIndex, //Nothing | ByteConst ResSource, //Nothing | String ResourceTag //Nothing | NameString Full ASL Reference This reference section is for developers who are writing ASL code while developing definition blocks for platforms.  ASL Names  XE "ASL:names"  This section describes how to encode object names using ASL. The following table lists the characters legal in any position in an ASL object name.   Table 15-2  Control Method Named Object Reference Encodings Value Description 41-5A, 5F Lead character of name ( LeadNameChar 30-39, 41-5A,  5F Non-lead (trailing) character of name ( 0 - 9 NameChar The following table lists the name modifiers. Table 15-3  Definition Block Name Modifier Encodings Description NamePrefix := Followed by  Name space root ( RootPrefix  Name Parent name space ( ParentPrefix  Name Name extender: 1 DualNamePrefix  Name Name Name extender: N MultiNamePrefix  count  Namecount ASL Data Types  XE "ASL:data types"  The contents of an object, or the data it references, may be abstract entities (for example,  Device Object ) or can be one of three computational data types. The computational data type can be used as arguments to many of the ASL Operator terms. Table 15-4  Data Types Data Type Description Integer 32-bit little endian unsigned value.  Buffer Arbitrary fixed length array of bytes. String ASCIIZ string 1 to 200 characters in length (including NullChar).   ASL Terms  XE "ASL:terms"  This section describes all the ASL terms and provides sample ASL code that uses the terms. The ASL terms are grouped into the following categories: Definition block term Compiler directive terms Object terms Opcode terms User terms Data objects Miscellaneous objects Definition Block Term DefinitionBlockTerm := DefinitionBlock( AMLFileName, //String TableSignature, //String ComplianceRevision, //ByteConst OEMID, //String TableID, //String OEMRevision //DWordConst ) {TermList} The DefinitionBlock term specifies the unit of data and/or AML code that the OS will load as part of the Differentiated Definition Block or as part of an additional Definition Block. This unit of data and/or AML code describes either the base system or some large extension (such as a docking station). The entire DefinitionBlock will be loaded and compiled by the OS as a single unit, and can be unloaded by the OS as a single unit. Compiler Directive Terms The compiler directives are: Include term External term Include   Include Another ASL File IncludeTerm := Include( IncFilePathName //String IncFilePathname is the full OS file system path to another file that contains ASL terms to be included in the current file of ASL terms. External   Declare External Objects ExternalTerm := External( ObjName, //NameString ObjType //Nothing | ObjectTypeKeyword The External compiler directive is to let the assembler know that the object is declared external to this table so that the assembler will not complain about the undeclared object.  During compiling, the assembler will create the external object at the specified place in the name space (if a full path of the object is specified), or the object will be created at the current scope of the External term.  ObjType is optional.  If not specified, "UnknownObj" type is assumed. Object Terms Object terms includes: Named Object terms and Name Space Modifiers. Named Object Terms  XE "ASL:named object terms"   XE "named object terms" \t "See ASL"  The ASL terms that can be used to create named objects in a definition block are listed in the following table. Table 15-5  Named Object Terms ASL Statement Description BankField Declares fields in a banked configuration object. CreateBitField Declare a bit field object of a buffer object. CreateByteField Declare a byte field object of a buffer object. CreateDWordField Declare a dword field object of a buffer object. CreateField Declare a field object of any bit length of a buffer object. CreateWordField Declare a dword field object of a buffer object. Device Declares a bus/device object.  Event Declares an event synchronization object. Field Declares fields of an operation region object. IndexField Declares fields in an index/data configuration object. Method Declares a control method. Mutex Declares a mutex synchronization object. OperationRegion Declares an operational region. PowerResource Declares a power resource object. Processor Declares a processor package. ThermalZone Declares a thermal zone package. BankField - Declare Bank/Data Field BankFieldTerm := BankField( RegionName, //NameString BankName, //NameString BankValue, //TermArg=>DWordConst AccessType, //AccessTypeKeyword LockRule, //LockRuleKeyword UpdateRule //UpdateRuleKeyword ) {FieldUnitList} This statement creates data field objects. The contents of the created objects are obtained by a reference to a bank selection register. This encoding is used to define named data field objects whose data values are fields within a larger object selected by a bank selected register. Accessing the contents of a banked field data object will occur automatically through the proper bank setting, with synchronization occurring on the operation region that contains the BankName data variable, and on the global lock if specified by the LockRule.    The AccessType, LockRule, UpdateRule, and FieldUnitList are the same format as the Field operator. The following is a block of ASL sample code using BankField: Creates a 4-bit bank select register in system I/O space. Creates overlapping fields in the same system I/O space which are selected via the bank register. // define 256-byte operational region in SystemIO space // and name it GIO0  OperationRegion (GIO0, SystemIO, 0x125, 0x100) // create some field in GIO including a 4 bit bank select register  Field (GIO0, ByteAcc, NoLock, Preserve) { GLB1, 1, GLB2, 1, Offset(1), // move to offset for byte 1 BNK1, 4 // Create FET0 & FET1 in bank 0 at byte offset 0x30 BankField (GIO0, BNK1, 0, ByteAcc, NoLock, Preserve) { Offset (0x30), FET0, 1, FET1, 1 // Create BLVL & BAC in bank 1 at the same offset BankField (GIO0, BNK1, 1, ByteAcc, NoLock, Preserve) { Offset (0x30), BLVL, 7, BAC,  1 CreateBitField CreateBitFieldTerm := CreateBitField( SourceBuffer, //TermArg=>BufferTerm BitIndex, //TermArg=>Integer BitFieldName //NameString  XE "ASL:CreateBitField"   XE "CreateBitField" \t "See ASL"  SourceBuffer is evaluated as a buffer.  BitIndex is evaluated as an integer.  A new buffer field object BitFieldName is created for the bit of SourceBuffer at the bit index of BitIndex.  The bit-defined field within SourceBuffer must exist. CreateByteField CreateByteFieldTerm := CreateByteField( SourceBuffer, //TermArg=>BufferTerm ByteIndex, //TermArg=>Integer ByteFieldName //NameString  XE "ASL:CreateByteField"   XE "CreateByteField" \t "See ASL"  SourceBuffer is evaluated as a buffer.  ByteIndex is evaluated as an integer.  A new buffer field object ByteFieldName is created for the byte of SourceBuffer at the byte index of ByteIndex.  The byte-defined field within SourceBuffer must exist. CreateDWordField CreateDWordFieldTerm := CreateDWordField( SourceBuffer, //TermArg=>BufferTerm ByteIndex, //TermArg=>Integer DWordFieldName //NameString  XE "ASL:CreateDWordField"   XE "CreateDWordField" \t "See ASL"  SourceBuffer is evaluated as a buffer.  ByteIndex is evaluated as an integer.  A new buffer field object DWordFieldName is created for the DWord of SourceBuffer at the byte index of ByteIndex.  The DWord-defined field within SourceBuffer must exist. CreateField - Field CreateFieldTerm := CreateField( SourceBuffer, //TermArg=>BufferTerm BitIndex, //TermArg=>Integer NumBits, //TermArg=>Integer FieldName //NameString  XE "ASL:CreateField - Field"   XE "CreateField - Field" \t "See ASL"  SourceBuffer is evaluated as a buffer.  BitIndex and NumBits are evaluated as integers.  A new buffer field object FieldName is created for the bits of SourceBuffer at BitIndex for NumBits.  The entire bit range of the defined field within SourceBuffer must exist. CreateWordField  CreateWordFieldTerm := CreateWordField( SourceBuffer, //TermArg=>BufferTerm ByteIndex, //TermArg=>Integer WordFieldName //NameString  XE "ASL:CreateWordField"   XE "CreateWordField" \t "See ASL"  SourceBuffer is evaluated as a buffer.  ByteIndex is evaluated as an integer.  A new bufferfield object WordFieldName is created for the word of SourceBuffer at the word index of ByteIndex.  The word-defined field within SourceBuffer must exist. Device - Declare Bus/Device Package DeviceTerm := Device( DeviceName //NameString ) {ObjectList}  XE "ASL:Device-Declare Bus/Device Package"  Creates a Device object, which represents either a bus or a device or any other such entity of use. Device opens a name scope. A Bus/Device Package is one of the basic ways the Differentiated Definition Block describes the hardware devices in the system to the operating software. Each Bus/Device Package is defined somewhere in the hierarchical name space corresponding to that device s location in the system. Within the name space of the device are other names that provide information and control of the device, along with any sub-devices that in turn describe sub-devices, and so on. For any device, the BIOS provides only information that is added to the device in a non-hardware standard manner. This type of  value added  function is expressible in the ACPI Definition Block such that operating software can use the function.   The BIOS supplies Device Objects only for devices that are obtaining some system-added function outside the device s normal capabilities and for any Device Object required to fill in the tree for such a device. For example, if the system includes a PCI device (integrated or otherwise) with no additional functions such as power management, the BIOS would not report such a device; however, if the system included an integrated ISA device below the integrated PCI device (device is an ISA bridge), then the system would include a Device Package for the ISA device with the minimum feature being added being the ISA device s ID and configuration information and the parent PCI device, because it is required to get the ISA Device Package placement in the Name Space correct. The following block of ASL sample code shows a nested use of Device objects to describe an IDE controller connected to the root PCI bus.  Device (IDE0) { // primary controller Name(_ADR, 0) // put PCI Address (device/function) here // define region for IDE mode register OperationRegion (PCIC, PCI_Config, 0x50, 0x10) Field (PCIC, AnyAcc, NoLock, Preserve) { Device(PRIM) { //Primary adapter Name(_ADR, 0) //Primary adapter = 0 Device(MSTR) { // master channel Name(_ADR, 0) Name(_PR0, Package(){0, PIDE}) Method (_STM, 2) { Device(SLAV) { Name(_ADR, 1) Name(_PR0, Package(){0, PIDE}) Method (_STM, 2) { Event - Declare Event Synchronization Object EventTerm := Event( EventName //NameString Creates an event synchronization object named EventName.  XE "ASL:Event-Declare Event Synchcronization Object"  For more information about the uses of an event synchronization object, see the ASL definitions for the Wait, Signal, and Reset function operators. Field - Declare Field Objects FieldTerm := Field( RegionName, //NameString AccessType, //AccessTypeKeyword LockRule, //LockRuleKeyword UpdateRule //UpdateRuleKeyword ) {FieldUnitList}  XE "ASL:Field - Declare Field Objects"  Declares a series of named data objects whose data values are fields within a larger object. The fields are parts of the object named by RegionName, but their names appear in the same scope as the Field term. For example, the field operator allows a larger operation region that represents a hardware register to be broken down into individual bit fields that can then be accessed by the bit field names. Extracting and combining the component field from its parent is done automatically when the field is accessed.  Accessing the contents of a field data object provides access to the corresponding field within the parent object.   If the parent object supports Mutex synchronization, accesses to modify the component data objects  will acquire and release ownership of the parent object around the modification.  All accesses within the parent object are performed naturally aligned. If desired, AccessType can be used to force minimum access width. Note that the parent object must be able to accommodate the AccessType width.  For example, an access type of WordAcc cannot read the last byte of an odd-length operation region. Not all access types are meaningful for every type of operational region.  The following table relates region types declared with an OperationRegion term to the different access types supported for each region. Table 15-6  OperationRegion Region Types and Access Types  Region Types Access Type Description SystemMemory ByteAcc SystemIO WordAcc PCI_Config DWordAcc AnyAcc Read/Write Byte, Word, DWord access EmbeddedControl  ByteAcc SMBus ByteAcc Read/Write SMBus byte protocol WordAcc Read/Write SMBus word protocol BlockAcc Read/Write SMBus block protocol AnyAcc Read/Write linear SMBus byte, word, block protocol SMBSendRecvAcc Send/Receive SMBus protocol SMBQuickAcc QuickRead/QuickWrite SMBus protocol If LockRule is set to Lock, accesses to modify the component data objects will acquire and release the global lock. If both types of locking occur, the global lock is acquired after the parent object Mutex. UpdateRule is used to specify how the unmodified bits of a field are treated. For example, if a field defines a component data object of 4 bits in the middle of a WordAcc region, when those 4 bits are modified the UpdateRule specifies how the other 12 bits are treated.    The named data objects are provided in FieldList as a series of names and bit widths. Bits assigned no name (or NULL) are skipped. The ASL compiler supports an Offset(ByteOffset) macro within a FieldList to skip to the bit position of the supplied byte offset.   For support of non-linear address devices, such as SMBus devices, a protocol is required to be associated with each command value. The ASL compiler supports the AccessAs(AccessType, AccessAttribute) macro within a FieldList. The AccessAttribute portion of the macro is interpreted differently depending on the address space.  For SystemMemory, SystemIO, PCI_Config or EmbeddedControl space the AccessAttribute is reserved.  For SMBus devices the AccessAttribute indicates the command value of the SMBus device to use for the field being defined. The AccessAttribute allows a specific protocol to be associated with the fields following the macro and can contain any of the Access Type listed in the table. SMBus Slave Address  XE "ASL:SmBus slave address"  SMBus device Addressing supports both a linear and non-linear addressing mechanism.  This section clarifies how ACPI treats these types of devices and how they should be defined and accessed.  SMBus devices are defined to have a fixed 7-bit slave address.  This can be illustrated by the smart battery subsystem devices: Table 15-7  Examples of SMBus Devices and Slave Addresses SMBus Device Description Slave Address (A0-A6) SMBus Host Slave Interface SBS Charger SBS Selector SBS Battery The SMBus driver expects a 7-bit slave address for the device to be passed to it.  The 1.0 System Management Bus specification defines the address protocols (how data is passed on the wiggling pins) as: EMBED Unknown Figure 15-1  SMBus Slave Address Protocol This indicates that bit 0 of the protocol represents whether this access is a read or write cycle, and the next six bits represent the slave address. Note that the driver expects a zero-based address, not a one-based address.  For example, the SBS battery has a slave address of 0xB, or 0001011b (bits 0, 1 and 4 being set). This value is represented by 0x16 for writes or 0x17 for reads to the smart battery in the SMBus protocol format. The protocol format of the slave address and the actual slave address should not be confused as the SMBus driver expects the actual slave address, not the protocol format with the read/write value; the driver will shift the slave address left by 1 bit and mask in the read/write protocol. SMBus Addressing  XE "ASL:SMBus addressing"  Associated with each SMBus device is an 8-bit command register that represents an additional address space within the device, allowing up to 256 registers within an SMBus device. For some devices this is treated as a linear address space; for other devices such as the Smart Battery, this is treated as a non-linear address space.  The SMBus driver differentiates these types of devices so that it can understand how to use the different SMBus protocols on the device. A linear address device treats the command and slave address fields as a byte-linear 15-bit address space where the address is formed as follows: EMBED Unknown Figure 15-2  SMBus Linear Address Decode For example an SMBus memory device that consumes slave address 0x40 would be accessing a linear address range of 0x4000-0x40FF (256 bytes of address space). A byte access to 0x4000 (slave 0x40, command 0) would access byte location 0x4000 (slave 0x40, command 0), and a word access to 0x4000 (slave 0x40, command 0) would access byte locations 0x4000-0x4001 (slave 0x40, commands 0-1). For a device that behaves in this manner, ASL should indicate an AnyAcc in the field operator defining the SMBus device.  This indicates to the SMBus driver that it can use the read/write block, read/write word, or read/write byte protocols to access this device. A non-linear address device (such as the smart battery) defines each command value within the device to be a potentially different size.  The ACPI driver treats such a device differently from a linear address device by only accessing command values with the specified protocol only.  For example the smart battery device has a slave address of 0xB and a definition for the first two command values as follows: Table 15-8    XE "smart battery:example command codes"  Example Command Codes from the Smart Battery Command Address Data Type  Protocol to Access Manufacture Access Word Read/Write Remaining Capacity Alarm Word Read/Write Remaining Time Alarm Word Read/Write Manufacture Name Block Read/Write Device Name Block Read/Write The Smart Battery uses a non-linear programming model. Each command register can be a different size and has a specific SMBus protocol associated with it. For example command register 0x0 contains a word of data (which in a linear device would take up two command registers 0 and 1) that represents the  Manufacture Access  and command register 0x1 contains the next word of data (which in a linear device would take up two command registers 0 and 1) that represents the  Remaining Capacity.  In a linear address model these registers would overlap; however, this is legitimate SMBus device definition. As a further example command register 0x20 can represent up to 32 bytes of data (block read/write) and command register 0x21 also represents up to 32 bytes of data. SMBus Protocols  XE "ASL:SMBus protocols"  This section describes the different SMBus protocols and how the SMBus driver treats them. It also gives examples of how to define and then access such devices in ASL. Quick Protocol (QuickAcc)  XE "SMBus protocols:quick protocol (QuickAcc)"  The SMBus Quick protocol does not transfer any data. This protocol is used to control simple devices and consists of the slave address with the R/W bit set high or low. Therefore, two types of Quick commands can be generated:  QuickRead with the R/W protocol bit reset LOW or QuickWrite with the R/W protocol bit set HIGH. A device defined to use the quick protocol has no command registers, and consumes the entire 7-bit slave address.   To define a quick device an operation region is generated using the SMBus address type.  Next a field is generated in the operation region using the  QuickAcc  access type.  To generate a QuickWrite protocol to this device,  ASL would generate a write to this field.  To generate a QuickRead protocol to this device, ASL would generate a read to this field.  Note that even though the ASL read the field and a QuickRead protocol was sent to the device, the device does not return any data and the numeric result returned by the SMB driver to the ASL will be 0. For example, Device(\_SB.EC0) { Name(_HID, EISAID("PNP0C09")) Name(_CRS,  ResourceTemplate(){ // port 0x62 and 0x66 IO(Decode16, 0x62, 0x62, 0, 1), IO(Decode16, 0x66, 0x66, 0, 1) Name(_GPE, Zero) //EC is wired to bit 0 of GPE Device (SMB1) { Name(_ADR, "ACPI0001") Name(_EC, 0x8030) // EC offset(0x80), Query (0x30) OperationRegion(PHO1, SMBus, 0x61, 0x1) Device(DEVA){ Name(_ADR, 0x61) // Slave Address 0x61 Field(PHO1, QuickAcc, NoLock, Preserve) { QCKA, // end of DEVA // end of SMB1 // end of EC0 This example creates a quick SMBus device residing at slave address 0x61 called  .  Examples of generating the Quick0 and Quick1 commands from ASL is illustrated below: Method(Test){ Store(1, QCKA) // Generates a QuickRead command to slave address 0x61 Store(QCKA, Local0) // Generates a QuickWrite command to slave address 0x61 Send/Receive Command Protocol (SMBSendRecvAcc)  XE "SMBus protocols:send/receive command protocol (SMBusSendRecvAcc)"  The SMBus Send/Receive protocol transfers a byte of data between the selected SMBus slave address and the ASL code performing a read/write to the field.  The SMBus protocol for send-command is defined that the byte being written is presented in the  command  field, while the data returned from a read-command is defined to be the byte in the data field. The SMBus driver will read and write the data to a SMBSendRecvAcc field accordingly. To define a send/receive command to a device an operation region is generated using the SMBus address type.  Next a field is generated in the operation region using the  SMBSendRecvAcc  access type.  To generate a send byte protocol to this device,  ASL would generate a write to this field. To generate a receive byte protocol to this device, ASL would generate a read to this field. For example, Device(\_SB.EC0) { Name(_HID, EISAID("PNP0C09")) Name(_CRS,  ResourceTemplate(){ // port 0x62 and 0x66 IO(Decode16, 0x62, 0x62, 0, 1), IO(Decode16, 0x66, 0x66, 0, 1) Name(_GPE, Zero) //EC is wired to bit 0 of GPE Device (SMB1) { Name(_ADR, "ACPI0001") Name(_EC, 0x8030) // EC offset(0x80), Query (0x30) OperationRegion(PHO1, SMBus, 0x62, 0x1) Device(DEVB){ Name(_ADR, 0x62) // Slave Address 0x62 Field(PHO1, SMBSendRecvAcc, NoLock, Preserve) { TSTA, TSTB, TSTC, // end of DEVB // end of SMB1 // end of EC0 This example creates a send/receive byte SMBus device residing at slave address 0x62.  There are three fields that reference this single byte called   and  . Examples of generating the send/receive byte protocols from ASL are illustrated below: Method(Test){ Store(1, TSTA) // Sets TSTA, preserved TSTB and TSTC, sendbyte Store(0, TSTB) // Clears TSTB, preserved TSTA and TSTC, sendbyte Store(0x7, TSTC) // Sets TSTC to 0111b, preserved TSTA and TSTB, sendbyte Store(TSTA, Local0) // returns 1, receive byte Store(TSTB, Local0) // returns 0, receive byte Store(TSTC, Local0) // returns 7, receive byte Read/Write Byte Protocol (ByteAcc)  XE "SMBus protocols:read/write byte protocol (ByteAcc)"  The SMBus Read/Write Byte protocol transfers a byte of data between the selected SMBus slave address and command value. The command address is defined through the use of the AccessAs(AccessType, AccessAttribute) macro. In this case the AccessAtrribute represents the byte aligned command value, and AccessType would be set to ByteAcc. To define a ByteAcc device an operation region is generated using the SMBus address type.  Next a field is generated in the operation region using the  ByteAcc  access type.  In the field list an AccessAs(ByteAcc, command_value) macro is used to define what command address is associated with this field. The absence of the macro assume a starting command value of 0. The SMBus driver assumes that after the AccessAs(ByteAcc, command_value) macro is declared, the next 8-bits represent this command register. If a field is defined that crosses over this 8-bit boundary, then the SMBus driver assumes this field resides in multiple byte-wide command registers with a command address value of command_value+1 (for each new register) using the ByteAcc protocol. To generate a write byte protocol to this device,  ASL would generate a write to this field.  To generate a read byte protocol to this device, ASL would generate a read to this field. For example, Device(\_SB.EC0) { Name(_HID, EISAID("PNP0C09")) Name(_CRS,  ResourceTemplate(){ // port 0x62 and 0x66 IO(Decode16, 0x62, 0x62, 0, 1), IO(Decode16, 0x66, 0x66, 0, 1) Name(_GPE, Zero)  //EC is wired to bit 0 of GPE Device (SMB1) { Name(_ADR, "ACPI0001") Name(_EC, 0x8030) // EC offset(0x80), Query (0x30) OperationRegion(PHO1, SMBus, 0x63, 0x1) Device(DEVB){ Name(_ADR, 0x63) // Slave Address 0x63 Field(PHO1, ByteAcc, NoLock, Preserve) { AccessAs(ByteAcc, 0), TSTA, TSTB, TSTC, TSTD,  // this field spans command address 0 and 1 // end of DEVB // end of SMB1 // end of EC0 This example creates a read/write byte SMBus device residing at slave address 0x63.  There are four fields that use two command registers (0 and 1), called  , and  .  TSTA, TSTB and TSTC reference command register 0.  TSTD references both command registers 0 and 1: bit0 of TSTD represents bit 7 of command register 0, while bits 1-3 of field TSTD represent bits 0-2 of command register 1.  Examples of generating the read/write byte protocols from ASL is illustrated below: Method(Test){ Store(1, TSTA) // Sets TSTA, preserved TSTB and TSTC, write byte Store(0, TSTB) // Clears TSTB, preserved TSTA and TSTC, write byte Store(0x7, TSTC) // Sets TSTC to 0111b, preserved TSTA and TSTB, write byte Store(0xF, TSTD) // Sets TSTD to 0xF, command registers 0 and 1 Store(TSTA, Local0) // returns 1, read byte Store(TSTB, Local0) // returns 0, read byte Store(TSTC, Local0) // returns 7, read byte Store(TSTD, Local0) // returns 0xF from command registers 0 and 1 Read/Write Word Protocol (WordAcc)  XE "SMBus protocols:read/write word protocol (WordAcc)"  The SMBus Read/Write Word protocol transfers a word of data between the selected SMBus slave address and command value. The command address is defined through the use of the AccessAs(AccessType, AccessAttribute) macro. In this case the AccessAttribute represents the byte aligned command value, and AccessType should be set to WordAcc. To define a WordAcc device an operation region is generated using the SMBus address type. Next a field is generated in the operation region using the  WordAcc  access type. In the field list an AccessAs(WordAcc, command_value) macro is used to define what command address is associated with this field. The absence of the macro assume a starting command value of 0. The SMBus driver assumes that after the AccessAs(WordAcc, command_value) macro is declared, the next 16-bits represent this command register. If a field is defined that crosses over this 16-bit boundary, then the SMBus driver assumes this field resides in multiple word wide command registers with a command address value of command_value+2 (for each new register) using the WordAcc protocol. To generate a write word protocol to this device,  ASL would generate a write to this field. To generate a read word protocol to this device, ASL would generate a read to this field. Read/Write Block Protocol (BlockAcc)  XE "SMBus protocols:read/write block protocol (BlockAcc)"  The SMBus Read/Write Block protocol transfers up to a 32 byte buffer of data between the selected SMBus slave address and command value.  The command address is defined through the use of the AccessAs(AccessType, AccessAttribute) macro.  In this case the AccessAttribute represents the byte aligned command value, and AccessType would be set to BlockAcc. To define a BlockAcc device an operation region is generated using the SMBus address type. Next a field is generated in the operation region using the  BlockAcc  access type.  In the field list an AccessAs(BlockAcc, command_value) macro is used to define what command address is associated with this field. The absence of the macro assume a starting command value of 0. The SMBus driver assumes that after the AccessAs(BlockAcc, command_value) macro is declared the command register is 32 bytes or less. Each block field must start on the a command_value boundary. The SMBus driver passes block data to and from ASL through the buffer data type. The buffer is structured such that the byte count of the data to write is in record 0 followed by the buffer data. For example a 5 byte buffer with the contents of  1, 2, 3, 4  would be generated as: Buffer(5){4, 1, 2, 3, 4} Where the length of the buffer is its byte data width plus 1, and the first entry is the length of data (buffer length minus 1). On reads, ASL will return a buffer with the first entry set to the number of data bytes returned. For example, Device(\_SB.EC0) { Name(_HID, EISAID("PNP0C09")) Name(_CRS,  ResourceTemplate(){ // port 0x62 and 0x66 IO(Decode16, 0x62, 0x62, 0, 1), IO(Decode16, 0x66, 0x66, 0, 1) Name(_GPE, Zero)  //EC is wired to bit 0 of GPE Device (SMB1) { Name(_ADR, "ACPI0001") Name(_EC, 0x8030) // EC offset(0x80), Query (0x30) OperationRegion(PHO1, SMBus, 0x65, 0x1) Device(DEVB){ Name(_ADR, 0x65) // Slave Address 0x65 Field(PHO1, BlockAcc, NoLock, Preserve) { AccessAs(BlockAcc, 0), FLD1, AccessAs(BlockAcc, 0x10), FLD2, // end of DEVB // end of SMB1 // end of EC0 This example creates a read/write block SMBus device residing at slave address 0x65.  There are two fields that use two command registers (0 and 0x10), called  , and  . Examples of generating the read/write block protocols from ASL is illustrated below: Method(Test){ Name(BUF1, Buffer(){8, 1, 2, 3, 4, 5, 6, 7, 8} // 8 is the number of bytes Name(BUF2, Buffer(){4, 9, 10, 11, 12} // 4 is the number of bytes Store(BUF1, FLD1) // Sets FLD1 SMBus device block register Store(BUF2, FLD2) // Sets FLD2 SMBus device block register Store(FLD1, Local0) // local0 contains buf: 8,1,2,3,4,5,6,7,8 Store(FLD2, Local0) // local0 contains buf: 4,9,10,11,12 SMBus Memory Devices (AnyAcc)  XE "SMBus protocols:SMBus memory devices (AnyAcc)"  The AnyAcc access type allows any of the Read/Write byte, word or Block protocol transfers to be made to the selected SMBus slave address and command value.  The combined slave and command value generates a single byte granular address space. The command address (A0-A7 of the 15-bit address) is defined through the use of the AccessAs(AccessType, AccessAtrribute) macro. In this case the AccessAttribute represents the byte aligned command value, and AccessType would be set to AnyAcc. To define a AnyAcc device an operation region is generated using the SMBus address type.  Next a field is generated in the operation region using the  AnyAcc  access type. In the field list an AccessAs(AnyAcc, command_value) macro is used to define what command address is associated with this field. The absence of the macro assume a starting command value of 0. The SMBus driver assumes that after the AccessAs(AnyAcc, command_value) macro is declared then command registers are byte-granular and linear. If a field is defined that crosses over a byte boundary, then the SMBus driver assumes this field resides in multiple command registers with a command address value of command_valuet+1 (for each new register). The SMBus driver will use the most appropriate protocol for accessing the registers associated with the fields. For example, if a field spans more than three bytes a read/write block protocol access can be made, while if only spanning a byte then the read/write byte protocol can be used. For example, a 5-byte buffer with the contents of   would be generated as: Buffer(){ On reads, ASL will return a buffer with the first entry set to the number of data bytes returned. For example, Device(\_SB.EC0) { Name(_HID, EISAID("PNP0C09")) Name(_CRS,  ResourceTemplate(){ // port 0x62 and 0x66 IO(Decode16, 0x62, 0x62, 0, 1), IO(Decode16, 0x66, 0x66, 0, 1) Name(_GPE, Zero)  //EC is wired to bit 0 of GPE Device (SMB1) { Name(_ADR, "ACPI0001") Name(_EC, 0x8030) // EC offset(0x80), Query (0x30) OperationRegion(PHO1, SMBus, 0x66, 0x1) Device(DEVB){ Name(_ADR, 0x66) // Slave Address 0x66 Field(PHO1, AnyAcc, NoLock, Preserve) { FLD1, FLD2, FLD3, FLD4,  FLD5, // end of DEVB // end of SMB1 // end of EC0 This definition creates a linear SMBus device residing at slave address 0x66.  There are six fields that use 102 command registers (0-101), called   and  .  FLD1 references command registers 0-63 (first 64 bytes) and will be accessed by the block protocol (data is over 3 bytes).  FLD2 represents command registers 64-95 (next 32 bytes) and will be accessed by the block command protocol (data is over 3 bytes).  FLD3 represents command registers 96-99 (next four bytes) and will be accessed by the block command protocol (data is over 3 bytes).  FLD4 represents command registers 100-101 (next two bytes) and will be accessed by the word command protocol.  FLD5 represents command register 102 (next byte) and will be accessed by the byte command protocol.  Examples of generating the accesses from ASL is illustrated below: Method(Test){ Name(BUF1, Buffer(){ Hannibal Name(BUF2, Buffer(){ Scipio Africanus Name(BUF3, Buffer(){ Store(BUF1, FLD1) // writes  Hannibal  to linear addresses for FLD1 Store(BUF2, FLD2) // writes  Scipio Africanus  to linear addresses for FLD2 Store(BUF3, FLD3) // writes   to linear addresses for FLD3 Store(0xFF12, FLD4) // sets FLD4 to 0xFF12 Store(0xEF, FLD5) // sets FLD5 to 0xEF Store(FLD1, Local0) // local0 contains 64 byte buffer with:  Hannibal Store(FLD2, Local0) // local0 contains 32 byte buffer with:  Scipio Africanus Store(FLD3, Local0) // local0 contains 4 bytes:  Store(FLD4, Local0) // local0 contains 2 bytes: 0xFF12 Store(FLD5, Local0) // local0 contains 1 byte: 0xEF Mixed Example (AnyAcc)  XE "SMBus protocols:example of multiple protocols"  Some devices can be accessed through multiple protocols. This section gives an example of such a device. Device(\SB._EC0) { Name(_HID, EISAID("PNP0C09")) Name(_CRS,  ResourceTemplate(){ // port 0x62 and 0x66 IO(Decode16, 0x62, 0x62, 0, 1), IO(Decode16, 0x66, 0x66, 0, 1) Name(_GPE, Zero)  //EC is wired to bit 0 of GPE Device (SMB1) { Name(_ADR, "ACPI0001") Name(_EC, 0x8030) // EC offset(0x80), Query (0x30) OperationRegion(PHO1, SMBus, 0x67, 0x1) Device(DEVB){ Name(_ADR, 0x67) // Slave Address 0x67 Field(PHO1, ByteAcc, NoLock, Preserve) { AccessAs(AnyAcc, 0), FLD1, FLD2, FLD3, AccessAs(WordAcc, 0x70), FLD4,  AccessAs(ByteAcc, 0x80), FLD5, // end of DEVB // end of SMB1 // end of EC0 This definition creates an SMBus device using various protocols residing at slave address 0x67. There are three fields that use four command registers (0, 1, 2 and 3), called   and  .  FLD1 references command registers 0-1 (32 bytes per command register) and will be accessed by the byte, word and block linear protocols.  FLD2 represents command register 064 and will be accessed by the byte, word and block linear protocols.  FLD3 represents command register 96 and will be accessed by the byte, word and block linear protocols.  FLD4 represents command register 0x70 and will be accessed by the word command protocol.  FLD5 represents command register 0x80 and will be accessed by the byte command protocol.   IndexField - Declare Index/Data Fields IndexFieldTerm := IndexField( IndexName, //NameString DataName, //NameString AccessType, //AccessTypeKeyword LockRule, //LockRuleKeyword UpdateRule //UpdateRuleKeyword ) {FieldUnitList}  XE "ASL:IndexField-Declare Index/Data Fields"   XE "IndexField-Declare Index/Data Fields" \t "See ASL"  Creates a series of named data objects whose data values are fields within a larger object accessed by an index/data-style reference to IndexName and DataName. This encoding is used to define named data objects whose data values are fields within an index/data register pair. This provides a simple way to declare register variables that occur behind a typical index and data register pair.  Accessing the contents of an indexed field data object will automatically occur through the DataName object by using an IndexName object aligned on an AccessType boundary, with synchronization occurring on the operation region which contains the index data variable, and on the global lock if specified by LockRule.    AccessType, LockRule, UpdateRule, and FieldList are the same format as the Field term. The following is a block of ASL sample code using IndexField: Creates an index/data register in system I/O space made up of 8-bit registers. Creates a FET0 field within the indexed range. Method(_EX1){ // define 256-byte operational region in SystemIO space // and name it GIO0  OperationRegion (GIO0, 1, 0x125, 0x100) // create field named Preserve structured as a sequence // of index and data bytes  Field (GIO0, ByteAcc, NoLock, WriteAsZeros) { IDX0, 8, DAT0, 8, // Create an IndexField within IDX0 & DAT0 which has // FETs in the first two bits of indexed offset 0,  // and another 2 FETs in the high bit on indexed  // 2f and the low bit of indexed offset 30 IndexField (IDX0, DAT0, ByteAcc, NoLock, Preserve) { FET0, 1, FET1, 1, Offset(0x2f), // skip to byte offset 2f // skip another 7 bits FET3, 1, FET4, 1 // Clear FET3 (index 2f, bit 7) Store (Zero, FET3) Method - Declare Control Method MethodTerm := Method( MethodName, //NameString NumArgs, //Nothing | ByteConst SerializeRule //Nothing | //SerializeRuleKeyword ) {TermList}  XE "ASL:Method - Declare control method"   XE "Method - Declare control method" \t "See ASL"  Declares a named package containing a series of object references that collectively represent a control method, which is a procedure that can be invoked to perform computation. Method opens a name scope. System software executes a control method by referencing the objects in the package in order. For more information on  LINK Word.Document.6 "D:\\toosday\\kenr\\ken.doc" "OLE_LINK14"  \* MERGEFORMAT \a \r control method  execution, see section 5.5.3. The current name space location used during name creation is adjusted to be the current location on the name space tree. Any names created within this scope are  below  the name of this package. The current name space location is assigned to the method package, and all name space references that occur during control method execution for this package are relative to that location. If a method is declared as Serialized, an implicit mutex associated with the method object is acquired at SyncLevel 0.  The serialize-rule can be used to prevent re-entering of a method.  This is especially useful if the method creates name space objects.  Without the serialize-rule, the re-entering of a method will fail when it attempts to create the same name space object. Also note that all name space objects created by a method have temporary lifetime.  When method execution exits, the created objects will be destroyed. The following block of ASL sample code shows a use of Method for defining a control method that turns on a power resource.  Method(_ON) { Store (One, GIO.IDEP)   // assert power Sleep (10)              // wait 10ms Store (One, GIO.IDER)   // de-assert reset# Stall (10)              // wait 10us Store (Zero, GIO.IDEI)  // de-assert isolation Mutex - Declare Synchronization / Mutex Object MutexTerm := Mutex( MutexName, //NameString SyncLevel //ByteConst  XE "ASL:Mutex - Declare Synchronization/Mutex Object"   XE "Mutex - Declare Synchronization/Mutex Object" \t "See ASL"  Creates a data mutex synchronization object named MutexName, with level from 0 to 15 specified by SyncLevel. A synchronization object provides a  LINK Word.Document.6 "D:\\toosday\\kenr\\ken.doc" "OLE_LINK14"  \* MERGEFORMAT \a \r control method  with a mechanism for waiting for certain events. To prevent deadlocks, wherever more than one synchronization object must be owned, the synchronization objects must always be released in the order opposite the order in which they were acquired. The SyncLevel parameter declares the logical nesting level of the synchronization object. All Acquire terms must refer to a synchronization object with an equal or greater SyncLevel to current level, and all Release terms must refer to a synchronization object with equal or lower SyncLevel to the current level. Mutex synchronization provides the means for mutually exclusive ownership. Ownership is acquired using an Acquire term and is released using a Release term. Ownership of a Mutex must be relinquished before completion of any invocation.  For example, the top level  LINK Word.Document.6 "D:\\toosday\\kenr\\ken.doc" "OLE_LINK14"  \* MERGEFORMAT \a \r control method  cannot exit while still holding ownership of a Mutex. Acquiring ownership of a Mutex can be nested. The SyncLevel check is not performed on a Mutex when the ownership count is nesting. The SyncLevel of a thread before acquiring any mutexes is zero.  The SyncLevel of the global lock (\_GL) is zero.  A method marked serialized has an inherent mutex of SyncLevel 0. OperationRegion - Declare Operation Region OpRegionTerm := OperationRegion( RegionName, //NameString RegionSpace, //RegionSpaceKeyword Offset, //TermArg=>DWordConst Length //TermArg=>DWordConst  XE "ASL:OperationRegion - Declare Operation Region"   XE "OperationRegion - Declare Operation Region" \t "See ASL"  Declares an operation region. Offset is the offset within the selected RegionSpace at which the region starts (byte-granular), and Length is the length of the region in bytes. An Operation Region is a type of data object where read or write operations to the data object are performed in some hardware space. For example, the Definition Block can define an Operation Region within a bus, or system IO space. Any reads or writes to the named object will results in accesses to the IO space. Operation regions are regions in some space that contain hardware registers for exclusive use by ACPI control methods. In general, no hardware register (at least byte granular) within the operation region accessed by an ACPI control method can be shared with any accesses from any other source, with the exception of using the Global Lock to share a region with the firmware. The entire Operation Region can be allocated for exclusive use to the ACPI subsystem in the host OS. Operation Regions have  virtual content  and are only accessible via Field objects Operation Region objects may be defined down to actual bit controls using Field data object definitions. The actual bit content of a Field are bits from within a larger Buffer that are normalized for that field (i.e., shifted down and masked to the proper length), and as such the data type of a Field is Buffer. Therefore fields which are 32 bits or less in size may be read and stored as Integers. An Operation Region object implicitly supports Mutex synchronization. Updates to the object, or a Field data object for the region,  will automatically synchronize on the Operation Region object; however, a control method may also explicitly synchronize to a region to prevent other accesses to the region (from other control methods). Note that, according to the control method execution model, control method execution is non-preemptive. Because of this, explicit synchronization to an Operation Region needs to be done only in cases where a control method blocks or yields execution and where the type of register usage requires such synchronization. Originally there were five Operation Region types specified in ACPI: 0 = SystemMemory 1 = SystemIO 2 = PCI_Config 3 = EmbeddedControl 4 = SMBus These are now extended to include vendor-defined Operation Regions, with 0x80 to 0xFF user defined.  The following example ASL code shows the use of OperationRegion combined with Field to describe IDE 0 and 1 controlled through general IO space, using one FET.  OperationRegion (GIO, SystemIO, 0x125, 0x1) Field (GIO, ByteAcc, NoLock, Preserve) { IDEI, // IDEISO_EN    - isolation buffer IDEP, // IDE_PWR_EN   - power IDER, // IDERST#_EN   - reset# PowerResource - Declare Power Resource PowerResTerm := PowerResource( ResourceName, //NameString SystemLevel, //ByteConst ResourceOrder //WordConst ) {ObjectList}  XE "ASL:PowerResource"   XE "Power Resource - Declare Power Resource" \t "See ASL"  Declares a power resource. PowerResource opens a name scope.  For a definition of the PowerResource term, see section 7.1.  Processor - Declare Processor ProcessorTerm := Processor( ProcessorName, //NameString ProcessorID, //ByteConst PBlockAddress, //DWordConst PblockLength //ByteConst ) {ObjectList}  XE "ASL:Processor - Declare Processor"   XE "Processor - Declare Processor" \t "See ASL"  Declares a named processor object. Processor opens a name scope. Each processor is required to have a unique ProcessorID value from any other ProcessorID value. The ACPI BIOS declares one processor object per processor in the system under the \_PR name space. PBlockAddress provides the system IO address for the processors register block.  Each processor can supply a different such address. PBlockLength is the length of the processor register block, in bytes which is either 0 (for no P_BLK) or 6.  With one exception, all processors are required to have the same PBlockLength.  The exception is that the boot processor can have a non-zero PBlockLength when all other processors have a zero PBlockLength.  The following block of ASL sample code shows a use of the Processor term.  Processor( \_PR.CPU0, // name space name 0x120, // PBlk system IO address // PBlkLen ThermalZone - Declare Thermal Zone ThermalZoneTerm := ThermalZone( ThermalZoneName //NameString ) {ObjectList}  XE "ASL:ThermalZone - Declare Thermal Zone"   XE "ThermalZone - Declare Thermal Zone" \t "See ASL"  Declares a named Thermal Zone object. ThermalZone opens a name scope. Each use of a ThermalZone term declares one thermal zone in the system. Each thermal zone in a system is required to have a unique ThermalZoneName. For sample ASL code that uses a ThermalZone statement, see section   REF _Ref368051715 \n  Error! Reference source not found. Name Space Modifiers  XE "ASL:Name Space Modifier Terms"   XE "Name Space Modifier Terms" \t "See ASL"  The name space modifiers are as follows: Table 15-9   Name Space Modifiers ASL Statement Description Alias Defines a name alias  Defines a global name and attaches a buffer, literal data item, or package to it.  Scope Declares the placement of one or more object names in the ACPI name space when the definition block that contains the Scope statement is loaded.  Alias - Declare Name Alias AliasTerm := Alias( SourceObject, //NameString AliasObject //NameString  XE "ASL:Alias - Declare Name Alias"   XE "Alias - Declare Name Alias" \t "See Alias - Declare Name Alias"  Creates a new name, AliasObject, which refers to and acts exactly the same as SourceObject. AliasObject is created as an alias of SourceObject in the name space. The SourceObject name must already exist in the name space. If the alias is to a name within the same definition block the SourceObject name must be logically ahead of this definition in the block. The following example shows use of an Alias term: Alias(\SUS.SET.EVEN, SSE) Name - Declare Named Object NameTerm := Name( ObjectName, //NameString Object //DataObject  XE "Name - Declare Named Object" \t "See ASL"   XE "ASL:Name - Declare Named Object" \t ""  Attaches Object to ObjectName in the Global ACPI name space. This encoding is to create ObjectName in the name space, which references the Object.  The following example creates the name PTTX in the root of the name space that references a package. Name(\PTTX, // Port to Port Translate Table Package() { Package() { 0x43, 0x59 }, Package() { 0x90, 0xff }} The following example creates the name CNT in the root of the name space that references an integer data object with the value 5. Name(\CNT, 5) Scope - Declare Name Scope ScopeTerm := Scope( Location //NameString ) {ObjectList}  XE "ASL:Scope - Declare Name Scope"   XE "Scope - Declare Name Scope" \t "See ASL"  Gives a base scope to a collection of objects.  All object names defined within the scope act relative to Location. Note that Location does not have to be below the surrounding scope. Note also that the Scope term does not create objects, but only locates objects in the name space; the located objects are created by other ASL terms. The Scope term alters the current name space location to Location. This causes the defined objects within TermList to occur relative to the new location in the name space. The following example ASL code Scope(\PCI0) { Name(X, 3) Scope(\) { Method(_RQ) { Return(0) } Name(^Y, 4) places the defined objects in ACPI name space as shown in the following: \PCI0.X Opcode Terms  XE "ASL:Operator Terms"   XE "ASL:Type 1 Operator Term"  There are two types of ASL opcode terms: Type 1 opcodes and Type 2 opcodes.  A Type1 opcode term can only be used standing alone on a line of ASL code; because these types of terms do not return a value, they cannot be used as a term in an expression. A Type2 opcode term can be used in an expression because these types of terms return a value.  When used in an expression the argument that names the object in which to store the result can be optional. Note that in the opcode definitions below, when the definition says  result is stored in  this literally means that the Store operator is assumed and the  execution result  is the Source operand to the Store opcode. Type 1 Opcodes Type1Opcode := BreakTerm | BreakPointTerm | FatalTerm | IfElseTerm | LoadTerm | NoOpTerm | NotifyTerm | ReleaseTerm | ResetTerm | ReturnTerm | SignalTerm | SleepTerm | StallTerm | UnloadTerm | WhileTerm The Type 1 opcodes are listed in the following table. Table 15-10  Type 1 Opcodes ASL Statement Description Break Stop executing the current code package at this point BreakPoint Used for debugging.  Stops execution in the debugger Else  Fatal Fatal check Load differentiating definition block No operation Notify Notify the OS that a specified notification value for a NotifyObject has occurred Release Release a synchronization object Reset Reset a synchronization object Return Return from a control method, optionally setting a return value Signal Signal a synchronization object Sleep Sleep n milliseconds (yields the processor) Stall Delay n microseconds (does not yield the processor) Unload Unload differentiating definition block While While Break - Break BreakTerm := Break  XE "ASL:Break - Break"   XE "Break - Break" \t "See ASL"  The break operation causes the current package execution to complete.  BreakPoint - BreakPoint BreakPointTerm := BreakPoint  XE "ASL:BreakPoint - BreakPoint"  Used for debugging, the Breakpoint opcode stops the execution and enters the AML debugger. In the retail version of the interpreter, BreakPoint is equivalent to Noop. Else - Else Operator ElseTerm := Nothing | <Else {TermList}>  XE "ASL:Else - Else Operator"   XE "Else - Else Operator" \t "See ASL"  In an If term, if Predicate evaluates to 0, it is false, and the term list in the Else term is executed.  If Predicate evaluates to Not 0 on the If term, then it is considered true, and the term list in the Else term is not executed. The following example checks Local0 to be zero or non-zero.  On non-zero, CNT is incremented; otherwise, CNT is decremented. If (Local0) { Increment (CNT) } Else { Decrement (CNT) Fatal - Fatal Check FatalTerm := Fatal( Type, //ByteConst Code, //DWordConst //TermArg=>Integer  XE "ASL:Fatal - Fatal Check"   XE "Fatal - Fatal Check" \t "See ASL"  This operation is used to inform the OS that there has been an OEM-defined fatal error. In response, the OS must log the fatal event and perform a controlled OS shutdown in a timely fashion.  If Operator IfTerm := If( Predicate //TermArg=>Integer ) {TermList} Predicate is evaluated as an integer. If the integer is non-zero, the term list of the If term is executed.  XE "ASL:If - If Operator"   XE "If - If Operator" \t "See ASL"  The following examples all check for bit 3 in Local0 being set, and clear it if set. // example 1 if (And(Local0, 4)) { XOr (Local0, 4, Local0) // example 2 Store(4, Local2) if (And(Local0, Local2)) { XOr (Local0, Local2, Local0) Load - Load Differentiated Definition Block LoadTerm := Load( Object, //NameString DDBHandle //SuperName  XE "ASL:Load - Load Differentiated Definition Block"   XE "Load Differentiated Definition Block" \t "See ASL"  Performs a run time load of a Definition Block. The Object parameter can either refer to an operation region field or an operation region directly.  If the object is an operation region, the operation region must be in SystemMemory space.  The Definition Block should contain a DESCRIPTION_HEADER of type SSDT or PSDT. The Definition Block must be totally contained within the supplied operational region or operation region field. This table is read into memory, the checksum is verified, and then it is loaded into the ACPI name space. The DDBHandle parameter is the handle to the Differentiating Definition Block that can be used to unload the Definition Block at a future time.  The OS can also check the OEM Table ID and Revision ID against a database for a newer revision Definition Block of the same OEM Table ID and load it instead.  The default name space location to load the Definition Block is relative to the current name space. The new Definition Block can override this by specifying absolute names or by adjusting the name space location using the Scope operator. Loading a Definition Block is a synchronous operation. Upon completion of the operation, the Definition Block has been loaded. The control methods defined in the Definition Block are not executed during load time. Noop Code - No Operation NoOpTerm := Noop  XE "ASL:Noop Code - No Operation"   XE "Noop Code - No Operation" \t "See ASL"  This operation has no effect. Notify - Notify NotifyTerm := Notify( Object, //SuperName NotificationValue //TermArg=>ByteConst  XE "ASL:Notify - Notify"   XE "Notify - Notify" \t "See ASL"  Notifies the OS that the NotificationValue for the Object has occurred. Object must be a reference to a device or thermal zone object.  Notification values are determined by the Object type. For example, the notify values for a thermal zone object are different from the notify values used for a device object. Undefined notification values are treated as reserved and are ignored by the OS. For lists of defined Notification values, see section   REF _Ref369887208 \n  Error! Reference source not found. Release - Release a Mutex Synchronization Object ReleaseTerm := Release( SyncObject //SuperName  XE "ASL:Release - Release a Mutex Synchronization Object"   XE "Release - Release a Mutex Synchronization Object" \t "See ASL"  SynchObject must be a mutex synchronization object. If the mutex object is owned by the current invocation, ownership for the Mutex is released once. It is fatal to release ownership on a Mutex unless it is currently owned. A Mutex must be totally released before an invocation completes. Reset - Reset an Event Synchronization Object ResetTerm := Reset( SyncObject //SuperName SynchObject must be an Event synchronization object.  This encoding is used to reset an event synchronization object to a non-signaled state. See also the Wait and Signal function operator definitions  XE "ASL:Reset - Reset an Event Synchronization Object"   XE "Reset - Reset an Event Synchronization Object" \t "See ASL"  Return - Return ReturnTerm := Return( //TermArg=>DataObject  XE "ASL:Return - Return"   XE "Return - Return" \t "See ASL"  Returns control to the invoking control method, optionally returning a copy of the object named in Arg. Signal - Signal a Synchronization Event SignalTerm := Signal( SyncObject //SuperName  XE "ASL:Signal - Signal a Synchronization Event"   XE "Signal - Signal a Synchronization Event" \t "See ASL"  SynchObject must be an Event synchronization object. The Event object is signaled once, allowing one invocation to acquire the event. Sleep - Sleep SleepTerm := Sleep( MilliSecs //TermArg=>Integer  XE "ASL:Sleep - Sleep"   XE "Sleep - Sleep" \t "See ASL"  The Sleep term is used to implement long-term timing requirements. Execution is delayed for at least the required number of milliseconds. The implementation of Sleep is to round the request up to the closest sleep time supported by the OS and relinquish the processor.  Stall - Stall for a Short Time StallTerm := Stall( MicroSecs //TermArg=>Integer  XE "ASL:Stall - Stall for a Short Time" \t "  The Stall term is used to implement short-term timing requirements. Execution is delayed for at least the required number of microseconds. The implementation of Stall is OS-specific, but must not relinquish control of the processor. Because of this, delays longer than 100 microseconds must use Sleep instead of Stall.  Unload - Unload Differentiated Definition Block UnloadTerm := Unload( DDBHandle //SuperName  XE "ASL:Unload - Unload Differentiated Definition Block"   XE "Unload - Unload Differentiated Definition Block" \t "See ASL"  Performs a run time unload of a Definition Block that was loaded using a Load term. Loading or unloading a Definition Block is a synchronous operation, and no control method execution occurs during the function. On completion of the Unload operation, the Definition Block has been unloaded (all the name space objects created as a result of the corresponding Load operation will be removed from the name space). While - While WhileTerm := While( Predicate //TermArg=>Integer ) {TermList}  XE "ASL:While - While"   XE "While - While" \t "See ASL"  Predicate is evaluated as an integer.  If the integer is non-zero, the list of terms in TermList is executed. The operation repeats until the Predicate evaluates to zero. Type 2 Opcodes Type2Opcode := AcquireTerm | AddTerm | AndTerm | ConcatTerm | CondRefOfTerm | DecTerm | DerefOfTerm | DivideTerm | FindSetLeftBitTerm | FindSetRightBitTerm | FromBCDTerm | IncTerm | IndexTerm | LAndTerm | LEqualTerm | LGreaterTerm | LGreaterEqualTerm | LLessTerm | LLessEqualTerm | LNotTerm | LNotEqualTerm | LOrTerm | MatchTerm | MultiplyTerm | NAndTerm | NOrTerm | NotTerm | ObjectTypeTerm | OrTerm | RefOfTerm | ShiftLeftTerm | ShiftRightTerm | SizeOfTerm | StoreTerm | SubtractTerm | ToBCDTerm | WaitTerm | XorTerm | UserTerm  XE "ASL:Type 2 Operators"   XE "Type 2 Operators" \t "See ASL"  The ASL terms for Type 2 Opcodes are listed in the following table.  Table 15-11   Type 2 Opcodes ASL Statement Description Acquire Acquire a synchronization object Add two values Bitwise And Concatenate Concatenate two strings CondRefOf Conditional reference to an object Decrement Decrement a value. DerefOf Dereference of an object reference Divide Divide FindSetLeftBit Index of first set Lsb FindSetRightBit Index of first set Msb FromBCD Convert from BCD to numeric Increment Increment a value Index Reference the nth element of a package Logical And LEqual Logical Equal LGreater Logical Greater LGreaterEqual Logical Not less LLess Logical Less LLessEqual Logical Not greater Logical Not LNotEqual Logical Not equal Logical Or Match Search for match in package array Multiply Multiply Bitwise Nand Bitwise Nor Bitwise Not ObjectType Type of object Bitwise Or RefOf Reference to an object ShiftLeft Shift value left ShiftRight Shift value right SizeOf Get the size of a buffer, string, or package Store Store value Subtract Subtract values ToBCD Convert numeric to BCD Bitwise Xor Acquire - Acquire a Mutex Synchronization Object AcquireTerm := Acquire( SyncObject, //SuperName TimeoutValue //WordConst ) => Boolean //Ones means timed-out  XE "ASL:Acquire - Acquire a Mutex Synchronization Object"   XE "Acquire - Acquire a Mutex Synchronization Object" \t "See ASL"  SynchObject must be a mutex synchronization object.  It refers to the mutex to be acquired. Ownership of the Mutex is obtained. If the Mutex is already owned by a different invocation, the processor is relinquished until the owner of the Mutex releases it or until at least TimeoutValue milliseconds have elapsed. A Mutex can be acquired more than once by the same invocation.  This operation returns a non-zero value if a timeout occurred and the mutex ownership was not acquired. A TimeoutValue of 0xFFFF indicates that there is no time out and the operation will wait indefinitely. Add - Add AddTerm := Add( Addend1, //TermArg=>Integer Addend2, //TermArg=>Integer Result //Nothing | SuperName ) => Integer  XE "ASL:Add - Add"   XE "Add - Add" \t "See ASL"  Addend1 and Addend2 are evaluated as integer data types and are added, and the result is optionally stored into Result.   Overflow conditions are ignored. And - Bitwise And AndTerm := And( Source1, //TermArg=>Integer Source2, //TermArg=>Integer Result //Nothing | SuperName ) => Integer  XE "ASL:And - Bitwise And"   XE "And - Bitwise And" \t "See ASL"  Source1 and Source2 are evaluated as integer data types, a bit-wise AND is performed, and the result is optionally stored into Result. Concatenate - Concatenate  ConcatTerm := Concatenate( Source1, //TermArg=>ComputationalData Source2, //TermArg=>ComputationalData Result //Nothing | SuperName ) => ComputationalData  XE "ASL:Concatenate - Concatenate"   XE "Concatenate - Concatenate" \t "See ASL"  Source1 and Source2 are evaluated. Source1 and Source2 must be of the same data type (that is, both integers, both strings, or both buffers).  Source2 is concatenated to Source1 and the result data is optionally stored into Result. Table 15-12 Concatenate Data Types Source1 Data Type Source2 Data Type Result Data Type Integer Integer Buffer String String String Buffer Buffer Buffer CondRefOf - Conditional Reference Of CondRefOfTerm := CondRefOf( Source, //SuperName Destination //SuperName ) => Boolean  XE "ASL:CondRefOf - Conditional Reference Of"   XE "CondRefOf - Conditional Reference Of" \t "See ASL"  Attempts to set Destination to refer to Source. The Source of this operation can be any object type (e.g., data package, device object, etc.). On success, the Destination object is set to refer to Source and the execution result of this operation is the constant Ones object. On failure the execution result of this operation is the constant Zero object and the Destination object is unchanged. This can be used to reference items in the name space which may appear dynamically (e.g., from a dynamically loaded differentiation definition block). CondRefOf is equivalent to RefOf except that if the Source object does not exist, it is fatal for RefOf but not for CondRefOf. Decrement - Decrement DecTerm := Decrement( Addend //SuperName ) => Integer This operation decrement the   XE "ASL:Decrement - Decrement" \t "See Add"  Addend by one and the result is stored back to Addend. DerefOf   Dereference Of Operator DerefOfTerm := DerefOf( Source //TermArg=>ObjectReference ) => ObjectReference  XE "ASL:DerefOf  - Dereference Of Operator"   XE "DerefOf  - Dereference Of Operator" \t "See ASL"  Returns the object referred by the Source object reference.  The object returned can be any object type (for example, a package, a device object, and so on). Divide - Divide DivideTerm := Divide( Dividend, //TermArg=>Integer Divisor, //TermArg=>Integer Remainder, //Nothing | SuperName Result //Nothing | SuperName ) => Integer //returns Result  XE "ASL:Divide - Divide"   XE "Divide - Divide" \t "See ASL"  Dividend and Divisor are evaluated as integer data. Dividend is divided by Divisor, then the resulting remainder is optionally stored into Remainder and the resulting quotient is optionally stored into Result. Divide-by-zero exceptions are fatal. FindSetLeftBit   Find Set Left Bit FindSetLeftBitTerm := FindSetLeftBit( Source, //TermArg=>Integer Result //Nothing | SuperName ) => Integer  XE "ASL:FindSetLeftBit - Find Set Left Bit"   XE "FindSetLeftBit - Find Set Left Bit" \t "See ASL"  Source is evaluated as integer data type, and the one-based bit location of the first MSb (most significant set bit) is optionally stored into Result. The result of 0 means no bit was set, 1 means the left-most bit set is the first bit, 2 means the left-most bit set is the second bit, and so on. FindSetRightBit - Find Set Right Bit FindSetRightBitTerm := FindSetRightBit( Source, //TermArg=>Integer Result //Nothing | SuperName ) => Integer  XE "ASL:FindSetRightBit - Find Set Right Bit"   XE "FindSetRightBit - Find Set Right Bit" \t "See ASL"  Source is evaluated as integer data type, and the one-based bit location of the most LSb ( least significant set bit) is optionally stored in Result. The result of 0 means no bit was set, 32 means the first bit set is the 32nd bit, 31 means the first bit set is the 31st bit, and so on. FromBCD - Convert from BCD FromBCDTerm := FromBCD( BCDValue, //TermArg=>Integer Result //Nothing | SuperName ) => Integer  XE "ASL:FromBCD - Convert from BCD"   XE "FromBCD - Convert from BCD" \t "See ASL"  The FromBCD operation is used to convert BCDValue to a numeric format and store the numeric value in Result.  Increment - Increment IncTerm := Increment( Addend //SuperName ) => Integer  XE "ASL:Increment - Increment" \t "See Add"  Equivalent to Add(Addend, 1, Addend) Index - Index IndexTerm := Index( Source, //TermArg=> //<BufferTerm | PackageTerm> Index, //TermArg=>Integer Destination //Nothing | SuperName ) => ObjectReference  XE "ASL:Index - Index"   XE "Index - Index" \t "See ASL"  Source is evaluated to either buffer or package data type. Index is evaluated to an integer. The object at Index within Source is optionally stored as a reference into Destination. The following example ASL code shows a way to use the Index term to store into a local variable the sixth element of the first package of a set of nested packages: Name(IO0D, Package() {   Package() {   0x01, 0x03F8, 0x03F8, 0x01, 0x08, 0x01,  0x25, 0xFF, 0xFE, 0x00, 0x00    Package() {   0x01, 0x02F8, 0x02F8, 0x01, 0x08, 0x01,  0x25, 0xFF, 0xBE, 0x00, 0x00    Package() {   0x01, 0x03E8, 0x03E8, 0x01, 0x08, 0x01,  0x25, 0xFF, 0xFA, 0x00, 0x00    Package() {   0x01, 0x02E8, 0x02E8, 0x01, 0x08, 0x01,  0x25, 0xFF, 0xBA, 0x00, 0x00    Package() {   0x01, 0x0100, 0x03F8, 0x08, 0x08, 0x02,  0x25, 0x20, 0x7F, 0x00, 0x00,  //Get the 6th element of the first package Store(DeRefOf(Index(DeRefOf(Index(IO0D, 0)), 5)), Local0) The following example ASL code shows a way to store into the 3rd byte of a buffer: Name(BUFF, Buffer() { 0x01, 0x02, 0x03, 0x04, 0x05 //Store 0x55 into the third byte of the buffer Store(0x55, Index(BUFF, 2)) LAnd - Logical And LAndTerm := LAnd( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean  XE "ASL:LAnd - Logical And"   XE "LAnd - Logical And" \t "See ASL"  Source1 and source2 are evaluated as integers. If both values are non-zero, the constant object Ones is returned, otherwise the constant object Zero is returned. LEqual - Logical Equal LEqualTerm := LEqual( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean  XE "ASL:LEqual - Logical Equal"   XE "LEqual - Logical Equal" \t "See ASL"  Source1 and Source2 are evaluated as integers.  If the values are equal, the constant object Ones is returned; otherwise, the constant object Zero is returned. LGreater - Logical Greater LGreaterTerm := LGreater( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean  XE "ASL:LGreater - Logical Greater"   XE "LGreater - Logical Greater" \t "See ASL"  Source1 and Source2 are evaluated as integers.  If Source1 is greater than Source2, the constant object Ones is returned; otherwise, the constant object Zero is returned. LGreaterEqual - Logical Greater Than Or Equal LGreaterEqualTerm := LGreaterEqual( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean  XE "ASL:LGreaterEqual - Logical Greater Than Or Equal"   XE "LGreaterEqual - Logical Greater Than Or Equal" \t "See ASL"  Source1 and Source2 are evaluated as integers. If Source1 is greater than or equal to Source2, the constant object Ones is returned; otherwise, the constant object Zero is returned. LLess - Logical Less LLessTerm := LLess( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean  XE "ASL:LLess - Logical Less"   XE "LLess - Logical Less" \t "See ASL"  Source1 and Source2 are evaluated as integers. If Source1 is less than Source2, the constant object Ones is returned; otherwise, the constant object Zero is returned. LLessEqual - Logical Less Than Or Equal LLessEqualTerm := LLessEqual( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean  XE "ASL:LLessEqual - Logical Less Than Or Equal"   XE "LLessEqual - Logical Less Than Or Equal" \t "See ASL"  Source1 and Source2 are evaluated as integers. If Source1 is less than or equal to Source2, then the constant object Ones is returned; otherwise, the constant object Zero is returned. LNot - Logical Not LNotTerm := LNot( Source, //TermArg=>Integer ) => Boolean  XE "ASL:LNot - Logical Not"   XE "LNot - Logical Not" \t "See ASL"  Source1 is evaluated as an integer.  If the value is non-zero, the constant object Zero is returned; otherwise, the constant object Ones is returned. LNotEqual - Logical Not Equal LNotEqualTerm := LNotEqual( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean  XE "ASL:LNot Equal - Logical Not Equal"   XE "LNot Equal - Logical Not Equal" \t "See ASL"  Source1 and Source2 are evaluated as integers.  If Source1 is not equal to Source2, then the constant object Ones is returned; otherwise, the constant object Zero is returned. LOr - Logical Or LOrTerm := LOr( Source1, //TermArg=>Integer Source2 //TermArg=>Integer ) => Boolean  XE "ASL:LOr - Logical Or"   XE "LOr - Logical Or" \t "See ASL"  Source1 and Source2 are evaluated as integers. If either values is non-zero, the constant object Ones is returned; otherwise, the constant object Zero is returned. Match - Find Object Match MatchTerm := Match( SearchPackage, //TermArg=>Package //MatchOpKeyword MatchObject1, //TermArg=>Integer //MatchOpKeyword MatchObject2, //TermArg=>Integer StartIndex //TermArg=>Integer ) => Ones | Integer  XE "ASL:Match - Find Object Match"   XE "Match - Find Object Match" \t "See ASL"  SearchPackage is evaluated to a package object and is treated as a one-dimension array.  A comparison is performed for each element of the package, starting with the index value indicated by StartIndex (0 is the first element). If the element of SearchPackage being compared against is called P[i], then the comparison is: if (P[i] Op1 MatchObject1) and (P[i] Op2 MatchObject2) then Match => i is returned. If the comparison succeeds, the index of the element that succeeded is returned; otherwise, the constant object Ones is returned. Op1 and Op2 have the following values and meanings listed in the following table. Table 15-13  Match Term Operator Meanings Operator Encoding Macro TRUE - a don t care, always returns TRUE EQ - returns TRUE if P[i] == MatchObject LE - returns TRUE if P[i] <= MatchObject LT - returns TRUE if P[i] < MatchObject GE - returns TRUE if P[i] >= MatchObject GT - returns TRUE if P[i] > MatchObject Following are some example uses of Match: Name(P1,  Package() {1981, 1983, 1985, 1987, 1989, 1990, 1991, 1993, 1995, 1997, 1999, 2001} // match 1993 == P1[i] Match(P1, MEQ, 1993, MTR, 0, 0) // -> 7, since P1[7] == 1993 // match 1984 == P1[i] Match(P1, MEQ, 1984, MTR, 0, 0) // -> ONES (not found) // match P1[i] > 1984 and P1[i] <= 2000 Match(P1, MGT, 1984, MLE, 2000, 0) // -> 2, since P1[2]>1984 and P1[2]<=2000 // match P1[i] > 1984 and P1[i] <= 2000, starting with 3rd element Match(P1, MGT, 1984, MLE, 2000, 3) // -> 3, first match at or past Start Multiply - Multiply MultiplyTerm := Multiply( Multiplicand, //TermArg=>Integer Multiplier, //TermArg=>Integer Result //Nothing | SuperName ) => Integer  XE "ASL:Multiply - Multiply"   XE "Multiply - Multiply" \t "See ASL"  Multiplicand and Multiplier are evaluated as integer data types. Multiplicand is multiplied by Multiplier, and the result is optionally stored into Result. Overflow conditions are ignored. NAnd - Bit-wise NAnd NAndTerm := NAnd( Source1, //TermArg=>Integer Source2 //TermArg=>Integer Result //Nothing | SuperName ) => Integer  XE "ASL:NAnd - Bit-wise NAnd"   XE "NAnd - Bit-wise NAnd" \t "See ASL"  Source1 and Source2 are evaluated as integer data types, a bit-wise NAND is performed, and the result is optionally stored in Result. NOr - Bitwise NOr NOrTerm := NOr( Source1, //TermArg=>Integer Source2 //TermArg=>Integer Result //Nothing | SuperName ) => Integer  XE "ASL:NOr - Bitwise NOr"   XE "NOr - Bitwise NOr" \t "See ASL"  Source1 and Source2 are evaluated as integer data types, a bit-wise NOR is performed, and the result is optionally stored in Result. Not - Not NotTerm := Not( Source, //TermArg=>Integer Result //Nothing | SuperName ) => Integer  XE "ASL:Not - Not"   XE "Not - Not" \t "See ASL"  Source1 is evaluated as an integer data type, a bit-wise NOT is performed, and the result is optionally stored in Result. ObjectType - Object Type ObjectTypeTerm := ObjectType( Object //SuperName ) => Integer  XE "ASL:ObjectType - Object Type"   XE "ObjectType - Object Type" \t "See ASL"  The execution result of this operation is an integer that has the numeric value of the object type for Object. The object type codes are listed in the following table.  Note that if this operation is performed on an object reference such as one produced by the Alias, Index or RefOf statements, the object type of the base object is returned.  For typeless objects such as scope names, type value  Uninitialized  is returned. Table 15-14  Values Returned By the ObjectType Operator Value Meaning Uninitialized Integer String Buffer Package Field Unit Device Event Method Mutex Operation Region Power Resource Processor Thermal Zone Buffer Field DDB Handle Debug Object Reserved Or - Bit-wise Or OrTerm := Or( Source1, //TermArg=>Integer Source2 //TermArg=>Integer Result //Nothing | SuperName ) => Integer  XE "ASL:Or - Bit-wise Or"   XE "Or - Bit-wise Or" \t "See ASL"  Source1 and Source2 are evaluated as integer data types, a bit-wide OR is performed, and the result is optionally stored in Result. RefOf - Reference Of RefOfTerm := RefOf( Object //SuperName ) => ObjectReference  XE "ASL:RefOf - Refernce Of"   XE "RefOf - Refernce Of" \t "See ASL"  Returns an object reference to Object.  Object can be any object type (for example, a package, a device object, and so on). If the Object does not exist, the result of a RefOf operation is fatal. Use the CondRefOf term in cases where the Object might not exist.  The primary purpose of RefOf() is to allow an object to be passed to a method as an argument to a method without the object being evaluated at the time of the method was loaded. ShiftLeft - Shift Left ShiftLeftTerm := ShiftLeft( Source, //TermArg=>Integer ShiftCount //TermArg=>Integer Result //Nothing | SuperName ) => Integer  XE "ASL:ShiftLeft - Shift Left"   XE "ShiftLeft - Shift Left" \t "See ASL"  Source and ShiftCount are evaluated as integer data types. Source is shifted left with the least significant bit zeroed ShiftCount times. The result is optionally stored into Result. ShiftRight - Shift Right ShiftRightTerm := ShiftRight( Source, //TermArg=>Integer ShiftCount //TermArg=>Integer Result //Nothing | SuperName ) => Integer  XE "ASL:ShiftRight - Shift Right"   XE "ShiftRight - Shift Right" \t "See ASL"  Source and ShiftCount are evaluated as integer data types. Source is shifted right with the most significant bit zeroed ShiftCount times.  The result is optionally stored into Result. SizeOf - SizeOf Data Object SizeOfTerm := SizeOf( DataObject //SuperName=>DataObject ) => Integer  XE "ASL:Siz  XE "SizeOf - Size Of Data Object" \t "See ASL"  eOf - Size Of Data Object"  Returns the size of a buffer, string, or package data object. For a buffer it returns the size in bytes of the data. For a string, it returns the size in bytes of the string NOT counting the trailing NULL. For a package, it returns the number of elements. Store - Store StoreTerm := Store( Source, //TermArg=>DataObject Destination //SuperName ) => DataObject  XE "ASL:Store - Store"   XE "Store - Store" \t "See ASL"  This operation evaluates Source converts to the data type of Destination and writes the results into Destination. If the Destination is of the type Uninitialized, then the Destination object is initialized as shown in the following table. Table 15-15  Store Operator Initialization Data Types for Uninitialized Destinations Data Type Description Integer Destination initialized as integer.  Buffer Destination initialized as buffer. String Destination initialized as string. The Buffer data type is a fixed length data type. If the source argument has a greater length than the destination size, extra data are truncated. If the source argument has a smaller length than the destination size, the rest of the destination data are zeroed.  Stores to Operational Region Field data types may relinquish the processor depending on the region type. All stores (of any type) to the constant zero, constant one, or constant ones object are not allowed.  Stores to read-only objects are fatal. The execution result of the operation is the same as the data written to Destination. The following example creates the name CNT that references an integer data object with the value 5 and then stores CNT to Local0. After the Store operation, Local0 is an integer object with the value 5. Name(CNT, 5) Store(CNT, Local0) Subtract - Subtract SubtractTerm := Subtract( Addend1, //TermArg=>Integer Addend2, //TermArg=>Integer Result //Nothing | SuperName ) => Integer  XE "ASL:Subtract - Subtract"   XE "Subtract - Subtract" \t "See ASL"  Addend1 and Addend2 are evaluated as integer data types. Addend2 is subtracted from Addend1, and the result is optionally stored into Result.  Underflow conditions are ignored. ToBCD - Convert to BCD ToBCDTerm := ToBCD( Value, //TermArg=>Integer Result //Nothing | SuperName ) => Integer  XE "ASL:ToBCD - Convert to BCD"   XE "ToBCD - Convert to BCD" \t "See ASL"  The ToBCD operation is used to convert Value from a numeric format to a BCD format and optionally store the numeric value in Result. Wait - Wait for a Synchronization Event WaitTerm := Wait( SyncObject, //SuperName TimeoutValue //TermArg=>Integer ) => Boolean  XE "ASL:Wait - Wait for a Synchronization Event"   XE "Wait - Wait for a Synchronization Event" \t "See ASL"  SynchObject must be an event synchronization object.  The calling method blocks waiting for the event to be signaled. The pending signal count is decremented. If there is no pending signal count, the processor is relinquished until a signal count is posted to the Event or until at least TimeoutValue milliseconds have elapsed.  This operation returns a non-zero value if a timeout occurred and a signal was not acquired. A TimeoutValue of 0xFFFF indicates that there is no time out and the operation will wait indefinitely. XOr - Bitwise XOr XOrTerm := XOr( Source1, //TermArg=>Integer Source2 //TermArg=>Integer Result //Nothing | SuperName ) => Integer  XE "ASL:XOr - Bit-wise XOr" \t "See"   XE "XOr - Bit-wise XOr" \t "See ASL"  Source1 and Source2 are evaluated as integer data types, a bit-wise XOR is performed, and the result is optionally stored in Result. User Terms UserTerm := NameString( //NameString=>MethodTerm ArgList ) => DataObject NameString must be referring to an existing method object in the Name Space.  It can either be an absolute Name Space path or else it must be accessible at the current scope of invocation.  The number of arguments in ArgList must match the number of arguments declared in the method object.  XE "ASL:XOr - Bit-wise XOr" \t "See"   XE "XOr - Bit-wise XOr" \t "See ASL"  Data Objects There are four different types of data objects: Buffer terms Package terms Literal data terms Data macros Buffer   Declare Buffer Object BufferTerm := Buffer( BuffSize //Nothing | //TermArg=>Integer ) {String | ByteList} Declares a Buffer, of size BuffSize and initial value of Initializer (ByteList). The optional BuffSize parameter specifies the size of the buffer and the initial value is specified in Initializer ByteList. If BuffSize is not specified, it defaults to the size of initializer. If the count is too small to hold the value specified by initializer, initializer size is used. For example, all four of the following examples generate the same datum in name space, although they have different ASL encodings: Buffer(10) { P00.00A Buffer(Arg0) {0x50 0x30 0x30 0x2e 0x30 0x30 0x41} Buffer(10) {0x50 0x30 0x30 0x2e 0x30 0x30 0x41 0x00 0x00 0x00} Buffer() {0x50 0x30 0x30 0x2e 0x30 0x30 0x41 0x00 0x00 0x00} Package   Declare Package Object PackageTerm := Package( NumElements //Nothing | //ByteConst ) {PackageList} Declares an unnamed aggregation of data items, constants, and/or references to control methods. The size of the package is NumElements. PackageList contains the list data items, constants, and/or control method references used to initialize the package. If NumElements is absent, it is set to match the number of elements in the PackageList. If NumElements is present and greater than the number of elements in the PackageList, the default entry Undefined is used to initialize the package elements beyond those initialized from the PackageList. Evaluating an undefined element will yield an error, but they can be assigned values to make them defined. It is an error for NumElements to be less than the number of elements in the PackageList  There are two types of package elements in the PackageList: data objects and references to control methods.  Note: If non method code package objects are implemented in an ASL compiler, evaluations of these objects are performed within the scope of the invoking method, and are performed when the containing definition block is loaded. This means that the targets of all stores, loads, and references to the locals, arguments, or constant terms are in the same name scope as the invoking method. Example 1:  Package () {  ACPI 1.0 COMPLIANT Package () {  CheckSum=> Package () {  Example 2: This example defines and initializes a two-dimensional array. Package () { Package () {11, 12, 13}, Package () {21, 22, 23} Example 3: This example is a legal encoding, but of no apparent use. Package (){} Example 4: This encoding allocates space for ten things to be defined later (see the Name and Index term definitions). Package (10) {} Literal Data Terms Literal Data terms include: Integers Strings Constant data terms Integers Integer := ByteConst | WordConst | DWordConst ByteConst := 0x00-0xff WordConst := 0x0000-0xffff DWordConst := 0x00000000-0xffffffff Using the above grammar to define an object containing the value of integer causes the ASL compiler to automatically generate the proper width of the defined integer (Byte, Word, or DWord). Strings String  AsciiCharList  AsciiCharList := Nothing | <AsciiChar AsciiCharList> AsciiChar := 0x01-0x7f NullChar := 0x00 The above grammar can be used to define an object containing a read-only string value. The default string value is the null string, which has 0 bytes available for storage of other values. Since literal strings are read-only constants, the following ASL statement (for example) is not supported: Store( However, the following sequence of statements is supported: Name(STR,  Store( , STR) Constant Data Terms ConstTerm := Zero | One | Ones | Revision  XE "constant terms" \t "See ASL"   XE "ASL:constant terms" \t ""  The constant declaration terms are Zero, One, Ones, and Revision. Zero - Constant Zero Object  XE "Zero-constant zero object" \t "See ASL"   XE "ASL:Zero-constant zero object" \t ""  The constant Zero object is an object of type Integer that will always read as all bits clear. Writes to this object are not allowed. One - Constant One Object  XE "ASL:one constant one object"   XE "one constant one object" \t "See ASL"  The constant One object is an object of type Integer that will always read the LSb as set and all other bits as clear  (that is, the value of 1). Writes to this object are not allowed. Ones - Constant Ones Object  XE "ones constant ones object" \t "See ASL"   XE "ASL:one constant one object" \t ""  The constant Ones object is an object of type Integer that will always read as all bits set. Writes to this object are not allowed. Revision   Constant Revision Object The constant Revision object is an object of type Integer that will always read as the revision of the AML interpreter. Data Macors The data macros  XE "data object declaration terms" \t "See ASL"   XE "ASL:data object declaration terms" \t ""   are: EISAID terms. ResourceTemplate terms. EISAID Macro - Convert EISA ID String To Integer EISAIDTerm := EISAID( EISAIDString //String ) => DWordConst  XE "ASL:EISAID - Convert EISA ID"   XE "EISAID - Convert EISA ID" \t "See ASL"  Converts EISAIDString, a 7-character text string argument, into its corresponding 4-byte numeric EISA ID encoding. The can be used when declaring IDs for devices that have EISA IDs. ResourceTemplate Macro   Convert Resource To Buffer Format ResourceTemplateTerm := ResourceTemplate() {ResourceMacroList} => BufferTerm For a full definition of the ResourceTemplateTerm macro, see section 6.4.1. Miscellaneous Objects Miscellaneous objects include: Debug objects ArgX objects LocalX objects Debug Data Object DebugTerm := Debug The debug data object  XE "ASL:debug data object"   XE "debug data object" \t "See ASL"   is a virtual data object.  Writes to this object provide debugging information. On at least debug versions of the interpreter any writes into this object are appropriately displayed on the system s native kernel debugger. All writes to the debug object are otherwise benign. If the system is in use without a kernel debugger, then writes to the debug object are ignored. The following table relates the ASL term types that can be written to the Debug object to the format of the information on the kernel debugger display.  Table 15-16  Debug Object Display Formats ASL Term Type Display Format Numeric data object All digits displayed in hexadecimal format. String data object String is displayed Object reference Information about the object is displayed (for example, object type and object name), but the object is not evaluated. The Debug object is a write-only object; attempting to read from the debug object is not supported. ArgX   Argument Data Objects ArgTerm := Arg0 | Arg1 | Arg2 | Arg3 | Arg4 | Arg5 | Arg6 Up to 7 argument object references can be passed to a control method. On entry to a control method, only the argument objects that are passed are usable. LocalX - Local Data Objects LocalTerm := Local0 | Local1 | Local2 | Local3 | Local4 | Local5 | Local6 | Local7 Up to 8 local objects can be referenced in a control method. On entry to a control method these objects are uninitialized and cannot be used until some value or reference is stored into the object. Once initialized, these objects are preserved in the scope of execution for that control method. ACPI Machine Language (AML) Specification  XE "ACPI Machine Language (AML):specification"   XE "AML:specification"  This section formally defines the ACPI Control Method Machine Language (AML) language. AML is the ACPI Control Method virtual machine language, machine code for a virtual machine which is supported by an ACPI-compatible OS. ACPI control methods can be written in AML, but humans ordinarily write control methods in ASL. AML is the language processed by the ACPI method interpreter. It is primarily a declarative language. It s best not to think of it as a stream of code, but rather as a set of declarations that the ACPI interpreter will compile into the ACPI name space at definition block load time. For example, notice that DefByte allocates an anonymous integer variable with a byte size initial value in ACPI space, and passes in an initial value. The byte in the AML stream that defines the initial value is not the address of the variable s storage location. An OEM or BIOS vendor needs to write ASL and be able to single step AML for debugging.  (Debuggers and other ACPI control method language tools are expected to be AML level tools, not source level tools.)  An ASL translator implementer must understand how to read ASL and generate AML.  An AML interpreter author must understand how to execute AML. AML and ASL  XE "AML and ASL:relation between"   are different languages though they are closely related. All ACPI-compatible OSes must support AML. A given user can define some arbitrary source language (to replace ASL) and write a tool to translate it to AML. However, the ACPI group will support a single translator for a single language, ASL. Notation Conventions  XE "AML:notation conventions"  The notation conventions in the table below help the reader to interpret the AML formal grammar. Table 16-1   AML Grammar Notation Conventions Notation Convention Description Example Refers to a byte value expressed as 2 hexadecimal digits. Number in bold. Denotes the encoding of the AML term. Term => Evaluated Type Shows the resulting type of the evaluation of Term. Single quotes ( Indicate constant characters.  => 0x41 Term := Term Term  The term to the left of := can be expanded into the sequence of terms on the right. aterm := bterm cterm means that aterm can be expanded into the two-term sequence of bterm followed by cterm. Term Term Term  Terms separated from each other by spaces form an ordered list. Angle brackets (< > ) Used to group items. <a b> | <c d> means either  a b or c d.  Bar symbol ( | ) Separates alternatives. aterm := bterm  |  [cterm  dterm]  means the following constructs are possible:    bterm    cterm  dterm aterm := [bterm | cterm] dterm  means the following constructs are possible:    bterm  dterm    cterm  dterm Dash character ( - ) Indicates a range. 1-9 means a single digit in the range 1 to 9 inclusive. Parenthesized term following another term. The parenthesized term is the repeat count of the previous term. aterm(3) means aterm aterm aterm. bterm(N) means N number of bterms. AML Grammar Definition  XE "AML:grammer definition"  This section defines the byte values that make up an AML byte stream. AMLCode := DefBlockHdr TermList DefBlockHdr := TableSig TableLen SpecCompliance CheckSum OemID OemTableID OemRev CreatorID CreatorRev TableSig := DWordConst //As defined in section 5.2.3. TableLen := DwordConst //Length of the table in bytes including the block //header. SpecCompliance := ByteConst //The revision of the structure. CheckSum := ByteConst //Byte checksum of the entire table. OemID := ByteConst(6) //OEM ID of up to 6 characters.  If the OEM ID is //shorter than 6 characters, it can be terminated //with a NULL character. OemTableID := ByteConst(8) //OEM Table ID of up to 8 characters.  If the OEM //Table ID is shorter than 8 characters, it can be //terminated with a NULL character. OemRev := DWordConst //OEM Table Revision. CreatorID := DWordConst //Vendor ID of the ASL assembler.  For example, //the Microsoft provided assembler has a vendor //ID  CreatorRev := DWordConst //Revision of the ASL assembler. The AML encoding can be categorized in the following groups: Name objects encoding Data objects encoding Package length encoding Term objects encoding Miscellaneous objects encoding Name Objects Encoding LeadNameChar NameChar  | LeadNameChar RootChar ParentPrefixChar := 0x41-0x5a := 0x5f := 0x30-0x39 := 0x5c := 0x5e NameSeg := <LeadNameChar NameChar NameChar NameChar> // Note that NameSegs shorter than 4 characters are // filled with trailing  NameString := <RootChar NamePath> | <PrefixPath NamePath> PrefixPath := Nothing | <  PrefixPath> NamePath := NullName | NameSeg | DualNamePath | MultiNamePath NullName := 0x00 DualNamePath := DualNamePrefix NameSeg NameSeg DualNamePrefix := 0x2e MultiNamePath := MultiNamePrefix SegCount NameSeg(SegCount) MultiNamePrefix := 0x2f SegCount := ByteData // SegCount can be from 1 to 255. // MultiNamePrefix(35) => 0x2f 0x23 // and following by 35 NameSegs. // So, the total encoding length // will be 1 + 1 + 35*4 = 142. // Note that: //   DualNamePrefix NameSeg NameSeg // has a smaller encoding than the // equivalent encoding of:   MultiNamePrefix(2) NameSeg NameSeg SuperName := NameString | ArgObj | LocalObj | DebugObj | DefIndex Data Objects Encoding DataObject := LiteralData | DefBuffer | DefPackage DataObjectList := Nothing | <DataObject DataObjectList> LiteralData := ByteConst | WordConst | DWordConst | String | ConstObj | RevisionOp ComputationalData := LiteralData | DefBuffer ByteConst := BytePrefix ByteData BytePrefix := 0x0a WordConst := WordPrefix WordData WordPrefix := 0x0b DWordConst := DWordPrefix DWordData DWordPrefix := 0x0c String := StringPrefix AsciiCharList NullChar StringPrefix := 0x0d ConstObj := ZeroOp | OneOp | OnesOp ByteList := Nothing | <ByteData ByteList> ByteData := 0x00-0xff WordData := ByteData ByteData // 0x0000-0xffff DWordData := ByteData ByteData ByteData ByteData // 0x00000000-0xffffffff AsciiCharList := Nothing | <AsciiChar AsciiCharList> AsciiChar := 0x01-0x7f NullChar := 0x00 ZeroOp := 0x00 OneOp := 0x01 OnesOp := 0xff RevisionOp := ExtOpPrefix 0x30 ExtOpPrefix := 0x5b Package Length Encoding PkgLength := PkgLeadByte | <PkgLeadByte ByteData> | <PkgLeadByte ByteData ByteData> | <PkgLeadByte ByteData ByteData ByteData> PkgLeadByte := <bit 7-6: follow ByteData count> <bit 5-4: reserved> <bit 3-0: least significant package length byte> // Note: The high 2 bits of the first byte reveal how many follow bytes are in the PkgLength.  If the PkgLength has only one byte, bit 0 through 5 are used to encode the package length (i.e. values 0-63).  If the package length value is more than 63, more than one byte must be used for the encoding in which case bit 5 and 4 of the PkgLeadByte are reserved and must be zero.  If multiple bytes encoding is used, bits 3-0 of the PkgLeadByte become the least significant 4 bits of the resulting package length value.  The next ByteData will become the next least significant 8 bits of the resulting value and so on. Term Objects Encoding TermObj := NameSpaceModifierObj | NamedObj | Type1Opcode | Type2Opcode | UserTermObj TermList := Nothing | <TermObj TermList> TermArg := Type2Opcode | DataObject | UserTermObj | ArgObj | LocalObj UserTermObj := NameString TermArgList TermArgList := Nothing | <TermArg TermArgList> ObjectList := Nothing | <Object ObjectList> Object := NameSpaceModifierObj | NamedObj Name Space Modifier Objects Encoding NameSpaceModifierObj := DefAlias | DefName | DefScope DefAlias := AliasOp NameString NameString AliasOp := 0x06 DefName := NameOp NameString DataObject NameOp := 0x08 DefScope := ScopeOp PkgLength NameString TermList ScopeOp := 0x10 Named Objects Encoding NamedObj := DefBankField | DefCreateBitField | DefCreateByteField | DefCreateDWordField | DefCreateField | DefCreateWordField | DefDevice | DefEvent | DefField | DefIndexField | DefMethod | DefMutex | DefOpRegion | DefPowerRes | DefProcessor | DefThermalZone DefBankField := BankFieldOp PkgLength NameString NameString BankValue FieldFlags FieldList BankFieldOp := ExtOpPrefix 0x87 BankValue := TermArg=>Integer FieldFlags := ByteData // bit 0-3: AccessType //    0: AnyAcc //    1: ByteAcc //    2: WordAcc //    3: DWordAcc //    4: BlockAcc //    5: SMBSendRecvAcc //    6: SMBQuickAcc // bit 4: LockRule //    0: NoLock //    1: Lock // bit 5-6: UpdateRule //    0: Preserve //    1: WriteAsOnes //    2: WriteAsZeros // bit 7: reserved (must be 0) FieldList := Nothing | <FieldElement FieldList> FieldElement := NamedField | ReservedField | AccessField NamedField := NameSeg PkgLength ReservedField := 0x00 PkgLength AccessField := 0x01 AccessType AccessAttrib AccessType := ByteData // Same as AccessType bits of FieldFlags AccessAttrib := ByteData DefCreateBitField := CreateBitFieldOp SourceBuff BitIndex NameString CreateBitFieldOp := 0x8d SourceBuff := TermArg=>BufferObj BitIndex := TermArg=>Integer DefCreateByteField := CreateByteFieldOp SourceBuff ByteIndex NameString CreateByteFieldOp := 0x8c ByteIndex := TermArg=>Integer DefCreateDWordField := CreateDWordFieldOp SourceBuff ByteIndex NameString CreateDWordFieldOp := 0x8a DefCreateField := CreateFieldOp SourceBuff BitIndex NumBits NameString CreateFieldOp := ExtOpPrefix 0x13 NumBits := TermArg=>Integer DefCreateWordField := CreateWordFieldOp SourceBuff ByteIndex NameString CreateWordFieldOp := 0x8b DefDevice := DeviceOp PkgLength NameString ObjectList DeviceOp := ExtOpPrefix 0x82 DefEvent := EventOp NameString EventOp := ExtOpPrefix 0x02 DefField := FieldOp PkgLength NameString FieldFlags FieldList FieldOp := ExtOpPrefix 0x81 DefIndexField := IndexFieldOp PkgLength NameString NameString FieldFlags FieldList IndexFieldOp := ExtOpPrefix 0x86 DefMethod := MethodOp PkgLength NameString MethodFlags TermList MethodOp := 0x14 MethodFlags := ByteData // bit 0-2: ArgCount (0-7) // bit 3: SerializeFlag //    0: NotSerialized //    1: Serialized // bit 4-7: reserved (must be 0) DefMutex := MutexOp NameString SyncFlags MutexOp := ExtOpPrefix 0x01 SyncFlags := ByteData // bit 0-3: SyncLevel (0x00-0x0f) // bit 4-7: reserved (must be 0) DefOpRegion := OpRegionOp NameString RegionSpace RegionOffset RegionLen OpRegionOp := ExtOpPrefix 0x80 RegionSpace := ByteData // 0x00: SystemMemory // 0x01: SystemIO // 0x02: PCI_Config // 0x03: EmbeddedControl // 0x04: SMBus // 0x80-0xff: user defined RegionOffset := TermArg=>DWordData RegionLen := TermArg=>DWordData DefPowerRes := PowerResOp PkgLength NameString SystemLevel ResourceOrder ObjectList PowerResOp := ExtOpPrefix 0x84 SystemLevel := ByteData ResourceOrder := WordData DefProcessor := ProcessorOp PkgLength NameString ProcID PBlkAddr PBlkLen ObjectList ProcessorOp := ExtOpPrefix 0x83 ProcID := ByteData PBlkAddr := DWordData PBlkLen := ByteData DefThermalZone := ThermalZoneOp PkgLength NameString ObjectList ThermalZoneOp := ExtOpPrefix 0x85 Type 1 Opcodes Encoding Type1Opcode := DefBreak | DefBreakPoint | DefFatal | DefIfElse | DefLoad | DefNoop | DefNotify | DefRelease | DefReset | DefReturn | DefSignal | DefSleep | DefStall | DefUnload | DefWhile DefBreak := BreakOp BreakOp := 0xa5 DefBreakPoint := BreakPointOp BreakPointOp := 0xcc DefElse := Nothing | <ElseOp PkgLength TermList> ElseOp := 0xa1 DefFatal := FatalOp FatalType FatalCode FatalArg FatalOp := ExtOpPrefix 0x32 FatalType := ByteData FatalCode := DWordData FatalArg := TermArg=>Integer DefIfElse := IfOp PkgLength Predicate TermList DefElse := 0xa0 Predicate := TermArg=>Integer DefLoad := LoadOp NameString DDBHandleObject LoadOp := ExtOpPrefix 0x20 DDBHandleObject := SuperName DefNoop := NoopOp NoopOp := 0xa3 DefNotify := NotifyOp NotifyObject NotifyValue NotifyOp := 0x86 NotifyObject := SuperName NotifyValue := TermArg=>Integer DefRelease := ReleaseOp MutexObject ReleaseOp := ExtOpPrefix 0x27 MutexObject := SuperName DefReset := ResetOp EventObject ResetOp := ExtOpPrefix 0x26 EventObject := SuperName DefReturn := ReturnOp ArgObject ReturnOp := 0xa4 ArgObject := TermArg=>DataObject DefSignal := SignalOp EventObject SignalOp := ExtOpPrefix 0x24 DefSleep := SleepOp MSecTime SleepOp := ExtOpPrefix 0x22 MsecTime := TermArg=>Integer DefStall := StallOp USecTime StallOp := ExtOpPrefix 0x21 UsecTime := TermArg=>ByteData DefUnload := UnloadOp DDBHandleObject UnloadOp := ExtOpPrefix 0x2a DefWhile := WhileOp PkgLength Predicate TermList WhileOp := 0xa2 Type 2 Opcodes Encoding Type2Opcode := DefAcquire | DefAdd | DefAnd | DefBuffer | DefConcat | DefCondRefOf | DefDecrement | DefDerefOf | DefDivide | DefFindSetLeftBit | DefFindSetRightBit | DefFromBCD | DefIncrement | DefIndex | DefLAnd | DefLEqual | DefLGreater | DefLGreaterEqual | DefLLess | DefLLessEqual | DefLNot | DefLNotEqual | DefLOr | DefMatch | DefMultiply | DefNAnd | DefNOr | DefNot | DefObjectType | DefOr | DefPackage | DefRefOf | DefShiftLeft | DefShiftRight | DefSizeOf | DefStore | DefSubtract | DefToBCD | DefWait | DefXOr DefAcquire := AcquireOp MutexObject Timeout AcquireOp := ExtOpPrefix 0x23 Timeout := WordData DefAdd := AddOp Operand1 Operand2 Target AddOp := 0x72 Operand1 := TermArg=>Integer Operand2 := TermArg=>Integer Target := SuperName | NullName DefAnd := AndOp Operand1 Operand2 Target AndOp := 0x7b DefBuffer := BufferOp PkgLength BufferSize ByteList BufferOp := 0x11 BufferSize := TermArg=>Integer DefConcat := ConcatOp Data1 Data2 Target ConcatOp := 0x73 Data1 := TermArg=>ComputationalData Data2 := TermArg=>ComputationalData DefCondRefOf := CondRefOfOp SuperName SuperName CondRefOfOp := ExtOpPrefix 0x12 DefDecrement := DecrementOp SuperName DecrementOp := 0x76 DefDerefOf := DerefOfOp ObjReference DerefOfOp := 0x83 ObjReference := TermArg=>ObjectReference //ObjectReference is an object produced by terms //such as Index, RefOf or CondRefOf. DefDivide := DivideOp Dividend Divisor Remainder Quotient DivideOp := 0x78 Dividend := TermArg=>Integer Divisor := TermArg=>Integer Remainder := Target Quotient := Target DefFindSetLeftBit := FindSetLeftBitOp Operand Target FindSetLeftBitOp := 0x81 Operand := TermArg=>Integer DefFindSetRightBit := FindSetRightBitOp Operand Target FindSetRightBitOp := 0x82 DefFromBCD := FromBCDOp BCDValue Target FromBCDOp := ExtOpPrefix 0x28 BCDValue := TermArg=>Integer DefIncrement := IncrementOp SuperName IncrementOp := 0x75 DefIndex := IndexOp BuffPkgObj IndexValue Target IndexOp := 0x88 BuffPkgObj := TermArg=>Buffer or Package object IndexValue := TermArg=>Integer DefLAnd := LAndOp Operand1 Operand2 LAndOp := 0x90 DefLEqual := LEqualOp Operand1 Operand2 LEqualOp := 0x93 DefLGreater := LGreaterOp Operand1 Operand2 LGreaterOp := 0x94 DefLGreaterEqual := LGreaterEqualOp Operand1 Operand2 LGreaterEqualOp := LNotOp LLessOp DefLLess := LLessOp Operand1 Operand2 LLessOp := 0x95 DefLLessEqual := LLessEqualOp Operand1 Operand2 LLessEqualOp := LNotOp LGreaterOp DefLNot := LNotOp Operand LNotOp := 0x92 DefLNotEqual := LNotEqualOp Operand1 Operand2 LNotEqualOp := LNotOp LEqualOp DefLOr := LOrOp Operand1 Operand2 LOrOp := 0x91 DefMatch := MatchOp SearchPkg Opcode1 Operand1 Opcode2 Operand2 StartIndex MatchOp := 0x89 SearchPkg := TermArg=>PackageObject Opcode1 := ByteData // 0: MTR // 1: MEQ // 2: MLE // 3: MLT // 4: MGE // 5: MGT Opcode2 := ByteData (same as Opcode1) StartIndex := TermArg=>Integer DefMultiply := MultiplyOp Operand1 Operand2 Target MultiplyOp := 0x77 DefNAnd := NAndOp Operand1 Operand2 Target NAndOp := 0x7c DefNOr := NOrOp Operand1 Operand2 Target NOrOp := 0x7e DefNot := NotOp Operand Target NotOp := 0x80 DefObjectType := ObjectTypeOp SuperName ObjectTypeOp := 0x8e DefOr := OrOp Operand1 Operand2 Target := 0x7d DefPackage := PackageOp PkgLength NumElements PackageElementList PackageOp := 0x12 NumElements := ByteData PackageElementList := Nothing | <PackageElement PackageElementList> PackageElement := DataObject | NameString DefRefOf := RefOfOp SuperName RefOfOp := 0x71 DefShiftLeft := ShiftLeftOp Operand ShiftCount Target ShiftLeftOp := 0x79 ShiftCount := TermArg=>Integer DefShiftRight := ShiftRightOp Operand ShiftCount Target ShiftRightOp := 0x7a DefSizeOf := SizeOfOp SuperName SizeOfOp := 0x87 DefStore := StoreOp Operand SuperName StoreOp := 0x70 DefSubtract := SubtractOp Operand1 Operand2 Target SubtractOp := 0x74 DefToBCD := ToBCDOp Operand Target ToBCDOp := ExtOpPrefix 0x29 DefWait := WaitOp EventObject Timeout WaitOp := ExtOpPrefix 0x25 DefXOr := XOrOp Operand1 Operand2 Target XOrOp := 0x7f Miscellaneous Objects Encoding Miscellaneous objects include: Arg objects Local objects Debug objects Arg Objects Encoding ArgObj := Arg0Op | Arg1Op | Arg2Op | Arg3Op | Arg4Op | Arg5Op | Arg6Op Arg0Op := 0x68 Arg1Op := 0x69 Arg2Op := 0x6a Arg3Op := 0x6b Arg4Op := 0x6c Arg5Op := 0x6d Arg6Op := 0x6e Local Objects Encoding LocalObj := Local0Op | Local1Op | Local2Op | Local3Op | Local4Op | Local5Op | Local6Op | Local7Op Local0Op := 0x60 Local1Op := 0x61 Local2Op := 0x62 Local3Op := 0x63 Local4Op := 0x64 Local5Op := 0x65 Local6Op := 0x66 Local7Op := 0x67 Debug Objects Encoding DebugObj := DebugOp DebugOp := ExtOpPrefix 0x31 AML Byte Stream Byte Values  XE "AML:byte stream"   XE "AML:byte values"  The following table lists all the byte values that can be found in an AML byte stream and the meaning of each byte value. This table is useful for debugging AML code. Table 16-2  AML Byte Stream Byte Values  Encoding Value Encoding Name Encoding Group Fixed List Arguments Variable List Arguments ZeroOp Data Object OneOp Data Object 0x02-0x05 AliasOp Term Object NameString NameString NameOp Term Object NameString DataObject BytePrefix Data Object ByteData WordPrefix Data Object WordData DwordPrefix Data Object DWordData StringPrefix Data Object AsciiCharList NullChar 0x0E-0x0F ScopeOp Term Object NameString TermList BufferOp Term Object TermArg ByteList PackageOp Term Object ByteData DataObjectList MethodOp Term Object NameString ByteData TermList 0x15-0x2D 0x2E ( DualNamePrefix Name Object NameSeg NameSeg 0x2F ( MultiNamePrefix Name Object ByteData NameSeg(N) 0x30-0x40 0x41-0x5A ( NameChar Name Object 0x5B ( ExtOpPrefix ByteData 0x5B 0x01 MutexOp Term Object NameString ByteData 0x5B 0x02 EventOp Term Object NameString 0x5B 0x12 CondRefOfOp Term Object SuperName SuperName 0x5B 0x13 CreateFieldOp Term Object TermArg TermArg TermArg NameString 0x5B 0x20 LoadOp Term Object NameString SuperName 0x5B 0x21 StallOp Term Object TermArg 0x5B 0x22 SleepOp Term Object TermArg 0x5B 0x23 AcquireOp Term Object SuperName WordData 0x5B 0x24 SignalOp Term Object SuperName 0x5B 0x25 WaitOp Term Object SuperName TermArg 0x5B 0x26 ResetOp Term Object SuperName 0x5B 0x27 ReleaseOp Term Object SuperName 0x5B 0x28 FromBCDOp Term Object TermArg Target 0x5B 0x29 ToBCD Term Object TermArg Target 0x5B 0x2A UnloadOp Term Object SuperName 0x5B 0x30 RevisionOp Data Object 0x5B 0x31 DebugOp Debug Object 0x5B 0x32 FatalOp Term Object ByteData DWordData TermArg 0x5B 0x80 OpRegionOp Term Object NameString ByteData TermArg TermArg 0x5B 0x81 FieldOp Term Object NameString ByteData FieldList 0x5B 0x82 DeviceOp Term Object NameString ObjectList 0x5B 0x83 ProcessorOp Term Object NameString ByteData DWordData ByteData ObjectList 0x5B 0x84 PowerResOp Term Object NameString ByteData WordData ObjectList 0x5B 0x85 ThermalZoneOp Term Object NameString ObjectList 0x5B 0x86 IndexFieldOp Term Object NameString NameString ByteData FieldList 0x5B 0x87 BankFieldOp Term Object NameString NameString TermArg ByteData FieldList 0x5C ( RootChar Name Object 0x5E ( ParentPrefixChar Name Object 0x60 ( Local0Op Local Object 0x61 ( Local1Op Local Object 0x62 ( Local2Op Local Object 0x63 ( Local3Op Local Object 0x64 ( Local4Op Local Object 0x65 ( Local5Op Local Object 0x66 ( Local6Op Local Object 0x67 ( Local7Op Local Object 0x68 ( Arg0Op Arg Object 0x69 ( Arg1Op Arg Object 0x6A ( Arg2Op Arg Object 0x6B ( Arg3Op Arg Object 0x6C ( Arg4Op Arg Object 0x6D ( Arg5Op Arg Object 0x6E ( Arg6Op Arg Object StoreOp Term Object TermArg SuperName RefOfOp Term Object SuperName  AddOp Term Object TermArg TermArg Target ConcatOp Term Object TermArg TermArg Target SubtractOp Term Object TermArg TermArg Target IncrementOp Term Object SuperName DecrementOp Term Object SuperName MultiplyOp Term Object TermArg TermArg Target DivideOp Term Object TermArg TermArg Target Target ShiftLeftOp Term Object TermArg TermArg Target ShiftRightOp Term Object TermArg TermArg Target AndOp Term Object TermArg TermArg Target NAndOp Term Object TermArg TermArg Target Term Object TermArg TermArg Target NOrOp Term Object TermArg TermArg Target XOrOp Term Object TermArg TermArg Target NotOp Term Object TermArg Target FindSetLeftBitOp Term Object TermArg Target FindSetRightBitOp Term Object TermArg Target DerefOfOp Term Object TermArg 0x84-0x85 NotifyOp Term Object SuperName TermArg SizeOfOp Term Object SuperName IndexOp Term Object TermArg TermArg Target MatchOp Term Object TermArg ByteData TermArg ByteData TermArg TermArg CreateDWordFieldOp Term Object TermArg TermArg NameString CreateWordFieldOp Term Object TermArg TermArg NameString CreateByteFieldOp Term Object TermArg TermArg NameString CreateBitFieldOp Term Object TermArg TermArg NameString ObjectTypeOp Term Object SuperName LAndOp Term Object TermArg TermArg LOrOp Term Object TermArg TermArg LNotOp Term Object TermArg 0x92 0x93 LNotEqualOp Term Object TermArg TermArg 0x92 0x94 LLessEqualOp Term Object TermArg TermArg 0x95 0x92 LGreaterEqualOp Term Object TermArg TermArg LEqualOp Term Object TermArg TermArg LGreaterOp Term Object TermArg TermArg LLessOp Term Object TermArg TermArg 0x96-0x9F Term Object TermArg TermList ElseOp Term Object TermList WhileOp Term Object TermArg TermList NoopOp Term Object ReturnOp Term Object TermArg BreakOp Term Object 0xA6-0xCB BreakPointOp Term Object 0xCD-0xFE OnesOp Data Object AML Encoding of Names in the Name Space Assume the following name space exists: Assume further that a definition block is loaded that creates a node \S0.CPU.SET, and loads a block using it as a root. Assume the loaded block contains the following names: ^^PCI0 ^^PCI0.SBS \S2.ISA.COM1 ^^^S3 ^^^S2.MEM ^^^S2.MEM.SET Scope(\S0.CPU.SET.STP1) { ^ABC.DEF This will be encoded in AML as: 'STP1' ParentPrefixChar 'GET_' ParentPrefixChar ParentPrefixChar 'PCI0' ParentPrefixChar ParentPrefixChar DualNamePrefix 'PCI0' 'SBS_' RootChar 'S2__' RootChar MultiNamePrefix 3 'S2__'  'ISA_'  'COM1' ParentPrefixChar ParentPrefixChar ParentPrefixChar 'S3__' ParentPrefixChar ParentPrefixChar ParentPrefixChar DualNamePrefix 'S2__'  'MEM_' ParentPrefixChar ParentPrefixChar ParentPrefixChar MultiNamePrefix 3 'S2__'  'MEM_'  'SET_' After the block is loaded, the name space will look like this (names added to the name space by the loading operation are shown in italics). Intel/Microsoft/Toshiba Intel/Microsoft/Toshiba Intel/Microsoft/Toshiba Intel/Microsoft/Toshiba print \p page " /ndf{1 index where{pop pop pop}{dup xcheck{bind}if def} ifelse}bind def /ed{exch def}bind def /SetPageOffset{neg wp$y add/dTop ed/dLeft ed}ndf /SetPageSize {neg dTop add/dBot ed dLeft add/dRight ed}ndf /DoCropMarks{gsave 0 setgray /dopaint true def 0.25 setlinewidth   dLeft 76 sub dTop moveto 72 0 rlineto dLeft 76 sub dBot moveto 72 0 rlineto   dRight 4 add dTop moveto 72 0 rlineto dRight 4 add dBot moveto 72 0 rlineto   dLeft dTop 76 add moveto 0 -72 rlineto dRight dTop 76 add moveto 0 -72 rlineto   dLeft dBot 4 sub moveto 0 -72 rlineto dRight dBot 4 sub moveto 0 -72 rlineto   stroke grestore}ndf /DoPageBox {gsave 0 setgray /dopaint true def 0.25 setlinewidth   dLeft dTop moveto dRight dTop lineto dRight dBot lineto dLeft dBot lineto   closepath stroke grestore}ndf 40.5 72 SetPageOffset 531 648 SetPageSize DoCropMarks DoPageBox" print \p page " /ndf{1 index where{pop pop pop}{dup xcheck{bind}if def} ifelse}bind def /ed{exch def}bind def /SetPageOffset{neg wp$y add/dTop ed/dLeft ed}ndf /SetPageSize {neg dTop add/dBot ed dLeft add/dRight ed}ndf /DoCropMarks{gsave 0 setgray /dopaint true def 0.25 setlinewidth   dLeft 76 sub dTop moveto 72 0 rlineto dLeft 76 sub dBot moveto 72 0 rlineto   dRight 4 add dTop moveto 72 0 rlineto dRight 4 add dBot moveto 72 0 rlineto   dLeft dTop 76 add moveto 0 -72 rlineto dRight dTop 76 add moveto 0 -72 rlineto   dLeft dBot 4 sub moveto 0 -72 rlineto dRight dBot 4 sub moveto 0 -72 rlineto   stroke grestore}ndf /DoPageBox {gsave 0 setgray /dopaint true def 0.25 setlinewidth   dLeft dTop moveto dRight dTop lineto dRight dBot lineto dLeft dBot lineto   closepath stroke grestore}ndf 40.5 72 SetPageOffset 531 648 SetPageSize DoCropMarks DoPageBox" print \p page " /ndf{1 index where{pop pop pop}{dup xcheck{bind}if def} ifelse}bind def /ed{exch def}bind def /SetPageOffset{neg wp$y add/dTop ed/dLeft ed}ndf /SetPageSize {neg dTop add/dBot ed dLeft add/dRight ed}ndf /DoCropMarks{gsave 0 setgray /dopaint true def 0.25 setlinewidth   dLeft 76 sub dTop moveto 72 0 rlineto dLeft 76 sub dBot moveto 72 0 rlineto   dRight 4 add dTop moveto 72 0 rlineto dRight 4 add dBot moveto 72 0 rlineto   dLeft dTop 76 add moveto 0 -72 rlineto dRight dTop 76 add moveto 0 -72 rlineto   dLeft dBot 4 sub moveto 0 -72 rlineto dRight dBot 4 sub moveto 0 -72 rlineto   stroke grestore}ndf /DoPageBox {gsave 0 setgray /dopaint true def 0.25 setlinewidth   dLeft dTop moveto dRight dTop lineto dRight dBot lineto dLeft dBot lineto   closepath stroke grestore}ndf 40.5 72 SetPageOffset 531 648 SetPageSize DoCropMarks DoPageBox" haZSO }vrkd]VOH qlgb]XSN zupkfa\W ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ zvspkd]VO {mje^WSL ~thc`ROH ~wple^ZSL }vokd]YR {vqlgb]XS tfa^[XURO ~ytoj\W yrng`YU |unjc\UQN }zwrolgb] spda^[ }xjgda\W }xsnida^[ |wtqlgb] |wrmhc^Y zupmje`[ }xsnid_Z ~ytoje`[V ~ytoje`[V snkheb {xurmhc^ {wkfc`[V ~{xupkfXU xtmfb[TP {tpib^WP snkhc^YTO yungc\UQ {tpib^WP }vokd]YR {wpie^WS snkheWRO |ykfc`RM mhdaa\WRa\WRa snk]X }vohd]VOK {vqlgb]XS |uqjc_XQM {tpib^WP ~yvhc`]ZL P-1&P P-1&P
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\readme.txt ===
ACPI Source Language Assembler Release History

Version 1.0.12 (c) Copyright 1999, Microsoft Corporation.  All rights reserved.

Version	Description
-------	-----------
0.9.8	Generates spec. v1.0 description header.
	Make semantics and opcode type synchronize to spec. v1.0.
	Added support for 3rd optional argument of "Method" (i.e. SyncType).
	Added support for the SMBus access types.
	Changed "Buffer" argument from "Byte" to "Opcode".
	Added 3rd argument (optional SuperName) to "Index".
	Changed argument type of "SizeOf" from "NameStr" to "SuperName".
	Changed "BankValue" of "BankField" from "DWord" to "Opcode".
	Changed "TimeOut" of "Acquire" from "DWord" to "Word".
	Added optional "SuperName" argument to a lot of Type2Opcodes.
	Changed "Load" syntax according to 1.0 spec.
	Changed "NotificationValue" of "Notify" from "Byte" to "Opcode".
	Changed "SyncObject" of "Reset" from "NameStr" to "SuperName".
	Changed "Sleep" and "Stall" arguments from "Word"/"Byte" to "Opcode".
	Changed "Unload" argument to "NameStr".
	Changed "TimeOut" of "Wait" from "DWord" to "Opcode".
	Fixed the encoding of NameStr if it contains only "\" or "^", in which
	  case, a NULL is appended as boundary mark to separate potential
	  following NameStr.
	Added support for methods invoking other methods with arugments.
	Changed "Buffer" to support reserved size bigger than initializer size.

0.9.9	Fixed "Alias" code generation.

0.9.10	Added spec. 1.0 compliant phrase in banner.

0.9.11	Fixed fault if buffer initializer size exceeds 255.

0.9.12	Changed Creator ID from MS to MSFT.
	Fixed default method mode to NOT_SERIALIZED.
	Optimized FieldList code generation so that an unnamed field with 0
	bits won't be generated.
	Added support to allow Index() to be part of SuperName so that it is
	  now legal to do "Store(Zero, Index(PKG, 2))".
	Added _STM to the reserved name table.
	Don't allow offset() to go backward.
	
0.9.13	Added DerefOf() support.

0.9.14	Added AccessAs() macro.

0.9.15	Added _PRT as valid reserved name.
        Added PNP Macro support except for auto CreateXField generation.
	
0.9.16	Added command line option to allow overriding AML file name.
	Added command line option to allow specifying LST file name.
	Renamed some of the command line options.
	Cleaned up the reserved name table (get rid of the obsolete ones
	  and added the missing ones).
	
0.9.17	Checksum in the EndTag of the PNP macros is now zero.

0.9.18  Added support for QWord Address Space Descriptor in PNP macros.
        Added length field in Word, DWord, QWord Address Space Descriptors.
        Added _INI object in reserved name table.
	
0.9.19	Fixed the IF-ELSE-ELSE problem so that we don't allow this any more.
	Added intensive semantic error checking.
        Added the /n option (NameSpace dump).

0.9.20  Improved the NameSpace Paths dump.
        Added CreateXField support for PNP macro.  So now you can do:
            Name(BUF0, ResourceTemplate() {
                        IRQ(Edge, ActiveHigh, Shared, IRQ0) {
                                3,4,5,7,9,10,11,14,15
                        }
                        IO(Decode16, 0x100, 0x3ff, 3, 8, IO0)
                       }
            )
            CreateWordField(BUF0, IRQ0._INT, INTR)
            CreateWordField(BUF0, IO0._MIN, IOL)

0.9.21  Cleaned up error messages.
        Fixed a fault when generating .LST file.
        Added more semantic error checks.
        Allowed Index() as well as CreateXField to use PNP macro labels.
          For example:
            Index(BUF0, IRQ0._INT, Local0)

0.9.22  Added a new compiler directive "External".  The syntax is:
            External(<ObjName>, <ObjType>)
        This directive is to let the assembler know that the object is declared
          external to this table so that the assembler will not complain about
          the undeclared object.  During compiling, the assembler will create
          the external object at the specified place in the name space (if a
          full path of the object is specified), or the object will be created
          at the current scope of the External statement.  <ObjType> is
          optional.  If not specified, "UnknownObj" type is assumed.  Valid
          values of <ObjType> are:
            UnknownObj
            IntObj
            StrObj
            BuffObj
            PkgObj
            FieldUnitObj
            DeviceObj
            EventObj
            MethodObj
            MutexObj
            OpRegionObj
            PowerResObj
            ThermalZoneObj
            BuffFieldObj
            DDBHandleObj

0.9.23  Added _PIC in reserved object table.
        Added .ASM file generation.
        Improved .LST file generation.
        Renamed some of the command line options to be more like the Microsoft
          C compiler.

0.9.24  Fixed command usage help text.
        .ASM/.LST: Fixed Method invocation.
        .ASM/.LST: Fixed constant terms in Package and Name.
        .ASM/.LST: Fixed keyword arguments.

0.9.25  Optimized EISAID() code generation.

0.9.26  Added a check to make sure Fields and BankFields do not have an offset
          outside of the OperationRegion range.
	Added _DCK in the reserved name table.
	
0.9.27	Added _FDI in the reserved name table.

1.0.0   Renamed to be ver 1.0.0 (the first final release candidate).

1.0.1   Added _DDN, _BDN in the reserved name table.
	Added type checking on SuperName to disallow PNP macro labels.
	
1.0.2	Added '*' for objects in NSD files to indicate object has temporary
	  life (i.e. objects created in methods).
	Added more semantic check code for checking proper child term class.
	
1.0.3	Fixed a bug on checking child term class involving nested "Include".
	Fixed a bug to complain on ASL source file without DefinitionBlock.
        CreateXField are now Object Creators instead of Type1Opcode.
        If, Else and While scopes will now allow Object Creator terms.
	
1.0.4	Added _REG in the reserved name table.

1.0.5   Added check to make sure integer values cannot exceed DWORD maximum.
        Added error message when offset in FieldUnit exceeds 0x1ffffff or
          field length exceeds 0x10000000.

1.0.6   Added code to allow specifying region space in OperationRegion as a
          number so that region space can be extended beyond the standard
          regions.
        Added _BBN in the reserved name table.

1.0.7   Added code to print AML code offset to NameSpace object dump at which
          the NameSpace object was created.
	
1.0.8	Redefined Interrupt Vector Flags of the Extended Interrupt Descriptor
	  resource macro so that low-active-edge and high-active-level are
	  allowed.

1.0.9   Added _SxD in the reserved name table.

1.0.10  Added code to fail forward references of PNP resource objects.
        Added code to check for incorrect number of arguments during method
          invocation.
        Fixed a bug that may result in skipping some object type/existence
          validations.

1.0.11  Added _GLK, _FDE, _S0D and _S5D in the reserved name table.

1.0.12	Added _BCL, _BCM, _DCS, _DDC, _DGS, _DOD, _DOS, _DSS and _ROM in the
	  reserved name table.
	  
1.0.13	Added an optional third argument to External so that it can be used
	  to specify the number of argument to the MethodObj.  If the third
	  argument is missing, it is assumed 0.  Currently, if the object
	  is not MethodObj, this optional argument is ignored.
	  e.g. External(ABCD, MethodObj, 2)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\resnames.txt ===
_AC0
_AC1
_AC2
_AC3
_AC4
_AC5
_AC6
_AC7
_AC8
_AC9
_ADR
_AL0
_AL1
_AL2
_AL3
_AL4
_AL5
_AL6
_AL7
_AL8
_AL9
_ALN
_BAS
_BBN
_BDN
_BIF
_BM_
_BST
_BTP
_CID
_CRS
_CRT
_CST
_DCK
_DDN
_DEC
_DIS
_DMA
_EC_
_EJ0
_EJ1
_EJ2
_EJ3
_EJ4
_EJD
_Exx
_FDE
_FDI
_GLK
_GL_
_GPE
_GRA
_GTF
_GTM
_HE_
_HID
_INI
_INT
_IRC
_LCK
_LEN
_LID
_LL_
_Lxx
_MAF
_MAX
_MEM
_MIF
_MIN
_MSG
_OFF
_ON_
_OS_
_PCL
_PIC
_PR0
_PR1
_PR2
_PRS
_PRT
_PRW
_PR_
_PS0
_PS1
_PS2
_PS3
_PSC
_PSL
_PSR
_PSV
_PSW
_PTS
_Qxx
_REG
_REV
_RMV
_RNG
_RQ_
_RW_
_S0_
_S1D
_S1_
_S2D
_S2_
_S3D
_S3_
_S4D
_S4_
_S5_
_SBS
_SB_
_SCP
_SHR
_SIZ
_SI_
_SRS
_SST
_STA
_STM
_SUN
_TC1
_TC2
_TMP
_TRA
_TSP
_TYP
_TZ_
_UID
_WAK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\new\resnames.txt ===
_AC0
_AC1
_AC2
_AC3
_AC4
_AC5
_AC6
_AC7
_AC8
_AC9
_ADR
_AL0
_AL1
_AL2
_AL3
_AL4
_AL5
_AL6
_AL7
_AL8
_AL9
_ALN
_BAS
_BBN
_BCL
_BCM
_BDN
_BIF
_BM_
_BST
_BTP
_CID
_CRS
_CRT
_DCK
_DCS
_DDC
_DDN
_DEC
_DGS
_DIS
_DMA
_DOD
_DOS
_DSS
_EC0
_EC1
_EC2
_EC3
_EC4
_EC5
_EC6
_EC7
_EC7
_EC9
_EC_
_EJ0
_EJ1
_EJ2
_EJ3
_EJ4
_EJD
_Exx
_FDE
_FDI
_GLK
_GL_
_GPE
_GRA
_GTF
_GTM
_HE_
_HID
_INI
_INT
_IRC
_LCK
_LEN
_LID
_LL_
_Lxx
_MAF
_MAX
_MEM
_MIF
_MIN
_MSG
_OFF
_ON_
_OS_
_PCL
_PIC
_PR0
_PR1
_PR2
_PRS
_PRT
_PRW
_PR_
_PS0
_PS1
_PS2
_PS3
_PSC
_PSL
_PSR
_PSV
_PSW
_PTS
_PWR
_Qxx
_REG
_REV
_RMV
_RNG
_ROM
_RQ_
_RW_
_S0D
_S0_
_S1D
_S1_
_S2D
_S2_
_S3D
_S3_
_S4D
_S4_
_S5D
_S5_
_SBS
_SB_
_SCP
_SHR
_SIZ
_SI_
_SRS
_SST
_STA
_STM
_SUN
_TC1
_TC2
_TMP
_TRA
_TSP
_TYP
_TZ_
_UID
_WAK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\asl\new\readme.txt ===
ACPI Source Language Assembler Release History

Version 1.0.12 (c) Copyright 1999, Microsoft Corporation.  All rights reserved.

Version	Description
-------	-----------
0.9.8	Generates spec. v1.0 description header.
	Make semantics and opcode type synchronize to spec. v1.0.
	Added support for 3rd optional argument of "Method" (i.e. SyncType).
	Added support for the SMBus access types.
	Changed "Buffer" argument from "Byte" to "Opcode".
	Added 3rd argument (optional SuperName) to "Index".
	Changed argument type of "SizeOf" from "NameStr" to "SuperName".
	Changed "BankValue" of "BankField" from "DWord" to "Opcode".
	Changed "TimeOut" of "Acquire" from "DWord" to "Word".
	Added optional "SuperName" argument to a lot of Type2Opcodes.
	Changed "Load" syntax according to 1.0 spec.
	Changed "NotificationValue" of "Notify" from "Byte" to "Opcode".
	Changed "SyncObject" of "Reset" from "NameStr" to "SuperName".
	Changed "Sleep" and "Stall" arguments from "Word"/"Byte" to "Opcode".
	Changed "Unload" argument to "NameStr".
	Changed "TimeOut" of "Wait" from "DWord" to "Opcode".
	Fixed the encoding of NameStr if it contains only "\" or "^", in which
	  case, a NULL is appended as boundary mark to separate potential
	  following NameStr.
	Added support for methods invoking other methods with arugments.
	Changed "Buffer" to support reserved size bigger than initializer size.

0.9.9	Fixed "Alias" code generation.

0.9.10	Added spec. 1.0 compliant phrase in banner.

0.9.11	Fixed fault if buffer initializer size exceeds 255.

0.9.12	Changed Creator ID from MS to MSFT.
	Fixed default method mode to NOT_SERIALIZED.
	Optimized FieldList code generation so that an unnamed field with 0
	bits won't be generated.
	Added support to allow Index() to be part of SuperName so that it is
	  now legal to do "Store(Zero, Index(PKG, 2))".
	Added _STM to the reserved name table.
	Don't allow offset() to go backward.
	
0.9.13	Added DerefOf() support.

0.9.14	Added AccessAs() macro.

0.9.15	Added _PRT as valid reserved name.
        Added PNP Macro support except for auto CreateXField generation.
	
0.9.16	Added command line option to allow overriding AML file name.
	Added command line option to allow specifying LST file name.
	Renamed some of the command line options.
	Cleaned up the reserved name table (get rid of the obsolete ones
	  and added the missing ones).
	
0.9.17	Checksum in the EndTag of the PNP macros is now zero.

0.9.18  Added support for QWord Address Space Descriptor in PNP macros.
        Added length field in Word, DWord, QWord Address Space Descriptors.
        Added _INI object in reserved name table.
	
0.9.19	Fixed the IF-ELSE-ELSE problem so that we don't allow this any more.
	Added intensive semantic error checking.
        Added the /n option (NameSpace dump).

0.9.20  Improved the NameSpace Paths dump.
        Added CreateXField support for PNP macro.  So now you can do:
            Name(BUF0, ResourceTemplate() {
                        IRQ(Edge, ActiveHigh, Shared, IRQ0) {
                                3,4,5,7,9,10,11,14,15
                        }
                        IO(Decode16, 0x100, 0x3ff, 3, 8, IO0)
                       }
            )
            CreateWordField(BUF0, IRQ0._INT, INTR)
            CreateWordField(BUF0, IO0._MIN, IOL)

0.9.21  Cleaned up error messages.
        Fixed a fault when generating .LST file.
        Added more semantic error checks.
        Allowed Index() as well as CreateXField to use PNP macro labels.
          For example:
            Index(BUF0, IRQ0._INT, Local0)

0.9.22  Added a new compiler directive "External".  The syntax is:
            External(<ObjName>, <ObjType>)
        This directive is to let the assembler know that the object is declared
          external to this table so that the assembler will not complain about
          the undeclared object.  During compiling, the assembler will create
          the external object at the specified place in the name space (if a
          full path of the object is specified), or the object will be created
          at the current scope of the External statement.  <ObjType> is
          optional.  If not specified, "UnknownObj" type is assumed.  Valid
          values of <ObjType> are:
            UnknownObj
            IntObj
            StrObj
            BuffObj
            PkgObj
            FieldUnitObj
            DeviceObj
            EventObj
            MethodObj
            MutexObj
            OpRegionObj
            PowerResObj
            ThermalZoneObj
            BuffFieldObj
            DDBHandleObj

0.9.23  Added _PIC in reserved object table.
        Added .ASM file generation.
        Improved .LST file generation.
        Renamed some of the command line options to be more like the Microsoft
          C compiler.

0.9.24  Fixed command usage help text.
        .ASM/.LST: Fixed Method invocation.
        .ASM/.LST: Fixed constant terms in Package and Name.
        .ASM/.LST: Fixed keyword arguments.

0.9.25  Optimized EISAID() code generation.

0.9.26  Added a check to make sure Fields and BankFields do not have an offset
          outside of the OperationRegion range.
	Added _DCK in the reserved name table.
	
0.9.27	Added _FDI in the reserved name table.

1.0.0   Renamed to be ver 1.0.0 (the first final release candidate).

1.0.1   Added _DDN, _BDN in the reserved name table.
	Added type checking on SuperName to disallow PNP macro labels.
	
1.0.2	Added '*' for objects in NSD files to indicate object has temporary
	  life (i.e. objects created in methods).
	Added more semantic check code for checking proper child term class.
	
1.0.3	Fixed a bug on checking child term class involving nested "Include".
	Fixed a bug to complain on ASL source file without DefinitionBlock.
        CreateXField are now Object Creators instead of Type1Opcode.
        If, Else and While scopes will now allow Object Creator terms.
	
1.0.4	Added _REG in the reserved name table.

1.0.5   Added check to make sure integer values cannot exceed DWORD maximum.
        Added error message when offset in FieldUnit exceeds 0x1ffffff or
          field length exceeds 0x10000000.

1.0.6   Added code to allow specifying region space in OperationRegion as a
          number so that region space can be extended beyond the standard
          regions.
        Added _BBN in the reserved name table.

1.0.7   Added code to print AML code offset to NameSpace object dump at which
          the NameSpace object was created.
	
1.0.8	Redefined Interrupt Vector Flags of the Extended Interrupt Descriptor
	  resource macro so that low-active-edge and high-active-level are
	  allowed.

1.0.9   Added _SxD in the reserved name table.

1.0.10  Added code to fail forward references of PNP resource objects.
        Added code to check for incorrect number of arguments during method
          invocation.
        Fixed a bug that may result in skipping some object type/existence
          validations.

1.0.11  Added _GLK, _FDE, _S0D and _S5D in the reserved name table.

1.0.12	Added _BCL, _BCM, _DCS, _DDC, _DGS, _DOD, _DOS, _DSS and _ROM in the
	  reserved name table.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\doc\acpiarch.doc ===
Microsoft Word Document MSWordDoc Word.Document.6Driver ComponentsDriver Components Jason Clark Normal Jason Clark Microsoft Word for Windows 95Driver Components The ACPI driver will consist of the following components: Static table reader   (acpiinit.c) This component will be called at initialization time to locate and read the ACPI tables.  After the interpreter has initialized it will read the Differentiated System Description Block within the DSDT. AML interpreter   (amli subproject) This component is called to read definition blocks and run control methods.  It will also have functions that locate objects within the ACPI name space (which it builds when reading definition blocks). ACPI Timer Handler   (acpitimr.c) This component will provide an internal service to retrieve the current value of the ACPI timer, and will use the Timer Overflow event to extend the 24 or 32 bit hardware timer to 64 bits in software. CPU Power Manager   (acpicpu.c) This component provides internal services to low the power state of the CPU.  Logic for determining when this is necessary and what C state to enter resides in the OS specific portion of the ACPI driver (or in the OS kernel). ACPI Event Handler   (acpievnt.c) This component is called as an event scheduled by the SCI interrupt handler.  It will check the PM and GP status bits to determine the cause(s) of an SCI and call a handler for the event that bit indicates.  In the case of General Purpose status bits, it will call the interpreter to run a control method (corresponding to the bit location within the GP_STS register) which in some cases will use the Notify mechanism to alert the OS as to the real nature of the interrupt. Global Lock Manager   (acpilock.c) This component will supply functions to acquire and release the Global Lock which is used to serialize access to the embedded controller. Power Resource Manager   (acpipowr.c) This component will contain functions that will be called each time a device s power state changes.  This function will determine how the power resource requirements have changed, and if any Power Resources can be turned on or off as a result. Device Power Manager   (acpidev.c) This component will be called to place an ACPI managed device in a different device power state using the appropriate control method for that device.  Thermal Management   (acpithrm.c) This component is responsible for maintaining reasonable thermal conditions using methods dictated by user preferences.  It is notified via a GP SCI whenever a thermal zone boundary is crossed. Sleep State Selection and Notification - (acpizzzz.c) This component is responsible for selecting the appropriate sleep state and notifying the system.     The following components exist in the OS specific portion of the ACPI driver. S2/S3 Wakeup Handler   This code will get called in real mode by the BIOS upon resume from S2 or S3 and will need to switch the processor into protected mode and restore some system context (depending the S state). SCI Handler - There will be OS specific code to hook and handle SCI s.  This code will call functions within the shared portion of the ACPI driver to disable SCI events, and to see if the event was actually triggered by ACPI. The following components exist ONLY in the Win9x implementation of ACPI: VPOWERD Interface   This will be the communication mechanism between ACPI and VPOWERD so that legacy VPOWERD aware drivers continue to work. CONFIGMG Interface   This will be the communication mechanism between ACPI and Win9x CONFIGMG. Detailed Component Descriptions Static Table Reader This portion of the ACPI driver is run at initialization time in response to the CONFIG_START message, and is responsible for detecting the presence of ACPI, reading various tables accessed through the Root System Description Table, and storing useful information from the tables in the ACPIInformation structure.   The presence of ACPI is determined by searching the E0000-FFFFF physical address range (on 16 byte boundaries) for something that matches the format of the Root System Description Table Pointer.  This format begins with the eight byte signature  RSD PTR   and also contains a checksum byte.  We use those two properties to identify the structure.  If found, it will contain the physical address of the Root System Description Table.  This table is essentially a variable length array of physical addresses of other tables.  It also contains a header which identifies the table and its length.  For each physical address in the RSDT, the ACPI driver will convert the address, and see if the signature of the table matches one of the tables with which the ACPI driver is concerned.  If it is a known table type, the ACPI driver will store the linear address of the table in the ACPIInformation structure and then call a table specific function to read any necessary information from the table. The ACPIInformation structure is a global structure which looks like this: typedef struct  _ACPIInformation        { PRSDT   RootSystemDescTable;    //      Linear address of Root System Description Table PFADT   FixedACPIDescTable;             //      Linear address of Fixed ACPI Description Table PFACS   FirmwareACPIControlStructure;   //      Linear address of the FACS PDSDT   DiffSystemDescTable;    //      Linear address of Differentiated System Description Table PULONG  GlobalLock;                             //      Linear address of GlobalLock dword  PKEVENT GlobalLockEventHandle;  //      Event object used for waiting on release of the Global Lock BOOLEAN ACPIOnly;                               //      Did we find SCI_EN set when we loaded ? IOBLK   PM1a_BLK;                               //      I/O address of PM1a_BLK IOBLK   PM1b_BLK;                               //      I/O address of PM1b_BLK IOBLK   PM1a_CTRL_BLK;                  //      I/O address of PM1a_CNT_BLK IOBLK   PM1b_CTRL_BLK;                  //      I/O address of PM1b_CNT_BLK IOBLK   PM2_CTRL_BLK;                   //      I/O address of PM2_CNT_BLK IOBLK   PM_TMR;                                 //      I/O address of PM_TMR IOBLK   GP0_BLK; IOBLK   GP1_BLK; IOBLK   P_BLK; USHORT  pm1_en_bits;                    //      Bit mask of enabled PM1 events. ULONG   ACPI_Flags;                             //      see below for bit descriptions. }       ACPIInformation; The ACPI_Flags fields contains flags indicating which Sleeping and CPU states are supported on the machine. The last table to be read is the DSDT which is read by calling the interpreter module s AMLIInitialize to interpret the AML in the Differentiated Definition Block.  See the description for the interpreter for more information.   AML Interpreter The interpreter has its very own spec, see amli\amliarch.doc. ACPI Timer Handler The ACPI timer is a 24 or 32 bit counter residing in system i/o space (part of PM1_BLK) operating at 3.579545 MHz.  An event is generated whenever the most significant bit changes (high to low or low to high).  The OS uses this event to extend the hardware timer to a 64 bit software timer, the upper 40 bits of which are managed by software.  When the ACPI driver initializes it will enable the timer overflow interrupt.  When the event handler detects this as the cause of an SCI it will call ACPIHandleTimerOverflow (VOID) which will update the software managed 64 bit timer The ACPI Timer Handler module has two entry points: ULONGLONG ACPIGetTimerValue (VOID); This function is an internal ACPI driver service which is used primarily by the ACPI Idle handler to measure how long the system stays in a particular CPU state.  When called it returns the current value of the 64 bit timer. VOID ACPIHandleTimerOverflow (VOID); This function is called by the ACPI event handler module in response to finding the TMR_STS bit set in the PM_STS register. It is responsible for updating the upper bits of the 64 bit timer. CPU Power Manager Processor power management allows the power state (C state) of the processor to be adjusted. The C1 state is entered by executing the STI - HALT sequence of instructions.  The C2 state is entered by reading the P_LVL2 register in system i/o space.  The C3 state is entered by reading the P_LVL3 register in system i/o space.  The latencies associated with entering and exiting (and therefore their desirability) are stated in the FADT.  In the C3 state processor cache coherency is not maintained if there is bus master activity.  The ACPI driver needs to disable the system arbiter (using the ARB_DIS bit in PM2_CNTRL) prior to entering the C3 state.  Also the ACPI driver will set the BM_RLD bit in the PM1_CNTRL register which will cause a bus master request to automatically exit the processor back to the C0 state.  The ACPI driver will use the BM_STS bit in the PM1_STS register to determine the amount of bus master activity (and therefore the likelihood of prematurely exiting the C3 state) and only enter the C3 state if there has been no recent bus master activity.  The OS kernel will invoke C1 as part of its normal idle loop.  When the Kernel detects an increased level of idleness it will call an OS dependent idle routine in the ACPI driver which will then call either ACPIEnterC2 (PPBLK ProcessorBlock) or ACPIEnterC3 (PPBLK ProcessorBlock).  All processor states (except C0, obviously) can be exited for any reason and will always be exited upon generation of an (unmasked) interrupt. ACPI Event Handler At initialization the ACPI driver will install an interrupt handler for the SCI interrupt (whose vector is identified in the FADT).  It will also set the enable bit for most of the events.  Upon receiving an SCI some OS specific code will schedule an event to determine the nature of the SCI.  When the event fires the ACPI driver will read & clear the various status registers and call the handler for each of the set status bits. There will be at most one pending interrupt processing event scheduled by the driver.  This event will check and deal with each event in a predefined priority order. If a status bit in the GP_STS register is set the ACPI driver will need to locate and execute the OEM supplied \_GPE._Lxx control method, where xx corresponds to the zero based bit position of the set status bit. The event handler has several entry points: VOID ACPIInterruptDisable (VOID); This function is called by the OS Specific ISR to disable all ACPI events. BOOLEAN ACPIInterruptTestOurs(VOID); This function is called by the OS Specific ISR to determine if the ACPI hardware actually generated a SCI.  This is done by looking at the PM_STS and GP_STS bits to see if any are set.  If none are set the interrupt is passed on to the next handler, otherwise an event is scheduled to process the interrupt. void _cdecl ACPIInterruptProcessing (ULONG holder); This function is called to snapshot & clear the status bits, re-enable ACPI interrupts and then process each set status bit.  For set GP_STS bits this means calling a function in the AML interpreter to run the control method associated with that bit. The path of an ACPI interrupt When an SCI is generated the OS specific interrupt handler is called, this function first call ACPIInterruptTestOurs to see if the interrupt was generated by the ACPI hardware, if it was the handler then calls ACPIInterruptDisable to prevent any further ACPI interrupts from happening.  If another ACPI event were to occur at this point, the status bit would still get set so the event would get processed.  The handler then schedules an event to be called at a time when pageable code can be executed.  ACPIInterruptProcessing will be called when this event fires.  This function will immediately take a snapshot of the ACPI status registers and re-set the set bits, and then re-enable ACPI interrupts. Global Lock Manager The global lock is used to serialize access to hardware that is shared between the SMI and OS environments.  When the OS needs to access a shared piece of hardware (the embedded controller for example) it first checks the ownership bit of the global lock DWORD (located within the FACS), and if set (indicating someone else (SMI) owns the global lock) the OS sets the pending bit, and waits for the BIOS to signal that is has released the lock at which point we attempt to re-acquire the lock using the previously described sequence.  When we relinquish the lock we check the pending bit and if set (indicating the BIOS wants the lock) we notify the BIOS that the lock is now free.  This component has two entry points: AcquireGlobalLockMustSucceed (void) -- will not return until the global lock has been acquired. ReleaseGlobalLock (void) --  releases the global lock, and if needed notifies the BIOS that the lock is now free. If AcquireGlobalLockMustSucceed finds that the global lock is currently owned by the SMI environment, it waits on the GlobalLockEventHandle event object.  This event is signaled by the ACPIEvent code upon detecting a set GBL_RLS bit in PM1_STS.   Power Resource Manager Each power resource object will have a ULONG use count field in its descriptor (PwrResDes structure).  This use count will be incremented each time a device transitions into a D state where it begins to need the power resource.  Likewise the use count will decrement each time a Device transitions into a D state where it no longer needs the resource.  You can determine a device s supported D states by finding the corresponding _PRn (where n is the Device state) object in the ACPI name space under the particular device. This object will evaluate to a PowerResource object which contains the minimum S state required for the resource to remain in the ON state. When a resource s use count falls to zero, the resource will be turned (if an off method exists for this resource).  Likewise, when the use count goes from 0 to 1, the resource will need to be turned on.  The function which handles power resource tracking will get called every time a main board device transitions to a different D state. The PwrResDes structure is allocated and initialized by the interpreter when it discovers a Power Resource in a description block.   typedef struct _PwrResDes PwrResDes *Next; // pointer to next Power Resource in the list, or NULL for list termination. ULONG Name; // four byte unique ID for this object (stated by OEM in the ASL) MIN_S_STATE MinSstate; // Minimum S state at which this power resource can remain ON.  ULONG Order; An OEM supplied value which tells the OS in which order to turn the  various power resources on or off. ULONG UseCount; // # of devices currently relying on this power resource. PwrResDes; Sleep State Selection and Notification A sleep state after evaluating four criteria: Which Sleep states are supported on the machine. Requirements imposed by wake-up devices. User preference (performance/power-savings). Application required resume latency. The first criteria is at initialization time, by searching for _Sn objects in the root of the ACPI name space.  The existence of a _Sn object indicates that Sleeping States n is supported. The second criteria is result of a wake-up device (or any device between it and the root of the hardware tree) having a minimum D state at which it is capable of waking the machine.  The device will have certain power resource requirements at that D state, and those power resources will have a minimum S state at which they remain on. The third criteria is set by the user in a control panel applet to indicate their performance/power preference. The fourth criteria is set by an application (typically a service application) to express the maximum allowable resume time. The appropriate sleep state will be selected by performing a logical AND on the allowable sleep state masks generated by evaluating criteria 1, 2 and 4.  From the allowable sleep states, one is chosen by finding the closest match with criteria 3.  All devices not required for wake-up will be sent a message/IRP requesting that they transition to the D3 device state.  If a device cannot transition to D3 it will be treated like a wake-up device in that its power requirements will have to be analyzed and a new minimum S state may be determined.  It would normally not be necessary to cancel the previous device state change requests, since they will continue to need to transition to D3. Once the process of selecting a sleep state and notifying the drivers has been completed, that machine will be transitioned to the selected S state by programming SLP_TYP and then setting SLP_EN. S1 Sleep State After setting SLP_EN the driver will spin waiting for the WAK_STS bit in PM1_STS to get set.  Once it is set the hardware resume process is complete and the driver will schedule an event to call ACPIEvent which will check the various status registers to determine the cause of the resume.   S2-S4 Sleep States Prior to entering this state the ACPI driver will lock the real-mode resume vector code, and fill in the physical address of this code into the Firmware Waking Vector location.  This code will get called from the BIOS in real mode, and will need to transition the processor into protect mode prior to determining the cause of the resume event. is selected  Normal Default Paragraph Font Unknown mark williams Jason Clark5C:\My Documents\New ACPI Core Driver Architecture.doc Jason & Janina ClarkAC:\My Documents\ACPI Specification\Architecture Docs\acpiarch.doc Jason Clark C:\My Documents\acpiarch.doc Jason Clark C:\My Documents\acpiarch.doc Times New Roman Symbol Arial Driver Components Jason Clark Jason Clark
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\doc\acpierrs.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Title _PID_GUIDJason Clark NORMAL Jason Clark Microsoft Word 8.0bjbjf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\acpi\doc\amliarch.doc ===
Microsoft Word Document MSWordDoc Word.Document.6Microsoft Corporation ACPI Machine Language (AML) Interpreter Design ArchitectureACPI Machine Language (AML) Interpreter Design Architecture Michael Tsang Normal Michael Tsang Microsoft Word for Windows 95ACPI Machine Language (AML) Interpreter Design Architecture Introduction The ACPI specification defines the ACPI Control Method Machine (AML) Language.  AML is a machine code for a virtual machine which is supported by an ACPI-compatible OS.  ACPI control methods are written in AML.  Therefore, in order to execute these control methods, the ACPI-compatible OS must be able to interpret and execute the AML machine instructions. The AML interpreter has two major functions: Parse the definition and description of all motherboard devices in an ACPI compliant system and store the information in the ACPI name space. Execute control methods in respond to system or user events.  These control methods provide an OS-independent way to access various hardware in the system. Function 1: AML defines and describes devices in an ACPI system. The AML Interpreter will parse the Differentiated System Description Table (DSDT) and build an ACPI name space which is a hierarchical representation of the devices in the system.  The information stored in the name space includes the device name, device ID, resource information as well as control methods to access a certain feature of the device.  The AML Interpreter will also parse any dynamic Device Description Block (DDB) that gets loaded as a result of events such as docking. Function 2: AML describes control methods to access devices. The AML interpreter will parse and execute control methods associated with devices whose information were stored in the ACPI name space when a Device Description Block (DDB) was loaded.  The execution of a control method is usually in respond to either a system or user event (e.g. user pressed the power button). Design Goals Fast and efficient execution of AML instructions:  On a moderately complicated ACPI machine, the amount of AML code executed could be significant.  This includes the boot time required to parse the device descriptions and perhaps frequent execution of a certain control methods associated with some repetitive hardware events. Self-contain and modular component with simple interface:  Although the AML interpreter is part of the ACPI core driver, it is complicated and self-contain enough to be considered a separate component.  It provides a very simple interface to the rest of the core driver.  The number of APIs exposed to the core driver is very low and it has no dependencies on the core driver.  In other words, it does not depend on the core driver for any kind of services. Built-in AML debugger:  Since the AML interpreter has all the knowledge about interpreting and executing AML instructions, it is a natural place to implement the debugger.  The AML debugger only exist in the debug versions of the interpreter and is primarily for OEM developers who write and debug ASL/AML code. Robust with intensive error checking and reporting:  Since the interpreter executes OEM code, it is important to build in intensive error checking although this goal may be somewhat in conflict with the  Fast and efficient execution  goal.  In general, we will have very intensive error checking code in the debug version which is the environment the OEM developers spend most of their time debugging their code.  In the retail version of the interpreter, we will have reasonable error checking and leave the most time consuming and redundant type of error checking to the compiler.  In the debug version, we will also have very good error reporting mechanism which enables the developer to pinpoint problems in the AML code very easily. Theoretically, assuming the compiler is doing a perfect job of finding all syntax and semantic errors and will not generate bad code, the interpreter can have minimal error checking code.  Unfortunately, we have to account for the possibility of third party compilers which may not do as a good job as our compiler as well as bugs in our own compiler which may produce erroneous code.  In all cases, the interpreter must not crash the system even with bad code.  The only exception is where bad control methods erroneously accessing hardware that caused a bus lock. In this case, there is no way for the interpret to tell the control method is bad because the code looks legitimate. Fast and Efficient Execution of AML Instructions AML instruction set has approximately 80 non-prefixed (1-byte opcode) instructions and 20 prefixed (2-byte opcode) extended instructions.  For the non-prefixed instructions, we will use a 256-entry direct mapping table for fast lookup of the primary instructions.  For the prefixed extended instructions, the direct mapping table method may be space inefficient because the table is too sparse.  For these instructions we will use a linear search array.  Different instructions have different number of fixed arguments associated with them.  The instruction lookup table/array will contain information on the number and type of arguments for each instructions.  Then a global array of argument data structure is used by a generic argument parsing routine to parse and store argument data.  After parsing and storing of all the arguments according to the information from the instruction lookup 