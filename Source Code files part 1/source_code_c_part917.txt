ETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ HIMC __RPC_FAR *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC __RPC_FAR *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pfdwConversion,
            /* [out] */ DWORD __RPC_FAR *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ HWND hWnd,
            /* [out] */ HWND __RPC_FAR *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD __RPC_FAR *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT __RPC_FAR *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ HWND hWnd,
            /* [out] */ UINT __RPC_FAR *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT __RPC_FAR *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ BOOL fRestoreLayout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDefWindowProc( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindows( 
            /* [in] */ ATOM __RPC_FAR *aaClassList,
            /* [in] */ UINT uSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ HKL hKL,
            /* [out] */ UINT __RPC_FAR *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ HKL hKL,
            /* [out] */ LANGID __RPC_FAR *plid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveIMMApp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveIMMApp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC __RPC_FAR *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigureIMEA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigureIMEW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [out] */ HIMC __RPC_FAR *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWordA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWordW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EscapeA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EscapeW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListCountA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListCountW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateWindow )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionFontA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionFontW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionStringA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionStringW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionWindow )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC __RPC_FAR *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionListA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionListW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionStatus )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pfdwConversion,
            /* [out] */ DWORD __RPC_FAR *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultIMEWnd )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND __RPC_FAR *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescriptionA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescriptionW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuideLineA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuideLineW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMEFileNameA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMEFileNameW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOpenStatus )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD __RPC_FAR *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyleA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyleW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatusWindowPos )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT __RPC_FAR *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVirtualKey )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT __RPC_FAR *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallIMEA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallIMEW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsIME )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsUIMessageA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsUIMessageW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyIME )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWordA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWordW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCandidateWindow )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionFontA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionFontW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionStringA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionStringW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionWindow )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConversionStatus )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOpenStatus )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatusWindowPos )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT __RPC_FAR *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SimulateHotKey )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWordA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWordW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ BOOL fRestoreLayout);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IActiveIMMApp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDefWindowProc )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FilterClientWindows )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ ATOM __RPC_FAR *aaClassList,
            /* [in] */ UINT uSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT __RPC_FAR *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLangId )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID __RPC_FAR *plid);
        
        END_INTERFACE
    } IActiveIMMAppVtbl;

    interface IActiveIMMApp
    {
        CONST_VTBL struct IActiveIMMAppVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMApp_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMApp_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMApp_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMApp_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMApp_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMApp_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMApp_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMApp_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMApp_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMApp_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMApp_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMApp_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMApp_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMApp_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMApp_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMApp_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMApp_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMApp_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_Activate(This,fRestoreLayout)	\
    (This)->lpVtbl -> Activate(This,fRestoreLayout)

#define IActiveIMMApp_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IActiveIMMApp_OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)

#define IActiveIMMApp_FilterClientWindows(This,aaClassList,uSize)	\
    (This)->lpVtbl -> FilterClientWindows(This,aaClassList,uSize)

#define IActiveIMMApp_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMApp_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMApp_AssociateContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIME,
    /* [out] */ HIMC __RPC_FAR *phPrev);


void __RPC_STUB IActiveIMMApp_AssociateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDA __RPC_FAR *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW __RPC_FAR *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_CreateContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [out] */ HIMC __RPC_FAR *phIMC);


void __RPC_STUB IActiveIMMApp_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_DestroyContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIME);


void __RPC_STUB IActiveIMMApp_DestroyContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMApp_EscapeA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMApp_EscapeW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwListSize,
    /* [out] */ DWORD __RPC_FAR *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwListSize,
    /* [out] */ DWORD __RPC_FAR *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateWindow_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate);


void __RPC_STUB IActiveIMMApp_GetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTA __RPC_FAR *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTW __RPC_FAR *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG __RPC_FAR *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG __RPC_FAR *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionWindow_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm);


void __RPC_STUB IActiveIMMApp_GetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HIMC __RPC_FAR *phIMC);


void __RPC_STUB IActiveIMMApp_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionStatus_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pfdwConversion,
    /* [out] */ DWORD __RPC_FAR *pfdwSentence);


void __RPC_STUB IActiveIMMApp_GetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDefaultIMEWnd_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HWND __RPC_FAR *phDefWnd);


void __RPC_STUB IActiveIMMApp_GetDefaultIMEWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szDescription,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szDescription,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPSTR pBuf,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPWSTR pBuf,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szFileName,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szFileName,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetOpenStatus_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_GetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetProperty_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ DWORD fdwIndex,
    /* [out] */ DWORD __RPC_FAR *pdwProperty);


void __RPC_STUB IActiveIMMApp_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetStatusWindowPos_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ POINT __RPC_FAR *pptPos);


void __RPC_STUB IActiveIMMApp_GetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetVirtualKey_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ UINT __RPC_FAR *puVirtualKey);


void __RPC_STUB IActiveIMMApp_GetVirtualKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ LPSTR szIMEFileName,
    /* [in] */ LPSTR szLayoutText,
    /* [out] */ HKL __RPC_FAR *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ LPWSTR szIMEFileName,
    /* [in] */ LPWSTR szLayoutText,
    /* [out] */ HKL __RPC_FAR *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsIME_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMApp_IsIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_NotifyIME_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIMMApp_NotifyIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ReleaseContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_ReleaseContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCandidateWindow_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate);


void __RPC_STUB IActiveIMMApp_SetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTA __RPC_FAR *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTW __RPC_FAR *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionWindow_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm);


void __RPC_STUB IActiveIMMApp_SetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetConversionStatus_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD fdwConversion,
    /* [in] */ DWORD fdwSentence);


void __RPC_STUB IActiveIMMApp_SetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetOpenStatus_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fOpen);


void __RPC_STUB IActiveIMMApp_SetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetStatusWindowPos_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ POINT __RPC_FAR *pptPos);


void __RPC_STUB IActiveIMMApp_SetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SimulateHotKey_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwHotKeyID);


void __RPC_STUB IActiveIMMApp_SimulateHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Activate_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ BOOL fRestoreLayout);


void __RPC_STUB IActiveIMMApp_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Deactivate_Proxy( 
    IActiveIMMApp __RPC_FAR * This);


void __RPC_STUB IActiveIMMApp_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_OnDefWindowProc_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT Msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMApp_OnDefWindowProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_FilterClientWindows_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ ATOM __RPC_FAR *aaClassList,
    /* [in] */ UINT uSize);


void __RPC_STUB IActiveIMMApp_FilterClientWindows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCodePageA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [out] */ UINT __RPC_FAR *uCodePage);


void __RPC_STUB IActiveIMMApp_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetLangId_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [out] */ LANGID __RPC_FAR *plid);


void __RPC_STUB IActiveIMMApp_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMApp_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMIME_INTERFACE_DEFINED__
#define __IActiveIMMIME_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IActiveIMMIME
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IActiveIMMIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("08C03411-F96B-11d0-A475-00AA006BCC59")
    IActiveIMMIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC __RPC_FAR *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ HIMC __RPC_FAR *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC __RPC_FAR *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pfdwConversion,
            /* [out] */ DWORD __RPC_FAR *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ HWND hWnd,
            /* [out] */ HWND __RPC_FAR *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD __RPC_FAR *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT __RPC_FAR *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ HWND hWnd,
            /* [out] */ UINT __RPC_FAR *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT __RPC_FAR *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateMessage( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMC( 
            /* [in] */ HIMC hIMC,
            /* [out] */ INPUTCONTEXT __RPC_FAR *__RPC_FAR *ppIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMC( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCLockCount( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateIMCC( 
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC __RPC_FAR *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReSizeIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC __RPC_FAR *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCSize( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD __RPC_FAR *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCLockCount( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD __RPC_FAR *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ UINT __RPC_FAR *puModifiers,
            /* [out] */ UINT __RPC_FAR *puVKey,
            /* [out] */ HKL __RPC_FAR *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSoftKeyboard( 
            /* [in] */ UINT uType,
            /* [in] */ HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ HWND __RPC_FAR *phSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroySoftKeyboard( 
            /* [in] */ HWND hSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowSoftKeyboard( 
            /* [in] */ HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ HKL hKL,
            /* [out] */ UINT __RPC_FAR *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ HKL hKL,
            /* [out] */ LANGID __RPC_FAR *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeybdEvent( 
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockModal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockModal( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveIMMIME __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveIMMIME __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC __RPC_FAR *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigureIMEA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigureIMEW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [out] */ HIMC __RPC_FAR *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWordA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWordW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EscapeA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EscapeW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListCountA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListCountW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateWindow )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionFontA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionFontW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionStringA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionStringW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionWindow )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC __RPC_FAR *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionListA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionListW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionStatus )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pfdwConversion,
            /* [out] */ DWORD __RPC_FAR *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultIMEWnd )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND __RPC_FAR *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescriptionA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescriptionW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuideLineA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuideLineW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMEFileNameA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMEFileNameW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOpenStatus )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD __RPC_FAR *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyleA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyleW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatusWindowPos )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT __RPC_FAR *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVirtualKey )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT __RPC_FAR *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallIMEA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallIMEW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsIME )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsUIMessageA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsUIMessageW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyIME )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWordA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWordW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCandidateWindow )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionFontA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionFontW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionStringA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionStringW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionWindow )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConversionStatus )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOpenStatus )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatusWindowPos )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT __RPC_FAR *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SimulateHotKey )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWordA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWordW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GenerateMessage )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockIMC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ INPUTCONTEXT __RPC_FAR *__RPC_FAR *ppIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockIMC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMCLockCount )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateIMCC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC __RPC_FAR *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyIMCC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockIMCC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockIMCC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReSizeIMCC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC __RPC_FAR *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMCCSize )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD __RPC_FAR *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMCCLockCount )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD __RPC_FAR *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHotKey )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ UINT __RPC_FAR *puModifiers,
            /* [out] */ UINT __RPC_FAR *puVKey,
            /* [out] */ HKL __RPC_FAR *phKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHotKey )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSoftKeyboard )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ UINT uType,
            /* [in] */ HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ HWND __RPC_FAR *phSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroySoftKeyboard )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowSoftKeyboard )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT __RPC_FAR *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLangId )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID __RPC_FAR *plid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KeybdEvent )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockModal )( 
            IActiveIMMIME __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockModal )( 
            IActiveIMMIME __RPC_FAR * This);
        
        END_INTERFACE
    } IActiveIMMIMEVtbl;

    interface IActiveIMMIME
    {
        CONST_VTBL struct IActiveIMMIMEVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMIME_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMIME_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMIME_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMIME_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMIME_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMIME_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMIME_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMIME_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMIME_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMIME_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMIME_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMIME_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMIME_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMIME_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMIME_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMIME_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMIME_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMIME_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMIME_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMIME_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMIME_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMIME_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMIME_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMIME_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMIME_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMIME_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMIME_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMIME_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMIME_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMIME_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMIME_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMIME_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMIME_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMIME_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMIME_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMIME_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMIME_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMIME_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMIME_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMIME_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMIME_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMIME_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMIME_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMIME_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMIME_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMIME_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMIME_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMIME_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMIME_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMIME_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMIME_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMIME_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMIME_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMIME_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMIME_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMIME_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMIME_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMIME_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMIME_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMIME_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMIME_GenerateMessage(This,hIMC)	\
    (This)->lpVtbl -> GenerateMessage(This,hIMC)

#define IActiveIMMIME_LockIMC(This,hIMC,ppIMC)	\
    (This)->lpVtbl -> LockIMC(This,hIMC,ppIMC)

#define IActiveIMMIME_UnlockIMC(This,hIMC)	\
    (This)->lpVtbl -> UnlockIMC(This,hIMC)

#define IActiveIMMIME_GetIMCLockCount(This,hIMC,pdwLockCount)	\
    (This)->lpVtbl -> GetIMCLockCount(This,hIMC,pdwLockCount)

#define IActiveIMMIME_CreateIMCC(This,dwSize,phIMCC)	\
    (This)->lpVtbl -> CreateIMCC(This,dwSize,phIMCC)

#define IActiveIMMIME_DestroyIMCC(This,hIMCC)	\
    (This)->lpVtbl -> DestroyIMCC(This,hIMCC)

#define IActiveIMMIME_LockIMCC(This,hIMCC,ppv)	\
    (This)->lpVtbl -> LockIMCC(This,hIMCC,ppv)

#define IActiveIMMIME_UnlockIMCC(This,hIMCC)	\
    (This)->lpVtbl -> UnlockIMCC(This,hIMCC)

#define IActiveIMMIME_ReSizeIMCC(This,hIMCC,dwSize,phIMCC)	\
    (This)->lpVtbl -> ReSizeIMCC(This,hIMCC,dwSize,phIMCC)

#define IActiveIMMIME_GetIMCCSize(This,hIMCC,pdwSize)	\
    (This)->lpVtbl -> GetIMCCSize(This,hIMCC,pdwSize)

#define IActiveIMMIME_GetIMCCLockCount(This,hIMCC,pdwLockCount)	\
    (This)->lpVtbl -> GetIMCCLockCount(This,hIMCC,pdwLockCount)

#define IActiveIMMIME_GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL)	\
    (This)->lpVtbl -> GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL)

#define IActiveIMMIME_SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL)	\
    (This)->lpVtbl -> SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL)

#define IActiveIMMIME_CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd)	\
    (This)->lpVtbl -> CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd)

#define IActiveIMMIME_DestroySoftKeyboard(This,hSoftKbdWnd)	\
    (This)->lpVtbl -> DestroySoftKeyboard(This,hSoftKbdWnd)

#define IActiveIMMIME_ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow)	\
    (This)->lpVtbl -> ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow)

#define IActiveIMMIME_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMIME_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMIME_KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo)	\
    (This)->lpVtbl -> KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo)

#define IActiveIMMIME_LockModal(This)	\
    (This)->lpVtbl -> LockModal(This)

#define IActiveIMMIME_UnlockModal(This)	\
    (This)->lpVtbl -> UnlockModal(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMIME_AssociateContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIME,
    /* [out] */ HIMC __RPC_FAR *phPrev);


void __RPC_STUB IActiveIMMIME_AssociateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ConfigureIMEA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDA __RPC_FAR *pData);


void __RPC_STUB IActiveIMMIME_ConfigureIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ConfigureIMEW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW __RPC_FAR *pData);


void __RPC_STUB IActiveIMMIME_ConfigureIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [out] */ HIMC __RPC_FAR *phIMC);


void __RPC_STUB IActiveIMMIME_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroyContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIME);


void __RPC_STUB IActiveIMMIME_DestroyContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumRegisterWordA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum);


void __RPC_STUB IActiveIMMIME_EnumRegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumRegisterWordW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum);


void __RPC_STUB IActiveIMMIME_EnumRegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EscapeA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMIME_EscapeA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EscapeW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMIME_EscapeW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetCandidateListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetCandidateListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListCountA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwListSize,
    /* [out] */ DWORD __RPC_FAR *pdwBufLen);


void __RPC_STUB IActiveIMMIME_GetCandidateListCountA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListCountW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwListSize,
    /* [out] */ DWORD __RPC_FAR *pdwBufLen);


void __RPC_STUB IActiveIMMIME_GetCandidateListCountW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateWindow_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate);


void __RPC_STUB IActiveIMMIME_GetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionFontA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTA __RPC_FAR *plf);


void __RPC_STUB IActiveIMMIME_GetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionFontW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTW __RPC_FAR *plf);


void __RPC_STUB IActiveIMMIME_GetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionStringA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG __RPC_FAR *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMIME_GetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionStringW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG __RPC_FAR *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMIME_GetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionWindow_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm);


void __RPC_STUB IActiveIMMIME_GetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HIMC __RPC_FAR *phIMC);


void __RPC_STUB IActiveIMMIME_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionListA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetConversionListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionListW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetConversionListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionStatus_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pfdwConversion,
    /* [out] */ DWORD __RPC_FAR *pfdwSentence);


void __RPC_STUB IActiveIMMIME_GetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDefaultIMEWnd_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HWND __RPC_FAR *phDefWnd);


void __RPC_STUB IActiveIMMIME_GetDefaultIMEWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDescriptionA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szDescription,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetDescriptionA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDescriptionW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szDescription,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetDescriptionW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetGuideLineA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPSTR pBuf,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMIME_GetGuideLineA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetGuideLineW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPWSTR pBuf,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMIME_GetGuideLineW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMEFileNameA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szFileName,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetIMEFileNameA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMEFileNameW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szFileName,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetIMEFileNameW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetOpenStatus_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_GetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetProperty_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ DWORD fdwIndex,
    /* [out] */ DWORD __RPC_FAR *pdwProperty);


void __RPC_STUB IActiveIMMIME_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetRegisterWordStyleA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetRegisterWordStyleA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetRegisterWordStyleW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetRegisterWordStyleW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetStatusWindowPos_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ POINT __RPC_FAR *pptPos);


void __RPC_STUB IActiveIMMIME_GetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetVirtualKey_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ UINT __RPC_FAR *puVirtualKey);


void __RPC_STUB IActiveIMMIME_GetVirtualKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_InstallIMEA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ LPSTR szIMEFileName,
    /* [in] */ LPSTR szLayoutText,
    /* [out] */ HKL __RPC_FAR *phKL);


void __RPC_STUB IActiveIMMIME_InstallIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_InstallIMEW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ LPWSTR szIMEFileName,
    /* [in] */ LPWSTR szLayoutText,
    /* [out] */ HKL __RPC_FAR *phKL);


void __RPC_STUB IActiveIMMIME_InstallIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsIME_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMIME_IsIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsUIMessageA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMIME_IsUIMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsUIMessageW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMIME_IsUIMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_NotifyIME_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIMMIME_NotifyIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RegisterWordA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister);


void __RPC_STUB IActiveIMMIME_RegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RegisterWordW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister);


void __RPC_STUB IActiveIMMIME_RegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ReleaseContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_ReleaseContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCandidateWindow_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate);


void __RPC_STUB IActiveIMMIME_SetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionFontA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTA __RPC_FAR *plf);


void __RPC_STUB IActiveIMMIME_SetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionFontW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTW __RPC_FAR *plf);


void __RPC_STUB IActiveIMMIME_SetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionStringA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMIME_SetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionStringW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMIME_SetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionWindow_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm);


void __RPC_STUB IActiveIMMIME_SetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetConversionStatus_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD fdwConversion,
    /* [in] */ DWORD fdwSentence);


void __RPC_STUB IActiveIMMIME_SetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetOpenStatus_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fOpen);


void __RPC_STUB IActiveIMMIME_SetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetStatusWindowPos_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ POINT __RPC_FAR *pptPos);


void __RPC_STUB IActiveIMMIME_SetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SimulateHotKey_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwHotKeyID);


void __RPC_STUB IActiveIMMIME_SimulateHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnregisterWordA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szUnregister);


void __RPC_STUB IActiveIMMIME_UnregisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnregisterWordW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szUnregister);


void __RPC_STUB IActiveIMMIME_UnregisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GenerateMessage_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_GenerateMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockIMC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ INPUTCONTEXT __RPC_FAR *__RPC_FAR *ppIMC);


void __RPC_STUB IActiveIMMIME_LockIMC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockIMC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_UnlockIMC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCLockCount_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwLockCount);


void __RPC_STUB IActiveIMMIME_GetIMCLockCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateIMCC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ DWORD dwSize,
    /* [out] */ HIMCC __RPC_FAR *phIMCC);


void __RPC_STUB IActiveIMMIME_CreateIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroyIMCC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC);


void __RPC_STUB IActiveIMMIME_DestroyIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockIMCC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IActiveIMMIME_LockIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockIMCC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC);


void __RPC_STUB IActiveIMMIME_UnlockIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ReSizeIMCC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC,
    /* [in] */ DWORD dwSize,
    /* [out] */ HIMCC __RPC_FAR *phIMCC);


void __RPC_STUB IActiveIMMIME_ReSizeIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCCSize_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ DWORD __RPC_FAR *pdwSize);


void __RPC_STUB IActiveIMMIME_GetIMCCSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCCLockCount_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ DWORD __RPC_FAR *pdwLockCount);


void __RPC_STUB IActiveIMMIME_GetIMCCLockCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetHotKey_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ DWORD dwHotKeyID,
    /* [out] */ UINT __RPC_FAR *puModifiers,
    /* [out] */ UINT __RPC_FAR *puVKey,
    /* [out] */ HKL __RPC_FAR *phKL);


void __RPC_STUB IActiveIMMIME_GetHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetHotKey_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ DWORD dwHotKeyID,
    /* [in] */ UINT uModifiers,
    /* [in] */ UINT uVKey,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMIME_SetHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateSoftKeyboard_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ UINT uType,
    /* [in] */ HWND hOwner,
    /* [in] */ int x,
    /* [in] */ int y,
    /* [out] */ HWND __RPC_FAR *phSoftKbdWnd);


void __RPC_STUB IActiveIMMIME_CreateSoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroySoftKeyboard_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hSoftKbdWnd);


void __RPC_STUB IActiveIMMIME_DestroySoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ShowSoftKeyboard_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hSoftKbdWnd,
    /* [in] */ int nCmdShow);


void __RPC_STUB IActiveIMMIME_ShowSoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCodePageA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [out] */ UINT __RPC_FAR *uCodePage);


void __RPC_STUB IActiveIMMIME_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetLangId_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [out] */ LANGID __RPC_FAR *plid);


void __RPC_STUB IActiveIMMIME_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_KeybdEvent_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ LANGID lgidIME,
    /* [in] */ BYTE bVk,
    /* [in] */ BYTE bScan,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwExtraInfo);


void __RPC_STUB IActiveIMMIME_KeybdEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockModal_Proxy( 
    IActiveIMMIME __RPC_FAR * This);


void __RPC_STUB IActiveIMMIME_LockModal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockModal_Proxy( 
    IActiveIMMIME __RPC_FAR * This);


void __RPC_STUB IActiveIMMIME_UnlockModal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMIME_INTERFACE_DEFINED__ */


#ifndef __IActiveIME_INTERFACE_DEFINED__
#define __IActiveIME_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IActiveIME
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IActiveIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6FE20962-D077-11d0-8FE7-00AA006BCC59")
    IActiveIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Inquire( 
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO __RPC_FAR *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD __RPC_FAR *pdwPrivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConversionList( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pRegisterWord) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ UINT uReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Escape( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void __RPC_FAR *pData,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActiveContext( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessKey( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE __RPC_FAR *pbKeyState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Select( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionString( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void __RPC_FAR *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void __RPC_FAR *pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ToAsciiEx( 
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE __RPC_FAR *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwTransBuf,
            /* [out] */ UINT __RPC_FAR *puSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyle( 
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puBufSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [out] */ UINT __RPC_FAR *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [out] */ LANGID __RPC_FAR *plid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveIME __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveIME __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Inquire )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO __RPC_FAR *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD __RPC_FAR *pdwPrivate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConversionList )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDest);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pRegisterWord);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Destroy )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ UINT uReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Escape )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void __RPC_FAR *pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetActiveContext )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessKey )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE __RPC_FAR *pbKeyState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Select )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionString )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void __RPC_FAR *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void __RPC_FAR *pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ToAsciiEx )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE __RPC_FAR *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwTransBuf,
            /* [out] */ UINT __RPC_FAR *puSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWord )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWord )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyle )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puBufSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWord )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageA )( 
            IActiveIME __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLangId )( 
            IActiveIME __RPC_FAR * This,
            /* [out] */ LANGID __RPC_FAR *plid);
        
        END_INTERFACE
    } IActiveIMEVtbl;

    interface IActiveIME
    {
        CONST_VTBL struct IActiveIMEVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIME_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIME_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIME_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIME_Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)	\
    (This)->lpVtbl -> Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)

#define IActiveIME_ConversionList(This,hIMC,szSource,uFlag,dwBufLen,pDest)	\
    (This)->lpVtbl -> ConversionList(This,hIMC,szSource,uFlag,dwBufLen,pDest)

#define IActiveIME_Configure(This,hKL,hWnd,dwMode,pRegisterWord)	\
    (This)->lpVtbl -> Configure(This,hKL,hWnd,dwMode,pRegisterWord)

#define IActiveIME_Destroy(This,uReserved)	\
    (This)->lpVtbl -> Destroy(This,uReserved)

#define IActiveIME_Escape(This,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> Escape(This,hIMC,uEscape,pData,plResult)

#define IActiveIME_SetActiveContext(This,hIMC,fFlag)	\
    (This)->lpVtbl -> SetActiveContext(This,hIMC,fFlag)

#define IActiveIME_ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)	\
    (This)->lpVtbl -> ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)

#define IActiveIME_Notify(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> Notify(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIME_Select(This,hIMC,fSelect)	\
    (This)->lpVtbl -> Select(This,hIMC,fSelect)

#define IActiveIME_SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIME_ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)	\
    (This)->lpVtbl -> ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)

#define IActiveIME_RegisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> RegisterWord(This,szReading,dwStyle,szString)

#define IActiveIME_UnregisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> UnregisterWord(This,szReading,dwStyle,szString)

#define IActiveIME_GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)	\
    (This)->lpVtbl -> GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)

#define IActiveIME_EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)	\
    (This)->lpVtbl -> EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)

#define IActiveIME_GetCodePageA(This,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,uCodePage)

#define IActiveIME_GetLangId(This,plid)	\
    (This)->lpVtbl -> GetLangId(This,plid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIME_Inquire_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ DWORD dwSystemInfoFlags,
    /* [out] */ IMEINFO __RPC_FAR *pIMEInfo,
    /* [out] */ LPWSTR szWndClass,
    /* [out] */ DWORD __RPC_FAR *pdwPrivate);


void __RPC_STUB IActiveIME_Inquire_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ConversionList_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR szSource,
    /* [in] */ UINT uFlag,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ CANDIDATELIST __RPC_FAR *pDest);


void __RPC_STUB IActiveIME_ConversionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Configure_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW __RPC_FAR *pRegisterWord);


void __RPC_STUB IActiveIME_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Destroy_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ UINT uReserved);


void __RPC_STUB IActiveIME_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Escape_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ void __RPC_FAR *pData,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIME_Escape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_SetActiveContext_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fFlag);


void __RPC_STUB IActiveIME_SetActiveContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ProcessKey_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uVirKey,
    /* [in] */ DWORD lParam,
    /* [in] */ BYTE __RPC_FAR *pbKeyState);


void __RPC_STUB IActiveIME_ProcessKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Notify_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIME_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Select_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fSelect);


void __RPC_STUB IActiveIME_Select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_SetCompositionString_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ void __RPC_FAR *pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ void __RPC_FAR *pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIME_SetCompositionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ToAsciiEx_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ UINT uVirKey,
    /* [in] */ UINT uScanCode,
    /* [in] */ BYTE __RPC_FAR *pbKeyState,
    /* [in] */ UINT fuState,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwTransBuf,
    /* [out] */ UINT __RPC_FAR *puSize);


void __RPC_STUB IActiveIME_ToAsciiEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_RegisterWord_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szString);


void __RPC_STUB IActiveIME_RegisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_UnregisterWord_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szString);


void __RPC_STUB IActiveIME_UnregisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetRegisterWordStyle_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
    /* [out] */ UINT __RPC_FAR *puBufSize);


void __RPC_STUB IActiveIME_GetRegisterWordStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_EnumRegisterWord_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IActiveIME_EnumRegisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetCodePageA_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *uCodePage);


void __RPC_STUB IActiveIME_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetLangId_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [out] */ LANGID __RPC_FAR *plid);


void __RPC_STUB IActiveIME_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIME_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CActiveIMM;

class DECLSPEC_UUID("4955DD33-B159-11d0-8FCF-00AA006BCC59")
CActiveIMM;
#endif
#endif /* __ActiveIMM_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\array.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	ARRAY.C	-- Generic Array Implementation |
 *	
 *	Original Author: <nl>
 *		Christian Fortini
 *
 *	History: <nl>
 *		6/25/95  alexgo  Cleanup and Commented
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */


#include "_common.h"
#include "_array.h"

ASSERTDATA

const int celGrow = 8;

//
//	Invariant support
//
#define	DEBUG_CLASSNAME	CArrayBase
#include "_invar.h"

// ===================================  CArrayBase  ================================================

#ifdef DEBUG
/*
 *	CArrayBase::Invariant()
 *
 *	@mfunc	Tests the array state to make sure it is valid.  DEBUG only
 *
 *	@rdesc	TRUE if the tests succeed, FALSE otherwise
 */
BOOL CArrayBase::Invariant() const
{
	Assert(_cbElem > 0);

	if(!_prgel)
	{
		Assert(_cel == 0);
		Assert(_celMax == 0);

		// We go ahead and return a value here so that
		// this function can be executed in the "watch"
		// window of various debuggers
		if(_cel || _celMax)
			return FALSE;
	}
	else
	{
		Assert(_celMax > 0 );
		Assert(_cel <= _celMax);

		if(_celMax == 0 || _cel > _celMax)
			return FALSE;
	}

	return TRUE;
}

/* 
 *	CArrayBase::Elem(iel)
 *
 *	@mfunc	Returns a pointer to the element indexed by <p iel>
 *
 *	@rdesc	A pointer to the element indexed by <p iel>.  This pointer may
 *	be cast to a pointer of the appropriate element type.
 */
void* CArrayBase::Elem(
	LONG iel) const	//@parm Index to use
{
	_TEST_INVARIANT_

	// This can arise with empty froms^3 controls.
	// Review (keithcu) Why did this start happening in Richedit 3?
	if (!_cel)
		return NULL;

	AssertSz(iel == 0 || (iel > 0 && iel < _cel),
		"CArrayBase::Elem() - Index out of range");

	return _prgel + iel * _cbElem;
}								 
#endif

/*
 *	CArrayBase::CArrayBase
 *
 *	@mfunc Constructor
 */
CArrayBase::CArrayBase(
	LONG cbElem)		//@parm	Size of an individual array element
{	
	_prgel = NULL; 
	_cel = 0; 
	_celMax = 0; 
	_cbElem = cbElem;
}

/*
 *	CArrayBase::ArAdd
 *
 *	@mfunc	Adds <p celAdd> elements to the end of the array.
 *
 *	@rdesc	A pointer to the start of the new elements added.  If non-NULL, 
 *	<p pielIns> will be set to the index at which elements were added.
 *
 *  We grow in steps of celGrow when small and exponentially when large.
 */
void* CArrayBase::ArAdd(
	LONG celAdd,	//@parm Count of elements to add
	LONG *pielIns)	//@parm Out parm for index of first element added
{
	_TEST_INVARIANT_
	char *pel;

	if(_cel + celAdd > _celMax)					// need to grow 
	{
		LONG celNew = max(celAdd, celGrow) + _cel / 16;
		pel = (char*)PvReAlloc(_prgel, (_celMax + celNew) * _cbElem);
		if(!pel)
			return NULL;
		_prgel = pel;
		_celMax += celNew;
	}
	pel = _prgel + _cel * _cbElem;
	ZeroMemory(pel, celAdd * _cbElem);

	if(pielIns)
		*pielIns = _cel;

	_cel += celAdd;
	return pel;
}

/*
 *	CArrayBase::ArInsert (iel, celIns)
 *
 *	@mfunc Inserts <p celIns> new elements at index <p iel>
 *
 *	@rdesc A pointer to the newly inserted elements.  Will be NULL on
 *	failure.
 */
void* CArrayBase::ArInsert(
	LONG iel,		//@parm	Index at which to insert
	LONG celIns)	//@parm Count of elements to insert
{
	char *pel;

	_TEST_INVARIANT_

	AssertSz(iel <= _cel, "CArrayBase::Insert() - Insert out of range");

	if(iel >= _cel)
		return ArAdd(celIns, NULL);

	if(_cel + celIns > _celMax)				// need to grow 
	{
		AssertSz(_prgel, "CArrayBase::Insert() - Growing a non existent array !");

		LONG celNew = max(celIns, celGrow) + _cel / 16;
		pel = (char*)PvReAlloc(_prgel, (_celMax + celNew) * _cbElem);
		if(!pel)
		{
			TRACEERRORSZ("CArrayBase::Insert() - Couldn't realloc line array");
			return NULL;
		}
		_prgel = pel;
		_celMax += celNew;
	}
	pel = _prgel + iel * _cbElem;
	if(iel < _cel)				// Nove Elems up to make room for new ones
		MoveMemory(pel + celIns*_cbElem, pel, (_cel - iel)*_cbElem);

	_cel += celIns;
	return pel;
}

/*
 *	CArrayBase::Remove
 *
 *	@mfunc	Removes the <p celFree> elements from the array starting at index
 *	<p ielFirst>.  If <p celFree> is negative, then all elements after
 *	<p ielFirst> are removed.
 *
 *	@rdesc nothing
 */
void CArrayBase::Remove(
	LONG ielFirst, 		//@parm Index at which elements should be removed
	LONG celFree) 		//@parm	Count of elements to remove. 
{
	char *pel;

	_TEST_INVARIANT_

	if(celFree < 0)
		celFree = _cel - ielFirst;

	AssertSz(ielFirst + celFree <= _cel, "CArrayBase::Free() - Freeing out of range");

	if(_cel > ielFirst + celFree)
	{
		pel = _prgel + ielFirst * _cbElem;
		MoveMemory(pel, pel + celFree * _cbElem,
			(_cel - ielFirst - celFree) * _cbElem);
	}

	_cel -= celFree;

	if(_cel < _celMax - celGrow - _cel / 16)
	{
		// Shrink array
		_celMax = max(_cel, celGrow);
		_prgel = (char*)PvReAlloc(_prgel, _celMax * _cbElem);
		Assert(_prgel);
	}
}

/*
 *	CArrayBase::Clear
 *
 *	@mfunc	Clears the entire array, potentially deleting all of the memory
 *	as well.
 *
 *	@rdesc	nothing
 */
void CArrayBase::Clear(
	ArrayFlag flag)	//@parm Indicates what should be done with the memory
					//in the array.  One of AF_DELETEMEM or AF_KEEPMEM
{
	_TEST_INVARIANT_

	if( flag == AF_DELETEMEM )
	{
		FreePv(_prgel);
		_prgel = NULL;
		_celMax = 0;
	}
	else if (_prgel)
	{
		_celMax = min(celGrow, _celMax);
		_prgel = (char*) PvReAlloc(_prgel, celGrow * _cbElem);
	}
	_cel = 0;
}

/*
 *	CArrayBase::Replace
 *
 *	@mfunc	Replaces the <p celRepl> elements at index <p ielRepl> with the
 *	contents of the array specified by <p par>.  If <p celRepl> is negative,
 *	then the entire contents of <p this> array starting at <p ielRepl> should
 *	be replaced.
 *
 *	@rdesc	Returns TRUE on success, FALSE otherwise.
 */
BOOL CArrayBase::Replace(
	LONG ielRepl, 		//@parm index at which replacement should occur
	LONG celRepl, 		//@parm number of elements to replace (may be
						//		negative, indicating that all
	CArrayBase *par)	//@parm array to use as the replacement source
{
	_TEST_INVARIANT_

	LONG celMove = 0;
	LONG celIns = par->Count();
	
	if (celRepl < 0)
		celRepl = _cel - ielRepl;

	AssertSz(ielRepl + celRepl <= _cel, "CArrayBase::ArReplace() - Replacing out of range");
	
	celMove = min(celRepl, celIns);

	if (celMove > 0) 
	{
		MoveMemory(Elem(ielRepl), par->Elem(0), celMove * _cbElem);
		celIns -= celMove;
		celRepl -= celMove;
		ielRepl += celMove;
	}

	Assert(celIns >= 0);
	Assert(celRepl >= 0);
	Assert(celIns + celMove == par->Count());

	if(celIns > 0)
	{
		Assert(celRepl == 0);
		void *pelIns = ArInsert (ielRepl, celIns);
		if (!pelIns)
			return FALSE;
		MoveMemory(pelIns, par->Elem(celMove), celIns * _cbElem);
	}
	else if(celRepl > 0)
		Remove (ielRepl, celRepl);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\aimm_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Tue Jan 13 08:56:29 1998
 */
/* Compiler settings for aimm.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_ActiveIMM = {0x4955DD30,0xB159,0x11d0,{0x8F,0xCF,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IEnumRegisterWordA = {0x08C03412,0xF96B,0x11d0,{0xA4,0x75,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IEnumRegisterWordW = {0x4955DD31,0xB159,0x11d0,{0x8F,0xCF,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IAIMMRegistrar = {0xc7afa428,0x5007,0x11d1,{0xaa,0x94,0x00,0x60,0xb0,0x67,0xb8,0x6e}};


const IID IID_IActiveIMMMessagePumpOwner = {0xb5cf2cfa,0x8aeb,0x11d1,{0x93,0x64,0x00,0x60,0xb0,0x67,0xb8,0x6e}};


const IID IID_IActiveIMMApp = {0x08c0e040,0x62d1,0x11d1,{0x93,0x26,0x00,0x60,0xb0,0x67,0xb8,0x6e}};


const IID IID_IActiveIMMIME = {0x08C03411,0xF96B,0x11d0,{0xA4,0x75,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IActiveIME = {0x6FE20962,0xD077,0x11d0,{0x8F,0xE7,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const CLSID CLSID_CActiveIMM = {0x4955DD33,0xB159,0x11d0,{0x8F,0xCF,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\antievt.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	ANTIEVT.C |
 *
 *	Purpose:
 *		implemenation of common anti-events and a caching mechanism
 *
 *	Author:
 *		alexgo 3/25/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_edit.h"
#include "_range.h"
#include "_select.h"
#include "_format.h"
#include "_coleobj.h"
#include "_objmgr.h"
#ifdef DEBUG
#include "_uspi.h"
#endif

ASSERTDATA


//
// CAntiEventDispenser global instance
//
CAntiEventDispenser gAEDispenser;


//
//	CBaseAE PUBLIC methods
//

/*
 *	CBaseAE::Destroy ()
 *
 *	@mfunc
 *		sends the Destroy notification to the next anti-event in the list
 */

void CBaseAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::Destroy");
	;
}

/*
 *	CBaseAE::Undo (ped, publdr)
 *
 *	@mfunc
 *		sends the Undo notification to the next anti-event in the list
 *
 *	@rdesc	HRESULT
 */
HRESULT CBaseAE::Undo(
	CTxtEdit *ped,			//@parm	the context for this undo operation
	IUndoBuilder *publdr)	//@parm the undo context.
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::Undo");
	return NOERROR;
}

/*
 *	CBaseAE::OnCommit (ped)
 *
 *	@mfunc	called after the anti-event is added to the undo stack
 *
 *	@rdesc	void
 */
void CBaseAE::OnCommit(
	CTxtEdit *ped)			//@parm the edit context
{
	;
}

/*
 *	CBaseAE::MergeData (dwDataType, pdata)
 *
 *	@mfunc	simply forwards the merge data request to the next anti-evt
 *			(if one exists)
 *
 *	@rdesc	HRESULT.  If S_FALSE, indicates that nothing could be done
 *			with the merge data.
 */
HRESULT	CBaseAE::MergeData(
	DWORD dwDataType, 		//@parm the type of data in <p pdata>
	void *pdata)			//@parm the merge data
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::MergeData");

	return S_FALSE;
}

/*
 *	CBaseAE::SetNext
 *
 *	@mfunc
 *		informs this anti-event of the anti-event which should follow it
 */
void CBaseAE::SetNext(
	IAntiEvent *pNext)		//@parm	the AntiEvent to link to
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::SetNext");

	_pnext  = pNext;
}

/*
 *	CBaseAE::GetNext
 *
 *	@mfunc
 *		retrieves the next element (if any)
 *
 *	@rdesc	a pointer to the next AntiEvent
 */
IAntiEvent *CBaseAE::GetNext()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::GetNext");

	return _pnext;
}

//
// CBaseAE PROTECTED methods
//

/*
 *	CBaseAE::CBaseAE()
 *
 *	@mfunc	Constructor
 */
CBaseAE::CBaseAE()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::CBaseAE");

	_pnext = NULL;
}

/*
 *	CReplaceRangeAE::Destroy ()
 *
 *	@mfunc
 *		deletes this instance
 */
void CReplaceRangeAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::Destroy");

	if(_paeCF)
	{
		_paeCF->Destroy();
		_paeCF = NULL;
	}
	if(_paePF)
	{
		_paePF->Destroy();
		_paePF = NULL;
	}

	CBaseAE::Destroy();
	delete this;
}
	
/*
 *	CReplaceRangeAE::Undo (ped, publdr)
 *
 *	@mfunc
 *		undoes a CTxtPtr::ReplaceRange operation
 *
 *	@comm	
 *	Algorithm:
 *
 *		A replace range works as follows:  delete n characters and in their
 *		place, put m characters.
 *
 *		To undo this, we delete m characters and restore the n that were
 *		originally deleted.  Note that we restore the n characters with
 *		default formatting.  If there was any other formatting to those
 *		characters, a separate anti-event (CReplaceFormattingAE) will
 *		apply the correct formatting.
 */
HRESULT CReplaceRangeAE::Undo(
	CTxtEdit *ped,			//@parm	Context for this undo operation
	IUndoBuilder *publdr)	//@parm Undo context	
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::Undo");

	CRchTxtPtr	rtp(ped, _cpMin);
	LONG		cchMove = 0;

	rtp.ReplaceRange(_cpMax - _cpMin,
		             _cchDel,
					 _pchDel,
					 publdr,
					 -1,
					 &cchMove,
					 RR_NO_EOR_CHECK | RR_ITMZ_NONE);		// RAID 6554


	// Passing NULL for the publdr is *extremely* important
	// below.  The rich text pointer ReplaceRange call will
	// already generate the appropriate anti-events for any
	// deleted formatting, so we do not need to repeat that here.

	if(_paeCF)
		_paeCF->Undo(ped, NULL);

	if(_paePF)
		_paePF->Undo(ped, NULL);


	if (ped->IsComplexScript())
	{
		// For complex script doc, we need itemization at the end of the range undo.
		// Since the formattings were rolled back. The rtp's runptrs are no longer
		// reliable.

		if (_paeCF && rtp._rpCF.IsValid())
			rtp._rpCF.BindToCp(_cpMin + _cchDel);

		if (_paePF && rtp._rpPF.IsValid())
			rtp._rpPF.BindToCp(_cpMin + _cchDel);

		rtp.ItemizeReplaceRange(_cchDel, cchMove, NULL, FALSE);
	}

	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CReplaceRangeAE::MergeData (dwDataType, pdata)	
 *
 *	@mfunc	gives the caller a chance to extend the current anti-event
 *			if we're in merge typing mode
 *
 *	@comm	if the requested data can be trivially merged into this
 *			anti-event, then do so; otherwise, return S_FALSE.
 *
 *			There are two cases of interest:  <nl>
 *				1. typing another character
 *				2. backspacing over a character in this merge
 *				   typing session.
 */
HRESULT CReplaceRangeAE::MergeData(
	DWORD dwDataType, 		//@parm	the type of <p pdata>
	void *pdata)			//@parm the merge data
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::MergeData");

	if(dwDataType == MD_SIMPLE_REPLACERANGE)
	{
		SimpleReplaceRange *psr = (SimpleReplaceRange *)pdata;

		// Test for first case: just typing another character
		if(psr->cpMin == _cpMax && psr->cchDel == 0)
		{
			_cpMax = psr->cpMax;
			return NOERROR;
		}
		// Second case: deleting text stored in this antievent
		if (psr->cpMax == psr->cpMin &&
			psr->cpMin + psr->cchDel == _cpMax &&
			psr->cpMin >= _cpMin)
		{
			_cpMax = psr->cpMax;
			return NOERROR;
		}
	}
	return S_FALSE;
}	

/*
 *	CReplaceRangeAE::CReplaceRangeAE (cpMin, cpMax, cchDel, pchDel, paeCF, paePF)
 *
 *	@mfunc	Constructor for a text replace range anti-event
 */
CReplaceRangeAE::CReplaceRangeAE(
	LONG cpMin, 			//@parm cp starting the *final* range
	LONG cpMax, 			//@parm cp ending the *final* range
	LONG cchDel, 			//@parm # of chars deleted during ReplaceRange
	TCHAR *pchDel, 			//@parm deleted characters.  Ownership of
							//		memory is transferred to this object.
	IAntiEvent *paeCF,		//@parm Anti-event for any character formatting
							//		replacement
	IAntiEvent *paePF)		//@parm Anti-event for any paragraph formatting
							//		replacement
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::CReplaceRangeAE");

	_cpMin 	= cpMin;
	_cpMax 	= cpMax;
	_cchDel = cchDel;
	_pchDel	= pchDel;
	_paeCF  = paeCF;
	_paePF  = paePF;
}

/*
 *	CReplaceRangeAE::~CReplaceRangeAE ()
 *
 *	@mfunc	Destructor
 */
CReplaceRangeAE::~CReplaceRangeAE()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::~CReplaceRangeAE");
		
	if(_pchDel)
		delete _pchDel;
}

/*
 *	CReplaceFormattingAE
 *
 *	@mfunc	Destroys this instance
 */
void CReplaceFormattingAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::Destroy");

	CBaseAE::Destroy();
	delete this;
}

/*
 *	CReplaceFormattingAE::Undo (ped, publdr)
 *
 *	@mfunc		Undoes a formatting operation
 *
 *	@devnote	This anti-event assumes that the text to which formatting
 *				should be applied exists!!
 */			
HRESULT CReplaceFormattingAE::Undo(
	CTxtEdit *ped,			//@parm CTxtEdit closure
	IUndoBuilder *publdr)	//@parm Undo builder context
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::Undo");

	LONG			cchEaten;
	LONG			cchTotal = 0;
	LONG			delta;
	LONG			i;
	LONG			iRunMerge;
	IAntiEvent *	pae;
	IFormatCache *	pf = _fPara
					   ? (IFormatCache *)GetParaFormatCache()
					   : (IFormatCache *)GetCharFormatCache();
	CNotifyMgr *	pnm = ped->GetNotifyMgr();
	CFormatRuns **	ppfmtruns;
	CTxtStory *		pStory = ped->GetTxtStory();
	const CParaFormat * pDefPF = _fPara ? pStory->GetParaFormat(-1) : NULL;
	BYTE			bDefPFLevel = pDefPF && pDefPF->IsRtlPara() ? 1 : 0;

	// First set things up correctly for whether we are paragraph
	// or character formatting
	CFormatRunPtr rp(_fPara ? pStory->GetPFRuns() :pStory->GetCFRuns());

	// Count up count of characters affected
	for(i = 0 ; i < _cRuns; i++)
		cchTotal += _prgRuns[i]._cch;

	// We are going to be adding in some runs, so be sure the format
	// run array is allocated!
	if(!rp.IsValid())
	{
		ppfmtruns = _fPara ? &(pStory->_pPFRuns) : &(pStory->_pCFRuns);

		if(!rp.InitRuns(0, ped->GetTextLength(), ppfmtruns))
			return E_OUTOFMEMORY;

		// tell folks we allocated a new run
		if(pnm)
			pnm->NotifyPostReplaceRange(NULL, CP_INFINITE, 0, 0, CP_INFINITE, CP_INFINITE);
	}
	// Now do a pre-notification of the change we are about to make
	// This let's objects like a delayed render data object grab
	// any data *before* we change it.

	rp.BindToCp(_cp);

	// do a little more checking
	AssertNr(rp.CalcTextLength() == ped->GetTextLength());

	if(pnm)
		pnm->NotifyPreReplaceRange(NULL, CP_INFINITE, 0, 0, _cp, _cp + cchTotal);

	// We want to merge runs with where we start plus one behind.
	iRunMerge = rp._iRun;
	if(iRunMerge > 0)
		iRunMerge--;

	// if we need to be able to undo this opertion, go through and
	// save existing run information
	if(publdr)
	{
		LONG	cchBackup = 0, cchAdvance = 0;
		if (ped->IsBiDi())
		{
			// For redo'ing purpose, we expand the range to keep in the antievent
			// to make sure that BiDi levels are recorded adequately.
			CRchTxtPtr	rtp(ped, _cp);
			cchBackup = rtp.ExpandRangeFormatting(cchTotal, 0, cchAdvance);
			Assert(cchBackup >= 0);
		}
		rp.AdvanceCp(-cchBackup);
		pae = gAEDispenser.CreateReplaceFormattingAE(ped, rp, cchTotal + cchBackup + cchAdvance,
				pf, _fPara);
		rp.AdvanceCp(cchBackup);

		if(pae)
			publdr->AddAntiEvent(pae);
	}	

#ifdef DEBUG
	CTxtPtr	rtp(ped, _cp);
	WCHAR   ch;
#endif
	
	// Now go through and apply the saved formatting.
	for(i = 0; i < _cRuns; i++)
	{
		cchEaten = 0;

        // Use a do-while, because we may have a zero-length
        // format run.  We know we need to do "something" at
        // least once, because otherwise, we would not have
        // bothered creating a run!
		do
		{
			if (_fPara && _prgRuns[i]._iFormat == -1)
				// (#6768) The -1 format may have changed before undoing.
				_prgRuns[i]._level._value = bDefPFLevel;

			delta = rp.SetFormat(_prgRuns[i]._iFormat,
							_prgRuns[i]._cch - cchEaten, pf, &_prgRuns[i]._level);
			if(delta == -1)
			{
				ped->GetCallMgr()->SetOutOfMemory();
				break;
			}
			cchEaten += delta;
		} while(cchEaten < _prgRuns[i]._cch);

#ifdef DEBUG
		if (_fPara)
		{
			rtp.AdvanceCp(_prgRuns[i]._cch);
			ch = rtp.GetPrevChar();
			if(!IsASCIIEOP(ch))
			{
				rtp.MoveGapToEndOfBlock();			// Make it easier to see
				AssertSz(FALSE,							//  what's going on
					"CReplaceFormattingAE::Undo: PF run doesn't end with EOP");
			}
		}
#endif

	}

	// Merge formatting runs in case there are duplicate formatting
	// runs side by side
    rp.NextRun();
	rp.MergeRuns(iRunMerge, pf);

	// Make sure the runs are still OK.
	AssertNr(rp.CalcTextLength() == ped->GetTextLength());

	if(pnm)
		pnm->NotifyPostReplaceRange(NULL, CP_INFINITE, 0, 0, _cp, _cp + cchTotal);

	ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);

	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CReplaceFormattingAE::CReplaceFormattingAE(&rpIn, cch, pf, fPara)
 *
 *	@mfunc	Constructor.  During construction, we will loop through and
 *			find all of the formats for the given text range
 */
CReplaceFormattingAE::CReplaceFormattingAE(
	CTxtEdit		*ped,			//@parm CTxtEdit
	CFormatRunPtr	&rpIn, 			//@parm	Run pointer to start with
	LONG cch,						//@parm Count of characters to
									//		find formatting info on
	IFormatCache 	*pf,   			//@parm Format cache (to AddRef/
									//		Release formats)
	BOOL fPara)						//@parm If TRUE, formatting is for paras
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::CReplaceFormattingAE");

    LONG		  cchLeft;
	LONG		  cchtemp = (LONG)cch;
	LONG		  i;
	CFormatRunPtr rp(rpIn);			// We use 2 format run pointers to avoid
	CFormatRunPtr rpTemp(rpIn);		// backing up after counting the number of
									// format runs
	Assert(pf);

	// TODO: pass in cp as a parameter to avoid following calculation
	_cp = rpIn.CalculateCp();
	_fPara = fPara;

	// Count the number of formats needed.  Recall that even
    // if 0 characters are to be deleted, we may still be
    // "deleting" a zero length format run.
	_cRuns = 0;
    do
	{
		_cRuns++;
        cchLeft = rp.GetCchLeft();
		cchtemp -= min(cchLeft, cchtemp);
        rp.NextRun();
	} while(cchtemp > 0);

	_prgRuns = new CFormatRun[_cRuns];

	if(!_prgRuns)
	{
		_cRuns = 0;
		return;
	}

	// Would be nice to add this but ped is not passed in
	// CTxtPtr	rtp(ped, _cp);
	// WCHAR   ch;

	for(i = 0; i < _cRuns; i++)
	{
		_prgRuns[i]._cch = min(cch, rpTemp.GetCchLeft());
		CFormatRun *pRun = rpTemp.GetRun(0);

		_prgRuns[i]._iFormat = pRun->_iFormat;

		_prgRuns[i]._level = pRun->_level;
		pf->AddRef(_prgRuns[i]._iFormat);
		rpTemp.NextRun();
		cch -= _prgRuns[i]._cch;

		#if 0
		// Would be nice dor DEBUG but ped is not passed in

		if (_fPara)
		{
			rtp.AdvanceCp(_prgRuns[i]._cch);
			ch = rtp.GetPrevChar();
			if(!IsASCIIEOP(ch))
			{
				rtp.MoveGapToEndOfBlock();			// Make it easier to see
				AssertSz(FALSE,							//  what's going on
					"CReplaceFormattingAE::CReplaceFormattingAE: PF run doesn't end with EOP");
			}
		}
		#endif
	}

	Assert(cch == 0);
}

/*
 * 	CReplaceFormattingAE::~CReplaceFormattingAE	()
 *
 *	@mfunc	Destructor
 */
CReplaceFormattingAE::~CReplaceFormattingAE()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::~CReplaceFormattingAE");

	IFormatCache *	pf = _fPara
					   ? (IFormatCache *)GetParaFormatCache()
					   : (IFormatCache *)GetCharFormatCache();
	if(_prgRuns)
	{
		if(pf)
		{
			for(LONG i = 0; i < _cRuns; i++)
				pf->Release(_prgRuns[i]._iFormat);
		}
		delete _prgRuns;
	}
}

//
//	CReplaceObjectAE PUBLIC methods
//

/*
 *	CReplaceObjectAE::Destroy()
 *
 *	@mfunc	Destroy's this object
 */
void CReplaceObjectAE::Destroy()
{
	COleObject *pobj;

	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::Destroy");

	pobj = _pobj;
	_pobj = NULL;

	// we only need to zombie the object if it wasn't put back into
	// the document.
	if(!_fUndoInvoked)
		pobj->MakeZombie();

	pobj->Release();
	CBaseAE::Destroy();
	delete this;
}

/*
 *	CReplaceObjectAE::Undo (ped, publdr)
 *
 *	@mfunc	Undo'es the delete operation and restores the object
 *			to it's original state
 *
 *	@rdesc	HRESULT
 */
HRESULT CReplaceObjectAE::Undo(
	CTxtEdit *ped,			//@parm	edit context
	IUndoBuilder *publdr)	//@parm undo/redo context
{
	CObjectMgr *pobjmgr;

	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::Undo");

	pobjmgr = ped->GetObjectMgr();
	if(_pobj && pobjmgr)
	{
		_fUndoInvoked = TRUE;
		_pobj->Restore();
		pobjmgr->RestoreObject(_pobj);
	}

	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CReplaceObjectAE::OnCommit(ped)
 *
 *	@mfunc	called when the anti-event chain is committed to the
 *			undo stack.  This gives us a chance to make 'dangerous'
 *			calls that could cause us to be re-entered.
 */
void CReplaceObjectAE::OnCommit(
	CTxtEdit *ped)			//@parm the edit context
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::OnCommit");
	_pobj->Close(OLECLOSE_SAVEIFDIRTY);
}

//
//	CReplaceObjectAE PRIVATE methods
//

/*
 *	CReplaceObjectAE::CReplaceObjectAE (pobj)
 *
 *	@mfunc	constructor
 */
CReplaceObjectAE::CReplaceObjectAE(
	COleObject *pobj)		//@parm object that was deleted
{
	_fUndoInvoked = FALSE;
	_pobj = pobj;
	_pobj->AddRef();
}

/*
 *	CReplaceObjectAE::~CReplaceObjectAE
 *
 *	@mfunc	destructor
 */
CReplaceObjectAE::~CReplaceObjectAE()
{
	Assert(_pobj == NULL);
}

//
//	CResizeObjectAE PUBLIC methods
//

/*
*	CResizeObjectAE::Destroy
 *
 *	@mfunc	Destroy's this object
 */
void CResizeObjectAE::Destroy(void)
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CResizeObjectAE::Destroy");

	_pobj = NULL;
	CBaseAE::Destroy();

	delete this;
}

/*
 *	CResizeObjectAE::Undo(ped, publdr)
 *
 *	@mfunc	Undo'es the resize operation and restores the object
 *			to it's original size/position
 *
 *	@rdesc	HRESULT
 */
HRESULT CResizeObjectAE::Undo(
	CTxtEdit *ped,			//@parm	edit context
	IUndoBuilder *publdr)	//@parm undo/redo context
{
	CObjectMgr *pobjmgr;

	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::Undo");

	pobjmgr = ped->GetObjectMgr();

	if(_pobj && pobjmgr)
	{
		_fUndoInvoked = TRUE;
		_pobj->Resize(_rcPos);
	}

	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CResizeObjectAE::OnCommit
 *
 *	@mfunc	called when the anti-event chain is committed to the
 *			undo stack.  This gives us a chance to make 'dangerous'
 *			calls that could cause us to be re-entered.
 */
void CResizeObjectAE::OnCommit(
	CTxtEdit *ped)			//@parm the edit context
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::OnCommit");
}

//
//	CResizeObjectAE PRIVATE methods
//

/*
 *	CResizeObjectAE::CResizeObjectAE (pobj, rcPos)
 *
 *	@mfunc	constructor
 *
 *	@rdesc	void
 */
CResizeObjectAE::CResizeObjectAE(
	COleObject *pobj,		//@parm the object that was resized
	RECT		rcPos)		//@parm the old position/size rect
{
	_fUndoInvoked = FALSE;
	_pobj = pobj;
	_rcPos = rcPos;
}

/*
 *	CResizeObjectAE::~CResizeObjectAE
 *
 *	@mfunc	destructor
 */
CResizeObjectAE::~CResizeObjectAE(void)
{
	Assert(_pobj == NULL);
}

//
//  CSelectionAE PUBLIC methods
//

/*
 *  CSelectionAE::Destroy ()
 *
 *  @mfunc  gets rid of this instance
 *
 *  @rdesc  void
 */
void CSelectionAE::Destroy()
{
    TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CSelectionAE::Destroy");

    CBaseAE::Destroy();
    delete this;
}

/*
 *  CSelectionAE::Undo (ped, publdr)
 *
 *  @mfunc  restore the selection to it's former position
 *
 *  @rdesc  NOERROR
 */
HRESULT CSelectionAE::Undo(
    CTxtEdit *ped,          //@parm the context for this undo operation
    IUndoBuilder *publdr)   //@parm the undo context
{
    TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CSelectionAE::Destroy");

    CTxtSelection *psel = ped->GetSel();

    if(psel)
        psel->SetDelayedSelectionRange(_cp, _cch);

	if(publdr)
	{
		IAntiEvent *pae;
		pae = gAEDispenser.CreateSelectionAE(ped, _cpNext, _cchNext,
					_cp, _cch);
		if(pae)
			publdr->AddAntiEvent(pae);
	}
	return CBaseAE::Undo(ped, publdr);
}

/*
 *  CSelectionAE::MergeData(dwDataType, pdata)
 *
 *  @mfunc  merges new selection data
 *
 *  @rdesc  S_FALSE, NOERROR
 *
 *	@comm	The mergine algorithm is fairly tricky.  There are basically two
 *			cases of interest:  group typing and drag-move.
 *
 *			In the group typing case, the "start" of the typing becomes a
 *			fixed reference from which characters are added or removed (i.e.
 *			you type or hit the backspace key).  "Undo" should return you to
 *			that reference point; redo, on the other hand, should return the
 *			selection to the last insertion point.  Thus, we only update
 *			_xxNext for the SELAE_MERGE action.
 *
 *			Drag-Move is somewhat different; in this case, there are really
 *			two actions--the "paste" on the drop, and the subsequent "cut"
 *			operation.  Thus, we need to be able to update the selection
 *			anti-event during the cut (since this only happens on move; not
 *			copies).  This is accomplished with teh FORCEREPLACE flag
 *			and by setting fields to -1 to be ignored.
 *
 */
HRESULT CSelectionAE::MergeData(
    DWORD dwDataType,       //@parm the type of data in <p pdata>
    void *pdata)            //@parm the merge data
{
    TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CSelectionAE::MergeData");

    SelRange *psrg = (SelRange *)pdata;

    if(dwDataType == MD_SELECTIONRANGE)
    {
		if(psrg->flags == SELAE_MERGE)
		{
			Assert(psrg->cpNext != -1);
			_cpNext = psrg->cpNext;
			_cchNext = psrg->cchNext;
		}
		else
		{
			// -1 is used a no-op, so we should ignore it
			if(psrg->cp != -1)
			{
				_cp = psrg->cp;
				_cch = psrg->cch;
			}
			if(psrg->cpNext != -1)
			{
				_cpNext = psrg->cpNext;
				_cchNext = psrg->cchNext;
			}
		}
        return NOERROR;
    }
    return S_FALSE;
}

//
//  CSelectionAE PRIVATE methods
//

/*
 *  CSelectionAE::CSelectionAE (cp, cch, cpNext, cchNext)
 *
 *  @mfunc  Constructor
 */
CSelectionAE::CSelectionAE(
    LONG    cp,             //@parm the actve end cp
    LONG    cch,            //@parm the signed extension
	LONG	cpNext,			//@parm the cp to use for the AE of this AE
	LONG	cchNext)		//@parm the cch for the AE of this AE
{
    _cp			= cp;
    _cch		= cch;
    _cpNext		= cpNext;
	_cchNext	= cchNext;
}

/*
 *  CSelectionAE::~CSelectionAE()
 *
 *  @mfunc  desctructor
 */
CSelectionAE::~CSelectionAE()
{
    ;
}

/*
 *	CAntiEventDispenser::CreateReplaceRangeAE(ped, cpMin, cpMax, cchDel,
 *											  pchDel, paeCF, paePF)
 *	@mfunc
 *		creates an anti-event for a replace range operation
 */
IAntiEvent * CAntiEventDispenser::CreateReplaceRangeAE(
	CTxtEdit *ped,			//@parm edit context
	LONG cpMin, 			//@parm cp starting the *final* range
	LONG cpMax, 			//@parm cp ending the *final* range
	LONG cchDel, 			//@parm # of chars deleted during ReplaceRange
	TCHAR *pchDel,			//@parm Deleted characters.  Ownership of
							//  memory is transferred to this object.
	IAntiEvent *paeCF,		//@parm Anti-event for any character formatting
							// replacement
	IAntiEvent *paePF)		//@parm Anti-event for any paragraph formatting
							// replacement	
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CAntiEventDispenser::CreateReplaceRangeAE");

	// FUTURE (alexgo): improve the efficiency of this routine!!
	IAntiEvent *pae;

	pae = (IAntiEvent *)(new CReplaceRangeAE(cpMin, cpMax, cchDel, pchDel,
								paeCF, paePF));

	if(!pae)
	{
		// we don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}

	return pae;
}

/*
 *	CAntiEventDispenser::CreateReplaceFormattingAE(ped, &rp, cch, pf, fPara)
 *
 *	@mfunc	Creates an anti-event for replacing formatting
 */
IAntiEvent * CAntiEventDispenser::CreateReplaceFormattingAE(
	CTxtEdit *ped,					//@parm Edit context
	CFormatRunPtr &rp, 				//@parm	Run pointer to start with
	LONG cch,						//@parm Countof characters to
									//		find formatting info on
	IFormatCache *pf,				//@parm Format cache (to AddRef/
									//Release formats)
	BOOL fPara)						//@parm If TRUE, formatting is paragraphs
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CAntiEventDispenser::CreateReplaceFormattingAE");

	// FUTURE (alexgo): improve the efficiency of this routine!!!
	IAntiEvent *pae;
	pae = (IAntiEvent *)(new CReplaceFormattingAE(ped, rp, cch, pf, fPara));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}

	return pae;
}

/*
 *	CAntiEventDispenser::CreateReplaceObjectAE (ped, pobj)
 *
 *	@mfunc	Creates an anti-event for replacing an object
 *
 *	@rdesc	the created anti-event
 */
IAntiEvent * CAntiEventDispenser::CreateReplaceObjectAE(
	CTxtEdit *ped,					//@parm the edit context.
	COleObject *pobj)				//@parm the object that was deleted
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN,
		"CAntiEventDispenser::CreateReplaceObjectAE");

	IAntiEvent *pae;

	// Always allocating is probably a reasonable strategy for objects;
	// they are not expected to be the bread & butter case.
	pae = (IAntiEvent *)(new CReplaceObjectAE(pobj));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}

	return pae;
}

/*
 *	CAntiEventDispenser::CreateResizeObjectAE (ped, pobj, rcPos)
 *
 *	@mfunc	Creates an anti-event for resizing an object
 *
 *	@rdesc	the created anti-event
 */
IAntiEvent * CAntiEventDispenser::CreateResizeObjectAE(
	CTxtEdit *ped,					//@parm the edit context.
	COleObject *pobj,				//@parm the object that was resized
	RECT rcPos)						//@parm the old object position rectangle
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN,
		"CAntiEventDispenser::CreateResizeeObjectAE");

	IAntiEvent *pae;

	// Always allocating is probably a reasonable strategy for objects;
	// they are not expected to be the bread & butter case.

	pae = (IAntiEvent *)(new CResizeObjectAE(pobj, rcPos));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}
	return pae;
}

/*
 *  CAntiEventDispenser::CreateSelectionAE (ped, cp, cch, cpNext, cchNext)
 *
 *  @mfunc  Creates an anti-event for restoring a non-degenerate selection
 *
 *  @rdesc  the created anti-event
 */
IAntiEvent * CAntiEventDispenser::CreateSelectionAE(
	CTxtEdit *ped,					//@parm edit context
    LONG    cp,                     //@parm the active end of the selection
    LONG    cch,                    //@parm the signed extension
	LONG	cpNext,					//@parm the cp to use for the AE of this AE
	LONG	cchNext)				//@parm the cch to use for the AE
{
	// FUTURE (alexgo): improve the efficiency of this routine
	IAntiEvent *pae;

    pae = (IAntiEvent *)(new CSelectionAE(cp, cch, cpNext, cchNext));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}
	return pae;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\lssrc\warichu.c ===
/* ---------------------------------------------------------------
 : LineServices 3.0
 :
 : WARICHU ("Two lines in one" in Winword)
 :
 : Object Handler Routines 
 :
 : Contact: AntonS
 :
 ------------------------------------------------------------------ */

#include	"lsmem.h"
#include	"limits.h"
#include	"warichu.h"
#include	"objhelp.h"
#include	"lsesc.h"
#include	"lscbk.h"
#include	"lsdevres.h"
#include	"pdobj.h"
#include	"objdim.h"
#include	"plssubl.h"
#include	"plsdnode.h"
#include	"pilsobj.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnset.h"
#include	"zqfromza.h"
#include	"lstfset.h"
#include	"lsdocinf.h"
#include	"fmti.h"
#include	"posichnk.h"
#include	"locchnk.h"
#include	"lsdnfin.h"
#include	"brko.h"
#include	"lspap.h"
#include	"plspap.h"
#include	"lsqsubl.h"
#include	"dispi.h"
#include	"lsdssubl.h"
#include	"dispmisc.h"
#include	"lstfset.h"
#include	"brkkind.h"

#include	"lschp.h"

 /* REVIEW (antons):

	- Assert that FormatUntilCpBreak fSuccessful

	- Assimetry between Prev and Next BreakWarichuDobj: it looks like
	  right margin as input to Next break may also optimize truncation.

	- In ForceBreak it may happen that dur < 0: What is the correct thing to do?

	- Invalid pdobj.wlayout when wwhole is not finished: dur must be
	  set correctly.

	- Can I assert that if subline was stopped at fmtrExceededMargin,
	  dur > RM.

	- Should ForceBreak return correct previous break if possible?

	- I rely on the following axiom:

	  If Warichu returned fmtrExceedMargin, it must be broken
	  inside (brkkind != brkkindImposedAfter)

	- Mod width: check method(s); should I count m-w in Warichu Truncation / Breaking 

	- Optimization of allocating WBRKREC

	- To have function GetDcpWarichu (additionally to GetCpLimOfWLayout)

    - Do something with FOpenBraceWLayout

	- Queries: callback to client saying where to snap?

    - Sergey: Assert in AdjustText & submitted sublines.

*/


/**********************************/
/*                                */
/* WARICHU Array of break records */
/*                                */
/**********************************/

typedef struct wbrkarray
{
	DWORD		nBreakRec;		/* Actual number of break records in the array */
	DWORD		nBreakRecMax;	/* Size of allocated array */
	BREAKREC	* rgBreakRec;	/* Ls array of break records */

	/* Note: Field nBreakRec is maintained by clients of this structure 
			 and it must be <= nBreakRecMax. nBreakRecMax and rgBreakRec
			 are set during allocation */

} WBRKARRAY;

typedef WBRKARRAY *PWBRKARRAY;


/****************************/
/*                          */
/* WARICHU Installed LS Obj */
/*                          */
/****************************/

typedef struct ilsobj
{
    POLS				pols;
    struct lscbk		lscbk;
	PLSC				plsc;
	DWORD				idobj;
	LSDEVRES			lsdevres;
	LSESC				lsescBraceOpen;
	LSESC				lsescText;
	LSESC				lsescBraceClose;
	WARICHUCBK			warichucbk;			/* Callbacks  to client application */
	BOOL				fContiguousFetch;	/* This flag was added to fix Word 9 bug */

} ILSOBJ;


/****************************/
/*                          */
/* WARICHU Internal Subline */
/*                          */
/****************************/

typedef struct wsubline
{
	PLSSUBL	plssubl;		/* Pointer to LS Subline */
	OBJDIM	objdim;			/* Dimensions of this subline */
	LSCP	cpFirst;		/* cp where formatting of this subline started */
	LSCP	cpLim;			/* cp-lim after formatting */

	/* Note: One exception when objdim & cpLim does not correspond to the
			 dimensions of the subline is the second subline in the Broken Warichu
			 before SetBreak. We lie putting objdim & cpLim of 
			 already broken subline. Durig Warichu SetBreak we call 
			 LsSetBreakSubline (plssubl...) and the lie turnes into the truth
	*/

} WSUBLINE;

typedef WSUBLINE *PWSUBLINE;


/****************************/
/*                          */
/* WARICHU Formatted Brace  */
/*                          */
/****************************/

typedef struct wbrace
{
	PLSSUBL plssubl;			/* Pointer to Ls subline with brace */
	OBJDIM  objdim;				/* Dimensions of the subline */
	LSCP	cpFirst;			/* cp-start formatting */
	LSCP	cpLim;				/* cp-lim after formatting */
	LSCP	cpLimAfterEsc;		/* cp-lim after brace ESC character (in our case cpLim + 1) */
	
} WBRACE;

typedef WBRACE *PBRACE;


/**********************/
/*                    */
/* WARICHU Dimensions */
/*                    */
/**********************/

typedef struct wdim
{
	OBJDIM	objdimAll;			/* Dimensions of the whole Warichu */
	long	dvpDescentReserved; /* Received from client together with objdimAll */
								/* REVIEW (antons): Clean this logic of calculating
													relative positions of warichu sublines */
} WDIM;


/************************/
/*                      */
/* WARICHU Layout		*/
/*                      */
/************************/

typedef struct wlayout
{
	WSUBLINE	wsubline1;		/* First subline in the layout (NULL if layout not valid) */
	WSUBLINE	wsubline2;		/* Second subline in the layout (NULL if no second line) */

	BOOL		fBroken;		/* Broken or whole Warichu? */
	BRKKIND		brkkind;		/* Kind of break to set at the end of second line if "Broken" */

	/*	Note: Although the following fields can be calculated using above data 
			  and DOBJ, it is filled by FinishObjDimLayout and nobody has the right 
			  to recalc it on his own way after it has been set. 
	*/

	WDIM		wdim;				/* Dimensions of the whole Warichu */

} WLAYOUT;

typedef WLAYOUT *PWLAYOUT;


/****************************/
/*                          */
/* WARICHU Kind of break    */
/*                          */
/****************************/

typedef enum wbreaktype 
{
	wbreaktypeInside,
	wbreaktypeAfter,
	wbreaktypeInvalid
	
} WBREAKTYPE;


/******************************************/
/*                                        */
/* Presentation Data for Warichu sublines */
/*                                        */
/******************************************/

typedef struct wdispsubl
{

	long	dup;		/* Dup of subline */
	POINTUV	duvStart;	/* Relative (from object start) position of subline */
						/* (in lstflow of the parent) */

} WDISPSUBL;

typedef WDISPSUBL *PWDISPSUBL;


/******************************************/
/*                                        */
/* Presentation Data for Warichu braces   */
/*                                        */
/******************************************/

typedef WDISPSUBL WDISPBRACE; /* Same as display information for sublines */

typedef WDISPBRACE *PWDISPBRACE;


/*****************************/
/*                           */
/* WARICHU Presentation Data */
/*                           */
/*****************************/

typedef struct wdisplay
{
	WDISPSUBL wdispsubl1;	/* Display information about Warichu first subline */
	WDISPSUBL wdispsubl2;	/* Display information about Warichu second subline */

	WDISPBRACE wdispbraceOpen;	/* Display information about Open brace */
	WDISPBRACE wdispbraceClose;	/* Display information about Closing brace */

	long dvpBetween;		/* REVIEW (antons): Do I need to store this? ;-) */
	long dupAll;			/* REVIEW (antons): Do I need to store this? ;-) */

} WDISPLAY;


/****************************/
/*                          */
/* WARICHU Whole subline    */
/*                          */
/****************************/

typedef struct wwhole
{
	PLSSUBL plssubl;	/* Whole formatted subline */

	LSCP cpFirst;		/* Cp first of the subline */
	LSCP cpLim;			/* Cp lim of the subline */

	OBJDIM objdim;		/* Dimensions of the formatted subline */

	long urColumnMax;	/* Column Max until we formatted the WHOLE line */
						/* REVIEW (antons): Do we need this? */

	BOOL fFinished;		/* If we have reached ESC character during formatting */

						/* REVIEW (antons): It seems now I can leave without cpTruncate at all */
	LSCP cpTruncate;	/* Truncation point at urColumnMax if fFinished = FALSE */
	LSCP cpLimAfterEsc;	/* First character after ESC if fFinished = TRUE */

	BOOL fJisRangeKnown;	/* Did we calculate cpJisRangeFirst & cpJisRangeLim? */

	/* The following two variables are valid only when "fJisRangeKnown == TRUE" */

	LSCP cpJisRangeFirst;	/* 4-th cpBreak break from the start of the WWhole subline */
	LSCP cpJisRangeLim;		/* 4-th cpBreak break from the end of WWhole subline */

	/* Note 1: Jis Range empty when cpJisRangeFirst >= cpJisRangeLim */
	/* Note 2: Jis Range defines possible set of Warichu breaks according
			   to JIS rule about 4 break opportunities before / after break. 
			   If cp belong to JisRange (cpJisRangeFirst <= cp < cpJisRangeLim)
			   it means that there are 4 break opportunities before / after cp. */
	/* Note 3: Jis Range is calculated only when neccesary (during breaking). After
			   formatting fJisRangeKnown==FALSE. When someone need Jis Range during
			   breaking, he should call CalcJisRange().
	*/

} WWHOLE;

typedef WWHOLE *PWWHOLE;

/***************************/
/*                         */
/* WARICHU DOBJ structure  */
/*                         */
/***************************/

struct dobj
{
	/* 1. Dobj life-time constant data */
		
	PILSOBJ		pilsobj;		 /* Pointer to ILS object */
	PLSDNODE	plsdnTop;		 /* Warichu parent DNode */

	LSCP		cpStart;		 /* Starting LS cp for object */
	LSCP		cpStartObj;		 /* Starting cp for object. If not Resumed => cpStartObj == cpStart */

	BOOL		fResumed;		 /* If Warichu was resumed  */
	/* REVIEW (antons): Can I assert that fResumed == (cpStart == cpStartObj) */

	LSTFLOW		lstflowParent;	 /* Lstflow of the parent subline */

	/* 2. Formattig + Breaking + Displaying */

	WLAYOUT		wlayout;			 /* Current layout after Formatting / SetBreak */

	WBRACE		wbraceOpen;		 /* Opening brace */
	WBRACE		wbraceClose;	 /* Closing brace */ 

	/* 3. Breaking */

	WBRKARRAY	wbrkarrayAtStart;

								/* Break records at line start */
								/* (if !fResumed => zero # of break records) */

	WWHOLE		wwhole;			 /* Structure containing warichu whole subline */

	WLAYOUT		wlayoutBreak [NBreaksToSave]; 
								 /* 3 break records for Prev / Next / Force */

	WLAYOUT		wlayoutTruncate; /* Optimization: we save the layout after Truncation */

	WBREAKTYPE	wbreaktype [NBreaksToSave];

	/* 4. Displaying */

	WDISPLAY	wdisplay;		/* Presentation info for current layout (valid after CalcPres) */

} DOBJ;


/***************************/
/*                         */
/* Some macors			   */
/*                         */
/***************************/

#define INT_UNDEFINED 0xFFFFFFFF
#define CP_MAX LONG_MAX

#define abs(x) ((x)<0 ? -(x) : (x))

#define max(a,b) ((a) > (b) ? (a) : (b))

#define ZeroObjDim(pobjdim) memset ((pobjdim), 0, sizeof(OBJDIM));

#define NOT !


/* O V E R F L O W  S A F E  A R I T H M E T I C S */
/*----------------------------------------------------------------------------
	%%Functions: ADDLongSafe, MULLongSafe
	%%Contact: antons

		Calculations with urColumnMax require special treatment because
		of possible overflow. Two functions below implement overflow-safe 
		arithmetics for ADD and MUL on positive (>=0) numbers.
		
----------------------------------------------------------------------------*/

/* ADDLongSafe: X + Y */

long ADDLongSafe (long x, long y) 
{
	Assert (x >= 0 && y >= 0);

	if (x > LONG_MAX - y) return LONG_MAX;
	else
		return x + y;
}

/* MULLongSafe: X * Y */

long MULLongSafe (long x, long y) 
{
	Assert (x >= 0 && y >= 0);

	if (y == 0) return 0;
	else if (x > LONG_MAX / y) return LONG_MAX;
	else
		return x * y;
}


/* W A  F I N D  N E X T  B R E A K  S U B L I N E */
/*----------------------------------------------------------------------------
	%%Function: WaFindNextBreakSubline
	%%Contact: antons

		Wrapper to LsFindNextBreakSubline () API. It makes sure that result is
		monotonous.

----------------------------------------------------------------------------*/
LSERR WaFindNextBreakSubline (

		PLSSUBL		plssubl, 
		LSCP		cpTruncate,	
		long		urColumnMax, 
		BOOL		* pfSuccessful, 
		LSCP		* pcpBreak,
		POBJDIM		pobjdimSubline )
{
	BRKPOS brkpos;

	LSERR lserr = LsFindNextBreakSubline ( plssubl, 
										   TRUE, 
										   cpTruncate, 
										   urColumnMax, 
										   pfSuccessful, 
										   pcpBreak, 
										   pobjdimSubline,
										   & brkpos );
	if (lserr != lserrNone) return lserr;

	if (* pfSuccessful) 
		{
		/* REVIEW (antons): Maybe still better have a loop for crazy case? */
		Assert (*pcpBreak > cpTruncate);

		/* REVIEW (antons): Check this Assert with Igor */
		Assert (brkpos != brkposBeforeFirstDnode);

		if (brkpos == brkposAfterLastDnode) *pfSuccessful = FALSE;
	};

	return lserrNone;
}

/* W A  F I N D  N E X T  B R E A K  S U B L I N E */
/*----------------------------------------------------------------------------
	%%Function: WaFindPrevBreakSubline
	%%Contact: antons

		Wrapper to LsForceBreakSubline () API. It makes sure that result is
		monotonous.

----------------------------------------------------------------------------*/
LSERR WaFindPrevBreakSubline (

		PLSSUBL		plssubl, 
		LSCP		cpTruncate,
		long		urColumnMax,
		BOOL		* pfSuccessful, 
		LSCP		* pcpBreak,
		POBJDIM		pobjdimSubline )
{
	BRKPOS brkpos;
	LSCP cpTruncateLoop;

	LSERR lserr = LsFindPrevBreakSubline ( plssubl, 
										   TRUE,
										   cpTruncate, 
										   urColumnMax, 
										   pfSuccessful, 
										   pcpBreak, 
										   pobjdimSubline,
										   & brkpos );
	if (lserr != lserrNone) return lserr;

	if (! *pfSuccessful) return lserrNone; 

	/* Successful => check monotonous and break "after"*/

	cpTruncateLoop = cpTruncate;

	while (brkpos == brkposAfterLastDnode || *pcpBreak > cpTruncate)
		{

		/*	Break is to the right from truncation point or 
			after the subline. Have to try another Prev Break 
		*/

		/* REVIEW (antons): Can I ever repeat this loop more then once? */

		cpTruncateLoop --;

		lserr = LsFindPrevBreakSubline ( plssubl,
										 TRUE, 
										 cpTruncateLoop,
										 urColumnMax,
										 pfSuccessful,
										 pcpBreak,
										 pobjdimSubline,
										 & brkpos );
		if (! *pfSuccessful) return lserrNone;

		};

	if (brkpos == brkposBeforeFirstDnode) 
		{
		*pfSuccessful = FALSE;
		return lserrNone;
		};

	Assert (*pfSuccessful);
	Assert (brkpos == brkposInside);
	Assert (*pcpBreak <= cpTruncate);

	return lserrNone;
}

/* W A  F O R C E  B R E A K  S U B L I N E */
/*----------------------------------------------------------------------------
	%%Function: WaForceForceBreakSubline
	%%Contact: antons

		Wrapper to LsForceBreakSubline () API.

----------------------------------------------------------------------------*/
LSERR WaForceBreakSubline ( PLSSUBL plssubl, 
						    LSCP	cpTruncate, 
						    long	dur, 
						    LSCP	* cpEnd, 
						    BRKPOS	* pbrkpos,
						    POBJDIM	pobjdim )
{
	LSERR	lserr;

	lserr = LsForceBreakSubline ( plssubl, TRUE, cpTruncate, dur, cpEnd, pobjdim,
								  pbrkpos );
	return lserr;
}

/* W A  D E S T R O Y  S U B L I N E  */
/*----------------------------------------------------------------------------
	%%Function: WaDestroySubline
	%%Contact: antons

		Wrapper to LsDestroySubline () API.

----------------------------------------------------------------------------*/
LSERR WaDestroySubline (PLSSUBL plssubl)
{
	if (plssubl != NULL) return LsDestroySubline (plssubl);
	else
		return lserrNone;
}


/* W A  M A T C H  P R E S  S U B L I N E   */
/*----------------------------------------------------------------------------
	%%Function: WaMatchPresSubline
	%%Contact: antons

		Wrapper to LsMatchPresSubline () API.

----------------------------------------------------------------------------*/
LSERR WaMatchPresSubline (PLSSUBL plssubl, long *pdup)
{
	LSERR lserr;
	BOOL fDone;
	LSTFLOW lstflowUnused;

	lserr = LssbFDonePresSubline (plssubl, &fDone);
	if (lserr != lserrNone) return lserr;

	if (!fDone)	lserr = LsMatchPresSubline (plssubl);
	if (lserr != lserrNone) return lserr; /* ;-) */

	lserr = LssbGetDupSubline (plssubl, &lstflowUnused, pdup);

	return lserr;
}


/* W A  E X P A N D  S U B L I N E  */
/*----------------------------------------------------------------------------
	%%Function: WaExpandSubline
	%%Contact: antons

		Wrapper to LsExpandSubline () API.

----------------------------------------------------------------------------*/
LSERR WaExpandSubline ( PLSSUBL	plssubl, 
					    LSKJUST	lskjust, 
					    long	dupExpand, 
					    long	* pdupSubline )
{
	LSERR lserr;
	LSTFLOW lstflowUnused;

	Unreferenced (dupExpand);
	Unreferenced (lskjust);

	lserr = LsExpandSubline (plssubl, lskjust, dupExpand);
	if (lserr != lserrNone) return lserr;

	lserr = LssbGetDupSubline (plssubl, &lstflowUnused, pdupSubline);
	return lserr;
}


/* S E T  B R E A K  W S U B L I N E  */
/*----------------------------------------------------------------------------
	%%Function: SetBreakWSubline
	%%Contact: antons

		Wrapper to LsSetBreakSubline () API for wsubline. Procedure changes
		objdim and cpLim of wsubline.

----------------------------------------------------------------------------*/

static LSERR SetBreakWSubline (
							   
		PWSUBLINE	pwsubline,		/* (IN): Subline to set break */
		BRKKIND		brkkind,		/* (IN): Kind of break to set */
		LSCP		cpLimBreak,		/* (IN): Cp-lim of the broken subline */
		POBJDIM		pobjdimBreak,	/* (IN): Dimensions of the broken subline */
		PWBRKARRAY	pwbrkarray)		/* (OUT): Array of break records */
{
	LSERR lserr;

	lserr = LsSetBreakSubline ( pwsubline->plssubl,
								brkkind,
								pwbrkarray->nBreakRecMax,
								pwbrkarray->rgBreakRec,
								& pwbrkarray->nBreakRec );

	pwsubline->objdim = * pobjdimBreak;
	pwsubline->cpLim = cpLimBreak;	

	#ifdef DEBUG 
	
		/* Check that pobjdimBreak contains correct dimensions of the broken subline */
		{ 
		OBJDIM objdimSubline;
		LSTFLOW lstflowSubline;

		lserr = LssbGetObjDimSubline (pwsubline->plssubl, &lstflowSubline, &objdimSubline);
		if (lserr != lserrNone) return lserr;

		Assert (memcmp (&objdimSubline, pobjdimBreak, sizeof(OBJDIM)) == 0);
		}

	#endif // DEBUG

	return lserr;
}


/* C L E A R  ... */
/*----------------------------------------------------------------------------
	%%Function: Clear...
	%%Contact: antons

		Set of procedures to clear all references from different warichu 
		data structures.
		
----------------------------------------------------------------------------*/

#define ClearWSubline(pwsubline) (pwsubline)->plssubl = NULL;

#define ClearWBrkArray(pwbrkarray) (pwbrkarray)->rgBreakRec = NULL;

#define ClearWBrace(pwbrace) (pwbrace)->plssubl = NULL;

#define ClearWWhole(pwwhole) (pwwhole)->plssubl = NULL;

static void ClearWLayout (PWLAYOUT pwlayout)
{
	ClearWSubline (&pwlayout->wsubline1);
	ClearWSubline (&pwlayout->wsubline2);
}

#define FWLayoutValid(pwlayout) ((pwlayout)->wsubline1.plssubl != NULL)
#define InvalidateWLayout(pwlayout) (pwlayout)->wsubline1.plssubl = NULL;

/* REVIEW (antons): Maybe we should have more clean def of "invalid" wlayout? */

/* Note: I do not have ClearDobj () because Warichu Dobj gets cleaned in NewDobj */



/* N E W  W B R K  A R R A Y  C O P Y */
/*----------------------------------------------------------------------------
	%%Function: NewWBrkArrayCopy
	%%Contact: antons

		Copy constructor for WBrkArray. Receives array of break records to 
		store in WBrkArray structure. Important: There is another constructor
		of WBrkArray so any change here may require adjusting of another 
		procedure.		
	
----------------------------------------------------------------------------*/

static LSERR NewWBrkArrayCopy (

		PDOBJ 		pdobj, 				/* (IN):  Warichu Dobj */
		DWORD		nBreakRec,			/* (IN):  Number of break records in array */
		const BREAKREC	
					* rgBreakRec,		/* (IN):  Array of break records */
		PWBRKARRAY  pwbrkarray )		/* (OUT): Initialized (allocated) structure */
{
	PILSOBJ pilsobj = pdobj->pilsobj;

	if (nBreakRec != 0)
		{
		pwbrkarray->rgBreakRec = AllocateMemory (pilsobj, nBreakRec * sizeof(BREAKREC));
		if (pwbrkarray->rgBreakRec == NULL) 
			{
			return lserrOutOfMemory;
			};

		pwbrkarray->nBreakRecMax = nBreakRec;
		pwbrkarray->nBreakRec = nBreakRec;
		/* Copy contents of the input array to the WBrkArray data structure */
		memcpy (pwbrkarray->rgBreakRec, rgBreakRec, nBreakRec * sizeof(BREAKREC));
		}
	else
		{
		/* nBreakRec == 0 */
		pwbrkarray->rgBreakRec = NULL;
		pwbrkarray->nBreakRecMax = 0;
		pwbrkarray->nBreakRec = 0;
		};

	return lserrNone;
}
		

/* N E W  W B R K  A R R A Y */
/*----------------------------------------------------------------------------
	%%Function: NewWBreakArray
	%%Contact: antons

		Constructor for WBrkArray. Allocate number of break records according
		to LsdnGetFormatDepth (...). Important: There is another constructor
		of WBrkArray so any change here may require adjusting of another procedure.
	
----------------------------------------------------------------------------*/

static LSERR NewWBrkArray (

		PDOBJ 		pdobj, 				/* (IN):  Warichu Dobj */
		PWBRKARRAY	pwbrarray )			/* (OUT): Initialized (allocated) structure */
{
	LSERR lserr;
	PILSOBJ pilsobj = pdobj->pilsobj;
	
	DWORD nBreakRecMax;

	lserr = LsdnGetFormatDepth (pilsobj->plsc, & nBreakRecMax);
	if (lserr != lserrNone) 
		{
		pwbrarray->rgBreakRec = NULL;
		return lserr;
		};

	pwbrarray->rgBreakRec = AllocateMemory (pilsobj, nBreakRecMax * sizeof(BREAKREC));

	if (pwbrarray->rgBreakRec == NULL) return lserrOutOfMemory;

	pwbrarray->nBreakRecMax = nBreakRecMax;
	pwbrarray->nBreakRec = 0; /* Initialization - no b.r. */

	return lserrNone;
}
		


/* D E S T R O Y  W B R K  A R R A Y  */
/*----------------------------------------------------------------------------
	%%Function: DestroyWBrkArray
	%%Contact: antons

		Destroy WBRKARRAY structure.
	
----------------------------------------------------------------------------*/

static void DestroyWBrkArray (PDOBJ pdobj, PWBRKARRAY pwbrkarray)
{
	PILSOBJ pilsobj = pdobj->pilsobj;

	if (pwbrkarray->rgBreakRec != NULL)
		{
		FreeMemory (pilsobj, pwbrkarray->rgBreakRec);
		pwbrkarray->rgBreakRec = NULL;
		};
}		
		

/* D E S T R O Y  W L A Y O U T  */
/*----------------------------------------------------------------------------
	%%Function: Destroywlayout
	%%Contact: antons

		Destroy sublines stored in the layout record

----------------------------------------------------------------------------*/

static LSERR DestroyWLayout (PWLAYOUT pwlayout)
{
	LSERR lserr1, lserr2;

	lserr1 = WaDestroySubline (pwlayout->wsubline1.plssubl);
	lserr2 = WaDestroySubline (pwlayout->wsubline2.plssubl);

	ClearWLayout (pwlayout);

	if (lserr1 != lserrNone) return lserr1;
	else return lserr2;
}


/* N E W  D O B J */
/*----------------------------------------------------------------------------
	%%Function: NewDobj
	%%Contact: antons

		Allocate new Dobj and initialize it.

----------------------------------------------------------------------------*/

static LSERR NewDobj (

	PILSOBJ		pilsobj,			/* (IN): Ilsobj for object */
	PLSDNODE	plsdnTop,			/* (IN): Parent Dnode */
	LSCP		cpStart,			/* (IN): Cp-start of the Warichu */
	LSCP		cpStartObj,			/* (IN): Cp-start from break record if fResumed */
	BOOL		fResumed,			/* (IN): FormatResume? */
	DWORD		nBreakRec,			/* (IN): fResumed => size of the break records array */
	const BREAKREC 
				* rgBreakRec,		/* (IN): fResumed => array of break records */
	LSTFLOW		lstflowParent,		/* (IN): Lstflow of the parent subline */
	PDOBJ		*ppdobj)			/* (OUT): allocated dobj */
{
	LSERR lserr;
	PDOBJ pdobj = AllocateMemory (pilsobj, sizeof(DOBJ));

	if (pdobj == NULL) 
		{
		*ppdobj = NULL;
		return lserrOutOfMemory;
		};

	#ifdef DEBUG 
	Undefined (pdobj); /* Put some garbage into all dobj bytes */
	#endif 

	pdobj->cpStart = cpStart;
	pdobj->cpStartObj = cpStartObj;

	pdobj->pilsobj = pilsobj;
	pdobj->plsdnTop = plsdnTop;
	pdobj->fResumed = fResumed;

	pdobj->lstflowParent = lstflowParent;

	ClearWLayout (&pdobj->wlayout);

	ClearWLayout (&pdobj->wlayoutBreak [0]); /* prev */
	ClearWLayout (&pdobj->wlayoutBreak [1]); /* next */
	ClearWLayout (&pdobj->wlayoutBreak [2]); /* force */

	ClearWLayout (&pdobj->wlayoutTruncate); /* OPT: Layout after truncation */

	Assert (NBreaksToSave == 3);

	pdobj->wbreaktype [0] = wbreaktypeInvalid; /* prev */
	pdobj->wbreaktype [1] = wbreaktypeInvalid; /* next */
	pdobj->wbreaktype [2] = wbreaktypeInvalid; /* force */

	ClearWBrace (&pdobj->wbraceOpen);
	ClearWBrace (&pdobj->wbraceClose);
	ClearWWhole (&pdobj->wwhole);

	*ppdobj = pdobj;

	if (fResumed)
		{
		/* RESUMED => Allocate array of break records in wwhole & store there rgBreakRec */

		lserr = NewWBrkArrayCopy (pdobj, nBreakRec, rgBreakRec, &pdobj->wbrkarrayAtStart);
		if (lserr != lserrNone) return lserr;
		}
	else
		{
		/* ! RESUMED => Allocate 0 break records */

		lserr = NewWBrkArrayCopy (pdobj, 0, NULL, &pdobj->wbrkarrayAtStart);
		if (lserr != lserrNone) return lserr;

		/*	Note: even if ! Resumed, I will use Resumed formatting just because
			I do not want to see at fResumed each time I format subline */
		};

	return lserrNone;
}


/* D E S T R O Y  D O B J */
/*----------------------------------------------------------------------------
	%%Function: DestroyDobj
	%%Contact: antons

		Release all resources associated with dobj for Warichu.
	
----------------------------------------------------------------------------*/

static LSERR DestroyDobj (PDOBJ pdobj)
{
	LSERR rglserr [8];
	int i;

	rglserr [0] = WaDestroySubline (pdobj->wbraceOpen.plssubl);
	rglserr [1] = WaDestroySubline (pdobj->wbraceClose.plssubl);
	rglserr [2] = DestroyWLayout (&pdobj->wlayout);
	rglserr [3] = DestroyWLayout (&pdobj->wlayoutBreak [0]);
	rglserr [4] = DestroyWLayout (&pdobj->wlayoutBreak [1]);
	rglserr [5] = DestroyWLayout (&pdobj->wlayoutBreak [2]);
	rglserr [6] = WaDestroySubline (pdobj->wwhole.plssubl);
	rglserr [7] = DestroyWLayout (&pdobj->wlayoutTruncate);

	DestroyWBrkArray (pdobj, &pdobj->wbrkarrayAtStart);

	FreeMemory (pdobj->pilsobj, pdobj);

	/* REVIEW (antons): return last error instead of first? */
	for (i = 0; i < 8; i++)
		{
		if (rglserr [i] != lserrNone) return rglserr [i];
		};

	return lserrNone;
}


/* F O R M A T  B R A C E  O F  W A R I C H U */
/*----------------------------------------------------------------------------
	%%Function: FormatBraceOfWarichu
	%%Contact: antons

		Create a line for beginning or ending bracket for Warichu.

----------------------------------------------------------------------------*/

typedef enum wbracekind {wbracekindOpen, wbracekindClose} WBRACEKIND;

static LSERR FormatBraceOfWarichu (

	PDOBJ		pdobj,				/* (IN): Warichu Dobj */
	LSCP		cpFirst,			/* (IN): Cp to start formatting */
	WBRACEKIND	wbracekind,			/* (IN): Open or Close */

	WBRACE		*wbrace)			/* (OUT): Brace data structure */

{
	LSERR	lserr;
	LSCP	cpLimSubline;
	FMTRES	fmtres;

	LSESC	* plsEscape; 

	Assert (wbracekind == wbracekindOpen || wbracekind == wbracekindClose);

	plsEscape = ( wbracekind == wbracekindOpen ? &pdobj->pilsobj->lsescBraceOpen
											   : &pdobj->pilsobj->lsescBraceClose );

	lserr = FormatLine( pdobj->pilsobj->plsc, 
						cpFirst, 
						LONG_MAX, 
						pdobj->lstflowParent, 
						& wbrace->plssubl, 
						1, 
						plsEscape,
						& wbrace->objdim, 
						& cpLimSubline, 
						NULL, 
						NULL, 
						& fmtres );

	if (lserr != lserrNone) return lserr;

	Assert (fmtres == fmtrCompletedRun); /* Hit esc character */

	wbrace->cpFirst = cpFirst;
	wbrace->cpLim = cpLimSubline;
	wbrace->cpLimAfterEsc = cpLimSubline + 1; /* Skip 1 esc character */

	return lserrNone;
}


/* F O R M A T  W W H O L E  S U B L I N E */
/*----------------------------------------------------------------------------
	%%Function: FormatWWholeSubline
	%%Contact: antons

		Formats the whole subline of Warichu (field "wwhole" in DOBJ).		

----------------------------------------------------------------------------*/
static LSERR FormatWWholeSubline (
								 
		PDOBJ			pdobj,		 	/* (IN):  Warichu Dobj */
		LSCP			cpFirst,	 	/* (IN):  Where to start formatting */
		long			urColumnMax, 	/* (IN):  RM to limit formatting */
		PWBRKARRAY		pwbrkarrayAtStart,
										/* (IN):  array of break records at wwhole start */
		PWWHOLE			pwwhole )	 	/* (OUT): Strucure with the whole subline */
{
	LSERR	lserr;
	LSCP	cpLimSubline;
	FMTRES	fmtres;

	ClearWWhole (pwwhole); /* For the case of error */

	Assert (pdobj->fResumed || (pdobj->wbrkarrayAtStart.nBreakRec == 0));

	lserr = FormatResumedLine ( 

						 pdobj->pilsobj->plsc, 
						 cpFirst, 
						 urColumnMax, 
						 pdobj->lstflowParent, 
						 & pwwhole->plssubl,
						 1, 
						 & pdobj->pilsobj->lsescText, 
						 & pwwhole->objdim,
						 & cpLimSubline,
						 NULL,
						 NULL,
						 & fmtres,
						 pwbrkarrayAtStart->rgBreakRec,
						 pwbrkarrayAtStart->nBreakRec );

	if (lserr != lserrNone) return lserr;

	Assert (pwwhole->plssubl != NULL);

	pwwhole->cpFirst = cpFirst;
	pwwhole->cpLim = cpLimSubline;

	pwwhole->urColumnMax = urColumnMax;

	Assert (fmtres == fmtrCompletedRun || fmtres == fmtrExceededMargin);

	if (fmtres == fmtrCompletedRun)
		{
		/* Formatting stopped at ESC character */

		pwwhole->fFinished = TRUE;
		pwwhole->cpLimAfterEsc = cpLimSubline + 1;

		Undefined (&pwwhole->cpTruncate);
		}
	else
		{
		/* Formatting stopped because of Exceeding RM */

		pwwhole->fFinished = FALSE;

		lserr = LsTruncateSubline (pwwhole->plssubl, urColumnMax, & pwwhole->cpTruncate);

		if (lserr != lserrNone)
			{
			WaDestroySubline (pwwhole->plssubl); /* Do not need to check error code */
			pwwhole->plssubl = NULL;
			return lserr;
			};

		Undefined (&pwwhole->cpLimAfterEsc);
		};

	pwwhole->fJisRangeKnown = FALSE;

	return lserrNone;
}


/* F O R M A T  W S U B L I N E  U N T I L  C P  B R E A K */
/*----------------------------------------------------------------------------
	%%Function: FormatWSublineUntilCpBreak
	%%Contact: antons

		Format subline until known break opportunity.

----------------------------------------------------------------------------*/
static LSERR FormatWSublineUntilCpBreak (

		PDOBJ		pdobj,				/* (IN): Warichu Dobj */
		LSCP		cpFirst,			/* (IN): Cp to start formatting */
		PWBRKARRAY  pwbrkArray,			/* (IN): Break records at start */
		LSCP		cpBreak,			/* (IN): Cp-break to find */
		long		urFormatEstimate,	/* (IN): Estimated RM for formatting */
		long		urTruncateEstimate,	/* (IN): Estimated RM for truncation */
		BOOL		* pfSuccessful,		/* (OUT): Did we find it? */
		WSUBLINE	* pwsubl,			/* (OUT): Warichu subline if found */
		OBJDIM		* pobjdimBreak,		/* (OUT): Dimensions of the break */
		BRKKIND		* pbrkkind )		/* (OUT): Kind of break to set in the subline */
{
	LSERR lserr;
	LSCP cpLimSubline;
	OBJDIM objdimSubline;
	OBJDIM objdimBreak;
	PLSSUBL plssubl;
	FMTRES fmtres;
	BOOL fContinue;
	LSCP cpTruncate;

	long urFormatCurrent;

	Assert (urFormatEstimate >= urTruncateEstimate);

	pwsubl->plssubl = NULL; /* in case of error */

	/* Loop initialization */

	urFormatCurrent = urFormatEstimate;
	fContinue = TRUE;

	/* Loop until we have fetched enough */

	/* REVIEW (antons): do-while instead of regular while to avoid
						VC++ 6.0 warning message */

	do /* while (fContinue) at the end */
		{
		lserr = FormatResumedLine ( pdobj->pilsobj->plsc,
									cpFirst,
									urFormatCurrent,
									pdobj->lstflowParent,
									& plssubl,
									1,
									& pdobj->pilsobj->lsescText,
									& objdimSubline,
									& cpLimSubline,
									NULL, 
									NULL,
									& fmtres,
									pwbrkArray->rgBreakRec,
									pwbrkArray->nBreakRec );

		if (lserr != lserrNone) return lserr;

		Assert (fmtres == fmtrCompletedRun || fmtres == fmtrExceededMargin);

		/*	REVIEW (antons): here I wrote "<=" because currently in our
			definition, break "after" subline is not a break opportunity.
			This place need to verifyed more carefully */

		if (cpLimSubline <= cpBreak)
			{
			/* Did not fetch enough CPs, try again with bigger RM */

			Assert (fmtres == fmtrExceededMargin);

			lserr = LsDestroySubline (plssubl);

			if (lserr != lserrNone) return lserr;

			/* REVIEW (antons): Is coefficient 1.5 OK? */

			/* REVIEW (antons): The following Assert is against infinite loop */
			Assert (urFormatCurrent < ADDLongSafe (urFormatCurrent, urFormatCurrent / 2));

			urFormatCurrent = ADDLongSafe (urFormatCurrent, urFormatCurrent / 2);
			}
		else
			{
			fContinue = FALSE;
			};

		} while (fContinue);

	Assert (cpBreak < cpLimSubline); 

	lserr = LsTruncateSubline (plssubl, urTruncateEstimate, & cpTruncate);

	if (lserr != lserrNone)
		{
		WaDestroySubline (plssubl); return lserr;
		};

	/* Going prev and next break to find required break point */

	if (cpTruncate < cpBreak)
		{
		/* Go forward with Next Break */

		LSCP cpLastBreak = cpTruncate;
		BOOL fBreakSuccessful = TRUE;

		do /* while (cpLastBreak < cpBreak && fBreakSuccessful) */
			{
			lserr = WaFindNextBreakSubline ( plssubl, cpLastBreak,
											LONG_MAX,
											& fBreakSuccessful,
											& cpLastBreak,
											& objdimBreak );

			if (lserr != lserrNone)
				{
				WaDestroySubline (plssubl); return lserr;
				};

			} while (cpLastBreak < cpBreak && fBreakSuccessful);

		if (! fBreakSuccessful || cpLastBreak > cpBreak)
			{
			lserr = LsDestroySubline (plssubl);

			if (lserr != lserrNone) return lserr;

			*pfSuccessful = FALSE;
			}
		else 
			{
			Assert (cpLastBreak == cpBreak && fBreakSuccessful);

			pwsubl->plssubl = plssubl;
			pwsubl->cpFirst = cpFirst;
			pwsubl->cpLim = cpBreak;
			pwsubl->objdim = objdimSubline;

			*pobjdimBreak = objdimBreak;
			*pfSuccessful = TRUE;

			*pbrkkind = brkkindNext;
			};

		} 

	else /* cpTruncate >= cpBreak */
		{

		/* Go backward with Prev Break */

		LSCP cpLastBreak = cpTruncate + 1;
		BOOL fBreakSuccessful = TRUE;

		do /* while (cpBreak < cpLastBreak && fBreakSuccessful) at the end */
			{
			lserr = WaFindPrevBreakSubline ( plssubl, cpLastBreak - 1,
											LONG_MAX,
											& fBreakSuccessful,
											& cpLastBreak,
											& objdimBreak );

			if (lserr != lserrNone)
				{
				WaDestroySubline (plssubl); return lserr;
				};

			} while (cpBreak < cpLastBreak && fBreakSuccessful);
			
		if (! fBreakSuccessful || cpBreak > cpLastBreak)
			{
			lserr = LsDestroySubline (plssubl);

			if (lserr != lserrNone) return lserr;

			*pfSuccessful = FALSE;
			}
		else 
			{
			Assert (cpLastBreak == cpBreak && fBreakSuccessful);

			pwsubl->plssubl = plssubl;
			pwsubl->cpFirst = cpFirst;
			pwsubl->cpLim = cpBreak;
			pwsubl->objdim = objdimSubline;

			*pobjdimBreak = objdimBreak;
			*pbrkkind = brkkindPrev;

			*pfSuccessful = TRUE;

			};

		}; /* End If (cpTruncate < cpBreak) Then ... Else ... */

	return lserrNone;

} /* FormatWSublineUntilCpBreak */



/* F O R M A T  W S U B L I N E  U N T I L  R M  */
/*----------------------------------------------------------------------------
	%%Function: FormatWSublineUntilRM
	%%Contact: antons

		Format until given right margin - wrapper to FormatLine ()

----------------------------------------------------------------------------*/
static LSERR FormatWSublineUntilRM (
								 
			PDOBJ		pdobj,			 /* (IN): Warichu Dobj */
			LSCP		cpFirst,		 /* (IN): Where to start formatting */
			long		urColumnMax,	 /* (IN): Right margin to format to */
			PWBRKARRAY	pwbrkarray,		 /* (IN): Array of break rec at subline start */
			BOOL		* fFinished,	 /* (OUT): Subline finished at Escape? */
			WSUBLINE	* pwsubl )		 /* (OUT): Formatted WSubline */
{
	LSERR lserr;
	FMTRES fmtr;

	lserr = FormatResumedLine ( pdobj->pilsobj->plsc, 
								cpFirst,
						 		urColumnMax, 
						 		pdobj->lstflowParent, 
						 		& pwsubl->plssubl,	/* out */
						 		1,
						 		& pdobj->pilsobj->lsescText, 
						 		& pwsubl->objdim, 	/* out */
						 		& pwsubl->cpLim,	/* out */
						 		NULL,
						 		NULL,
						 		& fmtr,
						 		pwbrkarray->rgBreakRec,
						 		pwbrkarray->nBreakRec );
	if (lserr != lserrNone) return lserr;

	*fFinished = (fmtr == fmtrCompletedRun);	/* out */
	pwsubl->cpFirst = cpFirst; 					/* out */
 	
	Assert (fmtr == fmtrCompletedRun || fmtr == fmtrExceededMargin);
	return lserrNone;
}
	

/* F O R M A T  W S U B L I N E  U N T I L  E S C A P E */
/*----------------------------------------------------------------------------
	%%Function: FormatWSublineUntilEscape
	%%Contact: antons

		Format subline until escape character - wrapper to FormatLine ()

----------------------------------------------------------------------------*/
static LSERR FormatWSublineUntilEscape (
								 
			PDOBJ		pdobj,			 /* (IN): Warichu Dobj */
			LSCP		cpFirst,		 /* (IN): Where to start formatting */
			PWBRKARRAY	pwbrkarray,		 /* (IN): Array of break rec at subline start */
			WSUBLINE	* pwsubl,		 /* (OUT): Formatted WSubline */
			long		* cpLimAfterEsc) /* (OUT): CpLim after Esc characters */
{
	FMTRES fmtres;
	LSERR lserr = FormatResumedLine ( pdobj->pilsobj->plsc, 
									  cpFirst,
						 			  LONG_MAX, /* urColumnMax */
							 		  pdobj->lstflowParent, 
						 		      & pwsubl->plssubl,	/* out */
						 			  1,
						 			  & pdobj->pilsobj->lsescText, 
						 		      & pwsubl->objdim,		/* out */
						 			  & pwsubl->cpLim,		/* out */
						 			  NULL,
						 			  NULL,
						 		      & fmtres,
						 			  pwbrkarray->rgBreakRec,
						 			  pwbrkarray->nBreakRec );
	if (lserr != lserrNone) return lserr;

	* cpLimAfterEsc = pwsubl->cpLim + 1;	/* out */
	pwsubl->cpFirst = cpFirst;				/* out */

	Assert (fmtres == fmtrCompletedRun);
	return lserrNone;
}


/* C H O O S E  N E A R E S T  B R E A K */
/*----------------------------------------------------------------------------
	%%Function: ChooseNearestBreak
	%%Contact: antons

		Choose nearest between prev and next breaks from the given 
		truncation Ur. If prev and next are on the same distance =>
		we choose next. 

----------------------------------------------------------------------------*/

static LSERR ChooseNearestBreak (

		PLSSUBL		plssubl,		/* (IN): Subline to find break */
		long		urTruncate2,	/* (IN): Truncation point multiplied by 2
									/*       (we *2 to avoid rounding erros) */
		LSCP		cpLookBefore,	/* (IN): Result must be before this cp */
		BOOL		*pfSuccessful,	/* (OUT): Did we find any break ? */
		LSCP		*pcpBreak,		/* (OUT): Cp of break */
		OBJDIM		*pobjdimBreak,	/* (OUT): Dimensions of the broken subline */
		BRKKIND		*pbrkkind)		/* (OUT): Break to set in the subline */
{
	LSERR lserr;
	LSCP cpTruncate;

	OBJDIM objdimNext, objdimPrev;
	LSCP cpBreakNext, cpBreakPrev;
	BOOL fSuccessfulNext, fSuccessfulPrev;

	lserr = LsTruncateSubline (plssubl, urTruncate2 / 2, & cpTruncate);

	if (lserr != lserrNone) return lserr;

	lserr = WaFindNextBreakSubline ( plssubl, cpTruncate, LONG_MAX,
									& fSuccessfulNext, & cpBreakNext,
									& objdimNext );
	if (lserr != lserrNone) return lserr;

	lserr = WaFindPrevBreakSubline ( plssubl, cpTruncate, LONG_MAX,
									& fSuccessfulPrev, & cpBreakPrev,
									& objdimPrev );
	if (lserr != lserrNone) return lserr;

	fSuccessfulNext = fSuccessfulNext && cpBreakNext <= cpLookBefore;
	fSuccessfulPrev = fSuccessfulPrev && cpBreakPrev <= cpLookBefore;
	
	if (fSuccessfulNext && 
		(!fSuccessfulPrev || abs (objdimNext.dur * 2 - urTruncate2) <= 
							 abs (objdimPrev.dur * 2 - urTruncate2) ) )
		{
		/* CHOOSING NEXT */

		* pfSuccessful = TRUE;

		* pcpBreak = cpBreakNext;
		* pobjdimBreak = objdimNext;	
		* pbrkkind = brkkindNext;
		}
	else if (fSuccessfulPrev)
		{
		/* CHOOSING PREV */

		* pfSuccessful = TRUE;

		* pcpBreak = cpBreakPrev;
		* pobjdimBreak = objdimPrev;
		* pbrkkind = brkkindPrev;
		}
	else
		{	
		/* Did not find any ;-( */

		* pfSuccessful = FALSE;
		};

	return lserrNone;

} /* ChooseNearestBreak */


/* G E T  D U R  B R A C E S */
/*----------------------------------------------------------------------------
	%%Function: GetDurBraces
	%%Contact: antons

	
----------------------------------------------------------------------------*/

#define FOpenBraceInWLayout(pdobj,pwlayout) (! (pdobj)->fResumed)

#define FCloseBraceInWLayout(pdobj,pwlayout) (! (pwlayout)->fBroken)

static void GetDurBraces (

			PDOBJ	pdobj,			/* (IN):  Warichu DOBJ */
			BOOL	fBroken,		/* (IN):  Is it broken? */
			BOOL	*pfOpenPresent,	/* (OUT): Open brace present */
		    long	*pdurOpen,		/* (OUT): dur of the open brace, 0 if no brace */
			BOOL	*pfClosePresent,/* (OUT): Close brace present */
			long	*pdurClose)		/* (OUT): dur of the close brace 0 if no brace */
{
	if (! pdobj->fResumed)
		{
		Assert (pdobj->wbraceOpen.plssubl != NULL);

		* pdurOpen = pdobj->wbraceOpen.objdim.dur;
		* pfOpenPresent = TRUE;
		}
	else
		{
		* pdurOpen = 0;
		* pfOpenPresent = FALSE;
		};

	if (! fBroken)
		{
		Assert (pdobj->wbraceClose.plssubl != NULL);

		* pdurClose = pdobj->wbraceClose.objdim.dur;
		* pfClosePresent = TRUE;
		}
	else
		{
		* pdurClose = 0;
		* pfClosePresent = FALSE;
		};

} /* CalcDurBraces */


/* F I N I S H  O B J D I M  W L A Y O U T */
/*----------------------------------------------------------------------------
	%%Function: FinishObjDimWLayout
	%%Contact: antons

		Complete calculations of the Warichu layout. This procedure
		fills WLAYOUT.wdim data structure. The calculations are based on
		the dimensions of Warichu sublines stored in WLAYOUT and the result
		of GetWarichuInfo callback.

----------------------------------------------------------------------------*/
static LSERR FinishObjDimWLayout (

			 PDOBJ		pdobj,		/* (IN): Warichu DOBJ */
			 WLAYOUT	* pwlayout)	/* (IN): Break record (layout) of the Warichu */
{
	LSERR	lserr;
	OBJDIM	objdimAll;
	long	dvpDescentReserved;
	long	durOpen, durClose;
	BOOL	fOpenBrace, fCloseBrace;

	PILSOBJ pilsobj = pdobj->pilsobj;

	Assert (pwlayout->wsubline1.plssubl != NULL);

	lserr = pilsobj->warichucbk.pfnGetWarichuInfo ( pilsobj->pols,
													pdobj->cpStartObj, 
													pdobj->lstflowParent,
													& pwlayout->wsubline1.objdim, 
													& pwlayout->wsubline2.objdim, 
													& objdimAll.heightsRef, 
													& objdimAll.heightsPres,
													& dvpDescentReserved );
	if (lserr != lserrNone) return lserr;

	GetDurBraces (pdobj, pwlayout->fBroken, 
				  &fOpenBrace, &durOpen, &fCloseBrace, &durClose);

	objdimAll.dur = durOpen + durClose +
					max (pwlayout->wsubline1.objdim.dur, pwlayout->wsubline2.objdim.dur);

	pwlayout->wdim.objdimAll = objdimAll;
	pwlayout->wdim.dvpDescentReserved = dvpDescentReserved;

	return lserrNone;
}
 	

/* F I N I S H  W L A Y O U T  S I N G L E  L I N E  */
/*----------------------------------------------------------------------------
	%%Function: FinishWLayoutSingleLine
	%%Contact: antons

		Finishes layout of warichu as it were only one line (of course, not broken)

----------------------------------------------------------------------------*/
static LSERR FinishWLayoutSingleLine (PDOBJ pdobj, PWLAYOUT pwlayout)
{
	pwlayout->fBroken = FALSE;
	pwlayout->wsubline2.plssubl = NULL; 

	/* REVIEW (antons): Does anybody use cpFirst & cpLim I set here? */
	pwlayout->wsubline2.cpFirst = pwlayout->wsubline1.cpLim;
	pwlayout->wsubline2.cpLim = pwlayout->wsubline1.cpLim;

	ZeroObjDim (& pwlayout->wsubline2.objdim);
	return FinishObjDimWLayout (pdobj, pwlayout);
}


/* P R O C E S S M O D W I D T H */
/*----------------------------------------------------------------------------
	%%Function: ProcessModWidth
	%%Contact: antons

		Ask client how much widths should be modified for lead or end
		bracket for the Warichu. Then modify the Warichu to reflect the
		change in size.
	
----------------------------------------------------------------------------*/
static LSERR ProcessModWidth (

		PDOBJ pdobj,				/* (IN): dobj */
		enum warichucharloc wloc,	/* (IN): location of mod width request */
		PLSRUN plsrun,				/* (IN): plsrun of the object */
		PLSRUN plsrunText,			/* (IN): plsrun of the preceding char */
		WCHAR wchar,				/* (IN): preceding character */
		MWCLS mwcls,				/* (IN): ModWidth class of preceding character */
		long *pdurChange)			/* (OUT): amount by which width of the preceding char is to be changed */
{
	PILSOBJ pilsobj = pdobj->pilsobj;
	LSERR lserr;
	long durWChange;

	lserr = pilsobj->warichucbk.pfnFetchWarichuWidthAdjust(pilsobj->pols,
		pdobj->cpStartObj, wloc, plsrunText, wchar, mwcls, plsrun, pdurChange,
			&durWChange);

	AssertSz(durWChange >= 0, 
		"ProcessModWidth - invalid return from FetchWidthAdjust");

	if (durWChange < 0)
		{
		durWChange = 0;
		}

	*pdurChange += durWChange;

	return lserr;
}


/* S U B M I T  W L A Y O U T  S U B L I N E S */
/*----------------------------------------------------------------------------
	%%Function: SubmitWLayoutSublines
	%%Contact: antons

		Submit sublines from the given layout for justification. We call
		it after formatting and during SetBreak.

----------------------------------------------------------------------------*/
static LSERR SubmitWLayoutSublines (PDOBJ pdobj, PWLAYOUT pwlayout)
{
	PLSSUBL rgsublSubmit [3];	/* Array of psublines to submit */
	DWORD	nSubmit;			/* Number of sublines to submit */
	LSERR	lserr;

	BOOL fOpenBrace, fCloseBrace;
	long durOpen, durClose;

	GetDurBraces (pdobj, pwlayout->fBroken, &fOpenBrace, &durOpen, &fCloseBrace, &durClose);

	nSubmit = 0;

	/* Submit open brace */

	if (fOpenBrace)
		{
		BOOL fSublineEmpty;		

		lserr = LssbFIsSublineEmpty (pdobj->wbraceOpen.plssubl, &fSublineEmpty);
		if (lserr != lserrNone) return lserr;
		
		if (! fSublineEmpty) /* Can not submit empty subline */
			{
			rgsublSubmit [nSubmit++] = pdobj->wbraceOpen.plssubl;
			}
		};

	/* Submit longest subline */

	/* REVIEW (antons): If first is empty & second is not empty but ZW,
						I do not submit neither */
	/* REVIEW (antons): Can it ever happen what I wrote before? */
 
	if (pwlayout->wsubline1.objdim.dur >= pwlayout->wsubline2.objdim.dur)
		{
		BOOL fSublineEmpty;		
		
		lserr = LssbFIsSublineEmpty (pwlayout->wsubline1.plssubl, &fSublineEmpty);
		if (lserr != lserrNone) return lserr;

		if (! fSublineEmpty) /* Can not submit empty subline */
			{
			rgsublSubmit [nSubmit++] = pwlayout->wsubline1.plssubl;
			};
		}
	else
		{
		BOOL fSublineEmpty;
		Assert (pwlayout->wsubline2.plssubl != NULL);
		
		lserr = LssbFIsSublineEmpty (pwlayout->wsubline2.plssubl, &fSublineEmpty);
		if (lserr != lserrNone) return lserr;

		if (! fSublineEmpty) /* Can not submit empty subline */
			{
			rgsublSubmit [nSubmit++] = pwlayout->wsubline2.plssubl;
			}
		};

	/* Submit closing brace */
 
	if (fCloseBrace)
		{
		BOOL fSublineEmpty;		

		lserr = LssbFIsSublineEmpty (pdobj->wbraceClose.plssubl, &fSublineEmpty);
		if (lserr != lserrNone) return lserr;
		
		if (! fSublineEmpty) /* Can not submit empty subline */
			{
			rgsublSubmit [nSubmit++] = pdobj->wbraceClose.plssubl;
			}
		};

	/* REVIEW (antons): This deletes previously submitted subline. Question: 
						should we better have additional procedure to "clear" submition?
	*/

	lserr = LsdnSubmitSublines ( pdobj->pilsobj->plsc, 
								 pdobj->plsdnTop, 
								 nSubmit, rgsublSubmit,
								 TRUE,					/* Justification */
								 FALSE,					/* Compression */
								 FALSE,					/* Display */
								 FALSE,					/* Decimal tab */
								 FALSE );				/* Trailing spaces */
	return lserr;
}


/* W A R I C H U C R E A T E I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: WarichuCreateILSObj
	%%Contact: ricksa

		Create main object for Warichu handlers.
	
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuCreateILSObj (

			POLS		pols,			/* (IN): client application context */
			PLSC		pclsc,			/* (IN): LS context */
			PCLSCBK		pclscbk,		/* (IN): callbacks to client application */
			DWORD		idobj,			/* (IN): id of the object */
			PILSOBJ		* ppilsobj )	/* (OUT): object ilsobj */
{
    PILSOBJ pilsobj;
	LSERR lserr;
	WARICHUINIT warichuinit;

	warichuinit.dwVersion = WARICHU_VERSION;

	/* Get initialization data */
	lserr = pclscbk->pfnGetObjectHandlerInfo(pols, idobj, &warichuinit);

	if (lserr != lserrNone)
		{
		return lserr;
		}

	/* Build ILS object */
    pilsobj = pclscbk->pfnNewPtr(pols, sizeof(*pilsobj));

	if (NULL == pilsobj) return lserrOutOfMemory;

	ZeroMemory(pilsobj, sizeof(*pilsobj));
    pilsobj->pols = pols;
	pilsobj->idobj = idobj;
    pilsobj->lscbk = *pclscbk;
	pilsobj->plsc = pclsc;
	pilsobj->lsescBraceOpen.wchFirst = warichuinit.wchEndFirstBracket;
	pilsobj->lsescBraceOpen.wchLast = warichuinit.wchEndFirstBracket;
	pilsobj->lsescText.wchFirst = warichuinit.wchEndText;
	pilsobj->lsescText.wchLast = warichuinit.wchEndText;
	pilsobj->lsescBraceClose.wchFirst = warichuinit.wchEndWarichu;
	pilsobj->lsescBraceClose.wchLast = warichuinit.wchEndWarichu;
	pilsobj->warichucbk = warichuinit.warichcbk;
	pilsobj->fContiguousFetch = warichuinit.fContiguousFetch;

	*ppilsobj = pilsobj;
	return lserrNone;
}


/* W A R I C H U D E S T R O Y I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: WarichuDestroyILSObj
	%%Contact: antons

		Free all resources connected with Warichu main object.
	
----------------------------------------------------------------------------*/

LSERR WINAPI WarichuDestroyILSObj(PILSOBJ pilsobj)
{
	FreeMemory (pilsobj, pilsobj);
	return lserrNone;
}


/* W A R I C H U S E T D O C */
/*----------------------------------------------------------------------------
	%%Function: WarichuSetDoc
	%%Contact: antons

		Save the device resolution for later scaling.
	
----------------------------------------------------------------------------*/

LSERR WINAPI WarichuSetDoc(
	PILSOBJ pilsobj,			/* (IN): object ilsobj */
	PCLSDOCINF pclsdocinf)		/* (IN): initialization data of the document level */
{
	pilsobj->lsdevres = pclsdocinf->lsdevres;
	return lserrNone;
}

/* W A R I C H U  C R E A T E  L N  O B J */
/*----------------------------------------------------------------------------
	%%Function: WarichuCreateLNObj
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI WarichuCreateLNObj (PCILSOBJ pcilsobj,	PLNOBJ *pplnobj)
{
	*pplnobj = (PLNOBJ) pcilsobj;

	return lserrNone;
}

/* W A R I C H U  D E S T R O Y  L N  O B J */
/*----------------------------------------------------------------------------
	%%Function: WarichuDestroyLNObj
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI WarichuDestroyLNObj (PLNOBJ plnobj)				
{
	Unreferenced(plnobj);

	return lserrNone;
}


/* G E T  C P  L I M  O F  W L A Y O U T  */
/*----------------------------------------------------------------------------
	%%Function: GetCpLimOfWLayout
	%%Contact: antons

		Return cp-lim for the given Warichu layout.
	
----------------------------------------------------------------------------*/

static LSCP GetCpLimOfWLayout (PDOBJ pdobj, WLAYOUT *pwlayout)
{
	Unreferenced (pdobj);

	Assert (FWLayoutValid (pwlayout));

	if (pwlayout->fBroken)
		{
		Assert (pwlayout->wsubline2.plssubl != NULL);
		return pwlayout->wsubline2.cpLim;
		}
	else
		{
		Assert (pdobj->wbraceClose.plssubl != NULL);
		return pdobj->wbraceClose.cpLimAfterEsc;
		};
}


/* R E F O R M A T  C L O S I N G  B R A C E  F O R  W O R D 9
/*----------------------------------------------------------------------------
	%%Function: ReformatClosingBraceForWord9
	%%Contact: antons

		REVIEW (antons):

		THIS IS HACK WHICH WAS REQUESTED BY WORD 9, BECAUSE THEY
		DID NOT WANT TO FIX THEIR BUG IN CODE WHICH INSERTS BRACES 
		ON-THE-FLY. IT MUST BE REMOVED AS SOON AS POSSIBLE, BECAUSE
		IT MAY SLOWS DOWN WARICHU FORMATTING SIGNIFICANTLY.

----------------------------------------------------------------------------*/

#define min(a,b) ((a)<(b) ? (a) : (b))

LSERR ReformatClosingBraceForWord9 (PDOBJ pdobj)
{
	DWORD cwchRun;
	WCHAR * lpwchRun;
	BOOL fHidden;
	LSCHP lschp;
	PLSRUN plsrun;

	LSCP cpFetch;
	LSCP cpLimFetch;

	LSERR lserr;

	if (pdobj->pilsobj->fContiguousFetch)
		{
		if (! FWLayoutValid (&pdobj->wlayout)) return lserrNone;

		cpFetch = pdobj->wwhole.cpFirst;
		cpLimFetch = min (pdobj->wwhole.cpLim, GetCpLimOfWLayout (pdobj, &pdobj->wlayout));

		while (cpFetch < cpLimFetch)
			{
			lserr = pdobj->pilsobj->lscbk.pfnFetchRun ( pdobj->pilsobj->pols, 
									  cpFetch, & lpwchRun,  & cwchRun,
									  & fHidden, & lschp, & plsrun );
			if (lserr != lserrNone) return lserr;

			lserr = pdobj->pilsobj->lscbk.pfnReleaseRun (pdobj->pilsobj->pols, plsrun);
			if (lserr != lserrNone) return lserr;

			Assert (cwchRun > 0);
			if (cwchRun == 0) return lserrInvalidDcpFetched;
			
			cpFetch = cpFetch + cwchRun;
			};

		cpFetch = cpLimFetch;
		cpLimFetch = GetCpLimOfWLayout (pdobj, &pdobj->wlayout);

		while (cpFetch < cpLimFetch)
			{
			lserr = pdobj->pilsobj->lscbk.pfnFetchRun ( pdobj->pilsobj->pols, 
									  cpFetch, & lpwchRun,  & cwchRun,
									  & fHidden, & lschp, & plsrun );
			if (lserr != lserrNone) return lserr;

			lserr = pdobj->pilsobj->lscbk.pfnReleaseRun (pdobj->pilsobj->pols, plsrun);
			if (lserr != lserrNone) return lserr;

			Assert (cwchRun > 0);
			if (cwchRun == 0) return lserrInvalidDcpFetched;
			
			cpFetch = cpFetch + cwchRun;
			};
		
		};

	return lserrNone;
}

/* F I N D  W L A Y O U T  O F  U N B R O K E N  W A R I C H U  */
/*----------------------------------------------------------------------------
	%%Function: FindWLayoutOfUnbrokenWarichu
	%%Contact: antons

		Find layout of the Warichu which is not broken. This procedure
		returns structure WLAYOUT.
	
----------------------------------------------------------------------------*/

static LSERR FindWLayoutOfUnbrokenWarichu (PDOBJ pdobj, WLAYOUT *pwlayout)
{
	LSERR	lserr;
	BOOL	fSuccessful;
	LSCP	cpBreakFirstLine;
	OBJDIM	objdimUnused;
	OBJDIM	objdimFirstLine;
	BRKKIND brkkindUnused;
	LSCP	cpLimUnused;
	
	Assert (pdobj->wwhole.plssubl != NULL);

	/* This should not be called when wwhole was not finished */
	Assert (pdobj->wwhole.fFinished);

	ClearWLayout (pwlayout); /* For the case of error */

	if (pdobj->wwhole.objdim.dur == 0) 
		{
		/* Either empty or zero-width subline */
		/* The only thing we can do is to create single-line Warichu */

		LSCP cpLimAfterEscUnused;
		lserr = FormatWSublineUntilEscape ( pdobj, pdobj->wwhole.cpFirst, 
											& pdobj->wbrkarrayAtStart,
											& pwlayout->wsubline1, 
											& cpLimAfterEscUnused );
		if (lserr != lserrNone) return lserr;

		Assert (pwlayout->wsubline1.objdim.dur == 0);

		return FinishWLayoutSingleLine (pdobj, pwlayout);
		};

	lserr = ChooseNearestBreak ( pdobj->wwhole.plssubl, 
								 pdobj->wwhole.objdim.dur,
								 CP_MAX,
								 & fSuccessful,
								 & cpBreakFirstLine,
								 & objdimUnused,
								 & brkkindUnused );
	if (lserr != lserrNone) return lserr;

	if (! fSuccessful)
		{
		/* Not a single break in the whole Warichu line */

		LSCP cpLimAfterEscUnused;

		lserr = FormatWSublineUntilEscape ( pdobj, pdobj->wwhole.cpFirst, 
											& pdobj->wbrkarrayAtStart,
											& pwlayout->wsubline1, 
											& cpLimAfterEscUnused );
		if (lserr != lserrNone) return lserr;

		return FinishWLayoutSingleLine (pdobj, pwlayout);
		}
	else
		{
		/* Yes, we have break between lines */

		BOOL fSuccessful;
		BRKKIND brkkind;

		WBRKARRAY wbrkarray;

		lserr = FormatWSublineUntilCpBreak ( pdobj, pdobj->wwhole.cpFirst, 
									 & pdobj->wbrkarrayAtStart,
									 cpBreakFirstLine, 
									 LONG_MAX, pdobj->wwhole.objdim.dur / 2, /* REVIEW THIS ! */
									 & fSuccessful,
									 & pwlayout->wsubline1, & objdimFirstLine, & brkkind );

		if (lserr != lserrNone) return lserr;

		Assert (fSuccessful); /* Something crazy inside Warichu */

		lserr = NewWBrkArray (pdobj, &wbrkarray);

		if (lserr != lserrNone) return lserr;
		
		lserr = SetBreakWSubline (&pwlayout->wsubline1, brkkind, cpBreakFirstLine,
								  &objdimFirstLine, &wbrkarray);

		lserr = FormatWSublineUntilEscape ( pdobj, pwlayout->wsubline1.cpLim,
									   & wbrkarray, & pwlayout->wsubline2, 
								       & cpLimUnused );

		if (lserr != lserrNone) return lserr;

		DestroyWBrkArray (pdobj, &wbrkarray);
		};

	pwlayout->fBroken = FALSE; /* This warichu is not broken ;-) */

	lserr = FinishObjDimWLayout (pdobj, pwlayout);
	return lserr;
}


/* F O R M A T  W A R I C H U  C O R E  */
/*----------------------------------------------------------------------------
	%%Function: FormatWarichuCore
	%%Contact: antons

		Format Warichu Object (called from methods WarichuFmt and WarichuFmtResumt)
		
----------------------------------------------------------------------------*/
static LSERR FormatWarichuCore (

		PLNOBJ 		plnobj,			/* (IN): Warichu LNOBJ */
    	PCFMTIN 	pcfmtin,		/* (IN): Formatting input */
		BOOL		fResumed,		/* (IN): Resumed? */
		DWORD	nBreakRec,			/* (IN): fResumed => size of the break records array */
		const BREAKREC 
					* rgBreakRec,	/* (IN): fResumed => array of break records */
	    FMTRES 		* pfmtres )		/* (OUT): formatting result */
{
	LSERR	lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj; /* They are the same */
	PDOBJ	pdobj;

	long urColumnMax  = pcfmtin->lsfgi.urColumnMax;

	/* REVIEW (antons): Can we optimize for case 0? */
	long durAvailable = max (0, pcfmtin->lsfgi.urColumnMax - pcfmtin->lsfgi.urPen);

	/* :: CREATE DOBJ WITH INITIAL OBJECT DATA */

	if (! fResumed)
		{
		/* Not Resumed */

		lserr = NewDobj ( pilsobj, 
						  pcfmtin->plsdnTop,
						  pcfmtin->lsfgi.cpFirst, 
						  pcfmtin->lsfgi.cpFirst,
						  FALSE,					/* fResumed */
						  0,
						  NULL,
						  pcfmtin->lsfgi.lstflow, 
						  & pdobj );
		}
	else
		{
		/* Resumed */

		Assert (nBreakRec > 0);
		Assert (rgBreakRec [0].idobj == pilsobj->idobj);

		lserr = NewDobj ( pilsobj, 
						  pcfmtin->plsdnTop,
						  pcfmtin->lsfgi.cpFirst, 
						  rgBreakRec [0].cpFirst,
						  TRUE,						/* fResumed */
						  nBreakRec-1,
						  & rgBreakRec [1],
						  pcfmtin->lsfgi.lstflow, 
						  & pdobj );
		};

	if (lserr != lserrNone) return lserr;

	/* :: FORMAT WARICHU OPEN BRACE IF not RESUMED*/

	if (!fResumed)
		{
		lserr = FormatBraceOfWarichu ( pdobj, pdobj->cpStart + 1 /* Skip 1 Esc */,
									   wbracekindOpen, & pdobj->wbraceOpen );
		if (lserr != lserrNone) 
			{ 
			DestroyDobj (pdobj); return lserr; 
			};
		}
	else
		pdobj->wbraceOpen.plssubl = NULL; /* No open brace */

	/* :: FORMAT THE WHOLE WARICHU LINE */

	{
		/* REVIEW (antons): Check with Igor that he is not playing with RM, because
							if he is, the following estimations of durFormatWhole are
							not correct */

		/*	To be able to check JIS rule, warichu needs to format the whole subline
			far ehough to be able to count 4 break opportunities from break-point. 
			We estimate it like

					2 * durAvailable + 2 * urColumnMax
		*/

		/* REVIEW (antons): I want to be sure that final line break does not depend on
							whatever estimations we use here */

		/* REVIEW (antons): Is that correct to return lserrUnsufficientFetch if there is
							no 4 breaks after (JIS rule) when wwhole is not finished? */

		/* REVIEW (antons): Can something like 5 * durAvailable may be better */

		long urFormatWhole = MULLongSafe (ADDLongSafe (durAvailable, urColumnMax), 2);

		LSCP cpStartFormatWhole = (fResumed ? pdobj->cpStart :
											  pdobj->wbraceOpen.cpLimAfterEsc);
		lserr = FormatWWholeSubline ( pdobj, 
									  cpStartFormatWhole,
									  urFormatWhole,
									  & pdobj->wbrkarrayAtStart,
									  & pdobj->wwhole );
		if (lserr != lserrNone) 
			{ 
			DestroyDobj (pdobj); return lserr; 
			};
	};

	/* :: CHECK IF THE WHOLE SUBLINE WAS NOT FINISHED */

	if (! pdobj->wwhole.fFinished)
		{
		/* Not finished => return fmtrExceedMargin */

		Assert (pdobj->wwhole.objdim.dur / 2 > durAvailable);

		InvalidateWLayout (&pdobj->wlayout); /* Invalidate layout */

		/* REVIEW (antons) */
		pdobj->wlayout.wdim.objdimAll = pdobj->wwhole.objdim; 
											  /* Must have correct objdim */

		/* REVIEW (antons): Check - we return dcp of the fetched range */
		/* REVIEW (antons): Check - we return objdim of the whole line */
		lserr = LsdnFinishRegular ( pilsobj->plsc,
									pdobj->wwhole.cpLim - pdobj->cpStart,
									pcfmtin->lsfrun.plsrun, 
									pcfmtin->lsfrun.plschp,
									pdobj,
									& pdobj->wwhole.objdim );

		if (lserr != lserrNone) { DestroyDobj (pdobj); return lserr; };

		* pfmtres = fmtrExceededMargin;
		return lserrNone;
		};

	/* :: FORMAT THE CLOSING BRACE */

	lserr = FormatBraceOfWarichu (pdobj, pdobj->wwhole.cpLimAfterEsc,
								  wbracekindClose, &pdobj->wbraceClose);

	if (lserr != lserrNone) { DestroyDobj (pdobj); return lserr; };

	/* :: FIND LAYOUT OF WARICHU AS IF IT IS NOT BROKEN AND FINISH FORMATTING */

	lserr = FindWLayoutOfUnbrokenWarichu (pdobj, &pdobj->wlayout);
	if (lserr != lserrNone) { DestroyDobj (pdobj); return lserr; };

	/* :: SUBMIT WARICHU SUBLINES */

	/* REVIEW (antons): MOVE SUBMITTION BELOW LSDNFINISHREGULAR WHEN
	   					WE ALIMINATE HACK WITH REFORMATTING ")" FOR SG */

	lserr = SubmitWLayoutSublines (pdobj, &pdobj->wlayout);
	if (lserr != lserrNone) { DestroyDobj (pdobj); return lserr; };

	ReformatClosingBraceForWord9 (pdobj);
	
	lserr = LsdnFinishRegular ( pilsobj->plsc,
								GetCpLimOfWLayout (pdobj, &pdobj->wlayout)-pdobj->cpStart,
								pcfmtin->lsfrun.plsrun, 
								pcfmtin->lsfrun.plschp,
								pdobj,
								& pdobj->wlayout.wdim.objdimAll );

	if (lserr != lserrNone) { DestroyDobj (pdobj); return lserr; };

	/* :: CHECK IF WE CROSSED RIGHT MARGIN AND RETURN */

	if (pdobj->wlayout.wdim.objdimAll.dur > durAvailable) 
		{
		* pfmtres = fmtrExceededMargin;
		}
	else
		{
		* pfmtres = fmtrCompletedRun;
		};

	return lserrNone;

} /* FormatWarichuCore */



/* W A R I C H U   F M T */
/*----------------------------------------------------------------------------
	%%Function: Warichu::Fmt
	%%Contact: antons

		Warichu FMT method entry point
	
----------------------------------------------------------------------------*/

LSERR WINAPI WarichuFmt ( PLNOBJ 	plnobj,			/* (IN): object lnobj */
    					  PCFMTIN 	pcfmtin,		/* (IN): formatting input */
						  FMTRES	* pfmtres )		/* (OUT): formatting result */
{
	return FormatWarichuCore ( plnobj,
							   pcfmtin,
							   FALSE,			/* fResumed  = false */
							   0,
							   NULL,
							   pfmtres );
}


/* W A R I C H U  F M T  R E S U M E */
/*----------------------------------------------------------------------------
	%%Function: Warichu::FmtResume
	%%Contact: anton

		Warichu FMT-RESUME method entry point
  
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuFmtResume ( 
							   
		PLNOBJ			plnobj,				/* (IN): object lnobj */
		const BREAKREC 	* rgBreakRecord,	/* (IN): array of break records */
		DWORD			nBreakRecord,		/* (IN): size of the break records array */
		PCFMTIN			pcfmtin,			/* (IN): formatting input */
		FMTRES			* pfmtres )			/* (OUT): formatting result */
{
	return FormatWarichuCore ( plnobj,
							   pcfmtin,
							   TRUE,			/* fResumed  = true */
							   nBreakRecord,
							   rgBreakRecord,
							   pfmtres );
}


/* W A R I C H U G E T M O D W I D T H P R E C E D I N G C H A R */
/*----------------------------------------------------------------------------
	%%Function: WarichuGetModWidthPrecedingChar
	%%Contact: ricksa

		.
	
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuGetModWidthPrecedingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the preceding char */
	PCHEIGHTS pcheightsRef,		/* (IN): height info about character */
	WCHAR wchar,				/* (IN): preceding character */
	MWCLS mwcls,				/* (IN): ModWidth class of preceding character */
	long *pdurChange)			/* (OUT): amount by which width of the preceding char is to be changed */
{
	Unreferenced(pcheightsRef);

	return ProcessModWidth(pdobj, warichuBegin, plsrun, plsrunText, 
		wchar, mwcls, pdurChange);
}

/* W A R I C H U G E T M O D W I D T H F O L L O W I N G C H A R */
/*----------------------------------------------------------------------------
	%%Function: WarichuGetModWidthFollowingChar
	%%Contact: ricksa

		.
	
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuGetModWidthFollowingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the following char */
	PCHEIGHTS pcheightsRef,		/* (IN): height info about character */
	WCHAR wchar,				/* (IN): following character */
	MWCLS mwcls,				/* (IN): ModWidth class of the following character */
	long *pdurChange)			/* (OUT): amount by which width of the following char is to be changed */
{
	Unreferenced(pcheightsRef);

	return ProcessModWidth(pdobj, warichuEnd, plsrun, plsrunText, 
			wchar, mwcls, pdurChange);
}


/* T R Y  B R E A K  W A R I C H U  A T  C P  */
/*----------------------------------------------------------------------------
	%%Function: TryBreakWarichuAtCp
	%%Contact: antons

		Given break-point in the whole line, find break of Warichu which
		ends at this break-point. For optimization during Truncation I added
		urColumnMax and special result type trybreakkindExceedMargin.

		This is the major breakig procedure which is called from Truncation,
		Prev / Next Breaks and probably Force break.

----------------------------------------------------------------------------*/

typedef enum trybreakwarichu
{
	trybreakwarichuSuccessful,
	trybreakwarichuExceedMargin,
	trybreakwarichuCanNotFinishAtCp

} TRYBREAKWARICHU;


LSERR TryBreakWarichuAtCp (

	PDOBJ			pdobj,				/* (IN): Warichu DOBJ */
	LSCP			cpBreakCandidate,	/* (IN): Candidate cpLim of broken Warichu */
	long			durBreakCandidate,	/* (IN): dur of break-point in the whole line */
	long			urColumnMax,		/* (IN): max width of broken warichu (for OPT only!) */
	TRYBREAKWARICHU	* ptrybreakwarichu,	/* (OUT): Successful | ExceededRM | Bad Candidate */
	PWLAYOUT		pwlayout) 			/* (OUT): Layout of broken Warichu if Successful */
{
	LSERR lserr;
	BOOL fSuccessful;
	LSCP cpBreakFirst;
	BRKKIND brkkindUnused;

	OBJDIM objdimBreakFirst;
	OBJDIM objdimBreakSecond;
	BRKKIND brkkindFirst;
	BRKKIND brkkindSecond;

	WBRKARRAY wbrkarrayAtFirstEnd;	/* WBreakArray at the end of first subline */

	long durOpen, durClose;
	BOOL boolUnused1, boolUnused2;

	pwlayout->wsubline1.plssubl = NULL;
	pwlayout->wsubline2.plssubl = NULL; /* In case of error */

	GetDurBraces (pdobj, TRUE, &boolUnused1, &durOpen, &boolUnused2, &durClose);

	/* REVIEW (antons): Hidden text at "cpBreakCandidate - 1" */

	lserr = ChooseNearestBreak ( pdobj->wwhole.plssubl,
								 durBreakCandidate,
								 cpBreakCandidate - 1,
								 & fSuccessful,
								 & cpBreakFirst,
								 & objdimBreakFirst,
								 & brkkindUnused );
	if (lserr != lserrNone) return lserr;

	Assert (fSuccessful); /* REVIEW (antons): Should not we provide special ret code? */

	/* Optimization check */

	/* REVIEW (antons): I do not like this check, calculation must be done in special function */
	if (durOpen + durClose + objdimBreakFirst.dur > urColumnMax)
		{
		* ptrybreakwarichu = trybreakwarichuExceedMargin;

		lserr = DestroyWLayout (pwlayout);
		return lserrNone;
		};

	/* Format first line */

	lserr = FormatWSublineUntilCpBreak ( pdobj, 
										 pdobj->wwhole.cpFirst,
										 & pdobj->wbrkarrayAtStart,
										 cpBreakFirst,
										 objdimBreakFirst.dur, /* REVIEW (antons): urColumnMax */
										 objdimBreakFirst.dur, /* REVIEW (antons): urTuncate */
										 & fSuccessful,
										 & pwlayout->wsubline1,
										 & objdimBreakFirst,
										 & brkkindFirst );
	if (lserr != lserrNone) return lserr;

	/* REVIEW (antons): Maybe we should leave this assert? */
	/* Assert (fSuccessful); */

	if (!fSuccessful) /* Incorrect object inside Warichu, but we can handle it */
		{
		* ptrybreakwarichu = trybreakwarichuCanNotFinishAtCp;

		lserr = DestroyWLayout (pwlayout);
		return lserr;
		};

	/* Create new WBreakArray */

	lserr = NewWBrkArray (pdobj, & wbrkarrayAtFirstEnd);

	if (lserr != lserrNone) {DestroyWLayout (pwlayout); return lserr;};

	/* Set break at the end of first line and fill WBreakArray */

	lserr = SetBreakWSubline (& pwlayout->wsubline1, brkkindFirst, 
							  cpBreakFirst, & objdimBreakFirst, & wbrkarrayAtFirstEnd);

	if (lserr != lserrNone) 
		{
		DestroyWLayout (pwlayout); 
		DestroyWBrkArray (pdobj, &wbrkarrayAtFirstEnd);
		
		return lserr;
		};


	/* REVIEW (antons): Check the following assumption! */

	Assert (durBreakCandidate >= objdimBreakFirst.dur);

	/* Format second line */

	lserr = FormatWSublineUntilCpBreak ( pdobj, 
								 cpBreakFirst,
								 & wbrkarrayAtFirstEnd,
								 cpBreakCandidate,
								 durBreakCandidate - objdimBreakFirst.dur, /* REVIEW (antons): urColumnMax */
								 durBreakCandidate - objdimBreakFirst.dur, /* REVIEW (antons): urTuncate */
								 & fSuccessful,
								 & pwlayout->wsubline2,
								 & objdimBreakSecond,
								 & brkkindSecond );

	if (lserr != lserrNone) 
		{
		DestroyWLayout ( pwlayout); 
		DestroyWBrkArray (pdobj, &wbrkarrayAtFirstEnd);
		
		return lserr;
		};

	/* We do not need wBreakArrayAtFirstEnd any more, so we release it */

	DestroyWBrkArray (pdobj, & wbrkarrayAtFirstEnd);

	/* If not Successful => result "Can not Finish At Cp" */

	if (!fSuccessful)
		{
		DestroyWLayout (pwlayout);

		* ptrybreakwarichu = trybreakwarichuCanNotFinishAtCp; 
		return lserrNone;
		};

	/*	Here comes a small cheating ;-) 

		We do not want to Set Break at the end of second line, but have to
		store objdim & cpLim as if after SetBreak. Maybe in the future I will
		get rid of this checting (hope it is the only one left in Warichu ;-)
		but today I change cpLim and objdim manually & also store 
		kind of	break to set at second line end (playout->brkkind).

	*/

	pwlayout->wsubline2.cpLim = cpBreakCandidate;
	pwlayout->wsubline2.objdim = objdimBreakSecond;

	pwlayout->brkkind = brkkindSecond;
	pwlayout->fBroken = TRUE;

	lserr = FinishObjDimWLayout (pdobj, pwlayout);
	if (lserr != lserrNone) {DestroyWLayout (pwlayout); return lserr;};
	
	/* Again, check for right Margin */

	if (pwlayout->wdim.objdimAll.dur > urColumnMax)
		{
		* ptrybreakwarichu = trybreakwarichuExceedMargin;

		lserr = DestroyWLayout (pwlayout);
		return lserr;
		}
	else
		{
		* ptrybreakwarichu = trybreakwarichuSuccessful;
		return lserrNone;
		};
}


/* C A L C  J I S  R A N G E */
/*----------------------------------------------------------------------------
	%%Function: CalcJisRange
	%%Contact: antons
	
		Calculate cpJisRangeFisrt and cpJisRangeLim as 4th break opportunities
		from the beginning and from the end of Whole subline. If range is empty,
		* pfJisRangeEmpty = FALSE and cps are undefined.

----------------------------------------------------------------------------*/

static LSERR CalcJisRange (
						   
	PDOBJ	pdobj,
	BOOL	*pfJisRangeEmpty,
	LSCP	*pcpJisRangeFirst,
	LSCP	*pcpJisRangeLim )
{
	LSERR	lserr;
	OBJDIM	objdimUnused;
	WWHOLE	* pwwhole = &pdobj->wwhole;

	Assert (pwwhole->plssubl != NULL);
	
	if (!pwwhole->fJisRangeKnown) /* Have to calculate */
		{
		/* Searching 4 breaks from WWHOLE start */

		LSCP cpTruncateBefore = pdobj->wwhole.cpFirst;
		BOOL fSuccessful = TRUE;
		long nFound = 0;

		while (fSuccessful && nFound < 4)
			{
			lserr = WaFindNextBreakSubline ( pwwhole->plssubl,
											cpTruncateBefore,
											LONG_MAX,
											& fSuccessful,
											& cpTruncateBefore,
											& objdimUnused );
			if (lserr != lserrNone) return lserr;

			if (fSuccessful) nFound ++;
			};

		if (fSuccessful)
			{
			/* Searching 4 breaks from WWHOLE end */

			LSCP cpTruncateAfter;
			BOOL fSuccessful = TRUE;
			long nFound = 0;

			if (pwwhole->fFinished)
				{
				/* Subline was finished at Esc char, so we can start from cpLim */
				cpTruncateAfter = pwwhole->cpLim;
				}
			else
				{
				/* Subline was stopped at RM => start at RM truncation point */
				cpTruncateAfter = pwwhole->cpTruncate+1;
				};
			
			/*	REVIEW (antons): To reduce check above maybe we can lie about
				cp-lim of the whole subline when it was not finished? */

			while (fSuccessful && nFound < 4)
				{
				lserr = WaFindPrevBreakSubline ( pwwhole->plssubl,
												cpTruncateAfter-1,
											    LONG_MAX,
											    & fSuccessful,
											    & cpTruncateAfter,
											    & objdimUnused );

				if (lserr != lserrNone) return lserr;

				if (fSuccessful) nFound ++;
				};

			if (fSuccessful)
				{
				/* Jis Range is not empty */

				pwwhole->cpJisRangeFirst = cpTruncateBefore;
				pwwhole->cpJisRangeLim = cpTruncateAfter + 1;
				}
			else
				{	
				/* Empty range */

				pwwhole->cpJisRangeFirst = 0;
				pwwhole->cpJisRangeLim = 0;
				};
			}
		else
			{
			/* Empty range */

			pwwhole->cpJisRangeFirst = 0;
			pwwhole->cpJisRangeLim = 0;
			};

		pwwhole->fJisRangeKnown = TRUE; /* Yes, now we know it */
		}
	else
		/* Nothing - already know ;-) */ ;


	Assert (pwwhole->fJisRangeKnown);

	*pfJisRangeEmpty = pwwhole->cpJisRangeFirst >= pwwhole->cpJisRangeLim;
	*pcpJisRangeFirst = pwwhole->cpJisRangeFirst;
	*pcpJisRangeLim = pwwhole->cpJisRangeLim;

	return lserrNone;
}


/* S A V E  B R E A K  I N S I D E  W A R I C H U  */
/*----------------------------------------------------------------------------
	%%Function: SaveBreakInsideWarichu
	%%Contact: antons

		Store layout for Prev / Next / Force break in dobj. This procedure
		also Invalidates pointers in input layout after copying.

----------------------------------------------------------------------------*/

static void SaveBreakInsideWarichu ( 
		
		PDOBJ		pdobj,			/* (IN): Warichu Dobj */
		BRKKIND		brkkind,		/* (IN): Kind of break happened */
		WLAYOUT		* pwlayout )	/* (IN/OUT): Layout to store */
{
	int ind = GetBreakRecordIndex (brkkind);

	/* Destroy previously saved layout */
	DestroyWLayout (& pdobj->wlayoutBreak [ind]);

	/* Copy input layout to pdobj */
	pdobj->wlayoutBreak [ind] = *pwlayout;

	pdobj->wbreaktype [ind] = wbreaktypeInside;
	
	/* Invalidate input layout */
	InvalidateWLayout (pwlayout);
}


/* S A V E  B R E A K  A F T E R */
/*----------------------------------------------------------------------------
	%%Function: SaveBreakAfter
	%%Contact: antons

		Changes break information so it says "After current layout"

----------------------------------------------------------------------------*/

static void SaveBreakAfterWarichu ( 
		
		PDOBJ		pdobj,			/* (IN): Warichu Dobj */
		BRKKIND		brkkind )		/* (IN): Kind of break happened */
{
	int ind = GetBreakRecordIndex (brkkind);

	/* Destroy previously saved layout */
	DestroyWLayout (& pdobj->wlayoutBreak [ind]);

	pdobj->wbreaktype [ind] = wbreaktypeAfter;
}


/* F I N D  P R E V  B R E A K  W A R I C H U  D O B J  */
/*----------------------------------------------------------------------------
	%%Function: FindPrevBreakWarichuDobj
	%%Contact: antons


		Important: This procedure has a twin "FindNextBreakWarichuDobj". Any
		change here may require adjusting of the code in another procedure
		as well.

----------------------------------------------------------------------------*/

static LSERR FindPrevBreakWarichuDobj ( 
									  
		PDOBJ	pdobj, 
		LSCP	cpTruncate,
		long	urColumnMax,	/* Only for optimization from Truncate */
		BOOL	* pfSuccessful,
		BOOL	* pfNextAfterColumnMax,	/* (OUT): TRUE if we know that next break is 
												  after urColumnMax for sure */
		LSCP	* pcpBreak,
		OBJDIM	* pobjdimBreak,
		WLAYOUT	* pwlayout )		/* (OUT): Layout of broken Warichu */
{
	LSERR lserr;
	LSCP cpJisRangeFirst, cpJisRangeLim;
	BOOL fJisRangeEmpty;

	InvalidateWLayout (pwlayout); /* Unsuccessful & error */

	lserr = CalcJisRange (pdobj, &fJisRangeEmpty, &cpJisRangeFirst, &cpJisRangeLim);

	if (lserr != lserrNone) return lserr;
	
	if (fJisRangeEmpty || (cpTruncate < cpJisRangeFirst))
		{
		* pfSuccessful = FALSE;
		return lserrNone;
		}
	else
		{
		LSCP cpBreak = cpTruncate+1;

		* pfNextAfterColumnMax = FALSE;

		/* REVIEW (antons): Is not it dangerous start from cpJisLim-1 ? */
		/* Snap to the end of Jis region */
		if (cpBreak > cpJisRangeLim) cpBreak = cpJisRangeLim; 

		for (;;)
			{
			TRYBREAKWARICHU trybreakwarichuKind;
			BOOL fSuccessful;
			OBJDIM objdim;

			lserr = WaFindPrevBreakSubline ( pdobj->wwhole.plssubl, cpBreak-1, LONG_MAX,
											& fSuccessful, & cpBreak, & objdim );

			if (lserr != lserrNone) return lserr;

			if (! fSuccessful || cpBreak < cpJisRangeFirst)
				{
				Assert (fSuccessful); /* Catch against crazy objects inside Warichu, can continue */

				* pfSuccessful = FALSE;
				return lserrNone;
				};

			Assert (cpBreak < cpJisRangeLim);

			lserr =  TryBreakWarichuAtCp (pdobj, cpBreak, objdim.dur,
										  urColumnMax, & trybreakwarichuKind, pwlayout );

			if (lserr != lserrNone) return lserr;

			if (trybreakwarichuKind== trybreakwarichuSuccessful)
				{
				/* Found Warichu Break */

				* pcpBreak = GetCpLimOfWLayout (pdobj, pwlayout);
 				* pfSuccessful = TRUE;
				* pobjdimBreak = pwlayout->wdim.objdimAll;

				return lserr;
				};

			Assert (trybreakwarichuKind == trybreakwarichuExceedMargin || 
					trybreakwarichuKind == trybreakwarichuCanNotFinishAtCp);


			if (trybreakwarichuKind == trybreakwarichuExceedMargin)
				{
				/* Could not break because or Exceeding RM */
				* pfNextAfterColumnMax = TRUE;
				};

			/* Continue loop */

			};

		};

	/* Unreachable code */
}


/* F I N D  N E X T  B R E A K  W A R I C H U  D O B J  */
/*----------------------------------------------------------------------------
	%%Function: FindNextBreakWarichuDobj
	%%Contact: antons

		Important: This procedure has a twin "FindNextBreakWarichuDobj". Any
		change here may require adjusting of the code in another procedure
		as well.

----------------------------------------------------------------------------*/

static LSERR FindNextBreakWarichuDobj ( 
									  
		PDOBJ	pdobj, 
		LSCP	cpTruncate,
		BOOL	* pfSuccessful,
		LSCP	* pcpBreak,
		OBJDIM	* pobjdimBreak,
		WLAYOUT	* pwlayout )		/* (OUT): Layout of broken Warichu */
{
	LSERR lserr;
	LSCP cpJisRangeFirst, cpJisRangeLim;
	BOOL fJisRangeEmpty;

	InvalidateWLayout (pwlayout); /* Unsuccessful & error */

	lserr = CalcJisRange (pdobj, &fJisRangeEmpty, &cpJisRangeFirst, &cpJisRangeLim);

	if (lserr != lserrNone) return lserr;
	
	if (fJisRangeEmpty || (cpTruncate >= cpJisRangeLim-1))
		{
		* pfSuccessful = FALSE;
		return lserrNone;
		}
	else
		{
		LSCP cpBreak = cpTruncate;

		/* REVIEW (antons): Is not it dangerous start from cpJisLim-1 ? */
		if (cpBreak < cpJisRangeFirst) cpBreak = cpJisRangeFirst-1; /* snap to the end of Jis region */
		
		for (;;)
			{
			TRYBREAKWARICHU trybreakwarichuKind;
			BOOL fSuccessful;
			OBJDIM objdim;

			lserr = WaFindNextBreakSubline ( pdobj->wwhole.plssubl, cpBreak, LONG_MAX,
											& fSuccessful, & cpBreak, & objdim );

			if (lserr != lserrNone) return lserr;

			if (! fSuccessful || cpBreak >= cpJisRangeLim)
				{
				Assert (fSuccessful); /* Catch against crazy objects inside Warichu, can continue */

				* pfSuccessful = FALSE;
				return lserrNone;
				};

			Assert (cpBreak >= cpJisRangeFirst);

			lserr =  TryBreakWarichuAtCp (pdobj, cpBreak, objdim.dur,
										  LONG_MAX, & trybreakwarichuKind, pwlayout );

			if (lserr != lserrNone) return lserr;

			if (trybreakwarichuKind == trybreakwarichuSuccessful)
				{
				/* Found Warichu Break */

				* pcpBreak = GetCpLimOfWLayout (pdobj, pwlayout);
				* pfSuccessful = TRUE;
				* pobjdimBreak = pwlayout->wdim.objdimAll;

				return lserrNone;
				};

			Assert (trybreakwarichuKind == trybreakwarichuExceedMargin || 
					trybreakwarichuKind == trybreakwarichuCanNotFinishAtCp);

			/* Continue loop */

			};

		};

	/* Unreachable code */
}


/* W A  T R U N C A T E  P R E V  F O R C E */
/*----------------------------------------------------------------------------
    %%Function: WaTruncatePrevForce
	%%Contact: antons


----------------------------------------------------------------------------*/
static LSERR WaTruncatePrevForce ( 

			PLSSUBL		plssubl, 
			long		urColumnMax, 
			BRKKIND		* pbrkkind,			/* (OUT): Kind of break: Prev or Force */
			LSCP		* pcpBreak,
			BRKPOS		* pbrkpos,
			POBJDIM		pobjdimSubline )
{
	LSERR lserr;

	BOOL fSuccessful;
	LSCP cpTruncate;

	lserr = LsTruncateSubline (plssubl, urColumnMax,  &cpTruncate);
	if (lserr != lserrNone) return lserr;

	lserr = WaFindPrevBreakSubline ( plssubl, cpTruncate, urColumnMax,
									 & fSuccessful, pcpBreak, pobjdimSubline );
	if (lserr != lserrNone) return lserr;

	if (fSuccessful)
		{
		* pbrkkind = brkkindPrev;
		* pbrkpos = brkposInside; /* REVIEW (antons) */
		}
	else
		{
		lserr = WaForceBreakSubline ( plssubl, cpTruncate, urColumnMax,
									  pcpBreak, pbrkpos, pobjdimSubline );
		if (lserr != lserrNone) return lserr;

		Assert (* pbrkpos != brkposBeforeFirstDnode); /* REVIEW (antons): Check with Igor */

		* pbrkkind = brkkindForce;
		* pbrkpos = * pbrkpos;
		};

	return lserrNone;
}


/* F O R C E  B R E A K  W A R I C H U  C O R E */
/*----------------------------------------------------------------------------
	%%Function: ForceBreakWarichuDobjCore
	%%Contact: antons


----------------------------------------------------------------------------*/
static LSERR ForceBreakWarichuDobjCore ( 
									  
		PDOBJ	pdobj, 
		long	urColumnMax,	
		BOOL	fBrokenWarichu,		/* (IN):  Which Warichu to produce: broken or not */
		BOOL	fLeaveSpaceForCloseBrace,
		BOOL	* pfSuccessful,
		LSCP	* pcpBreak,
		OBJDIM	* pobjdimBreak,
		WLAYOUT	* pwlayout )		/* (OUT): Layout of broken Warichu */
{
	LSERR lserr;

	long durOpen, durClose;
	BOOL fBraceOpen, fBraceClose;
	long durAvailable;
	BOOL fFinished;

	BRKPOS brkpos;
	LSCP cpBreak;
	BRKKIND brkkind;
	OBJDIM objdimBreak;

	WBRKARRAY wbrkarrayAtFirstEnd;

	InvalidateWLayout (pwlayout); /* error and unsuccessful */

	/* REVIEW (antons): HACK HACK HACK */

	if (! fLeaveSpaceForCloseBrace)
		{
		GetDurBraces (pdobj, fBrokenWarichu, &fBraceOpen, &durOpen, &fBraceClose, &durClose);
		durAvailable = urColumnMax - durOpen - durClose;
		}
	else
		{
		GetDurBraces (pdobj, FALSE, &fBraceOpen, &durOpen, &fBraceClose, &durClose);
		durAvailable = urColumnMax - durOpen - durClose;
		};

	if (durAvailable <= 0)
		{
		if (! fBrokenWarichu)
			{
			* pfSuccessful = FALSE;
			return lserrNone;
			}
		else
			{
			durAvailable = 0;
			}
		};

	lserr = FormatWSublineUntilRM (pdobj, pdobj->wwhole.cpFirst, durAvailable, 
								   &pdobj->wbrkarrayAtStart, &fFinished,
								   &pwlayout->wsubline1);
	if (lserr != lserrNone) return lserr;

	if (fFinished && pwlayout->wsubline1.objdim.dur <= durAvailable)
		{
		/* REVIEW (antons): Im I right that this assert shows possible error in
		                    breaking inside Warichu? */
		AssertSz (FALSE, "This should not happen in real life, but we handle it");
	
		Assert (! fBrokenWarichu); /* REVIEW (antons) */

		lserr = FinishWLayoutSingleLine (pdobj, pwlayout);
		if (lserr != lserrNone) { DestroyWLayout (pwlayout); return lserr;};

		* pfSuccessful = TRUE;
		* pcpBreak = GetCpLimOfWLayout (pdobj, pwlayout);
		* pobjdimBreak = pwlayout->wdim.objdimAll;

		return lserrNone;
		};

	/* Break first subline at durAvailable */

	lserr = WaTruncatePrevForce ( pwlayout->wsubline1.plssubl, 
								  durAvailable,
								  & brkkind,
								  & cpBreak,
								  & brkpos,
								  & objdimBreak );
	if (lserr != lserrNone) { DestroyWLayout (pwlayout); return lserr;};

	lserr = NewWBrkArray (pdobj, &wbrkarrayAtFirstEnd);
	if (lserr != lserrNone) { DestroyWLayout (pwlayout); return lserr;};

	lserr = SetBreakWSubline ( & pwlayout->wsubline1, brkkind, cpBreak, 
							   & objdimBreak, & wbrkarrayAtFirstEnd );
	if (lserr != lserrNone) 
		{ 
		DestroyWBrkArray (pdobj, &wbrkarrayAtFirstEnd);
		DestroyWLayout (pwlayout); return lserr;
		};

	/* Continue to format second line */

	lserr = FormatWSublineUntilRM ( pdobj, cpBreak, durAvailable, 
								    & wbrkarrayAtFirstEnd, & fFinished,
								    & pwlayout->wsubline2 );
	if (lserr != lserrNone) 
		{ 
		DestroyWBrkArray (pdobj, &wbrkarrayAtFirstEnd);
		DestroyWLayout (pwlayout); return lserr;
		};

	DestroyWBrkArray (pdobj, &wbrkarrayAtFirstEnd);

	if (fFinished && pwlayout->wsubline2.objdim.dur <= durAvailable)
		{
		/* Second subline stopped before RM */

		Assert (pdobj->wwhole.fFinished);

		pwlayout->fBroken = FALSE; /* Closing brace can not stand alone */
		pwlayout->brkkind = brkkindImposedAfter; /* in the case of fBroken */

		lserr = FinishObjDimWLayout (pdobj, pwlayout);
		if (lserr != lserrNone) { DestroyWLayout (pwlayout); return lserr;};

		* pfSuccessful = TRUE;
		* pcpBreak = GetCpLimOfWLayout (pdobj, pwlayout);
		* pobjdimBreak = pwlayout->wdim.objdimAll;

		return lserrNone;
		};

	/* Break at the end of second line... */

	lserr = WaTruncatePrevForce ( pwlayout->wsubline2.plssubl, 
								  durAvailable,
								  & brkkind, 
								  & cpBreak, 
								  & brkpos, 
								  & objdimBreak );
	if (lserr != lserrNone) { DestroyWLayout (pwlayout); return lserr;};

	if (brkpos == brkposAfterLastDnode)
		{
		/* Second subline broken "After" */

		Assert (pdobj->wwhole.fFinished);
		
		pwlayout->fBroken = FALSE; /* Closing brace can not stand alone */
		pwlayout->brkkind = brkkind; /* in the case of fBroken */

		lserr = FinishObjDimWLayout (pdobj, pwlayout);
		if (lserr != lserrNone) { DestroyWLayout (pwlayout); return lserr;};

		* pfSuccessful = TRUE;
		* pcpBreak = GetCpLimOfWLayout (pdobj, pwlayout);
		* pobjdimBreak = pwlayout->wdim.objdimAll;

		return lserrNone;
	};

	if (fBrokenWarichu)
		{
		/* REVIEW (antons) */
		/* Our cheating to postpone SetBreakSubline until WarichuSetBreak */

		pwlayout->wsubline2.cpLim = cpBreak;
		pwlayout->wsubline2.objdim = objdimBreak;

		pwlayout->brkkind = brkkind;
		pwlayout->fBroken = TRUE;

		lserr = FinishObjDimWLayout (pdobj, pwlayout);

		if (lserr != lserrNone) { DestroyWLayout (pwlayout); return lserr;};

		* pfSuccessful = TRUE;
		* pcpBreak = GetCpLimOfWLayout (pdobj, pwlayout);
		* pobjdimBreak = pwlayout->wdim.objdimAll;
		return lserrNone;
		}
	else
		{
		/* Have to return Unsuccessful */

		* pfSuccessful = FALSE;

		lserr = DestroyWLayout (pwlayout); /* Not to loose memory */
		return lserrNone;
		}
}


/* F O R C E  B R E A K  W A R I C H U  D O B J  */
/*----------------------------------------------------------------------------
	%%Function: ForceBreakWarichuDobj
	%%Contact: antons


----------------------------------------------------------------------------*/
static LSERR ForceBreakWarichuDobj ( 
									
				PDOBJ	pdobj,
				long	urColumnMax,	
				BOOL	* pfSuccessful,
				LSCP	* pcpBreak,
				OBJDIM	* pobjdimBreak,
				WLAYOUT	* pwlayout )/* (OUT): Layout of broken Warichu */
{
	LSERR lserr;
	BOOL fSuccessful = FALSE;

	/* 1. TRY FORCE BREAK WITHOUT BREAKING OF WARICHU */

	if (pdobj->wwhole.fFinished)
		{
		/* Without breaking can be only when closing brace fetched */
		
		lserr = ForceBreakWarichuDobjCore ( pdobj, urColumnMax, FALSE, FALSE, & fSuccessful,
											pcpBreak, pobjdimBreak, pwlayout );
		if (lserr != lserrNone) return lserr;
		};

	if (! fSuccessful)
		{
		/* 2. TRY FORCE BREAK WITH POSSIBLE BREAKING OF WARICHU */

		lserr = ForceBreakWarichuDobjCore ( pdobj, urColumnMax, TRUE, FALSE, & fSuccessful,
											pcpBreak, pobjdimBreak, pwlayout );
		if (lserr != lserrNone) return lserr;

		/* Euristic solution for the case when we exceed RM because we added closing brace */

		if (fSuccessful && pdobj->wwhole.fFinished && urColumnMax < pobjdimBreak->dur)
			{
			lserr = DestroyWLayout (pwlayout);
			if (lserr != lserrNone) return lserr;

			lserr = ForceBreakWarichuDobjCore ( pdobj, urColumnMax, TRUE, TRUE, & fSuccessful,
												pcpBreak, pobjdimBreak, pwlayout );
			if (lserr != lserrNone) return lserr;
			};
	
		};

	* pfSuccessful = fSuccessful;

	return lserrNone;
}


/* T R U N C A T E  W A R I C H U  D O B J  */
/*----------------------------------------------------------------------------
	%%Function: TruncateWarichuDobj
	%%Contact: antons


----------------------------------------------------------------------------*/
static LSERR TruncateWarichuDobj ( 
									  
		PDOBJ	pdobj, 				/* (IN):  Warichu DOBJ */
		long	urColumnMax,		/* (IN):  ColumnMax to fix warichu before */
		BOOL	* pfSuccessful,		/* (OUT): Successful? */
		LSCP	* pcpBreak,			/* (OUT): Cp of broken Warichu if fSuccessful */
		OBJDIM	* pobjdimBreak,		/* (OUT): Dim of broken Warichu if fSuccessful */
		WLAYOUT	* pwlayout )		/* (OUT): Layout of broken Warichu if fSuccessful */
{
	LSERR lserr;

	long	durOpen;
	long	durClose;
	BOOL	boolUnused1, boolUnused2;
	BOOL	fSuccessful;
	BOOL	fNextAfterColumnMax;

	LSCP	cpBreakCandidate;
	LSCP	cpTruncateWhole;
	OBJDIM	objdimCandidate;

	ClearWLayout (pwlayout); /* in case of error or ! fSuccessful */

	GetDurBraces (pdobj, TRUE, &boolUnused1, &durOpen, &boolUnused2, &durClose);

	/* REVIEW (antons): Move this check to a separate function */
	if (urColumnMax <= durOpen + durClose) 
	{
		/* Optimization: in this case we know for sure there is no break */
		*pfSuccessful = FALSE;
		return lserrNone;
	};

	/* Estimate truncation point in WWHOLE (find cpTruncateWhole) */

	{
		/*	We want to estimate truncation point on WWHOLE as 2*(urColumnMax-durOpen-durClose),
			but unfortunately it is not always possible. Here we check if can truncate
			WWHOLE at this urTruncateWhole or, if we can not, take last possible cp in the
			whole subline. Situation depends on whether we finished WWHOLE or not */

		long urTruncateWhole = MULLongSafe (urColumnMax - durOpen - durClose, 2);

		/* REVIEW (antons): Can we optimize if we know durs of JIS range? */
		/* REVIEW (antons): Check all situation when I may come to "else" */
		/* REVIEW (antons): Should the second part (starting with "NOT") ever cause "else"? */
		if ( (    pdobj->wwhole.fFinished && urTruncateWhole < pdobj->wwhole.objdim.dur) ||
			 (NOT pdobj->wwhole.fFinished && urTruncateWhole < pdobj->wwhole.urColumnMax ) )
			{
				lserr = LsTruncateSubline (pdobj->wwhole.plssubl, urTruncateWhole,
										   & cpTruncateWhole);
				if (lserr != lserrNone) return lserr;
			}
		else if (pdobj->wwhole.fFinished)
			{
			cpTruncateWhole = pdobj->wwhole.cpLim;
			}
		else
			{
			cpTruncateWhole = pdobj->wwhole.cpTruncate;
			};
	}

	/* REVIEW (antos): Here and later in this proc I use pwayout as a candidate for 
					   truncation. Should I better use local structure? */

	lserr = FindPrevBreakWarichuDobj ( pdobj, cpTruncateWhole, urColumnMax, & fSuccessful, 
									   & fNextAfterColumnMax, & cpBreakCandidate, & objdimCandidate, 
									   pwlayout );
	if (lserr != lserrNone) return lserr;

	if (fSuccessful && fNextAfterColumnMax)
		{
		/* Candidate is OK */

		* pfSuccessful = TRUE;
		* pcpBreak = cpBreakCandidate;
		* pobjdimBreak = objdimCandidate;
		return lserrNone;
		};

	if (!fSuccessful)
		{
		/* Prev break Dobj is not found (or beyond RM) => try next break as a candidate */

		lserr = FindNextBreakWarichuDobj ( pdobj, cpTruncateWhole, & fSuccessful, 
										   & cpBreakCandidate, & objdimCandidate, pwlayout );
		if (lserr != lserrNone) return lserr;

		if (!fSuccessful)
			{
			/* NEXT break is not found */

			* pfSuccessful = FALSE;
			return lserrNone;
			}
		else if (objdimCandidate.dur > urColumnMax)
			{
			/* NEXT break is found but it is beyond RM */

			* pfSuccessful = FALSE;
			lserr = DestroyWLayout (pwlayout);
			return lserr;
			};
		};

	/* At this point we have break candidate: (pwlayout, cpBreakCandidate, objdimCandidate) */
	/* Now we shall go forward to make sure we have last possible break before RM */

	{
		BOOL fContinue;
		Assert (objdimCandidate.dur <= urColumnMax);

		fContinue = TRUE;

		while (fContinue)
			{
			WLAYOUT	wlayoutNext;
			OBJDIM	objdimNext;
			LSCP	cpBreakNext;
			BOOL	fSuccessful;
			
			lserr = FindNextBreakWarichuDobj ( pdobj, cpBreakCandidate, & fSuccessful, 
											  & cpBreakNext, & objdimNext, &wlayoutNext );
			if (lserr != lserrNone) {DestroyWLayout (pwlayout); return lserr;};

			if (!fSuccessful)
				{
				/* Next not found => Candidate is OK */
				fContinue = FALSE;
				}

			else if (objdimNext.dur > urColumnMax)
			{
				/* Next found, but exceeds RM => Candidate OK */

				/* Destroy wlayoutNext, because we do not need it */
				lserr = DestroyWLayout (&wlayoutNext); 
				if (lserr != lserrNone) {DestroyWLayout (pwlayout); return lserr;};

				fContinue = FALSE;
				}
			else
				{
				/* Next found and before RM => Is is a new Candidate */

				/* Destroy layout of the candidate, because we do not need it */
				lserr = DestroyWLayout (pwlayout); /* Destroy old candidate */
				if (lserr != lserrNone) {DestroyWLayout (&wlayoutNext); return lserr;};

				* pwlayout = wlayoutNext;
				cpBreakCandidate = cpBreakNext; /* Next break also before RM */
				objdimCandidate = objdimNext;
				}
			
			}; /* While (fContinue */

		* pfSuccessful = TRUE;
		* pcpBreak = cpBreakCandidate;
		* pobjdimBreak = objdimCandidate;

		/* pwlayout contains correct candiate layout */
		Assert (pwlayout->wdim.objdimAll.dur == objdimCandidate.dur); /* Sanity check */
		return lserrNone;
	};

} /* TruncateWarichuDobj */


/* P U T  B R E A K  A T  W A R I C H U  E N D  */
/*----------------------------------------------------------------------------
	%%Function: PutBreakAtWarichuEnd
	%%Contact: antons

		Fill in break output record for the end of the Warichu
	
----------------------------------------------------------------------------*/
static void PutBreakAtWarichuEnd (

		DWORD ichnk,				/* (IN): index in chunk */
		PCLOCCHNK pclocchnk,		/* (IN): locchnk to find break */
		PBRKOUT pbrkout)			/* (OUT): results of breaking */
{	
	PDOBJ pdobj = pclocchnk->plschnk[ichnk].pdobj;

	pbrkout->fSuccessful = TRUE;
	pbrkout->posichnk.dcp = GetCpLimOfWLayout (pdobj, &pdobj->wlayout) - pdobj->cpStart; 
																/* REVIEW (antons) */
	pbrkout->posichnk.ichnk = ichnk;
	pbrkout->objdim = pdobj->wlayout.wdim.objdimAll;
}


/* P U T  B R E A K  A T  W A R I C H U  B E G I N  */
/*----------------------------------------------------------------------------
	%%Function: PutBreakAtWarichuBegin
	%%Contact: antons

		Fill in break output record for break before Warichu.
	
----------------------------------------------------------------------------*/
static void PutBreakAtWarichuBegin (

		DWORD ichnk,				/* (IN): index in chunk */
		PCLOCCHNK pclocchnk,		/* (IN): locchnk to find break */
		PBRKOUT pbrkout )			/* (OUT): results of breaking */
{	
	Unreferenced (pclocchnk);

	pbrkout->fSuccessful = TRUE;
	pbrkout->posichnk.dcp = 0;
	pbrkout->posichnk.ichnk = ichnk;

	ZeroObjDim (&pbrkout->objdim);
}



/* P U T  B R E A K  W A R I C H U  U N S U C C E S S F U L  */
/*----------------------------------------------------------------------------
	%%Function: PutBreakWarichuUnsuccessful
	%%Contact: antons


----------------------------------------------------------------------------*/
static void PutBreakWarichuUnsuccessful (PBRKOUT pbrkout)
{	
	pbrkout->fSuccessful = FALSE;
	pbrkout->brkcond = brkcondPlease;

	/* Hack to fix crash before we eliminate posichnkBeforeTrailing */

}


/* P U T  B R E A K  W A R I C H U  D O B J */
/*----------------------------------------------------------------------------
	%%Function: PutBreakWarichuDobj
	%%Contact: antons


----------------------------------------------------------------------------*/
static void PutBreakAtWarichuDobj (

		DWORD ichnk, 
		PCLOCCHNK pclocchnk, 
		LSCP cpBreak,
		OBJDIM *pobjdimBreak,
				
		PBRKOUT pbrkout)
{	
	PDOBJ pdobj = pclocchnk->plschnk[ichnk].pdobj;

	pbrkout->fSuccessful = TRUE;
	pbrkout->posichnk.dcp = cpBreak - pdobj->cpStart;
	pbrkout->posichnk.ichnk = ichnk;
	pbrkout->objdim = *pobjdimBreak;

	Assert (pbrkout->posichnk.dcp > 0);
}


/* W A R I C H U  T R U N C A T E  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: WarichuTruncateChunk
	%%Contact: antons


----------------------------------------------------------------------------*/

LSERR WINAPI WarichuTruncateChunk (PCLOCCHNK plocchnk, PPOSICHNK pposichnk)			
{
	LSERR	lserr;
	long	urColumnMax = plocchnk->lsfgi.urColumnMax;

	DWORD	ichnk = 0;
	BOOL	fFound = FALSE;

	/* Find object containing RM */

	while (!fFound)
		{
		Assert (ichnk < plocchnk->clschnk);
		Assert (plocchnk->ppointUvLoc[ichnk].u <= urColumnMax);

		fFound = plocchnk->ppointUvLoc[ichnk].u + 
				 plocchnk->plschnk[ichnk].pdobj->wlayout.wdim.objdimAll.dur > urColumnMax;

		if (!fFound) ichnk++;
		};

	Assert (ichnk < plocchnk->clschnk);

	/* Element ichnk contains RM, try to prev break it to find correct tr point */

	{
		LSCP	cpBreak;
		BOOL	fSuccessful;
		OBJDIM	objdimBreak;
		WLAYOUT wlayoutBreak;
		
		PDOBJ	pdobj = plocchnk->plschnk[ichnk].pdobj;
		
		lserr = TruncateWarichuDobj ( pdobj, 
									  urColumnMax - plocchnk->ppointUvLoc[ichnk].u,
									  & fSuccessful,
									  & cpBreak,
									  & objdimBreak,
									  & wlayoutBreak );
		if (lserr != lserrNone) return lserr;

		ReformatClosingBraceForWord9 (pdobj);
		
		if (fSuccessful) /* Found break before RM */
			{
			/* REVIEW (antons): Move this before call to TruncateWarichuDobj */
			lserr = DestroyWLayout (&pdobj->wlayoutTruncate);
			if (lserr != lserrNone) return lserr;

			pdobj->wlayoutTruncate = wlayoutBreak;
			
			pposichnk->ichnk = ichnk;
			pposichnk->dcp = cpBreak - pdobj->cpStart + 1; /* +1 because dcp is always lim */
			return lserrNone;
			}
		else
			{
			/* Break before RM not found => dcpTruncate := 1 */

			pposichnk->ichnk = ichnk;
			pposichnk->dcp = 1; 
			return lserrNone;
			};
			
	};
}


/* W A R I C H U  F I N D  P R E V  B R E A K  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: WarichuFindPrevBreakChunk
	%%Contact: antons

		Important: This procedure is similar to "WarichuFindPrevBreakChunk". 
		Any change here may require to change another procedure as well.
  
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuFindPrevBreakChunk (

		PCLOCCHNK	pclocchnk,		/* (IN):  locchnk to break */
		PCPOSICHNK	pcpoischnk,		/* (IN):  place to start looking for break */
		BRKCOND		brkcond,		/* (IN):  recommmendation about the break after chunk */
		PBRKOUT		pbrkout)		/* (OUT): results of breaking */
{
	LSERR	lserr;
	PDOBJ	pdobj;

	WLAYOUT	wlayoutBreak;
	BOOL	fSuccessful;
	LSCP	cpBreak;
	LSCP	cpTruncate;
	OBJDIM	objdimBreak;
	BOOL	fNextBeforeColumnMaxUnused;

	POSICHNK posichnk = *pcpoischnk;	/* position to start looking for break */

	if (posichnk.ichnk == ichnkOutside)
		{
		if (brkcond != brkcondNever)
			{
			/* Can break after chunk */

			pdobj = pclocchnk->plschnk [pclocchnk->clschnk - 1].pdobj;

			SaveBreakAfterWarichu (pdobj, brkkindPrev);
			PutBreakAtWarichuEnd (pclocchnk->clschnk - 1, pclocchnk, pbrkout);
			return lserrNone;
			}
		else
			{
			/* Can not break after chunk, will try to break last Warichu */

			PDOBJ pdobj = pclocchnk->plschnk[pclocchnk->clschnk - 1].pdobj;

			posichnk.ichnk = pclocchnk->clschnk - 1;
			posichnk.dcp = GetCpLimOfWLayout (pdobj, &pdobj->wlayout) - pdobj->cpStart;
			};
		};

	/* Call routing which breaks Warichu */

	pdobj = pclocchnk->plschnk[posichnk.ichnk].pdobj;
	cpTruncate = pdobj->cpStart + posichnk.dcp - 1;

	if (FWLayoutValid (&pdobj->wlayoutTruncate) &&
	    cpTruncate == GetCpLimOfWLayout (pdobj, &pdobj->wlayoutTruncate))
	    {
	    /* Optimization: we can take WLayout saved during Truncation */

		PutBreakAtWarichuDobj (posichnk.ichnk, pclocchnk, cpTruncate, 
							   & pdobj->wlayoutTruncate.wdim.objdimAll, pbrkout);
		SaveBreakInsideWarichu (pdobj, brkkindPrev, &pdobj->wlayoutTruncate);

	    ClearWLayout (&pdobj->wlayoutTruncate);
	    return lserrNone;
	    }

	lserr = FindPrevBreakWarichuDobj ( pdobj, cpTruncate,
									   LONG_MAX, & fSuccessful, & fNextBeforeColumnMaxUnused,
									   & cpBreak, & objdimBreak, & wlayoutBreak );
	if (lserr != lserrNone) return lserr;

	ReformatClosingBraceForWord9 (pdobj);

	/* Check result */

	if (fSuccessful)
		{
		/* Successful => Break inside Watichu */
		Assert (cpBreak <= pdobj->cpStart + (long)posichnk.dcp - 1); /* Monotinous axiom */

		SaveBreakInsideWarichu (pdobj, brkkindPrev, &wlayoutBreak);
		PutBreakAtWarichuDobj (posichnk.ichnk, pclocchnk, cpBreak, &objdimBreak, pbrkout);
		}
	else if (posichnk.ichnk > 0)
		{
		/* Can break between Warichus */

		pdobj = pclocchnk->plschnk [posichnk.ichnk-1].pdobj;

		SaveBreakAfterWarichu (pdobj, brkkindPrev);
		PutBreakAtWarichuEnd (posichnk.ichnk-1, pclocchnk, pbrkout);
		}
	else
		{
		/* Unsuccessful */

		PutBreakWarichuUnsuccessful (pbrkout);
		};

	return lserrNone;
}



/* W A R I C H U  F I N D  N E X T  B R E A K  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: WarichuFindNextBreakChunk
	%%Contact: antons

		Important: This procedure is similar to "WarichuFindNextBreakChunk". 
		Any change here may require to change another procedure as well.
	
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuFindNextBreakChunk (

		PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
		PCPOSICHNK pcpoischnk,		/* (IN): place to start looking for break */
		BRKCOND brkcond,			/* (IN): recommendation about the break before chunk */
		PBRKOUT pbrkout)			/* (OUT): results of breaking */
{
	LSERR	lserr;
	PDOBJ	pdobj;

	WLAYOUT	wlayoutBreak;
	BOOL	fSuccessful;
	LSCP	cpBreak;
	OBJDIM	objdimBreak;

	POSICHNK posichnk = *pcpoischnk;	/* position to start looking for break */

	if (posichnk.ichnk == ichnkOutside)
		{
		if (brkcond != brkcondNever)
			{
			/* Can break before chunk */

			PutBreakAtWarichuBegin (0, pclocchnk, pbrkout);
			return lserrNone;
			}
		else
			{
			/* Can not break before chunk, will try to break first Warichu */

			posichnk.ichnk = 0;
			posichnk.dcp = 1; /* REVIEW (antons): Check this dcp assigment */
			};
		};


	/* Call routing which breaks Warichu */

	pdobj = pclocchnk->plschnk[posichnk.ichnk].pdobj;

	lserr = FindNextBreakWarichuDobj ( pdobj, pdobj->cpStart + posichnk.dcp - 1,
									   & fSuccessful, & cpBreak, 
									   & objdimBreak, & wlayoutBreak );
	if (lserr != lserrNone) return lserr;

	ReformatClosingBraceForWord9 (pdobj);

	/* Check result */

	if (fSuccessful)
		{
		/* Break inside Watichu */
		Assert (cpBreak > pdobj->cpStart + (long)posichnk.dcp - 1); /* Monotinous axiom */

		SaveBreakInsideWarichu (pdobj, brkkindNext, &wlayoutBreak);
		PutBreakAtWarichuDobj (posichnk.ichnk, pclocchnk, cpBreak, &objdimBreak, pbrkout);
		}
	else if (posichnk.ichnk < (long)pclocchnk->clschnk - 1)
		{
		/* Can break between Warichus */

		pdobj = pclocchnk->plschnk [posichnk.ichnk].pdobj;

		SaveBreakAfterWarichu (pdobj, brkkindNext);
		PutBreakAtWarichuEnd (posichnk.ichnk, pclocchnk, pbrkout);
		}
	else
		{
		/* Unsuccessful */

		pbrkout->objdim = pclocchnk->plschnk[pclocchnk->clschnk - 1].pdobj->wlayout.wdim.objdimAll;

		SaveBreakAfterWarichu (pdobj, brkkindNext);
		PutBreakWarichuUnsuccessful (pbrkout);
		};

	return lserrNone;
}


/* W A R I C H U  F O R C E  B R E A K  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: WarichuForceBreakChunk
	%%Contact: antons


----------------------------------------------------------------------------*/

LSERR WINAPI WarichuForceBreakChunk (

		PCLOCCHNK pclocchnk,		/* (IN):  Locchnk to break */
		PCPOSICHNK pcposichnk,		/* (IN):  Place to start looking for break */
		PBRKOUT pbrkout)			/* (OUT): Results of breaking */
{
	/*	This procedure must be called with same arguments passed to Truncation.
		If this is violated, Warichu may appear beyond RM */

	/* REVIEW (antons): Should I assert agains violations? */

	LSERR	lserr;

	BOOL	fSuccessful;
	LSCP	cpBreak;
	OBJDIM	objdimBreak;

	WLAYOUT wlayoutBreak;

	DWORD	ichnk = pcposichnk->ichnk;
	PDOBJ	pdobj;

	if (ichnk == ichnkOutside) ichnk = 0; /* When left indent is bigger then RM */
	Assert (ichnk != ichnkOutside);
	
	if (ichnk > 0)
		{
		/* Can break after previous Warichu */
		pdobj = pclocchnk->plschnk [ichnk-1].pdobj;

		SaveBreakAfterWarichu (pdobj, brkkindForce);
		PutBreakAtWarichuEnd (ichnk-1, pclocchnk, pbrkout);
		}
	else if (!pclocchnk->lsfgi.fFirstOnLine)
		{
		/* Can break before first chunk element, because !fFirstOnLine */

		Assert (ichnk == 0);

		PutBreakAtWarichuBegin (0, pclocchnk, pbrkout);
		}
	else
		{
		/* We are the only on the line */

		/* REVIEW (antons): Check it and if this is correct make same changes in ROBJ etc. */
		long urAvailable = pclocchnk->lsfgi.urColumnMax - 
						   pclocchnk->ppointUvLoc [ichnk].u;

		pdobj = pclocchnk->plschnk [ichnk].pdobj;

		/* Try to force break Warichi */
		lserr = ForceBreakWarichuDobj ( pdobj, urAvailable, & fSuccessful, 
									    & cpBreak, & objdimBreak, &wlayoutBreak );
		if (lserr != lserrNone) return lserr;

		ReformatClosingBraceForWord9 (pdobj);

		if (fSuccessful)
			{
			/* Yes, we can force break Warichu */
	
			Assert (cpBreak > pdobj->cpStart);

			SaveBreakInsideWarichu (pdobj, brkkindForce, &wlayoutBreak);
			PutBreakAtWarichuDobj ( ichnk, pclocchnk, cpBreak, 
									&objdimBreak, pbrkout);
			}
		else
			{
			/* Nothing to do... have to break "after" and go beyond RM */

			pdobj = pclocchnk->plschnk [ichnk].pdobj;

			SaveBreakAfterWarichu (pdobj, brkkindForce);
			PutBreakAtWarichuEnd (ichnk, pclocchnk, pbrkout);
			}
		};

	Assert (pbrkout->fSuccessful); /* Force break always successful */
	return lserrNone;
}	


/* W A R I C H U S E T B R E A K */
/*----------------------------------------------------------------------------
	%%Function: WarichuSetBreak
	%%Contact: antons


--------------------------------------------------------------------------*/
LSERR WINAPI WarichuSetBreak (

		PDOBJ pdobj,				/* (IN): Dobj which is broken */
		BRKKIND brkkind,			/* (IN): Kind of break */
		DWORD cBreakRecord,			/* (IN): Size of array */
		BREAKREC *rgBreakRecord,	/* (IN): Array of break records */
		DWORD *pcActualBreakRecord)	/* (IN): Actual number of used elements in array */
{
	LSERR lserr;

	/* REVIEW (antons): Should we destroy formatting layout forever? */
	/* REVIEW (antons): Should we release info about other previous breaks? */

	if (brkkind == brkkindImposedAfter)
		{
		/* Looks like we are doing nothing */

		*pcActualBreakRecord = 0; /* Break after Warichu, so it is terminate */
		
		return lserrNone;
		}
	else
		{
		/* Prev | Next | Force */

		int	ind = GetBreakRecordIndex (brkkind);
		WLAYOUT * pwlayout = & pdobj->wlayout;

		if (pdobj->wbreaktype [ind] == wbreaktypeAfter)
			{
			/* Break was after Warichu */

			*pcActualBreakRecord = 0;
			return lserrNone;
			};

		/* This Assert actually means != wbreaktypeInvalid */
		Assert (pdobj->wbreaktype [ind] == wbreaktypeInside);

		if (cBreakRecord < 1) return lserrInsufficientBreakRecBuffer;

		Assert (cBreakRecord >= 1); /* Broken warichu is not terminate ;-) */

		/* REVIEW (antons): Find better way to check correctess of break data */
		Assert (pdobj->wlayoutBreak [ind].wsubline1.plssubl != NULL);

		lserr = DestroyWLayout (&pdobj->wlayout);
		if (lserr != lserrNone) return lserr;

		* pwlayout = pdobj->wlayoutBreak [ind]; /* Copy break wlayout to current */

		ClearWLayout (&pdobj->wlayoutBreak [ind]);

		/* REVIEW (antons): is there any other exceptions? */
		Assert (brkkind == brkkindForce || pwlayout->fBroken);
		Assert (pwlayout->wsubline2.plssubl != NULL);

		/* Have to set break at the end of second line */

		/* REVIEW (antons): ? Assert against incorrect dimensions? */
		lserr = LsSetBreakSubline ( pwlayout->wsubline2.plssubl, 
									pwlayout->brkkind,
									cBreakRecord - 1,
									& rgBreakRecord [1],
									pcActualBreakRecord );
		if (lserr != lserrNone) return lserr;

		lserr = SubmitWLayoutSublines (pdobj, pwlayout);
		if (lserr != lserrNone) return lserr;

		rgBreakRecord [0].idobj = pdobj->pilsobj->idobj;
		rgBreakRecord [0].cpFirst = pdobj->cpStartObj; /* REVIEW (antons) */

		(*pcActualBreakRecord) ++; /* Add 1 for Warichu break record */

		return lserrNone;
		};

}

/* W A R I C H U  G E T  S P E C I A L  E F F E C T S  I N S I D E */
/*----------------------------------------------------------------------------
	%%Function: WarichuGetSpecialEffectsInside
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI WarichuGetSpecialEffectsInside (PDOBJ pdobj, UINT *pEffectsFlags)
{
	LSERR lserr;
	WLAYOUT	* pwlayout = & pdobj->wlayout;

	UINT uiOpen   = 0;
	UINT uiClose  = 0;
	UINT uiFirst  = 0;
	UINT uiSecond = 0;

	if (FOpenBraceInWLayout (pdobj, pwlayout))
		{
		lserr = LsGetSpecialEffectsSubline (pdobj->wbraceOpen.plssubl, &uiOpen);
		if (lserr != lserrNone) return lserr;
		};

	lserr = LsGetSpecialEffectsSubline (pwlayout->wsubline1.plssubl, &uiFirst);
	if (lserr != lserrNone) return lserr;

	if (pwlayout->wsubline2.plssubl != NULL)
		{
		lserr = LsGetSpecialEffectsSubline (pwlayout->wsubline2.plssubl, &uiSecond);
		if (lserr != lserrNone) return lserr;
		};

	if (FCloseBraceInWLayout (pdobj, pwlayout))
		{
		lserr = LsGetSpecialEffectsSubline (pdobj->wbraceClose.plssubl, &uiClose);
		if (lserr != lserrNone) return lserr;
		};
	
	*pEffectsFlags = uiOpen | uiClose | uiFirst | uiSecond;
	
	return lserrNone;
}


/* W A R I C H U  C A L C   P R E S E N T A T I O N */
/*----------------------------------------------------------------------------
	%%Function: WarichuCalcPresentation
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI WarichuCalcPresentation (PDOBJ pdobj, long dup, LSKJUST lskjust, BOOL fLastVisibleOnLine)
{
	LSERR lserr;

	WLAYOUT	 * pwlayout = & pdobj->wlayout;
	WDISPLAY * pwdisplay = & pdobj->wdisplay;

	long dupInside; /* Dup of the longest Warichu subline */

	Unreferenced (fLastVisibleOnLine);	
	Unreferenced (lskjust);
	Unreferenced (dup);

	/* REVIEW (antons): The following Assert is agains the rule that object which
	   exceeded RM must be broken inside (see formatting code for details) */

	Assert (FWLayoutValid (&pdobj->wlayout));

	/* 1. Prepare both warichu lines for display & store dups in our structures */

	if (pwlayout->wsubline1.objdim.dur >= pwlayout->wsubline2.objdim.dur)
		{
		/* First subline is bigger */
		/* NOTE: THIS PIECE OF CODE (-then-) HAS A TWIN IN (-else-) */

		lserr = WaMatchPresSubline (pwlayout->wsubline1.plssubl, & pwdisplay->wdispsubl1.dup);
		if (lserr != lserrNone) return lserr;

		dupInside = pwdisplay->wdispsubl1.dup; /* Dup of the first subline */

		if (pwlayout->wsubline2.plssubl != NULL)
			{
			/* Second subline is not empty */

			lserr = WaExpandSubline (pwlayout->wsubline2.plssubl, 
									lskjFullScaled,
									pwdisplay->wdispsubl1.dup, 
									& pwdisplay->wdispsubl2.dup);

			if (lserr != lserrNone) return lserr;
			}
		else
			pwdisplay->wdispsubl2.dup = 0; /* Used in calculation further in this proc */
		}
	else
		{
		/* Second subline is bigger */
		/* NOTE: THIS PIECE OF CODE (-else-) HAS A TWIN IN (-then-) */

		lserr = WaMatchPresSubline (pwlayout->wsubline2.plssubl, & pwdisplay->wdispsubl2.dup);
		if (lserr != lserrNone) return lserr;

		dupInside = pwdisplay->wdispsubl2.dup; /* Dup of the second subline */

		lserr = WaExpandSubline (pwlayout->wsubline1.plssubl, 
								lskjFullScaled,
								pwdisplay->wdispsubl2.dup, 
								& pwdisplay->wdispsubl1.dup);

		if (lserr != lserrNone) return lserr;
		};

	/* 2. Prepare brackets for display & store dups in our structures */

	/* REVIEW (antons): Rick expanded closing brace if it was not DonePres before... */

	if (FOpenBraceInWLayout(pdobj, pwlayout)) /* Open brace present */
		{
		lserr = WaMatchPresSubline (pdobj->wbraceOpen.plssubl, &pwdisplay->wdispbraceOpen.dup);
		if (lserr != lserrNone) return lserr;
		}
	else 
		pwdisplay->wdispbraceOpen.dup = 0; /* Used in calculation further in this proc */


	if (FCloseBraceInWLayout(pdobj, pwlayout)) /* Close brace present */
		{
		lserr = WaMatchPresSubline (pdobj->wbraceClose.plssubl, &pwdisplay->wdispbraceClose.dup);
		if (lserr != lserrNone) return lserr;
		}
	else
		pwdisplay->wdispbraceClose.dup = 0; /* Used in calculation further in this proc */

	/* 3. Magic dvpBetween */

	/* REVIEW (antons): Clear this issue */

	pwdisplay->dvpBetween =	  

			  pwlayout->wdim.objdimAll.heightsPres.dvMultiLineHeight
			- pwlayout->wsubline1.objdim.heightsPres.dvAscent
			- pwlayout->wsubline1.objdim.heightsPres.dvDescent
			- pwlayout->wsubline2.objdim.heightsPres.dvAscent
			- pwlayout->wsubline2.objdim.heightsPres.dvDescent
			- pwlayout->wdim.dvpDescentReserved ;
	
	/* 3. Calculate relative positions of Warichu sublines & braces */

	pwdisplay->wdispbraceOpen.duvStart.u = 0;
	pwdisplay->wdispbraceOpen.duvStart.v = 0;

	pwdisplay->wdispsubl1.duvStart.u = pwdisplay->wdispbraceOpen.dup;
	pwdisplay->wdispsubl1.duvStart.v = 

			  pwlayout->wsubline2.objdim.heightsPres.dvAscent 
			+ pwlayout->wsubline2.objdim.heightsPres.dvDescent 
			+ pwdisplay->dvpBetween
			+ pwlayout->wsubline1.objdim.heightsPres.dvDescent
			- pwlayout->wdim.objdimAll.heightsPres.dvDescent 
			- pwlayout->wdim.dvpDescentReserved ;

	if (pwlayout->wsubline2.plssubl != NULL)
		{

		pwdisplay->wdispsubl2.duvStart.u = pwdisplay->wdispbraceOpen.dup;
		pwdisplay->wdispsubl2.duvStart.v = 

				  pwlayout->wsubline2.objdim.heightsPres.dvDescent 
				- pwlayout->wdim.objdimAll.heightsPres.dvDescent 
				- pwlayout->wdim.dvpDescentReserved ;

		Assert (pwdisplay->wdispsubl1.duvStart.v >= pwdisplay->wdispsubl2.duvStart.v);
		};


	pwdisplay->wdispbraceClose.duvStart.u = pwdisplay->wdispbraceOpen.dup 
		+ dupInside;

	pwdisplay->wdispbraceClose.duvStart.v = 0;

	/*	REVIEW (antons): Clear the problem of possible difference 
		between dup-input and calculated dup in this procedure */

	pwdisplay->dupAll =  pwdisplay->wdispbraceOpen.dup + pwdisplay->wdispbraceClose.dup + 
						+ dupInside;

	/* REVIEW (antons): It is better if we try to make 
	   dup == pwdisplay->dupAll, do something like David Bangs in text */

/* REVIEW (antons): The following assert has been commented out for build 314 */

/*  Assert (dup == pwdisplay->dupAll); */

	return lserrNone;

} /* WarichuCalcPresentation */



/* W A R I C H U   Q U E R Y   P O I N T   P C P */
/*----------------------------------------------------------------------------
	%%Function: WarichuQueryPointPcp
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI WarichuQueryPointPcp (

	PDOBJ		pdobj,			/* (IN): dobj to query */
	PCPOINTUV	ppointuvQuery,	/* (IN): query point (uQuery,vQuery) */
	PCLSQIN		plsqin,			/* (IN): query input */
	PLSQOUT		plsqout)		/* (OUT): query output */
{
	/* REVIEW (antons): I changed logic of snapping; must be checked */

	/* The new version does not allow to come to open & close bracket */

	WDISPLAY * pwdisplay = & pdobj->wdisplay;
	WLAYOUT * pwlayout = & pdobj->wlayout;

	if (pwlayout->wsubline2.plssubl == NULL)
		{
		/* Only first subline ;-) */

		return CreateQueryResult (pwlayout->wsubline1.plssubl, 
								  pwdisplay->wdispsubl1.duvStart.u, 
								  pwdisplay->wdispsubl1.duvStart.v,
								  plsqin, plsqout );
		}
	else
		{
		/* Two sublines; snap according to v-point */

		long dvMiddle = 
			( pwdisplay->wdispsubl1.duvStart.v - pwlayout->wsubline1.objdim.heightsPres.dvDescent +
			  pwdisplay->wdispsubl2.duvStart.v + pwlayout->wsubline2.objdim.heightsPres.dvAscent ) / 2;

		/* dvMiddle is v-level which devides between first and second lines of Warichu */

		if (ppointuvQuery->v >= dvMiddle) 
			{
			/* Snapping to the first subline */

			return CreateQueryResult (pwlayout->wsubline1.plssubl, 
									  pwdisplay->wdispsubl1.duvStart.u, 
									  pwdisplay->wdispsubl1.duvStart.v,
									  plsqin, plsqout );
			}
		else
			{
			/* Snapping to the second subline */

			return CreateQueryResult (pwlayout->wsubline2.plssubl, 
									  pwdisplay->wdispsubl2.duvStart.u, 
									  pwdisplay->wdispsubl2.duvStart.v,
									  plsqin, plsqout );
			};

	}; /* if (pwlayout->wsubline2.plssubl == NULL) */

} /* WarichuQueryPointPcp */



/* W A R I C H U  Q U E R Y  C P  P P O I N T */
/*----------------------------------------------------------------------------
	%%Function: WarichuQueryCpPpoint
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI WarichuQueryCpPpoint(

		PDOBJ		pdobj,				/* (IN): dobj to query, */
		LSDCP		dcp,				/* (IN): dcp for the query */
		PCLSQIN		plsqin,				/* (IN): query input */
		PLSQOUT		plsqout)			/* (OUT): query output */
{

	/* REVIEW (antons): I changed logic of snapping; must be checked */

	WDISPLAY * pwdisplay = & pdobj->wdisplay;
	WLAYOUT	* pwlayout = & pdobj->wlayout;
	LSCP cpQuery = pdobj->cpStart + dcp;

	if (FOpenBraceInWLayout (pdobj, pwlayout) && 
		cpQuery < pwlayout->wsubline1.cpFirst)
		{
		/* Snap to the openning brace */

		return CreateQueryResult (pdobj->wbraceOpen.plssubl, 
								  pwdisplay->wdispbraceOpen.duvStart.u,
								  pwdisplay->wdispbraceOpen.duvStart.v,
								  plsqin, plsqout );
		}

	else if (FCloseBraceInWLayout (pdobj, pwlayout) && 
			 cpQuery >= pdobj->wbraceClose.cpFirst )
		 {
		/* Snap to the closing brace */

		return CreateQueryResult (pdobj->wbraceClose.plssubl, 
								  pwdisplay->wdispbraceClose.duvStart.u,
								  pwdisplay->wdispbraceClose.duvStart.v,
								  plsqin, plsqout );
		  }

	else if (pwlayout->wsubline2.plssubl == NULL)
		{
		/* Only first subline, snap to the first */

		return CreateQueryResult (pwlayout->wsubline1.plssubl, 
								  pwdisplay->wdispsubl1.duvStart.u, 
								  pwdisplay->wdispsubl1.duvStart.v,
								  plsqin, plsqout );
		}

	else if (cpQuery < pwlayout->wsubline2.cpFirst)
		{
		/* Snap to the first subline */

		return CreateQueryResult (pwlayout->wsubline1.plssubl, 
								  pwdisplay->wdispsubl1.duvStart.u, 
								  pwdisplay->wdispsubl1.duvStart.v,
								  plsqin, plsqout );
		}
	else
		{
		/* Snap to the second subline */

		return CreateQueryResult (pwlayout->wsubline2.plssubl, 
								  pwdisplay->wdispsubl2.duvStart.u, 
								  pwdisplay->wdispsubl2.duvStart.v,
								  plsqin, plsqout );
		};

} /* WarichuQueryPointPcp */


/* G E T  W A R I C H U  X Y  P O I N T S */
/*----------------------------------------------------------------------------
	%%Function: GetWarichuXYPoints
	%%Contact: antons


----------------------------------------------------------------------------*/

static void GetWarichuXYPoints (

		PDOBJ		pdobj, 
		const POINT	* ppt, 
		LSTFLOW		lstflow, 
		POINT		* pptOpen, 
		POINT		* pptFirst,
		POINT		* pptSecond,
		POINT		* pptClose )
{
	LSERR		lserr;

	WDISPLAY	* pwdisplay = & pdobj->wdisplay;
	WLAYOUT		* pwlayout = & pdobj->wlayout;

	/* REVIEW (antons): How they can not be equal */
	Assert (lstflow == pdobj->lstflowParent);

	/* OPEN BRACE */

	if (FOpenBraceInWLayout(pdobj, pwlayout))
		{
		lserr = LsPointXYFromPointUV (ppt, lstflow, 
									  & pwdisplay->wdispbraceOpen.duvStart, pptOpen);
		/* REVIEW (antons): Is it OK to have such asserts? */
		Assert (lserr == lserrNone);
		};

	/* FIRST SUBLINE */

	lserr = LsPointXYFromPointUV (ppt, lstflow, 
								  & pwdisplay->wdispsubl1.duvStart, pptFirst);
	Assert (lserr == lserrNone);

	/* SECIND SUBLINE */

	if (pwlayout->wsubline2.plssubl != NULL)
		{
		lserr = LsPointXYFromPointUV (ppt, lstflow, 
									  & pwdisplay->wdispsubl2.duvStart, pptSecond);
		Assert (lserr == lserrNone);
		};

	/* CLOSE BRACE */

	if (FCloseBraceInWLayout(pdobj, pwlayout))
		{
		lserr = LsPointXYFromPointUV (ppt, lstflow, 
									  & pwdisplay->wdispbraceClose.duvStart, pptClose);
		Assert (lserr == lserrNone);
		};

} /* GetWarichuXYPoints */


/* W A R I C H U  D I S P L A Y */
/*----------------------------------------------------------------------------
	%%Function: WarichuDisplay
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI WarichuDisplay (PDOBJ pdobj, PCDISPIN pcdispin)
{
	/* Now it is very elegant ;-) */

	WLAYOUT	 *pwlayout = & pdobj->wlayout;

	LSERR lserr;
	POINT ptOpen;
	POINT ptFirst;
	POINT ptSecond;
	POINT ptClose;

	GetWarichuXYPoints (pdobj, &pcdispin->ptPen, pcdispin->lstflow,
						& ptOpen, & ptFirst, & ptSecond, & ptClose );

	/* Printing open brace */

	if (FOpenBraceInWLayout(pdobj, pwlayout))
		{
		lserr = LsDisplaySubline (pdobj->wbraceOpen.plssubl, &ptOpen, 
								  pcdispin->kDispMode, pcdispin->prcClip);
		if (lserr != lserrNone) return lserr;
		};

	/* Printing 1st subline of Warichu */
	
	lserr = LsDisplaySubline (pwlayout->wsubline1.plssubl, &ptFirst, 
							  pcdispin->kDispMode, pcdispin->prcClip);
	if (lserr != lserrNone) return lserr;

	/* Printing 2nd subline of Warichu */

	if (pwlayout->wsubline2.plssubl != NULL)
		{
		lserr = LsDisplaySubline (pwlayout->wsubline2.plssubl, &ptSecond, 
							  pcdispin->kDispMode, pcdispin->prcClip);
		if (lserr != lserrNone) return lserr;
		}

	/* Printing close brace */

	if (FCloseBraceInWLayout(pdobj, pwlayout))
		{
		lserr = LsDisplaySubline (pdobj->wbraceClose.plssubl, &ptClose,
								  pcdispin->kDispMode, pcdispin->prcClip);
		if (lserr != lserrNone) return lserr;
		};

	return lserrNone;
}

/* W A R I C H U  D E S T R O Y  D O B J */
/*----------------------------------------------------------------------------
	%%Function: WarichuDestroyDobj
	%%Contact: antons

	
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuDestroyDobj (PDOBJ pdobj)
{
	/* REVIEW (antons): Should we eliminate this extra call? */

	return DestroyDobj (pdobj);
}


/* W A R I C H U E N U M */
/*----------------------------------------------------------------------------
	%%Function: WarichuEnum
	%%Contact: antons

	
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuEnum(
	PDOBJ pdobj,				/*(IN): dobj to enumerate */
	PLSRUN plsrun,				/*(IN): from DNODE */
	PCLSCHP plschp,				/*(IN): from DNODE */
	LSCP cp,					/*(IN): from DNODE */
	LSDCP dcp,					/*(IN): from DNODE */
	LSTFLOW lstflow,			/*(IN): text flow*/
	BOOL fReverse,				/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,		/*(IN): do we provide geometry ? */
	const POINT *pt,			/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,		/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun)				/*(IN): from DNODE, relevant iff fGeometryNeeded */
{
	POINT ptOpen;
	POINT ptClose;
	POINT ptFirst;
	POINT ptSecond;

	WLAYOUT * pwlayout = & pdobj->wlayout;
	WDISPLAY * pwdisplay = & pdobj->wdisplay;

	if (fGeometryNeeded)
		{
		GetWarichuXYPoints (pdobj, pt, lstflow, &ptOpen, &ptFirst, &ptSecond, &ptClose);
		}

	/* REVIEW (antons): Should we provide something like fOpenBrace & fCloseBrace */

	return pdobj->pilsobj->warichucbk.pfnWarichuEnum (
		
		pdobj->pilsobj->pols, 
		plsrun,	plschp, cp, dcp, 

		lstflow, fReverse, fGeometryNeeded, 

		pt,	pcheights, dupRun, 

		& ptOpen,  & pdobj->wbraceOpen. objdim.heightsPres, pwdisplay->wdispbraceOpen .dup,
		& ptClose, & pdobj->wbraceClose.objdim.heightsPres, pwdisplay->wdispbraceClose.dup,

		&ptFirst, & pwlayout->wsubline1.objdim.heightsPres, pwdisplay->wdispsubl1.dup,
		&ptSecond,& pwlayout->wsubline2.objdim.heightsPres, pwdisplay->wdispsubl2.dup,

		pdobj->wbraceOpen.plssubl,
		pdobj->wbraceClose.plssubl,
		pwlayout->wsubline1.plssubl,	
		pwlayout->wsubline2.plssubl );
}

/* G E T W A R I C H U L S I M E T H O D S */
/*----------------------------------------------------------------------------
	%%Function: GetWarichuLsimethods
	%%Contact: ricksa

		Get LSIMETHODS so client application can use Warichu object handler.
	
----------------------------------------------------------------------------*/
LSERR WINAPI LsGetWarichuLsimethods (LSIMETHODS *plsim)
{
	plsim->pfnCreateILSObj = WarichuCreateILSObj;
	plsim->pfnDestroyILSObj = WarichuDestroyILSObj;
	plsim->pfnSetDoc = WarichuSetDoc;
	plsim->pfnCreateLNObj = WarichuCreateLNObj;
	plsim->pfnDestroyLNObj = WarichuDestroyLNObj;
	plsim->pfnFmt = WarichuFmt;
	plsim->pfnFmtResume = WarichuFmtResume; 
	plsim->pfnGetModWidthPrecedingChar = WarichuGetModWidthPrecedingChar;
	plsim->pfnGetModWidthFollowingChar = WarichuGetModWidthFollowingChar;
	plsim->pfnTruncateChunk = WarichuTruncateChunk;
	plsim->pfnFindPrevBreakChunk = WarichuFindPrevBreakChunk;
	plsim->pfnFindNextBreakChunk = WarichuFindNextBreakChunk;
	plsim->pfnForceBreakChunk = WarichuForceBreakChunk;
	plsim->pfnSetBreak = WarichuSetBreak;
	plsim->pfnGetSpecialEffectsInside = WarichuGetSpecialEffectsInside;
	plsim->pfnFExpandWithPrecedingChar = ObjHelpFExpandWithPrecedingChar;
	plsim->pfnFExpandWithFollowingChar = ObjHelpFExpandWithFollowingChar;
	plsim->pfnCalcPresentation = WarichuCalcPresentation;
	plsim->pfnQueryPointPcp = WarichuQueryPointPcp;
	plsim->pfnQueryCpPpoint = WarichuQueryCpPpoint;
	plsim->pfnDisplay = WarichuDisplay;
	plsim->pfnDestroyDObj = WarichuDestroyDobj;
	plsim->pfnEnum = WarichuEnum;

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\cmsgflt.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	CMSGFLT.CPP	-- Text Message Implementation |
 *	
 *		Most everything to do with IME message handling.
 *
 *	Original Author: <nl>
 *		Hon Wah Chan
 *
 *	History: <nl>
 *		2/6/98  v-honwch
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "_cmsgflt.h"
#include "_ime.h"

#define MAX_RECONVERSION_SIZE 100
#define CONTROL(_ch) (_ch - 'A' + 1)

/*
 *	void CreateIMEMessageFilter(ITextMsgFilter **ppMsgFilter)
 *
 *	@func
 *		TextMsgFilter class factory.
 */       
void CreateIMEMessageFilter(ITextMsgFilter **ppMsgFilter)
{
	CTextMsgFilter *pNewFilter = new CTextMsgFilter;
	*ppMsgFilter = pNewFilter ? pNewFilter : NULL;
}

/*
 *	void CTextMsgFilter::~CTextMsgFilter
 *
 *	@mfunc
 *		CTextMsgFilter Destructor
 *			Release objects being used.
 *		
 */
CTextMsgFilter::~CTextMsgFilter ()
{
	if (_hIMCContext)
		ImmAssociateContext(_hwnd, _hIMCContext, _fUsingAIMM);	// Restore IME before exit

	// Release various objects 
	if (_fUsingAIMM)		
		DeactivateAIMM();

	if (_pFilter)
		_pFilter->Release();
	
	if (_pTextSel)
		_pTextSel->Release();
	
	_pFilter = NULL;
	_pTextDoc = NULL;
	_pTextSel = NULL;
	_hwnd = NULL;
	_hIMCContext = NULL;

}

/*
 *	STDMETHODIMP CTextMsgFilter::QueryInterface (riid, ppv)
 *
 *	@mfunc
 *		IUnknown QueryInterface support
 *
 *	@rdesc
 *		NOERROR if interface supported
 *
 */
STDMETHODIMP CTextMsgFilter::QueryInterface (REFIID riid, void ** ppv)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CTextMsgFilter::QueryInterface");

	if( IsEqualIID(riid, IID_IUnknown) )
	{
		*ppv = (IUnknown *)this;
	}
	else if( IsEqualIID(riid, IID_ITextMsgFilter) )
	{
		*ppv = (ITextMsgFilter *)this;
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();

	return NOERROR;
}

/*
 *	STDMETHODIMP_(ULONG) CTextMsgFilter::AddRef
 *
 *	@mfunc
 *		IUnknown AddRef support
 *
 *	@rdesc
 *		Reference count
 */
STDMETHODIMP_(ULONG) CTextMsgFilter::AddRef()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::AddRef");

	return ++_crefs;
}

/*
 *	STDMETHODIMP_(ULONG) CTextMsgFilter::Release()
 *
 *	@mfunc
 *		IUnknown Release support - delete object when reference count is 0
 *
 *	@rdesc
 *		Reference count
 */
STDMETHODIMP_(ULONG) CTextMsgFilter::Release()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CTextMsgFilter::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	STDMETHODIMP_(HRESULT) CTextMsgFilter::AttachDocument(HWND, ITextDocument2)
 *
 *	@mfunc
 *		Attach message filter. Perform genral initialization
 *
 *	@rdesc
 *		NOERROR
 */
STDMETHODIMP_(HRESULT) CTextMsgFilter::AttachDocument( HWND hwnd, ITextDocument2 *pTextDoc)
{
	HRESULT hResult; 

	// Cache the values for possible later use.
	// The TextDocument interface pointer is not AddRefed because it is a back pointer
	// and the lifetime of message filters is assumed to be nested inside text documents	
	_hwnd = hwnd;
	_pTextDoc = pTextDoc;

	// Don't get selection until it is needed
	_pTextSel = NULL;

	_fUnicodeWindow = 0;	
	if (hwnd)
		_fUnicodeWindow = IsWindowUnicode(hwnd);

	_fUsingAIMM = 0; 
	// We will activate AIMM if it has been loaded by previous instances
	// NOTE: we don't support AIMM for windowless mode.
	if (_hwnd && IsAIMMLoaded())
	{
		// activate AIMM
		hResult = ActivateAIMM(FALSE);

		if (hResult == NOERROR)
		{
			DWORD	dwAtom;
			ATOM	aClass;

			// filter client windows
			if (dwAtom = GetClassLong(hwnd, GCW_ATOM))
			{
				aClass = dwAtom;				
				hResult = FilterClientWindowsAIMM(&aClass, 1);
			}
			_fUsingAIMM = 1;
		}
	}

	// Check if current keyboard is MSIME98 or later.
	CheckIMEType(NULL);

	// Initialize some member data
	_fHangulToHanja = FALSE;
	_fIMECancelComplete = FALSE;	
	_fIMEAlwaysNotify = FALSE;
	_hIMCContext = NULL;

	_pTextDoc->GetFEFlags(&_lFEFlags);
	_fRE10Mode = (_lFEFlags & tomRE10Mode);

	// For 1.0 mode IME color 
	memset(_crComp, 0, sizeof(_crComp));
	_crComp[0].crBackground = 0x0ffffff;
	_crComp[0].dwEffects = CFE_UNDERLINE;
	_crComp[1].crBackground = 0x0808080;
	_crComp[2].crBackground = 0x0ffffff;
	_crComp[2].dwEffects = CFE_UNDERLINE;
	_crComp[3].crText = 0x0ffffff;


	_uSystemCodePage = GetACP();

	return NOERROR;
}

/*
 *	STDMETHODIMP_(HRESULT) CTextMsgFilter::HandleMessage(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Main Message filter message loop handling
 *
 *	@rdesc
 *		S_OK		if we have handled the message
 *		S_FALSE		if we want the caller to process the message
 */
STDMETHODIMP_(HRESULT) CTextMsgFilter::HandleMessage( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres)
{
	HRESULT hr = S_FALSE;
	BOOL	bReleaseSelction = FALSE;
	HRESULT hResult;

	// Give other message filters a chance to handle message
	// Stop with the first guy that handles the message
	if (_pFilter)	 
		hr = _pFilter->HandleMessage(pmsg, pwparam, plparam, plres);

	if (hr == S_OK)
		return hr;

 	if (IsIMEComposition())
	{
		// During IME Composition, there are some messages we should
		// not handle.  Also, there are other messages we need to handle by
		// terminating the IME composition first.
		// For WM_KEYDOWN, this is handled inside edit.c OnTxKeyDown().
		switch( *pmsg )
		{
			case WM_COPY:
			case WM_CUT:
			case WM_DROPFILES:
			case EM_REDO:
			case EM_SETCHARFORMAT:			
			case WM_SETFONT:
				return S_OK;					// Just ignore these

			
			case EM_UNDO:
			case WM_UNDO:
				// just terminate and exist for undo cases
				_ime->TerminateIMEComposition(*this, CIme::TERMINATE_NORMAL);
				return S_OK;

			case WM_SETTEXT:
			case WM_CLEAR:
			case EM_STREAMIN:
				// these messages are used to reset our state, so reset
				// IME as well
				_ime->TerminateIMEComposition(*this, CIme::TERMINATE_FORCECANCEL);
				break;

			case EM_SETTEXTEX:
				if (!_fRE10Mode)			// Don't terminate if running in 10 mode			
					_ime->TerminateIMEComposition(*this, CIme::TERMINATE_FORCECANCEL);
				break;

			case WM_SYSKEYDOWN:
				// Don't terminate IME composition on VK_PROCESSKEY (F10) since Japanese 
				// IME will process the F10 key
				if ( *pwparam == VK_PROCESSKEY )
					break;
				// otherwise we want to terminate the IME

			case EM_SETWORDBREAKPROC:
 			case WM_PASTE:
			case EM_PASTESPECIAL:					  			
 			case EM_SCROLL:
			case EM_SCROLLCARET:
 			case WM_VSCROLL:
			case WM_HSCROLL:
			case WM_KILLFOCUS:
			case EM_STREAMOUT:
			case EM_SETREADONLY:
 			case EM_SETSEL:
			case EM_SETPARAFORMAT:
			case WM_INPUTLANGCHANGEREQUEST:	
				_ime->TerminateIMEComposition(*this, CIme::TERMINATE_NORMAL);
				break;

			case WM_KEYDOWN:
				if(GetKeyState(VK_CONTROL) & 0x8000)
				{	
					// During IME Composition, there are some key events we should
					// not handle.  Also, there are other key events we need to handle by
					// terminating the IME composition first.			
					switch((WORD) *pwparam)
					{
					case VK_TAB:
		   			case VK_CLEAR:
					case VK_NUMPAD5:
					case 'A':						// Ctrl-A => select all
					case 'C':						// Ctrl-C => copy
					case 'X':						// Ctrl-X => cut
					case 'Y':						// Ctrl-Y => redo
						return S_OK;				// Just ignore these

					case 'V':						// Ctrl-V => paste
					case 'Z':						// Ctrl-Z => undo	
						_ime->TerminateIMEComposition(*this, CIme::TERMINATE_NORMAL);						
						if ((WORD) *pwparam == 'Z')	// Early exist for undo case
							return S_OK;
					}
				}
				else
				{
					switch((WORD) *pwparam)
					{					
					case VK_F16:
						return S_OK;				// Just ignore these
					
					case VK_BACK:
					case VK_INSERT:					// Ins			
					case VK_LEFT:					// Left arrow
					case VK_RIGHT:					// Right arrow
					case VK_UP:						// Up arrow
					case VK_DOWN:					// Down arrow
					case VK_HOME:					// Home
					case VK_END:					// End
					case VK_PRIOR:					// PgUp
					case VK_NEXT:					// PgDn
					case VK_DELETE:					// Del
					case CONTROL('J'):
					case VK_RETURN:
						_ime->TerminateIMEComposition(*this, CIme::TERMINATE_NORMAL);
						break;
					}
				}
				break;

			default:
				// only need to handle mouse related msgs during composition
				if (IN_RANGE(WM_MOUSEFIRST, *pmsg, WM_MBUTTONDBLCLK) || *pmsg == WM_SETCURSOR)
				{
					bReleaseSelction = GetTxSelection();
					if (_pTextSel)
						hr = IMEMouseCheck( *this, pmsg, pwparam, plparam, plres);
					goto Exit;
				}				
		}
	}

	// Get Fe Flags for ES_NOIME or ES_SELFIME setting
	_lFEFlags = 0;

	// ... Local mucking with msg, params, etc, ...
	switch ( *pmsg )
	{
		case WM_CHAR:
			hr = OnWMChar (pmsg, pwparam, plparam, plres);
			break;

		case WM_IME_CHAR:
			_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if ((_lFEFlags & ES_NOIME))
				hr = S_OK;
			else
				hr = OnWMIMEChar (pmsg, pwparam, plparam, plres);
			break;
		
		case WM_IME_STARTCOMPOSITION:
			_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & ES_SELFIME))
			{				
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
					hr = StartCompositionGlue (*this);
			}
			break;

		case WM_IME_COMPOSITION:
			_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			
			if ((_lFEFlags & ES_NOIME) && !IsIMEComposition())
				hr = S_OK;			
			else if (!(_lFEFlags & ES_SELFIME))
			{
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
				{
					hr = CompositionStringGlue ( *plparam, *this );
					// Turn off Result string bit to avoid WM_IME_CHAR message.
					*plparam &= ~GCS_RESULTSTR;
				}
			}

			if (_hwnd && IsIMEComposition() && _ime->IgnoreIMECharMsg())
			{
				_ime->AcceptIMECharMsg();
				if (fHaveAIMM)
					hr = CallAIMMDefaultWndProc(_hwnd, *pmsg, *pwparam, *plparam, plres);
				else
					*plres = ::DefWindowProc(_hwnd, *pmsg, *pwparam, *plparam);				

				hr = S_OK;
			}

			break;

		case WM_IME_ENDCOMPOSITION:
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & ES_SELFIME))
			{			
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
					hr = EndCompositionGlue ( *this, FALSE );
			}
			break;

		case WM_IME_NOTIFY:
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
			{
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)			
					hr = IMENotifyGlue ( *pwparam, *plparam, *this );
			}
			break;

		case WM_IME_COMPOSITIONFULL:	// Level 2 comp string about to overflow.
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & ES_SELFIME))
			{
				IMECompositionFull ( *this );
			}
			hr = S_FALSE;
			break;

		case WM_KEYDOWN:
			
			bReleaseSelction = GetTxSelection();
			if (_pTextSel)
			{
				if (*pwparam == VK_KANJI)
				{
					hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
					
					_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
					// for Korean, need to convert the next Korean Hangul character to Hanja
					if(CP_KOREAN == _uKeyBoardCodePage && !(_lFEFlags & (ES_SELFIME | ES_NOIME)))
						hr = IMEHangeulToHanja ( *this );
				}
			}
			break;

		case WM_INPUTLANGCHANGE: 
			CheckIMEType((HKL)*plparam);
			hr = S_FALSE;
			break;

		case WM_KILLFOCUS:
			OnKillFocus();
			break;
		
		case WM_SETFOCUS:
			OnSetFocus();
			break;

		case EM_SETIMEOPTIONS:
			*plres = OnSetIMEOptions(*pwparam, *plparam);
			hr = S_OK;
			break;

		case EM_GETIMEOPTIONS:
			*plres = OnGetIMEOptions();
			hr = S_OK;
			break;

		case WM_IME_REQUEST:
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
			{				
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
				{
					_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
					if (*pwparam == IMR_RECONVERTSTRING || *pwparam == IMR_CONFIRMRECONVERTSTRING
						|| *pwparam == IMR_DOCUMENTFEED)			
						hr = OnIMEReconvert(pmsg, pwparam, plparam, plres, _fUnicodeWindow);	
					else if (*pwparam == IMR_QUERYCHARPOSITION)
						hr = OnIMEQueryPos(pmsg, pwparam, plparam, plres, _fUnicodeWindow);
				}				
			}
			break;

		case EM_RECONVERSION:
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
			{
				// Application initiates reconversion
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
				{
					if (!IsIMEComposition())
					{
						if (_fMSIME && MSIMEReconvertRequestMsg)
							// Use private message if it is available
							IMEMessage( *this, MSIMEReconvertRequestMsg, 0, (LPARAM)_hwnd, TRUE );				
						else
						{
							hr = OnIMEReconvert(pmsg, pwparam, plparam, plres, TRUE);							
							*plres = 0;
						}
					}
				}
			}
			hr = S_OK;
			break;

		case EM_SETLANGOPTIONS:
			// Setup IME related setting.
			// hr is not S_OK so textserv could handle other language setting
			_fIMEAlwaysNotify = (*plparam & IMF_IMEALWAYSSENDNOTIFY) != 0;
			_fIMECancelComplete = (*plparam & IMF_IMECANCELCOMPLETE) != 0;
			*plres = 1;
			break;

		case EM_GETLANGOPTIONS:
			// Report IME related setting.
			// hr is not S_OK so textserv could fill in other language setting
			if ( _fIMECancelComplete ) 
				*plres |= IMF_IMECANCELCOMPLETE;
			if ( _fIMEAlwaysNotify )
				*plres |= IMF_IMEALWAYSSENDNOTIFY;
			break;

		case EM_GETIMECOMPMODE:
			// Get current IME level
			*plres = OnGetIMECompositionMode( *this );
			hr = S_OK;
			break;

		case EM_SETEDITSTYLE:							
			if (*pwparam & SES_USEAIMM)
			{
				if (_hwnd && !_fUsingAIMM && LoadAIMM())
				{
					hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
					if (!(_lFEFlags & ES_NOIME))			// No IME style on?
					{
						// activate AIMM
						hResult = ActivateAIMM(FALSE);

						if (hResult == NOERROR)
						{
							DWORD	dwAtom;
							ATOM	aClass;

							// filter client windows
							if (dwAtom = GetClassLong(_hwnd, GCW_ATOM))
							{
								aClass = dwAtom;				
								hResult = FilterClientWindowsAIMM(&aClass, 1);
							}
							_fUsingAIMM = 1;
						}
					}
				}
			}
			if ((*plparam == 0 || *plparam & SES_NOIME) && _hwnd)
			{
				if (*pwparam & SES_NOIME)
				{
					if (!_hIMCContext)
						_hIMCContext = ImmAssociateContext(_hwnd, NULL, _fUsingAIMM);	// turn off IME									
				}
				else if (*plparam & SES_NOIME)
				{
					if (_hIMCContext)
						ImmAssociateContext(_hwnd, _hIMCContext, _fUsingAIMM);			// turn on IME
					_hIMCContext = NULL;
				}
			}			

			// remove settings that are handled.
			*pwparam &= ~(SES_NOIME | SES_USEAIMM);
			*plparam &= ~(SES_NOIME | SES_USEAIMM);

			// fall thru to return the edit style

		case EM_GETEDITSTYLE:
			if (_hIMCContext)
				*plres = SES_NOIME;			// IME has been turned off
			if (_fUsingAIMM)
				*plres |= SES_USEAIMM;		// AIMM is on

			break;

		case EM_SETIMECOLOR:
			if (_fRE10Mode)
			{
				memcpy(&_crComp, (const void *)(*plparam), sizeof(_crComp));
				*plres = 1;
			}
			hr = S_OK;
			break;

		case EM_GETIMECOLOR:
			if (_fRE10Mode)
			{
				memcpy((void *)(*plparam), &_crComp, sizeof(_crComp));
				*plres = 1;
			}
			hr = S_OK;
			break;

		default:
			if (*pmsg)
			{
				// Look for IME98 private messages
				if (*pmsg == MSIMEReconvertMsg || *pmsg == MSIMEDocFeedMsg
					|| *pmsg == MSIMEQueryPositionMsg)
				{
					hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
					if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
					{
						bReleaseSelction = GetTxSelection();
						if (_pTextSel)
						{
							if (*pmsg == MSIMEQueryPositionMsg)
								hr = OnIMEQueryPos(pmsg, pwparam, plparam, plres, TRUE);
							else
								hr = OnIMEReconvert(pmsg, pwparam, plparam, plres, TRUE);
						}
					}
				}
			}
			break;
	}

Exit:
	// Release Selection if we get it for this message
	if (bReleaseSelction && _pTextSel)
	{
		_pTextSel->Release();
		_pTextSel = NULL;
	}

	// Return the value that will cause message to be processed normally
	return hr;
}

/*
 *	HRESULT CTextMsgFilter::AttachMsgFilter(ITextMsgFilter *)
 *
 *	@mfunc
 *		Add another message filter to the chain
 *
 *	@rdesc
 *		NOERROR if added
 */
HRESULT STDMETHODCALLTYPE CTextMsgFilter::AttachMsgFilter( ITextMsgFilter *pMsgFilter)
{
	HRESULT hr = NOERROR;
	if (_pFilter)
		hr = _pFilter->AttachMsgFilter( pMsgFilter );
	else
	{
		_pFilter = pMsgFilter;
		_pFilter->AddRef();
	}
	return hr;
}

/*
 *	HRESULT CTextMsgFilter::OnWMChar(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Handle WM_CHAR message - look for Japanese keyboard with Kana key on
 *		Convert the SB Kana to Unicode if needed.
 *
 *	@rdesc
 *		S_FALSE so caller will handle the modified character in wparam
 */
HRESULT CTextMsgFilter::OnWMChar( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres)
{
	// For Japanese keyboard, if Kana mode is on,
	// Kana characters (single byte Japanese chars) are coming in via WM_CHAR.
	if ( GetKeyState(VK_KANA) & 0x1 )
	{
		_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);

		if (_uKeyBoardCodePage == CP_JAPAN)
		{
			// check if this is a single byte character.
 			TCHAR	unicodeConvert;
			BYTE	bytes[2];
			bytes[0] = (BYTE)(*pwparam >> 8);	// Interchange DBCS bytes in endian
			bytes[1] = (BYTE)*pwparam;			// independent fashion (use byte array)

			if (!bytes[0])
			{
				if(UnicodeFromMbcs((LPWSTR)&unicodeConvert, 1, 
					(LPCSTR)&bytes[1], 1, _uKeyBoardCodePage) == 1)
					*pwparam = unicodeConvert;
			}
			
			return InputFEChar(*pwparam);
		}
	}

	return S_FALSE;
}

/*
 *	HRESULT CTextMsgFilter::OnWMIMEChar(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Handle WM_IMECHAR message - convert the character to unicode.
 *
 *	@rdesc
 *		S_OK - caller to ignore the message
 *		S_FALSE - caller to handle the message.  wparam may contains a new char
 */
HRESULT CTextMsgFilter::OnWMIMEChar( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres)
{
	TCHAR	unicodeConvert;
	BYTE	bytes[2];

	// We may receive IMECHAR even if we have handled the composition char already.
	// This is the case when the host does not call the DefWinProc with the composition
	// bit masked off.  So, we need to ignore this message to avoid double entry.
	if (IsIMEComposition() && _ime->IgnoreIMECharMsg())
	{
		_ime->SkipIMECharMsg();		// Skip this ime char msg
		return S_OK;	
	}

	bytes[0] = *pwparam >> 8;		// Interchange DBCS bytes in endian
	bytes[1] = *pwparam;			// independent fashion (use byte array)
	
	// need to convert both single-byte KANA and DBC
	if (!bytes[0] || GetTrailBytesCount(bytes[0], _uKeyBoardCodePage))
	{
		if( UnicodeFromMbcs((LPWSTR)&unicodeConvert, 1, 
			bytes[0] == 0 ? (LPCSTR)&bytes[1] : (LPCSTR)bytes,
			bytes[0] == 0 ? 1 : 2,
			_uKeyBoardCodePage) == 1 )
			*pwparam = unicodeConvert;

		return InputFEChar(*pwparam);
	}

	return S_FALSE;
}

/*
 *	HRESULT CTextMsgFilter::OnIMEReconvert(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Handle IME Reconversion and Document feed. We only handle Unicode messages.
 *		We use a limit of MAX_RECONVERSION_SIZE(100) characters in both cases.
 *
 *	@rdesc
 *		S_OK		if we have handled the message
 */
HRESULT CTextMsgFilter::OnIMEReconvert( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres,
		BOOL		fUnicode)
{
	HRESULT		hr = S_OK;
	LPRECONVERTSTRING lpRCS = (LPRECONVERTSTRING)(*plparam);
	long		cbStringSize;
	long		cpMin, cpMax;
	long		cpParaStart, cpParaEnd;
	HRESULT		hResult;
	ITextRange *pTextRange, *pTempTextRange;
	long		cbAdded;				
	BOOL		bDocumentFeed;
	long		cLastChar;
	BOOL		fAdjustedRange = FALSE;

	*plres = 0;

	// NT doesn't support Ansi window when the CP_ACP isn't the same
	// as keyboard codepage.
	if (!fUnicode && !(W32->OnWin9x()) && _uKeyBoardCodePage != _uSystemCodePage)
		return S_OK;

	bDocumentFeed = (MSIMEDocFeedMsg && *pmsg == MSIMEDocFeedMsg)
					|| (*pmsg == WM_IME_REQUEST && *pwparam == IMR_DOCUMENTFEED);

	if (bDocumentFeed && IsIMEComposition() && _ime->GetIMELevel() == IME_LEVEL_3)
	{
		// Composition in progress, use composition string as selection
		cpMin = ((CIme_Lev3 *)_ime)->GetIMECompositionStart();
		cpMax = ((CIme_Lev3 *)_ime)->GetIMECompositionLen() + cpMin;
	}
	else
	{
		// Get current selection
		hResult	= _pTextSel->GetStart(&cpMin);
		hResult	= _pTextSel->GetEnd(&cpMax);
	}

	// Expand to include the current paragraph
	hResult = _pTextDoc->Range(cpMin, cpMax, &pTextRange);
	Assert (pTextRange != NULL);
	if (hResult != NOERROR)
		return S_OK;

	hResult = pTextRange->Expand(tomParagraph, &cbAdded);

	// Fail to get Paragraph, get the story
	// Note:- Expand will return S_FALSE for plain text when
	// the whole story is selected
	if (hResult != NOERROR)		
		hResult = pTextRange->Expand(tomStory, &cbAdded);

	hResult = pTextRange->GetStart(&cpParaStart);
	hResult = pTextRange->GetEnd(&cpParaEnd);

	if (*pwparam == IMR_CONFIRMRECONVERTSTRING)
	{
		*plres = CheckIMEChange(lpRCS, cpParaStart, cpParaEnd, cpMin, cpMax, fUnicode);		
		goto Exit;
	}
		
	// Initialize to hugh number
	_cpReconvertStart = tomForward;

	// Check if Par included	
	hResult = _pTextDoc->Range(cpParaEnd-1, cpParaEnd, &pTempTextRange);
	if (hResult != NOERROR)
		goto Exit;
	Assert (pTempTextRange != NULL);

	hResult	= pTempTextRange->GetChar(&cLastChar);
	pTempTextRange->Release();

	if (hResult == NOERROR && (WCHAR)cLastChar == CR)
	{
		if (cpMax == cpParaEnd)
		{								
			// Par is selected, change selection to exclude the par char
			cpMax--;
			_pTextSel->SetEnd(cpMax);

			if (cpMin > cpMax)
			{
				// Adjust cpMin as well
				cpMin = cpMax;
				_pTextSel->SetStart(cpMin);
			}
		}

		// Get rid of par char 
		cpParaEnd--;
		fAdjustedRange = TRUE;
	}

	// Check for MAX_RECONVERSION_SIZE since we don't want to pass a hugh buffer
	// to IME
	long	cchSelected;

	cchSelected = cpMax - cpMin;
	if (cpParaEnd - cpParaStart > MAX_RECONVERSION_SIZE)
	{
		// Too many character selected, forget it
		if (cchSelected > MAX_RECONVERSION_SIZE)
			goto Exit;

		if (cchSelected == MAX_RECONVERSION_SIZE)
		{
			// Selection reaches the limit
			cpParaStart = cpMin;
			cpParaEnd = cpMax;
		}
		else
		{
			long	cchBeforeSelection = cpMin - cpParaStart;
			long	cchAfterSelection = cpParaEnd - cpMax;
			long	cchNeeded = MAX_RECONVERSION_SIZE - cchSelected;
			
			if (cchBeforeSelection < cchNeeded/2)
			{
				// Put in all characters from the Par start
				// and move Par end
				cpParaEnd = cpParaStart + MAX_RECONVERSION_SIZE - 1;
			}
			else if (cchAfterSelection < cchNeeded/2)
			{
				// Put in all character to the Par end
				// and move Par start
				cpParaStart = cpParaEnd - MAX_RECONVERSION_SIZE + 1;

			}
			else
			{
				// Adjust both end
				cpParaStart = cpMin - cchNeeded/2;
				cpParaEnd = cpParaStart + MAX_RECONVERSION_SIZE - 1;
			}
		}
		fAdjustedRange = TRUE;
	}

	if (fAdjustedRange)
	{
		// Adjust the text range
		hResult	= pTextRange->SetRange(cpParaStart, cpParaEnd);
		
		if (hResult != NOERROR)
			goto Exit;
	}

	cbStringSize = (cpParaEnd - cpParaStart) * 2;

	// No char in current par, forget it.
	if (cbStringSize <= 0)
		goto Exit;

	if (EM_RECONVERSION == *pmsg)
	{
		// RE reconversion msg, allocate the Reconversion buffer
		lpRCS = (LPRECONVERTSTRING) PvAlloc(sizeof(RECONVERTSTRING) + cbStringSize + 2, GMEM_ZEROINIT);
		Assert(lpRCS != NULL);

		if (lpRCS)
			lpRCS->dwSize = sizeof(RECONVERTSTRING) + cbStringSize + 2;
	}

	if (lpRCS)
	{
		BSTR		bstr = NULL;
		LPSTR		lpReconvertBuff;

		hResult = pTextRange->GetText(&bstr);

		if (hResult != NOERROR || bstr == NULL)
		{
			if (EM_RECONVERSION == *pmsg)
				FreePv(lpRCS);
			goto Exit;						// forget it		
		}
		
		if (lpRCS->dwSize - sizeof(RECONVERTSTRING) - 2 < (DWORD)cbStringSize)
			cbStringSize = lpRCS->dwSize - sizeof(RECONVERTSTRING) - 2;
		
		lpReconvertBuff = (LPSTR)(lpRCS) + sizeof(RECONVERTSTRING);

		if (fUnicode)
		{
			// fill in the buffer
			memcpy(lpReconvertBuff, (LPSTR)bstr, cbStringSize);

			*(lpReconvertBuff+cbStringSize) = '\0';
			*(lpReconvertBuff+cbStringSize+1) = '\0';
			
			lpRCS->dwStrLen = (cpParaEnd - cpParaStart);					
			lpRCS->dwCompStrLen = (cpMax - cpMin);
			lpRCS->dwCompStrOffset = (cpMin - cpParaStart)*2;	// byte offset from beginning of string
		}
		else
		{
			// Ansi case, need to find byte offset and Ansi string
			long	cch = WideCharToMultiByte(_uKeyBoardCodePage, 0, bstr, -1, lpReconvertBuff, cbStringSize+1, NULL, NULL);
			Assert (cch > 0);
			if (cch > 0)
			{
				CTempCharBuf tcb;
				char *psz = tcb.GetBuf(cch);

				if (cch > 1 && lpReconvertBuff[cch-1] == '\0')
					cch--;			// Get rid of the null char

				lpRCS->dwStrLen = cch;
				lpRCS->dwCompStrOffset = WideCharToMultiByte(_uKeyBoardCodePage, 0, 
					bstr, cpMin - cpParaStart, psz, cch, NULL, NULL);
				
				lpRCS->dwCompStrLen = 0;
				if (cpMax > cpMin)				
					lpRCS->dwCompStrLen = WideCharToMultiByte(_uKeyBoardCodePage, 0, 
						bstr+cpMin, cpMax - cpMin, psz, cch, NULL, NULL);				
			}
			else
			{
				SysFreeString (bstr);
				if (EM_RECONVERSION == *pmsg)
					FreePv(lpRCS);
				goto Exit;						// forget it
			}
		}

		// Fill in the rest of the RCS struct
		lpRCS->dwVersion = 0;		
		lpRCS->dwStrOffset = sizeof(RECONVERTSTRING);		// byte offset from beginning of struct		
		lpRCS->dwTargetStrLen = lpRCS->dwCompStrLen;
		lpRCS->dwTargetStrOffset = lpRCS->dwCompStrOffset;
		
		*plres = sizeof(RECONVERTSTRING) + cbStringSize + 2;

		// Save this for the CONFIRMRECONVERTSTRING handling
		_cpReconvertStart = cpParaStart;
		_cpReconvertEnd = cpParaEnd;
		
		SysFreeString (bstr);

		if (EM_RECONVERSION == *pmsg)
		{
			HIMC	hIMC = ImmGetContext(_hwnd);

			if (hIMC)
			{
				DWORD imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_SETCOMPSTR, _fUsingAIMM);

				if ((imeProperties & (SCS_CAP_SETRECONVERTSTRING | SCS_CAP_MAKEREAD))
					== (SCS_CAP_SETRECONVERTSTRING | SCS_CAP_MAKEREAD))
				{
					if (ImmSetCompositionStringW(hIMC, SCS_QUERYRECONVERTSTRING, lpRCS, *plres, NULL, 0))
					{
						// Check if there is any change in selection
						CheckIMEChange(lpRCS, cpParaStart, cpParaEnd, cpMin, cpMax, TRUE);
						ImmSetCompositionStringW(hIMC, SCS_SETRECONVERTSTRING, lpRCS, *plres, NULL, 0);
					}
				}
				ImmReleaseContext(_hwnd, hIMC);
			}

			FreePv(lpRCS);
		}
	}
	else
	{
		// return size for IME to allocate the buffer
		*plres = sizeof(RECONVERTSTRING) + cbStringSize + 2;	
	}

Exit:
	pTextRange->Release();

	return hr;
}

/* 
 *  BOOL  CTextMsgFilter::CheckIMEChange(LPRECONVERTSTRING,long,long,long,long)
 *
 *	@mfunc
 *	 	Verify if IME wants to re-adjust the selection
 *
 *	@rdesc
 *		TRUE - allow IME to change the selection
 */
BOOL  CTextMsgFilter::CheckIMEChange(
	LPRECONVERTSTRING	lpRCS,
	long				cpParaStart, 
	long				cpParaEnd,
	long				cpMin,
	long				cpMax,
	BOOL				fUnicode)
{
	long		cpImeSelectStart = 0;
	long		cpImeSelectEnd = 0;
	HRESULT		hResult;	

	if (!lpRCS || _cpReconvertStart == tomForward)
		// Never initialize, forget it
		return FALSE;

	if (fUnicode)
	{
		cpImeSelectStart = _cpReconvertStart + lpRCS->dwCompStrOffset / 2;
		cpImeSelectEnd = cpImeSelectStart + lpRCS->dwCompStrLen;
	}
	else
	{
		// Need to convert the byte offset to char offset.
		ITextRange *pTextRange;
		BSTR		bstr = NULL;

		hResult = _pTextDoc->Range(_cpReconvertStart, _cpReconvertEnd, &pTextRange);
		if (hResult != NOERROR)
			return FALSE;
				
		// Get the text
		hResult = pTextRange->GetText(&bstr);

		if (hResult == S_OK)
		{
			long	cchReconvert = _cpReconvertEnd - _cpReconvertStart + 1;
			CTempCharBuf tcb;
			char *psz = tcb.GetBuf((cchReconvert)*2);
			long cch = WideCharToMultiByte(_uKeyBoardCodePage, 0, 
				bstr, -1, psz, (cchReconvert)*2, NULL, NULL);

			if (cch > 0)
			{
				long dwCompStrOffset, dwCompStrLen;
				CTempWcharBuf	twcb;
				WCHAR			*pwsz = twcb.GetBuf(cchReconvert);

				dwCompStrOffset = MultiByteToWideChar(_uKeyBoardCodePage, 0, 
					psz, lpRCS->dwCompStrOffset, pwsz, cchReconvert);

				dwCompStrLen = MultiByteToWideChar(_uKeyBoardCodePage, 0, 
					psz+lpRCS->dwCompStrOffset, lpRCS->dwCompStrLen, pwsz, cchReconvert);
				
				Assert(dwCompStrOffset > 0 || dwCompStrLen > 0);

				cpImeSelectStart = _cpReconvertStart + dwCompStrOffset;
				cpImeSelectEnd = cpImeSelectStart + dwCompStrLen;
			}
			else
				hResult = S_FALSE;
			
		}

		if (bstr)
			SysFreeString (bstr);
			
		pTextRange->Release();

		if (hResult != S_OK)
			return FALSE;
	}

	if (cpParaStart <= cpImeSelectStart && cpImeSelectEnd <= cpParaEnd)
	{
		if (_pTextSel && (cpImeSelectStart != cpMin || cpImeSelectEnd != cpMax))
		{
			// IME changes selection.
			hResult	= _pTextSel->SetRange(cpImeSelectStart, cpImeSelectEnd);

			if (hResult != NOERROR)
				return FALSE;
		}
		return TRUE;		// Allow Ime to change selection
	}

	return FALSE;
}

/* 
 *  BOOL  CTextMsgFilter::GetTxSelection()
 *
 *	@mfunc
 *	 	Get Selection if we haven't got it before
 *
 *	@rdesc
 *		TRUE if this is first time getting the selection
 *		FALSE if it is already exist or no selection available.
 */
BOOL  CTextMsgFilter::GetTxSelection()
{
	HRESULT hResult;

	if (_pTextSel)
		return FALSE;					// Already there

	hResult = _pTextDoc->GetSelectionEx(&_pTextSel);

	return _pTextSel ? TRUE : FALSE;
}

/*
 *	HRESULT CTextMsgFilter::OnIMEQueryPos(UINT *, WPARAM *, LPARAM *, LRESULT *, BOOL)
 *
 *	@mfunc
 *		Fill in the current character size and window rect. size.  
 *
 *	@rdesc
 *		S_OK
 *		*plres = 0 if we do not filled in data
 */
HRESULT CTextMsgFilter::OnIMEQueryPos( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres,
		BOOL		fUnicode)		
{
	HRESULT				hResult;
	PIMECHARPOSITION	pIMECharPos = (PIMECHARPOSITION)*plparam;
	long				cpRequest;
	RECT				rcArea;
	ITextRange			*pTextRange = NULL;
	POINT				ptTopPos, ptBottomPos = {0, 0};
	bool				fGetBottomPosFail = false;

	if (pIMECharPos->dwSize != sizeof(IMECHARPOSITION))
		goto Exit;

	// NT doesn't support Ansi window when the CP_ACP isn't the same
	// as keyboard codepage.
	if (!fUnicode && !(W32->OnWin9x()) && _uKeyBoardCodePage != _uSystemCodePage)
		goto Exit;

	if (IsIMEComposition() && _ime->GetIMELevel() == IME_LEVEL_3)
	{
		cpRequest = ((CIme_Lev3 *)_ime)->GetIMECompositionStart();
		if (fUnicode)
			cpRequest += pIMECharPos->dwCharPos;
		else if (pIMECharPos->dwCharPos > 0)
		{
			// Need to convert pIMECharPos->dwCharPos from Acp to Cp
			long	cchComp = ((CIme_Lev3 *)_ime)->GetIMECompositionLen();
			long	cchAcp = (long)(pIMECharPos->dwCharPos);
			BSTR	bstr;
			WCHAR	*pChar;

			if (cchComp)
			{
				hResult = _pTextDoc->Range(cpRequest, cpRequest+cchComp, &pTextRange);
				
				Assert (pTextRange != NULL);				
				if (hResult != NOERROR || !pTextRange)
					goto Exit;
				
				hResult = pTextRange->GetText(&bstr);
				if (hResult != NOERROR )
					goto Exit;

				// The algorithm assumes that for a DBCS charset any character
				// above 128 has two bytes, except for the halfwidth KataKana,
				// which are single bytes in ShiftJis.
				pChar = (WCHAR *)bstr;
				Assert (pChar);

				while (cchAcp > 0 && cchComp > 0)
				{
					cchAcp--;
					if(*pChar >= 128 && (CP_JAPAN != _uKeyBoardCodePage ||
						!IN_RANGE(0xFF61, *pChar, 0xFF9F)))
						cchAcp--;

					pChar++;
					cchComp--;
					cpRequest++;
				}

				SysFreeString (bstr);
				pTextRange->Release();
				pTextRange = NULL;
			}
		}
	}
	else if (pIMECharPos->dwCharPos == 0)
	{
		// Get current selection
		hResult	= _pTextSel->GetStart(&cpRequest);
		if (hResult != NOERROR)
			goto Exit;
	}
	else
		goto Exit;

	// Get requested cp location in screen coordinates
	hResult = _pTextDoc->Range(cpRequest, cpRequest+1, &pTextRange);
	Assert (pTextRange != NULL);	
	if (hResult != NOERROR || !pTextRange)
		goto Exit;
	
	hResult = pTextRange->GetPoint( tomStart+TA_TOP+TA_LEFT,
			&(ptTopPos.x), &(ptTopPos.y) );

	if (hResult != NOERROR)
	{
		// Scroll and try again
		hResult = pTextRange->ScrollIntoView(tomStart);
		if (hResult == NOERROR)
			hResult = pTextRange->GetPoint( tomStart+TA_TOP+TA_LEFT,
				&(ptTopPos.x), &(ptTopPos.y) );
	}

	if (hResult == NOERROR)
	{
		hResult = pTextRange->GetPoint( tomStart+TA_BOTTOM+TA_LEFT,
				&(ptBottomPos.x), &(ptBottomPos.y) );
		if (hResult != NOERROR)
			fGetBottomPosFail = true;
	}

	pIMECharPos->pt = ptTopPos;

	// Get application rect in screen coordinates
	hResult = _pTextDoc->GetClientRect(tomIncludeInset,
				&(rcArea.left), &(rcArea.top),
				&(rcArea.right), &(rcArea.bottom));	

	if (hResult != NOERROR)
		goto Exit;

	// Get line height in pixel
	if (fGetBottomPosFail)
		pIMECharPos->cLineHeight = rcArea.bottom - ptTopPos.y;
	else
		pIMECharPos->cLineHeight = ptBottomPos.y - ptTopPos.y;	

	pIMECharPos->rcDocument = rcArea;

	*plres = TRUE;

Exit:
	if (pTextRange)
		pTextRange->Release();

	return S_OK;
}

/*
 *	CTextMsgFilter::CheckIMEType(HKL hKL)
 *
 *	@mfunc
 *		Check for MSIME98 or later
 *
 */
void CTextMsgFilter::CheckIMEType(
	HKL	hKL)
{
	
	if (!hKL)
		hKL = GetKeyboardLayout(0x0FFFFFFFF);				// Get default HKL if caller pass in NULL

	// initialize to non MS IME
	_fMSIME	= 0;

	if (IsFELCID((WORD)hKL))
	{
		// Check what kind of IME user selected
		if (MSIMEServiceMsg && IMEMessage( *this, MSIMEServiceMsg, 0, 0, FALSE ))
			_fMSIME = 1;

	}
}

/*
 *	CTextMsgFilter::InputFEChar(WCHAR	wchFEChar)
 *
 *	@mfunc
 *		Input the FE character and ensure we have a correct font.
 *
 *	@rdesc
 *		S_OK if handled
 */
HRESULT CTextMsgFilter::InputFEChar(
	WCHAR	wchFEChar)
{
	BOOL	bReleaseSelction = GetTxSelection();
	long	cchExced;
	HRESULT	hr = S_FALSE;
	
	if (wchFEChar > 256 
		&& _pTextSel->CanEdit(NULL) == NOERROR
		&& _pTextDoc->CheckTextLimit(1, &cchExced) == NOERROR
		&& cchExced == 0)
	{
		// setup FE font to handle the FE character
		long		cpMin, cpMax;
		TCHAR		wchFE[2];
		BOOL		fSelect = FALSE;
		ITextRange	*pTextRange = NULL;
		ITextFont	*pTextFont = NULL;
		ITextFont	*pFEFont = NULL;
		HRESULT		hResult = S_FALSE;
		BSTR		bstr = NULL;

		// Inform client IME compostion is on to by-pass some font setting
		// problem in Arabic systems
		_pTextDoc->IMEInProgress(tomTrue);

		wchFE[0] = wchFEChar;
		wchFE[1] = L'\0';				
		
		_pTextSel->GetStart(&cpMin);
		_pTextSel->GetEnd(&cpMax);
		
		// For selection case, we want font to the right of first character
		if (cpMin != cpMax)
		{
			hResult = _pTextDoc->Range(cpMin, cpMin, &pTextRange);
			if (hResult != S_OK)
				goto ERROR_EXIT;

			hResult = pTextRange->GetFont(&pTextFont);

			cpMin++;
			fSelect = TRUE;
		}
		else
			hResult = _pTextSel->GetFont(&pTextFont);

		// Get a duplicate font and setup the correct FE font
		hResult = pTextFont->GetDuplicate(&pFEFont);

		if (hResult != S_OK)
			goto ERROR_EXIT;				

		CIme::CheckKeyboardFontMatching (cpMin, *this, pFEFont);
		
		if (fSelect)
			_pTextSel->SetText(NULL);		// Delete the selection

		bstr = SysAllocString(wchFE);
		if (!bstr)
		{
			hResult = E_OUTOFMEMORY;
			goto ERROR_EXIT;				
		}

		_pTextSel->SetFont(pFEFont);		// Setup FE font
		_pTextSel->TypeText(bstr);			// Input the new FE character
					
ERROR_EXIT:
		if (hResult == S_OK)
			hr = S_OK;

		if (pFEFont)
			pFEFont->Release();

		if (pTextFont)
			pTextFont->Release();

		if (pTextRange)
			pTextRange->Release();

		if (bstr)
			SysFreeString(bstr);

		// Inform client IME compostion is done
		_pTextDoc->IMEInProgress(tomFalse);
	}


	if (bReleaseSelction && _pTextSel)
	{
		_pTextSel->Release();
		_pTextSel = NULL;
	}

	return hr;
}

/*
 *	CTextMsgFilter::OnSetFocus()
 *
 *	@mfunc
 *		Restore the previous keyboard if we are in FORCEREMEMBER mode.  
 *		Otherwise, setup the FE keyboard.
 *		
 */
void CTextMsgFilter::OnSetFocus()
{
	if (!_hwnd)
		return;

	if (_fForceRemember && _fIMEHKL)
	{
		// Restore previous keyboard
		ActivateKeyboardLayout(_fIMEHKL, 0);
		if (IsFELCID((WORD)_fIMEHKL))
		{
			// Set Open status and Conversion mode
			HIMC	hIMC = ImmGetContext(_hwnd);
			if (hIMC)
			{
				if (ImmSetOpenStatus(hIMC, _fIMEEnable, _fUsingAIMM) && _fIMEEnable)
					ImmSetConversionStatus(hIMC, _fIMEConversion, _fIMESentence, _fUsingAIMM); // Set conversion status

				ImmReleaseContext(_hwnd, hIMC);
			}			
		}
	}
	else
		SetupIMEOptions();
}

/*
 *	CTextMsgFilter::OnKillFocus()
 *
 *	@mfunc
 *		If we are in FORCE_REMEMBER mode, save the current keyboard
 *	and conversion setting.
 *		
 */
void CTextMsgFilter::OnKillFocus()
{
	if (!_hwnd)
		return;

	if (_fForceRemember)
	{
		// Get current keyboard
		_fIMEHKL = GetKeyboardLayout(0x0FFFFFFFF);

		if (IsFELCID((WORD)_fIMEHKL))
		{
			// Get Open status
			HIMC	hIMC = ImmGetContext(_hwnd);
			if (hIMC)
			{
				_fIMEEnable = ImmGetOpenStatus(hIMC, _fUsingAIMM);

				if (_fIMEEnable)					
					ImmGetConversionStatus(hIMC, &_fIMEConversion, &_fIMESentence, _fUsingAIMM); // get conversion status

				ImmReleaseContext(_hwnd, hIMC);
			}			
		}
	}
}

/*
 *	CTextMsgFilter::OnSetIMEOptions(WPARAM wparam, LPARAM lparam)
 *
 *	@mfunc
 *	
 *	@rdesc
 */
LRESULT CTextMsgFilter::OnSetIMEOptions(
	WPARAM	wparam,
	LPARAM	lparam)
{
	LRESULT lIMEOptionCurrent = OnGetIMEOptions();
	LRESULT lIMEOptionNew = 0;

	// Mask off bits that we will support for now
	lparam &= (IMF_FORCEACTIVE | IMF_FORCEENABLE | IMF_FORCEREMEMBER);

	switch(wparam)
	{
	case ECOOP_SET:
		lIMEOptionNew = lparam;
		break;

	case ECOOP_OR:
		lIMEOptionNew = lIMEOptionCurrent | lparam;
		break;

	case ECOOP_AND:
		lIMEOptionNew = lIMEOptionCurrent & lparam;
		break;

	case ECOOP_XOR:
		lIMEOptionNew = lIMEOptionCurrent ^ lparam;
		break;

	default:
		return 0;		// Bad option
	}

	if (lIMEOptionNew == lIMEOptionCurrent)			// Nothing change
		return 1;

	_fForceActivate = FALSE;
	if (lIMEOptionNew & IMF_FORCEACTIVE)
		_fForceActivate = TRUE;

	_fForceEnable = FALSE;
	if (lIMEOptionNew & IMF_FORCEENABLE)
		_fForceEnable = TRUE;
	
	_fForceRemember = FALSE;
	if (lIMEOptionNew & IMF_FORCEREMEMBER)
		_fForceRemember = TRUE;

	SetupIMEOptions();

	return 1;
}

/*
 *	CTextMsgFilter::OnGetIMEOptions()
 *
 *	@mfunc
 *	
 *	@rdesc
 */
LRESULT CTextMsgFilter::OnGetIMEOptions()
{
	LRESULT		lres = 0;

	if (_fForceActivate)
		lres |= IMF_FORCEACTIVE;		

	if (_fForceEnable)
		lres |= IMF_FORCEENABLE;

	if (_fForceRemember)
		lres |= IMF_FORCEREMEMBER;

	return lres;
}

/*
 *	CTextMsgFilter::SetupIMEOptions()
 *
 *	@mfunc
 *	
 */
void CTextMsgFilter::SetupIMEOptions()
{
	if (!_hwnd)
		return;

	_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);	

	if (_fForceEnable)
	{		
		LONG	cpgLocale = GetACP();
		BYTE	bCharSet = (BYTE)GetCharSet(cpgLocale);	

		if (W32->IsFECodePage(cpgLocale))
		{
			if (_uKeyBoardCodePage != (UINT)cpgLocale)
				W32->CheckChangeKeyboardLayout(bCharSet);

			HIMC	hIMC = ImmGetContext(_hwnd);

			if (hIMC)
			{
				if (ImmSetOpenStatus(hIMC, TRUE, _fUsingAIMM) && _fForceActivate)
				{
					// Activate native input mode
					DWORD	dwConversion;
					DWORD	dwSentence;

					if (ImmGetConversionStatus(hIMC, &dwConversion, &dwSentence, _fUsingAIMM))
					{
						dwConversion |= IME_CMODE_NATIVE;
						if (bCharSet == SHIFTJIS_CHARSET)
							dwConversion |= IME_CMODE_FULLSHAPE;
						ImmSetConversionStatus(hIMC, dwConversion, dwSentence, _fUsingAIMM);
					}
				}
				ImmReleaseContext(_hwnd, hIMC);
			}			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\callmgr.cpp ===
/*
 *
 *	@doc	INTERNAL
 *
 *	@module	CALLMGR.CPP		CCallMgr implementation |
 *
 *	Purpose:  The call manager controls various aspects of
 *		a client call chain, including re-entrancy management,
 *		undo contexts, and change notifications.
 *
 *	Author:	<nl>
 *		alexgo 2/8/96
 *
 *	See the documentation in reimplem.doc for a detailed explanation
 *	of how all this stuff works.
 *
 */

#include "_common.h"
#include "_edit.h"
#include "_m_undo.h"
#include "_callmgr.h"
#include "_select.h"
#include "_disp.h"

ASSERTDATA

/*
 *	CCallMgr::SetChangeEvent
 *
 *	@mfunc	informs the callmgr that some data in the document 
 *			changed.  The fType parameter describes the actual change
 *
 *	@rdesc	void
 */
void CCallMgr::SetChangeEvent(
	CHANGETYPE fType)		//@parm the type of change (e.g. text, etc)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetChangeEvent");

	// if another callmgr exists higher up the chain, then 
	// delegate the call to it
	if( _pPrevcallmgr )
	{
		Assert(_fChange == FALSE);
		Assert(_fTextChanged == FALSE);
		_pPrevcallmgr->SetChangeEvent(fType);
	}
	else
	{
		_fChange = TRUE;
		_ped->_fModified = TRUE;
		_ped->_fSaved = FALSE;
		_fTextChanged = !!(fType & CN_TEXTCHANGED);
	}
}

/*
 *	CCallmgr::ClearChangeEvent
 *
 *	@mfunc	If a change happened, then clear the change event bit. 
 *			This allows callers to make changes to the edit control
 *			_without_ having a notifcation fire.  Sometimes, this
 *			is necessary for backwards compatibility.
 *
 *	@devnote	This is a very dangerous method to use.  If _fChange
 *			is set, it may represent more than 1 change; in other words,
 *			other changes than the one that should be ignored.  However,
 *			for all existing uses of this method, earlier changes are
 *			irrelevant.
 */
void CCallMgr::ClearChangeEvent()
{
	if( _pPrevcallmgr )
	{
		Assert(_fChange == FALSE);
		Assert(_fTextChanged == FALSE);
		_pPrevcallmgr->ClearChangeEvent();
	}
	else
	{
		_fChange = FALSE;
		_fTextChanged = FALSE;
		// caller is responsible for setting _fModifed
	}
}

/*
 *	CCallMgr::SetNewUndo
 *
 *	@mfunc	Informs the notification code that a new undo action has
 *			been added to the undo stack
 *
 *	@rdesc	void
 */
void CCallMgr::SetNewUndo()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetNewUndo");

	// we should only ever do this once per call
//	It's assert during IME composition in Outlook.  (see bug #3883)
//  Removing the assert does not caused any side effect.
//	Assert(_fNewUndo == FALSE);


	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->SetNewUndo();
	}
	else
	{
		_fNewUndo = TRUE;
	}
}

/*
 *		
 *	CCallMgr::SetNewRedo
 *
 *	@mfunc	Informs the notification code that a new redo action has
 *			been added to the redo stack.
 *
 *	@rdesc	void
 */
void CCallMgr::SetNewRedo()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetNewRedo");

	// we should only ever do this once per call.
	// The following assert looks bogus as it is forced to occur when an undo is
	// called with a count greater than 1. Therefore, for now, I (a-rsail) am
	// commenting it out.
	// Assert(_fNewRedo == FALSE);

	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->SetNewRedo();
	}
	else
	{
		_fNewRedo = TRUE;
	}
}

/*
 *	CCallMgr::SetMaxText
 *
 *	@mfunc	Informs the notification code that the max text limit has
 *			been reached.
 *
 *	@rdesc	void
 */
 void CCallMgr::SetMaxText()
 {
     TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetMaxText");

	// if there is a call context higher on the stack, delegate to it.

	if( _pPrevcallmgr )
	{
		Assert(_fMaxText == 0);
		_pPrevcallmgr->SetMaxText();
	}
	else
	{
		_fMaxText = TRUE;
	}
}

/*
 *	CCallMgr::SetSelectionChanged
 *
 *	@mfunc	Informs the notification code that the selection has
 *			changed
 *
 *	@rdesc	void
 */
void CCallMgr::SetSelectionChanged()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetSelectionChanged");

    AssertSz(_ped->DelayChangeNotification() ? _ped->Get10Mode() : 1, "Flag only should be set in 1.0 mode");        
    if (_ped->DelayChangeNotification())
        return;
	
	// if there is a call context higher on the stack, delegate to it.

	if( _pPrevcallmgr )
	{
		Assert(_fSelChanged == 0);
		_pPrevcallmgr->SetSelectionChanged();
	}
	else
	{
		_fSelChanged = TRUE;
	}
}

/*
 *	CCallMgr::SetOutOfMemory()
 *
 *	@mfunc	Informs the notification code that we were unable to allocate
 *			enough memory.
 *
 *	@rdesc	void
 */
void CCallMgr::SetOutOfMemory()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetOutOfMemory");

	// if there is a call context higher on the stack, delegate to it.

	if( _pPrevcallmgr )
	{
		Assert(_fOutOfMemory == 0);
		_pPrevcallmgr->SetOutOfMemory();
	}
	else
	{
		_fOutOfMemory = TRUE;
	}
}

/*
 *	CCallMgr::SetInProtected
 *
 *	@mfunc	Indicates that we are currently processing an EN_PROTECTED
 *			notification
 *
 *	@rdesc	void
 */
void CCallMgr::SetInProtected(BOOL flag)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetInProtected");

	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->SetInProtected(flag);
	}
	else
	{
		_fInProtected = flag;
	}
}

/*
 *	CCallMgr:GetInProtected
 *
 *	@mfunc	retrieves the InProtected flag, whether or not we are currently
 *			processing an EN_PROTECTED notification
 *
 *	@rdesc	void
 */
BOOL CCallMgr::GetInProtected()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::GetInProtected");

	if( _pPrevcallmgr )
	{
		return _pPrevcallmgr->GetInProtected();
	}
	else
	{
		return _fInProtected;
	}
}	

/*
 *	CCallMgr::RegisterComponent
 *
 *	@mfunc	Registers a subsystem component implementing IReEntrantComponent.
 *			This enables this call manager to inform those objects about
 *			relevant changes in our re-entrancy status.
 *
 *	@rdesc	void
 *
 */
void CCallMgr::RegisterComponent(
	IReEntrantComponent *pcomp,	//@parm The component to register
	CompName name)				//@parm The name for the component
{
	pcomp->_idName = name;
	pcomp->_pnext = _pcomplist;
	_pcomplist = pcomp;
}

/*
 *	CCallMgr::RevokeComponent
 *
 *	@mfunc	Removes a subsystem component from the list of components.  The
 *			component must have been previously registered with _this_
 *			call context.
 *
 *	@rdesc	void
 */
void CCallMgr::RevokeComponent(
	IReEntrantComponent *pcomp)	//@parm The component to remove
{
	IReEntrantComponent *plist, **ppprev;
	plist = _pcomplist;
	ppprev = &_pcomplist;

	while( plist != NULL )
	{
		if( plist == pcomp )
		{
			*ppprev = plist->_pnext;
			break;
		}
		ppprev = &(plist->_pnext);
		plist = plist->_pnext;
	} 
}

/*
 *	CCallMgr::GetComponent
 *
 *	@mfunc	Retrieves the earliest instance of a registered sub-component.
 *
 *	@rdesc	A pointer to the component, if one has been registered.  NULL
 *			otherwise.
 */
IReEntrantComponent *CCallMgr::GetComponent(
	CompName name)				//@parm the subsystem to look for
{
	IReEntrantComponent *plist = _pcomplist;

	while( plist != NULL )
	{
		if( plist->_idName == name )
		{
			return plist;
		}
		plist = plist->_pnext;
	}

	// hmm, didn't find anything.  Try contexts higher up, if we're
	// the top context, then just return NULL.

	if( _pPrevcallmgr )
	{
		return _pPrevcallmgr->GetComponent(name);
	}
	return NULL;
}


/*
 *	CCallMgr::CCallMgr
 *
 *	@mfunc	Constructor
 *
 *	@rdesc	void
 */
CCallMgr::CCallMgr(CTxtEdit *ped)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::");

	// set everthing to NULL
	ZeroMemory(this, sizeof(CCallMgr));

	if(ped)								// If ped is NULL, a zombie has
	{									//  been entered
		_ped = ped;
		_pPrevcallmgr = ped->_pcallmgr;
		ped->_pcallmgr = this;
		NotifyEnterContext();
	}
}

/*
 *	CCallMgr::~CCallMgr
 *
 *	@mfunc	Destructor.  If appropriate, we will fire any cached
 *			notifications and cause the edit object to be destroyed.
 *
 *	@rdesc	void
 */
CCallMgr::~CCallMgr()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::");

	if(IsZombie())					// No reentrancy with Zombies
		return;

	if( _pPrevcallmgr )
	{
		// we don't allow these flags to be set in re-entrant call
		// states
		Assert(_fMaxText == FALSE);
		Assert(_fSelChanged == FALSE);
		Assert(_fTextChanged == FALSE);
		Assert(_fChange == FALSE);
		Assert(_fNewRedo == FALSE);
		Assert(_fNewUndo == FALSE);
		Assert(_fOutOfMemory == FALSE);

		// set the ped to the next level of the call state
		_ped->_pcallmgr = _pPrevcallmgr;
	
		return;
	}

	// we're the top level. Note that we explicity do not
	// have an overall guard for cases where we are re-entered
	// while firing these notifications.  This is necessary for
	// better 1.0 compatibility and for Forms^3, which wants
	// to 'guard' their implementation of ITextHost::TxNotify and
	// ignore any notifications that happen while they are 
	// processing our notifications.  Make sense?

	_ped->_pcallmgr = NULL;

	// Process our internal notifications
	if(_ped->_fUpdateSelection)
	{	
		CTxtSelection *psel = _ped->GetSel();

		_ped->_fUpdateSelection = FALSE;

		if(psel && !_ped->_pdp->IsFrozen() && !_fOutOfMemory )
		{
			// this may cause an out of memory, so set things
			// up for that
			CCallMgr callmgr(_ped);
			psel->Update(FALSE);
		}
	}

	// Now fire any external notifications that may be necessary
	if( _fChange || _fSelChanged || _fMaxText || _fOutOfMemory )
	{
		SendAllNotifications();
	}

	// finally, we should check to see if we should delete the 
	// CTxtEdit instance.

	if( _ped->_unk._cRefs == 0 && !_ped->_fSelfDestruct)
	{
		delete _ped;
	}
}

//
//	PRIVATE methods
//

/*
 *	CCallMgr::SendAllNotifications
 *
 *	@mfunc	sends notifications for any cached notification bits.
 *
 *	@rdesc	void
 */
void CCallMgr::SendAllNotifications()
{
	ITextHost *phost = _ped->GetHost();
	CHANGENOTIFY	cn;

    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::");

	//
	// COMPATIBILITY ISSUE: The ordering of these events _may_
	// be an issue.  I've attempted to preserve the ordering
	// that the original code would use, but we have ~many~ more
	// control paths, so it's difficult.
	//
	if(	_fMaxText )
	{			
		// Beep if we are to emulate the system edit control
		if (_ped->_fSystemEditBeep)
			_ped->Beep();
		phost->TxNotify(EN_MAXTEXT, NULL);
	}
	
	if( _fSelChanged )
	{ 		
		if( (_ped->_dwEventMask & ENM_SELCHANGE) && !(_ped->_fSuppressNotify))
		{
			SELCHANGE selchg;

			ZeroMemory(&selchg, sizeof(SELCHANGE));

			_ped->GetSel()->SetSelectionInfo(&selchg);
			
			if (_ped->Get10Mode())
			{
				selchg.chrg.cpMin = _ped->GetAcpFromCp(selchg.chrg.cpMin);
				selchg.chrg.cpMost = _ped->GetAcpFromCp(selchg.chrg.cpMost);
			}

			phost->TxNotify(EN_SELCHANGE, &selchg);
		}
	}

	if( _fOutOfMemory && !_ped->GetOOMNotified())
	{
		_fNewUndo = 0;
		_fNewRedo = 0;
		_ped->ClearUndo(NULL);
		_ped->_pdp->InvalidateRecalc();
		_ped->SetOOMNotified(TRUE);
		phost->TxNotify(EN_ERRSPACE, NULL);
		_ped->SetOOMNotified(FALSE);
	}

	if( _fChange )
	{
		if( (_ped->_dwEventMask & ENM_CHANGE) && !(_ped->_fSuppressNotify))
		{
			cn.dwChangeType = 0;
			cn.pvCookieData = 0;
			
			if( _fNewUndo )
			{
				Assert(_ped->_pundo);
				cn.dwChangeType |= CN_NEWUNDO;
				cn.pvCookieData = _ped->_pundo->GetTopAECookie();

			}
			else if( _fNewRedo )
			{
				Assert(_ped->_predo);
				cn.dwChangeType |= CN_NEWREDO;
				cn.pvCookieData = _ped->_predo->GetTopAECookie();
			}

			if( _fTextChanged )
			{
				cn.dwChangeType |= CN_TEXTCHANGED;
			}
			_ped->_dwEventMask &= ~ENM_CHANGE;
			phost->TxNotify(EN_CHANGE, &cn);
			_ped->_dwEventMask |= ENM_CHANGE;
		}
	}
}

/*
 *	CCallMgr::NotifyEnterContext
 *
 *	@mfunc	Notify any registered components that a new context
 *			has been entered.
 *
 *	@rdesc	void
 */
void CCallMgr::NotifyEnterContext()
{
	IReEntrantComponent *pcomp = _pcomplist;

	while( pcomp )
	{
		pcomp->OnEnterContext();
		pcomp = pcomp->_pnext;
	}

	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->NotifyEnterContext();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\coleobj.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	COLEOBJ.CPP	OLE Object management class implemenation |
 *
 * 	Author:		alexgo 10/24/95
 *
 *	Note:	Much of this code is a port from RichEdit 1.0 sources
 *			(cleaned up a bit, ported to C++, etc.)  So if there's any
 *			bit of strangeness, it's probably there for a reason.
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_coleobj.h"
#include "_objmgr.h"
#include "_select.h"
#include "_rtext.h"
#include "_disp.h"
#include "_dispprt.h"
#include "_antievt.h"
#include "_dxfrobj.h"

ASSERTDATA

//
// data private to this file
//
static const OLECHAR szSiteFlagsStm[] = OLESTR("RichEditFlags");	

//
// EXCEL clsid's.  We have to make some special purpose hacks
// for XL.
const CLSID rgclsidExcel[] =
{
    { 0x00020810L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel Worksheet
    { 0x00020811L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel Chart
    { 0x00020812L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel App1
    { 0x00020841L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel App2
};
const INT cclsidExcel = sizeof(rgclsidExcel) / sizeof(rgclsidExcel[0]);


//
//	WordArt CLSID for more special purpose hacks.
//
const GUID CLSID_WordArt =
    { 0x000212F0L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} };
const GUID CLSID_PaintbrushPicture =
    { 0x0003000AL, 0x0000, 0x0000, { 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 } };
const GUID CLSID_BitmapImage =
    { 0xD3E34B21L, 0x9D75, 0x101A, { 0x8C, 0x3D, 0x00, 0xAA, 0x00, 0x1A, 0x16, 0x52 } };


#define dxyHandle (6) // Object frame handle size
#define dxyFrameDefault  (1) // Object frame width

//
// utility functions
//

/*
 *	IsExcelCLSID (clsid)
 *
 *	@func	checks to see if the given clsid is one of XL's
 *
 *	@rdesc	TRUE/FALSE
 */
BOOL IsExcelCLSID(
	REFGUID clsid)
{
    for(LONG i = 0; i < cclsidExcel; i++)
    {
        if(IsEqualCLSID(clsid, rgclsidExcel[i]))
			return TRUE;
    }
    return FALSE;
}

//
//	PUBLIC methods
//

/*
 *	COleObject::QueryInterface(ridd, ppv)
 *
 *	@mfunc	the standard OLE QueryInterface
 *
 *	@rdesc	NOERROR		<nl>
 *			E_NOINTERFACE
 */
STDMETHODIMP COleObject::QueryInterface(
	REFIID	riid,		//@parm Requested interface ID
	void **	ppv)		//@parm Out parm for result
{
	HRESULT hr = NOERROR;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::QueryInterface");

    if(IsZombie())
        return CO_E_RELEASED;

	if(!ppv)
		return E_INVALIDARG;
	else
		*ppv = NULL;

	if(IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown *)(IOleClientSite *)this;

	else if(IsEqualIID(riid, IID_IOleClientSite))
		*ppv = (IOleClientSite *)this;

	else if(IsEqualIID(riid, IID_IOleInPlaceSite))
		*ppv = (IOleInPlaceSite *)this;

	else if(IsEqualIID(riid, IID_IAdviseSink))
		*ppv = (IAdviseSink *)this;

	else if(IsEqualIID(riid, IID_IOleWindow))
		*ppv = (IOleWindow *)this;

	else if(IsEqualIID(riid, IID_IRichEditOleCallback))
	{
		// NB!! Returning this pointer in our QI is
		// phenomenally bogus; it breaks fundamental COM
		// identity rules (granted, not many understand them!).
		// Anyway, RichEdit 1.0 did this, so we better.

		TRACEWARNSZ("Returning IRichEditOleCallback interface, COM "
			"identity rules broken!");

		*ppv = _ped->GetRECallback();
	}
	else
		hr = E_NOINTERFACE;

	if(*ppv)
		(*(IUnknown **)ppv)->AddRef();

	return hr;
}

/*
 *	COleObject::AddRef()
 *
 *	@mfunc	Increments reference count
 *
 *	@rdesc	New reference count
 */
STDMETHODIMP_(ULONG) COleObject::AddRef()
{
    ULONG cRef;
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::AddRef");

    cRef = SafeAddRef();
	
	return cRef;
}

/*
 *	COleObject::Release	()
 *
 *	@mfunc	Decrements reference count
 *
 *	@rdesc	New reference count
 */
STDMETHODIMP_(ULONG) COleObject::Release()
{
    ULONG cRef;
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Release");

	cRef = SafeRelease();

	return cRef;
}

/*
 *	COleObject::SaveObject ()
 *
 *	@mfunc	implemtenation of IOleClientSite::SaveObject
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::SaveObject()
{
	CCallMgr	callmgr(_ped);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SaveObject");

	return SafeSaveObject();
}

/*
 *	COleObject::SafeSaveObject ()
 *
 *	@mfunc	implemtenation of IOleClientSite::SaveObject for internal consumption
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::SafeSaveObject()
{
	IPersistStorage *pps;
	HRESULT hr;
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SafeSaveObject");

	if(!_punkobj || !_pstg)
	{
		TRACEWARNSZ("SaveObject called on invalid object");
		return E_UNEXPECTED;
	}

    if(IsZombie())
        return CO_E_RELEASED;

	hr = _punkobj->QueryInterface(IID_IPersistStorage, (void **)&pps);

	TESTANDTRACEHR(hr);

	if(hr == NOERROR)
	{
        if(IsZombie())
            return CO_E_RELEASED;

		SavePrivateState();
		
        if(IsZombie())
            return CO_E_RELEASED;

		hr = OleSave(pps, _pstg, TRUE);
	
	    if(IsZombie())
	        return CO_E_RELEASED;

		TESTANDTRACEHR(hr);

		// note that SaveCompleted is called even if OleSave fails.
		// If both OleSave and SaveCompleted succeed, then go ahead
		// and commit the changes

		if(pps->SaveCompleted(NULL) == NOERROR && hr == NOERROR)
		{
		    if(IsZombie())
		        return CO_E_RELEASED;
			
			hr = _pstg->Commit(STGC_DEFAULT);

			TESTANDTRACEHR(hr);
		}
        pps->Release();
	}
	return hr;
}

/*
 *	COleObject::GetMoniker (dwAssign, dwWhichMoniker, ppmk)
 *
 *	@mfunc	implementation of IOleClientSite::GetMoniker
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP COleObject::GetMoniker(
	DWORD		dwAssign,		//@parm	Force an assignment?
	DWORD		dwWhichMoniker,	//@parm	Kind of moniker to get
	IMoniker **	ppmk)			//@parm Out parm for result
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetMoniker");

	TRACEWARNSZ("method not implemented!");

	if(ppmk)
		*ppmk = NULL;

	return E_NOTIMPL;
}
	
/*
 *	COleObject::GetContainer(ppcont)
 *
 *	@mfunc	implementation of IOleClientSite::GetContainer
 *
 *	@rdesc	E_NOINTERFACE
 */
STDMETHODIMP COleObject::GetContainer(
	IOleContainer **ppcont)	//@parm	Out parm for result
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetContainer");

	TRACEWARNSZ("method not implemented!");

	if(ppcont)
		*ppcont = NULL;

	// richedit 1.0 returns E_NOINTERFACE instead of E_NOTIMPL.  Do
	// the same.

	return E_NOINTERFACE;
}

/*
 *	COleObject::ShowObject()
 *
 *	@mfunc	Implementation of IOleClientSite::ShowObject.
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP COleObject::ShowObject()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::ShowObject");

	TRACEWARNSZ("method not implemented!");

	return E_NOTIMPL;
}

/*
 *	COleObject::OnShowWindow (fShow)
 *
 *	@mfunc
 *		implementation of IOleClientSite::OnShowWindow -- notifies
 *		the client site that the object is or is not being shown in its
 *		own application window.  This governs whether or not hatching
 *		should appear around the object in richedit.
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnShowWindow(
	BOOL fShow)		//@parm If TRUE, object is being drawn in its own window
{
	DWORD dwFlags = _pi.dwFlags;
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnShowWindow");

    if(IsZombie())
        return CO_E_RELEASED;

	_pi.dwFlags &= ~REO_OPEN;
	if(fShow)
		_pi.dwFlags |= REO_OPEN;

	// If something changed, redraw object
	if(dwFlags != _pi.dwFlags)
	{
		// Invalidate rect that we're in.
		_ped->TxInvalidateRect(&_rcPos, FALSE);

		// We're not allowed to call invalidate rect by itself without
		// terminating it with a call to update window.However, we don't
		// care at this point if things are redrawn right away.
		_ped->TxUpdateWindow();

		// COMPATIBILITY ISSUE: (alexgo) the RE1.0 code did some funny
		// stuff with undo here.  I don't believe it's necessary to
		// repeat that code with our multi-level undo model,
	}
	return NOERROR;
}

/*
 *	COleObject::RequestNewObjectLayout ()
 *
 *	@mfunc	Implementation of IOleClientSite::RequestNewObjectLayout
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP COleObject::RequestNewObjectLayout()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN,
			"COleObject::RequestNewObjectLayout");

	TRACEWARNSZ("method not implemented!");

	return E_NOTIMPL;
}

/*
 *	COleObject::GetWindow(phwnd)
 *
 *	@mfunc	Implementation of IOleInPlaceSite::GetWindow
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::GetWindow(
	HWND *phwnd)	//@parm Where to put window
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetWindow");

	// NB! this method is not stabilized.

    if(IsZombie())
        return CO_E_RELEASED;

	if(phwnd)
		return _ped->TxGetWindow(phwnd);

	return E_INVALIDARG;
}

/*
 *	COleObject::ContextSensitiveHelp(fEnterMode)
 *
 *	@mfunc	Implemenation of IOleInPlaceSite::ContextSensitiveHelp
 *
 *	@rdesc	HRESULT
 */
 STDMETHODIMP COleObject::ContextSensitiveHelp(
 	BOOL fEnterMode)	//@parm, If TRUE, then we're in help mode
 {
 	IRichEditOleCallback *precall;
	CCallMgr	callmgr(_ped);
	CStabilize	stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN,
			"COleObject::ContextSensitiveHelp");

    if(IsZombie())
        return CO_E_RELEASED;

	// If the mode changes
	if(_ped->GetObjectMgr()->GetHelpMode() != fEnterMode)
	{
		_ped->GetObjectMgr()->SetHelpMode(fEnterMode);

		precall = _ped->GetRECallback();
		if(precall)
			return precall->ContextSensitiveHelp(fEnterMode);
	}
	return NOERROR;
}

/*
 *	COleObject::CanInPlaceActivate()
 *
 *	@mfunc	implementation of IOleInPlaceSite::CanInPlaceActivate
 *
 *	@rdesc	NOERROR or S_FALSE
 */
STDMETHODIMP COleObject::CanInPlaceActivate()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN,
			"COleObject::CanInPlaceActivate");

    if(IsZombie())
        return CO_E_RELEASED;

	// If we have a callback && the object is willing to show
	// content, then we can in-place activate

	if(_ped->GetRECallback() && _pi.dvaspect == DVASPECT_CONTENT)
 		return NOERROR;

	return S_FALSE;
}

/*
 *	COleObject::OnInPlaceActivate()
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnInPlaceActivate
 *
 *	@rdesc	noerror
 */
STDMETHODIMP COleObject::OnInPlaceActivate()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnInPlaceActivate");
	// assume that in-place objects can never be blank.
	_pi.dwFlags &= ~REO_BLANK;
	_fInPlaceActive = TRUE;

	return NOERROR;
}

/*
 *	COleObject::OnUIActivate ()
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnUIActivate.  Notifies
 *			the container that the object is about to be activated in
 *			place with UI elements suchs as merged menus
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnUIActivate()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnUIActivate");

	CCallMgr	callmgr(_ped);
	CStabilize	stabilize(this);

    if(IsZombie())
        return CO_E_RELEASED;

	CObjectMgr *		  pobjmgr = _ped->GetObjectMgr();
	IRichEditOleCallback *precall = pobjmgr->GetRECallback();

	if(precall)
	{
		// Force this object to be selected, if it isn't already
		// Update the selection before making the outgoing call
		if(!(_pi.dwFlags & REO_SELECTED))
		{
			CTxtSelection *psel = _ped->GetSel();
			if(psel)
				psel->SetSelection(_cp, _cp + 1);
		}
		precall->ShowContainerUI(FALSE);
	    if(IsZombie())
	        return CO_E_RELEASED;

		// This is an optimization for activating multiple
		pobjmgr->SetShowUIPending(FALSE);

		// RAID 7212
		// We don't want to set the in place active object if we are already in the process of activating the pbject.
		// Otherwise, there will be bad interactions with the code in TxDraw for out of process servers.
		// Note : it may be possible to always set this in ActivateObj but I left this here for those cases wher
		// OnUIActivate may be called directly.
		if (!_fActivateCalled)
		{
			Assert(!pobjmgr->GetInPlaceActiveObject());	
			pobjmgr->SetInPlaceActiveObject(this);
			_pi.dwFlags |= REO_INPLACEACTIVE;
		}

		return NOERROR;
	}
	return E_UNEXPECTED;
}

/*
 *	COleObject::GetWindowContext(ppipframe, ppipuidoc, prcPos, prcClip, pipfinfo)
 *
 *	@mfunc	Implementation of IOleInPlaceSite::GetWindowContext.
 *			Enables the in-place object to retrieve the window
 *			interfaces that form the window object hierarchy.
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::GetWindowContext(
	IOleInPlaceFrame **ppipframe,	//@parm	Where to put in-place frame
	IOleInPlaceUIWindow **ppipuidoc,//@parm Where to put ui window
	LPRECT prcPos,					//@parm Position rect
	LPRECT prcClip,					//@parm Clipping rect
	LPOLEINPLACEFRAMEINFO pipfinfo)	//@parm Accelerator information
{
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);
	
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetWindowContext");
	
    if(IsZombie())
        return CO_E_RELEASED;

	// Let container verify other parameters; we don't use them
	if(!prcPos || !prcClip)
		return E_INVALIDARG;
		
	IRichEditOleCallback *precall = _ped->GetRECallback();
	if(precall)
	{
		// Recall that there are two rects here in client coordiantes:
		// the rect for this object (_rcPos) and the rect for
		// our main display;
		*prcPos = _rcPos;

		// FUTURE (alexgo); we may need to get this from the
		// display instead to handle the inactive state if we ever
		// want to support embedded objects with the inactive state.
		_ped->TxGetClientRect(prcClip);
		return precall->GetInPlaceContext(ppipframe, ppipuidoc, pipfinfo);
	}
	return E_UNEXPECTED;
}

/*
 *	COleObject::Scroll(sizeScroll)
 *
 *	@mfunc	implementation of IOleInPlaceSite::Scroll
 *
 *	@rdesc 	E_NOTIMPL;
 */
STDMETHODIMP COleObject::Scroll(
	SIZE sizeScroll)	//@parm Amount to scroll
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Scroll");

	TRACEWARNSZ("method not implemented!");

	return E_NOTIMPL;
}

/*
 *	COleObject::OnUIDeactivate (fUndoable)
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnUIDeactivate.  Notifies
 *			the container that it should re-install its user interface
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnUIDeactivate(
	BOOL fUndoable)		//@parm Whether you can undo anything here
{
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnUIDeactivate");

    if(IsZombie())
        return CO_E_RELEASED;

	CObjectMgr *pobjmgr = _ped->GetObjectMgr();
	IRichEditOleCallback *precall = _ped->GetRECallback();

	if(_fIsPaintBrush)
	{
		// Hack for RAID 3293.  Bitmap object disappears after editing.
		// Apparently paint only triggers OnUIDeactivate and not OnInPlaceDeactivate
		// assume that in-place objects can never be blank.
		_fInPlaceActive = FALSE;
		// Reset REO_INPLACEACTIVE
		_pi.dwFlags &= ~REO_INPLACEACTIVE;
	}

	if(!precall)
		return E_UNEXPECTED;

	if(_ped->TxIsDoubleClickPending())
		_ped->GetObjectMgr()->SetShowUIPending(TRUE);
	else
	{
		// Ignore any errors; the old code did.
		precall->ShowContainerUI(TRUE);

	    if(IsZombie())
	        return CO_E_RELEASED;
	}
	
	pobjmgr->SetInPlaceActiveObject(NULL);

	if (!_fDeactivateCalled)
	{
		// We got here without DeActiveObj. Since to shutdown correctly
		// we need to call this, we do so here.
		DeActivateObj();
	}

	// Get focus back
	_ped->TxSetFocus();

#ifdef DEBUG
	// the OLE undo model is not very compatible with multi-level undo.
	// For simplicity, just ignore stuff.
	if(fUndoable)
	{
		TRACEWARNSZ("Ignoring a request to keep undo from an OLE object");
	}
#endif

	// Some objects draw outside the
	// areas they are supposed to.  So we need to
	// just invalidate everything and redraw.

	_ped->TxInvalidateRect(NULL, TRUE);
	return NOERROR;
}

/*
 *	COleObject::OnInPlaceDeactivate	()
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnInPlaceDeactivate
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP COleObject::OnInPlaceDeactivate()
{
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN,
			"COleObject::OnInPlaceDeactivate");

	_fInPlaceActive = FALSE;

	//Reset REO_INPLACEACTIVE
	_pi.dwFlags &= ~REO_INPLACEACTIVE;

	if(!_punkobj)
		return E_UNEXPECTED;

    if(IsZombie())
        return CO_E_RELEASED;

	// Apparently, WordArt 2.0 had some sizing problems.  The original
	// code has this call to GetExtent-->SetExtent, so I've kept it here.
	
	if(_fIsWordArt2)
	{
		// Ignore errors.  If anything fails, too bad.
		FetchObjectExtents();	// this will reset _sizel
		SetExtent(SE_NOTACTIVATING);
	}

	// Some objects draw outside the
	// areas they are supposed to.  So we need to
	// just invalidate everything and redraw.

	// Note that we do this in UIDeactivate as well; however, the
	// double invalidation is necessary to cover some re-entrancy
	// cases where we might be painted before everything is ready.

	_ped->TxInvalidateRect(NULL, TRUE);
	return NOERROR;
}

/*
 *	COleObject::DiscardUndoState ()
 *
 *	@mfunc	implementation of IOleInPlaceSite::DiscardUndoState.
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP COleObject::DiscardUndoState()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN,
			"COleObject::DiscardUndoState");

	// Nothing to do here; we don't keep any OLE-undo state as it's
	// not very compatible with multi-level undo.
	
	return NOERROR;
}

/*
 *	COleObject::DeactivateAndUndo ()
 *
 *	@mfunc	implementation of IOleInPlaceSite::DeactivateAndUndo--
 *			called by an active object when the user invokes undo
 *			in the active object
 *
 *	@rdesc	NOERROR	(yep, richedit1.0 ignored all the errors here)
 */
STDMETHODIMP COleObject::DeactivateAndUndo()
{
	CStabilize	stabilize(this);

  	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::DeactivateAndUndo");

    if(IsZombie())
        return CO_E_RELEASED;

	// Ignore error
	_ped->InPlaceDeactivate();

	// COMPATIBILITY ISSUE: we don't bother doing any undo here, as
	// a multi-level undo model is incompatible with OLE undo.

	return NOERROR;
}

/*
 *	COleObject::OnPosRectChange	(prcPos)
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnPosRectChange.  This
 *			method is called by an in-place object when its extents have
 *			changed
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnPosRectChange(
	LPCRECT prcPos)
{
	IOleInPlaceObject *pipo;
 	RECT rcClip;
	RECT rcNewPos;
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnPosRectChange");
	
	if(!prcPos)
		return E_INVALIDARG;

	if(!_punkobj)
		return E_UNEXPECTED;
		
    if(IsZombie())
        return CO_E_RELEASED;

	if(!_ped->fInplaceActive())
		return E_UNEXPECTED;

	// Check to see if the rect moved; we don't allow this, but
	// do allow the object to keep the new size

	rcNewPos = *prcPos;

	if(prcPos->left != _rcPos.left	|| prcPos->top != _rcPos.top)
	{
		rcNewPos.right = rcNewPos.left + (prcPos->right - prcPos->left);
		rcNewPos.bottom = rcNewPos.top + (prcPos->bottom - prcPos->top);		
	}

	_ped->TxGetClientRect(&rcClip);

	HRESULT hr = _punkobj->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo);
	if(hr == NOERROR)
	{
		hr = pipo->SetObjectRects(&rcNewPos, &rcClip);
        pipo->Release();

        // bug fix 6073
        // Need to set viewchange flag so we resize the ole object properly on ITextServices::TxDraw
		CObjectMgr * pobjmgr = _ped->GetObjectMgr();
		if (pobjmgr && pobjmgr->GetInPlaceActiveObject() == this)
			_fViewChange = TRUE;
	}
	return hr;
}

/*
 *	COleObject::OnDataChange (pformatetc, pmedium)
 *
 *	@mfunc	implementation of IAdviseSink::OnDataChange
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP_(void) COleObject::OnDataChange(
	FORMATETC *pformatetc,		//@parm Format of data that changed
	STGMEDIUM *pmedium)			//@parm Data that changed
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnDataChange");
	CCallMgr	callmgr(_ped);

    if(IsZombie())
        return;
	_pi.dwFlags &= ~REO_BLANK;
	// this will also set the modified flag
	_ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);

	return;
}

/*
 *	COleObject::OnViewChange(dwAspect, lindex)
 *
 *	@mfunc	implementation of IAdviseSink::OnViewChange.  Notifies
 *			us that the object's view has changed.
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP_(void) COleObject::OnViewChange(
	DWORD	dwAspect,		//@parm Aspect that has changed
	LONG	lindex)			//@parm unused
{
	CStabilize	stabilize(this);
	CCallMgr	callmgr(_ped);
		
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnViewChange");
	
	if(!_punkobj)
		return;		// E_UNEXPECTED

    if(IsZombie())
        return;

	if (_fInUndo)	// This object has been deleted, forget view change
		return;

	_pi.dwFlags &= ~REO_BLANK;
	// Richedit 1.0 ignored errors on getting object extents

  	FetchObjectExtents();

    // bug fix 6073
    // Need to set viewchange flag so we resize the ole object properly on ITextServices::TxDraw
    CObjectMgr * pobjmgr = _ped->GetObjectMgr();
	if (pobjmgr && pobjmgr->GetInPlaceActiveObject() == this)
		_fViewChange = TRUE;

	CDisplay *pdp = _ped->_pdp;
	if(pdp)
		pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, _cp, _cp + 1);

	_ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);
	return;
}
	
/*
 *	COleObject::OnRename (pmk)
 *
 *	@mfunc	implementation of IAdviseSink::OnRename.  Notifies the container
 *			that the object has been renamed
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP_(void) COleObject::OnRename(
	IMoniker *pmk)			//@parm Object's new name
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnRename");
	
	TRACEWARNSZ("IAdviseSink::OnRename not implemented!");

	return;	// E_NOTIMPL;
}

/*
 *	COleObject::OnSave ()
 *
 *	@mfunc	implementation of IAdviseSink::OnSave.  Notifies the container
 *			that an object has been saved
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP_(void) COleObject::OnSave()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnSave");
	_pi.dwFlags &= ~REO_BLANK;
}

/*
 *	COleObject::OnClose	()
 *
 *	@mfunc	implementation of IAdviseSink::OnClose.  Notifies the container
 *			that an object has been closed.
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP_(void) COleObject::OnClose()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnClose");
	
    if(IsZombie())
        return;

	// If the object is blank (i.e. no data in it), we don't want to leave
	// it in the backing store--there is nothing for us to draw && therefore
	// nothing for the user to click on!  So just delete the object with
	// a space.  Note that 1.0 actually deleted the object; we'll just
	// replace it with a space to make everything work out right.
	if(_pi.dwFlags & REO_BLANK)
	{
		CCallMgr	callmgr(_ped);
		CStabilize	stabilize(this);
		CRchTxtPtr	rtp(_ped, _cp);

		// We don't want the delete of this object to go on the undo
		// stack.  We use a space so that cp's will work out right for
		// other undo actions.
		rtp.ReplaceRange(1, 1, L" ", NULL, -1);
	}
	_ped->TxSetForegroundWindow();
}
				
/*
 *	COleObject::OnPreReplaceRange
 *
 *	@mfunc	implementation of ITxNotify::OnPreReplaceRange
 *			called before changes are made to the backing store
 */
void COleObject::OnPreReplaceRange(
	LONG cp, 			//@parm cp of the changes
	LONG cchDel,		//@parm #of chars deleted
	LONG cchNew,		//@parm # of chars added
	LONG cpFormatMin, 	//@parm min cp of formatting changes
	LONG cpFormatMax)	//@parm max cp of formatting changes
{
	Assert(_fInUndo == FALSE);
}

/*
 *	COleObject::OnPostReplaceRange
 *
 *	@mfunc	implementation of ITxNotify::OnPostReplaceRange
 *			called after changes are made to the backing store
 *	
 *	@comm	we use this method to keep our cp's up-to-date
 */
void COleObject::OnPostReplaceRange(
	LONG cp, 			//@parm cp of the changes
	LONG cchDel,		//@parm #of chars deleted
	LONG cchNew,		//@parm # of chars added
	LONG cpFormatMin, 	//@parm min cp of formatting changes
	LONG cpFormatMax)	//@parm max cp of formatting changes
{
	// The only case we need to worry about is when changes
	// come before our object

	Assert(_fInUndo == FALSE);

	_fDraw = TRUE;
	if(cp <= _cp)
	{		
		if(cp + cchDel > _cp)
		{
			_fDraw = FALSE;
			return;
		}
		_cp += (cchNew - cchDel);
	}
}
		
/*
 *	COleObject::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie
 *
 */
void COleObject::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Zombie");

	_ped = NULL;
}

/*
 *	COleObject::COleObject(ped)
 *
 *	@mfunc	constructor
 */
COleObject::COleObject(
	CTxtEdit *ped)	//@parm context for this object
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::COleObject");

	AddRef();

	// Most values will be NULL by virtue of the allocator
	_ped = ped;

	CNotifyMgr *pnm = ped->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);
}

/*
 *	COleObject::GetObjectData(preobj, dwFlags)
 *
 *	@mfunc	fills out an REOBJECT structure with information relevant
 *			to this object
 *
 *	@rdesc	HRESULT
 */
HRESULT	COleObject::GetObjectData(
	REOBJECT *preobj, 		//@parm Struct to fill out
	DWORD dwFlags)			//@parm Indicate what data is requested
{
	IOleObject *poo = NULL;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::GetObjectData");

	Assert(preobj);
	Assert(_punkobj);

	preobj->cp = _cp;
	
	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		// Don't worry about failures here
		poo->GetUserClassID(&(preobj->clsid));
	}
	
	preobj->dwFlags 	= _pi.dwFlags;
	preobj->dvaspect 	= _pi.dvaspect;
	preobj->dwUser 		= _pi.dwUser;
	preobj->sizel		= _sizel;		

   	if(dwFlags & REO_GETOBJ_POLEOBJ)
	{
		preobj->poleobj = poo;
		if(poo)
			poo->AddRef();
	}
	else
		preobj->poleobj = NULL;

    if(poo)
        poo->Release();

    if(IsZombie())
        return CO_E_RELEASED;

	if(dwFlags & REO_GETOBJ_PSTG)
	{
		preobj->pstg = _pstg;
		if(_pstg)
			_pstg->AddRef();
	}
	else
		preobj->pstg = NULL;

	if(dwFlags & REO_GETOBJ_POLESITE)
	{
		// COMPATIBILITY HACK!!  Note that we don't 'release' any pointer that
		// may already be in the stored in the site.  RichEdit1.0 always sets
		// the value, consequently several apps pass in garbage for the site.
		//
		// If the site was previously set, we will get a reference counting
		// bug, so be sure that doesn't happen!

       	preobj->polesite = (IOleClientSite *)this;
       	AddRef();
 	}
	else
		preobj->polesite = NULL;

	return NOERROR;
}	

/*
 *	COleObject::IsLink()
 *
 *	@mfunc	returns TRUE if the object is a link
 *
 *	@rdesc	BOOL
 */
BOOL COleObject::IsLink()
{
	return !!(_pi.dwFlags & REO_LINK);
}

/*
 *	COleObject::InitFromREOBJECT(cp, preobj)
 *
 *	@mfunc	initializes this object's state from the given
 *			REOBJECT data structure
 *
 *	@rdesc	HRESULT
 */
HRESULT COleObject::InitFromREOBJECT(
	LONG	cp,			//@parm cp for the object
	REOBJECT *preobj)	//@parm	Data to use for initialization
{
	IOleLink *plink;
	HRESULT	hr = E_INVALIDARG;
	CRchTxtPtr rtp(_ped, 0);
	POINT pt;
	
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::InitFromREOBJECT");
	
	Assert(_punkobj == NULL);
    if(IsZombie())
        return CO_E_RELEASED;

	_cp = cp;

	if(preobj->poleobj)
		hr = preobj->poleobj->QueryInterface(IID_IUnknown, (void **)&_punkobj);
	else
	{
		_punkobj = (IOleClientSite *) this;
		AddRef();
		hr = NOERROR;
	}

	if(hr != NOERROR)
		return hr;
	
	_pstg = preobj->pstg;
	if(_pstg)
		_pstg->AddRef();

	_pi.dwFlags	 = preobj->dwFlags & REO_READWRITEMASK;
	_pi.dwUser	 = preobj->dwUser;
	_pi.dvaspect = preobj->dvaspect;

	_sizel = preobj->sizel;		// COMPATIBILITY ISSUE: the RE 1.0 code had
								// some stuff to deal with REO_DYNAMICSIZE
								// here. We do not currently support that.
	
	if(_punkobj->QueryInterface(IID_IOleLink, (void **)&plink) == NOERROR)
	{
		_pi.dwFlags |= REO_LINK | REO_LINKAVAILABLE;
		plink->Release();
	}

    if(IsZombie())
        return CO_E_RELEASED;

	if (IsEqualCLSID(preobj->clsid, CLSID_StaticMetafile) ||
		IsEqualCLSID(preobj->clsid, CLSID_StaticDib) ||
		IsEqualCLSID(preobj->clsid, CLSID_Picture_EnhMetafile))
	{
		_pi.dwFlags |= REO_STATIC;
	}
	else if(IsExcelCLSID(preobj->clsid))
		_pi.dwFlags |= REO_GETMETAFILE;

	else if(IsEqualCLSID(preobj->clsid, CLSID_WordArt))
		_fIsWordArt2 = TRUE;

	else if(IsEqualCLSID(preobj->clsid, CLSID_PaintbrushPicture) ||
			IsEqualCLSID(preobj->clsid, CLSID_BitmapImage))
	{
		_fIsPaintBrush = TRUE;

		// These calls will initialize the flag, _fPBUseLocalSizel, which
		// indicates that for this PB object, SetExtent calls are not
		// acknowledged by the object, and we are to use our local value
		// of _sizel as the object extents.
		FetchObjectExtents();
		SetExtent(SE_NOTACTIVATING);
	}

	hr = ConnectObject();

    if(IsZombie())
        return CO_E_RELEASED;

	// This is a bit non-intuitive, but we need to figure out
	// where the object would be so that it can inplace activate correctly.

	if(cp)
		cp--;

	rtp.SetCp(cp);

	pt.x = pt.y = 0;
	if (!_ped->_pdp->IsFrozen())
		_ped->_pdp->PointFromTp(rtp, NULL, FALSE, pt, NULL, TA_TOP);
	_rcPos.top = _rcPos.bottom = pt.y;	//bottom will be set below in
	                                    // FetchExtents
	_rcPos.left = _rcPos.right = pt.x;

	if(preobj->sizel.cx || preobj->sizel.cy)
		_sizel = preobj->sizel;
	else
		FetchObjectExtents();

	if (!_ped->_pdp->IsFrozen())
		ResetPosRect();

    if(IsZombie())
        return CO_E_RELEASED;

	// We don't do the following anymore although it was originally spec'd as the correct
	// behavior for applications in OLE 2.01. The reason is that no one else seems to and
	// it seems to result in some odd behavior.
#if 0
    // Finally, lock down Link objects so they we don't try to refetch their
	// extents from the server.  After initialization, link object size is
	// entirely determined by the container.
	if(_pi.dwFlags & REO_LINK)
    {
        // so we don't call GetExtents on remeasuring.
        _fSetExtent = TRUE;
	}
#endif

	return NOERROR;
}

/*
 *	COleObject::MeasureObj(dypInch, dxpInch, xWidth, yHeight, yDescent)
 *
 * Review: (keithcu) Should yDescentFont be descent of font
 * or descent of entire line? LS does one thing, old measurer
 * does another. I'm hoping that this feature is only used on
 * lines with one font..
 *	@mfunc	calculates the size of this object in device units
 */
void COleObject::MeasureObj(
	long	dypInch,		//@parm	resolution of device
	long	dxpInch,
	LONG &	xWidth,			//@parm Object width
	LONG &	yAscent,		//@parm Object ascent
	LONG &  yDescent,		//@parm Object descent
	SHORT	yDescentFont)	//@parm object's font descent
{
	xWidth = W32->HimetricXtoDX(_sizel.cx, dxpInch);
	LONG yHeight = W32->HimetricYtoDY(_sizel.cy, dypInch);

	if (_pi.dwFlags & REO_BELOWBASELINE)
	{
		yDescent = yDescentFont;
		yAscent = max(0, yHeight - yDescent);
	}
	else //The normal case
	{
		yAscent = yHeight;
		yDescent = 0;
	}
}

/*
 * COleObject::InHandle(x, y, &pt)
 *
 * @mfunc  See if a point is in the rectangle defined by the handle at
 *		the given coordinates.
 *
 * @rdesc True if point is in handle.
 */
BOOL COleObject::InHandle(
	int		x,		//@parm Upper left corner x coordinate of handle box
	int		y,		//@parm Upper left corner y coordinate of handle box
	const POINT &pt)//@parm Point to check
{
    RECT    rc;

    rc.left = x;
    rc.top = y;

	// Add one to bottom right because PtInRect does not consider
	// points on bottom or right to be in rect.
    rc.right = x + dxyHandle + 1;
    rc.bottom = y + dxyHandle + 1;
    return PtInRect(&rc, pt);
}

/*
 *	COleObject::CheckForHandleHit(&pt)
 *
 *	@mfunc	Check for a hit on any of the frame handles.
 *
 *	@rdesc	 NULL if no hit, cursor resource ID if there is a hit.
 */
LPTSTR COleObject::CheckForHandleHit(
	const POINT &pt)	//@parm POINT containing client coord. of the cursor.
{
	RECT	rc;

	// If object is not resizeable, no chance of hitting a resize handle!
	if(!(_pi.dwFlags & REO_RESIZABLE))
		return NULL;

	CopyRect(&rc, &_rcPos);

	if(!_dxyFrame)
		_dxyFrame = dxyFrameDefault;

	// Check to see if point is farther into the interior of the
	// object than the handles extent. If it is we can just bail.
	InflateRect(&rc, -(_dxyFrame + dxyHandle), -(_dxyFrame + dxyHandle));
	if(PtInRect(&rc, pt))
		return NULL;

	// Check to see if point is in any of the handles and
	// return the proper cursor ID if it is.
	InflateRect(&rc, dxyHandle, dxyHandle);

	if(InHandle(rc.left, rc.top, pt) ||
	   InHandle(rc.right-dxyHandle, rc.bottom-dxyHandle, pt))
	{
		return IDC_SIZENWSE;
	}
	if(InHandle(rc.left, rc.top+(rc.bottom-rc.top-dxyHandle)/2, pt) ||
	   InHandle(rc.right-dxyHandle,
			rc.top+(rc.bottom-rc.top-dxyHandle)/2, pt))
	{
		return IDC_SIZEWE;
	}
	if(InHandle(rc.left, rc.bottom-dxyHandle, pt) ||
	   InHandle(rc.right-dxyHandle, rc.top, pt))
	{
		return IDC_SIZENESW;
	}
	if(InHandle(rc.left+(rc.right-rc.left-dxyHandle)/2, rc.top, pt) ||
	   InHandle(rc.left+(rc.right-rc.left-dxyHandle)/2,
			rc.bottom-dxyHandle, pt))
	{
		return IDC_SIZENS;
	}
	return NULL;
}

/*
 * COleObject::DrawHandle(hdc, x, y)
 *
 * @mfunc  Draw a handle on the object frame at the specified coordinate
 */
void COleObject::DrawHandle(
	HDC hdc,	//@parm HDC to be drawn into
	int x,		//@parm x coordinate of upper-left corner of handle box
	int y)		//@parm y coordinate of upper-left corner of handle box
{
    RECT    rc;

	// Draw handle by inverting
    rc.left = x;
    rc.top = y;
    rc.right = x + dxyHandle;
    rc.bottom = y + dxyHandle;
    InvertRect(hdc, (LPRECT)&rc);
}

/*
 *	COleObject::DrawFrame(pdp, hdc, prc)
 *
 *	@mfunc	Draw a frame around the object.  Invert if required and
 *		include handles if required.
 */
void COleObject::DrawFrame(
	const CDisplay *pdp,    //@parm the display to draw to
	HDC             hdc,	//@parm the device context
	RECT           *prc)  //@parm the rect around which to draw
{
	if(_pi.dwFlags & REO_OWNERDRAWSELECT)
		return;

	RECT	rc;
	CopyRect(&rc, prc);

	if(_pi.dwFlags & REO_INVERTEDSELECT)
		InvertRect(hdc, &rc);				//Invert entire object

	else
	{
		// Just the border, so use a null brush
		SaveDC(hdc);
		SetROP2(hdc, R2_NOT);
		SelectObject(hdc, GetStockObject(NULL_BRUSH));
		Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
		RestoreDC(hdc, -1);
	}

	if(_pi.dwFlags & REO_RESIZABLE)
	{
		int     bkmodeOld;
		HPEN	hpen;
		LOGPEN	logpen;

		bkmodeOld = SetBkMode(hdc, TRANSPARENT);

		// Get frame width
		_dxyFrame = dxyFrameDefault;
		hpen = (HPEN)GetCurrentObject(hdc, OBJ_PEN);
		if(W32->GetObject(hpen, sizeof(LOGPEN), &logpen))
		{
			if(logpen.lopnWidth.x)
				_dxyFrame = (SHORT)logpen.lopnWidth.x;
		}

		// Draw handles inside rectangle boundary
 		InflateRect(&rc, -_dxyFrame, -_dxyFrame);

		LONG x = rc.left;

		DrawHandle(hdc, x, rc.top);
		DrawHandle(hdc, x, rc.top	 + (rc.bottom - rc.top - dxyHandle)/2);
		DrawHandle(hdc, x, rc.bottom - dxyHandle);

		x = rc.left + (rc.right - rc.left - dxyHandle)/2;
		DrawHandle(hdc, x, rc.top);
		DrawHandle(hdc, x, rc.bottom - dxyHandle);

		x = rc.right - dxyHandle;
		DrawHandle(hdc, x, rc.top);
		DrawHandle(hdc, x, rc.top + (rc.bottom - rc.top - dxyHandle)/2);
		DrawHandle(hdc, x, rc.bottom - dxyHandle);

		SetBkMode(hdc, bkmodeOld);
	}
}


/*
 *	COleObject::CreateDib (hdc)
 *
 *	@mfunc	Create DIB for Windows CE display
 */
void COleObject::CreateDib(
	HDC hdc)
{
	int				nCol = 0;
    BYTE            *pbDib;
	HGLOBAL			hnew = NULL;
	BYTE			*pbSrcBits;
	LPBITMAPINFO	pbmi = (LPBITMAPINFO) GlobalLock(_hdata);
	DWORD			dwPixelsPerRow = 0;
	DWORD			dwPixels = 0;

    if(pbmi->bmiHeader.biBitCount <= 8)
    {
	    nCol = 1 << pbmi->bmiHeader.biBitCount;

		// Calculate the number of pixels.  Account for DWORD alignment
		DWORD dwPixelsPerByte = 8 / pbmi->bmiHeader.biBitCount;
		DWORD dwBitsPerRow = pbmi->bmiHeader.biWidth * pbmi->bmiHeader.biBitCount;
		dwBitsPerRow = (dwBitsPerRow + 7) & ~7;				// Round up to byte boundary
		DWORD dwBytesPerRow = dwBitsPerRow / 8;
		dwBytesPerRow = (dwBytesPerRow + 3) & ~3;			// Round up to DWORD
		dwPixelsPerRow = dwBytesPerRow * dwPixelsPerByte;

		// Double check with original
		#ifdef DEBUG
		DWORD dwBlockSize = GlobalSize(_hdata);
		DWORD dwBitMapBytes = dwBlockSize - sizeof(BITMAPINFOHEADER) - (nCol * sizeof(RGBQUAD));
		DWORD dwBitMapPixels = dwBitMapBytes * dwPixelsPerByte;
		dwPixels = dwPixelsPerRow * pbmi->bmiHeader.biHeight;
		Assert(dwPixels == dwBitMapPixels);
		#endif
    }
	else
		dwPixelsPerRow = pbmi->bmiHeader.biWidth;

	dwPixels = dwPixelsPerRow * pbmi->bmiHeader.biHeight;

	pbSrcBits = (BYTE*)(pbmi) + sizeof(BITMAPINFOHEADER) + (nCol * sizeof(RGBQUAD));

#ifdef TARGET_NT

	// For NT viewing convert four color bitmaps to 16 color bitmap
	if(nCol == 4)
	{
		// First let's figure out how big the new memory block needs to be.
		DWORD cb = sizeof(BITMAPINFOHEADER) + (16 * sizeof(RGBQUAD));
		cb += dwPixels / 2;
		hnew = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, cb);
	
		// Now locate the interesting places
		LPBITMAPINFO pNewBmi = (LPBITMAPINFO) GlobalLock(hnew);
		BYTE *pNewBits = (BYTE*)(pNewBmi) + sizeof(BITMAPINFOHEADER) + (16 * sizeof(RGBQUAD));

		// Modify the header
		pNewBmi->bmiHeader = pbmi->bmiHeader;
		pNewBmi->bmiHeader.biBitCount = 4;
		pNewBmi->bmiHeader.biClrUsed = 4;

		// Set up the DIB RGB Colors.
		for (int i = 0; i < 16; i++)
		{
			BYTE data = 0;
			switch (i % 4)
			{
			case 0:
				break;
			case 1:
				data = 0x55;
				break;
			case 2:
				data = 0xAA;
				break;
			case 3:
				data = 0xFF;
				break;
			}
			pNewBmi->bmiColors[i].rgbBlue = data;
			pNewBmi->bmiColors[i].rgbGreen = data;
			pNewBmi->bmiColors[i].rgbRed = data;
			pNewBmi->bmiColors[i].rgbReserved = 0;
		}

		// Convert the byte array.
		for (DWORD j = 0; j < dwPixels; j++)
		{
			int iSrcByte = j / 4;

			BYTE bits = pbSrcBits[iSrcByte];
			bits >>= 6 - (j%4) * 2;
			bits &= 0x3;
			int iDstByte = j / 2;
			bits <<= 4 - (j%2) * 4;
			pNewBits[iDstByte] |= bits;
		}
		GlobalUnlock(pbmi);
		pbmi = pNewBmi;
		pbSrcBits = pNewBits;
	}
#endif

	_hdib = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, (void**)&pbDib, NULL, 0);
	if(_hdib == NULL)
	{
		_ped->GetCallMgr()->SetOutOfMemory();

        // V-GUYB:
        // Do not attempt to repaint this picture until the user starts typing in the
        // control. This allows the user to dismiss the oom that will appear and then
        // save the document, and then free up some space. If we don't do this here,
        // every time the oom msg is dismissed it will appear again. This doesn't allow
        // the user to save the document unless they can find some memory to free.
        _fDraw = FALSE;

		TRACEWARNSZ("Out of memory creating DIB");
		return;
	}

	DWORD nBytes;

	if(nCol)
	{
		DWORD nPixelsPerByte =  8 / pbmi->bmiHeader.biBitCount;
		nBytes = dwPixels / nPixelsPerByte;
	}
	else
		nBytes =  dwPixels * 4;			// Each pixel occupies 4 bytes in DIB
	CopyMemory(pbDib, pbSrcBits, nBytes);

	GlobalUnlock(pbmi);
	GlobalFree(hnew);
}

/*
 *	COleObject::DrawDib (hdc, prc)
 *
 *	@mfunc	Auxiliary function that draws the dib in the given dc
 */
void COleObject::DrawDib(
	HDC hdc,
	RECT *prc)
{
	if(!_hdib)
		CreateDib(hdc);

	// If _hdib is still NULL, just return.  Maybe out of memory.
	if(!_hdib)
		return;

	HDC hdcMem = CreateCompatibleDC(hdc);
	LPBITMAPINFO	pbmi = (LPBITMAPINFO) LocalLock(_hdata);
	SelectObject(hdcMem, _hdib);
    StretchBlt(hdc, prc->left, prc->top,
			prc->right - prc->left, prc->bottom - prc->top,
			hdcMem, 0, 0, pbmi->bmiHeader.biWidth, pbmi->bmiHeader.biHeight, SRCCOPY);
	GlobalUnlock(pbmi);
	DeleteDC(hdcMem);
}

/*
 *	COleObject::DrawObj (pdp, hdc, fMetafile, ppt, prcRender)
 *
 *	@mfunc	draws the object
 */
void COleObject::DrawObj(
	const CDisplay *pdp,	//@parm Display object for the view
	LONG		dypInch,	//@parm Resolution of device
	LONG		dxpInch,
	HDC			hdc,		//@parm Drawing HDC (can differ from display's)
	BOOL		fMetafile,	//@parm Whether the HDC is a metafile
	POINT *		ppt,		//@parm Top left corner of where to draw
	RECT  *		prcRender,	//@parm Pointer to render rectangle
	LONG		yBaselineLine,
	LONG		yDescentMaxCur)
{
	LONG			 adjust = 0;
	BOOL			 fMultipleSelect = FALSE;
	CObjectMgr *	 pobjmgr = _ped->GetObjectMgr();
	IViewObject *	 pvo;
	CDisplayPrinter *pdpPrint;
	RECT			 rc, rc1;
	LONG			 cpMin, cpMost;
	_ped->GetSelRangeForRender(&cpMin, &cpMost);
	BOOL			 fSelected = _cp >= cpMin && _cp < cpMost;

	SaveDC(hdc);

	if (fSelected)
		SetBkMode(hdc, OPAQUE);

	if(pdp->IsMain() && !(_pi.dwFlags & REO_OWNERDRAWSELECT))
	{
		if(fSelected)
		{
			if(cpMost - cpMin > 1)
				fMultipleSelect = TRUE;

			// The following overwrites the selection colors currently
			// selected into the hdc. We do this for RE 2.0 compatibility,
			// e.g., else selected name links in Outlook appear yellow
			// after the InvertRect() in DrawFrame() (altho the semicolon
			// blanks appear in selection colors). Note: we could define
			// REO_OWNERDRAWSELECT, which would bypass the following 2 lines
			// and suppress the InvertRect below and in DrawFrame(). Then
			// Outlook's From:, To:, and CC: would have correct selection
			// colors throughout.
			::SetTextColor(hdc, _ped->TxGetForeColor());
			::SetBkColor  (hdc, _ped->TxGetBackColor());
		}
	}

	if(_fInPlaceActive || !_fDraw)
	{
		// If we're inplace active, don't do anything; the server is
		// drawing for us. We also don't do anything prior to the fDraw
		// property being set
		return;
	}

	//REVIEW (keithcu) Do we need this?
	//Worse case, update only if pdp->IsMain(). This whole thing is ugly.
	if (pdp->IsMain())
		ResetPosRect(&adjust);		// Update position rectangle

	// Draw object where we are asked within rendering rectangle
	rc.left = ppt->x;
	rc.right = rc.left + W32->HimetricXtoDX(_sizel.cx, dxpInch);

	rc.bottom = ppt->y + yBaselineLine;
	rc.top = rc.bottom - W32->HimetricYtoDY(_sizel.cy, dypInch);

	if (_pi.dwFlags & REO_BELOWBASELINE)
		OffsetRect(&rc, 0, yDescentMaxCur);

	SetTextAlign(hdc, TA_TOP);

	SaveDC(hdc);  // calls to OLE object (IViewObject::Draw or OleDraw) might change HDC

	//Do clipping because OLE doesn't know where to draw
	IntersectClipRect(hdc, prcRender->left, prcRender->top,
					 prcRender->right, prcRender->bottom);

	if(_hdata)
	{
		// This is some Windows CE Dib, let's try the direct approach
		DrawDib(hdc, &rc);
	}
	else if(fMetafile)
	{
		if(_punkobj->QueryInterface(IID_IViewObject, (void **)&pvo)
				== NOERROR)
		{
			pdpPrint = (CDisplayPrinter *)pdp;
			rc1 = pdpPrint->GetPrintPage();

			// Fix up rc for Draw()
			rc1.bottom = rc1.bottom - rc1.top;			
			rc1.right = rc1.right - rc1.left;

			pvo->Draw(_pi.dvaspect, -1, NULL, NULL, 0, hdc, (RECTL *)&rc,
					(RECTL *)&rc1, NULL, 0);
			pvo->Release();
		}
	}
	else
		OleDraw(_punkobj, _pi.dvaspect, hdc, &rc);

	RestoreDC(hdc, -1);

	// Do selection stuff if this is for the main (screen) view.
	if(pdp->IsMain())
	{
		if(_pi.dwFlags & REO_OPEN)
			OleUIDrawShading(&rc, hdc);

		// If the object has been selected by clicking on it, draw
		// a frame and handles around it.  Otherwise, if we are selected
		// as part of a range, invert ourselves.
		if(!fMetafile && pobjmgr->GetSingleSelect() == this)
			DrawFrame(pdp, hdc, &rc);

		else if(fMultipleSelect)
			InvertRect(hdc, &rc);
	}
	RestoreDC(hdc, -1);
}

/*
 *	COleObject::Delete (publdr)
 *
 *	@mfunc	deletes this object from the backing store _without_
 *			making outgoing calls.  The commit on generated anti-events
 *			will handle the outgoing calls
 */
void COleObject::Delete(
	IUndoBuilder *publdr)
{

	Assert(_fInUndo == FALSE);
	_fInUndo = TRUE;

	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Remove((ITxNotify *)this);

	if(publdr)
	{
		// The anti-event will take care of calling IOO::Close for us
		IAntiEvent *pae = gAEDispenser.CreateReplaceObjectAE(_ped, this);
		if(pae)
			publdr->AddAntiEvent(pae);
	}
	else
	{
		Close(OLECLOSE_NOSAVE);
		MakeZombie();
	}

	// If we're being deleted, we can't be selected anymore
	_pi.dwFlags &= ~REO_SELECTED;
	_fDraw = 0;
}

/*
 *	COleObject::Restore()
 *
 *	@mfunc	restores the object from the undo state back into the
 *			backing store
 *
 *			No outgoing calls will be made
 */
void COleObject::Restore()
{
	Assert(_fInUndo);

	_fInUndo = FALSE;
	_fDraw = TRUE;

	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);
}

/*
 *	COleObject::SetREOSELECTED (fSelect)
 *
 *	@mfunc	cmember set REO_SELECTED state
 */
void COleObject::SetREOSELECTED(
	BOOL fSelect)
{
	_pi.dwFlags &= ~REO_SELECTED;
	if(fSelect)
		_pi.dwFlags |= REO_SELECTED;
}

/*
 *	COleObject::Close(dwSave)
 *
 *	@mfunc	closes this object
 */
void COleObject::Close(
	DWORD	dwSave)		//same as IOleObject::Close
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::Close");

	if(!_punkobj)
		return;

	IOleObject *poo;
	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		poo->Close(dwSave);
		poo->Release();
	}
}

/*
 *	COleObject::ScrollObject(dx, dy, prcScroll)
 *
 *	@mfunc	updates _rcPos if we were scrolled
 */
void COleObject::ScrollObject(
	LONG dx,			//@parm Change in the x direction
	LONG dy,			//@parm Change in the y direction
	LPCRECT prcScroll)	//@parm Rect that is being scrolled
{
	RECT rcInter;

	// If we're inplace active, OnReposition will handle the scrolling
	if(!_fInPlaceActive && !_fGuardPosRect &&
		IntersectRect(&rcInter, &_rcPos, prcScroll))
	{
		OffsetRect(&_rcPos, dx, dy);
	}
}

				
//
//	PRIVATE methods
//
/*
 *	COleObject::~COleObject()
 *
 *	@mfunc	destructor
 */
COleObject::~COleObject()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::~COleObject");

	CleanupState();
}

/*
 *	COleObject::SavePrivateState()
 *
 *	@mfunc	Saves information such as the aspect and various flags
 *	into the object's storage.
 *
 *	@devnote	This method is used mostly for compatibility with
 *	richedit 1.0--we save the same information they did.
 *
 *	Also note that this method returns void--even if any particular
 *	call failes, we should be able to "recover" and limp along.
 *	Richedit 1.0 also had this behavior.
 */
void COleObject::SavePrivateState()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::SavePrivateState");
	Assert(_pstg);

	IStream *	pstm;
	HRESULT hr = _pstg->CreateStream(szSiteFlagsStm, STGM_READWRITE |
					STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);
    if(IsZombie())
        return;

	if(hr == NOERROR)
	{
		pstm->Write(&_pi, sizeof(PersistedInfo), NULL);
		pstm->Release();
	}
}

/*
 *	COleObject::FetchObjectExtents()
 *
 *	@mfunc 	determines the object's size in himetric.  Typically, this
 *			is achieved via IOleObject::GetExtent, but some error
 *			recovery is implemented
 *
 *	@rdesc	void.  _sizel is updated
 */
void COleObject::FetchObjectExtents()
{
	HRESULT hr = NOERROR;
	IOleObject *poo;
	IViewObject2 *pvo;
	CDisplay *pdp;

    if(IsZombie())
        return;

	// We _don't_ want to make calls to GetExtent if:
	// (1) We have outstanding updates to _sizel for which we
	//		haven't successfully called SetExtent
	// (2) This is a PaintBrush object and the most recent call
	//		to SetExtent for this PB object failed

	if(_fAspectChanged || !(_fSetExtent || (_fIsPaintBrush && _fPBUseLocalSizel)))
	{	
		// try IOleObject::GetExtent as long as we shouldn't try for
		// the metafile first.

		// If this flag was set, it has done its job so turn it off.
		_fAspectChanged = FALSE;

		if(!(_pi.dwFlags & REO_GETMETAFILE))
		{
			hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
			if(hr == NOERROR)
			{
				hr = poo->GetExtent(_pi.dvaspect, &_sizel);
				poo->Release();
			}
			if(IsZombie())
				return;
		}
		else
			hr = E_FAIL;

		if(hr != NOERROR)
		{
			if(_punkobj->QueryInterface(IID_IViewObject2, (void **)&pvo) == NOERROR)
			{
				hr = pvo->GetExtent(_pi.dvaspect, -1, NULL, &_sizel);
				pvo->Release();
			}
		}

	    if(IsZombie())
	        return;

		if(hr != NOERROR || _sizel.cx == 0 || _sizel.cy == 0)
			_sizel.cx = _sizel.cy = 2000;
	}
	// If _fSetExtent==TRUE, we've made a change to _sizel for which
	// we haven't called IOleObject::SetExtent successfully.  Therefore
	// fall through with existing _sizel.

	// Update our position rectangle
	pdp = _ped->_pdp;

	_rcPos.right  = _rcPos.left + pdp->HimetricXtoDX(_sizel.cx);
	_rcPos.bottom = _rcPos.top  + pdp->HimetricYtoDY(_sizel.cy);
}

/*
 *	COleObject::ConnectObject()
 *
 *	@mfunc	setup the necessary advises to the embedded object.
 *
 *	@rdesc 	HRESULT
 *
 *	@comm	This code is similar to ole2ui's OleStdSetupAdvises
 */
HRESULT COleObject::ConnectObject()
{
	IViewObject *pvo;
	IOleObject *poo;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::ConnectObject");
	
    if(IsZombie())
        return CO_E_RELEASED;
	
	Assert(_punkobj);

	if(_punkobj->QueryInterface(IID_IViewObject, (void **)&pvo) == NOERROR)
	{
		pvo->SetAdvise(_pi.dvaspect, ADVF_PRIMEFIRST, (IAdviseSink *)this);
		pvo->Release();
	}

    if(IsZombie())
        return CO_E_RELEASED;
	
	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr == NOERROR)
	{
		hr = poo->Advise((IAdviseSink *)this, &_dwConn);

		CObjectMgr *pobjmgr = _ped->GetObjectMgr();
		Assert(pobjmgr);

		// The doc may be NULL, but not the app.  Don't do anything
		// if the app name is NULL
		if(pobjmgr->GetAppName())
		{
			hr = poo->SetHostNames(pobjmgr->GetAppName(),
						pobjmgr->GetDocName());
		}
		poo->Release();
	}

    if(IsZombie())
        return CO_E_RELEASED;
	
	OleSetContainedObject(_punkobj, TRUE);
	return hr;
}

/*
 *	COleObject::DisconnectObject
 *
 *	@mfunc	reverses the connections made in ConnectObject and releases
 *			the object.  Note that the object's storage is _NOT_
 *			released.
 */
void COleObject::DisconnectObject()
{
	IOleObject * poo = NULL;
	IViewObject *pvo = NULL;

	if(IsZombie())
		return;		// Already Disconnected.

	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		poo->SetClientSite(NULL);
		if(_dwConn)
			poo->Unadvise(_dwConn);
	
		poo->Release();
	}

	if(_punkobj->QueryInterface(IID_IViewObject, (void **)&pvo) == NOERROR)
	{
		pvo->SetAdvise(_pi.dvaspect, ADVF_PRIMEFIRST, NULL);
		pvo->Release();
	}

	CoDisconnectObject(_punkobj, NULL);
	SafeReleaseAndNULL(&_punkobj);
}

/*
 *	COleObject::MakeZombie()
 *
 *	@mfunc	Force this object to enter a zombie state.  This
 *      is called when we should be gone but aren't.  It cleans
 *      up our state and flags us so we don't do nasty things
 *		between now and the time were are deleted.
 *
 */
void COleObject::MakeZombie()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::MakeZombie");

	CleanupState();
    Zombie();
}

/*
 *	COleObject::CleanupState()
 *
 *	@mfunc	Called on delete and when we become zombied.  It cleans
 *		up our member data and any other dependencies that need to
 *		be resolved.
 */
void COleObject::CleanupState()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::CleanupState");
	
    if(_ped && !_fInUndo)
	{
		CNotifyMgr *pnm = _ped->GetNotifyMgr();
		if(pnm)
			pnm->Remove((ITxNotify *)this);

		_ped = NULL;
	}

	DisconnectObject();

	if(_pstg)
		SafeReleaseAndNULL((IUnknown**)&_pstg);

	if(_hdib)
	{
		::DeleteObject(_hdib);
		_hdib = NULL;
	}
	GlobalFree(_hdata);
	_hdata = NULL;
	if(_pimageinfo)
	{
		delete _pimageinfo;
		_pimageinfo = NULL;
	}
}	

/*
 *	COleObject::ActivateObj	(uiMsg, wParam, lParam)
 *	
 *	@mfunc Activates the object.
 *
 *	@rdesc
 *		BOOL	Whether object has been activated.
 */
BOOL COleObject::ActivateObj(
	UINT uiMsg,
	WPARAM wParam,
	LPARAM lParam)
{
	LPOLEOBJECT		poo;
	HWND			hwnd;
	MSG				msg;
	DWORD			dwPos;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::AcitvateObj");

	if(_ped->TxGetWindow(&hwnd) != NOERROR)
		return FALSE;

	ResetPosRect();

	// Fill in message structure
	msg.hwnd = hwnd;
	msg.message = uiMsg;
	msg.wParam = wParam;
	msg.lParam = lParam;
	msg.time = GetMessageTime();
	dwPos = GetMessagePos();
	msg.pt.x = (LONG) LOWORD(dwPos);
	msg.pt.y = (LONG) HIWORD(dwPos);

	// Force this object to be selected, if it isn't already
	// Update the selection before making the outgoing call
	if(!(_pi.dwFlags & REO_SELECTED))
	{
		CTxtSelection *psel = _ped->GetSel();
		if(psel)
			psel->SetSelection(_cp, _cp + 1);
	}

	// Execute the primary verb
	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		_fActivateCalled = TRUE;

		// Make sure we tell the object its size has changed if we haven't
		// already notified it.
		if(_fSetExtent)
			SetExtent(SE_ACTIVATING);

		HRESULT	hr;
		hr = poo->DoVerb(OLEIVERB_PRIMARY, &msg, (LPOLECLIENTSITE)this, 0, hwnd, &_rcPos);

#ifndef MACPORT
		if(FAILED(hr))
		{
			ENOLEOPFAILED	enoleopfailed;

			enoleopfailed.iob = _ped->_pobjmgr->FindIndexForCp(GetCp());
			enoleopfailed.lOper = OLEOP_DOVERB;
			enoleopfailed.hr = hr;
	        _ped->TxNotify(EN_OLEOPFAILED, &enoleopfailed);
		}
#endif
	    poo->Release();

		if(_fInPlaceActive && !(_pi.dwFlags & REO_INPLACEACTIVE))
		{
			CObjectMgr *pobjmgr = _ped->GetObjectMgr();
			Assert(!pobjmgr->GetInPlaceActiveObject());	
			pobjmgr->SetInPlaceActiveObject(this);
			_pi.dwFlags |= REO_INPLACEACTIVE;
		}
		_fActivateCalled = FALSE;
	}
	else
		return FALSE;

	return TRUE;
}

/*
 *	COleObject::DeActivateObj
 *	
 *	@mfunc Deactivates the object.
 *
 */
HRESULT COleObject::DeActivateObj(void)
{
	IOleInPlaceObject * pipo;
	IOleObject *poo;
	MSG msg;
	HRESULT hr = NOERROR;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::DeActivateObj");

	if (_fDeactivateCalled)
	{
		// There are multiple paths through the deactive code. The assumption
		// with this logic is that it is more disconcerting for an app to
		// get multiple deactivate calls than the opposite. This might
		// prove to be an incorrect assumption. This go put in because I
		// added a DeActivateObj call in DeActivateObj where there wasn't
		// one before and I was afraid that this could cause problems because
		// apps might get a call that they didn't have before. It is important
		// to note that the opposite might be the case. (a-rsail).
		return NOERROR;
	}

	_fDeactivateCalled = TRUE;

	ResetPosRect();

	if(_punkobj->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo)
		== NOERROR)
	{
		hr  =_punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
		if(hr == NOERROR)
		{
			// This code is a bit different from 1.0, but seems to
			// make things work a bit better.  Basically, we've taken a leaf
			// from various sample apps and do the most brute force "de-activate"
			// possible (you'd think just one call would be enough ;-)

			// Don't bother with the error return here.
			pipo->UIDeactivate();
			
			// Fake something
			ZeroMemory(&msg, sizeof(MSG));
			msg.message = WM_LBUTTONDOWN;	
			_ped->TxGetWindow(&msg.hwnd);

			// Again, don't bother checking for errors; we need to
			// plow through and get rid of stuff as much as possible.
			poo->DoVerb(OLEIVERB_HIDE, &msg, (IOleClientSite *)this,
			-1, msg.hwnd, &_rcPos);

			// COMPATIBILITY ISSUE (alexgo): the RE1.0 code did some funny
			// stuff with undo here, but I don't think it's necessary now
			// with our multi-level undo model.
			hr = pipo->InPlaceDeactivate();
			poo->Release();
		}
	    pipo->Release();
	}

	_fDeactivateCalled = FALSE;
	return hr;
}

/*
 *	COleObject::Convert (rclsidNew,	lpstrUserTypeNew)
 *
 *	@mfunc	Converts the object to the specified class.  Does reload
 *		the object but does NOT force an update (caller must do this).
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT COleObject::Convert(
	REFCLSID rclsidNew,			//@parm Destination clsid
	LPCSTR	 lpstrUserTypeNew)	//@parm New user type name
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Convert");

	CLIPFORMAT cfOld;
	CLSID clsidOld;
	LPOLESTR szUserTypeOld = NULL;
	HRESULT hr;
	HRESULT hrLatest;
	UsesMakeOLESTR;


	// If object has no storage, return
	if(!_pstg)
		return ResultFromScode(E_INVALIDARG);

	// Read the old class, format, and user type in
	if ((hr = ReadClassStg(_pstg, &clsidOld)) ||
		(hr = ReadFmtUserTypeStg(_pstg, &cfOld, &szUserTypeOld)))
	{
		return hr;
	}

	// Unload object
	Close(OLECLOSE_SAVEIFDIRTY);
	_punkobj->Release();

    if(IsZombie())
        return CO_E_RELEASED;

	// Write new class and user type, but old format, into storage
	if ((hr = WriteClassStg(_pstg, rclsidNew)) ||
		(hr = WriteFmtUserTypeStg(_pstg, cfOld,
			(LPOLESTR) MakeOLESTR(lpstrUserTypeNew))) ||
		(hr = SetConvertStg(_pstg, TRUE)) ||
		((hr = _pstg->Commit(0)) && (hr = _pstg->Commit(STGC_OVERWRITE))))
	{
		// Uh oh, we're in a bad state; rewrite the original info
		(VOID) WriteClassStg(_pstg, clsidOld);
		(VOID) WriteFmtUserTypeStg(_pstg, cfOld, szUserTypeOld);
	}

    if(IsZombie())
        return CO_E_RELEASED;

	// Reload the object and connect. If we can't reload it, delete it.
	hrLatest = OleLoad(_pstg, IID_IOleObject, (LPOLECLIENTSITE) this,
			(void **)&_punkobj);

	if(hrLatest != NOERROR)
	{
		CRchTxtPtr	rtp(_ped, _cp);

		// we don't want the delete of this object to go on the undo
		// stack.  We use a space so that cp's will work out right for
		// other undo actions.
		rtp.ReplaceRange(1, 1, L" ", NULL, -1);
	}
	else
		ConnectObject();

	// Free the old
	CoTaskMemFree(szUserTypeOld);
	return hr ? hr : hrLatest;
}

/*
 *	COleObject::ActivateAs (rclsid, rclsidAs)
 *
 *	@mfunc	Handles a request by the user to activate all objects of a particular
 *		class as objects of another class.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT COleObject::ActivateAs(
	REFCLSID rclsid,
	REFCLSID rclsidAs)
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::ActivateAs");

	IOleObject * poo = NULL;
	CLSID	clsid;

	// Get clsid of object
	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr == NOERROR)
	{
		// NOTE:  We are depending on the behavior of GetUserClassID to
		// return the current clsid of the object (not the TreatAs id).
		// This should hold true as long as long as we haven't reloaded
		// it yet.  If there are problems with ActivateAs in the future,
		// this might be a suspect.
		hr = poo->GetUserClassID(&clsid);
		poo->Release();
	}

	if(hr != NOERROR)
		return hr;
	
    if(IsZombie())
        return CO_E_RELEASED;

	// Check to see if object clsid matches clsid to be treated as something
	// else. If it is we need to unload and reload the object.
	if(IsEqualCLSID(clsid, rclsid))
	{
		// Unload object
		Close(OLECLOSE_SAVEIFDIRTY);
		_punkobj->Release();

		if(IsZombie())
			return CO_E_RELEASED;

		// Reload object and connect. If we can't reload it, delete it.
		hr = OleLoad(_pstg, IID_IOleObject, (LPOLECLIENTSITE) this,
				(void **)&_punkobj);

		if(hr != NOERROR)
		{
			CRchTxtPtr	rtp(_ped, _cp);

			// We don't want the delete of this object to go on the undo
			// stack.  We use a space so that cp's will work out right for
			// other undo actions.
			rtp.ReplaceRange(1, 1, L" ", NULL, -1);
		}
		else
			ConnectObject();
	}
	return hr;
}

/*
 *	COleObject::SetLinkAvailable(fAvailable)
 *
 *	@mfunc
 *		Allows client to tell us whether the link is available or not.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT COleObject::SetLinkAvailable(
	BOOL fAvailable)	//@parm	if TRUE, make object linkable
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SetLinkAvailable");
	
	// If this is not a link, return
	if(!(_pi.dwFlags & REO_LINK))
		return E_INVALIDARG;

	// Set flag as appropriate
	_pi.dwFlags &= ~REO_LINKAVAILABLE;
	if(fAvailable)
		_pi.dwFlags |= REO_LINKAVAILABLE;

	return NOERROR;
}

/*
 *	COleObject::WriteTextInfoToEditStream(pes)
 *
 *	@mfunc
 *		Used for textize support,  Tries to determine the text
 *		representation for an object and then writes that info
 *		to the given stream.  The only thing this is particularly useful
 *		for is to support richedit1.0's TEXTIZED data format.
 *
 *	@rdesc
 *		LONG				Number of chras written..
 */
LONG COleObject::WriteTextInfoToEditStream(
	EDITSTREAM *pes)
{
	LONG cch;
	LONG cbWritten = 0;
	IOleObject *poo;
	IDataObject *pdataobj = NULL;
	STGMEDIUM med;
	char *pch;			//we only deal with ANSI data here

	HANDLE		hGlobal;

	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr == NOERROR)
	{
		hr = poo->GetClipboardData(0, &pdataobj);
        poo->Release();
	}

	if(FAILED(hr))
	{
		hr = _punkobj->QueryInterface(IID_IDataObject, (void **)&pdataobj);
		if(FAILED(hr))
		{
			pes->dwError = (DWORD) E_FAIL;
			goto Default;
		}
	}

	med.tymed = TYMED_HGLOBAL;
	med.pUnkForRelease = NULL;
	med.hGlobal = NULL;

	hr = pdataobj->GetData(&g_rgFETC[iAnsiFETC], &med);
	if(FAILED(hr))
		pes->dwError = (DWORD)hr;
	else
	{
		hGlobal = med.hGlobal;
		pch = (char *)GlobalLock(hGlobal);
		if(pch)
		{
			for (cch = 0; pch[cch]; cch++);
			pes->dwError = pes->pfnCallback(pes->dwCookie, (BYTE *)pch, cch,
												&cbWritten);
			GlobalUnlock(hGlobal);
		}
		ReleaseStgMedium(&med);
	}

Default:
	if(cbWritten <= 0)
	{
		char ch = ' ';

		pes->pfnCallback(pes->dwCookie, (BYTE *)&ch, sizeof(char), &cbWritten);
		pes->dwError = 0;
	}

    pdataobj->Release();
	return cbWritten;
}

/*
 *	COleObject::SetDvaspect (dvaspect)
 *
 *	@mfunc	Allows client to tell us which aspect to use and force us
 *		to recompute positioning and redraw.
 */
void COleObject::SetDvaspect(
	DWORD dvaspect)	//@parm	the aspect to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SetDvaspect");

	_pi.dvaspect = dvaspect;
	
	// Force FetchObjectExtents to call through
	_fAspectChanged = TRUE;

	// Cause ourselves to redraw and update
	OnViewChange(dvaspect, (DWORD) -1);
}

/*
 *	COleObject::HandsOffStorage
 *
 *	@mfunc	See IPersistStore::HandsOffStorage.
 *
 */
void COleObject::HandsOffStorage(void)
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::HandsOffStorage");

	// Free storage we currently have, if we have one.
	SafeReleaseAndNULL((IUnknown**)&_pstg);
}

/*
 *	COleObject::SaveCompleted
 *
 *	@mfunc	See IPersistStore::SaveCompleted.
 */
void COleObject::SaveCompleted(
	LPSTORAGE lpstg)	//@parm	new storage
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SaveCompleted");

	// Did our caller give us a new storage to remember?
	if(lpstg)
	{
		// Free storage we currently have, if we have one
		if(_pstg)
			SafeReleaseAndNULL((IUnknown**)&_pstg);

		// Remember storage we are given, since we are given one
		lpstg->AddRef();
		_pstg = lpstg;
	}
}

/*
 *	SetAllowedResizeDirections
 *	
 *	@func Resizing helper function
 *
 */
static void SetAllowedResizeDirections(
	const POINT  & pt,
	const RECT   & rc,
	      LPTSTR   lphand,
	      BOOL   & fTop,
	      BOOL   & fBottom,
	      BOOL   & fLeft,
	      BOOL   & fRight)
{
   	fTop = abs(pt.y - rc.top) < abs(pt.y - rc.bottom);
	fBottom = !fTop;
	fLeft = abs(pt.x - rc.left) < abs(pt.x - rc.right);
	fRight = !fLeft;

	if(lphand == IDC_SIZENS)
		fLeft = fRight = FALSE;

	else if(lphand == IDC_SIZEWE)
		fTop = fBottom = FALSE;
}

/*
*	SetRestriction.
 *	
 *	@func Resizing helper function determines bounding rectangle for resizing.
 */
static void SetRestriction(
    RECT  & rc,
	HWND    hwnd,
	DWORD   dwScroll)
{
	GetClientRect(hwnd, &rc);
	InflateRect(&rc, -1, -1);			// So rectangle is visible

	// Allow objects to grow larger than the window in the
	// directions which have scrollbars
	if(dwScroll & WS_HSCROLL)
		rc.right = MAXLONG;

	if(dwScroll & WS_VSCROLL)
		rc.bottom = MAXLONG;
}

/*
 *	Restrict (&pt, &rc)
 *	
 *	@func Resizing helper function bounds a point within a rectangle
 */
static void Restrict(
	POINT  &pt,
	RECT   &rc)
{
	if(pt.x < rc.left)
		pt.x = rc.left;
	else if(pt.x > rc.right)
		pt.x = rc.right;

	if(pt.y < rc.top)
		pt.y = rc.top;
	else if(pt.y > rc.bottom)
		pt.y = rc.bottom;
}

/*
 *	COleObject::HandleResize (&pt)
 *	
 *	@mfunc Deal with object resizing.
 *
 *	@rdesc	BOOL
 */
BOOL COleObject::HandleResize(
	const POINT &pt)
{
	LPTSTR lphand;
	DWORD  dwFlags = _pi.dwFlags;
 	HWND   hwnd;
	RECT   rcOld;
	RECT   rcRestrict;
	BOOL   fTop, fBottom, fLeft, fRight;
	BOOL   fEscape;
	CDisplay *pdp = _ped->_pdp;

	if(!(dwFlags & REO_SELECTED)	||
		!(dwFlags & REO_RESIZABLE)	||
		(lphand = CheckForHandleHit(pt)) == NULL || !pdp)
	{
		return FALSE;
	}
 	
	HDC hdc = pdp->GetDC();
	rcOld = _rcPos;				// Save old size
	_ped->TxGetWindow(&hwnd);
	SetCapture(hwnd);
	
	SetRestriction(rcRestrict, hwnd, _ped->TxGetScrollBars());

	SetAllowedResizeDirections(pt, _rcPos, lphand,
		                       fTop, fBottom, fLeft, fRight);
	
	// Erase and redraw frame without handles.
	DrawFrame(pdp, hdc, &_rcPos);
	_pi.dwFlags = REO_NULL;
	DrawFrame(pdp, hdc, &_rcPos);

	fEscape = FALSE;
	const INT vkey = GetSystemMetrics(SM_SWAPBUTTON) ? VK_RBUTTON : VK_LBUTTON;
	while (GetAsyncKeyState(vkey) & 0x8000)
	{		
		POINT ptLast = pt;
		POINT ptCur;
		MSG msg;

		// Stop if the ESC key has been pressed
		if(GetAsyncKeyState(VK_ESCAPE) & 0x0001)
		{
			fEscape = TRUE;
			break;
		}
		
		GetCursorPos(&ptCur);
		ScreenToClient(hwnd, &ptCur);

// GetCursorPos() isn't supported on WinCE. We have  it hacked to
// be GetMessagePos() which unfortunately in this case will cause
// ptCur to never change. By removing this check we end up drawing
// multiple times when the user pauses during a resize.
#ifndef UNDER_CE
		// If mouse hasn't moved, try again
		if((ptCur.x == ptLast.x) && (ptCur.y == ptLast.y))
			continue;
#endif

		ptLast = ptCur;
		Restrict(ptCur, rcRestrict);

		// Erase old rectangle, update rectangle, and redraw
		DrawFrame(pdp, hdc, &_rcPos);	
		if(fLeft)   _rcPos.left   = ptCur.x;
		if(fRight)  _rcPos.right  = ptCur.x;
		if(fTop)    _rcPos.top    = ptCur.y;
		if(fBottom) _rcPos.bottom = ptCur.y;
		// Keep a minimun width and height
		INT xWidthSys = pdp->GetXWidthSys();
		INT yHeightSys = pdp->GetYHeightSys();
		if(_rcPos.right - _rcPos.left < xWidthSys)
		{
			if(fLeft) _rcPos.left = _rcPos.right - xWidthSys;
			if(fRight) _rcPos.right = _rcPos.left + xWidthSys;
		}
		if(_rcPos.bottom - _rcPos.top < yHeightSys)
		{
			if(fTop) _rcPos.top = _rcPos.bottom - yHeightSys;
			if(fBottom) _rcPos.bottom = _rcPos.top + yHeightSys;
		}

		DrawFrame(pdp, hdc, &_rcPos);
		// FUTURE: (joseogl): It would be cool if we could do something
		// bettter here, but for now, it appears to be necessary.
		Sleep(100);
		
		// Eat input messages
		if (PeekMessage(&msg, 0, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE) ||
			PeekMessage(&msg, 0, WM_MOUSEFIRST,
			                      WM_MOUSELAST, PM_REMOVE | PM_NOYIELD) ||
			PeekMessage(&msg, 0, WM_NCMOUSEFIRST,
			                      WM_NCMOUSELAST, PM_REMOVE | PM_NOYIELD))
		{
			// Break out of the loop if the Escape key was pressed
		    if(msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE)
			{
	        	fEscape = TRUE;
				break;
			}
		}
	}

	DrawFrame(pdp, hdc, &_rcPos);
  	ReleaseCapture();
	RECT rcNew = _rcPos;
	_rcPos = rcOld;
 	_pi.dwFlags = dwFlags;

	// If user aborted, then we skip the resizing stuff
	if(fEscape)
		DrawFrame(pdp, hdc, &_rcPos);
	else
	{
		EnableGuardPosRect();
		Resize(rcNew);
		DrawFrame(pdp, hdc, &_rcPos);
		DisableGuardPosRect();
	}
	pdp->ReleaseDC(hdc);
	return TRUE;
}

/*
 *	COleObject::Resize(rcNew)
 *	
 *	@mfunc Set new object size.  Handle undo details.
 */
void COleObject::Resize(
	const RECT &rcNew)
{
	CDisplay *	pdp = _ped->_pdp;
	SIZEL		sizelold = _sizel;

	// Change the size of our internal representation.
	_sizel.cx = pdp->DXtoHimetricX(rcNew.right - rcNew.left);
	_sizel.cy = pdp->DYtoHimetricY(rcNew.bottom - rcNew.top);

	//If size didn't really change, don't do anything else.
	if(_sizel.cx != sizelold.cx || _sizel.cy != sizelold.cy)
	{
		if(_ped->_fUseUndo)
		{
			CGenUndoBuilder undobldr(_ped, UB_AUTOCOMMIT);
			IAntiEvent *pae;

			pae = gAEDispenser.CreateResizeObjectAE(_ped, this, _rcPos);
			if(pae)
				undobldr.AddAntiEvent(pae);
		}
		_rcPos.bottom = _rcPos.top + pdp->HimetricYtoDY(_sizel.cy);
		_rcPos.right = _rcPos.left + pdp->HimetricXtoDX(_sizel.cx);

		SetExtent(SE_NOTACTIVATING);

		// Force a redraw that will stretch the object.
		pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, _cp, _cp + 1);

		_ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);
	}
}

/*
 *	COleObject::OnReposition (dx, dy)
 *	
 *	@mfunc Set object's new position.  May have changed as a result of scrolling.
 */
void COleObject::OnReposition(
	LONG dx,
	LONG dy)
{
	IOleInPlaceObject *pipo;
	RECT rcClip;

	if(!_fInPlaceActive)
	{
		// If we're not inplace active, don't do anything
		return;
	}

	_ped->_pdp->GetViewRect(rcClip);
	_rcPos.left += dx;
	_rcPos.right += dx;
	_rcPos.top += dy;
	_rcPos.bottom += dy;

	if(_punkobj->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo)
		== NOERROR)
	{
		pipo->SetObjectRects(&_rcPos, &rcClip);
        pipo->Release();
	}
}

 /*
 *	COleObject::ResetPosRect(pAdjust)
 *	
 *	@mfunc Recompute the object's position rectangle from its cp.
 */
void COleObject::ResetPosRect(
	 LONG *pAdjust)		//@parm output adjustment needed for positioning below baseline
{
	CRchTxtPtr rtp(_ped, 0);
	POINT pt, pt1;
	LONG yHeight = _ped->_pdp->HimetricYtoDY(_sizel.cy);
	
	rtp.SetCp(_cp);
	if(_ped->_pdp->PointFromTp(rtp, NULL, FALSE, pt, NULL, TA_TOP) == -1)
		return;
	_rcPos.top = pt.y;
	_ped->_pdp->PointFromTp(rtp, NULL, FALSE, pt1, NULL,
		(_pi.dwFlags & REO_BELOWBASELINE) ? TA_BOTTOM : TA_BASELINE);

	if(pAdjust)
		*pAdjust = 0;

	if(pt1.y - pt.y > yHeight)
	{
		// If line is bigger than object move object down.
		_rcPos.top += pt1.y - pt.y - yHeight;
		if(pAdjust)
			*pAdjust = pt1.y - pt.y - yHeight;
	}

	_rcPos.bottom = _rcPos.top + yHeight;
	_rcPos.left = pt.x;
	_rcPos.right = _rcPos.left + _ped->_pdp->HimetricXtoDX(_sizel.cx);
}

#ifdef DEBUG
void COleObject::DbgDump(DWORD id){
	Tracef(TRCSEVNONE, "Object #%d %X: cp = %d , rect = (%d, %d, %d, %d)",id,this,_cp,_rcPos.top,_rcPos.left,_rcPos.bottom,_rcPos.right);
}
#endif

/*	
 *	COleObject:SetExtent(iActivating)
 *
 *	@mfunc A wrapper around IOleObject::SetExtent which makes some additional
 *			checks if the first call to IOleObject::SetExtent fails.
 *
 *	@rdesc HRESULT
 */
HRESULT COleObject::SetExtent(
	int iActivating) //@parm indicates if object is currently being activated
{
	LPOLEOBJECT poo;

	// If we are connected to a link object, the native extent can't be change,
	// so don't bother doing anything here.
	if(_pi.dwFlags & REO_LINK)
	{
		// So we don't call GetExtents on remeasuring.
		_fSetExtent = TRUE;
		return NOERROR;
	}

	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr != NOERROR)
		return hr;

	// If we are about to activate the object, fall through and OleRun the
	// object prior to attempting to SetExtent.  Otherwise, attempt a SetExtent
	// directly.
	if(iActivating == SE_NOTACTIVATING)
	{
		// By default, we will call SetExtent when the object is next activated.
		_fSetExtent = TRUE;

		hr = poo->SetExtent(_pi.dvaspect, &_sizel);

		DWORD dwStatus;

		// If the server is not running we need to to some additional
		// checking. If it was, we do not need to call SetExtent again.

		// Find out if OLEMISC_RECOMPOSEONRESIZE is set.  If it is, we should
		// run the object and call setextent.  If not, we defer calling set
		// extent until we are ready to activate the object.
		if(!(hr == OLE_E_NOTRUNNING &&
			poo->GetMiscStatus(_pi.dvaspect, &dwStatus) == NOERROR &&
			(dwStatus & OLEMISC_RECOMPOSEONRESIZE)))
		{
			goto DontRunAndSetAgain;
		}
		// Fall through and attempt the SetExtent again after running the object
	}

    {
        SIZEL sizelsave = _sizel;
        OleRun(_punkobj);		// This call causes _sizel to be reset
                                // via OLE and FetchObjectExtents.
        _sizel = sizelsave;
    }
	poo->SetExtent(_pi.dvaspect, &_sizel);

DontRunAndSetAgain:
	if((hr == NOERROR) ||
		(iActivating == SE_NOTACTIVATING && hr != OLE_E_NOTRUNNING))
	{
		_fSetExtent = FALSE;
	}
	// If the server is still not running, we try again at
	// activation time.  Otherwise the server has either
	// done its thing or it doesn't do resize.  Either way
	// we don't bother trying again at activation time.

	if(hr == NOERROR && _fIsPaintBrush)
	{
		SIZEL sizelChk;

		poo->GetExtent(_pi.dvaspect, &sizelChk);
		_fPBUseLocalSizel = !(sizelChk.cx == _sizel.cx &&
								sizelChk.cy == _sizel.cy);
		// HACK:  Calls to SetExtent on PaintBrush objects may not
		// 	actually change the object extents.  In such cases,
		//	we will rely on local _sizel for PaintBrush object extents.
	}
	poo->Release();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\cfpf.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	CFPF.C -- -- RichEdit CCharFormat and CParaFormat Classes |
 *
 *	Created: <nl>
 *		9/1995 -- Murray Sargent <nl>
 *
 *	@devnote
 *		The this ptr for all methods points to an internal format class, i.e.,
 *		either a CCharFormat or a CParaFormat, which uses the cbSize field as
 *		a reference count.  The pCF or pPF argument points at an external
 *		CCharFormat or CParaFormat class, that is, pCF->cbSize and pPF->cbSize
 *		give the size of their structure.  The code still assumes that both
 *		internal and external forms are derived from the CHARFORMAT(2) and
 *		PARAFORMAT(2) API structures, so some redesign would be necessary to
 *		obtain a more space-efficient internal form.
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_array.h"					// for fumemmov()
#include "_rtfconv.h"				// for IsCharSetValid()
#include "_font.h"					// for GetFontNameIndex(), GetFontName()

ASSERTDATA


// Table of formatting info for Normal and Heading styles
const STYLEFORMAT g_Style[] =		// {dwEffects; yHeight}
{							// Measurements in points
	{CFE_BOLD,				14},	// Heading 1
	{CFE_BOLD + CFE_ITALIC,	12},	// Heading 2
	{0,						12},	// Heading 3
	{CFE_BOLD,				12},	// Heading 4
	{0,						11},	// Heading 5
	{CFE_ITALIC,			11},	// Heading 6
	{0,						 0},	// Heading 7
	{CFE_ITALIC,			 0},	// Heading 8
	{CFE_BOLD + CFE_ITALIC,	 9}		// Heading 9
};


BOOL IsValidTwip(LONG dl)
{
	static const LONG dlMax =  0x00FFFFFF;
	static const LONG dlMin = -0x00FFFFFF;
	if (dl > dlMax || dl < dlMin)
		return FALSE;
	return TRUE;
}

//------------------------- CCharFormat Class -----------------------------------

/*
 *	CCharFormat::Apply(pCF, dwMask, dwMask2)
 *
 *	@mfunc
 *		Apply *<p pCF> to this CCharFormat as specified by nonzero bits in
 *		dwMask and dwMask2
 *
 *	@devnote
 *		Autocolor is dealt with through a neat little hack made possible
 *		by the choice CFE_AUTOCOLOR = CFM_COLOR (see richedit.h).  Hence
 *		if <p pCF>->dwMask specifies color, it automatically resets autocolor
 *		provided (<p pCF>->dwEffects & CFE_AUTOCOLOR) is zero.
 *
 *		*<p pCF> is an external CCharFormat, i.e., it's either a CHARFORMAT
 *		or a CHARFORMAT2 with the appropriate size given by cbSize. But
 *		this CCharFormat is internal and cbSize is used as a reference count.
 */
HRESULT CCharFormat::Apply (
	const CCharFormat *pCF,	//@parm	CCharFormat to apply to this CF
	DWORD dwMask,			//@parm Mask corresponding to CHARFORMAT2
	DWORD dwMask2)			//@parm Mask for additional internal parms
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Apply");

	DWORD	dwEffectMask = dwMask & CFM_EFFECTS2;
	bool	fNewCharset = false;

	// Reset effect bits to be modified and OR in supplied values
	_dwEffects &= ~dwEffectMask;
	_dwEffects |= pCF->_dwEffects & dwEffectMask;

	// Ditto for additional effects given by dwMask2
	dwEffectMask = dwMask2 & 0xBBFC0000;	// Don't allow autocolors, sub/sups
	_dwEffects	&= ~dwEffectMask;
	_dwEffects	|= pCF->_dwEffects & dwEffectMask;

	// If CFM_BOLD is specified, it overrides the font weight
	if(dwMask & CFM_BOLD)
		_wWeight = (pCF->_dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;

	// Handle CFM_COLOR since it's overloaded with CFE_AUTOCOLOR
	if(dwMask & CFM_COLOR)
		_crTextColor = pCF->_crTextColor;

	if(dwMask & ~CFM_EFFECTS)				// Early out if only dwEffects
	{										//  is modified. Note that
		if(dwMask & CFM_SIZE)				//  CFM_EFFECTS includes CFM_COLOR
		{
			// If dwMask2 CFM2_USABLEFONT bit is set, pCF->_yHeight (from
			// EM_SETFONTSIZE wparam) is signed increment in points.
			_yHeight = dwMask2 & CFM2_USABLEFONT
					? GetUsableFontHeight(_yHeight, pCF->_yHeight)
					: pCF->_yHeight;
		}

		if(dwMask & CFM_OFFSET)
			_yOffset = pCF->_yOffset;

		if((dwMask & CFM_CHARSET) && IsCharSetValid(pCF->_bCharSet) &&

			// Caller guarantees no check needed
			(dwMask2 & (CFM2_NOCHARSETCHECK | CFM2_MATCHFONT) ||

			// Caller is itemizer. Change to ANSI_CHARSET only if current is BiDi,
			// dont change if current is DBCS/FE charset or symbol.
			(dwMask2 & CFM2_SCRIPT && 
			 (!pCF->_bCharSet && IsBiDiCharSet(_bCharSet) || 
			  pCF->_bCharSet && !IsFECharSet(_bCharSet) && !IsSymbolOrOEM(_bCharSet) && !(_dwEffects & CFE_RUNISDBCS))) ||

			// Caller is not itemizer. Allow consistent direction
			(!(dwMask2 & CFM2_SCRIPT) && 
			 (!(IsRTLCharSet(_bCharSet) ^ IsRTLCharSet(pCF->_bCharSet)) ||
			  IsSymbolOrOEM(pCF->_bCharSet)))))
		{
			fNewCharset = TRUE;
			_bCharSet = pCF->_bCharSet;
		}
			
		if ((dwMask2 & (CFM2_MATCHFONT | CFM2_ADJUSTFONTSIZE)) == (CFM2_MATCHFONT | CFM2_ADJUSTFONTSIZE) &&
			_bCharSet != pCF->_bCharSet && (dwMask & CFM_SIZE))
		{
			// Check if we need to adjust the font size
			_yHeight = W32->GetPreferredFontHeight(
				(dwMask2 & CFM2_UIFONT) != 0,
				pCF->_bCharSet,
				_bCharSet,
				_yHeight);
		}

		if(dwMask & CFM_FACE)
		{
			_bPitchAndFamily = pCF->_bPitchAndFamily;
			_iFont = pCF->_iFont;
			
			WCHAR wch = GetFontName((LONG)_iFont)[0];
			
			if (!fNewCharset && wch == L'\0')				
			{
				// API to choose default font								
				INT		uCpg = GetLocaleCodePage();
				SHORT	iDefFont;
				BYTE	yDefHeight;
				BYTE	bDefPitchAndFamily;

				// Get default font name and charset
				bool	fr = W32->GetPreferredFontInfo(
							uCpg, FALSE, iDefFont, 
							(BYTE&)yDefHeight, bDefPitchAndFamily );
					
				if (fr) 
				{
					_bCharSet = GetCharSet(uCpg);
					_iFont = iDefFont;
						
					if(!(dwMask & CFM_SIZE) || _yHeight < yDefHeight * 20)	// Setup default height if needed.
						_yHeight = yDefHeight * 20;

					_bPitchAndFamily = bDefPitchAndFamily;
				}				
			}
			else if (GetCharFlags(wch) & fFE && !IsFECharSet(_bCharSet))
			{
				// make sure that we dont end up having DBCS facename with Non-FE charset
				DWORD dwFontSig;
				if (GetFontSignatureFromFace(_iFont, &dwFontSig))
				{
					dwFontSig &= (fFE >> 8);	// Only interest in FE charset
					if (dwFontSig)
						_bCharSet = GetFirstAvailCharSet(dwFontSig);
				}
			}
		}

		if (!(dwMask2 & CFM2_CHARFORMAT) &&
			(dwMask & ~CFM_ALL))					// CHARFORMAT2 extensions
		{
			if((dwMask & (CFM_WEIGHT | CFM_BOLD)) == CFM_WEIGHT) 
			{			
				_wWeight		= pCF->_wWeight;
				_dwEffects	   |= CFE_BOLD;			// Set above-average
				if(_wWeight < 551)					//  weights to bold
					_dwEffects &= ~CFE_BOLD;
			}

			if(dwMask & CFM_BACKCOLOR)
				_crBackColor	= pCF->_crBackColor;

			if(dwMask & CFM_LCID)
				_lcid			= pCF->_lcid;

			if(dwMask & CFM_SPACING)
				_sSpacing		= pCF->_sSpacing;

			if(dwMask & CFM_KERNING)
				_wKerning		= pCF->_wKerning;

			if(dwMask & CFM_STYLE)
				_sStyle			= pCF->_sStyle;

			if(dwMask & CFM_UNDERLINETYPE)
			{
				_bUnderlineType	= pCF->_bUnderlineType;
				if(!(dwMask & CFM_UNDERLINE))		// If CFE_UNDERLINE
				{									//  isn't defined,
					_dwEffects	&= ~CFE_UNDERLINE;	//  set it according to
					if(_bUnderlineType)				//  bUnderlineType
						_dwEffects |= CFE_UNDERLINE;
				}
			}

			if((dwMask & CFM_ANIMATION) && pCF->_bAnimation <= 18)
				_bAnimation		= pCF->_bAnimation;

			if(dwMask & CFM_REVAUTHOR)
				_bRevAuthor		= pCF->_bRevAuthor;
    	}
	}

	if(dwMask2 & CFM2_SCRIPT)
		_wScript = pCF->_wScript;

	return NOERROR;
}

/*
 *	CCharFormat::ApplyDefaultStyle(Style)
 *
 *	@mfunc	
 *		Set default style properties in this CCharFormat
 */
void CCharFormat::ApplyDefaultStyle (
	LONG Style)		//@parm Style to use
{
	Assert(IsKnownStyle(Style));

	if(IsHeadingStyle(Style))
	{
		LONG i = -Style + STYLE_HEADING_1;
		_dwEffects = (_dwEffects & 0xFFFFFF00) | g_Style[i].bEffects;
		_wWeight = (_dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;

		if(g_Style[i].bHeight)
			_yHeight = g_Style[i].bHeight * 20;

		DWORD dwFontSig;				
		LONG  iFont = _iFont;			// Save _iFont in case Arial doesn't
		_iFont = IFONT_ARIAL;			//  support _bCharSet

		GetFontSignatureFromFace(_iFont, &dwFontSig);
		if(GetFontSig(_bCharSet) & dwFontSig)
			_bPitchAndFamily = FF_SWISS;// Arial supports _bCharSet
		else
			_iFont = iFont;				// Restore iFont
	}
}

/*
 *	CCharFormat::Compare(pCF)
 *
 *	@mfunc
 *		Compare this CCharFormat to *<p pCF>
 *
 *	@rdesc
 *		TRUE if they are the same not including _cRefs
 */
BOOL CCharFormat::Compare (
	const CCharFormat *pCF) const	//@parm	CCharFormat to compare this
{									//  CCharFormat to
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Compare");

	return !CompareMemory(this, pCF, sizeof(CCharFormat));
}

/*
 *	CCharFormat::Delta(pCF, fCHARFORMAT)
 *
 *	@mfunc
 *		Calculate dwMask for differences between this CCharformat and
 *		*<p pCF>
 *
 *	@rdesc
 *		return dwMask of differences (1 bit means a difference)
 */
DWORD CCharFormat::Delta (
	CCharFormat *pCF,		//@parm	CCharFormat to compare this one to
	BOOL fCHARFORMAT) const	//@parm Only compare CHARFORMAT members
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Delta");
												// Collect bits for properties
	LONG dw = _dwEffects ^ pCF->_dwEffects;		//  that change. Note: auto
												//  color is handled since
	if(_yHeight		!= pCF->_yHeight)			//  CFM_COLOR = CFE_AUTOCOLOR
		dw |= CFM_SIZE;

	if(_yOffset		!= pCF->_yOffset)
		dw |= CFM_OFFSET;

	if(_crTextColor	!= pCF->_crTextColor)
		dw |= CFM_COLOR;

	if(_bCharSet	!= pCF->_bCharSet)
		dw |= CFM_CHARSET;

	if(_iFont		!= pCF->_iFont)
		dw |= CFM_FACE;

	if(fCHARFORMAT)
		return dw;							// Done with CHARFORMAT stuff

	if(_crBackColor	!= pCF->_crBackColor)	// CHARFORMAT2 stuff
		dw |= CFM_BACKCOLOR;

	if(_wKerning	!= pCF->_wKerning)
		dw |= CFM_KERNING;

	if(_lcid		!= pCF->_lcid)
		dw |= CFM_LCID;

	if(_wWeight		!= pCF->_wWeight)
		dw |= CFM_WEIGHT;

	if(_sSpacing	!= pCF->_sSpacing)
		dw |= CFM_SPACING;

	if(_sStyle		!= pCF->_sStyle)
		dw |= CFM_STYLE;

	if(_bUnderlineType != pCF->_bUnderlineType)
		dw |= CFM_UNDERLINETYPE;

	if(_bAnimation	!= pCF->_bAnimation)
		dw |= CFM_ANIMATION;

	if(_bRevAuthor	!= pCF->_bRevAuthor)
		dw |= CFM_REVAUTHOR;

	return dw;
}

/*
 *	CCharFormat::fSetStyle(dwMask)
 *
 *	@mfunc
 *		return TRUE iff pCF specifies that the style should be set. See
 *		code for list of conditions for this to be true
 *
 *	@rdesc
 *		TRUE iff pCF specifies that the style _sStyle should be set
 */
BOOL CCharFormat::fSetStyle(DWORD dwMask, DWORD dwMask2) const
{
	return	dwMask != CFM_ALL2		&&
			dwMask &  CFM_STYLE		&&
			!(dwMask2 & CFM2_CHARFORMAT) &&
			IsKnownStyle(_sStyle);
}

/*
 *	CCharFormat::Get(pCF, CodePage)
 *
 *	@mfunc
 *		Copy this CCharFormat to the CHARFORMAT or CHARFORMAT2 *<p pCF>
 */
void CCharFormat::Get (
	CHARFORMAT2 *pCF2,		//@parm CHARFORMAT to copy this CCharFormat to
	UINT CodePage) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Get");

	pCF2->dwMask		= CFM_ALL;				// Use CHARFORMAT
	pCF2->dwEffects		= _dwEffects;
	pCF2->yHeight		= _yHeight;
	pCF2->yOffset		= _yOffset;
	pCF2->crTextColor	= _crTextColor;
	pCF2->bCharSet		= GetGdiCharSet(_bCharSet);
	pCF2->bPitchAndFamily = _bPitchAndFamily;

	UINT cb = pCF2->cbSize;
	const WCHAR *pch = GetFontName((LONG)_iFont);

	AssertSz((CodePage != 1200) ^ IsValidCharFormatW(pCF2),
		"CCharFormat::Get: wrong codepage for CHARFORMAT");
	
	if(CodePage != 1200)
	{
		if(_dwEffects & CFE_FACENAMEISDBCS)
		{
			// The face name is actually DBCS stuffed into the unicode
			// buffer, so simply un-stuff this DBCS into the ANSI string
			char *pachDst = (char *)pCF2->szFaceName;

			while(*pch)
				*pachDst++ = *pch++;

			*pachDst = 0;
		}
		else
		{
			MbcsFromUnicode((char *)pCF2->szFaceName, LF_FACESIZE,
							pch, -1, CodePage, UN_NOOBJECTS);
		}
	}
	else
		wcscpy(pCF2->szFaceName, pch);
	
	if (cb == sizeof(CHARFORMATW) || cb == sizeof(CHARFORMATA))	// We're done
		return;

	char *pvoid = (char *)&pCF2->wWeight;
	if(pCF2->cbSize == sizeof(CHARFORMAT2A))
		pvoid -= sizeof(CHARFORMAT2W) - sizeof(CHARFORMAT2A);
	else
		Assert(pCF2->cbSize == sizeof(CHARFORMAT2));// Better be a CHARFORMAT2

	pCF2->dwMask = CFM_ALL2;
	CopyMemory(pvoid, &_wWeight, 3*sizeof(DWORD));
	CopyMemory(pvoid + 4*sizeof(DWORD),  &_sStyle,  2*sizeof(DWORD));
	*(DWORD *)(pvoid + 3*sizeof(DWORD)) = 0;
}

/*
 *	CCharFormat::InitDefault(hfont)
 *
 *	@mfunc	
 *		Initialize this CCharFormat with information coming from the font
 *		<p hfont>
 *	
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : E_FAIL
 */
HRESULT CCharFormat::InitDefault (
	HFONT hfont)		//@parm Handle to font info to use
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::InitDefault");

	LOGFONT lf;
	BOOL	fUseStockFont = hfont == NULL;

	ZeroMemory(this, sizeof(CCharFormat));

	// If hfont isn't defined, get LOGFONT for default font
	if(!hfont)
		hfont = W32->GetSystemFont();

	// Get LOGFONT for passed hfont
	if(!W32->GetObject(hfont, sizeof(LOGFONT), &lf))
		return E_FAIL;

	_yHeight = (lf.lfHeight * LY_PER_INCH) / W32->GetYPerInchScreenDC();
	if(_yHeight <= 0)
		_yHeight = -_yHeight;
	else if (fUseStockFont)		// This is Cell Height for System Font case
		_yHeight -= (W32->GetSysFontLeading() * LY_PER_INCH) / W32->GetYPerInchScreenDC();
	else
	{
		// This is Cell Height, need to get the character height by subtracting 
		// the tm.tmInternalLeading.
		CLock		lock;
		HDC			hdc = W32->GetScreenDC();
		HFONT		hOldFont = SelectFont(hdc, hfont);
		TEXTMETRIC	tm;

		if(hOldFont)
		{
			if(GetTextMetrics(hdc, &tm))			
    			_yHeight -= (tm.tmInternalLeading * LY_PER_INCH) / W32->GetYPerInchScreenDC();

			SelectFont(hdc, hOldFont); 
		}
	}

#ifndef MACPORTStyle
	_dwEffects = (CFM_EFFECTS | CFE_AUTOBACKCOLOR) & ~(CFE_PROTECTED | CFE_LINK);

#else
	_dwEffects = (CFM_EFFECTS | CFE_AUTOBACKCOLOR | CFE_OUTLINE | CFE_SHADOW)
					& ~(CFE_PROTECTED | CFE_LINK);
	if(!(lf.lfWeight & FW_OUTLINE))
		_dwEffects &= ~CFE_OUTLINE;
	if (!(lf.lfWeight & FW_SHADOW))
		_dwEffects &= ~CFE_SHADOW;
#endif

	if(lf.lfWeight < FW_BOLD)
		_dwEffects &= ~CFE_BOLD;

	if(!lf.lfItalic)
		_dwEffects &= ~CFE_ITALIC;

	if(!lf.lfUnderline)
		_dwEffects &= ~CFE_UNDERLINE;

	if(!lf.lfStrikeOut)
		_dwEffects &= ~CFE_STRIKEOUT;

	_wWeight		= (WORD)lf.lfWeight;
	_lcid			= GetSystemDefaultLCID();
	_bCharSet		= lf.lfCharSet;
	_bPitchAndFamily= lf.lfPitchAndFamily;
	_iFont			= GetFontNameIndex(lf.lfFaceName);
	_bUnderlineType	= CFU_UNDERLINE;			// Default solid underlines
												// Are gated by CFE_UNDERLINE

	// Qualify the charformat produced by incoming hfont before exit.
	// We did this to make sure that the charformat we derived from hfont is usable
	// since caller can send us bad font like given facename can't handle given charset.
	if (!fUseStockFont)
	{
		DWORD dwFontSig;
		if (GetFontSignatureFromFace(_iFont, &dwFontSig) &&
			!(GetFontSig(_bCharSet) & dwFontSig))
			_bCharSet = GetFirstAvailCharSet(dwFontSig);
	}

	return NOERROR;
}

/*
 *	CCharFormat::Set(pCF, CodePage)
 *
 *	@mfunc
 *		Copy the CHARFORMAT or CHARFORMAT2 *<p pCF> to this CCharFormat 
 */
void CCharFormat::Set (
	const CHARFORMAT2 *pCF2, 	//@parm	CHARFORMAT to copy to this CCharFormat
	UINT CodePage)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Set");
	
	_dwEffects			= pCF2->dwEffects;
	_bCharSet			= pCF2->bCharSet;
	_bPitchAndFamily	= pCF2->bPitchAndFamily;
	if(pCF2->dwMask & CFM_FACE)
	{
		AssertSz((CodePage != 1200) ^ IsValidCharFormatW(pCF2),
			"CCharFormat::Set: wrong codepage for CHARFORMAT");

		if(CodePage != 1200)
		{
			WCHAR sz[LF_FACESIZE + 1];
			UnicodeFromMbcs(sz, LF_FACESIZE, (char *)pCF2->szFaceName, LF_FACESIZE,
							CodePage);
			_iFont		= GetFontNameIndex(sz);
		}
		else
			_iFont		= GetFontNameIndex(pCF2->szFaceName);
	}
	_yHeight			= Get16BitTwips(pCF2->yHeight);
	_yOffset			= Get16BitTwips(pCF2->yOffset);
	_crTextColor		= pCF2->crTextColor;
	
	UINT cb = pCF2->cbSize;
	if(cb == sizeof(CHARFORMATW) || cb == sizeof(CHARFORMATA))
	{
		_dwEffects |= CFE_AUTOBACKCOLOR;
		_bUnderlineType = CFU_UNDERLINE;
		ZeroMemory((LPBYTE)&_wWeight,
			sizeof(CCharFormat) - offsetof(CCharFormat, _wWeight));
		return;
	}

	char *pvoid = (char *)&pCF2->wWeight;
	if(pCF2->cbSize == sizeof(CHARFORMAT2A))
		pvoid -= sizeof(CHARFORMAT2W) - sizeof(CHARFORMAT2A);
	else
		Assert(pCF2->cbSize == sizeof(CHARFORMAT2));// Better be a CHARFORMAT2

	CopyMemory(&_wWeight, pvoid, 3*sizeof(DWORD));
	CopyMemory(&_sStyle,  pvoid + 4*sizeof(DWORD),  2*sizeof(DWORD));
}


//------------------------- CParaFormat Class -----------------------------------

/*
 *	CParaFormat::AddTab(tbPos, tbAln, tbLdr)
 *
 *	@mfunc
 *		Add tabstop at position <p tbPos>, alignment type <p tbAln>, and
 *		leader style <p tbLdr>
 *
 *	@rdesc
 *		(success) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		Tab struct that overlays LONG in internal _rgxTabs is
 *
 *			DWORD	tabPos : 24;
 *			DWORD	tabType : 4;
 *			DWORD	tabLeader : 4;
 */
HRESULT CParaFormat::AddTab (
	LONG	tbPos,		//@parm New tab position
	LONG	tbAln,		//@parm New tab alignment type
	LONG	tbLdr,		//@parm New tab leader style
	BOOL	fInTable,	//@parm True if simulating cells
	LONG *	prgxTabs)	//@parm Where the tabs are
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::AddTab");

	if (!fInTable &&
		((DWORD)tbAln > tomAlignBar ||				// Validate arguments
		 (DWORD)tbLdr > tomEquals ||				// Comparing DWORDs causes
		 (DWORD)tbPos > 0xffffff || !tbPos))		//  negative values to be
	{												//  treated as invalid
		return E_INVALIDARG;
	}

	LONG iTab;
	LONG tbValue = tbPos + (tbAln << 24) + (tbLdr << 28);

	for(iTab = 0; iTab < _bTabCount &&			// Determine where to
		tbPos > GetTabPos(prgxTabs[iTab]); 		//  insert new tabstop
		iTab++) ;

	if(iTab >= MAX_TAB_STOPS)
		return S_FALSE;

	LONG tbPosCurrent = GetTabPos(prgxTabs[iTab]);
	if(iTab == _bTabCount || tbPosCurrent != tbPos)
	{
		if(_bTabCount >= MAX_TAB_STOPS)
			return S_FALSE;

		MoveMemory(&prgxTabs[iTab + 1],			// Shift array down
			&prgxTabs[iTab],					//  (unless iTab = Count)
			(_bTabCount - iTab)*sizeof(LONG));

		_bTabCount++;							// Increment tab count
	}
	prgxTabs[iTab] = tbValue;
	return NOERROR;
}

/*
 *	CParaFormat::Apply(pPF)
 *
 *	@mfunc
 *		Apply *<p pPF> to this CParaFormat as specified by nonzero bits in
 *		<p pPF>->dwMask
 */
HRESULT CParaFormat::Apply (
	const CParaFormat *pPF,	//@parm CParaFormat to apply to this PF
	DWORD	dwMask)			//@parm mask to use
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Apply");

	const DWORD dwMaskApply	= dwMask;
	BOOL		fPF = dwMask & PFM_PARAFORMAT;
	WORD		wEffectMask;

	if(dwMaskApply & PFM_NUMBERING)
		_wNumbering = pPF->_wNumbering;

	if(dwMaskApply & PFM_OFFSET)
	{
		if (!IsValidTwip(pPF->_dxOffset))
			return E_INVALIDARG;
		_dxOffset = pPF->_dxOffset;
	}

	if(dwMaskApply & PFM_STARTINDENT)
	{
		if (!IsValidTwip(pPF->_dxStartIndent))
			return E_INVALIDARG;

		_dxStartIndent = pPF->_dxStartIndent;
	}
	else if(dwMaskApply & PFM_OFFSETINDENT)
	{
		if (!IsValidTwip(pPF->_dxStartIndent))
			return E_INVALIDARG;

		// bug fix #5761
		LONG dx = max(0, _dxStartIndent + pPF->_dxStartIndent);

		// Disallow shifts that move start of first or subsequent lines left of left margin.
		// Normally we just make indent zero in paraformat check below, 
		//	but in the case of bullet we want some space left.
		
		if(!_wNumbering || dx + _dxOffset >= 0)
			_dxStartIndent = dx;
	}

	if(dwMaskApply & PFM_RIGHTINDENT)
	{
		if (!IsValidTwip(pPF->_dxRightIndent))
			return E_INVALIDARG;

		_dxRightIndent = pPF->_dxRightIndent;
	}

	if(dwMaskApply & PFM_ALIGNMENT)
	{
		if(!fPF && !IN_RANGE(PFA_LEFT, pPF->_bAlignment, PFA_SNAP_GRID))
		{
			TRACEERRORSZ("CParaFormat::Apply: invalid Alignment ignored");
			return E_INVALIDARG;
		}
		if(pPF->_bAlignment <= PFA_SNAP_GRID)
			_bAlignment = pPF->_bAlignment;
	}

	// Save whether this is a table now.
	BOOL fInTablePrev = InTable();

	if((dwMaskApply & PFM_TABSTOPS) && !fInTablePrev)
	{
		_bTabCount = (BYTE)min(pPF->_bTabCount, MAX_TAB_STOPS);
		_bTabCount = (BYTE)max(_bTabCount, 0);
		_iTabs	   = pPF->_iTabs;
		AssertSz(!_bTabCount || _iTabs >= 0,
			"CParaFormat::Apply: illegal _iTabs value");
	}

	// AymanA: 11/7/96 Moved the wEffects set before the possible return NOERROR.
	wEffectMask	= (WORD)(dwMaskApply >> 16);	// Reset effect bits to be
	_wEffects &= ~wEffectMask;					//  modified and OR in
	_wEffects |= pPF->_wEffects & wEffectMask;	//  supplied values

	if(InTable())
		_wEffects &= ~PFE_RTLPARA;				// Tables use paras for rows

	else if(fInTablePrev)
	{
		// This was a table now it isn't. We must dump the tab information
		// because it is totally bogus.
		_iTabs = -1;
		_bTabCount = 0;
	}

	if ((dwMaskApply & PFM_RTLPARA) && !(dwMaskApply & PFM_ALIGNMENT) &&
		_bAlignment != PFA_CENTER)
	{
		_bAlignment = IsRtlPara() ? PFA_RIGHT : PFA_LEFT;
	}

	// PARAFORMAT check
	if(fPF)
	{
		if(dwMaskApply & (PFM_STARTINDENT | PFM_OFFSET))
		{
			if(_dxStartIndent < 0)				// Don't let indent go
				_dxStartIndent = 0;				//  negative

			if(_dxStartIndent + _dxOffset < 0)	// Don't let indent +
				_dxOffset = -_dxStartIndent;	//  offset go negative
		}
		return NOERROR;							// Nothing more for
	}											//  PARAFORMAT

	// PARAFORMAT2 extensions
	if(dwMaskApply & PFM_SPACEBEFORE)
	{
		_dySpaceBefore = 0;

		if (pPF->_dySpaceBefore > 0)
			_dySpaceBefore	= pPF->_dySpaceBefore;
	}

	if(dwMaskApply & PFM_SPACEAFTER)
	{
		_dySpaceAfter = 0;

		if (pPF->_dySpaceAfter > 0)
			_dySpaceAfter	= pPF->_dySpaceAfter;
	}

	if(dwMaskApply & PFM_LINESPACING)
	{
		_dyLineSpacing	  = pPF->_dyLineSpacing;
		_bLineSpacingRule = pPF->_bLineSpacingRule;
	}

	if(dwMaskApply & PFM_OUTLINELEVEL)
		_bOutlineLevel	= pPF->_bOutlineLevel;

	if(dwMaskApply & PFM_STYLE)
		HandleStyle(pPF->_sStyle);

	Assert((_bOutlineLevel & 1) ^ IsHeadingStyle(_sStyle));

	if(dwMaskApply & PFM_SHADING)
	{
		_wShadingWeight	= pPF->_wShadingWeight;
		_wShadingStyle	= pPF->_wShadingStyle;
	}

	if(dwMaskApply & PFM_NUMBERINGSTART)
		_wNumberingStart = pPF->_wNumberingStart;

	if(dwMaskApply & PFM_NUMBERINGSTYLE)
		_wNumberingStyle = pPF->_wNumberingStyle;

	if(dwMaskApply & PFM_NUMBERINGTAB)
		_wNumberingTab	= pPF->_wNumberingTab;

	if(dwMaskApply & PFM_BORDER)
	{
		_dwBorderColor	= pPF->_dwBorderColor;
		_wBorders		= pPF->_wBorders;
		_wBorderSpace	= pPF->_wBorderSpace;
		_wBorderWidth	= pPF->_wBorderWidth;
	}

#ifdef DEBUG
	ValidateTabs();
#endif // DEBUG

	return NOERROR;
}

/*
 *	CParaFormat::ApplyDefaultStyle(Style)
 *
 *	@mfunc	
 *		Copy default properties for Style
 */
void CParaFormat::ApplyDefaultStyle (
	LONG Style)		//@parm Style to apply
{
	Assert(IsKnownStyle(Style));

	if(IsHeadingStyle(Style))				// Set Style's dySpaceBefore,
	{										//  dySpaceAfter (in twips)
		_dySpaceBefore = 12*20;				//  (same for all headings)
		_dySpaceAfter  =  3*20;
		_wNumbering	   = 0;					// No numbering
	}
}

/*
 *	CParaFormat::DeleteTab(tbPos)
 *
 *	@mfunc
 *		Delete tabstop at position <p tbPos>
 *
 *	@rdesc
 *		(success) ? NOERROR : S_FALSE
 */
HRESULT CParaFormat::DeleteTab (
	LONG	tbPos,			//@parm Tab position to delete
	LONG *	prgxTabs)		//@parm Tab array to use
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::DeleteTab");

	if(tbPos <= 0)
		return E_INVALIDARG;

	LONG Count	= _bTabCount;
	for(LONG iTab = 0; iTab < Count; iTab++)	// Find tabstop for position
	{
		if(GetTabPos(prgxTabs[iTab]) == tbPos)
		{
			MoveMemory(&prgxTabs[iTab],			// Shift array down
				&prgxTabs[iTab + 1],			//  (unless iTab is last tab)
				(Count - iTab - 1)*sizeof(LONG));
			_bTabCount--;						// Decrement tab count and
			return NOERROR;						//  signal no error
		}
	}
	return S_FALSE;
}

/*
 *	CParaFormat::Delta(pPF)
 *
 *	@mfunc
 *		return mask of differences between this CParaFormat and *<p pPF>.
 *		1-bits indicate corresponding parameters differ; 0 indicates they
 *		are the same
 *
 *	@rdesc
 *		mask of differences between this CParaFormat and *<p pPF>
 */
DWORD CParaFormat::Delta (
	CParaFormat *pPF,		 		//@parm	CParaFormat to compare this
	BOOL		fPARAFORMAT) const	//		CParaFormat to
{									
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Delta");

	LONG dwT = 0;								// No differences yet

	if(_wNumbering	  != pPF->_wNumbering)
		dwT |= PFM_NUMBERING;					// _wNumbering values differ

	if(_dxStartIndent != pPF->_dxStartIndent)
		dwT |= PFM_STARTINDENT;					// ...

	if(_dxRightIndent != pPF->_dxRightIndent)
		dwT |= PFM_RIGHTINDENT;

	if(_dxOffset	  != pPF->_dxOffset)
		dwT |= PFM_OFFSET;

	if(_bAlignment	  != pPF->_bAlignment)
		dwT |= PFM_ALIGNMENT;

	AssertSz(pPF->_bTabCount >= 0 && pPF->_bTabCount <= MAX_TAB_STOPS,
		"RTR::GetParaFormat(): illegal tab count");

	if (_bTabCount != pPF->_bTabCount)
		dwT |= PFM_TABSTOPS;
	else if (_bTabCount > 0)
	{
		const LONG	*pTabs1 = GetTabs();
		const LONG	*pTabs2 = pPF->GetTabs();
		if (pTabs1 != pTabs2 &&
			(pTabs1 == 0 || pTabs2 == 0 || CompareMemory(pTabs1, pTabs2, _bTabCount * sizeof(LONG))))
			dwT |= PFM_TABSTOPS;
	}

	dwT |= (_wEffects ^ pPF->_wEffects) << 16;


	if(!fPARAFORMAT)
	{
		if(_dySpaceBefore	!= pPF->_dySpaceBefore)
			dwT |= PFM_SPACEBEFORE;

		if(_dySpaceAfter	!= pPF->_dySpaceAfter)
			dwT |= PFM_SPACEAFTER;

		if (_dyLineSpacing	!= pPF->_dyLineSpacing	||
		   _bLineSpacingRule!= pPF->_bLineSpacingRule)
		{
			dwT |= PFM_LINESPACING;
		}

		if(_sStyle			!= pPF->_sStyle)
			dwT |= PFM_STYLE;

		if (_wShadingWeight	!= pPF->_wShadingWeight ||
			_wShadingStyle	!= pPF->_wShadingStyle)
		{
			dwT |= PFM_SHADING;
		}

		if(_wNumberingStart	!= pPF->_wNumberingStart)
			dwT |= PFM_NUMBERINGSTART;

		if(_wNumberingStyle	!= pPF->_wNumberingStyle)
			dwT |= PFM_NUMBERINGSTYLE;

		if(_wNumberingTab	!= pPF->_wNumberingTab)
			dwT |= PFM_NUMBERINGTAB;

		if (_wBorders		!= pPF->_wBorders	 ||
			_wBorderWidth	!= pPF->_wBorderWidth ||
			_wBorderSpace	!= pPF->_wBorderSpace ||
			_dwBorderColor	!= pPF->_dwBorderColor)
		{
			dwT |= PFM_BORDER;
		}
	}

	return dwT;
}		

#define PFM_IGNORE	(PFM_OUTLINELEVEL | PFM_COLLAPSED | PFM_PARAFORMAT | PFM_BOX)

/*
 *	CParaFormat::fSetStyle()
 *
 *	@mfunc
 *		Return TRUE iff this PF specifies that the style should be set.
 *		See code for list of conditions for this to be true
 *
 *	@rdesc
 *		TRUE iff pCF specifies that the style _sStyle should be set
 */
BOOL CParaFormat::fSetStyle(DWORD dwMask) const
{
	return	(dwMask & ~PFM_IGNORE) != PFM_ALL2	&&
			dwMask &  PFM_STYLE					&&
			!(dwMask & PFM_PARAFORMAT)			&&
			IsKnownStyle(_sStyle);
}

/*
 *	CParaFormat::Get(pPF)
 *
 *	@mfunc
 *		Copy this CParaFormat to *<p pPF>
 */
void CParaFormat::Get (
	PARAFORMAT2 *pPF2) const	//@parm	PARAFORMAT2 to copy this CParaFormat to
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Get");

	LONG cb = pPF2->cbSize;

	pPF2->dwMask = PFM_ALL2;					// Default PARAFORMAT2
	if(cb != sizeof(PARAFORMAT2))				// It isn't
	{
		pPF2->dwMask = PFM_ALL;					// Make it PARAFORMAT
		Assert(cb == sizeof(PARAFORMAT));		// It better be a PARAFORMAT
	}
	CopyMemory(&pPF2->wNumbering, &_wNumbering, (char *)&_bAlignment - (char *)&_wNumbering);
	pPF2->wAlignment = _bAlignment;
	pPF2->cTabCount	= _bTabCount;

	LONG cb1 = _bTabCount*sizeof(LONG);
	if(_bTabCount)
	{
		AssertSz(_iTabs >= 0,
			"CParaFormat::Get: illegal _iTabs value");
		CopyMemory(pPF2->rgxTabs, GetTabsCache()->Deref(_iTabs), cb1);
	}
	ZeroMemory(pPF2->rgxTabs + _bTabCount, MAX_TAB_STOPS*sizeof(LONG) - cb1);
	CopyMemory(&pPF2->dySpaceBefore, &_dySpaceBefore,
			   cb - offsetof(PARAFORMAT2, dySpaceBefore));
}

/*
 *	CParaFormat::GetTab (iTab, ptbPos, ptbAln, ptbLdr)
 *
 *	@mfunc
 *		Get tab parameters for the <p iTab> th tab, that is, set *<p ptbPos>,
 *		*<p ptbAln>, and *<p ptbLdr> equal to the <p iTab> th tab's
 *		displacement, alignment type, and leader style, respectively.  The
 *		displacement is given in twips.
 *
 *	@rdesc
 *		HRESULT = (no <p iTab> tab)	? E_INVALIDARG : NOERROR
 */
HRESULT CParaFormat::GetTab (
	long	iTab,				//@parm Index of tab to retrieve info for
	long *	ptbPos,				//@parm Out parm to receive tab displacement
	long *	ptbAln,				//@parm Out parm to receive tab alignment type
	long *	ptbLdr,				//@parm Out parm to receive tab leader style
	const LONG *prgxTabs) const	//@parm Tab array
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEEXTERN, "CParaFormat::GetTab");

	AssertSz(ptbPos && ptbAln && ptbLdr,
		"CParaFormat::GetTab: illegal arguments");

	if(iTab < 0)									// Get tab previous to, at,
	{												//  or subsequent to the
		if(iTab < tomTabBack)						//  position *ptbPos
			return E_INVALIDARG;

		LONG i;
		LONG tbPos = *ptbPos;
		LONG tbPosi;

		*ptbPos = 0;								// Default tab not found
		for(i = 0; i < _bTabCount &&				// Find *ptbPos
			tbPos > GetTabPos(prgxTabs[i]); 
			i++) ;

		tbPosi = GetTabPos(prgxTabs[i]);			// tbPos <= tbPosi
		if(iTab == tomTabBack)						// Get tab info for tab
			i--;									//  previous to tbPos
		else if(iTab == tomTabNext)					// Get tab info for tab
		{											//  following tbPos
			if(tbPos == tbPosi)
				i++;
		}
		else if(tbPos != tbPosi)					// tomTabHere
			return S_FALSE;

		iTab = i;		
	}
	if((DWORD)iTab >= (DWORD)_bTabCount)			// DWORD cast also
		return E_INVALIDARG;						//  catches values < 0

	iTab = prgxTabs[iTab];
	*ptbPos = GetTabPos(iTab);
	*ptbAln = GetTabAlign(iTab);
	*ptbLdr = GetTabLdr(iTab);
	return NOERROR;
}

/*
 *	CParaFormat::GetTabs ()
 *
 *	@mfunc
 *		Get ptr to tab array.  Use GetTabPos(), GetTabAlign(), and
 *		GetTabLdr() to access the tab position, alignment, and leader
 *		type, respectively.
 *
 *	@rdesc
 *		Ptr to tab array.
 */
const LONG * CParaFormat::GetTabs () const
{
	return GetTabsCache()->Deref(_iTabs);
}

/*
 *	CParaFormat::HandleStyle(Style)
 *
 *	@func
 *		If Style is a promote/demote command, i.e., if abs((char)Style)
 *			<= # heading styles - 1, add (char)Style to	sStyle (if heading)
 *			and to bOutlineLevel (subject to defined max and min values);
 *		else sStyle = Style.
 *
 *	@rdesc
 *		return TRUE iff sStyle or bOutlineLevel changed
 *
 *	@devnote
 *		Heading styles are -2 (heading 1) through -10 (heading 9), which
 *		with TOM and WOM. Heading outline levels are 0, 2,..., 16,
 *		corresponding to headings 1 through 9 (NHSTYLES), respectively,
 *		while text that follows has outline levels 1, 3,..., 17.  This value
 *		is used for indentation. Collapsed text has the PFE_COLLAPSED bit set.
 */
BOOL CParaFormat::HandleStyle(
	LONG Style)		//@parm Style, promote/demote code, or collapse-level code
{
	if(IsStyleCommand(Style))					// Set collapse level
	{											
		WORD wEffectsSave = _wEffects;			

		Style = (char)Style;					// Sign extend low byte
		if(IN_RANGE(1, Style, NHSTYLES))
		{
			_wEffects &= ~PFE_COLLAPSED;
			if((_bOutlineLevel & 1) || _bOutlineLevel > 2*(Style - 1))
				_wEffects |= PFE_COLLAPSED;		// Collapse nonheadings and
		}										//  higher numbered headings
		else if(Style == -1)
			_wEffects &= ~PFE_COLLAPSED;		// Expand all

		return _wEffects != wEffectsSave;		// Return whether something
	}											//  changed

	// Ordinary Style specification
	BYTE bLevel = _bOutlineLevel;
	_bOutlineLevel |= 1;						// Default not a heading
	if(IsHeadingStyle(Style))					// Headings have levels
	{											//  0, 2,..., 16, while the
		_bOutlineLevel = -2*(Style				//  text that follows has
						 - STYLE_HEADING_1);	//  1, 3,..., 17.
	}
	if(_sStyle == Style && bLevel == _bOutlineLevel)
		return FALSE;							// No change

	_sStyle = (SHORT)Style;						
	return TRUE;
}

/*
 *	CParaFormat::InitDefault(wDefEffects)
 *
 *	@mfunc
 *		Initialize this CParaFormat with default paragraph formatting
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : E_FAIL
 */
HRESULT CParaFormat::InitDefault(
	WORD wDefEffects)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::InitDefault");
	
	ZeroMemory(this, sizeof(CParaFormat));
	_bAlignment		= PFA_LEFT;
	_sStyle			= STYLE_NORMAL;			// Default style
	_wEffects		= wDefEffects;
	_bOutlineLevel	= 1;					// Default highest text outline
	_iTabs			= -1;					//  level
											
#if lDefaultTab <= 0
#error "default tab (lDefaultTab) must be > 0"
#endif

	return NOERROR;
}

/*
 *	CParaFormat::NumToStr(pch, n)
 *
 *	@mfunc	
 *		Convert the list number n to a string taking into consideration
 *		CParaFormat::wNumbering, wNumberingStart, and wNumberingStyle
 *	
 *	@rdesc
 *		cch of string converted
 */
LONG CParaFormat::NumToStr(
	TCHAR *	pch,				//@parm Target string
	LONG	n,					//@parm Number + 1 to convert
	DWORD   grf) const			//@parm Collection of flags
{
	if(IsNumberSuppressed())
	{
		*pch = 0;
		return 0;								// Number/bullet suppressed
	}

	if(!n)										// Bullet of some kind
	{											// CParaFormat::wNumbering
		*pch++ = (_wNumbering > ' ')			//  values > ' ' are Unicode
			   ? _wNumbering : 0x00B7;			//  bullets. Else use bullet
		return 1;								//  in symbol font
	}

	// Numbering of some kind
	//							 i  ii  iii  iv v  vi  vii  viii   ix
	const BYTE RomanCode[]	  = {1, 5, 0x15, 9, 2, 6, 0x16, 0x56, 0xd};
	const char RomanLetter[] = "ivxlcdmno";
	BOOL		fRtlPara = IsRtlPara() && !(grf & fRtfWrite);
	LONG		RomanOffset = 0;
	LONG		cch	= 0;						// No chars yet
	WCHAR		ch	= fRtlPara && (grf & fIndicDigits) ? 0x0660 : '0';	
												// Default char code offset
	LONG		d	= 1;						// Divisor
	LONG		r	= 10;						// Default radix 
	LONG   		quot, rem;						// ldiv result
	LONG		Style = (_wNumberingStyle << 8) & 0xF0000;

	n--;										// Convert to number offset
	if(Style == tomListParentheses ||			// Numbering like: (x)
	   fRtlPara && Style == 0)					// or 1) in bidi text.
	{										
		cch = 1;								// Store leading lparen
		*pch++ = '(';
	}
	else if (Style == tomListPeriod && fRtlPara)
	{
		cch = 1;
		*pch++ = '.';
		Style = tomListPlain;
	}

	if(_wNumbering == tomListNumberAsSequence)
		ch = _wNumberingStart;					// Needs generalizations, e.g.,
												//  appropriate radix
	else
	{
		n += _wNumberingStart;
		if(IN_RANGE(tomListNumberAsLCLetter, _wNumbering, tomListNumberAsUCLetter))
		{
			ch = (_wNumbering == tomListNumberAsLCLetter) ? 'a' : 'A';
			if(_wNumberingStart >= 1)
				n--;
			r = 26;								// LC or UC alphabetic number
		}										// Radix 26
	}

	while(d < n)
	{
		d *= r;									// d = smallest power of r > n
		RomanOffset += 2;
	}
	if(n && d > n)
	{
		d /= r;
		RomanOffset -= 2;
	}

	while(d)
	{
		quot = n / d;
		rem = n % d;
		if(IN_RANGE(tomListNumberAsLCRoman, _wNumbering, tomListNumberAsUCRoman))
		{
			if(quot)
			{
				n = RomanCode[quot - 1];
				while(n)
				{
					ch = RomanLetter[(n & 3) + RomanOffset - 1];
					if(_wNumbering == tomListNumberAsUCRoman)
						ch &= 0x5F;
					*pch++ = ch;
					n >>= 2;
					cch++;
				}
			}
			RomanOffset -= 2;
		}
		else
		{
			n = quot + ch;
			if(r == 26 && d > 1)				// If alphabetic higher-order
				n--;							//  digit, base it on 'a' or 'A'
			*pch++ = (WORD)n;					// Store digit
			cch++;
		}
		n = rem;								// Setup remainder
		d /= r;
	}
	if (Style != tomListPlain &&				// Trailing text
		(!fRtlPara || Style))
	{											// We only do rparen or period
		*pch++ = (Style == tomListPeriod) ? '.' : ')';

		cch++;
	}
	
	*pch = 0;									// Null terminate for RTF writer
	return cch;
}

/*
 *	CParaFormat::Set(pPF)
 *
 *	@mfunc
 *		Copy PARAFORMAT or PARAFORMAT2 *<p pPF> to this CParaFormat 
 */
void CParaFormat::Set (
	const PARAFORMAT2 *pPF2) 	//@parm	PARAFORMAT to copy to this CParaFormat
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Set");

	CopyMemory(&_wNumbering, &pPF2->wNumbering,
			   (char *)&_bAlignment - (char *)&_wNumbering);
	_bAlignment = (BYTE)pPF2->wAlignment;

	_iTabs = -1;
	_bTabCount = 0;

	if((pPF2->dwMask & PFM_TABSTOPS) && pPF2->cTabCount)
	{
		_bTabCount = (BYTE)min(MAX_TAB_STOPS, (BYTE)pPF2->cTabCount);
		_iTabs = GetTabsCache()->Cache(pPF2->rgxTabs, _bTabCount);
	}

	if(pPF2->dwMask & ~(PFM_ALL | PFM_PARAFORMAT))
	{
		CopyMemory(&_dySpaceBefore, &pPF2->dySpaceBefore,
			sizeof(CParaFormat) - offsetof(CParaFormat, _dySpaceBefore));
	}

#ifdef DEBUG
	ValidateTabs();
#endif // DEBUG
}

/*
 *	CParaFormat::UpdateNumber(n, pPF)
 *
 *	@mfunc
 *		Return new value of number for paragraph described by this PF
 *		following a paragraph described by pPF
 *
 *	@rdesc
 *		New number for paragraph described by this PF
 */
LONG CParaFormat::UpdateNumber (
	LONG  n,						//@parm Current value of number
	const CParaFormat *pPF) const	//@parm Previous CParaFormat
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::UpdateNumber");

	if(!IsListNumbered())			
		return 0;						// No numbering

	if(IsNumberSuppressed())
		return n;						// Number is suppressed, so no change

	if (!pPF || _wNumbering != pPF->_wNumbering ||
		(_wNumberingStyle != pPF->_wNumberingStyle && !pPF->IsNumberSuppressed()) ||
		_wNumberingStart != pPF->_wNumberingStart)
	{									// Numbering type or style
		return 1;						//  changed, so start over
	}
	return n + 1;						// Same kind of numbering,
}

#ifdef DEBUG
/*
 *	CParaFormat::ValidateTabs()
 *
 *	@mfunc
 *		Makes sure that a set of tabs would make sense for a non-table
 *		paragraph. Is called in places where we have set the tabs.
 *
 *	@rdesc
 *		None.
 */
void CParaFormat::ValidateTabs()
{
	if (_wEffects & PFE_TABLE)
	{
		// It would be nice to assert something reasonable here. However, the
		// rtf reader insists on setting things inconsistenly and I don't
		// have time at the moment to figure out why. (a-rsail)
		//	AssertSz((_bTabCount != 0),
		//	"CParaFormat::ValidateTabs: table with invalid tab count ");
		
		return;
	}

	// Non-table case.

	// It would be nice to assert on the consistency between these _bTabCount and _iTabs
	// but rtf reader has troubles with this. 
	//	AssertSz(((_bTabCount != 0) && (-1 != _iTabs)) || ((-1 == _iTabs) && (0 == _bTabCount)), 
	//	"CParaFormat::ValidateTabs: tab count and default tab index inconsistent");

	if (-1 == _iTabs)
	{
		// No tabs to validate so we are done.
		return;
	}

	const LONG *prgtabs = GetTabs();

	AssertSz(prgtabs != NULL, "CParaFormat::ValidateTabs: missing tab table");

	for (int i = 0; i < _bTabCount; i++)
	{
		AssertSz(GetTabAlign(prgtabs[i]) <= tomAlignBar,
			"CParaFormat::ValidateTabs: Invalid tab being set");
	}
}
#endif // DEBUG

//------------------------- Helper Functions -----------------------------------

// Defines and fixed font size details for increasing/decreasing font size
#define PWD_FONTSIZEPOINTMIN    1
// The following corresponds to the max signed 2-byte TWIP value, (32760)
#define PWD_FONTSIZEPOINTMAX    1638    

typedef struct tagfsFixup
{
    BYTE EndValue;
    BYTE Delta;
}
FSFIXUP;

const FSFIXUP fsFixups[] =
{
    12, 1,
    28, 2,
    36, 0,
    48, 0,
    72, 0,
    80, 0,
  	 0, 10			// EndValue = 0 case is treated as "infinite"
};

#define PWD_FONTSIZEMAXFIXUPS   (sizeof(fsFixups)/sizeof(fsFixups[0]))

/*
 *	GetUsableFontHeight(ySrcHeight, lPointChange)
 *
 *	@func
 *		Return a font size for setting text or insertion point attributes
 *
 *	@rdesc
 *		New TWIPS height
 *
 *	@devnote
 *		Copied from WinCE RichEdit code (written by V-GUYB)
 */
LONG GetUsableFontHeight(
	LONG ySrcHeight,		//@parm Current font size in twips
	LONG lPointChange)		//@parm Increase in pt size, (-ve if shrinking)
{
	LONG	EndValue;
	LONG	Delta;
    int		i;
    LONG	yRetHeight;

    // Input height in twips here, (TWentIeths of a Point).
    // Note, a Point is a 1/72th of an inch. To make these
    // calculations clearer, use point sizes here. Input height
    // in twips is always divisible by 20 (NOTE (MS3): maybe with
	// a truncation, since RTF uses half-point units).
    yRetHeight = (ySrcHeight / 20) + lPointChange;

    // Fix new font size to match sizes used by Word95
    for(i = 0; i < PWD_FONTSIZEMAXFIXUPS; ++i)
    {
		EndValue = fsFixups[i].EndValue;
		Delta	 = fsFixups[i].Delta;

        // Does new height lie in this range of point sizes?
        if(yRetHeight <= EndValue || !EndValue)
        {
            // If new height = EndValue, then it doesn't need adjusting
            if(yRetHeight != EndValue)
            {
                // Adjust new height to fit this range of point sizes. If
                // Delta = 1, all point sizes in this range stay as they are.
                if(!Delta)
                {
                    // Everything in this range is rounded to the EndValue
                    yRetHeight = fsFixups[(lPointChange > 0 ?
                                    i : max(i - 1, 0))].EndValue;
                }
                else if(Delta != 1)
                {
                    // Round new height to next delta in this range
                    yRetHeight = ((yRetHeight +
                        (lPointChange > 0 ? Delta - 1 : 0))
                                / Delta) * Delta;
                }
            }
            break;
        }
    }

    // Limit the new text size. Note, if we fix the text size
    // now, then we won't take any special action if we change
    // the text size later in the other direction. For example,
    // we shrink chars with size 1 and 2. They both change to
    // size 1. Then we grow them both to 2. So they are the
    // same size now, even though they weren't before. This
    // matches Word95 behavior.
    yRetHeight = max(yRetHeight, PWD_FONTSIZEPOINTMIN);
    yRetHeight = min(yRetHeight, PWD_FONTSIZEPOINTMAX);

    return yRetHeight*20;			// Return value in twips
}

/*
 *	IsValidCharFormatW(pCF)
 *
 *	@func
 *		Return TRUE iff the structure *<p pCF> has the correct size to be
 *		a CHARFORMAT or a CHARFORMAT2
 *
 *	@rdesc
 *		Return TRUE if *<p pCF> is a valid CHARFORMAT(2)
 */
BOOL IsValidCharFormatW (
	const CHARFORMAT * pCF) 		//@parm CHARFORMAT to validate
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "IsValidCharFormat");

	return pCF && (pCF->cbSize == sizeof(CHARFORMATW) ||
				   pCF->cbSize == sizeof(CHARFORMAT2W));
}

/*
 *	IsValidCharFormatA(pCFA)
 *
 *	@func
 *		Return TRUE iff the structure *<p pCF> has the correct size to be
 *		a CHARFORMATA or a CHARFORMAT2A
 *
 *	@rdesc
 *		Return TRUE if *<p pCF> is a valid CHARFORMAT(2)A
 */
BOOL IsValidCharFormatA (
	const CHARFORMATA * pCFA) 	//@parm CHARFORMATA to validate
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "IsValidCharFormatA");

	return pCFA && (pCFA->cbSize == sizeof(CHARFORMATA) ||
					pCFA->cbSize == sizeof(CHARFORMAT2A));
}

/*
 *	IsValidParaFormat(pPF)
 *
 *	@func
 *		Return TRUE iff the structure *<p pPF> has the correct size to be
 *		a PARAFORMAT or a PARAFORMAT2
 *
 *	@rdesc
 *		Return TRUE if *<p pPF> is a valid PARAFORMAT(2)
 */
BOOL IsValidParaFormat (
	const PARAFORMAT * pPF)		//@parm PARAFORMAT to validate
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "IsValidParaFormat");

	if (pPF && (pPF->cbSize == sizeof(PARAFORMAT) ||
				pPF->cbSize == sizeof(PARAFORMAT2)))
	{
		return TRUE;
	}
	TRACEERRORSZ("!!!!!!!!!!! bogus PARAFORMAT from client !!!!!!!!!!!!!");
	return FALSE;
}

/*
 *	Get16BitTwips(dy)
 *
 *	@func
 *		Return dy if |dy| < 32768; else return 32767, i.e., max value
 *		that fits into a SHORT
 *
 *	@rdesc
 *		dy if abs(cy) < 32768; else 32767
 */
SHORT Get16BitTwips(LONG dy)
{
	return abs(dy) < 32768 ? (SHORT)dy : 32767;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\cbhost.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	LBHOST.CPP -- Text Host for CreateWindow() Rich Edit 
 *		Combo Box Control | 
 *		Implements CCmbBxWinHost message
 *		
 *	Original Author: 
 *		Jerry Kim
 *
 *	History: <nl>
 *		01/30/97 - v-jerrki Created
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "_host.h"
#include "imm.h"
#include "_format.h"
#include "_edit.h"
#include "_cfpf.h"
#include "_cbhost.h"

ASSERTDATA

// Helper function in edit.cpp
LONG GetECDefaultHeightAndWidth(
	ITextServices *pts,
	HDC hdc,
	LONG lZoomNumerator,
	LONG lZoomDenominator,
	LONG yPixelsPerInch,
	LONG *pxAveWidth,
	LONG *pxOverhang,
	LONG *pxUnderhang);

// For effeciency and to avoid Winnt thunking layer we will call
// the listbox winproc directly
LRESULT CALLBACK RichListBoxWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam);

//////////////////////////// System Window Procs ////////////////////////////
/*
 *	RichComboBoxWndProc (hwnd, msg, wparam, lparam)
 *
 *	@mfunc
 *		Handle window messages pertinent to the host and pass others on to
 *		text services. 
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CALLBACK RichComboBoxWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichComboBoxWndProc");

	LRESULT	lres = 1;	//signify we didn't handle the message
	HRESULT hr = S_FALSE;
	CCmbBxWinHost *phost = (CCmbBxWinHost *) GetWindowLongPtr(hwnd, ibPed);

#ifdef DEBUG
	Tracef(TRCSEVINFO, "hwnd %lx, msg %lx, wparam %lx, lparam %lx", hwnd, msg, wparam, lparam);
#endif	// DEBUG

	switch(msg)
	{
	case WM_NCCREATE:
		return CCmbBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *)lparam);

	case WM_CREATE:
		// We may be on a system with no WM_NCCREATE (e.g. WINCE)
		if (!phost)
		{
			(void) CCmbBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *) lparam);
			phost = (CCmbBxWinHost *) GetWindowLongPtr(hwnd, ibPed);
		}
		break;
		
	case WM_DESTROY:
		if(phost)
			CCmbBxWinHost::OnNCDestroy(phost);
		return 0;
	}

	if (!phost)
		return ::DefWindowProc(hwnd, msg, wparam, lparam);

	// in certain out-of-memory situations, clients may try to re-enter us 
	// with calls.  Just bail on the call if we don't have a text services
	// pointer.
	if(!phost->_pserv)
		return 0;

	// stabilize ourselves
	phost->AddRef();

	switch(msg)
	{
	case WM_MOUSEMOVE:
		if (!phost->OnMouseMove(wparam, lparam))
			break;
		goto serv;

	case WM_LBUTTONUP:
		if (!phost->OnLButtonUp(wparam, lparam))
			break;
		goto serv;

	case WM_MOUSEWHEEL:
		if (!phost->OnMouseWheel(wparam, lparam))
			break;
		goto defproc;

	case WM_LBUTTONDBLCLK:
	case WM_LBUTTONDOWN:
		if (!phost->OnLButtonDown(wparam, lparam))
			goto Exit;
		goto serv;

	case WM_COMMAND:
		if (!phost->OnCommand(wparam, lparam))
			break;
		goto serv;		

	case WM_CREATE:
		lres = phost->OnCreate((CREATESTRUCT*)lparam);
		break;
	
	case WM_KEYDOWN:
		if (!phost->OnKeyDown((WORD) wparam, (DWORD) lparam))
			break;								
		goto serv;						//  give it to text services		   

	case WM_SETTEXT:
		if (phost->_cbType != CCmbBxWinHost::kDropDown)
		{
			lres = CB_ERR;
			break;
		}
		goto serv;
		
	case WM_GETTEXT:
		GETTEXTEX gt;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gt );
		goto serv;

	case WM_GETTEXTLENGTH:
		GETTEXTLENGTHEX gtl;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gtl );
		goto serv;
		
	case WM_CHAR:

		if (W32->OnWin9x() || phost->_fANSIwindow)
		{
			CW32System::WM_CHAR_INFO wmci;
			wmci._fAccumulate = phost->_fAccumulateDBC != 0;
			W32->AnsiFilter( msg, wparam, lparam, (void *) &wmci );
			if (wmci._fLeadByte)
			{
				phost->_fAccumulateDBC = TRUE;
				phost->_chLeadByte = wparam << 8;
				goto Exit;					// Wait for trail byte
			}
			else if (wmci._fTrailByte)
			{
				// UNDONE:
				// Need to see what we should do in WM_IME_CHAR
				wparam = phost->_chLeadByte | wparam;
				phost->_fAccumulateDBC = FALSE;
				phost->_chLeadByte = 0;
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
		}
	
		if(!phost->OnChar((WORD) wparam, (DWORD) lparam))
			// processed code: break out
			break;							
		goto serv;							//  else give it to text services

	case WM_DRAWITEM:
		lres = phost->CbMessageItemHandler(NULL, ITEM_MSG_DRAWLIST, wparam, lparam);
		if (lres)
			break;
		goto defproc;

	case WM_DELETEITEM:
		lres = phost->CbMessageItemHandler(NULL, ITEM_MSG_DELETE, wparam, lparam);
		if (lres)
			break;
		goto defproc;		

	case WM_ENABLE:
		if (phost->OnEnable(wparam, lparam))
		{
			if(!wparam ^ phost->_fDisabled)
			{
				// Stated of window changed so invalidate it so it will
				// get redrawn.
				InvalidateRect(phost->_hwnd, NULL, TRUE);
				phost->SetScrollBarsForWmEnable(wparam);

				// Need to enable the listbox window
				::EnableWindow(phost->_hwndList, wparam);
			}
			phost->_fDisabled = !wparam;				// Set disabled flag
			lres = 0;							// Return value for message
		}
											// Fall thru to WM_SYSCOLORCHANGE?
	case WM_SYSCOLORCHANGE:
		//forward message to listbox first then pass to textservice
		SendMessage(phost->_hwndList, msg, wparam, lparam);
		phost->OnSysColorChange();
		goto serv;							// Notify text services that
											//  system colors have changed
	case WM_GETDLGCODE:
		//forward message to listbox first then pass to textservice
		SendMessage(phost->_hwndList, msg, wparam, lparam);
		lres = phost->OnGetDlgCode(wparam, lparam);
		break;

    case WM_STYLECHANGING:
		// Just pass this one to the default window proc
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;
		
	case WM_SIZE:
		lres = phost->OnSize(wparam, lparam);
		break;

	case WM_SETCURSOR:
		//	Only set cursor when over us rather than a child; this
		//	helps prevent us from fighting it out with an inplace child
		if((HWND)wparam == hwnd)
		{
			if(!(lres = ::DefWindowProc(hwnd, msg, wparam, lparam)))
				lres = phost->OnSetCursor(wparam, lparam);
		}
		break;

	case WM_SHOWWINDOW:
		hr = phost->OnTxVisibleChange((BOOL)wparam);
		break;

	case WM_NCPAINT:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		if(phost->TxGetEffects() == TXTEFFECT_SUNKEN && dwMajorVersion < VERS4)
		{
			HDC hdc = GetDC(hwnd);
			if(hdc)
			{
				phost->DrawSunkenBorder(hwnd, hdc);
				ReleaseDC(hwnd, hdc);
			}
		}		
		break;

	case WM_PAINT:
		lres = phost->OnPaint(wparam, lparam);
		break;

	case WM_KILLFOCUS:
		lres = phost->OnKillFocus(wparam, lparam);
		if (!lres)
			goto serv;
		goto defproc;

	case LBCB_TRACKING:
		// release any mousedown stuff
		phost->OnLButtonUp(0, 0);
		phost->_fFocus = 1;
		phost->_fLBCBMessage = 1;
		// Fall through case!!!
		
	case WM_SETFOCUS:
		lres = phost->OnSetFocus(wparam, lparam);		
		if (lres)
			goto defproc;
		goto serv;

	case WM_SYSKEYDOWN:
		if (phost->OnSyskeyDown((WORD)wparam, (DWORD)lparam))
			goto serv;
		break;

	case WM_CAPTURECHANGED:
		if (!phost->OnCaptureChanged(wparam, lparam))
			goto serv;
		break;
		
	//bug fix #4076
	case CB_GETDROPPEDSTATE:
		lres = phost->_fListVisible;
		goto Exit;

	// combo box messages
	case CB_GETEXTENDEDUI:
		lres = phost->CbGetExtendedUI();
		break;

	case CB_SETEXTENDEDUI:
		lres = phost->CbSetExtendedUI(wparam);
		break;
	
    case CB_SETITEMHEIGHT:
		lres = phost->CbSetItemHeight((wparam == (unsigned)-1) ? TRUE : FALSE, (int)lparam);
		break;

	case CB_GETITEMHEIGHT:
		lres = phost->CbGetItemHeight((wparam == (unsigned)-1) ? TRUE : FALSE);
		break;

// Listbox specific messages
    case CB_DELETESTRING:
    	msg = LB_DELETESTRING;
    	goto deflstproc;

    case CB_SETTOPINDEX:
    	msg = LB_SETTOPINDEX;
    	goto deflstproc;

    case CB_GETTOPINDEX:
    	msg = LB_GETTOPINDEX;
    	goto deflstproc;
 
    case CB_GETCOUNT:
    	msg = LB_GETCOUNT;
    	goto deflstproc;
    	
    case CB_GETCURSEL:
    	msg = LB_GETCURSEL;
    	goto deflstproc;
    	
    case CB_GETLBTEXT:
    	msg = LB_GETTEXT;
    	goto deflstproc;
    	
    case CB_GETLBTEXTLEN:
    	msg = LB_GETTEXTLEN;
    	goto deflstproc;
    	
    case CB_INSERTSTRING:
    	msg = LB_INSERTSTRING;
    	goto deflstproc;
    	
    case CB_RESETCONTENT:
    	msg = LB_RESETCONTENT;
    	goto deflstproc;

    case CB_FINDSTRING:
    	msg = LB_FINDSTRING;
    	goto deflstproc;

    case CB_FINDSTRINGEXACT:
    	msg = LB_FINDSTRINGEXACT;
    	goto deflstproc;

    case CB_SELECTSTRING:
    	//bug fix
    	// The system control does 2 things here.  1) selects the requested item
    	// 2) sets the newly selected item to the top of the list
    	lres = CB_ERR;
    	if (phost->_hwndList)
    	{
    		lres = RichListBoxWndProc(phost->_hwndList, LB_SELECTSTRING, wparam, lparam);
    		phost->UpdateEditBox();
    	}
    	break;    	

    case CB_GETITEMDATA:
    	msg = LB_GETITEMDATA;
    	goto deflstproc;

    case CB_SETITEMDATA:
    	msg = LB_SETITEMDATA;
    	goto deflstproc;

    case CB_SETCURSEL:
    	//bug fix
    	// The system control does 2 things here.  1) selects the requested item
    	// 2) sets the newly selected item to the top of the list
    	if (phost->_hwndList)
    	{
    		lres = RichListBoxWndProc(phost->_hwndList, LB_SETCURSEL, wparam, lparam);
    		if (lres != -1)
    			RichListBoxWndProc(phost->_hwndList, LB_SETTOPINDEX, wparam, 0);
    		phost->UpdateEditBox();
    	}
    	break;

	case CB_ADDSTRING:
		msg = LB_ADDSTRING;
		goto deflstproc;

// edit box specific messages
    case CB_GETEDITSEL:
		msg = EM_GETSEL;
		goto serv;

    case CB_LIMITTEXT:
		msg = EM_SETLIMITTEXT;
		goto serv;    	
    
    case CB_SETEDITSEL:
    	if (phost->_cbType == CCmbBxWinHost::kDropDownList)
    	{
    	    lres = CB_ERR;
    		break;
    	}
    	msg = EM_SETSEL;
		// When we are in a dialog box that is empty, EM_SETSEL will not select
		// the final always existing EOP if the control is rich.
		if (phost->_fUseSpecialSetSel &&
			((CTxtEdit *)phost->_pserv)->GetAdjustedTextLength() == 0 &&
			wparam != -1)
		{
			lparam = 0;
			wparam = 0;
		}
		else
		{			
			//parameters are different between CB and EM messages
			wparam = (WPARAM)(signed short)LOWORD(lparam);
			lparam = (LPARAM)(signed short)HIWORD(lparam);
		}
		goto serv;

	
	case EM_SETMARGINS:  //PPT uses this message for the combo box. bug fix #4072
		// We need to keep track of the margins size because we have a minimum inset
		// value bug fix #4659
		if (wparam & EC_LEFTMARGIN)
			phost->_dxLOffset = LOWORD(lparam);
		if (wparam & EC_RIGHTMARGIN)
			phost->_dxROffset = HIWORD(lparam);
		phost->OnSetMargins(wparam, LOWORD(lparam) + phost->_dxLInset, 
			HIWORD(lparam) + phost->_dxRInset);
		break;
		
	case EM_GETOPTIONS:
		lres = phost->OnGetOptions();
		break;
		
	case EM_SETOPTIONS:
		phost->OnSetOptions((WORD) wparam, (DWORD) lparam);
		lres = (phost->_dwStyle & ECO_STYLES);
		if(phost->_fEnableAutoWordSel)
			lres |= ECO_AUTOWORDSELECTION;
		break;

	case EM_HIDESELECTION:
		if(lparam)
		{
			DWORD dwPropertyBits = 0;

			phost->_dwStyle |= ES_NOHIDESEL;
			if(wparam)
			{
				phost->_dwStyle &= ~ES_NOHIDESEL;
				dwPropertyBits = TXTBIT_HIDESELECTION;
			}

			// Notify text services of change in status.
			phost->_pserv->OnTxPropertyBitsChange(TXTBIT_HIDESELECTION, 
				dwPropertyBits);
		}
		goto serv;

	case EM_GETPASSWORDCHAR:
#ifndef NOACCESSIBILITY    
		lres = 0;
		break;
#endif

	// We should ignore any EM_ messages which we don't handle ourselves
	case EM_SETPALETTE:
	case EM_GETRECT:
	case EM_SETBKGNDCOLOR:
	case EM_SETPASSWORDCHAR:
	case EM_SETREADONLY:
	case EM_SETRECTNP:							
	case EM_SETRECT:	
    case CB_GETDROPPEDCONTROLRECT:
    case CB_SETDROPPEDWIDTH:
    case CB_GETDROPPEDWIDTH:
    case CB_INITSTORAGE:
    case CB_GETHORIZONTALEXTENT:
    case CB_SETHORIZONTALEXTENT:        
    case CB_SETLOCALE:
    case CB_GETLOCALE:
		AssertSz(FALSE, "Message not supported");
		//FALL THROUGH!!!

	case WM_STYLECHANGED:
		break;

	case EM_SETTEXTEX:
		phost->OnSetTextEx(wparam, lparam);
		break;

    case CB_SHOWDROPDOWN:
        if (wparam && !phost->_fListVisible)
        {
            phost->ShowListBox(TRUE);
        }
        else if (!wparam && phost->_fListVisible)
        {
            phost->HideListBox(TRUE, FALSE);
        }
        break;

#ifndef NOACCESSIBILITY        
	case WM_GETOBJECT:	
		IUnknown* punk;
		phost->QueryInterface(IID_IUnknown, (void**)&punk);
		Assert(punk);
		lres = W32->LResultFromObject(IID_IUnknown, wparam, (LPUNKNOWN)punk);
		AssertSz(!FAILED((HRESULT)lres), "WM_GETOBJECT message FAILED\n");
		punk->Release();
		break;
#endif		
		
	default:
		//CTxtWinHost message handler
serv:
		hr = phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);

defproc:
		if(hr == S_FALSE)
		{			
			// Message was not processed by text services so send it
			// to the default window proc.
			lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		}

		// Need to do some things after we send the message to ITextService
		switch (msg)
		{
		case EM_SETSEL:
			phost->_pserv->TxSendMessage(EM_HIDESELECTION, 0, 0, NULL);
			lres = 1;
			break;

		// Need to return 1 per SDK documentation
		case EM_SETLIMITTEXT:
			lres = 1;
			break;

		case WM_SETFONT:
		{
			// Special border processing. The inset changes based on the size of the
			// defautl character set. So if we got a message that changes the default
			// character set, we need to update the inset.
			// Update our font height member variable with the new fonts height
			// Get the inset information
			HDC hdc = GetDC(hwnd);
			LONG xAveCharWidth = 0;
			LONG yCharHeight = GetECDefaultHeightAndWidth(phost->_pserv, hdc, 1, 1,
				W32->GetYPerInchScreenDC(), &xAveCharWidth, NULL, NULL);
			ReleaseDC(hwnd, hdc);

			if (yCharHeight)
				phost->_dyFont = yCharHeight;

			// force a recalculation of the edit control
			phost->_dyEdit = 0;
			phost->CbCalcControlRects(&phost->_rcWindow, TRUE);

			// force a resize of the control
			phost->_fListVisible = 1;
			phost->HideListBox(FALSE, FALSE);
		}
			goto deflstproc;
			
		case EM_FORMATRANGE:
		case EM_SETPARAFORMAT:
		case EM_SETCHARFORMAT:
		case EM_SETLANGOPTIONS:
		case EM_SETBIDIOPTIONS:
		case EM_SETTYPOGRAPHYOPTIONS:
			goto deflstproc;			
		}
		break;

deflstproc:
		//CLstBxWinHost message handler
		Assert(phost->_hwndList);
		if (phost->_hwndList)
		{
			lres = SendMessage(phost->_hwndList, msg, wparam, lparam);
			
			switch (msg)
			{
			case LB_RESETCONTENT:
				//need to remove the content from the edit box
				phost->_pserv->TxSendMessage(WM_SETTEXT, wparam, NULL, &lres);
				break;

			case LB_SETCURSEL:
				// need to update the edit control
				phost->UpdateEditBox();
				break;	
			}
		}
		break;				
	}	

Exit:
	phost->Release();
	return lres;
}


//////////////// CCmbBxWinHost Creation/Initialization/Destruction ///////////////////////
#ifndef NOACCESSIBILITY
/*
 *	CCmbBxWinHost::QueryInterface(REFIID riid, void **ppv)
 *
 *	@mfunc
 *		
 */
HRESULT CCmbBxWinHost::QueryInterface(REFIID riid, void **ppv)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::QueryInterface");
  
  	if(riid == IID_IAccessible)
		*ppv = (IAccessible*)this;
    else if (riid == IID_IDispatch)
		*ppv = (IDispatch*)(IAccessible*)this;
    else if (IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown*)(IAccessible*)this;
    else
        return CTxtWinHost::QueryInterface(riid, ppv);

	AddRef();		
	return NOERROR;
}
#endif

/*
 *	CCmbBxWinHost::OnNCCreate (hwnd, pcs)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message (see remain.c)
 */
LRESULT CCmbBxWinHost::OnNCCreate(
	HWND hwnd,
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnNCCreate");


	CCmbBxWinHost *phost = new CCmbBxWinHost();

	if (!phost)
	{
		// Allocation failure.
		return 0;
	}

	if(!phost->Init(hwnd, pcs))					// Stores phost in associated
	{											//  window data
		phost->Shutdown();
		delete phost;
		return 0;
	}
	return TRUE;
}

/*
 *	CCmbBxWinHost::OnNCDestroy (phost)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message
 *
 *	@devnote
 *		phost ptr is stored in window data (GetWindowLongPtr())
 */
void CCmbBxWinHost::OnNCDestroy(
	CCmbBxWinHost *phost)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnNCDestroy");

	// NOTE:
	//	We have to be careful when we destroy the window because there can be cases
	// when we have a valid hwnd but no host for the hwnd so we have to check for
	// both cases

	if (phost->_plbHost)
	{
		// ALERT!! :The DestroyWindow function does not send the WM_NCDESTROY message for Windows CE		
		phost->_plbHost->Release();
	}
		
	// Destroy list box here so we will get the WM_DELETEITEM before the
	// combo box gets destroyed
	if (phost->_hwndList)
		DestroyWindow(phost->_hwndList);

	phost->Shutdown();
	phost->Release();
	
}

/*
 *	CCmbBxWinHost::CCmbBxWinHost()
 *
 *	@mfunc
 *		constructor
 */
CCmbBxWinHost::CCmbBxWinHost(): CTxtWinHost(), _plbHost(NULL), _hwndList(NULL), _hcurOld(NULL)
{
	_dxLInset = _dxRInset = 0;
	_fIgnoreUpdate = 0;
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CTxtWinHost");
}

/*
 *	CCmbBxWinHost::~CCmbBxWinHost()
 *
 *	@mfunc
 *		destructor
 */
CCmbBxWinHost::~CCmbBxWinHost()
{
}

/*
 *	CCmbBxWinHost::Init (hwnd, pcs)
 *
 *	@mfunc
 *		Initialize this CCmbBxWinHost
 */
BOOL CCmbBxWinHost::Init(
	HWND hwnd,					//@parm Window handle for this control
	const CREATESTRUCT *pcs)	//@parm Corresponding CREATESTRUCT
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::Init");

	if(!pcs->lpszClass)
		return -1;
		
	_fRightAlign = 0;
	_fListVisible = 0;
	_fOwnerDraw = 0;
	_fFocus = 0;
	_fMousedown = 0;
	_cyList = 0;
	_fDisabled = 0;
	_fNoIntegralHeight = 0;
	_idCtrl = (UINT)(DWORD_PTR) pcs->hMenu;
	_fKeyMaskSet = 0;
	_fMouseMaskSet = 0;
	_fScrollMaskSet = 0;
	_fMousedown = 0;
	_nCursor = -2;
	_fExtendedUI = 0;
	_fLBCBMessage = 0;
	_dxROffset = _dxLOffset = 0;

	// Set pointer back to CCmbBxWinHost from the window
	if(hwnd)
		SetWindowLongPtr(hwnd, ibPed, (INT_PTR)this);
		
	_hwnd = hwnd;

	if(pcs)
	{
		_hwndParent = pcs->hwndParent;
		_dwExStyle	= pcs->dwExStyle;
		_dwStyle	= pcs->style;

		// We need to change our Extended because we don't support most of them
		DWORD dwExStyle = _dwExStyle & (WS_EX_LEFTSCROLLBAR | WS_EX_TOPMOST | WS_EX_RIGHT |
							WS_EX_RTLREADING | WS_EX_CLIENTEDGE); 
		//	NOTE:
		//	  The order in which we check the style flags immulate
		//	WinNT's order.  So please verify with NT order before
		//	reaaranging order.
		if (_dwStyle & CBS_DROPDOWN)
		{
			_cbType = kDropDown;
			if (_dwStyle & CBS_SIMPLE)
				_cbType = kDropDownList;
		}
		else
		{
			AssertSz(FALSE, "CBS_SIMPLE not supported");
		}

		if (_dwStyle & CBS_OWNERDRAWFIXED)
			_fOwnerDraw = 1;
			
		if (_dwStyle & WS_DISABLED)
			_fDisabled = 1;

		if (_dwStyle & CBS_NOINTEGRALHEIGHT)
			_fNoIntegralHeight = 1;

		// the combobox doesn't support ES_RIGHT because its value is the 
		// same as CBS_DROPDOWN!!
		if (_dwExStyle & WS_EX_RIGHT)
		{
			_fRightAlign = 1;
			_dwStyle |= ES_RIGHT;
		}

		// implicitly set the ES_AUTOHSCROLL style bit
		_dwStyle |= ES_AUTOHSCROLL;				
		_dwStyle &= ~ES_AUTOVSCROLL;

		// If we have any kind of border it will always be a 3d border
		if (_dwStyle & WS_BORDER || _dwExStyle & WS_EX_CLIENTEDGE)
		{
			_fBorder = 1;
			_dwStyle &= ~WS_BORDER;
			_dwExStyle |= WS_EX_CLIENTEDGE;
			dwExStyle |= WS_EX_CLIENTEDGE;
		}

		// handle default disabled
		if(_dwStyle & WS_DISABLED)
			_fDisabled = TRUE;

		DWORD dwStyle = _dwStyle;
		// Remove the verticle scroll style for the window
		if (_dwStyle & WS_VSCROLL)
			dwStyle &= ~WS_VSCROLL;

        // Set the window styles
        SetWindowLong(_hwnd, GWL_STYLE, dwStyle);
        SetWindowLong(_hwnd, GWL_EXSTYLE, dwExStyle);
	}

	// Create Text Services component
	if(FAILED(CreateTextServices()))
		return FALSE;

	_xInset = 1;
	_yInset = 1;

	PARAFORMAT PF2;	
	PF2.dwMask = 0;
	if(_dwExStyle & WS_EX_RIGHT)
	{
		PF2.dwMask |= PFM_ALIGNMENT;
		PF2.wAlignment = (WORD)(PFA_RIGHT);	// right or center-aligned
	}

	if(_dwExStyle & WS_EX_RTLREADING)
	{
		PF2.dwMask |= PFM_RTLPARA;
		PF2.wEffects = PFE_RTLPARA;		// RTL reading order
	}

	if (PF2.dwMask)
	{
		PF2.cbSize = sizeof(PARAFORMAT2);
		//  tell text services
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF2, NULL);
	}
	
	PARAFORMAT PF;							// If left or right alignment,
	if(_fRightAlign)				//  tell text services
	{
		PF.cbSize = sizeof(PARAFORMAT);
		PF.dwMask = PFM_ALIGNMENT;
		PF.wAlignment = (WORD)PFA_RIGHT;
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF, NULL);
	}

	//bug fix #4644 we want the EN_CHANGE and EN_UPDATE notifications
	_pserv->TxSendMessage(EM_SETEVENTMASK, 0, ENM_UPDATE | ENM_CHANGE, NULL);

	// Tell textservices to turn-on auto font sizing
	_pserv->TxSendMessage(EM_SETLANGOPTIONS, 0, 
			IMF_AUTOKEYBOARD | IMF_AUTOFONT | IMF_AUTOFONTSIZEADJUST | IMF_UIFONTS |
			IMF_IMEALWAYSSENDNOTIFY, NULL);
			
	
	return TRUE;
}


/*
 *	CCmbBxWinHost::OnCreate (pcs)
 *
 *	@mfunc
 *		Handle WM_CREATE message
 *
 *	@rdesc
 *		LRESULT = -1 if failed to in-place activate; else 0
 */
LRESULT CCmbBxWinHost::OnCreate(const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnCreate");

	RECT rcClient;

	// sometimes, these values are -1 (from windows itself); just treat them
	// as zero in that case
	LONG cy = (pcs->cy < 0) ? 0 : pcs->cy;
	LONG cx = (pcs->cx < 0) ? 0 : pcs->cx;

	rcClient.top = pcs->y;
	rcClient.bottom = rcClient.top + cy;
	rcClient.left = pcs->x;
	rcClient.right = rcClient.left + cx;

	// Notify Text Services that we are in place active
	if(FAILED(_pserv->OnTxInPlaceActivate(&rcClient)))
		return -1;	

	// Get the font height to base the control heights from
	// Initially the font height is the item height	
	HDC hdc = GetDC(_hwnd);	
	LONG xAveCharWidth = 0;
	_dyFont = GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
		W32->GetYPerInchScreenDC(), &xAveCharWidth, NULL, NULL);
	Assert(_dyFont != 0); // _yInset should be zero since listbox's doesn't have yinsets

	ReleaseDC(_hwnd, hdc);
	
	
	// init variables
	_idCtrl = (UINT)(DWORD_PTR)pcs->hMenu;

	// Need to calculate the rects of EVERYTHING!!
	// Force a request of itemHeight
	_rcButton.left = 0;
	_dyEdit = 0;
	_cyList = -1;
	CbCalcControlRects(&rcClient, TRUE);

	// Now lets handle the listbox stuff!
	// create and tranlate styles for combo box to listbox
	DWORD lStyle = WS_BORDER | WS_CHILD | WS_VISIBLE | LBS_NOTIFY | LBS_COMBOBOX | WS_CLIPSIBLINGS;
	if (_dwStyle & CBS_HASSTRINGS)
		lStyle |= LBS_HASSTRINGS;

	if (_dwStyle & CBS_SORT)
		lStyle |= LBS_SORT;

	if (_dwStyle & CBS_DISABLENOSCROLL)
		lStyle |= LBS_DISABLENOSCROLL;

	if (_dwStyle & CBS_NOINTEGRALHEIGHT)
		lStyle |= LBS_NOINTEGRALHEIGHT;

	if (_dwStyle & CBS_OWNERDRAWFIXED)
	{
		_fOwnerDraw;
		lStyle |= LBS_OWNERDRAWFIXED;
	}

	// copy over some window styles
	lStyle |= (_dwStyle & WS_DISABLED);
	lStyle |= (_dwStyle & WS_VSCROLL);
	
	DWORD lExStyle = _dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);

	//NOTE. It doesn't matter if the listbox is made with the correct size since
	// it's going to get resized anyways
	if (!W32->OnWin9x())
	{
		//WinNT
		_hwndList = ::CreateWindowExW(lExStyle | WS_EX_TOOLWINDOW, L"REListBox20W", 
					NULL, lStyle, _rcList.left, _rcList.top, _rcList.right - _rcList.left,
					_rcList.bottom - _rcList.top, _hwnd, (HMENU)CB_LISTBOXID, NULL, this);
	}
	else
	{
		// Win '95, '98 system
		_hwndList = ::CreateWindowExA(lExStyle | WS_EX_TOOLWINDOW, "REListBox20W", 
					NULL, lStyle, _rcList.left, _rcList.top, _rcList.right - _rcList.left,
					_rcList.bottom - _rcList.top, _hwnd, (HMENU)CB_LISTBOXID, NULL, this);
	}
	
	Assert(_hwndList);
	_plbHost = (CLstBxWinHost *) GetWindowLongPtr(_hwndList, ibPed);
	Assert(_plbHost);
	if (!_plbHost)
		return -1;
		
	// increment reference counter!
	_plbHost->AddRef();

	if (_cbType != kSimple)
		ShowWindow(_hwndList, SW_HIDE);
	SetParent(_hwndList, NULL);
				
	if (_cbType == kDropDownList)
	{			
		AssertSz(!((CTxtEdit*)_pserv)->_fReadOnly, "edit is readonly");
		
		// Tell textservices to select the entire background
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_EXTENDBACKCOLOR, SES_EXTENDBACKCOLOR, NULL);	

		// format the paragraph to immulate the system control
		PARAFORMAT2 pf;
		pf.cbSize = sizeof(PARAFORMAT2);
		pf.dwMask = PFM_STARTINDENT;
		pf.dxStartIndent = (1440.0 / W32->GetXPerInchScreenDC());
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&pf, NULL);
		_usIMEMode = ES_NOIME;
		// Tell textservices to turnoff ime
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_NOIME, SES_NOIME, NULL);	

	}
	else
	{
		// make the richedit control behave like the edit control		
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_EMULATESYSEDIT, SES_EMULATESYSEDIT, NULL);
	}

	// Need to resize the list box
	if (_cbType != kSimple)
		SetDropSize(&_rcList);

	return 0;
}


/////////////////////////// CCmbBxWinHost Helper functions /////////////////////////////////
/*
 *	CCmbBxWinHost::GetTextLength ()
 *
 *	@mfunc
 *		returns the text length of the edit control using CR and NOT CRLF
 *
 *	@rdesc
 *		LRESULT = text length
 */
 LRESULT CCmbBxWinHost::GetTextLength()
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::GetTextLength");
 	
 	LRESULT lr = 0;
	GETTEXTLENGTHEX gtl;
	gtl.flags = GTL_NUMCHARS | GTL_PRECISE;
	gtl.codepage = 1200;

#ifdef DEBUG
	HRESULT hr = _pserv->TxSendMessage(EM_GETTEXTLENGTHEX, (WPARAM)&gtl, 0, &lr);
	Assert(hr == NOERROR);
#else
	_pserv->TxSendMessage(EM_GETTEXTLENGTHEX, (WPARAM)&gtl, 0, &lr);
#endif
	return lr;
 }

/*
 *	CCmbBxWinHost::GetEditText (LPTSTR, int)
 *
 *	@mfunc
 *		returns the text length in the edit control in UNICODE
 *
 *	@rdesc
 *		LRESULT = text length copied to passed in buffer
 */
 LRESULT CCmbBxWinHost::GetEditText (LPTSTR szStr, int nSize)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::GetEditText");

	LRESULT lr = 0;
 	GETTEXTEX gt;
	gt.cb = nSize * sizeof(TCHAR);
	gt.flags = 0;
	gt.codepage = 1200;
	gt.lpDefaultChar = NULL;
	gt.lpUsedDefChar = NULL;

#ifdef DEBUG
	HRESULT hr = _pserv->TxSendMessage(EM_GETTEXTEX, (WPARAM)&gt, (LPARAM)szStr, &lr);
	Assert(hr == NOERROR);
#else
	_pserv->TxSendMessage(EM_GETTEXTEX, (WPARAM)&gt, (LPARAM)szStr, &lr);
#endif
	return lr;
 }
 
 
/*
 *	CCmbBxWinHost::SetDropSize(RECT* prc)
 *
 *	@mfunc
 *		Compute the drop down window's width and max height
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
void CCmbBxWinHost::SetDropSize(RECT* prc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::SetDropSize");

	_fListVisible = TRUE;
	HideListBox(FALSE, FALSE);
	POINT pt1 = {prc->left, prc->top};
	POINT pt2 = {prc->right, prc->bottom};
	::ClientToScreen(_hwnd, &pt1);
	::ClientToScreen(_hwnd, &pt2);
	MoveWindow(_hwndList, pt1.x, pt1.y, pt2.x - pt1.x,
			pt2.y - pt1.y, FALSE);

}

/*
 *	CCmbBxWinHost::SetSizeEdit(int nLeft, int nTop, int nRight, int nBottom)
 *
 *	@mfunc
 *		sets the edit controls size
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
void CCmbBxWinHost::SetSizeEdit(int nLeft, int nTop, int nRight, int nBottom)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::SizeEdit");

	// Generate default view rect from client rect
	if(_fBorder)
	{
		// Factors in space for borders
  		_rcViewInset.top	= W32->DYtoHimetricY(nTop, W32->GetYPerInchScreenDC());
   		_rcViewInset.bottom	= W32->DYtoHimetricY(nBottom, W32->GetYPerInchScreenDC());
   		_rcViewInset.left	= W32->DXtoHimetricX(nLeft, W32->GetXPerInchScreenDC());
   		_rcViewInset.right	= W32->DXtoHimetricX(nRight, W32->GetXPerInchScreenDC());
	}
	else
	{
		// Default the top and bottom inset to 0 and the left and right
		// to the size of the border.
		_rcViewInset.top = 0;
		_rcViewInset.bottom = 0;
		_rcViewInset.left = W32->DXtoHimetricX(nLeft, W32->GetXPerInchScreenDC());
		_rcViewInset.right = W32->DXtoHimetricX(nRight, W32->GetXPerInchScreenDC());
	}
}

/*
 *	CCmbBxWinHost::CbCalcControlRects(RECT* prc, BOOL bCalcChange)
 *
 *	@mfunc
 *		Calculates the RECT for all the controls.  The rect should
 *	include the non-client area's also
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
BOOL CCmbBxWinHost::CbCalcControlRects(RECT* prc, BOOL bCalcChange)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbCalcControlRects");

	// copy over the window rect
	_rcWindow = *prc;

	// Item specific things
	const int smY = GetSystemMetrics(SM_CYEDGE);
	const int smX = GetSystemMetrics(SM_CXEDGE);
	
	_cxCombo = _rcWindow.right - _rcWindow.left;

	if (!_dyEdit)
		_dyEdit = _dyFont + 2 + ((_fBorder) ? (2 * _yInset) : 0);
	
	if (_fOwnerDraw)
	{		
		if (bCalcChange)
		{
            // No height has been defined yet for the static text window.  Send
            // a measure item message to the parent
			MEASUREITEMSTRUCT mis;
            mis.CtlType = ODT_COMBOBOX;
            mis.CtlID = _idCtrl;
            mis.itemID = (UINT)-1;
            mis.itemHeight = _dyEdit;
            mis.itemData = 0;

            SendMessage(_hwndParent, WM_MEASUREITEM, _idCtrl, (LPARAM)&mis);
			_dyEdit = mis.itemHeight;
        }
	}
	else
	{
		// NOTE:
		//	Richedit prevents us from trying to set the itemHeight less than the 
		// font height so we need to take account of this by preventing user from
		// setting height less than font height
		int nyEdit = _dyFont + ((_fBorder) ? 2 * _yInset : 0);
		if (_dyEdit > nyEdit)
		{
			//In order for the highlighting to work properly we need to empty
			//the richedit control
			LRESULT nLen;
			_pserv->TxSendMessage(WM_GETTEXTLENGTH, 0, 0, &nLen);

			TCHAR* pwch = NULL;
			if (nLen && _cbType == kDropDownList)
			{
				pwch = new TCHAR[nLen + 1 /*NULL*/];				
				AssertSz(pwch, "Unable to allocate memory for string");

				if (pwch)
				{				
					// Get the text from richedit and emtpy it
					_pserv->TxSendMessage(WM_GETTEXT, nLen + 1, (LPARAM)pwch, NULL);
					_pserv->TxSendMessage(WM_SETTEXT, 0, NULL, NULL);
				}
				else
				{
					// something bad happened so send a message
					// to client
					TxNotify(EN_ERRSPACE, NULL);	
				}
			}
			else if (_cbType == kDropDown && nLen == 0)
			{
				// we need to insert a dummy character into the richedit
				// control so it won't try to highlight space after
				// the paragraph
				_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)L" ", NULL);
			}
					
		 	// Calculate the difference in size
		 	nyEdit = _dyEdit - nyEdit;				 	

			PARAFORMAT2 pf;			
			pf.cbSize = sizeof(PARAFORMAT2);
			pf.dwMask = PFM_SPACEAFTER;
			pf.dySpaceAfter = (int)(((double)nyEdit * 1440.0) / (double)W32->GetYPerInchScreenDC());
			_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&pf, NULL);

			//Reset the text which was there before in the richedit control
			if (pwch || (_cbType == kDropDown && nLen == 0))
			{
				_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)(pwch ? pwch : NULL), NULL);
				if (pwch)
					delete pwch;
			}
		}
		else
			_dyEdit = nyEdit;	// stabalize ourselves
	}

	// For Bordered Combobox we take account of the clientedge for the top
	// and bottom. And since we want to draw the focus rect within the yellow
	// area we need to subtract 1.
	_cyCombo = min(_dyEdit + ((_fBorder) ? 2 * smY : 0), 
				_rcWindow.bottom - _rcWindow.top); 
	
	// recompute the max height of the dropdown listbox -- full window
    // size MINUS edit/static height
    if (_cyList == -1)        
        _cyList = max((_rcWindow.bottom - _rcWindow.top) - _cyCombo, 0);

	// calculate the rect for the buttons
	if (_cbType != kSimple)
	{
		_rcButton.top = 0;
		_rcButton.bottom = min(_dyEdit, _rcWindow.bottom - _rcWindow.top);
		if (_fRightAlign)
		{
			_rcButton.left = 0;
			_rcButton.right = _rcButton.left + GetSystemMetrics(SM_CXVSCROLL);
		}
		else
		{
			_rcButton.right = _cxCombo - ((_fBorder) ? (2 * smX): 0);
			_rcButton.left = _rcButton.right - GetSystemMetrics(SM_CXVSCROLL);
		}
	}


	// calculate the edit control rect	
	int nTop = _yInset;
	int nBottom = 0;
	_dxLInset = _xInset;
	_dxRInset = _xInset;	
	if (_cbType != kSimple)
	{
		if (_fRightAlign)
			_dxLInset = (_rcButton.right - _rcButton.left) + smX;
		else
			_dxRInset = (_rcButton.right - _rcButton.left) + smX;
	}
	SetSizeEdit(_dxLInset + _dxLOffset, nTop, _dxRInset + _dxROffset, nBottom);

	// calculate the rect for the list box window
	_rcList.left = (_fBorder) ? - smX : 0;
	_rcList.top = _cyCombo - ((_fBorder) ? smY : 0);
	_rcList.right = (_fBorder) ? max(_cxCombo - smX, 0) : _rcWindow.right;
	_rcList.bottom = _cyCombo + _cyList;	

	return TRUE;
}


/*
 *	CCmbBxWinHost::DrawButton(HDC, BOOL)
 *
 *	@mfunc
 *		Draws the combo box button given an hdc
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
 void CCmbBxWinHost::DrawButton(HDC hdc, BOOL bDown)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::DrawButton");

	// Check if we have to draw the drop down button
    if (_cbType != kSimple) 
	{
		BOOL bRelease = !hdc;
		if (!hdc)
			hdc = TxGetDC();

        DrawFrameControl(hdc, &_rcButton, DFC_SCROLL, DFCS_SCROLLCOMBOBOX |
            (bDown ? DFCS_PUSHED | DFCS_FLAT: 0) | (!_fBorder ? DFCS_FLAT : 0) |
            (!_fDisabled ? 0 : DFCS_INACTIVE));

		if (bRelease)
			TxReleaseDC(hdc);
    }
}


/* 
 *	CCmbBxWinHost::TxNotify (iNotify,	pv)
 *
 *	@mfunc
 *		Notify Text Host of various events.  Note that there are
 *		two basic categories of events, "direct" events and 
 *		"delayed" events.  In the case of the combobox we will
 *		notify parent of only two edit notifications; EN_CHANGE 
 *		and EN_UPDATE.  The others will be from the listbox
 *		or be generated because of focus changing
 *
 *
 *	@rdesc	
 *		S_OK - call succeeded <nl>
 *		S_FALSE	-- success, but do some different action
 *		depending on the event type (see below).
 *
 *	@comm
 *		<CBN_DBLCLK> user double-clicks an item in the list box
 *
 *		<CBN_ERRSPACE> The list box cannot allocate enough memory to 
 *		fulfill a request
 *
 *		<CBN_KILLFOCUS> The list box loses the keyboard focus
 *
 *		<CBN_SELENDCANCEL> notification message is sent when the user 
 *		selects an item, but then selects another control or closes the 
 *		dialog box
 *
 *		<CBN_SELCHANGE> notification message is sent when the user changes 
 *		the current selection in the list box of a combo box
 *
 *		<CBN_SETFOCUS> The list box receives the keyboard focus
 *
 *		<CBN_CLOSEUP> This message is sent when the listbox has been closed
 *
 *		<CBN_SELENDOK> notification message is sent when the user selects a 
 *		list item, or selects an item and then closes the list
 *
 *		<CBN_EDITCHANGE> notification message is sent after the user 
 *		has taken an action that may have altered the text in the edit 
 *		control portion of a combo box
 *
 *		<CBN_EDITUPDATE> notification message is sent when the edit control 
 *		portion of a combo box is about to display altered text
 *
 *		<CBN_DROPDOWN> This message is sent when the listbox has been made visible
 */
HRESULT CCmbBxWinHost::TxNotify(
	DWORD iNotify,		//@parm	Event to notify host of.  One of the
						//		EN_XXX values from Win32, e.g., EN_CHANGE
	void *pv)			//@parm In-only parameter with extra data.  Type
						//		dependent on <p iNotify>
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CCmbBxWinHost::TxNotify");
	HRESULT hr = S_FALSE;

	if(_hwndParent)
	{
		// First, handle WM_NOTIFY style notifications
		//WPARAM LOWORD(_idCtrl) ; LPARAM - HWND(COMBO)
		switch(iNotify)
		{
		case EN_CHANGE:
			//update the listbox bug fix #5206
			if (_fIgnoreChange)
			{
				_fIgnoreChange = 0;
				return hr;
			}

			if (_fListVisible && _cbType == kDropDown)
				UpdateListBox(FALSE);
			else if (_cbType == kDropDownList)
			    // don't send notification if dropdownlist
			    return S_FALSE;
			    
			iNotify = CBN_EDITCHANGE;
			goto sndmsg;
			
		case EN_UPDATE:
			//bug fix - we're sending too much CBN_UPDATE notifications
			if (_fIgnoreUpdate)
				return hr;
			if (_cbType == kDropDownList)
			    return S_FALSE;
			    
			iNotify = CBN_EDITUPDATE;
			goto sndmsg;
			
		case EN_ERRSPACE:
			iNotify = (unsigned)CBN_ERRSPACE;
			goto sndmsg;

		case CBN_SELCHANGE: 
		case CBN_SELENDCANCEL:		
		case CBN_CLOSEUP:
		case CBN_DBLCLK:	
		case CBN_DROPDOWN:  
		case CBN_KILLFOCUS:  
		case CBN_SELENDOK:
		case CBN_SETFOCUS:
	
sndmsg:
		hr = SendMessage(_hwndParent, WM_COMMAND, 
						GET_WM_COMMAND_MPS(_idCtrl, _hwnd, iNotify));
		}		
	}
	return hr;
}

/*
 *	CCmbBxWinHost::DrawEditFocus(HDC)
 *
 *	@mfunc
 *		Either draws or notifies owner to draw the focus rect
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::DrawEditFocus(HDC hdc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::DrawEditFocus");

	BOOL bRelease = FALSE;
	if (!hdc)
	{
		hdc = TxGetDC();
		bRelease = TRUE;
	}

	RECT rc;
	GetClientRect(_hwnd, &rc);

	if (!_fOwnerDraw)
	{
		HiliteEdit(_fFocus);

		if (_cbType == kDropDownList)
		{
			// shrink the focus rect by the inset
			rc.top += _yInset;
			rc.bottom -= _yInset;			
			
			if (_fRightAlign)
				rc.left = _rcButton.right;
			else
				rc.right = _rcButton.left;

			rc.left += _xInset;
			rc.right -= _xInset;

			DrawFocusRect(hdc, &rc);
		}
	}

	if (bRelease)
		TxReleaseDC(hdc);
	
}

/*
 *	CCmbBxWinHost::SetSelectionInfo(BOOL bOk, int nIdx)
 *
 *	@mfunc
 *		Completes the text in the edit box with the closest match from the
 * listbox.  If a prefix match can't be found, the edit control text isn't
 * updated. Assume a DROPDOWN style combo box.
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::SetSelectionInfo(BOOL bOk, int nIdx)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::SetSelectionInfo");
	

	_nCursor = nIdx;
	_bSelOk = bOk;	
}

/*
 *	CCmbBxWinHost::AutoUpdateEdit(int i)
 *
 *	@mfunc
 *		Completes the text in the edit box with the closest match from the
 * listbox.  If a prefix match can't be found, the edit control text isn't
 * updated. Assume a DROPDOWN style combo box.
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::AutoUpdateEdit(int nItem)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::AutoUpdateEdit");

    // We update the edit part of the combo box with the current selection of
    // the list box
	int cch;
	TCHAR* pszText;
	LRESULT lr;

	// find the best matching string in the list box
	if (nItem == -1 || nItem == -2)
	{
		cch = GetTextLength();

		// no text to search so just get out
	    if (!cch)
	    	return;

	    cch++; // account for null character
	    pszText = new TCHAR[cch];
	    AssertSz(pszText, "string allocation failed");
	    if (!pszText) 
	    {
			TxNotify((unsigned)CBN_ERRSPACE, NULL);
			return;
		}

		// get string from edit control and try to find a exact match else a match
		// in the list box
		GetEditText(pszText, cch);
		
	    nItem = RichListBoxWndProc(_hwndList, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pszText);

	    if (nItem == -1)
	    	nItem = RichListBoxWndProc(_hwndList, LB_FINDSTRING, (WPARAM)-1, (LPARAM)pszText);
		delete [] pszText;

		// no match found so just get out
	    if (nItem == -1)         	
	    	return;
    }

	cch = RichListBoxWndProc(_hwndList, LB_GETTEXTLEN, nItem, 0);

	if (cch <= 0)
		return;
		
    cch++; // account for null character
    pszText = new TCHAR[cch];
	AssertSz(pszText, "Unable to allocate string");
	if (!pszText)
	{
		TxNotify((unsigned)CBN_ERRSPACE, NULL);
		return;
	}

	RichListBoxWndProc(_hwndList, LB_GETTEXT, nItem, (LPARAM)pszText);
	_fIgnoreChange = 1;
	_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)pszText, &lr);

   	HiliteEdit(TRUE);

    delete [] pszText;
}

/*
 *	CCmbBxWinHost::HiliteEdit(BOOL)
 *
 *	@mfunc
 *		Sets the hilite background or selects the entire text for the
 *	edit control
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::HiliteEdit(BOOL bSelect)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::HiliteEdit");

	//bug fix 4073
	Assert(!_fOwnerDraw || _cbType == kDropDown);

	if (_cbType != kDropDownList)
	{
		//if bSelect is true else put cursor at beginning of text
		_pserv->TxSendMessage(EM_SETSEL, 0, (LPARAM)((bSelect) ? -1 : 0), NULL);
	}
	else
	{
		//Get the range of the paragraph
		ITextRange* pRange;		
		if (NOERROR != ((CTxtEdit*)_pserv)->Range(0, 0, &pRange))
		{
			AssertSz(FALSE, "unable to get range");
			return;
		}
		Assert(pRange);

		DWORD crFore = (unsigned)tomAutoColor;
		DWORD crBack = (unsigned)tomAutoColor;
		if (bSelect)
		{
			crFore = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
			crBack = ::GetSysColor(COLOR_HIGHLIGHT);
		}

		// Get the entire paragraph
		ITextFont* pFont = NULL;	

		// Select entire text
		CHECKNOERROR(pRange->SetIndex(tomParagraph, 1, 1));
		
		// Set the background and forground color
		CHECKNOERROR(pRange->GetFont(&pFont));
		
		Assert(pFont);
		CHECKNOERROR(pFont->SetBackColor(crBack));
		CHECKNOERROR(pFont->SetForeColor(crFore));

CleanExit:
		// Release pointers
		if (pFont)
			pFont->Release();
		pRange->Release();
	}
}


/*
 *	CCmbBxWinHost::UpdateEditBox()
 *
 *	@mfunc
 *		Updates the editcontrol window so that it contains the text
 * given by the current selection in the listbox.  If the listbox has no
 * selection (ie. -1), then we erase all the text in the editcontrol.
 *
 * hdc is from WM_PAINT messages Begin/End Paint hdc. If null, we should
 * get our own dc.
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::UpdateEditBox()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::UpdateEditBox");

    Assert(_hwndList);
    Assert(_plbHost);

    // Update the edit box
    if (_cbType == kDropDownList && _fOwnerDraw)
    {
	   	CbMessageItemHandler(NULL, ITEM_MSG_DRAWCOMBO, 0, 0);
	   	return;
	}
    else 
    {
		TCHAR* pszText = NULL;
	   	int nItem = (signed)_plbHost->GetCursor();   	
	    if (nItem != -1)
		{
			int cch = RichListBoxWndProc(_hwndList, LB_GETTEXTLEN, (LPARAM)nItem, 0);
		    pszText = new TCHAR[cch + 1];
			AssertSz(pszText, "allocation failed");

			// just get out if memory allocation failed
			if (!pszText)
			{
				TxNotify((unsigned)CBN_ERRSPACE, NULL);
				return;
			}
			RichListBoxWndProc(_hwndList, LB_GETTEXT, (WPARAM)nItem, (LPARAM)pszText);		
		}
	
    	// if the cursor is on a valid item then update edit with the item text
    	// else we just display a blank text
    	TCHAR szEmpty[] = L"";
    	_fIgnoreChange = 1;
    	_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)((pszText) ? pszText : szEmpty), NULL);
   		DrawEditFocus(NULL);
    	if (pszText)
    		delete pszText;
    }
}

/*
 *	CCmbBxWinHost::UpdateListBox(BOOL)
 *
 *	@mfunc
 *		Updates the list box by searching and moving to the top the text in
 *	edit control.  And possibly pre-selecting the item if bSetSel is set
 *
 *	@rdesc
 *		int = found ? index of item : -1
 */
int CCmbBxWinHost::UpdateListBox(BOOL bSetSel)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::UpdateListBox");

    int nItem = -1;
    int nSel = -1;
	TCHAR* pszText;
	int cch;

	// Get text from edit box
    cch = GetTextLength();
    if (cch) 
    {
    	// add one for null string
        cch++;
        pszText = new TCHAR[cch];
        if (pszText != NULL) 
        {  
        	if (GetEditText(pszText, cch))
        	{
        		//Bypass Winnt thunking layer by calling the function directly
        		nItem = RichListBoxWndProc(_hwndList, LB_FINDSTRING, (WPARAM)-1L, (LPARAM)pszText);
        	}
        	delete [] pszText;        	
        }
        else
        {
			TxNotify((unsigned)CBN_ERRSPACE, NULL);
			return 0;
		}
    }

    if (bSetSel)
        nSel = nItem;

	// update the list box
    RichListBoxWndProc(_hwndList, LB_SETCURSEL, (LPARAM)nSel, 0);
	RichListBoxWndProc(_hwndList, LB_SETTOPINDEX, (LPARAM)max(nItem, 0), 0);	
    return nItem;
}


/*
 *	CCmbBxWinHost::HideListBox(BOOL, BOOL)
 *
 *	@mfunc
 *		Hides the list box
 *
 *	@rdesc
 *		void
 */
BOOL CCmbBxWinHost::HideListBox(BOOL bNotify, BOOL fSelOk)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::HideListBox");

	//send CBN_SELENDOK to all types of comboboxes but only
    // allow CBN_SELENDCANCEL to be sent for droppable comboboxes
	if (bNotify)
	{
		if (fSelOk)
		{
			TxNotify(CBN_SELENDOK, NULL);
		}
		else if (_cbType != kSimple)
		{
			TxNotify(CBN_SELENDCANCEL, NULL);
		}
	}
	
    // return, we don't hide simple combo boxes.
	if (!_fListVisible || _cbType == kSimple) 
    	return TRUE;

    // Tell the listbox to end tracking
    Assert(_plbHost);
	_plbHost->OnCBTracking(LBCBM_END, 0);     	
    
    // Hide the listbox window
    _fListVisible = 0;
    ShowWindow(_hwndList, SW_HIDE);
	if (_fCapture)
	{
		_fCapture = FALSE;
		TxSetCapture(FALSE);
	}

	_fResizing = 1;
    // Invalidate the item area now since SWP() might update stuff.
    // Since the combo is CS_VREDRAW/CS_HREDRAW, a size change will
    // redraw the whole thing, including the item rect.  But if it
    // isn't changing size, we still want to redraw the item anyway
    // to show focus/selection
    if (_cbType == kDropDownList)
	{
		if (!_fOwnerDraw)
			HiliteEdit(_fFocus);
        InvalidateRect(_hwnd, NULL, TRUE);
	}

	//bug fix
	// The button may look depressed so we must redraw the button
	if (_fMousedown)
	{
		_fMousedown = FALSE;
		InvalidateRect(_hwnd, &_rcButton, FALSE);
	}

    SetWindowPos(_hwnd, HWND_TOP, 0, 0, _cxCombo, _cyCombo, 
    	SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

	_fResizing = 0;

	if (_cbType == kDropDown)
		AutoUpdateEdit(_nCursor);
	_nCursor = -2;

    // In case size didn't change
    UpdateWindow(_hwnd);

    if (bNotify) 
    {
        //Notify parent we will be popping up the combo box.
        TxNotify(CBN_CLOSEUP, NULL);
    }

	// reset back to old cursor if mouse cursor was set
	if (_hcurOld)
	{
		TxSetCursor2(_hcurOld, NULL);
		_hcurOld = NULL;
	}
    return(TRUE);
}



/*
 *	CCmbBxWinHost::ShowListBox(BOOL)
 *
 *	@mfunc
 *		Displays the list box
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::ShowListBox(BOOL fTrack)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::ShowListBox");
	
	Assert(_cbType != kSimple);
	Assert(_hwndList);

	// Notify parent window we are about to drop down the list box
	TxNotify(CBN_DROPDOWN, NULL);

	// force a redraw of the button so it looks depressed
	InvalidateRect(_hwnd, &_rcButton, TRUE);

	_fListVisible = TRUE;
	_fIgnoreChange = 0;

	_bSelOk = 0;
	if (_cbType == kDropDown)
	{
		UpdateListBox(!_fMousedown);
		if (!_fMousedown)
			AutoUpdateEdit(-1);
		_nCursor = _plbHost->GetCursor();

	}
	else
	{
        // Scroll the currently selected item to the top of the listbox.        
		int idx = (signed)_plbHost->GetCursor();
		_nCursor = idx;
		if (idx == -1)
			idx = 0;

		// set the top index if there is something in the list box
		if (_plbHost->GetCount() > 0)
			RichListBoxWndProc(_hwndList, LB_SETTOPINDEX, idx, 0);	

		// We are to lose focus in this case
		_fFocus = 0;
		if (!_fOwnerDraw)
			HiliteEdit(FALSE);
		
	    // We need to invalidate the edit rect so that the focus frame/invert
        // will be turned off when the listbox is visible.  Tandy wants this for
        // his typical reasons...        
        InvalidateRect(_hwnd, NULL, TRUE);        
    }

    // Figure out where to position the dropdown listbox.
    // We want the dropdown to pop below or above the combo
    // Get screen coords
    RECT rcList;
	POINT pt1;
    pt1.x = _rcList.left;
    pt1.y = _rcList.top;

	TxClientToScreen(&pt1);
	rcList.left = pt1.x;
	rcList.top = pt1.y;
	rcList.right = rcList.left + (_rcList.right - _rcList.left);
	rcList.bottom = rcList.top + _cyList;


    // List area
    int cyItem = _plbHost->GetItemHeight();
    AssertSz(cyItem, "LB_GETITEMHEIGHT is returning 0");

    if (cyItem == 0)
    	cyItem = _plbHost->GetFontHeight();

    // Windows NT comment:
    //  we shoulda' just been able to use cyDrop here, but thanks to VB's need
    //  to do things their OWN SPECIAL WAY, we have to keep monitoring the size
    //  of the listbox 'cause VB changes it directly (jeffbog 03/21/94)
    int iHeight = max(_cyList, _rcWindow.bottom - _rcWindow.top);
	DWORD dwMult = (DWORD)RichListBoxWndProc(_hwndList, LB_GETCOUNT, 0, 0);
	
    if (dwMult) 
    {
        dwMult = (DWORD)(LOWORD(dwMult) * cyItem);
        dwMult += GetSystemMetrics(SM_CYEDGE);

        if (dwMult < 0x7FFF)
            iHeight = min(LOWORD(dwMult), iHeight);
    }

    if (!_fNoIntegralHeight) 
    {
        iHeight = ((iHeight - GetSystemMetrics(SM_CYEDGE)) / cyItem) * cyItem + 
        	GetSystemMetrics(SM_CYEDGE);
    }

    //UNDONE: Multi-monitor
    //	We need to change the following code if we are to support multi-monitor
    int yTop;
    int nScreenHeight = GetSystemMetrics(SM_CYFULLSCREEN);    
    if (rcList.top + iHeight <= nScreenHeight) 
    {
        yTop = rcList.top;
        if (!_fBorder)
            yTop -= GetSystemMetrics(SM_CYBORDER);
    } 
    else 
    {
        yTop = max(rcList.top - iHeight - _cyCombo + 
			((_fBorder) ? GetSystemMetrics(SM_CYBORDER) : 0), 0);
    }

    
    SetWindowPos(_hwndList, HWND_TOPMOST, rcList.left,
        yTop, rcList.right - rcList.left, iHeight, 0);

	Assert(_plbHost);
    _plbHost->SetScrollInfo(SB_VERT, FALSE);

	
	if (_cbType == kDropDownList)
		_fFocus = 0;

	// UNDONE:
	// Are we going to support window animation?	
    ShowWindow(_hwndList, SW_SHOW);
	
	// We send a message to the listbox to prepare for tracking
	if (fTrack)
	{		
		Assert(_plbHost);
		// initialize type searching
		_plbHost->InitSearch();
		_plbHost->OnCBTracking(LBCBM_PREPARE, LBCBM_PREPARE_SAVECURSOR | 
						((_cbType == kDropDownList) ? LBCBM_PREPARE_SETFOCUS : 0));
	}
	
	// Since we are about to display the list box change mouse cursor to arrow
	if (!_hcurOld)
		_hcurOld = TxSetCursor2(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)), NULL);
}

////////////////////////// Combo box Message Handlers ////////////////////////////////

/*
 *	CCmbBxWinHost::CbSetItemHeight(BOOL, int)
 *
 *	@mfunc
 *		Sets the size of the edit or list box.
 *
 *
 *	@rdesc
 *		LRESULT = successful ? 1 : CB_ERR
 */
LRESULT CCmbBxWinHost::CbSetItemHeight(BOOL bEdit, int nHeight)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbSetItemHeight");

	//bug fix #4556
	if (nHeight == 0 || nHeight > 255)
		return CB_ERR;

	// We need to update the height internally
	if (bEdit)
	{
		RECT rc;
		GetClientRect(_hwnd, &rc);
		_dyEdit = nHeight;
		OnSize(0, MAKELONG(rc.right - rc.left, rc.bottom - rc.top));
	}
	else
	{
		RichListBoxWndProc(_hwndList, LB_SETITEMHEIGHT, 0, MAKELPARAM(nHeight, 0));
	}
	return 1;
}

/*
 *	CCmbBxWinHost::CbGetItemHeight(BOOL)
 *
 *	@mfunc
 *		Retrieves the size of the edit or list box.
 *
 *
 *	@rdesc
 *		LRESULT = successful ? 1 : CB_ERR
 */
LRESULT CCmbBxWinHost::CbGetItemHeight(BOOL bEdit)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbGetItemHeight");

	// We need to update the height internally
	if (bEdit)
	{
		return _dyEdit;
	}
	else
	{
		return RichListBoxWndProc(_hwndList, LB_GETITEMHEIGHT, 0, 0);
	}
}


/*
 *	CCmbBxWinHost::CbSetExtendedUI(BOOL)
 *
 *	@mfunc
 *		Retrieves the size of the edit or list box.
 *
 *
 *	@rdesc
 *		LRESULT = successful ? CB_OKAY : CB_ERR
 */
LRESULT CCmbBxWinHost::CbSetExtendedUI(BOOL bExtendedUI)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbSetExtendedUI");

	// We need to update the height internally
	_fExtendedUI = bExtendedUI ? 1 : 0;
	return CB_OKAY;
}


/*
 *	CCmbBxWinHost::CbMessageItemHandler(int, WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles any and all WM_DRAWITEM and WM_DELETEITEM messages
 *
 *
 *	@rdesc
 *		LRESULT = whatever the parent window returns
 */
LRESULT CCmbBxWinHost::CbMessageItemHandler(HDC hdc, int ff, WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbMessageItemHandler");

	// modify the structure info a bit and pass it to the parent window
    DRAWITEMSTRUCT dis;   
    BOOL bRelease = FALSE;
    UINT msg = WM_DRAWITEM;
	switch (ff)
	{
	case ITEM_MSG_DRAWLIST:
		((LPDRAWITEMSTRUCT)lparam)->CtlType = ODT_COMBOBOX;
	    ((LPDRAWITEMSTRUCT)lparam)->CtlID = _idCtrl;
	    ((LPDRAWITEMSTRUCT)lparam)->hwndItem = _hwnd;	    
	    break;

	case ITEM_MSG_DELETE:
		((LPDELETEITEMSTRUCT)lparam)->CtlType = ODT_COMBOBOX;
	    ((LPDELETEITEMSTRUCT)lparam)->CtlID = _idCtrl;
	    ((LPDELETEITEMSTRUCT)lparam)->hwndItem = _hwnd;
	    msg = WM_DELETEITEM;
	    break;

	case ITEM_MSG_DRAWCOMBO:
		if (!hdc)
	    {
	    	bRelease = TRUE;
	    	hdc = TxGetDC();
	    }
	    //Fill the DRAWITEMSTRUCT with the unchanging constants
	    dis.CtlType = ODT_COMBOBOX;
	    dis.CtlID = _idCtrl;    

	    // Use -1 if an invalid item number is being used.  This is so that the app
	    // can detect if it should draw the caret (which indicates the lb has the
	    // focus) in an empty listbox
	    dis.itemID = _plbHost->GetCursor();
	    dis.itemAction = ODA_DRAWENTIRE;
	    dis.hwndItem = _hwnd;	    
	    dis.hDC = hdc;
		dis.itemData = (_plbHost->GetCount()) ? (((signed)dis.itemID >= 0) ? _plbHost->GetData(dis.itemID) : 0) : 0;
	    dis.itemState = (UINT)((_fFocus && !_fListVisible ? ODS_SELECTED | ODS_FOCUS : 0) |
                    ((_fDisabled) ? ODS_DISABLED : 0) | ODS_COMBOBOXEDIT);
		           
		// Calculate the drawing rect
        TxGetClientRect(&dis.rcItem);
        if (_cbType != kSimple)
        {
        	if (_fRightAlign)
        		dis.rcItem.left = _rcButton.right;
        	else
        		dis.rcItem.right = _rcButton.left;
        }

        // immulate the system by making the HDC invert text if we have focus
		SetBkMode(hdc, OPAQUE);
		PatBlt(hdc, dis.rcItem.left, dis.rcItem.top, dis.rcItem.right - dis.rcItem.left,
                dis.rcItem.bottom - dis.rcItem.top, PATCOPY);

		if (_fFocus && !_fListVisible) 
		{
	        // only do the FillRect if we know its not
	        // ownerdraw item, otherwise we mess up people up
	        // BUT: for Compat's sake we still do this for Win 3.1 guys
            SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
        } 
        
        // Don't let ownerdraw dudes draw outside of the combo client
        // bounds.
		InflateRect(&dis.rcItem, -1, -1);
        IntersectClipRect(hdc, dis.rcItem.left, dis.rcItem.top, dis.rcItem.right, 
        				dis.rcItem.bottom);
	    lparam = (LPARAM)&dis;		
	}

	LRESULT lres = SendMessage(_hwndParent, msg, _idCtrl, lparam);
	if (bRelease)
		TxReleaseDC(hdc);

	return lres;
}

/////////////////////////// Windows Message Handlers /////////////////////////////////
/* 
 *	CCmbBxWinHost::OnCommand(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles notification from listbox and reflects it to the parent of
 *		the combo box
 *
 *	@comm
 *		LRESULT = Handled ? 0 : 1
 *
 *
 */
HRESULT CCmbBxWinHost::OnCommand(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CCmbBxWinHost::OnCommand");
	
	// Filter-out all the messages except Listbox notification messages
	Assert(_hwndParent);
	switch (HIWORD(wparam))
	{	
	case LBN_DBLCLK:
    	TxNotify(CBN_DBLCLK, NULL);
        break;

    case LBN_ERRSPACE:
        TxNotify((unsigned)CBN_ERRSPACE, NULL);
        break;

    case LBN_SELCHANGE:
    case LBN_SELCANCEL:
    	if (!_fListVisible)
			HideListBox(TRUE, TRUE);
    	TxNotify(CBN_SELCHANGE, NULL);
        UpdateEditBox();
        break;

    default:
    	// not handled so pass down the line
        return 1;
	}
	return 0;
}

/*
 *	CCmbBxWinHost::OnEnable(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_ENABLE message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnEnable(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnEnable");

	if (_fMousedown) 
	{
        _fMousedown = FALSE;
        DrawButton(NULL, FALSE);

        //
        // Pop combo listbox back up, canceling.
        //
        if (_fListVisible)
            HideListBox(TRUE, FALSE);
    }
    return 1;
}


/*
 *	CCmbBxWinHost::OnChar(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_CHAR message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnChar(WORD wparam, DWORD lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnChar");

	// Check if we should eat the message or not
	if (_cbType == kDropDownList)
	{
		//bug fix #5318 - ignore delete, insert and clear
		if (((WCHAR)wparam) == VK_DELETE || ((WCHAR)wparam) == VK_INSERT ||
			((WCHAR)wparam) == VK_CLEAR)
			return 0;
			
		// Sending WM_CHAR is BAD!!! call the message handler directly
		// send the character string message to the listbox if visible
		_plbHost->OnChar(LOWORD(wparam), lparam);

		//	If Hi-Ansi need to send a wm_syskeyup message to ITextServices to 
		// stabalize the state
		if (0x80 <= wparam && wparam <= 0xFF && !HIWORD(GetKeyState(VK_MENU)))
		{
			LRESULT lres;
			_pserv->TxSendMessage(WM_SYSKEYUP, VK_MENU, 0xC0000000, &lres);
		}		
		return 0;
	}

	
	if (_cbType == kDropDown)
	{
		if (_fListVisible)
		{
			if (!_fCapture)
			{
				// Tell listbox to reset capturing by ending then starting it up
				_plbHost->OnCBTracking(LBCBM_END, 0);
				_plbHost->OnCBTracking(LBCBM_PREPARE, 0);			
			}

			// Send the message to the edit control iff it's not a tab
			if (((WCHAR)wparam) != VK_TAB)
				_pserv->TxSendMessage(WM_CHAR, wparam, lparam, NULL);

			if (!_fCapture)
			{
				// capture the cursor
				TxSetCapture(TRUE);
				_fCapture = 1;				
			}
		}
		else
		{
			// set the cursel to -1 if it already isn't
			if ((wparam != VK_RETURN) && (_plbHost->GetCursor() != -1))
				RichListBoxWndProc(_hwndList, LB_SETCURSEL, (WPARAM)-1, 0);

			// Send the message to the edit control iff it's not CTRL+i or CTRL+h
			if (((WCHAR)wparam) != VK_TAB)
				_pserv->TxSendMessage(WM_CHAR, wparam, lparam, NULL);
		}		
		return 0;
	}
	return 1;
}

/*
 *	CCmbBxWinHost::OnKeyDown(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_KEYDOWN message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnKeyDown(WORD wparam, DWORD lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnKeyDown");

	if (_fListVisible && (wparam == VK_RETURN || wparam == VK_ESCAPE))
	{
		if (wparam == VK_RETURN)
			_nCursor = _plbHost->GetCursor();
		HideListBox(TRUE, wparam == VK_RETURN);
		return 0;
	}
	
	// if we are in extended mode and F4 is hit
	// we just ignore it
	if (_fExtendedUI && wparam == VK_F4)
		return 0;
	
	Assert(_plbHost);
	int fExtUI = _fExtendedUI;
	int nCurSel = _plbHost->GetCursor();
	Assert(nCurSel >= -1);
	
	// if we are a dropdownlist combo box then just forward the message on to the 
	// list box 
	if (_cbType == kDropDownList)
	{
		switch (wparam)
		{		
		case VK_F4:
			if (_fListVisible)
				break;;
			fExtUI = 1;
			Assert(fExtUI && !_fListVisible);
			// fall through case		
			
		case VK_DOWN:
			if (fExtUI && !_fListVisible)
			{
				ShowListBox(TRUE);
				TxSetCapture(TRUE);			
				_fCapture = TRUE;
				return 1;			
			}		
			// Fall through case
			
		case VK_UP:
		case VK_NEXT:
		case VK_PRIOR:		
		case VK_RETURN:
		case VK_ESCAPE:	
			break;	

		//bug fix #5318
		/*
		case VK_DELETE:
		case VK_CLEAR:
		case VK_INSERT:
		*/

		default:
			// There no reason for us to pass these keys to ITextServices since the control is suppose
			// to be read-only
			return 0;
		}
	}
	else 
	{
		switch (wparam)
		{		
		case VK_F4:
			if (_fListVisible)
				break;
			fExtUI = 1;
			Assert(fExtUI && !_fListVisible);
			// fall through case		
			
		case VK_DOWN:
			if (fExtUI && !_fListVisible)
			{
				ShowListBox(TRUE);
				TxSetCapture(TRUE);			
				_fCapture = TRUE;
				return 0;			
			}		
			// Fall through case
			
		case VK_UP:
		case VK_NEXT:
		case VK_PRIOR:
			if (_fListVisible)
			{				
				if (_fCapture)
				{
					// release our capture flag and tell lb to start tracking
					_fCapture = 0;
					_plbHost->OnCBTracking(LBCBM_START, _fMousedown);
				}

				// selecting the top index and then sending the keydown to the 
				// listbox causes 2 moves so handle this ourselves
				if (nCurSel == -1)
				{
					RichListBoxWndProc(_hwndList, LB_SETCURSEL, _plbHost->GetTopIndex(), 0);
					UpdateEditBox();
					UpdateCbWindow();
					return 0;
				}
			}
			else
			{
				// if Listbox isn't visible and the listbox cursor is -1
				// then we should try to select the correct item in the list
				// box
				if (nCurSel == -1)
				{
					UpdateListBox(TRUE);
					if (_plbHost->GetCursor() >= 0)
					{
						HiliteEdit(TRUE);
						return 0;
					} else if (!_plbHost->GetCount())
					{
						return 0;
					}
				}
			}
			break;
		
		case VK_RETURN:
		case VK_ESCAPE:	
			break;		

		default:
			// return zero to say we didn't handle this
			return 1;
		}
	}
	// pass message to list box
	_plbHost->OnKeyDown(wparam, lparam, 0);
	UpdateCbWindow();
			
	return 0; 
	
}

/*
 *	CCmbBxWinHost::OnSyskeyDown(WORD, DWORD)
 *
 *	@mfunc
 *		handles the WM_SYSKEYDOWN message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnSyskeyDown(WORD wparam, DWORD lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSyskeyDown");

	if (lparam & 0x20000000L)  /* Check if the alt key is down */ 
	{
	    // Handle Combobox support.  We want alt up or down arrow to behave
	    // like F4 key which completes the combo box selection
		if (lparam & 0x1000000)
		{
			// We just want to ignore keys on the number pad...
	        // This is an extended key such as the arrow keys not on the
	        // numeric keypad so just drop the combobox.
	        if (wparam != VK_DOWN && wparam != VK_UP)
	            return 1;
		}
		else if (GetKeyState(VK_NUMLOCK) & 0x1) 
	    {
	        //If numlock down, just send all system keys to dwp
	        return 1;
	    } 
	    else 
	    {
			if (wparam != VK_DOWN && wparam != VK_UP)
				return 1;	    	
	    }

	    // If the listbox isn't visible, just show it
	    if (!_fListVisible) 
		{
			ShowListBox(TRUE);
			TxSetCapture(TRUE);			
			_fCapture = TRUE;
		}
	    else  	//Ok, the listbox is visible.  So hide the listbox window.
	        HideListBox(TRUE, TRUE);
	    return 0;
	}
	return 1;
}

/*
 *	CCmbBxWinHost::OnCaptureChanged(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_CAPTURECHANGED message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnCaptureChanged(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnCaptureChanged");
    if (_fCapture) 
    {   
        // Pop combo listbox back up, canceling.
        if (_fListVisible)
            HideListBox(TRUE, FALSE);
        else
        {
        	_fCapture = FALSE;
   			_fMousedown = FALSE;
        	DrawButton(NULL, FALSE);
        }
		return 0;
    }
	return 1;
}


/*
 *	CCmbBxWinHost::OnMouseMove(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_MOUSEMOVE message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnMouseMove(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnMouseMove");

	// We do the following if we have mouse captured or if the listbox is visible
	if (_cbType != kSimple && _fCapture)
	{
		// get the point coordinates of mouse
		POINT pt;
		POINTSTOPOINT(pt, lparam);
		if (_fListVisible)
		{
			// if the listbox is visible visible check if the cursor went over 
			// list box
			RECT rc;
			POINT ptScreen = pt;
			GetWindowRect(_hwndList, &rc);
			TxClientToScreen(&ptScreen);			
			if (PtInRect(&rc, ptScreen))
			{
				// Release the capture state of the mouse
				if (_fCapture)
				{
					_fCapture = FALSE;
					TxSetCapture(FALSE);
				}

				// notify the listbox to start tracking
				Assert(_plbHost);					
				::PostMessage(_hwndList, LBCB_TRACKING, LBCBM_START, _fMousedown);
				_fMousedown = 0;
			}
		}
		DrawButton(NULL, _fMousedown ? PtInRect(&_rcButton, pt) : FALSE);
		return FALSE;
	}
#ifdef DEBUG
	if (_cbType != kSimple)
		Assert(!_fListVisible);
#endif
	return TRUE;
}
	
/*
 *	CCmbBxWinHost::OnLButtonUp(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_LBUTTONUP message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnLButtonUp(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnLButtonUp");
 
    if (_fMousedown) 
	{
        _fMousedown = FALSE;
        if (_cbType != kSimple) 
		{
            // If an item in the listbox matches the text in the edit
            // control, scroll it to the top of the listbox. Select the
            // item only if the mouse button isn't down otherwise we
            // will select the item when the mouse button goes up.
			if (_cbType == kDropDown)
			{
				UpdateListBox(TRUE);
				AutoUpdateEdit(-1);		
			}
			
			// if we recieved a mouse up and the listbox is still visible then user 
			// hasn't selected any items from the listbox so don't release the capture yet
			if (_fCapture && !_fListVisible)
			{
				_fCapture = FALSE;
				TxSetCapture(FALSE);
			}

			DrawButton(NULL, FALSE);       
			return FALSE;
		}
    }
	return TRUE;
}

/*
 *	CCmbBxWinHost::OnLButtonDown(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the client edges of the combo box
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnLButtonDown(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnLButtonDown");

	// check if we should dropdown the list box
	POINT pt;
	POINTSTOPOINT(pt, lparam);
	
	// if we don't have focus then set the focus first
	if (!_fFocus)
		TxSetFocus();
	_fFocus = 1;

	// listbox is down so pop it back up
	if (_fListVisible)
	{
		return !HideListBox(TRUE, FALSE);		
	}
	else if (_cbType == kDropDownList || (_cbType == kDropDown && PtInRect(&_rcButton, pt)))
	{	
		// need to show listbox
		ShowListBox(TRUE);
		_fMousedown = TRUE;
					
		TxSetCapture(TRUE);			
		_fCapture = TRUE;
		return 0;
	}
	return 1;
}

/*
 *	CCmbBxWinHost::OnMouseWheel(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the client edges of the combo box
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnMouseWheel(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnMouseWheel");
	
    // Handle only scrolling.
    if (wparam & (MK_CONTROL | MK_SHIFT))
        return 1;

    // If the listbox is visible, send it the message to scroll.
    // if the listbox is 
	if (_fListVisible)
	{
		_plbHost->OnMouseWheel(wparam, lparam);
		return 0;
	}
		
    // If we're in extended UI mode or the edit control isn't yet created,
    // bail.
    if (_fExtendedUI)
        return 0;

    // Emulate arrow up/down messages to the edit control.
    int i = abs(((short)HIWORD(wparam))/WHEEL_DELTA);
    wparam = ((short)HIWORD(wparam) > 0) ? VK_UP : VK_DOWN;

    while (i-- > 0) 
        OnKeyDown(wparam, lparam);

	return 0;
}


/*
 *	CCmbBxWinHost::OnSetCursor(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Changes the cursor depending on where the cursor is
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
 LRESULT CCmbBxWinHost::OnSetCursor(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSetCursor");

	POINT pt;
	GetCursorPos(&pt);
	::ScreenToClient(_hwnd, &pt);

	if ((_cbType == kDropDownList) || 
		(_cbType == kDropDown && ((_fRightAlign) ? _rcButton.right >= pt.x : _rcButton.left <= pt.x)))
	{
		TxSetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)), NULL);
	}
	else
		_pserv->OnTxSetCursor(DVASPECT_CONTENT,	-1,	NULL, NULL, NULL, NULL,
			NULL, pt.x, pt.y);

	return TRUE;
}

/*
 *	CCmbBxWinHost::OnSetFocus(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
 LRESULT CCmbBxWinHost::OnSetFocus(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSetFocus");

    _fFocus = TRUE;

	// Hide the list box
	if (_fListVisible)		    	
    	HideListBox(TRUE, _bSelOk);
    else if (_fOwnerDraw && _cbType == kDropDownList)
    	CbMessageItemHandler(NULL, ITEM_MSG_DRAWCOMBO, 0, 0);
	else    
		DrawEditFocus(NULL);    // Draw the focus 

    // Notify the parent we have the focus iff this function
    // wasn't called in response to LBCB_TRACKING
    if (_fLBCBMessage)
    	_fLBCBMessage = 0;
    else
	    TxNotify(CBN_SETFOCUS, NULL);

	// we return 1 if we are owner draw or if
	// we are a kDropDownList, this is because
	// we have to prevent the message from being passed
	// to _pserv
    return (_cbType == kDropDownList);
}


/*
 *	CCmbBxWinHost::OnKillFocus(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
 LRESULT CCmbBxWinHost::OnKillFocus(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnKillFocus");

	// if we never had focus or if not list window just get out
	if (_hwndList == NULL)
	      return 0;
		
    if ((HWND)wparam != _hwndList) 
    {
		// We only give up the focus if the new window getting the focus
        // doesn't belong to the combo box.
	    
	    // The combo box is losing the focus.  Send buttonup clicks so that
	    // things release the mouse capture if they have it...  If the
	    // pwndListBox is null, don't do anything.  This occurs if the combo box
	    // is destroyed while it has the focus.
	    OnLButtonUp(0L, 0xFFFFFFFFL);

		if (_fListVisible)
			HideListBox(TRUE, FALSE);		
	}

	//bug fix #4013
	if (!_fFocus)
		return 0;
	_fFocus = FALSE;
	
	// Remove Focus Rect
	if (_cbType != kDropDownList)
	{		
		HiliteEdit(FALSE);

		// Hide any selections
		_pserv->TxSendMessage(EM_HIDESELECTION, 1, 0, NULL);
	}
	else if (_fOwnerDraw)
		CbMessageItemHandler(NULL, ITEM_MSG_DRAWCOMBO, 0, 0);
	else
		DrawEditFocus(NULL);
		
		
	TxNotify(CBN_KILLFOCUS, NULL); 

	if (_cbType == kDropDownList)
		return 1;
	return 0;
}


/*
 *	CCmbBxWinHost::OnSize(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = Processed ? FALSE : TRUE
 */
 LRESULT CCmbBxWinHost::OnSize(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnCbSize");

    // only deal with this message if we didn't generate the message and
    // the new size is a valid one
    if (!_fResizing && _hwndList)
    {
    	_fResizing = 1;
    	RECT rc;
    	GetWindowRect(_hwnd, &rc);
    	rc.right -= rc.left;
    	rc.bottom -= rc.top;    	
    	rc.left = rc.top = 0;
    	CbCalcControlRects(&rc, FALSE);
    	
    	// Need to resize the list box
		if (_cbType != kSimple)
			SetDropSize(&_rcList);
		_fResizing = 0;
    } 
	_pserv->TxSendMessage(WM_SIZE, wparam, lparam, NULL);
	CTxtWinHost::OnSize(_hwnd, wparam, (int)LOWORD(lparam), (int)HIWORD(lparam));	
	return FALSE;
}

/*
 *	CCmbBxWinHost::OnGetDlgCode(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
 LRESULT CCmbBxWinHost::OnGetDlgCode(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnGetDlgCode");

	// call the parents GetDlgCode first	
	LRESULT code = DLGC_WANTCHARS | DLGC_WANTARROWS;
	if (_cbType != kDropDownList)
		code |= DLGC_HASSETSEL;

	// If the listbox is dropped and the ENTER key is pressed,
	// we want this message so we can close up the listbox
	if ((lparam != 0) &&
	    (((LPMSG)lparam)->message == WM_KEYDOWN) &&
	    _fListVisible &&
	    ((wparam == VK_RETURN) || (wparam == VK_ESCAPE)))
	{
	    code |= DLGC_WANTMESSAGE;
	}
	_fInDialogBox = TRUE;
		
	return((LRESULT)code);
}

/*
 *	CCmbBxWinHost::OnSetTextEx(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
 LRESULT CCmbBxWinHost::OnSetTextEx(WPARAM wparam, LPARAM lparam)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSetTextEx");

 	WCHAR* psz = (WCHAR*)lparam;

 	while (*psz != L'\r')
 		psz++;
 	*psz = L'\0';

 	//Send message to host
 	_pserv->TxSendMessage(EM_SETTEXTEX, wparam, lparam, NULL);

	//Set the string back to old and send message to listbox
 	*psz = L'\r';
 	psz++;
 	return ::SendMessage(_hwndList, EM_SETTEXTEX, wparam, (LPARAM)psz);
 }

/*
 *	CCmbBxWinHost::OnPaint(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = processed ? 0 : 1
 */
 LRESULT CCmbBxWinHost::OnPaint(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnPaint");

	PAINTSTRUCT ps;
	HPALETTE hpalOld = NULL;
	HDC hdc = BeginPaint(_hwnd, &ps);
	RECT rcClient;
	
	// Since we are using the CS_PARENTDC style, make sure
	// the clip region is limited to our client window.
	GetClientRect(_hwnd, &rcClient);
	
	// pass message on to the parentwindow if owner draw
	if (_cbType != kDropDownList || !_fOwnerDraw)
	{
		RECT rcFocus = rcClient;
		
		// Set up the palette for drawing our data
		if (_hpal)
		{
			hpalOld = SelectPalette(hdc, _hpal, TRUE);
			RealizePalette(hdc);
		}

		SaveDC(hdc);

		IntersectClipRect(hdc, rcClient.left, rcClient.top, rcClient.right,
			rcClient.bottom);

		// Fill-in the gap between the button and richedit control
		RECT rcGap;
		if (_fRightAlign)
		{
			rcGap.left = _rcButton.right;
			rcGap.right = rcGap.left + _xInset + 1;
		}
		else
		{
			rcGap.right = _rcButton.left;
			rcGap.left = rcGap.right - _xInset - 1;
		}
		rcGap.top = rcClient.top;
		rcGap.bottom = rcClient.bottom;			
		FillRect(hdc, &rcGap, (HBRUSH)(DWORD_PTR)(((_fDisabled) ? COLOR_BTNFACE : COLOR_WINDOW) + 1));
	
		if (_fFocus && _cbType == kDropDownList)		
		{	
			//First if there is a focus rect then remove the focus rect
			// shrink the focus rect by the inset
			rcFocus.top += _yInset;
			rcFocus.bottom -= _yInset;			
			
			if (_fRightAlign)
				rcFocus.left = _rcButton.right;
			else
				rcFocus.right = _rcButton.left;

			rcFocus.left += _xInset;
			rcFocus.right -= _xInset;

			// We need to erase the focus rect if we haven't already 
			// erased the background
			DrawFocusRect(hdc, &rcFocus);
		}		

		_pserv->TxDraw(
			DVASPECT_CONTENT,  		// Draw Aspect
			-1,						// Lindex
			NULL,					// Info for drawing optimazation
			NULL,					// target device information
			hdc,					// Draw device HDC
			NULL, 				   	// Target device HDC
			(const RECTL *) &rcClient,// Bounding client rectangle
			NULL, 					// Clipping rectangle for metafiles
			&ps.rcPaint,			// Update rectangle
			NULL, 	   				// Call back function
			NULL,					// Call back parameter
			TXTVIEW_ACTIVE);		// What view - the active one!

		// Restore palette if there is one
		if(hpalOld)
			SelectPalette(hdc, hpalOld, TRUE);

		RestoreDC(hdc, -1);

		if(TxGetEffects() == TXTEFFECT_SUNKEN && dwMajorVersion < VERS4)
			DrawSunkenBorder(_hwnd, hdc);

		//Redraw the focus rect, don't have to recalc since we already did above
		if (_fFocus && _cbType == kDropDownList)
			DrawFocusRect(hdc, &rcFocus);

		DrawButton(hdc, _fMousedown);
	}
	else
	{
		// We have to draw the button first because CbMessageItemHandler
		// will perform a IntersectClipRect which will prevent us from
		// drawing the button later
		DrawButton(hdc, _fMousedown);
		
		CbMessageItemHandler(hdc, ITEM_MSG_DRAWCOMBO, 0, 0);
	}
	EndPaint(_hwnd, &ps);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\clasifyc.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module clasifyc.cpp -- Kinsoku classify characters |
 *	
 *		Used in word breaking procs, particularly important
 *		for properly wrapping a line.
 *	
 *	Authors: <nl>
 *		Jon Matousek
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */								

#include "_common.h"
#include "_clasfyc.h"
#include "_array.h"

ASSERTDATA

// Data for Kinsoku character classifications.
// NOTE: All values are for UNICODE characters.

// "dumb" quotes and other characters with no left/right orientation.
// This is a hack-around the Kinsoku rules, these are treated
// like an opening paren, when leading and kind of like a closing
// paren when follow--but will only break on white space in former case.
#define	brkclsQuote	0
#define C3_FullWidth	(C3_KATAKANA | C3_HIRAGANA | C3_IDEOGRAPH | C3_FULLWIDTH)

const WCHAR set0[] = {
	0x0022,	// QUOTATION MARK
	0x0027, // APOSTROPHE
	0x2019, // RIGHT SINGLE QUOTATION MARK
	0x301F,	// LOW DOUBLE PRIME QUOTATION MARK
	0xFF02,	// FULLWIDTH QUOTATION MARK
	0xFF07,	// FULLWIDTH APOSTROPHE
	0
};

// Opening-parenthesis character
#define	brkclsOpen	1

const WCHAR set1[] = {
	0x0028, // LEFT PARENTHESIS
	0x003C,	// LEFT ANGLE BRACKET
	0x005B, // LEFT SQUARE BRACKET
	0x007B, // LEFT CURLY BRACKET
	0x00AB, // LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
	0x2018, // LEFT SINGLE QUOTATION MARK
	0x201C, // LEFT DOUBLE QUOTATION MARK
	0x2039, // SINGLE LEFT-POINTING ANGLE QUOTATION MARK
	0x2045, // LEFT SQUARE BRACKET WITH QUILL
	0x207D, // SUPERSCRIPT LEFT PARENTHESIS
	0x208D, // SUBSCRIPT LEFT PARENTHESIS
	0x3008, // LEFT ANGLE BRACKET
	0x300A, // LEFT DOUBLE ANGLE BRACKET
	0x300C, // LEFT CORNER BRACKET
	0x300E, // LEFT WHITE CORNER BRACKET
	0x3010, // LEFT BLACK LENTICULAR BRACKET
	0x3014, // LEFT TORTOISE SHELL BRACKET
	0x3016, // LEFT WHITE LENTICULAR BRACKET
	0x3018, // LEFT WHITE TORTOISE SHELL BRACKET
	0x301A, // LEFT WHITE SQUARE BRACKET
	0x301D, // REVERSED DOUBLE PRIME QUOTATION MARK
	0xFD3E, // ORNATE LEFT PARENTHESIS
	0xFE59, // SMALL LEFT PARENTHESIS
	0xFE5B, // SMALL LEFT CURLY BRACKET
	0xFE5D, // SMALL LEFT TORTOISE SHELL BRACKET
	0xFF08, // FULLWIDTH LEFT PARENTHESIS
	0xFF3B, // FULLWIDTH LEFT SQUARE BRACKET
	0xFF5B, // FULLWIDTH LEFT CURLY BRACKET
	0xFF62, // HALFWIDTH LEFT CORNER BRACKET
	0xFFE9, // HALFWIDTH LEFTWARDS ARROW
	0
};

// Closing-parenthesis character
#define	brkclsClose	2

const WCHAR set2[] = {
	// 0x002C, // COMMA	moved to set 6 to conjoin numerals.
	0x002D,	// HYPHEN
	0x00AD,	// OPTIONAL HYPHEN
	0x055D, // ARMENIAN COMMA
	0x060C, // ARABIC COMMA
	0x3001, // IDEOGRAPHIC COMMA
	0xFE50, // SMALL COMMA
	0xFE51, // SMALL IDEOGRAPHIC COMMA
	0xFF0C, // FULLWIDTH COMMA
	0xFF64, // HALFWIDTH IDEOGRAPHIC COMMA

	0x0029, // RIGHT PARENTHESIS
	0x003E,	// RIGHT ANGLE BRACKET
	0x005D, // RIGHT SQUARE BRACKET
	0x007D, // RIGHT CURLY BRACKET
	0x00BB, // RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
	//0x2019, // RIGHT SINGLE QUOTATION MARK moved to set 0
	0x201D, // RIGHT DOUBLE QUOTATION MARK
	0x203A, // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
	0x2046, // RIGHT SQUARE BRACKET WITH QUILL
	0x207E, // SUPERSCRIPT RIGHT PARENTHESIS
	0x208E, // SUBSCRIPT RIGHT PARENTHESIS
	0x3009, // RIGHT ANGLE BRACKET
	0x300B, // RIGHT DOUBLE ANGLE BRACKET
	0x300D, // RIGHT CORNER BRACKET
	0x300F, // RIGHT WHITE CORNER BRACKET
	0x3011, // RIGHT BLACK LENTICULAR BRACKET
	0x3015, // RIGHT TORTOISE SHELL BRACKET
	0x3017, // RIGHT WHITE LENTICULAR BRACKET
	0x3019, // RIGHT WHITE TORTOISE SHELL BRACKET
	0x301B, // RIGHT WHITE SQUARE BRACKET
	0x301E, // DOUBLE PRIME QUOTATION MARK
	0xFD3F, // ORNATE RIGHT PARENTHESIS
	0xFE5A, // SMALL RIGHT PARENTHESIS
	0xFE5C, // SMALL RIGHT CURLY BRACKET
	0xFE5E, // SMALL RIGHT TORTOISE SHELL BRACKET
	0xFF09, // FULLWIDTH RIGHT PARENTHESIS
	0xFF3D, // FULLWIDTH RIGHT SQUARE BRACKET
	0xFF5D, // FULLWIDTH RIGHT CURLY BRACKET
	0xFF63, // HALFWIDTH RIGHT CORNER BRACKET
	0xFFEB, // HALFWIDTH RIGHTWARDS ARROW
	0
};

// 'Non-breaking' em-character at line-starting point
#define	brkclsGlueA	3

const WCHAR set3[] = {
	0x3005, // IDEOGRAPHIC ITERATION MARK
	0x309D, // HIRAGANA ITERATION MARK
	0x309E, // HIRAGANA VOICED ITERATION MARK
	0x30FC, // KATAKANA-HIRAGANA PROLONGED SOUND MARK
	0x30FD, // KATAKANA ITERATION MARK
	0x30FE, // KATAKANA VOICED ITERATION MARK
	0x3041, // HIRAGANA LETTER SMALL A
	0x3043, // HIRAGANA LETTER SMALL I
	0x3045, // HIRAGANA LETTER SMALL U
	0x3047, // HIRAGANA LETTER SMALL E
	0x3049, // HIRAGANA LETTER SMALL O
	0x3063, // HIRAGANA LETTER SMALL TU
	0x3083, // HIRAGANA LETTER SMALL YA
	0x3085, // HIRAGANA LETTER SMALL YU
	0x3087, // HIRAGANA LETTER SMALL YO
	0x308E, // HIRAGANA LETTER SMALL WA
	0x309B,	// KATAKANA-HIRAGANA VOICED SOUND MARK
	0x309C,	// KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
	0x30A1, // KATAKANA LETTER SMALL A
	0x30A3, // KATAKANA LETTER SMALL I
	0x30A5, // KATAKANA LETTER SMALL U
	0x30A7, // KATAKANA LETTER SMALL E
	0x30A9, // KATAKANA LETTER SMALL O
	0x30C3, // KATAKANA LETTER SMALL TU
	0x30E3, // KATAKANA LETTER SMALL YA
	0x30E5, // KATAKANA LETTER SMALL YU
	0x30E7, // KATAKANA LETTER SMALL YO
	0x30EE, // KATAKANA LETTER SMALL WA
	0x30F5, // KATAKANA LETTER SMALL KA
	0x30F6, // KATAKANA LETTER SMALL KE
	0xFF67, // HALFWIDTH KATAKANA LETTER SMALL A
	0xFF68, // HALFWIDTH KATAKANA LETTER SMALL I
	0xFF69, // HALFWIDTH KATAKANA LETTER SMALL U
	0xFF6A, // HALFWIDTH KATAKANA LETTER SMALL E
	0xFF6B, // HALFWIDTH KATAKANA LETTER SMALL O
	0xFF6C, // HALFWIDTH KATAKANA LETTER SMALL YA
	0xFF6D, // HALFWIDTH KATAKANA LETTER SMALL YU
	0xFF6E, // HALFWIDTH KATAKANA LETTER SMALL YO
	0xFF6F, // HALFWIDTH KATAKANA LETTER SMALL TU
	0xFF70, // HALFWIDTH KATAKANA-HIRAGANA PROLONGED SOUND MARK
	0xFF9E,	// HALFWIDTH KATAKANA VOICED SOUND MARK
	0xFF9F,	// HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
	0
};

// Expression mark
#define	brkclsExclaInterr	4

const WCHAR set4[] = {
	0x0021, // EXCLAMATION MARK
	0x003F, // QUESTION MARK
	0x00A1, // INVERTED EXCLAMATION MARK
	0x00BF, // INVERTED QUESTION MARK
	0x01C3, // LATIN LETTER RETROFLEX CLICK
	0x037E, // GREEK QUESTION MARK
	0x055C, // ARMENIAN EXCLAMATION MARK
	0x055E, // ARMENIAN QUESTION MARK
	0x055F, // ARMENIAN ABBREVIATION MARK
	0x061F, // ARABIC QUESTION MARK
	0x203C, // DOUBLE EXCLAMATION MARK
	0x203D, // INTERROBANG
	0x2762, // HEAVY EXCLAMATION MARK ORNAMENT
	0x2763, // HEAVY HEART EXCLAMATION MARK ORNAMENT
	0xFE56, // SMALL QUESTION MARK
	0xFE57, // SMALL EXCLAMATION MARK
	0xFF01, // FULLWIDTH EXCLAMATION MARK
	0xFF1F, // FULLWIDTH QUESTION MARK
	0
};

// Centered punctuation mark

const WCHAR set5[] = {		
//	0x003A,	// COLON		moved to set 6 to conjoin numerals.
//	0x003B, // SEMICOLON	moved to set 6 to conjoin numerals
	0x00B7, // MIDDLE DOT
	0x30FB, // KATAKANA MIDDLE DOT
	0xFF65, // HALFWIDTH KATAKANA MIDDLE DOT
	0x061B, // ARABIC SEMICOLON
	0xFE54, // SMALL SEMICOLON
	0xFE55, // SMALL COLON
	0xFF1A, // FULLWIDTH COLON
	0xFF1B, // FULLWIDTH SEMICOLON
	0
};

// Punctuation mark		// diverged from the Kinsoku tables to enhance
#define	brkclsSlash	6

const WCHAR set6[] = {	// How colon, comma, and full stop are treated around
	0x002C, // COMMA	//  numerals and set 15 (roman text).
	0x002f,	// SLASH	// But don't break up URLs (see IsURLDelimiter())!
	0x003A, // COLON
	0x003B, // SEMICOLON

	0x002E, // FULL STOP (PERIOD)
	0x0589, // ARMENIAN FULL STOP
	0x06D4, // ARABIC FULL STOP
	0x3002, // IDEOGRAPHIC FULL STOP
	0xFE52, // SMALL FULL STOP
	0xFF0E, // FULLWIDTH FULL STOP
	0xFF61, // HALFWIDTH IDEOGRAPHIC FULL STOP
	0
};

// Inseparable character
#define	brkclsInseparable	7

const WCHAR set7[] = {
	0		// FUTURE (alexgo): maybe handle these.
};

// Pre-numeral abbreviation
#define	brkclsPrefix	8

const WCHAR set8[] = {
	0x0024, // DOLLAR SIGN
	0x00A3, // POUND SIGN
	0x00A4, // CURRENCY SIGN
	0x00A5, // YEN SIGN
	0x005C, // REVERSE SOLIDUS (looks like Yen in FE fonts.)
	0x0E3F, // THAI CURRENCY SYMBOL BAHT
	0x20AC, // EURO-CURRENCY SIGN
	0x20A1, // COLON SIGN
	0x20A2, // CRUZEIRO SIGN
	0x20A3, // FRENCH FRANC SIGN
	0x20A4, // LIRA SIGN
	0x20A5, // MILL SIGN
	0x20A6, // NAIRA SIGN
	0x20A7, // PESETA SIGN
	0x20A8, // RUPEE SIGN
	0x20A9, // WON SIGN
	0x20AA, // NEW SHEQEL SIGN

	0xFF04, // FULLWIDTH DOLLAR SIGN
	0xFFE5,	// FULLWIDTH YEN SIGN
	0xFFE6,	// FULLWIDTH WON SIGN

	0xFFE1,	// FULLWIDTH POUND SIGN
	0
};

// Post-numeral abbreviation
#define	brkclsPostfix	9

const WCHAR set9[] = {
	0x00A2, // CENT SIGN
	0x00B0, // DEGREE SIGN
	0x2103, // DEGREE CELSIUS
	0x2109, // DEGREE FAHRENHEIT
	0x212A, // KELVIN SIGN
	0x0025, // PERCENT SIGN
	0x066A, // ARABIC PERCENT SIGN
	0xFE6A, // SMALL PERCENT SIGN
	0xFF05, // FULLWIDTH PERCENT SIGN
	0x2030, // PER MILLE SIGN
	0x2031, // PER TEN THOUSAND SIGN
	0x2032, // PRIME
	0x2033, // DOUBLE PRIME
	0x2034, // TRIPLE PRIME
	0x2035, // REVERSED PRIME
	0x2036, // REVERSED DOUBLE PRIME
	0x2037,	// REVERSED TRIPLE PRIME

	0xFF05,	// FULLWIDTH PERCENT SIGN
	0xFFE0,	// FULLWIDTH CENT SIGN
	0
};

// Japanese space (blank) character
#define	brkclsNoStartIdeo	10

const WCHAR set10[] = {
	0x3000,  // IDEOGRAPHIC SPACE
	0
};

// Japanese characters other than above
#define	brkclsIdeographic	11

const WCHAR set11[] = {
	0		//we use GetStringTypeEx
};

// Characters included in numeral-sequence
#define	brkclsNumeral	12

const WCHAR set12[] = {
	0x0030, // DIGIT ZERO
	0x0031, // DIGIT ONE
	0x0032, // DIGIT TWO
	0x0033, // DIGIT THREE
	0x0034, // DIGIT FOUR
	0x0035, // DIGIT FIVE
	0x0036, // DIGIT SIX
	0x0037, // DIGIT SEVEN
	0x0038, // DIGIT EIGHT
	0x0039, // DIGIT NINE
	0x0660, // ARABIC-INDIC DIGIT ZERO
	0x0661, // ARABIC-INDIC DIGIT ONE
	0x0662, // ARABIC-INDIC DIGIT TWO
	0x0663, // ARABIC-INDIC DIGIT THREE
	0x0664, // ARABIC-INDIC DIGIT FOUR
	0x0665, // ARABIC-INDIC DIGIT FIVE
	0x0666, // ARABIC-INDIC DIGIT SIX
	0x0667, // ARABIC-INDIC DIGIT SEVEN
	0x0668, // ARABIC-INDIC DIGIT EIGHT
	0x0669, // ARABIC-INDIC DIGIT NINE
	0x06F0, // EXTENDED ARABIC-INDIC DIGIT ZERO
	0x06F1, // EXTENDED ARABIC-INDIC DIGIT ONE
	0x06F2, // EXTENDED ARABIC-INDIC DIGIT TWO
	0x06F3, // EXTENDED ARABIC-INDIC DIGIT THREE
	0x06F4, // EXTENDED ARABIC-INDIC DIGIT FOUR
	0x06F5, // EXTENDED ARABIC-INDIC DIGIT FIVE
	0x06F6, // EXTENDED ARABIC-INDIC DIGIT SIX
	0x06F7, // EXTENDED ARABIC-INDIC DIGIT SEVEN
	0x06F8, // EXTENDED ARABIC-INDIC DIGIT EIGHT
	0x06F9, // EXTENDED ARABIC-INDIC DIGIT NINE
	0x0966, // DEVANAGARI DIGIT ZERO
	0x0967, // DEVANAGARI DIGIT ONE
	0x0968, // DEVANAGARI DIGIT TWO
	0x0969, // DEVANAGARI DIGIT THREE
	0x096A, // DEVANAGARI DIGIT FOUR
	0x096B, // DEVANAGARI DIGIT FIVE
	0x096C, // DEVANAGARI DIGIT SIX
	0x096D, // DEVANAGARI DIGIT SEVEN
	0x096E, // DEVANAGARI DIGIT EIGHT
	0x096F, // DEVANAGARI DIGIT NINE
	0x09E6, // BENGALI DIGIT ZERO
	0x09E7, // BENGALI DIGIT ONE
	0x09E8, // BENGALI DIGIT TWO
	0x09E9, // BENGALI DIGIT THREE
	0x09EA, // BENGALI DIGIT FOUR
	0x09EB, // BENGALI DIGIT FIVE
	0x09EC, // BENGALI DIGIT SIX
	0x09ED, // BENGALI DIGIT SEVEN
	0x09EE, // BENGALI DIGIT EIGHT
	0x09EF, // BENGALI DIGIT NINE
	0x0A66, // GURMUKHI DIGIT ZERO
	0x0A67, // GURMUKHI DIGIT ONE
	0x0A68, // GURMUKHI DIGIT TWO
	0x0A69, // GURMUKHI DIGIT THREE
	0x0A6A, // GURMUKHI DIGIT FOUR
	0x0A6B, // GURMUKHI DIGIT FIVE
	0x0A6C, // GURMUKHI DIGIT SIX
	0x0A6D, // GURMUKHI DIGIT SEVEN
	0x0A6E, // GURMUKHI DIGIT EIGHT
	0x0A6F, // GURMUKHI DIGIT NINE
	0x0AE6, // GUJARATI DIGIT ZERO
	0x0AE7, // GUJARATI DIGIT ONE
	0x0AE8, // GUJARATI DIGIT TWO
	0x0AE9, // GUJARATI DIGIT THREE
	0x0AEA, // GUJARATI DIGIT FOUR
	0x0AEB, // GUJARATI DIGIT FIVE
	0x0AEC, // GUJARATI DIGIT SIX
	0x0AED, // GUJARATI DIGIT SEVEN
	0x0AEE, // GUJARATI DIGIT EIGHT
	0x0AEF, // GUJARATI DIGIT NINE
	0x0B66, // ORIYA DIGIT ZERO
	0x0B67, // ORIYA DIGIT ONE
	0x0B68, // ORIYA DIGIT TWO
	0x0B69, // ORIYA DIGIT THREE
	0x0B6A, // ORIYA DIGIT FOUR
	0x0B6B, // ORIYA DIGIT FIVE
	0x0B6C, // ORIYA DIGIT SIX
	0x0B6D, // ORIYA DIGIT SEVEN
	0x0B6E, // ORIYA DIGIT EIGHT
	0x0B6F, // ORIYA DIGIT NINE
	0x0BE7, // TAMIL DIGIT ONE
	0x0BE8, // TAMIL DIGIT TWO
	0x0BE9, // TAMIL DIGIT THREE
	0x0BEA, // TAMIL DIGIT FOUR
	0x0BEB, // TAMIL DIGIT FIVE
	0x0BEC, // TAMIL DIGIT SIX
	0x0BED, // TAMIL DIGIT SEVEN
	0x0BEE, // TAMIL DIGIT EIGHT
	0x0BEF, // TAMIL DIGIT NINE
	0x0BF0, // TAMIL NUMBER TEN
	0x0BF1, // TAMIL NUMBER ONE HUNDRED
	0x0BF2, // TAMIL NUMBER ONE THOUSAND
	0x0C66, // TELUGU DIGIT ZERO
	0x0C67, // TELUGU DIGIT ONE
	0x0C68, // TELUGU DIGIT TWO
	0x0C69, // TELUGU DIGIT THREE
	0x0C6A, // TELUGU DIGIT FOUR
	0x0C6B, // TELUGU DIGIT FIVE
	0x0C6C, // TELUGU DIGIT SIX
	0x0C6D, // TELUGU DIGIT SEVEN
	0x0C6E, // TELUGU DIGIT EIGHT
	0x0C6F, // TELUGU DIGIT NINE
	0x0CE6, // KANNADA DIGIT ZERO
	0x0CE7, // KANNADA DIGIT ONE
	0x0CE8, // KANNADA DIGIT TWO
	0x0CE9, // KANNADA DIGIT THREE
	0x0CEA, // KANNADA DIGIT FOUR
	0x0CEB, // KANNADA DIGIT FIVE
	0x0CEC, // KANNADA DIGIT SIX
	0x0CED, // KANNADA DIGIT SEVEN
	0x0CEE, // KANNADA DIGIT EIGHT
	0x0CEF, // KANNADA DIGIT NINE
	0x0D66, // MALAYALAM DIGIT ZERO
	0x0D67, // MALAYALAM DIGIT ONE
	0x0D68, // MALAYALAM DIGIT TWO
	0x0D69, // MALAYALAM DIGIT THREE
	0x0D6A, // MALAYALAM DIGIT FOUR
	0x0D6B, // MALAYALAM DIGIT FIVE
	0x0D6C, // MALAYALAM DIGIT SIX
	0x0D6D, // MALAYALAM DIGIT SEVEN
	0x0D6E, // MALAYALAM DIGIT EIGHT
	0x0D6F, // MALAYALAM DIGIT NINE
	0x0E50, // THAI DIGIT ZERO
	0x0E51, // THAI DIGIT ONE
	0x0E52, // THAI DIGIT TWO
	0x0E53, // THAI DIGIT THREE
	0x0E54, // THAI DIGIT FOUR
	0x0E55, // THAI DIGIT FIVE
	0x0E56, // THAI DIGIT SIX
	0x0E57, // THAI DIGIT SEVEN
	0x0E58, // THAI DIGIT EIGHT
	0x0E59, // THAI DIGIT NINE
	0x0ED0, // LAO DIGIT ZERO
	0x0ED1, // LAO DIGIT ONE
	0x0ED2, // LAO DIGIT TWO
	0x0ED3, // LAO DIGIT THREE
	0x0ED4, // LAO DIGIT FOUR
	0x0ED5, // LAO DIGIT FIVE
	0x0ED6, // LAO DIGIT SIX
	0x0ED7, // LAO DIGIT SEVEN
	0x0ED8, // LAO DIGIT EIGHT
	0x0ED9, // LAO DIGIT NINE
	0xFF10, // FULLWIDTH DIGIT ZERO
	0xFF11, // FULLWIDTH DIGIT ONE
	0xFF12, // FULLWIDTH DIGIT TWO
	0xFF13, // FULLWIDTH DIGIT THREE
	0xFF14, // FULLWIDTH DIGIT FOUR
	0xFF15, // FULLWIDTH DIGIT FIVE
	0xFF16, // FULLWIDTH DIGIT SIX
	0xFF17, // FULLWIDTH DIGIT SEVEN
	0xFF18, // FULLWIDTH DIGIT EIGHT
	0xFF19, // FULLWIDTH DIGIT NINE

	0x3007, // IDEOGRAPHIC NUMBER ZERO
	0x3021, // HANGZHOU NUMERAL ONE
	0x3022, // HANGZHOU NUMERAL TWO
	0x3023, // HANGZHOU NUMERAL THREE
	0x3024, // HANGZHOU NUMERAL FOUR
	0x3025, // HANGZHOU NUMERAL FIVE
	0x3026, // HANGZHOU NUMERAL SIX
	0x3027, // HANGZHOU NUMERAL SEVEN
	0x3028, // HANGZHOU NUMERAL EIGHT
	0x3029, // HANGZHOU NUMERAL NINE
	0
};

// Characters included in unit symbol group
const WCHAR set13[] = {
	0		//we use GetStringTypeEx
};

//Roman inter-word space
#define	brkclsSpaceN	14

const WCHAR set14[] = {
	0x0009,	// TAB
	0x0020, // SPACE
	0x2002, // EN SPACE
	0x2003, // EM SPACE
	0x2004, // THREE-PER-EM SPACE
	0x2005, // FOUR-PER-EM SPACE
	0x2006, // SIX-PER-EM SPACE
	0x2007, // FIGURE SPACE
	0x2008, // PUNCTUATION SPACE
	0x2009, // THIN SPACE
	0x200A, // HAIR SPACE
	0x200B,  // ZERO WIDTH SPACE
	WCH_EMBEDDING, // OBJECT EMBEDDING (0xFFFC)
	0
};

// Roman characters
#define	brkclsAlpha	15

const WCHAR set15[] = {
	0		//we use GetStringTypeEx
};

// So we can easily loop over all Kinsoku categories.
const WCHAR *charCategories[] = {
	set0,
	set1,
	set2,
	set3,
	set4,
	set5,
	set6,
	set7,
	set8,
	set9,
	set10,
	set11,
	set12,
	set13,
	set14,
	set15
};

static const INT classifyChunkSize = 64;
static const INT indexSize = 65536 / classifyChunkSize;
static const INT classifyBitMapSize = indexSize / 8;
static const INT bitmapShift = 6; // 16 - log(indexSize)/log(2)

typedef struct {
	CHAR classifications[classifyChunkSize];		// must be unsigned bytes!
} ClassifyChunk;

static ClassifyChunk *classifyData;					// Chunk array, sparse chrs
static BYTE *classifyIndex;							// Indexes into chunk array


/*
 *	BOOL InitKinsokuClassify()
 *
 *	@func
 *		Map the static character tables into a compact array for
 *		quick lookup of the characters Kinsoku classification.
 *
 *	@comm
 *		Kinsoku classification is necessary for word breaking and
 *		may be neccessary for proportional line layout, Kinsoku style.
 *
 *	@devnote
 *		We break the entire Unicode range in to chunks of characters.
 *		Not all of the chunks will have data in them. We do not
 *		maintain information on empty chunks, therefore we create
 *		a compact, contiguous array of chunks for only the chunks
 *		that do contain information. We prepend 1 empty chunk to the
 *		beginning of this array, where all of the empty chunks map to,
 *		this prevents a contiontional test on NULL data. The lookup
 *		will return 0 for any character not in the tables, so the client
 *		will then need to process the character further in such cases.
 *
 *	@rdesc
 *		return TRUE if we successfully created the lookup table.
 */
BOOL InitKinsokuClassify()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "InitKinsokuClassify");

	WORD	bitMapKey;								// For calcing total chunks
	BYTE	bitData;								// For calcing total chunks
	WCHAR	ch;
	LPCWSTR pWChar;								// Looping over char sets.
	INT		i, j, count;							// Loop support.
	BYTE	classifyBitMap[classifyBitMapSize],		// Temp bitmap.
			*pIndex;								// Index into chunk array.

	// See how many chunks we'll need. We loop over all of the special
	//  characters
	AssertSz(cKinsokuCategories == ARRAY_SIZE(charCategories),
		"InitKinsokuClassify: incorrect Kinsoku-category count");

	ZeroMemory(classifyBitMap, sizeof(classifyBitMap));
	for (i = 0; i < cKinsokuCategories; i++ )
	{
		pWChar = charCategories[i];
		while ( ch = *pWChar++ )
		{
			bitMapKey = ch >> bitmapShift;
			classifyBitMap[bitMapKey >> 3] |= 1 << (bitMapKey & 7);
		}
	}

	// Now that we know how many chunks we'll need, allocate the memory.
	count = 1 + CountMatchingBits((DWORD *)classifyBitMap, (DWORD *)classifyBitMap, sizeof(classifyBitMap)/sizeof(DWORD));
	classifyData = (ClassifyChunk *) PvAlloc( sizeof(ClassifyChunk) * count, GMEM_ZEROINIT);
	classifyIndex = (BYTE *) PvAlloc( sizeof(BYTE) * indexSize, GMEM_ZEROINIT);

	// We failed if we did not get the memory.
	if ( !classifyData || !classifyIndex )
		return FALSE;								// FAILED.

	// Set Default missing value.
	FillMemory( classifyData, -1, sizeof(ClassifyChunk) * count );

	// Init the pointers to the chunks, which are really just indexes into
	//  a contiguous block of memory -- an one-based array of chunks.
	pIndex = classifyIndex;
	count = 1;										// 1 based array.
	for (i = 0; i < sizeof(classifyBitMap); i++ )	// Loop over all bytes.
	{												// Get the bitmap data.
		bitData = classifyBitMap[i];				// For each bit in the byte
		for (j = 0; j < 8; j++, bitData >>= 1, pIndex++)
		{
			if(bitData & 1)			
				*pIndex = count++;					// We used a chunk.
		}
	}
	
	// Store the classifications of each character.
	// Note: classifications are 1 based, a zero value
	//  means the category was not set.
	for (i = 0; i < cKinsokuCategories; i++ )
	{
		pWChar = charCategories[i];					// Loop over all chars in
		while ( ch = *pWChar++ )					//  category.
		{
			bitMapKey = ch >> bitmapShift;
			Assert( classifyIndex[bitMapKey] > 0 );
			Assert( classifyIndex[bitMapKey] < count );

			classifyData[classifyIndex[bitMapKey]].
				classifications[ ch & ( classifyChunkSize-1 )] = (char)i;
		}
	}
	return TRUE;									// Successfully created.
}

void UninitKinsokuClassify()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "UninitKinsokuClassify");

	FreePv(classifyData);
	FreePv(classifyIndex);
}

/*
 *	KinsokuClassify(ch)
 *
 *	@func
 *		Kinsoku classify the character iff it was a given from
 *		one of the classification tables.
 *
 *	@comm
 *		Hi order bits of ch are used to get an index value used to index
 *		into an array of chunks. Each chunk contains the classifications
 *		for that character as well as some number of characters adjacent
 *		to that character. The low order bits are used to index into
 *		the chunk of adjacent characters.
 *
 *	@devnote
 *		Because of the way we constructed the array, all that we need to
 *		do is look up the data; no conditionals necessary.
 *
 *		The routine is inline to avoid the call overhead. It is static
 *		because it only returns characters from the tables; i.e., this
 *		routine does NOT classify all Unicode characters.
 *
 *	@rdesc
 *		Returns the classification.
 */
static inline INT
KinsokuClassify(
	WCHAR ch )	// @parm char to classify.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "KinsokuClassify");

	return classifyData[ classifyIndex[ ch >> bitmapShift ] ].
			classifications[ ch & ( classifyChunkSize-1 )];
}


#define IsSameNonFEClass(_c1, _c2)	(!(((_c1) ^ (_c2)) & WBF_CLASS))
#define IdeoKanaTypes (C3_HALFWIDTH | C3_FULLWIDTH | C3_KATAKANA | C3_HIRAGANA)
#define IdeoTypes	  (IdeoKanaTypes | C3_IDEOGRAPH)
#define IsIdeographic(_c1) ( 0 != (_c1 & (C3_KATAKANA | C3_HIRAGANA | C3_IDEOGRAPH)) )

/*
 *	IsSameClass(currType1, startType1, currType3, startType3 )
 *
 *	@func	Used to determine word breaks.
 *
 *	@comm	Ideographic chars are all considered to be unique, so that only
 *			one at a time is selected
 */
BOOL IsSameClass(WORD currType1, WORD startType1,
				 WORD currType3, WORD startType3 )
{
	BOOL	fIdeographic = IsIdeographic(currType3);

	// Do classifications for startType3 being ideographic
	if(IsIdeographic(startType3))
	{
		int checkTypes = (currType3 & IdeoTypes) ^ (startType3 & IdeoTypes);

		// We only get picky with non-ideographic Kana chars
		//  C3_HALFWIDTH | C3_FULLWIDTH | C3_KATAKANA | C3_HIRAGANA.
		return fIdeographic && (startType3 & IdeoKanaTypes) &&
			   (!checkTypes || checkTypes == C3_FULLWIDTH || checkTypes == C3_HIRAGANA ||
			   checkTypes == (C3_FULLWIDTH | C3_HIRAGANA));
	}	

	// Do classifications for nonideographic startType3
	return !fIdeographic && IsSameNonFEClass(currType1, startType1);
}

WORD ClassifyChar(TCHAR ch)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "ClassifyChar");
	WORD wRes;

	if (IsKorean(ch))									// special Korean class
		return WBF_KOREAN;

	if (IsThai(ch))
		return 0;

	if (ch == WCH_EMBEDDING)							// Objects
		return 2 | WBF_BREAKAFTER;

	W32->GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE1, &ch, 1, &wRes);

	if(wRes & C1_SPACE)
	{
		if(wRes & C1_BLANK)								// Only TAB, BLANK, and
		{												//  nobreak BLANK are here
			if(ch == 0x20)
				return 2 | WBF_BREAKLINE | WBF_ISWHITE;
			if(ch == TAB)
				return 3 | WBF_ISWHITE;
			return 2 | WBF_ISWHITE;
		}
		if(ch == CELL)
			return 3 | WBF_ISWHITE;
		return 4 | WBF_ISWHITE;
	}
	if(wRes & C1_PUNCT && !IsDiacriticOrKashida(ch, 0))
		return ch == '-' ? (1 | WBF_BREAKAFTER) : 1;
	return 0;
}

/*
 *	BatchClassify (pch, cch, pcType3, kinsokuClassifications, pwRes)
 *
 *	@func
 *		Kinsoku classify and ClassifyChar() each character of the given string.
 *
 *	@comm
 *		The Kinsoku classifications are passed to the CanBreak() routine. We
 *		do process in batch to save on overhead.
 *
 *		If the character is not in the Kinsoku classification tables then
 *		GetStringTypeEx is used to classify any remaining character.
 *
 *	@rdesc
 *		Result in out param kinsokuClassifications.
 *		pcType3 result from GetStringTypeEx for CT_CTYPE3
 */
void BatchClassify (
	const WCHAR *pch,	// @parm char string
	INT	  cch,			// @parm Count of chars in string
	WORD *pcType3,		// @parm Result of GetStringTypeEx for CT_CTYPE3
	INT * kinsokuClassifications,	// @parm Result of the classifications
	WORD *pwRes)		// @parm ClassifyChar() result
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "BatchClassify");

	WCHAR	ch;
	WORD	cType3;
	INT		iCategory;
	WORD	wRes;

	Assert( cch < MAX_CLASSIFY_CHARS );
	Assert( pch );
	Assert( kinsokuClassifications );

	// *Note* Using CT_CTYPE1 values alone is unreliable since CT_CTYPE1
	// defines C1_PUNCT for all diacritic characters. According to KDChang,
	// this is by design for POSIX compatibility and it couldn't be changed
	// easily since Win9x shares the same NLS data with NT. (wchao)
	// Therefore we use CT_CTYPE3 data to distinguish diacritics, except on
	// Win9x, for which we use a range check, since GetStringTypeExW isn't
	// supported).

	W32->GetStringTypes(0, pch, cch, pwRes, pcType3);

	while ( cch-- )									// For all ch...
	{
		wRes = *pwRes;
		ch = *pch++;
		
		if(IsKorean(ch))								
			wRes = WBF_KOREAN;						// Special Korean class
		else if (IsThai(ch))
			wRes = 0;								// Thai class
		else if (ch == WCH_EMBEDDING)				// Objects
			wRes = 2 | WBF_BREAKAFTER;
		else if(wRes & C1_SPACE)
		{
			if (wRes & C1_BLANK)
			{
				wRes = 2 | WBF_ISWHITE;
				if(ch == 0x20)
					wRes = 2 | WBF_BREAKLINE | WBF_ISWHITE;
				if(ch == TAB)
					wRes = 3 | WBF_ISWHITE;
			}
			else
				wRes = 4 | WBF_ISWHITE;
		}
		else if(ch == CELL)
			wRes = 3 | WBF_ISWHITE;
		else if((wRes & C1_PUNCT) && !IsDiacriticOrKashida(ch, *pcType3))
			wRes = ch == '-' ? (1 | WBF_BREAKAFTER) : 1;
		else
			wRes = 0;

		*pwRes++ = wRes;

		if(IsKorean(ch))
			iCategory = 11;									
		else
		{
			iCategory = KinsokuClassify(ch);
			if(iCategory < 0)						// If not classified
			{										//  then it is one of:
				cType3 = *pcType3;
				if(cType3 & C3_SYMBOL)
					iCategory = 13;					//  symbol chars,
				else if(cType3 & C3_FullWidth)
					iCategory = 11;					//  ideographic chars,
				else
					iCategory = 15;					//  all other chars.
			}
		}
		*kinsokuClassifications++ = iCategory;
		pcType3++;
	}
}

/*
 *	GetKinsokuClass (ch)
 *
 *	@func
 *		Kinsoku classify ch
 *
 *	@comm
 *		The Kinsoku classifications are passed to the CanBreak() routine. This
 *		single-character routine is for use with LineServices
 *
 *		If the character is not in the Kinsoku classification tables then
 *		GetStringTypeEx is used to classify any remaining character.
 *
 *	@rdesc
 *		Kinsoku classification for ch
 */
INT GetKinsokuClass (
	WCHAR ch)	// @parm char
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "GetKinsokuClassification");

	if(IsKorean(ch))
		return 11;

	// surrogate classification
	if (IN_RANGE(0xD800, ch, 0xDFFF))
		return IN_RANGE(0xDC00, ch, 0xDFFF) ? brkclsClose : brkclsOpen;


	INT iCategory = KinsokuClassify(ch);
	if(iCategory >= 0)
		return iCategory;

	WORD cType3;
	W32->GetStringTypeEx(0, CT_CTYPE3, &ch, 1, &cType3);

	if(cType3 & C3_SYMBOL)
		return 13;							// Symbol chars

	if(cType3 & C3_FullWidth)
		return 11;							// Ideographic chars

	return 15;								// All other chars.
}

/*
 *	CanBreak(class1, class2)
 *
 *	@func
 *		Look into the truth table to see if two consecutive charcters
 *		can have a line break between them.
 *
 *	@comm
 *		This determines whether two successive characters can break a line.
 *		The matrix is taken from JIS X4051 and is based on categorizing
 *		characters into 15 classifications.
 *
 *	@devnote
 *		The table is 1 based.
 *
 *	@rdesc
 *		Returns TRUE if the characters can be broken across a line.
 */
BOOL CanBreak(
	INT class1,		//@parm	Kinsoku classification of character #1
	INT class2 )	//@parm	Kinsoku classification of following character.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CanBreak");

	static const WORD br[16] = {//   fedc ba98 7654 3210
		0x0000,					// 0 0000 0000 0000 0000
		0x0000,					// 1 0000 0000 0000 0000
		0xfd82,					// 2 1111 1101 1000 0010
		0xfd82,					// 3 1111 1101 1000 0010
		0xfd82,					// 4 1111 1101 1000 0010
		0xfd82,					// 5 1111 1101 1000 0010
		0x6d82,					// 6 0110 1101 1000 0010
		0xfd02,					// 7 1111 1101 0000 0010
		0x0000,					// 8 0000 0000 0000 0000
		0xfd82,					// 9 1111 1101 1000 0010
		0xfd83,					// a 1111 1101 1000 0011
		0xfd82,					// b 1111 1101 1000 0010
		0x6d82,					// c 0110 1101 1000 0010
		0x5d82,					// d 0101 1101 1000 0010
		0xfd83,					// e 1111 1101 1000 0011
		0x4d82,					// f 0100 1101 1000 0010
	};
	return (br[class1] >> class2) & 1;
}

/*
 *	IsURLDelimiter(ch)
 *
 *	@func
 *		Punctuation characters are those of sets 0, 1, 2, 4, 5, and 6,
 *		and < or > which we consider to be brackets, not "less" or
 *      "greater" signs. On the other hand; "/" (in set 6) should not be
 *		a delimiter, but rather a part of the URL.
 *
 *	@comm This function is used in URL detection
 *
 *	@rdesc
 *		Returns TRUE if the character is a punctuation mark.
 */
BOOL IsURLDelimiter(
	WCHAR ch)
{
	if (IsKorean(ch))
		return TRUE;

	INT iset = KinsokuClassify(ch);

	return IN_RANGE(0, iset, 2) || (IN_RANGE(4, iset, 6) && ch != '/')
		   || ch == '<' || ch == '>';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\debug.cpp ===
/*
 *	DEBUG.CPP
 *	
 *	Purpose:
 *		RICHEDIT debugging support--commented out in ship builds
 *
 *	History: <nl>
 *		7/29/98	KeithCu Wrote it stealing much from Rich Arneson's code
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"

//Module is empty if this is a retail build.
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)

DWORD dwDebugOptions = 0;         //Debug option flags
PFNASSERTHOOK pfnAssert = NULL;   //Assert hook function
PFNTRACEHOOK pfnTrace = NULL;     //Trace hook function

// Static variables
static HINSTANCE ghMod;                        //Dll module handle
static DWORD TlsIndex;                      //Debug output indent level
static HANDLE hLogFile = NULL;              //Log file handle
static BOOL fIgnoreAsserts = FALSE;         //Ignore all asserts if true
static CRITICAL_SECTION csLog;              //Critical section for log file i/o
static CRITICAL_SECTION csAssert;           //Critical section for asserts
static HANDLE hEventAssert1 = NULL;         //Event for assert syncing
static HANDLE hEventAssert2 = NULL;         //Event for assert syncing
static HWND hwndAssert = NULL;           	//Assert dialog window handle
static HANDLE hAssertThrd = NULL;           //Assert thread handle
static char szAssert[MAXDEBUGSTRLEN];       //Assert message buffer
static int idAssert = -1;                   //Assert button pressed by user
DWORD WINAPI AssertThread(LPVOID lParam);	//Assert thread entry point
static BOOL fDllDetach = FALSE;				//True if we are in dll detach

//Strings for subsystem element of message
static char* TrcSubsys [] =
{
    "",
    "Display",
    "Wrapper",
    "Edit",
    "TextServices",
    "TOM",
    "OLE Object Support",
    "Store",
    "Selection",
    "WinHost",
    "DataXfer",
    "MultiUndo",
    "Range",
    "Util",
    "Notification Mgr.",
    "RTF Reader",
    "RTF Writer",
    "Printing",
    "Far East",
	"Font"
};

//Strings for severity element of message
static char* TrcSeverity [] =
{
    "",
    "WARNING",
    "ERROR",
    "ASSERT",
    "INFO",
	"MEMORY"
};

//Strings for scope element of message
static char* TrcScope [] =
{
    "",
    "External",
    "Internal"
};

//Structure for lookup tables
typedef struct
{
    DWORD dwKey;
    char * sz;
} TabElem;

//Lookup table for CTrace param strings
static TabElem TrcParamTab [] = 
{
//Richedit Messages
    {(DWORD)EM_GETLIMITTEXT, "EM_GETLIMITTEXT"},
    {(DWORD)EM_POSFROMCHAR, "EM_POSFROMCHAR"},
    {(DWORD)EM_CHARFROMPOS, "EM_CHARFROMPOS"},
    {(DWORD)EM_SCROLLCARET, "EM_SCROLLCARET"},
    {(DWORD)EM_CANPASTE, "EM_CANPASTE"},
    {(DWORD)EM_DISPLAYBAND, "EM_DISPLAYBAND"},
    {(DWORD)EM_EXGETSEL, "EM_EXGETSEL"},
    {(DWORD)EM_EXLIMITTEXT, "EM_EXLIMITTEXT"},
    {(DWORD)EM_EXLINEFROMCHAR, "EM_EXLINEFROMCHAR"},
    {(DWORD)EM_EXSETSEL, "EM_EXSETSEL"},
    {(DWORD)EM_FINDTEXT, "EM_FINDTEXT"},
    {(DWORD)EM_FORMATRANGE, "EM_FORMATRANGE"},
    {(DWORD)EM_GETCHARFORMAT, "EM_GETCHARFORMAT"},
    {(DWORD)EM_GETEVENTMASK, "EM_GETEVENTMASK"},
    {(DWORD)EM_GETOLEINTERFACE, "EM_GETOLEINTERFACE"},
    {(DWORD)EM_GETPARAFORMAT, "EM_GETPARAFORMAT"},
    {(DWORD)EM_GETSELTEXT, "EM_GETSELTEXT"},
    {(DWORD)EM_HIDESELECTION, "EM_HIDESELECTION"},
    {(DWORD)EM_PASTESPECIAL, "EM_PASTESPECIAL"},
    {(DWORD)EM_REQUESTRESIZE, "EM_REQUESTRESIZE"},
    {(DWORD)EM_SELECTIONTYPE, "EM_SELECTIONTYPE"},
    {(DWORD)EM_SETBKGNDCOLOR, "EM_SETBKGNDCOLOR"},
    {(DWORD)EM_SETCHARFORMAT, "EM_SETCHARFORMAT"},
    {(DWORD)EM_SETEVENTMASK, "EM_SETEVENTMASK"},
    {(DWORD)EM_SETOLECALLBACK, "EM_SETOLECALLBACK"},
    {(DWORD)EM_SETPARAFORMAT, "EM_SETPARAFORMAT"},
    {(DWORD)EM_SETTARGETDEVICE, "EM_SETTARGETDEVICE"},
    {(DWORD)EM_STREAMIN, "EM_STREAMIN"},
    {(DWORD)EM_STREAMOUT, "EM_STREAMOUT"},
    {(DWORD)EM_GETTEXTRANGE, "EM_GETTEXTRANGE"},
    {(DWORD)EM_FINDWORDBREAK, "EM_FINDWORDBREAK"},
    {(DWORD)EM_SETOPTIONS, "EM_SETOPTIONS"},
    {(DWORD)EM_GETOPTIONS, "EM_GETOPTIONS"},
    {(DWORD)EM_FINDTEXTEX, "EM_FINDTEXTEX"},
    {(DWORD)EM_GETWORDBREAKPROCEX, "EM_GETWORDBREAKPROCEX"},
    {(DWORD)EM_SETWORDBREAKPROCEX, "EM_SETWORDBREAKPROCEX"},
    {(DWORD)EM_SETUNDOLIMIT, "EM_SETUNDOLIMIT"},
    {(DWORD)EM_REDO, "EM_REDO"},
    {(DWORD)EM_CANREDO, "EM_CANREDO"},
    {(DWORD)EM_SETPUNCTUATION, "EM_SETPUNCTUATION"},
    {(DWORD)EM_GETPUNCTUATION, "EM_GETPUNCTUATION"},
    {(DWORD)EM_SETWORDWRAPMODE, "EM_SETWORDWRAPMODE"},
    {(DWORD)EM_GETWORDWRAPMODE, "EM_GETWORDWRAPMODE"},
    {(DWORD)EM_SETIMECOLOR, "EM_SETIMECOLOR"},
    {(DWORD)EM_GETIMECOLOR, "EM_GETIMECOLOR"},
    {(DWORD)EM_SETIMEOPTIONS, "EM_SETIMEOPTIONS"},
    {(DWORD)EM_GETIMEOPTIONS, "EM_GETIMEOPTIONS"},
    {(DWORD)EN_MSGFILTER, "EN_MSGFILTER"},
    {(DWORD)EN_REQUESTRESIZE, "EN_REQUESTRESIZE"},
    {(DWORD)EN_SELCHANGE, "EN_SELCHANGE"},
    {(DWORD)EN_DROPFILES, "EN_DROPFILES"},
    {(DWORD)EN_PROTECTED, "EN_PROTECTED"},
    {(DWORD)EN_CORRECTTEXT, "EN_CORRECTTEXT"},
    {(DWORD)EN_STOPNOUNDO, "EN_STOPNOUNDO"},
    {(DWORD)EN_IMECHANGE, "EN_IMECHANGE"},
    {(DWORD)EN_SAVECLIPBOARD, "EN_SAVECLIPBOARD"},
    {(DWORD)EN_OLEOPFAILED, "EN_OLEOPFAILED"},

//Window Messages

	{(DWORD)WM_NULL, "WM_NULL"},
	{(DWORD)WM_CREATE, "WM_CREATE"},
	{(DWORD)WM_DESTROY, "WM_DESTROY"},
	{(DWORD)WM_MOVE, "WM_MOVE"},
	{(DWORD)WM_SIZE, "WM_SIZE"},
	{(DWORD)WM_ACTIVATE, "WM_ACTIVATE"},
	{(DWORD)WM_SETFOCUS, "WM_SETFOCUS"},
	{(DWORD)WM_KILLFOCUS, "WM_KILLFOCUS"},
	{(DWORD)WM_ENABLE, "WM_ENABLE"},
	{(DWORD)WM_SETREDRAW, "WM_SETREDRAW"},
	{(DWORD)WM_SETTEXT, "WM_SETTEXT"},
	{(DWORD)WM_GETTEXT, "WM_GETTEXT"},
	{(DWORD)WM_GETTEXTLENGTH, "WM_GETTEXTLENGTH"},
	{(DWORD)WM_PAINT, "WM_PAINT"},
	{(DWORD)WM_CLOSE, "WM_CLOSE"},
	{(DWORD)WM_QUERYENDSESSION, "WM_QUERYENDSESSION"},
	{(DWORD)WM_QUIT, "WM_QUIT"},
	{(DWORD)WM_QUERYOPEN, "WM_QUERYOPEN"},
	{(DWORD)WM_ERASEBKGND, "WM_ERASEBKGND"},
	{(DWORD)WM_SYSCOLORCHANGE, "WM_SYSCOLORCHANGE"},
	{(DWORD)WM_ENDSESSION, "WM_ENDSESSION"},
	{(DWORD)WM_SHOWWINDOW, "WM_SHOWWINDOW"},
	{(DWORD)WM_WININICHANGE, "WM_WININICHANGE"},
	{(DWORD)WM_SETTINGCHANGE, "WM_SETTINGCHANGE"},
	{(DWORD)WM_DEVMODECHANGE, "WM_DEVMODECHANGE"},
	{(DWORD)WM_ACTIVATEAPP, "WM_ACTIVATEAPP"},
	{(DWORD)WM_FONTCHANGE, "WM_FONTCHANGE"},
	{(DWORD)WM_TIMECHANGE, "WM_TIMECHANGE"},
	{(DWORD)WM_CANCELMODE, "WM_CANCELMODE"},
	{(DWORD)WM_SETCURSOR, "WM_SETCURSOR"},
	{(DWORD)WM_MOUSEACTIVATE, "WM_MOUSEACTIVATE"},
	{(DWORD)WM_CHILDACTIVATE, "WM_CHILDACTIVATE"},
	{(DWORD)WM_QUEUESYNC, "WM_QUEUESYNC"},
	{(DWORD)WM_GETMINMAXINFO, "WM_GETMINMAXINFO"},
	{(DWORD)WM_PAINTICON, "WM_PAINTICON"},
	{(DWORD)WM_ICONERASEBKGND, "WM_ICONERASEBKGND"},
	{(DWORD)WM_NEXTDLGCTL, "WM_NEXTDLGCTL"},
	{(DWORD)WM_SPOOLERSTATUS, "WM_SPOOLERSTATUS"},
	{(DWORD)WM_DRAWITEM, "WM_DRAWITEM"},
	{(DWORD)WM_MEASUREITEM, "WM_MEASUREITEM"},
	{(DWORD)WM_DELETEITEM, "WM_DELETEITEM"},
	{(DWORD)WM_VKEYTOITEM, "WM_VKEYTOITEM"},
	{(DWORD)WM_CHARTOITEM, "WM_CHARTOITEM"},
	{(DWORD)WM_SETFONT, "WM_SETFONT"},
	{(DWORD)WM_GETFONT, "WM_GETFONT"},
	{(DWORD)WM_SETHOTKEY, "WM_SETHOTKEY"},
	{(DWORD)WM_GETHOTKEY, "WM_GETHOTKEY"},
	{(DWORD)WM_QUERYDRAGICON, "WM_QUERYDRAGICON"},
	{(DWORD)WM_COMPAREITEM, "WM_COMPAREITEM"},
	{(DWORD)WM_COMPACTING, "WM_COMPACTING"},
	{(DWORD)WM_COMMNOTIFY, "WM_COMMNOTIFY"},
	{(DWORD)WM_WINDOWPOSCHANGING, "WM_WINDOWPOSCHANGING"},
	{(DWORD)WM_WINDOWPOSCHANGED, "WM_WINDOWPOSCHANGED"},
	{(DWORD)WM_POWER, "WM_POWER"},
	{(DWORD)WM_COPYDATA, "WM_COPYDATA"},
	{(DWORD)WM_CANCELJOURNAL, "WM_CANCELJOURNAL"},
	{(DWORD)WM_NOTIFY, "WM_NOTIFY"},
	{(DWORD)WM_INPUTLANGCHANGEREQUEST, "WM_INPUTLANGCHANGEREQUEST"},
	{(DWORD)WM_INPUTLANGCHANGE, "WM_INPUTLANGCHANGE"},
	{(DWORD)WM_TCARD, "WM_TCARD"},
	{(DWORD)WM_HELP, "WM_HELP"},
	{(DWORD)WM_USERCHANGED, "WM_USERCHANGED"},
	{(DWORD)WM_NOTIFYFORMAT, "WM_NOTIFYFORMAT"},
	{(DWORD)WM_CONTEXTMENU, "WM_CONTEXTMENU"},
	{(DWORD)WM_STYLECHANGING, "WM_STYLECHANGING"},
	{(DWORD)WM_STYLECHANGED, "WM_STYLECHANGED"},
	{(DWORD)WM_DISPLAYCHANGE, "WM_DISPLAYCHANGE"},
	{(DWORD)WM_GETICON, "WM_GETICON"},
	{(DWORD)WM_SETICON, "WM_SETICON"},
	{(DWORD)WM_NCCREATE, "WM_NCCREATE"},
	{(DWORD)WM_NCDESTROY, "WM_NCDESTROY"},
	{(DWORD)WM_NCCALCSIZE, "WM_NCCALCSIZE"},
	{(DWORD)WM_NCHITTEST, "WM_NCHITTEST"},
	{(DWORD)WM_NCPAINT, "WM_NCPAINT"},
	{(DWORD)WM_NCACTIVATE, "WM_NCACTIVATE"},
	{(DWORD)WM_GETDLGCODE, "WM_GETDLGCODE"},
	{(DWORD)WM_NCMOUSEMOVE, "WM_NCMOUSEMOVE"},
	{(DWORD)WM_NCLBUTTONDOWN, "WM_NCLBUTTONDOWN"},
	{(DWORD)WM_NCLBUTTONUP, "WM_NCLBUTTONUP"},
	{(DWORD)WM_NCLBUTTONDBLCLK, "WM_NCLBUTTONDBLCLK"},
	{(DWORD)WM_NCRBUTTONDOWN, "WM_NCRBUTTONDOWN"},
	{(DWORD)WM_NCRBUTTONUP, "WM_NCRBUTTONUP"},
	{(DWORD)WM_NCRBUTTONDBLCLK, "WM_NCRBUTTONDBLCLK"},
	{(DWORD)WM_NCMBUTTONDOWN, "WM_NCMBUTTONDOWN"},
	{(DWORD)WM_NCMBUTTONUP, "WM_NCMBUTTONUP"},
	{(DWORD)WM_NCMBUTTONDBLCLK, "WM_NCMBUTTONDBLCLK"},
	{(DWORD)WM_KEYFIRST, "WM_KEYFIRST"},
	{(DWORD)WM_KEYDOWN, "WM_KEYDOWN"},
	{(DWORD)WM_KEYUP, "WM_KEYUP"},
	{(DWORD)WM_CHAR, "WM_CHAR"},
	{(DWORD)WM_DEADCHAR, "WM_DEADCHAR"},
	{(DWORD)WM_SYSKEYDOWN, "WM_SYSKEYDOWN"},
	{(DWORD)WM_SYSKEYUP, "WM_SYSKEYUP"},
	{(DWORD)WM_SYSCHAR, "WM_SYSCHAR"},
	{(DWORD)WM_SYSDEADCHAR, "WM_SYSDEADCHAR"},
	{(DWORD)WM_KEYLAST, "WM_KEYLAST"},
	{(DWORD)WM_IME_STARTCOMPOSITION, "WM_IME_STARTCOMPOSITION"},
	{(DWORD)WM_IME_ENDCOMPOSITION, "WM_IME_ENDCOMPOSITION"},
	{(DWORD)WM_IME_COMPOSITION, "WM_IME_COMPOSITION"},
	{(DWORD)WM_IME_KEYLAST, "WM_IME_KEYLAST"},
	{(DWORD)WM_INITDIALOG, "WM_INITDIALOG"},
	{(DWORD)WM_COMMAND, "WM_COMMAND"},
	{(DWORD)WM_SYSCOMMAND, "WM_SYSCOMMAND"},
	{(DWORD)WM_TIMER, "WM_TIMER"},
	{(DWORD)WM_HSCROLL, "WM_HSCROLL"},
	{(DWORD)WM_VSCROLL, "WM_VSCROLL"},
	{(DWORD)WM_INITMENU, "WM_INITMENU"},
	{(DWORD)WM_INITMENUPOPUP, "WM_INITMENUPOPUP"},
	{(DWORD)WM_MENUSELECT, "WM_MENUSELECT"},
	{(DWORD)WM_MENUCHAR, "WM_MENUCHAR"},
	{(DWORD)WM_ENTERIDLE, "WM_ENTERIDLE"},
	{(DWORD)WM_CTLCOLORMSGBOX, "WM_CTLCOLORMSGBOX"},
	{(DWORD)WM_CTLCOLOREDIT, "WM_CTLCOLOREDIT"},
	{(DWORD)WM_CTLCOLORLISTBOX, "WM_CTLCOLORLISTBOX"},
	{(DWORD)WM_CTLCOLORBTN, "WM_CTLCOLORBTN"},
	{(DWORD)WM_CTLCOLORDLG, "WM_CTLCOLORDLG"},
	{(DWORD)WM_CTLCOLORSCROLLBAR, "WM_CTLCOLORSCROLLBAR"},
	{(DWORD)WM_CTLCOLORSTATIC, "WM_CTLCOLORSTATIC"},
	{(DWORD)WM_MOUSEFIRST, "WM_MOUSEFIRST"},
	{(DWORD)WM_MOUSEMOVE, "WM_MOUSEMOVE"},
	{(DWORD)WM_LBUTTONDOWN, "WM_LBUTTONDOWN"},
	{(DWORD)WM_LBUTTONUP, "WM_LBUTTONUP"},
	{(DWORD)WM_LBUTTONDBLCLK, "WM_LBUTTONDBLCLK"},
	{(DWORD)WM_RBUTTONDOWN, "WM_RBUTTONDOWN"},
	{(DWORD)WM_RBUTTONUP, "WM_RBUTTONUP"},
	{(DWORD)WM_RBUTTONDBLCLK, "WM_RBUTTONDBLCLK"},
	{(DWORD)WM_MBUTTONDOWN, "WM_MBUTTONDOWN"},
	{(DWORD)WM_MBUTTONUP, "WM_MBUTTONUP"},
	{(DWORD)WM_MBUTTONDBLCLK, "WM_MBUTTONDBLCLK"},
	{(DWORD)WM_MOUSELAST, "WM_MOUSELAST"},
	{(DWORD)WM_PARENTNOTIFY, "WM_PARENTNOTIFY"},
	{(DWORD)WM_ENTERMENULOOP, "WM_ENTERMENULOOP"},
	{(DWORD)WM_EXITMENULOOP, "WM_EXITMENULOOP"},
	{(DWORD)WM_NEXTMENU, "WM_NEXTMENU"},
	{(DWORD)WM_SIZING, "WM_SIZING"},
	{(DWORD)WM_CAPTURECHANGED, "WM_CAPTURECHANGED"},
	{(DWORD)WM_MOVING, "WM_MOVING"},
	{(DWORD)WM_POWERBROADCAST, "WM_POWERBROADCAST"},
	{(DWORD)WM_DEVICECHANGE, "WM_DEVICECHANGE"},
	{(DWORD)WM_IME_SETCONTEXT, "WM_IME_SETCONTEXT"},
	{(DWORD)WM_IME_NOTIFY, "WM_IME_NOTIFY"},
	{(DWORD)WM_IME_CONTROL, "WM_IME_CONTROL"},
	{(DWORD)WM_IME_COMPOSITIONFULL, "WM_IME_COMPOSITIONFULL"},
	{(DWORD)WM_IME_SELECT, "WM_IME_SELECT"},
	{(DWORD)WM_IME_CHAR, "WM_IME_CHAR"},
	{(DWORD)WM_IME_KEYDOWN, "WM_IME_KEYDOWN"},
	{(DWORD)WM_IME_KEYUP, "WM_IME_KEYUP"},
	{(DWORD)WM_MDICREATE, "WM_MDICREATE"},
	{(DWORD)WM_MDIDESTROY, "WM_MDIDESTROY"},
	{(DWORD)WM_MDIACTIVATE, "WM_MDIACTIVATE"},
	{(DWORD)WM_MDIRESTORE, "WM_MDIRESTORE"},
	{(DWORD)WM_MDINEXT, "WM_MDINEXT"},
	{(DWORD)WM_MDIMAXIMIZE, "WM_MDIMAXIMIZE"},
	{(DWORD)WM_MDITILE, "WM_MDITILE"},
	{(DWORD)WM_MDICASCADE, "WM_MDICASCADE"},
	{(DWORD)WM_MDIICONARRANGE, "WM_MDIICONARRANGE"},
	{(DWORD)WM_MDIGETACTIVE, "WM_MDIGETACTIVE"},
	{(DWORD)WM_MDISETMENU, "WM_MDISETMENU"},
	{(DWORD)WM_ENTERSIZEMOVE, "WM_ENTERSIZEMOVE"},
	{(DWORD)WM_EXITSIZEMOVE, "WM_EXITSIZEMOVE"},
	{(DWORD)WM_DROPFILES, "WM_DROPFILES"},
	{(DWORD)WM_MDIREFRESHMENU, "WM_MDIREFRESHMENU"},
	{(DWORD)WM_CUT, "WM_CUT"},
	{(DWORD)WM_COPY, "WM_COPY"},
	{(DWORD)WM_PASTE, "WM_PASTE"},
	{(DWORD)WM_CLEAR, "WM_CLEAR"},
	{(DWORD)WM_UNDO, "WM_UNDO"},
	{(DWORD)WM_RENDERFORMAT, "WM_RENDERFORMAT"},
	{(DWORD)WM_RENDERALLFORMATS, "WM_RENDERALLFORMATS"},
	{(DWORD)WM_DESTROYCLIPBOARD, "WM_DESTROYCLIPBOARD"},
	{(DWORD)WM_DRAWCLIPBOARD, "WM_DRAWCLIPBOARD"},
	{(DWORD)WM_PAINTCLIPBOARD, "WM_PAINTCLIPBOARD"},
	{(DWORD)WM_VSCROLLCLIPBOARD, "WM_VSCROLLCLIPBOARD"},
	{(DWORD)WM_SIZECLIPBOARD, "WM_SIZECLIPBOARD"},
	{(DWORD)WM_ASKCBFORMATNAME, "WM_ASKCBFORMATNAME"},
	{(DWORD)WM_CHANGECBCHAIN, "WM_CHANGECBCHAIN"},
	{(DWORD)WM_HSCROLLCLIPBOARD, "WM_HSCROLLCLIPBOARD"},
	{(DWORD)WM_QUERYNEWPALETTE, "WM_QUERYNEWPALETTE"},
	{(DWORD)WM_PALETTEISCHANGING, "WM_PALETTEISCHANGING"},
	{(DWORD)WM_PALETTECHANGED, "WM_PALETTECHANGED"},
	{(DWORD)WM_HOTKEY, "WM_HOTKEY"},
	{(DWORD)WM_PRINT, "WM_PRINT"},
	{(DWORD)WM_PRINTCLIENT, "WM_PRINTCLIENT"},
	{(DWORD)WM_HANDHELDFIRST, "WM_HANDHELDFIRST"},
	{(DWORD)WM_HANDHELDLAST, "WM_HANDHELDLAST"},
	{(DWORD)WM_AFXFIRST, "WM_AFXFIRST"},
	{(DWORD)WM_AFXLAST, "WM_AFXLAST"},
	{(DWORD)WM_PENWINFIRST, "WM_PENWINFIRST"},
	{(DWORD)WM_PENWINLAST, "WM_PENWINLAST"},
	{(DWORD)WM_APP, "WM_APP"}
};

// release + asserts build has no memory checking
#ifndef _RELEASE_ASSERTS_

void DlgDisplayVrgmst(HWND hListMemory)
{
	char szTemp[300];
	int cbTotal = 0;
	for(int imst = 0; vrgmst[imst].szFile != 0; imst++)
		{
		cbTotal += vrgmst[imst].cbAlloc;
		wsprintfA(szTemp, "%6.d   %s", vrgmst[imst].cbAlloc, vrgmst[imst].szFile);
		SendMessage(hListMemory, LB_ADDSTRING, 0,  (LPARAM) szTemp);
		}

	wsprintfA(szTemp, "%6.d   %s", cbTotal, "--- Total ---");
	SendMessage(hListMemory, LB_ADDSTRING, 0,  (LPARAM) szTemp);
}

HFONT hf = 0;

INT_PTR CALLBACK FDlgRicheditDebugCentral(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	HWND hListMemory;
	switch (message)
		{
		case WM_INITDIALOG:
			hListMemory = GetDlgItem(hdlg, IDC_MEMORY_STATISTICS);
			LOGFONTA lf;
			ZeroMemory(&lf, sizeof(lf));
			lf.lfHeight = 14;
			memcpy(lf.lfFaceName, "Courier New", 12);
			hf = CreateFontIndirectA(&lf);
			SendMessage(hListMemory, WM_SETFONT, (WPARAM)hf, FALSE);
			UpdateMst();
			DlgDisplayVrgmst(hListMemory);
			return FALSE;

		case WM_COMMAND:
			switch (wParam)
				{
				case IDOK:
					EndDialog(hdlg, IDOK);
					return TRUE;
				case IDCANCEL:
					EndDialog(hdlg, IDCANCEL);
					return TRUE;
				}
			break;
		}

	return FALSE;
}

void RicheditDebugCentral(void)
{
	DialogBoxA(hinstRE, MAKEINTRESOURCEA(IDD_DEBUG), NULL, FDlgRicheditDebugCentral);
	DeleteObject(hf);
}

#endif //!_RELEASE_ASSERTS_


/*
 *  DebugMain
 *	
 *  @mfunc
 *      Dll entry point.  See Win32 SDK documentation for details.
 *          hDLL - handle of DLL
 *          dwReason - indicates why DLL called
 *          lpReserved - reserved
 *
 *  @rdesc
 *      TRUE (always)
 *
 */
BOOL WINAPI DebugMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            //
            // DLL is attaching to the address space of the current process.
            //
            ghMod = hDLL;
            TlsIndex = TlsAlloc();
            TlsSetValue(TlsIndex, (LPVOID)-1);
            InitializeCriticalSection(&csLog);
            InitializeCriticalSection(&csAssert);

			//Create a separate thread to handle asserts.
            //We use events to halt the the asserting thread
            //during an assert, and to halt the assert thread the rest of
            //the time.  Note that these are autoreset events.
            hEventAssert1= CreateEvent(NULL, FALSE, FALSE, NULL);
            hEventAssert2= CreateEvent(NULL, FALSE, FALSE, NULL);

            INITDEBUGSERVICES(OPTUSEDEFAULTS, NULL, NULL);

            break;
        }

        case DLL_THREAD_ATTACH:
        {

            //
            // A new thread is being created in the current process.
            //
            TlsSetValue(TlsIndex, (LPVOID)-1);
            break;
        }

        case DLL_THREAD_DETACH:
        {
            //
            // A thread is exiting cleanly.
            //
            break;
        }

        case DLL_PROCESS_DETACH:
        {
            //
            // The calling process is detaching the DLL from its address space.
            //
			fDllDetach = TRUE;

            //Clean up after ourselves.
            TlsFree(TlsIndex);
            SETLOGGING(FALSE);

			//Clean up the assert thread stuff.
            if (NULL != hAssertThrd)
                TerminateThread(hAssertThrd, 0);
            if (NULL != hEventAssert1)
                CloseHandle(hEventAssert1);
            if (NULL != hEventAssert2)
                CloseHandle(hEventAssert2);

            DeleteCriticalSection(&csLog);
            DeleteCriticalSection(&csAssert);

            break;
        }
    }   

    return TRUE;
}


//This is not in release asserts build
#ifndef _RELEASE_ASSERTS_

/*
 *  SetLogging
 *	
 *  @mfunc
 *      This function starts and stops logging of output from
 *      the debug services.  If logging is being started, it
 *      creates a new file for logging (path and name specified
 *      in win.ini).  fStartLog is TRUE and logging is already
 *      on, or fStartLog is FALSE and logging is off, this
 *      nothing happens.
 *
 *      fStartLog - TRUE to start logging, FALSE to stop logging.
 *
 */
void WINAPI SetLogging(BOOL fStartLog)
{
    //Don't start logging if it's already on.
    if (fStartLog && !fLogging)
    {
        char szLogFile[MAX_PATH];

        //Set option flag telling everyone we're on
        dwDebugOptions |= OPTLOGGINGON;

        //Get file name
        GetProfileStringA("RICHEDIT DEBUG", "LOGFILE", "", szLogFile, MAX_PATH);

        //Create new file
        hLogFile = CreateFileA(szLogFile, GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        //If we didn't succed creating the file, reset flags and tell user.
        if (INVALID_HANDLE_VALUE == hLogFile)
        {
            dwDebugOptions &= ~OPTLOGGINGON;
            MessageBoxA(NULL, "Unable to open log file.", "Richedit Debug", MB_OK);
        }
    }
    //Don't stop logging if it's not on.
    else if (!fStartLog && fLogging)
    {
        //Set option flag telling everyone we're off, and close file.
        dwDebugOptions &= ~OPTLOGGINGON;
        CloseHandle(hLogFile);
    }
}

#endif //!_RELEASE_ASSERTS_


/*
 *  InitDebugServices
 *	
 *  @mfunc
 *      This function initializes the options for the debug
 *      services.  If this function is not called, all optional
 *      debug services are left off by default.
 *      If OPTUSEDEFAULTS is specified for dwOpts, options are
 *      loaded from win.ini, otherwise  the caller specified
 *      options are set.  If the caller wishes to specify options
 *      they must specify all options they want turned on.  Any
 *      options not explicitly specified will be turned off.
 *      The function also takes a pointer to an assert hook
 *      function and a trace hook function.
 *
 *      dwOpts - Debug options to be set.
 *      pfnAssertHook - Pointer to assert hook function (NULL if none).
 *      pfnTraceHook - Pointer to trace hook function (NULL if none).
 *
 */
DllExport void WINAPI InitDebugServices(DWORD dwOpts,
    PFNASSERTHOOK pfnAssertHook, PFNTRACEHOOK pfnTraceHook)
{
    // Check to see if OPTUSEDEFAULTS was specified.  If so, get
    // values from win.ini.  Otherwise, set options to values
    // specified by caller.
    if (dwOpts & OPTUSEDEFAULTS)
    {
        SETLOGGING(GetProfileIntA("RICHEDIT DEBUG", "LOGGING", 0));
        SETVERBOSE(GetProfileIntA("RICHEDIT DEBUG", "VERBOSE", 0));
        SETINFO(GetProfileIntA("RICHEDIT DEBUG", "INFO", 0));
        SETMEMORY(GetProfileIntA("RICHEDIT DEBUG", "MEMORY", 0));
        SETTRACING(GetProfileIntA("RICHEDIT DEBUG", "TRACE", 0));
        SETTRACEEXT(GetProfileIntA("RICHEDIT DEBUG", "TRACEEXT", 0));
        SETOPT(OPTTRACEDISP, GetProfileIntA("RICHEDIT DEBUG", "TRACEDISP", 0));
        SETOPT(OPTTRACEWRAP, GetProfileIntA("RICHEDIT DEBUG", "TRACEWRAP", 0));
        SETOPT(OPTTRACEEDIT, GetProfileIntA("RICHEDIT DEBUG", "TRACEEDIT", 0));
        SETOPT(OPTTRACETS, GetProfileIntA("RICHEDIT DEBUG", "TRACETS", 0));
        SETOPT(OPTTRACETOM, GetProfileIntA("RICHEDIT DEBUG", "TRACETOM", 0));
        SETOPT(OPTTRACEOLE, GetProfileIntA("RICHEDIT DEBUG", "TRACEOLE", 0));
        SETOPT(OPTTRACEBACK, GetProfileIntA("RICHEDIT DEBUG", "TRACEBACK", 0));
        SETOPT(OPTTRACESEL, GetProfileIntA("RICHEDIT DEBUG", "TRACESEL", 0));
        SETOPT(OPTTRACEHOST, GetProfileIntA("RICHEDIT DEBUG", "TRACEHOST", 0));
        SETOPT(OPTTRACEDTE, GetProfileIntA("RICHEDIT DEBUG", "TRACEDTE", 0));
        SETOPT(OPTTRACEUNDO, GetProfileIntA("RICHEDIT DEBUG", "TRACEUNDO", 0));
        SETOPT(OPTTRACERANG, GetProfileIntA("RICHEDIT DEBUG", "TRACERANG", 0));
        SETOPT(OPTTRACEUTIL, GetProfileIntA("RICHEDIT DEBUG", "TRACEUTIL", 0));
        SETOPT(OPTTRACENOTM, GetProfileIntA("RICHEDIT DEBUG", "TRACENOTM", 0));
        SETOPT(OPTTRACERTFR, GetProfileIntA("RICHEDIT DEBUG", "TRACERTFR", 0));
        SETOPT(OPTTRACERTFW, GetProfileIntA("RICHEDIT DEBUG", "TRACERTFW", 0));
        SETOPT(OPTTRACEPRT, GetProfileIntA("RICHEDIT DEBUG", "TRACEPRT", 0));
        SETOPT(OPTTRACEFE, GetProfileIntA("RICHEDIT DEBUG", "TRACEFE", 0));
        SETOPT(OPTTRACEFONT, GetProfileIntA("RICHEDIT DEBUG", "TRACEFONT", 0));
    }
    else
    {
        //Set up logging before we set dwDebugOptions because
        //SetLogging will not turn logging on if the flag
        //indicates it is already on.
        SETLOGGING(dwOpts & OPTLOGGINGON);
        dwDebugOptions = dwOpts;
    }

    SETASSERTFN(pfnAssertHook);
    SETTRACEFN(pfnTraceHook);
}


/*
 *  AssertProc
 *	
 *  @mfunc
 *      This is the dialog proc for the assert message.
/ *
 *      lParam - The string to display in the dialog.
 *
 */
INT_PTR CALLBACK AssertProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            {
                RECT rcDlg, rcDesk;

                GetWindowRect(hwndDlg, &rcDlg);
                GetWindowRect(GetDesktopWindow(), &rcDesk);

                SetWindowPos(hwndDlg, HWND_TOP,
                ((rcDesk.right - rcDesk.left ) - (rcDlg.right - rcDlg.left))/2,
                ((rcDesk.bottom - rcDesk.top ) - (rcDlg.bottom - rcDlg.top))/2,
                0, 0, SWP_NOSIZE);


                if (NULL != lParam)
                    SetDlgItemTextA(hwndDlg, IDC_MSG, (LPSTR)lParam);

                //Sometimes we don't always end up on top.  I don't know why.
                SetForegroundWindow(hwndDlg);                
            }
            break;

        case WM_COMMAND:
            //Kill dialog and return button id that was pressed.
            EndDialog(hwndDlg, LOWORD(wParam));
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


/*
 *  AssertThread
 *	
 *  @mfunc
 *      This is the entry point for the thread created for the
 *      assert dialog.
 *
 *      lParam - Data passed to thread...not used.
 *
 *  @rdesc
 *      Should not return.  It will be explicitly terminated.
 *
 */
DWORD WINAPI AssertThread(LPVOID lParam)
{
    //This should run until it is explicitly terminated in
    //process detach.
    while(TRUE)
    {
		//We go into a wait state until the event is signaled,
		//which means we are handling an assert.
        WaitForSingleObject(hEventAssert1, INFINITE);
        idAssert = DialogBoxParamA(ghMod, MAKEINTRESOURCEA(IDD_ASSERT),
            NULL, AssertProc, (LPARAM)szAssert);
		//The asserting thread will be waiting on this event so
		//set it to allow the asserting thread continue.
        SetEvent(hEventAssert2);
    }

    return 0;
}


char * __cdecl strrchr (
        const char * string,
        int ch
        )
{
        char *start = (char *)string;

        while (*string++)                       /* find end of string */
                ;
                                                /* search towards front */
        while (--string != start && *string != (char)ch)
                ;

        if (*string == (char)ch)                /* char found ? */
                return( (char *)string );

        return(NULL);
}

/*
 *  AssertSzFn
 *	
 *  @mfunc
 *      Display a message for the user and give the
 *      option to abort, ignore, or ignore all.
 *      Selecting ignore all causes all asserts to be
 *      ignored from that time forward.  It cannot be
 *      reset.  If the assert dialog cannot be created
 *      A message box is used.  The message box has one
 *      button (OK) which will cause an abort.
 *
 *      szFile - the file the warning occured in.
 *      iLine - the line number the warning occured at.
 *      szUserMsg - User define message string
 *
 */
void AssertSzFn(LPSTR szUserMsg, LPSTR szFile, int iLine)
{
    char szModuleName[MAX_PATH];
    char * pszModuleName;
    DWORD pid;
    DWORD tid;
    DWORD dwAssertTID;

    //Check to see if an assert hook has been set. If it has, call
    //it with pointers to all our parameters (they can be modified
    //this way if desired).  If the hook returns false, return.
    //Otherwise, continue with our assert with the potentially
    //modified parameters.
    if (NULL != pfnAssert)
        if (!pfnAssert(szUserMsg, szFile, &iLine))
            return;


    if( NULL == hAssertThrd )
    {
        if( NULL != hEventAssert1 && NULL != hEventAssert2)
        {
            hAssertThrd = CreateThread(NULL, 0, AssertThread,
                NULL, 0, &dwAssertTID);
        }
    }

    //This critical section will prevent us from being entered simultaneously
    //by multiple threads.  This alone will not prevent reentrance by our own thread
    //once the assert dialog is up. Under normal circumstances a special thread
    //exists to run the assert dialog and Event objects are used to halt this
    //thread while the assert dialog is up (see WaitForSingleObject
    //further down).  If the assert thread does not exist, a MessageBox is used
    //and we can be reentered (this is a fallback position and there's
    //not much we can do about it).
    EnterCriticalSection(&csAssert);

    pid = GetCurrentProcessId();
    tid = GetCurrentThreadId();

    //Get the module name to include in assert message.
    if (GetModuleFileNameA(NULL, szModuleName, MAX_PATH))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }


    //Send a message to the debug output and build a string for the
    //assert dialog.  The string depends on whether the user provided
    //a message.
    if (NULL != szUserMsg)
    {
		TRACEASSERTSZ(szUserMsg, szFile, iLine);
        sprintf(szAssert,
            "PROCESS: %s, PID: %d, TID: %d\nFILE: %s (%d)\n%s\n",
             pszModuleName, pid, tid, szFile, iLine, szUserMsg);
    }
    else
    {
		TRACEASSERT(szFile, iLine);
        sprintf(szAssert,
            "PROCESS: %s, PID: %d, TID: %d\nFILE: %s (%d)\n",
             pszModuleName, pid, tid, szFile, iLine);
    }


    //If the user did not disable asserts on a previous assert,
    //put up a dialog with the assert message.
    if (!fIgnoreAsserts)
    {
        idAssert = -1;

		//If we are in the middle of process detach, the assert thread
		//will not execute so pop the dialog here ourselves.  Presumably there
		//is little change of reentrancy at this point.  If we are not
		//in process detach, let the assert thread handle the assert.
		if (fDllDetach)
		{
            idAssert = DialogBoxParamA(ghMod, MAKEINTRESOURCEA(IDD_ASSERT),
                NULL, AssertProc, (LPARAM)szAssert);
		}
        else
        {
            SetEvent(hEventAssert1);
            WaitForSingleObject(hEventAssert2, INFINITE);
        }

        //The assert thread doesn't exist or the dialogbox create failed so
        //use a message box instead.  In this case, since we
        //are obviously having problems, we are only going to
        //give the user one choice...abort.
        if (-1 == idAssert)
        {
            idAssert = MessageBoxA(NULL,
                             szAssert,
                             "Richedit Assert - (retry will be ignored)",
                              MB_SETFOREGROUND | MB_TASKMODAL |
                              MB_ICONEXCLAMATION | MB_ABORTRETRYIGNORE);

            //
            // If id == 0, then an error occurred.  There are two possibilities
            // that can cause the error:  Access Denied, which means that this
            // process does not have access to the default desktop, and everything
            // else (usually out of memory).
            //
            if (!idAssert)
            {
                if (GetLastError() == ERROR_ACCESS_DENIED)
                {
                    //
                    // Retry this one with the SERVICE_NOTIFICATION flag on.  That
                    // should get us to the right desktop.
                    //
                    idAssert = MessageBoxA(   NULL,
                                        szAssert,
                                        "Richedit Assert - (retry will be ignored)",
                                        MB_SETFOREGROUND | MB_TASKMODAL | MB_ICONEXCLAMATION | 
                                        MB_ABORTRETRYIGNORE);

                }
            }
        }

        if (idAssert == ID_IGNOREALL)
        {
            fIgnoreAsserts = TRUE;
        }

        if (idAssert == IDABORT )
        {
            //This will cause a break when debugging, and
            //an exception leading to termination otherwise.
            DebugBreak();
			return;
        }
    }

    LeaveCriticalSection(&csAssert);
}


/*
 *  TabLookup
 *	
 *  @mfunc
 *      This function searches an array of TabElem
 *      structures looking for an entry whose key
 *      matches the one we were given. If found, it
 *      copies the string associated with the key into
 *      the supplied buffer.
 *      
 *      Table - TabElem pointer to start of array.
 *      TabSize - Size of array in bytes.
 *      dwKey - Key to match.
 *      szBuf - Buffer to hold string (assumed MAXDEBUGSTRLEN in size).
 *
 *  @rdesc
 *      FALSE if key not found, TRUE if found.
 *
 */
BOOL TabLookup(TabElem * Table, UINT TabSize, DWORD dwKey, LPSTR szBuf)
{
    BOOL fRet = FALSE;
    UINT cTab, index;
    
    cTab = TabSize/sizeof(TabElem);

    for (index = 0; index < cTab; index++)
    {
        if (Table[index].dwKey == dwKey)
            break;
    }

    if (index < cTab)
    {
        lstrcpyA(szBuf, Table[index].sz);
        fRet = TRUE;
    }

    return fRet;
}

/*
 *  GetHResultSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string associated
 *      with a given HRESULT.  This string can then be used
 *      in the output from TraceMsg.
 *      
 *      hr - HRESULT on which the string will be based.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 *
 */
void GetHResultSz(HRESULT hr, LPSTR szBuf)
{
    // Build string based on FormatMessageA
    if (!FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD)hr,
        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
        szBuf, MAXDEBUGSTRLEN, NULL))
    {
        // Build default string
        sprintf(szBuf, "hr = %d: Unrecognized HRESULT.", hr);
    }
    else
    {
        int cch;
        char * pch;

        //Need to get rid of the CRLF from FormatMessageA.
        pch = szBuf;
        cch = strlen(szBuf);
        pch += (cch - 2);
        *pch = '\0';
    }
}


/*
 *  GetParamSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string associated
 *      with a param from the text message handler.
 *      This string can then be used in the output from
 *      TraceMsg.
 *      
 *      dwParam - param on which the string will be based.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 */
void GetParamSz(DWORD dwParam, LPSTR szBuf)
{
    char szTemp[MAXDEBUGSTRLEN];

    if (!TabLookup(TrcParamTab, sizeof(TrcParamTab), (DWORD)dwParam, szTemp))
	{
        sprintf(szBuf, "PARAM = %d: Unrecognized PARAM.", dwParam);
	}
	else
	{
        sprintf(szBuf, "PARAM: %s", szTemp);
	}
}

/*
 *  GetDefaultSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string associated
 *      with either the value from GetLastError, or with a
 *      default string. This string can then be used in the
 *      output from TraceMsg.
 *      
 *      dwError - Value from GetLastError.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 *
 */
void GetDefaultSz(DWORD dwError, LPSTR szBuf)
{
    //Check to see if we have an error value
    if (dwError)
    {
        // Build string based on FormatMessageA
        if (!FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError,
            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
            szBuf, MAXDEBUGSTRLEN, NULL))
        {
            // Build default string
            lstrcpyA(szBuf, "Reason unknown.");
        }
        else
        {
            int cch;
            char * pch;

            //Need to get rid of the CRLF from FormatMessageA.
            pch = szBuf;
            cch = strlen(szBuf);
            pch += (cch - 2);
            *pch = '\0';
        }
    }
    else
    {
        // Build default string
        lstrcpyA(szBuf, "Reason unknown.");
    }
}

//The following are not used by the release with asserts build
#ifndef _RELEASE_ASSERTS_

/*
 *  GetDataSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string representing
 *      data passed to TraceMsg in one of it's DWORDS data
 *      parameters. This string can then be used in the
 *      output from TraceMsg.
 *      
 *      uDataType - This is the type of data we are dealing with.
 *      dwData - This is the data itself.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 *
 */
void GetDataSz(UINT uDataType, DWORD dwData, LPSTR szBuf)
{
    switch (uDataType)
    {
        // Data is an HRESULT
        case TRCDATAHRESULT:
            GetHResultSz((HRESULT)dwData, szBuf);
            break;

        // Data is a string (copy to szBuf and pass it through)
        case TRCDATASTRING:
            lstrcpyA(szBuf, (LPSTR)(DWORD_PTR)dwData);
            break;

        // Data is a parameter value
        case TRCDATAPARAM:
            GetParamSz(dwData, szBuf);
            break;

        // Get string based on GetLastError
        case TRCDATADEFAULT:
        default:
            GetDefaultSz(dwData, szBuf);
            break;
    }
}


/*
 *  LogDebugString
 *	
 *  @mfunc
 *      This function writes a string to the log file.  The file must
 *      be opened already and hLogFile must contain the handle.
 *      
 *      szDebugMsg - String to write to log file.
 *
 */
void LogDebugString(LPSTR szDebugMsg)
{
    if ((NULL != hLogFile) && (INVALID_HANDLE_VALUE != hLogFile))
    {
        DWORD dwMsgBytes, dwBytes;

        dwMsgBytes = strlen(szDebugMsg)*sizeof(char);

        //Prevent other threads from trying to write at same time.
        EnterCriticalSection(&csLog);
        SetFilePointer(hLogFile, 0, NULL, FILE_END);
        WriteFile (hLogFile, szDebugMsg, dwMsgBytes, &dwBytes, NULL);
        LeaveCriticalSection(&csLog);
    }
}


/*
 *  TraceMsg
 *	
 *  @mfunc
 *      This is the central message generating facility for
 *      the debug tools.  All messages to the debug output
 *      or log file are generated here. This function takes
 *      a DWORD (dwFlags) that consists of packed values that determine
 *      the kind of message to generated.  It takes two DWORD
 *      data parameters that can contain several different
 *      types of data (string, HRESULT, etc.)  These are interpreted
 *      using dwFlags. It also takes the file and line associated with
 *      the point in the source where it was called.
 *      
 *      dwFlags - Packed values tell us how to generate the message.
 *      dwData1 - The first of two data parameters.
 *      dwData2 - The second of two data parameters.
 *      szFile  - File name we were called from.
 *      iLine   - Line number we were called from.
 *
 */
void TraceMsg(DWORD dwFlags, DWORD dwData1, DWORD dwData2,
    LPSTR szFile, int iLine)
{
    //The following three buffers are used to build our message.
    char szTemp[MAXDEBUGSTRLEN];
    char szTemp2[MAXDEBUGSTRLEN];
    char szDebugMsg[MAXDEBUGSTRLEN];
    char* pch;
    int cch;
    TrcFlags trcf; //Used to decode dwFlags
    DWORD pid;
    DWORD tid;
    DWORD dwError;
    int indent, tls;
    
    //Check to see if a Trace hook has been set. If it has, call
    //it with pointers to all our parameters (they can be modified
    //this way if desired).  If the hook returns false, return.
    //Otherwise, continue with our message output with the potentially
    //modified parameters.
    if (NULL != pfnTrace)
        if (!pfnTrace(&dwFlags, &dwData1, &dwData2, szFile, &iLine))
            return;

    trcf.dw = dwFlags;

    //Return if this is an informational message and they are disabled.
    if ((TRCSEVINFO == trcf.fields.uSeverity) && !fInfo)
        return;

     // Call GetLastError now in case we need it later.
    // This way api calls downstream won't disturb the value
    // we need.
    dwError = GetLastError();
    pid = GetCurrentProcessId();
    tid = GetCurrentThreadId();
    szTemp[0] = '\0';
    szTemp2[0] = '\0';
    szDebugMsg[0] = '\0';

    // Handle indentation (TLSindent is set by CTrace)
    tls = (int)(DWORD_PTR)TlsGetValue(TlsIndex);
    indent = (tls < 0 ? 0 : tls);
    memset(szDebugMsg, ' ', 2*indent*sizeof(char));
    szDebugMsg[2*indent] = '\0';

    // Handle severity (Warning, Error, etc.)
    if (TRCSEVNONE != trcf.fields.uSeverity)
    {
        sprintf(szTemp, "%s: ", TrcSeverity[trcf.fields.uSeverity]);
        strcat(szDebugMsg, szTemp);
    }
    
    // Interpret the first data value
    if (TRCDATANONE != trcf.fields.uData1)
    {
        if (TRCDATADEFAULT == trcf.fields.uData1)
            dwData1 = dwError;
        GetDataSz(trcf.fields.uData1, dwData1, szTemp2);
        lstrcpyA(szTemp, szDebugMsg);
        wsprintfA(szDebugMsg, "%s%s ", szTemp, szTemp2);
    }

    // Interpret the second data value.
    if (TRCDATANONE != trcf.fields.uData2)
    {
        if (TRCDATADEFAULT == trcf.fields.uData2)
            dwData2 = dwError;
        GetDataSz(trcf.fields.uData2, dwData2, szTemp2);
        lstrcpyA(szTemp, szDebugMsg);
        wsprintfA(szDebugMsg, "%s%s", szTemp, szTemp2);
    }

    if (fVerbose)
    {
        // Handle scope (Internal/External call)
        if (TRCSCOPENONE != trcf.fields.uScope)
        {
            sprintf(szTemp, "SCOPE: %s ", TrcScope[trcf.fields.uScope]);
            strcat(szDebugMsg, szTemp);
        }

        // Handle subsytem (TOM, ITextServices, etc.)
        if (TRCSUBSYSNONE != trcf.fields.uSubSystem)
        {
            sprintf(szTemp, "SUBSYSTEM: %s ", TrcSubsys[trcf.fields.uSubSystem]);
            strcat(szDebugMsg, szTemp);
        }

        // Handle process ID, thread ID, file and line.
        sprintf(szTemp, "PID: %u TID: %u ", pid, tid);
        strcat(szDebugMsg, szTemp);
    }

    // Up to now there is no real danger of overflowing our buffer since
    // we were dealing with strings of small size.  Now we will be running
    // in to paths and user strings.  We will use _snprintf to concatonate
    // new stuff to our message.  This is not the most effecient way since
    // it involves alot of copying, but it is a fairly simple way to keep
    // adding to our string without having to worry about how much room is
    // left in the buffer.  It will truncate if we go past the end.
    if (NULL != szFile)
    {
        lstrcpyA(szTemp, szDebugMsg);

        if (0 != iLine)
        {
            wsprintfA(szDebugMsg, "%sFILE: %s (%u) ",
                szTemp, szFile, iLine);
        }
        else
        {
            wsprintfA(szDebugMsg, "%sFILE: %s ",
                szTemp, szFile);
        }
    }

    // Append a CRLF to the end of the string (make sure we don't overflow)
    cch = strlen(szDebugMsg);
    pch = szDebugMsg;
    if (cch < (MAXDEBUGSTRLEN - 3))
        pch += cch;
    else
        pch += (MAXDEBUGSTRLEN - 3);

    lstrcpyA(pch, "\r\n");

    if (fLogging)
        LogDebugString(szDebugMsg);

    // Write to debug output.
    OutputDebugStringA(szDebugMsg);
}

/*
 *	Tracef
 *
 *	@mfunc:
 *      The given format string and parameters are used to render a
 *      string into a buffer. This string is passed to TraceMsg.
 *      The severity parameter determines the type of message.  The
 *      following values are valid: TRCSEVWARN, TRCSEVERR, TRCSEVINFO.
 *	
 *	Arguments:
 *      dwSev   Severity of message.
 *		szFmt	Format string for wvsprintf (qqv)
 */
void Tracef(DWORD dwSev, LPSTR szFmt, ...)
{
	va_list	valMarker;
    char rgchTraceTagBuffer[MAXDEBUGSTRLEN];

	//	format out a string
	va_start(valMarker, szFmt);
	wvsprintfA(rgchTraceTagBuffer, szFmt, valMarker);
	va_end(valMarker);

	if (dwSev == TRCSEVERR)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	else if (dwSev == TRCSEVWARN)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
    else if (dwSev == TRCSEVINFO)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVINFO, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	else if (dwSev == TRCSEVMEM)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVMEM, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	else
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVNONE, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
}

/*
 *	TraceError
 *
 *	@mfunc:
 *		This function is for compatibility with old debug functionality.
 *      An error message is generated and sent to TraceMsg.
 *	
 */
void TraceError(LPSTR sz, LONG sc)
{
	if (FAILED(sc))
	{
        char rgchTraceTagBuffer[MAXDEBUGSTRLEN];

		wsprintfA(rgchTraceTagBuffer,
				  "%s, error=%ld (%#08lx).", sz, sc, sc);
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	}
}

/*
 *  CheckTrace
 *	
 *  @mfunc
 *      This function checks to see if tracing should be performed
 *      in a function given the debug options set and the subsystem
 *      the function is in.
 *      ptrcf   - Pointer to TrcFlags structure passed to CTrace.
 *
 *  @rdesc
 *      True if tracing should be performed, false otherwise.
 *
 */
static BOOL CheckTrace(TrcFlags * ptrcf)
{
    DWORD dwOpt;

    //Set dwOpt to the correct value for the subsytem we are
    //in.
    switch (ptrcf->fields.uSubSystem)
    {
        case TRCSUBSYSDISP: dwOpt = OPTTRACEDISP;   break;
        case TRCSUBSYSWRAP: dwOpt = OPTTRACEWRAP;   break;
        case TRCSUBSYSEDIT: dwOpt = OPTTRACEEDIT;   break;
        case TRCSUBSYSTS:   dwOpt = OPTTRACETS;     break;
        case TRCSUBSYSTOM:  dwOpt = OPTTRACETOM;    break;
        case TRCSUBSYSOLE:  dwOpt = OPTTRACEOLE;    break;
        case TRCSUBSYSBACK: dwOpt = OPTTRACEBACK;   break;
        case TRCSUBSYSSEL:  dwOpt = OPTTRACESEL;    break;
        case TRCSUBSYSHOST: dwOpt = OPTTRACEHOST;   break;
        case TRCSUBSYSDTE:  dwOpt = OPTTRACEDTE;    break;
        case TRCSUBSYSUNDO: dwOpt = OPTTRACEUNDO;   break;
        case TRCSUBSYSRANG: dwOpt = OPTTRACERANG;   break;
        case TRCSUBSYSUTIL: dwOpt = OPTTRACEUTIL;   break;
        case TRCSUBSYSNOTM: dwOpt = OPTTRACENOTM;   break;
        case TRCSUBSYSRTFR: dwOpt = OPTTRACERTFR;   break;
        case TRCSUBSYSRTFW: dwOpt = OPTTRACERTFW;   break;
        case TRCSUBSYSPRT:  dwOpt = OPTTRACEPRT;    break;
        case TRCSUBSYSFE:   dwOpt = OPTTRACEFE;     break;
        case TRCSUBSYSFONT: dwOpt = OPTTRACEFONT;   break;
        default:
             return FALSE;
    }

    //If there is no tracing at any level enabled, return false.
    if (!ISOPTSET(dwOpt) && !fTrace
        && !(fTraceExt && (ptrcf->fields.uScope == TRCSCOPEEXTERN)))
        return FALSE;

    return TRUE;
}

/*
 *  CTrace::CTrace
 *	
 *  @mfunc
 *      This constructor is used to generate output about the function
 *      it is called from.  Creating an instance of this class on the
 *      stack at the beginning of a function, will cause a trace message
 *      to be sent to the debug output.  When the function returns, the
 *      destructor will be called automatically and another message
 *      will be sent to the debug output.
 *      This constructor takes several parameters to pass on to
 *      TraceMsg and it also stores certain data for use by the destructor.
 *      
 *      dwFlags - Packed values tell us how to generate the message.
 *      dw1     - The first of two data parameters.  This must be
 *                the name of the function we were called from.
 *      dw2     - The second of two data parameters.  This will be either
 *                unused or it will be a parameter to be interpreted by
 *                TraceMsg.
 *      szFile  - File name we were called from.
 *
 */
CTrace::CTrace(DWORD dwFlags, DWORD dw1, DWORD dw2, LPSTR szFile)
{
    char szFunc[80];
    int tls;

    trcf.dw = dwFlags;

    //Return if tracing is not enabled.
    if (!CheckTrace(&trcf))
        return;

    //Increment indentation level on entrance to function
    tls = (int)(DWORD_PTR)TlsGetValue(TlsIndex);
    tls++;
    TlsSetValue(TlsIndex, (LPVOID)(DWORD_PTR)tls);

    szFunc[0] = '\0';
    lstrcpyA(szFileName, szFile);
    lstrcpyA(szFuncName, (LPSTR)(DWORD_PTR)dw1);

    sprintf(szFunc, "IN : %s.", szFuncName);

    TraceMsg (trcf.dw, (DWORD)(DWORD_PTR)szFunc, dw2, szFileName, 0);
}


/*
 *  CTrace::~CTrace
 *	
 *  @mfunc
 *      This destructor is used to generate output about the function
 *      it is called from.  Creating an instance of this class on the
 *      stack at the beginning of a function, will cause a trace message
 *      to be sent to the debug output.  When the function returns, the
 *      destructor will be called automatically and another message
 *      will be sent to the debug output.
 *
 *
 */
CTrace::~CTrace()
{
    char szFunc[80];
    int tls;

    //Return if tracing is not enabled.
    if (!CheckTrace(&trcf))
        return;

    szFunc[0] = '\0';
    sprintf(szFunc, "OUT: %s.", szFuncName);

    trcf.fields.uData2 = TRCDATANONE;
    TraceMsg (trcf.dw, (DWORD)(DWORD_PTR)szFunc, 0, szFileName, 0);

    //Decrement indentation level on exit from function
    tls = (int)(DWORD_PTR)TlsGetValue(TlsIndex);
    tls--;
    TlsSetValue(TlsIndex, (LPVOID)(DWORD_PTR)tls);
}

#endif //!_RELEASE_ASSERTS_

#endif // !!(DEBUG) && !! _RELEASE_ASSERTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\dfreeze.cpp ===
/*	@doc INTERNAL
 *
 *	@module _DFREEZE.CPP  Implementation for classes handle freezing the display |
 *	
 *	This module implements non-inline members used by logic to handle freezing the display
 *
 *	History: <nl>
 *		2/8/96	ricksa	Created
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */
#include	"_common.h"
#include	"_disp.h"
#include	"_dfreeze.h"

ASSERTDATA

/*
 *	CAccumDisplayChanges::GetUpdateRegion(pcpStart, pcchDel, pcchNew,
 *										  pfUpdateCaret, pfScrollIntoView)
 *	@mfunc
 *		Get region for display to update
 */
void CAccumDisplayChanges::GetUpdateRegion(
	LONG *pcpStart,			//@parm where to put the cpStart
	LONG *pcchDel,			//@parm where to put the del char count
	LONG *pcchNew,			//@parm where to put the new char count
	BOOL *pfUpdateCaret,	//@parm whether caret update is needed
	BOOL *pfScrollIntoView,	//@parm whether to scroll caret into view
	BOOL *pfNeedRedisplay)	//@parm whether it needs redisplay
{
	LONG cchDel;
	*pcpStart = _cpMin;

	if(pfUpdateCaret)
		*pfUpdateCaret = _fUpdateCaret;
	if(pfScrollIntoView)
		*pfScrollIntoView = _fScrollIntoView;
	if (pfNeedRedisplay)
		*pfNeedRedisplay = _fNeedRedisplay;

	if(_cpMin == CP_INFINITE)
		return;

	cchDel = _cpMax - _cpMin;

	if(pcchDel)
		*pcchDel =  cchDel;

	*pcchNew = cchDel + _delta;

	_cpMin = CP_INFINITE;
}

/*
 *	CAccumDisplayChanges::UpdateRecalcRegion(cpStartNew, cchDel, cchNew)
 *
 *	@mfunc
 *		Merge new update with region to be recalculated
 */
void CAccumDisplayChanges::UpdateRecalcRegion(
	LONG cpStartNew,	//@parm Start of update
	LONG cchDel,		//@parm Count of chars to delete
	LONG cchNew)		//@parm Count of chars to add
{
	if(CP_INFINITE == _cpMin)
	{
		// Object is empty so just assign values
		_cpMin = cpStartNew;
		_cpMax = cpStartNew + cchDel;
		_delta = cchNew - cchDel;
		return;
	}

	// The basic idea of this algorithm is to merge the updates so that
	// they appear to the display sub-system as if only one replace range
	// has occured. To do this we keep track of the start of the update 
	// (_cpMin) relative to the original text and the end of the update 
	// (_cpMax) relative to the original text and the change  in the count 
	// of text (_delta). We can recreate cchDel from _cpMost - _cpMin and 
	// cchNew from cchDel + _delta.

	// Do we need to update _cpMin? - we only need to update _cpMin if the
	// current update begins before the last update because the final update
	// need only know the very start of the range updated.
	if(cpStartNew < _cpMin)
		_cpMin = cpStartNew;

	// Do we need to udpate _cpMax? - we only need to update _cpMax if the
	// current update implies a _cpMax that is greater than the current one.
	// Note that because prior updates affect where the _cpMax is located
	// we need to compare againt the proposed _cpMax against the current
	// _cpMax adjusted by the change in the text since the beginning of the
	// updates.
	if(cpStartNew + cchDel > _cpMax + _delta)
		_cpMax = cpStartNew + cchDel - _delta;

	// Increment the total change by the change for this update.
	_delta += cchNew - cchDel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\devdsc.cpp ===
/*
 *	DEVDSC.C
 *	
 *	Purpose:
 *		CDevDesc (Device Descriptor) class
 *	
 *	Owner:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 */

#include "_common.h"
#include "_devdsc.h"
#include "_edit.h"
#include "_font.h"

ASSERTDATA

BOOL CDevDesc::SetDC(HDC hdc, LONG dxpInch, LONG dypInch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::SetDC");

	AssertSz((NULL == hdc) || (GetDeviceCaps(hdc, TECHNOLOGY) != DT_METAFILE),
		"CDevDesc::SetDC attempting to set a metafile");

	_hdc = hdc;
	if(!_hdc)
	{
	    if(!_ped->_fInPlaceActive || !(hdc = _ped->TxGetDC()))
        {
            _dxpInch = _dypInch = 0;
    	    return FALSE;
        }
    }

	if (dxpInch == -1)
	{
		// Get device metrics - these should both succeed
		_dxpInch = (SHORT)GetDeviceCaps(hdc, LOGPIXELSX);
		AssertSz(_dxpInch != 0, "CDevDesc::SetDC _dxpInch is 0");
	}
	else
		_dxpInch = dxpInch;

	if (dypInch == -1)
	{
		_dypInch = (SHORT)GetDeviceCaps(hdc, LOGPIXELSY);
		AssertSz(_dypInch != 0, "CDevDesc::SetDC _dypInch is 0");
	}
	else
		_dypInch = dypInch;

	if(!_dxpInch || !_dypInch)
		return FALSE;

	// Release DC if we got the window DC
	if(!_hdc)
		_ped->TxReleaseDC(hdc);

	return TRUE;
}


void CDevDesc::SetMetafileDC(
	HDC hdcMetafile,
	LONG xMeasurePerInch,
	LONG yMeasurePerInch)
{
	_fMetafile = TRUE;
	_hdc = hdcMetafile;
	_dxpInch = (SHORT) xMeasurePerInch;
	_dypInch = (SHORT) yMeasurePerInch;
}

HDC CDevDesc::GetScreenDC() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::GetScreenDC");

	Assert(!_hdc);
	Assert(_ped);
	return _ped->TxGetDC();
}

VOID CDevDesc::ReleaseScreenDC(HDC hdc) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::ReleaseScreenDC");

	Assert(!_hdc);
	Assert(_ped);
	_ped->TxReleaseDC(hdc);
}

LONG CDevDesc::DXtoLX(LONG x) const	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::DXtoLX");

    AssertSz(_dxpInch, "CDevDesc::DXtoLX() - hdc has not been set");
    return ((x * LX_PER_INCH) * 2 + _dxpInch) / (2 * _dxpInch);
}

LONG CDevDesc::DYtoLY(LONG y) const	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::DYtoLY");

    AssertSz(_dypInch, "CDevDesc::DYtoLY() - hdc has not been set");
    return ((y * LY_PER_INCH) * 2 + _dypInch) / (2 * _dypInch);
}

void CDevDesc::DPtoLP(POINT &ptDest, const POINT &ptSrc) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::DPtoLP");

    ptDest.x = DXtoLX(ptSrc.x);    
    ptDest.y = DYtoLY(ptSrc.y);    
}

void CDevDesc::DRtoLR(RECT &rcDest, const RECT &rcSrc) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::DRtoLR");

    rcDest.left = DXtoLX(rcSrc.left);    
    rcDest.right = DXtoLX(rcSrc.right);    
    rcDest.top = DYtoLY(rcSrc.top);    
    rcDest.bottom = DYtoLY(rcSrc.bottom);    
}

#ifdef DEBUG
LONG CDevDesc::LXtoDX(LONG x) const	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::LXtoDX");

    AssertSz(_dxpInch, "CDevDesc::LXtoDX() - hdc has not been set");
    return ((x * _dxpInch) + LX_PER_INCH / 2) / LX_PER_INCH;
}

LONG CDevDesc::LYtoDY(LONG y) const	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::LYtoDY");

    AssertSz(_dypInch, "CDevDesc::LYtoDY() - hdc has not been set");
    return ((y * _dypInch) + LY_PER_INCH / 2) / LY_PER_INCH;
}
#endif  // DEBUG

void CDevDesc::LPtoDP(POINT &ptDest, const POINT &ptSrc) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::LPtoDP");

    ptDest.x = LXtoDX(ptSrc.x);    
    ptDest.y = LYtoDY(ptSrc.y);    
}

void CDevDesc::LRtoDR(RECT &rcDest, const RECT &rcSrc) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::LRtoDR");

    rcDest.left = LXtoDX(rcSrc.left);    
    rcDest.right = LXtoDX(rcSrc.right);    
    rcDest.top = LYtoDY(rcSrc.top);    
    rcDest.bottom = LYtoDY(rcSrc.bottom);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\disp.cpp ===
/*
 *	DISP.CPP
 *	
 *	Purpose:
 *		CDisplay class
 *	
 *	Owner:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *		Jon Matousek - smooth scrolling.
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_disp.h"
#include "_edit.h"
#include "_select.h"
#include "_font.h"
#include "_measure.h"
#include "_osdc.h"
#include "_dfreeze.h"

ASSERTDATA

// Decimal point precision of smooth scrolling calculations.
#define SMOOTH_PRECISION (100000L)


// ===========================  Invariant stuff  ======================================================

#define DEBUG_CLASSNAME CDisplay
#include "_invar.h"

#ifdef DEBUG
BOOL
CDisplay::Invariant( void ) const
{
	AssertSz(_yHeightView >= 0, "CDisplay::Invariant invalid _yHeightView");
	AssertSz(_yHeightClient	>= 0, 
		"CDisplay::Invariant invalid _yHeightClient");

	return TRUE;
}
#endif

// Constant used to build the rectangle used for determining if a hit is close
// to the text.
#define HIT_CLOSE_RECT_INC	5


// Auto scroll constants
#define dwAutoScrollUp		1
#define dwAutoScrollDown	2
#define dwAutoScrollLeft	3
#define dwAutoScrollRight	4


// ===========================  CLed  =====================================================


void CLed::SetMax(
	const CDisplay * const pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLed::SetMax");

	_cpMatchNew	 = _cpMatchOld	= pdp->_ped->GetTextLength();
	_iliMatchNew = _iliMatchOld = max(0, pdp->LineCount() - 1);
	_yMatchNew	 = _yMatchOld	= pdp->GetHeight();
}


// ===========================  CDisplay  =====================================================


DWORD 	CDisplay::_dwTimeScrollNext;	// time for next scroll step
DWORD 	CDisplay::_dwScrollLast;		// last scroll action

/*
 *	CDisplay::ConvertYPosToMax(xPos)
 *
 *	@mfunc	
 *		Calculate real scroll position from scroll position
 *
 *	@rdesc
 *		X position from scroll
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the Y position
 *		gets greater than that.
 */
LONG CDisplay::ConvertScrollToXPos(
	LONG xPos)		//@parm Scroll position 
{
	LONG xMax = GetMaxXScroll();

	// Has maximum scroll range exceeded 16-bits?
	if (xMax >= _UI16_MAX)
	{
		// Yes - Extrapolate to the "real" x Positioin
		xPos = MulDiv(xPos, xMax, _UI16_MAX);
	}
	return xPos;
}

/*
 *	CDisplay::ConvertXPosToScrollPos(xPos)
 *
 *	@mfunc	
 *		Calculate scroll position from X position in document.
 *
 *	@rdesc
 *		Scroll position from X position
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the Y position
 *		gets greater than that.
 *
 */
LONG CDisplay::ConvertXPosToScrollPos(
	LONG xPos)		//@parm Y position in document
{
	LONG xMax = GetMaxXScroll();

	// Has maximum scroll range exceeded 16-bits?
	if(xMax >= _UI16_MAX)
	{
		// Yes - Extrapolate to the scroll bar position		
		xPos = MulDiv(xPos, _UI16_MAX, xMax);
	}
	return xPos;
}

/*
 *	CDisplay::ConvertYPosToMax(yPos)
 *
 *	@mfunc	
 *		Calculate the real scroll position from the scroll position
 *
 *	@rdesc
 *		Y position from scroll
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the Y position
 *		gets greater than that.
 */
LONG CDisplay::ConvertYPosToScrollPos(
	LONG yPos)		//@parm Scroll position 
{
	// Default is single line edit control which cannot have Y-Scroll bars
	return 0;
}

CDisplay::CDisplay (CTxtEdit* ped) :
	CDevDesc (ped)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::CDisplay");

	_TEST_INVARIANT_
	_fRecalcDone = TRUE;
}

CDisplay::~CDisplay()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::~CDisplay");
				 
	_TEST_INVARIANT_
	
	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Remove(this);

	CheckRemoveSmoothVScroll();

	if (_padc)
		delete _padc;

#ifdef LINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif
}

/*
 *	CDisplay::InitFromDisplay(pdp)
 *
 *	@mfunc initialize this display from another display instance.
 *
 *	@comment
 *			copy *only* the members that will remain constant
 *		   	between two different display instances.  Currently, that
 *			is only the view variables and device descriptor info.
 */
void CDisplay::InitFromDisplay(
	const CDisplay *pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::InitFromDisplay");

	_xWidthView		= pdp->_xWidthView;
	_yHeightView	= pdp->_yHeightView;
	_yHeightClient	= pdp->_yHeightClient;

	// Don't save DC; just coordinate information.
	_dxpInch		= pdp->_dxpInch;
	_dypInch		= pdp->_dypInch;

	// If display we are copying from is active display,
	// then this new display is the active display.
	_fActive		= pdp->_fActive;
}

/*
 *	CDisplay::Init()
 *
 *	@mfunc Initializes CDisplay
 *
 *	@rdesc
 *		TRUE iff initialization succeeded
 */
BOOL CDisplay::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::Init");

	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Add(this);

	return TRUE;
}

/*
 *	CDisplay::GetSelBarInPixels()
 *
 *	@mfunc
 *		Helper that returns size of selection bar in device units.
 *
 *	@rdesc
 *		Size of selection bar (is 0 if none).
 */
LONG CDisplay::GetSelBarInPixels()
{
	return HimetricXtoDX(_ped->TxGetSelectionBarWidth());
}


//================================  Device drivers  ===================================
/*
 *	CDisplay::SetMainTargetDC(hdc, xWidthMax)
 *
 *	@mfunc
 *		Sets a target device for this display and updates view 
 *
 *  Note:
 *      No support for targetDC in the base CDisplay class.
 *
 *	Note:
 *		Target device can't be a metafile (can get char width out of a 
 *		metafile)
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplay::SetMainTargetDC(
	HDC	 hdc,			//@parm Target DC, NULL for same as rendering device
	LONG xWidthMax)		//@parm Max width of lines (not used if target device is screen)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetMainTargetDC");

	_TEST_INVARIANT_

	return TRUE;
}

BOOL CDisplay::SetTargetDC(
	HDC hdc, LONG dxpInch, LONG dypInch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetTargetDC");

	_TEST_INVARIANT_

	return TRUE;
}

/* 
 *	CDisplay::SetDrawInfo(pdi, dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev)
 *
 *	@mfunc
 *		Sets the drawing information into the display
 *
 *	@rdesc	
 *		void - this cannot fail
 *
 *	@devnote
 *		The key point to this routine is that the caller of this routine
 *		is the owner of the memory for the drawing information. It is the
 *		callers responsiblity to call ReleaseDrawInfo to tell the display
 *		that it is done with the drawing information.
 */
void CDisplay::SetDrawInfo(
	CDrawInfo *pdi,		//@parm memory for draw info if there is not one already
	DWORD dwDrawAspect,	//@parm draw aspect
	LONG  lindex,		//@parm currently unused
	void *pvAspect,		//@parm info for drawing optimizations (OCX 96)
	DVTARGETDEVICE *ptd,//@parm information on target device								
	HDC hicTargetDev)	//@parm	target information context
{
	HDC hicTargetToUse = hicTargetDev;
	const CDevDesc *pdd;

	// Set up the target device if we need to use the default
	if ((NULL == hicTargetToUse))
	{
		pdd = GetDdTarget();
		if(pdd)
			hicTargetToUse = pdd->GetDC();	
	}

	if (NULL == _pdi)
	{
		// Draw structure not yet allocated so use the one
		// passed in
		_pdi = pdi;
	}

	// Reset the parameters
	_pdi->Init(
		dwDrawAspect,
		lindex,
		pvAspect,
		ptd,
		hicTargetToUse);
}

/* 
 *	CDisplay::ReleaseDrawInfo ()
 *
 *	@mfunc
 *		Releases drawing information from display
 *
 *	@rdesc	
 *		void - this cannot fail
 *
 *	@devnote
 *		Since the display does not own the memory for the drawing information,
 *		this only NULLs out the pointer in the drawing information pointer. It
 *		is the responsiblity of the caller to free the memory for the drawing
 *		information.
 */
void CDisplay::ReleaseDrawInfo()
{
	if(_pdi && !_pdi->Release())
	{
		// This object is no longer referenced so we toss our reference.
		_pdi = NULL;
	}
}

/* 
 *	CDisplay::GetTargetDev ()
 *
 *	@mfunc
 *		Get the target device if one is available
 *
 *	@rdesc	
 *		Pointer to device description object or NULL if none is available.
 *
 *	@devnote
 *		This uses the draw info if it is available and then the main target DC
 *		if it is available.
 */
const CDevDesc*CDisplay::GetTargetDev() const
{
	const CDevDesc *pdd = NULL;

	if(_pdi && _pdi->GetTargetDD())
		pdd = _pdi->GetTargetDD();

	return pdd ? pdd : GetDdTarget();
}


//================================  Background Recalc  ===================================
/*
 *	CDisplay::StepBackgroundRecalc()
 *
 *	@mfunc
 *		Steps background line recalc (at GetCp()CalcMax position)
 *		Called by timer proc. No effect for base class
 *
 *	??? CF - Should use an idle thread
 */
void CDisplay::StepBackgroundRecalc()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::StepBackgroundRecalc");

	_TEST_INVARIANT_
}

/*
 *	CDisplay::WaitForRecalc(cpMax, yMax)
 *
 *	@mfunc
 *		Ensures that lines are recalced until a specific character
 *		position or ypos. Always TRUE for base CDisplay class.
 *						
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplay::WaitForRecalc(
	LONG cpMax,		//@parm Position recalc up to (-1 to ignore)
	LONG yMax)		//@parm ypos to recalc up to (-1 to ignore)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::WaitForRecalc");

	_TEST_INVARIANT_

	return TRUE;
}

/*
 *	CDisplay::WaitForRecalcIli(ili)
 *
 *	@mfunc
 *		Returns TRUE if lines were recalc'd up to ili
 *      Always the case for base CDisplay class.
 */
BOOL CDisplay::WaitForRecalcIli(
	LONG ili)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::WaitForRecalcIli");

	_TEST_INVARIANT_

    return TRUE;
}

/*
 *	CDisplay::WaitForRecalcView()
 *
 *	Purpose
 *		Ensure visible lines are completly recalced
 *      Always the case for base CDisplay class
 */
BOOL CDisplay::WaitForRecalcView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::WaitForRecalcView");

	_TEST_INVARIANT_

	return TRUE;
}


//====================================  Rendering  =======================================
/*
 * 	CDisplay::Draw(hdcDraw, hicTargetDev, prcClient, prcWBounds,
 *				   prcUpdate, pfnContinue, dwContinue)
 *	@mfunc
 *		General drawing method called by IViewObject::Draw() or in
 *		response to WM_PAINT
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT	CDisplay::Draw(
	HDC		hdcDraw,			//@parm	Rendering device context
	HDC		hicTargetDev,		//@parm	Target information context
	LPCRECT	prcClient,			//@parm	Bounding (client) rectangle
	LPCRECT	prcWBounds,			//@parm Clipping rect for metafiles
    LPCRECT prcUpdate,			//@parm	Dirty rect inside prcClient
	BOOL (CALLBACK *pfnContinue)(DWORD),//@parm Callback for interrupting
								//	long display (currently unused)
	DWORD	dwContinue)			//@parm	Param to pass to pfnContinue
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::Draw");

	_TEST_INVARIANT_

	HRESULT hr = S_OK;

	// Store current depth in drawing locally so we can tell
	// whether we need to actually render.
	DWORD dwDepthThisDraw = _pdi->GetDrawDepth();

    RECT rcView, rcClient, rcRender;
	CTxtSelection *psel = _ped->GetSelNC();

    // Get client rect
    if(prcClient)
    	rcClient = *prcClient;
    else
    {
        AssertSz(_ped->_fInPlaceActive, 
        	"CDisplay::GetViewRect() - Not in-place and !prcClient");
        _ped->TxGetClientRect(&rcClient);
    }

	if(!prcWBounds)		// No metafile, so just set rendering DC
	{
		if(!SetDC(hdcDraw))
		{
			hr = E_FAIL;
			goto Cleanup;
		}
	}
	else				// Rendering to a metafile
	{
		//Forms^3 draws using screen resolution, while OLE specifies HIMETRIC
		long dxpInch = GetPed()->fInOurHost() ? 2540 : W32->GetXPerInchScreenDC();
		long dypInch = GetPed()->fInOurHost() ? 2540 : W32->GetYPerInchScreenDC();

		SetWindowOrgEx(hdcDraw, prcWBounds->left, prcWBounds->top, NULL);
		SetWindowExtEx(hdcDraw, prcWBounds->right, prcWBounds->bottom, NULL);

		SetMetafileDC(hdcDraw, dxpInch, dypInch);
	}		

	// Compute view rectangle (rcView) from client rectangle (account for
	// inset and selection bar width)
  	GetViewRect(rcView, &rcClient);

	// If this view is not active and it is not to be recalc'd then
	// we only decide to use it if the size matches and return S_FALSE
	// if it doesn't so the caller can create a new display to use for
	// drawing.
	if(!IsActive() && !_fNeedRecalc)
	{
		if (rcView.right - rcView.left != GetViewWidth() ||
			rcView.bottom - rcView.top != GetViewHeight())
		{
			hr = S_FALSE;
			goto Cleanup;
		}
	}

	// Make sure our client rectangle is set correctly.
	_yHeightClient = rcClient.bottom - rcClient.top;

    // Recalc view 
    // bug fix #5521
    // RecalcView can potentially call RequestResize which would
    // change the client rect.  Send rect down to update the client rect
    if(!RecalcView(rcView, &rcClient))
		goto Cleanup;

	if(dwDepthThisDraw != _pdi->GetDrawDepth())
	{
		// A draw happened recursively to this draw. Therefore,
		// the screen has already been rendered so we don't need
		// to do anything more here.
		goto Cleanup;
	}

    // Compute rect to render
    if(!prcUpdate)						// Update full view
        rcRender = rcClient;			
	else								// Clip rendering to client rect 
	{
        if(!IntersectRect(&rcRender, &rcClient, prcUpdate))
            goto Cleanup;
    }
    
    if(psel)
        psel->ClearCchPending();

    if(IsMain())
        _ped->TxNotify( EN_UPDATE, NULL );

    // Now render
    Render(rcView, rcRender);

	// Update cursor if we need to
	if(_fUpdateCaret)
	{
		// The caret only belongs in an active view with
		// a selection on a control that has the focus
		if (IsActive() && psel && _ped->_fFocus)
		{
			// Update the caret if there is a selection object.
			// Note: we only scroll the caret into view, if
			// it was previously in the view. This avoids having
			// window pop to caret if it is resized and the
			// caret is not in the view.
			psel->UpdateCaret(psel->IsCaretInView());
		}
		_fUpdateCaret = FALSE;
	}

Cleanup:

   	// Reset DC in device descriptor
 	ResetDC();

	return hr;
}	


//====================================  View Recalc  ===================================
/*
 *	CDisplay::UpdateViewRectState(prcClient)
 *
 *	@mfunc	Compares new view to cached and updates the view as well as the
 *	what type of view recalculation needs to occur.
 */
void CDisplay::UpdateViewRectState(
	const RECT *prcClient)	//@parm New client rectangle
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::UpdateViewRectState");

    // Check whether the view rect has changed since last rendering
    // If width has changed, need complete line recalc.
    // If height has changed, recalc all visible and update scrollbars
    if(prcClient->right - prcClient->left != _xWidthView)
    {
        _xWidthView = (SHORT)(prcClient->right - prcClient->left);
        _fViewChanged = TRUE;            
        _fNeedRecalc = TRUE;    // need full recalc
    }

    if(prcClient->bottom - prcClient->top != _yHeightView) 
    {
        _yHeightView = prcClient->bottom - prcClient->top;

		// The height can go negative when there is an inset and
		// the client rect is very small. We just set it to 0 because
		// that is the smallest the view can actually get.
		if (_yHeightView < 0)
			_yHeightView = 0;

        _fViewChanged = TRUE;
    } 
}

/*
 *	CDisplay::ReDrawOnRectChange
 *
 *	@mfunc	Compares new view to cached and updates the display both
 *	internal and visible state appropriately.
 */
void CDisplay::ReDrawOnRectChange( 
	HDC hicTarget,			//@param Target device
	const RECT *prcClient)	//@param New client rectangle
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::ReDrawOnRectChange");

	_TEST_INVARIANT_

    RECT rcView;

	// Convert client rect to our view rect
  	GetViewRect(rcView, prcClient);

	// Update the x and y coordinates of the view based on the client rect
	UpdateViewRectState(&rcView);

	if(_fNeedRecalc || _fViewChanged)
	{
		// The client rect changed in some way so lets update our client
		// rect height for zoom.
		_yHeightClient = prcClient->bottom - prcClient->top;

		// Remeasure but don't update scroll bars now.
		RecalcView(FALSE);

		// Forms does not want the screen to reflect what the user clicked on
		// or moved the cursor to so we oblige them by not updating the screen
		// here but waiting for some future action to do so.
	}
}

/*
 *	CDisplay::RecalcView(rcView)
 *
 *	@mfunc
 *		RecalcView after the view rect changed
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplay::RecalcView (
	const RECT &rcView, RECT* prcClient)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::RecalcView");

	_TEST_INVARIANT_

	// Update the x and y coordinates of the view based on the client rect
	UpdateViewRectState(&rcView);

	// Ensure lines are recalced
	if(_fNeedRecalc)
	{
		// Display got recalculated so the caret needs to be repositioned.
		_fUpdateCaret = TRUE;
    	return RecalcView(TRUE, prcClient);
	}
	if(_fViewChanged)
	{
		// The scroll bars are up to date so we can turn off the notification.
		_fViewChanged = FALSE;

		// A height change was noticed in UpdateViewRectState so make sure
		// the horizontal scroll bar (if any is correct).
		UpdateScrollBar(SB_VERT);
	}
    return WaitForRecalcView();
}


//====================================  View Update  ===================================

/*
 *	CDisplay::UpdateView()
 *
 *	@mfunc
 *		Fully recalc all lines and update the visible part of the display 
 *		(the "view") on the screen.
 *
 *	Returns:
 *		TRUE if success
 */
BOOL CDisplay::UpdateView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::UpdateView");

	_TEST_INVARIANT_

	if(_fNoUpdateView)
		return TRUE;

	if(!_ped->_fInPlaceActive)
    {
        // If not active, just invalidate everything
        InvalidateRecalc();
        _ped->TxInvalidateRect(NULL, FALSE);
		_ped->TxUpdateWindow();
        return TRUE;
    }

	if(_ped->_pdp->IsFrozen())
	{
		_ped->_pdp->SetNeedRedisplayOnThaw(TRUE);
		return TRUE;
	}

	// If we get here, we are updating some general characteristic of the
	// display and so we want the cursor updated as well as the general
	// change; otherwise the cursor will land up in the wrong place.
	_fUpdateCaret = TRUE;

	RECT rcView;

	// Get view rectangle
  	GetViewRect(rcView, NULL);
	
	// Update size of view, which could have changed
	UpdateViewRectState(&rcView);

    // From here on we better be in place
    Assert(_ped->_fInPlaceActive);

	if(!CDevDesc::IsValid())
	{
		// Make our device valid
		SetDC(NULL);
	}

    // Recalc everything
    RecalcView(TRUE);

	// Invalidate entire view
	_ped->TxInvalidateRect (NULL, FALSE);
	
	return TRUE;
}

/*
 *	CDisplay::RoundToLine(hdc, width, pheight)
 *
 *	@mfunc
 *		Calculate number of default lines to fit in input height
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 */
HRESULT CDisplay::RoundToLine(
	HDC hdc, 			//@parm DC for the window
	LONG width,			//@parm in - width of window; out max width
	LONG *pheight)		//@parm in - proposed height; out - actual
{
	CLock lock;					// Uses global (shared) FontCache
	SetDC(hdc);					// Set DC

	// Set height temporarily so zoom factor will work out
	LONG yOrigHeightClient = SetClientHeight((SHORT) *pheight);

	// Use this to adjust for inset height
	LONG yAdjForInset = *pheight;

	// Get rectangle adjusted for insets
	GetViewDim(width, *pheight);

	// Save proposed height
	LONG yProposed = *pheight;

	// Calc inset adjusted height
	yAdjForInset -= yProposed;

	// Get font
	const CCharFormat *pCF = _ped->GetCharFormat(-1);

	Assert(pCF);

	// Get font cache object
	LONG dypInch = MulDiv(GetDeviceCaps(hdc, LOGPIXELSY), GetZoomNumerator(), GetZoomDenominator());

	CCcs *pccs = fc().GetCcs(pCF, dypInch);
	SHORT	yAdjustFE = pccs->AdjustFEHeight(!_ped->fUseUIFont() && _ped->_pdp->IsMultiLine());
	
	// Get height of font
	LONG yHeight = pccs->_yHeight + (yAdjustFE << 1);;

	// All we wanted is the height and we have got it so dump the
	// font cache entry
	pccs->Release();

	// Figure out how many lines fit into the input height
	LONG cLines = yProposed / yHeight;

	// See if we need to round up
	if(yProposed % yHeight || !cLines)
		cLines++;

	// Set height to new value
	*pheight = yHeight * cLines + yAdjForInset;

	// Set client height back to what it was
	SetClientHeight(yOrigHeightClient);

	// Reset the DC
	ResetDC();

	return NOERROR;
}


//=============================  Client and view rectangles  ===========================

/*
 * 	CDisplay::OnClientRectChange(&rcClient)
 *
 *	@mfunc
 *		Update when either the client rectangle changes
 *      >>> Should be called only when in-place active <<<
 */
void CDisplay::OnClientRectChange(
	const RECT &rcClient)	//@parm New client rectangle
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::OnClientRectChange");

	_TEST_INVARIANT_

    RECT rcView;
    
	AssertSz(_ped->_fInPlaceActive, "CDisplay::OnClientRectChange() called when not in-place active");

	// Make sure our client rectangle is set correctly.
	_yHeightClient = rcClient.bottom - rcClient.top;

    // Use view rect change notification
	GetViewRect(rcView);

	// Make sure that we will have a selection object at this point
	_ped->GetSel();

 	// Update when view rectangle changes
	OnViewRectChange(rcView);
}

/*
 * 	CDisplay::OnViewRectChange(&rcView)
 *
 *	@mfunc
 *		Update when either the view rectangle changes
 *  
 *  Arguments:
 *      rcView   new view rectangle, in:
 *               - log units (twips) rel. to top/left of client rect if not in-place
 *               - containing window client coords if in-place active
 */
void CDisplay::OnViewRectChange(
	const RECT &rcView)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::OnViewRectChange");

	_TEST_INVARIANT_

    if(!_ped->_fInPlaceActive)
        // We'll adjust the view rect during next Draw.
        return;

	CTxtSelection *psel = _ped->GetSelNC();
	const BOOL fCaretShowing = psel ? psel->ShowCaret(FALSE) : FALSE;
	const BOOL fCaretInView = fCaretShowing ? psel->IsCaretInView() : FALSE;
    RECT rcV = rcView;
	COleObject *pipo;

	// Factor in selection bar space
	if (_ped->IsSelectionBarRight())
		rcV.right -= GetSelBarInPixels();
	else
		rcV.left += GetSelBarInPixels();

	// Recalc with new view rectangle
    // ??? What if this fails ?
    RecalcView(rcView);
	
	// Repaint window before showing the caret
    _ped->TxInvalidateRect(NULL, FALSE);  // ??? for now, we could be smarter 
	_ped->TxUpdateWindow();

	// Reposition the caret
	if(fCaretShowing)
	{
	    Assert(psel);
		psel->ShowCaret(TRUE);
		psel->UpdateCaret(fCaretInView);
	}

	// FUTURE: since we're now repositioning in place active 
	// objects every time we draw, this call seems to be 
	// superfluous (AndreiB)

	// Tell object subsystem to reposition any in place objects
	if( _ped->HasObjects() )
	{
		pipo = _ped->GetObjectMgr()->GetInPlaceActiveObject();
		if(pipo)
			pipo->OnReposition( 0, 0 );
	}
}

/*
 * 	CDisplay::RequestResize()
 *
 *	@mfunc
 *		Forces the control to resize vertically so that all text fit into it
 *
 *	@rdesc
 *		HRESULT = (autosize) ? TxNotify(EN_REQUESTRESIZE, &resize) : S_OK
 */
HRESULT CDisplay::RequestResize()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::RequestResize");

	_TEST_INVARIANT_

	if(_ped->TxGetAutoSize())
	{
		REQRESIZE resize;

		// If word wrapping is on, then the width is the normal
		// client width.  Otherwise, it's the width of the longest
		// line plus the width of the caret.
		DWORD width = GetWordWrap() ? _xWidthView : GetWidth() + dxCaret;

		// Get view inset for adjusting width
	 	RECT rcInset;
		_ped->TxGetViewInset(&rcInset, this);
		
		resize.nmhdr.hwndFrom = NULL;
		resize.nmhdr.idFrom = NULL;
		resize.nmhdr.code = EN_REQUESTRESIZE;

		resize.rc.top = 0;
		resize.rc.left = 0;
		resize.rc.bottom = GetResizeHeight();

		// 1.0 COMPATABILITY
        // 1.0 included the borders when requesting resize
        if (_ped->Get10Mode())
        {
            AssertSz(_ped->fInplaceActive(), "In 1.0 mode but not inplace active!!");
            HWND hwnd = NULL;
            _ped->TxGetWindow(&hwnd);
            if (hwnd)
            {
                RECT rcClient, rcWindow;
                _ped->TxGetClientRect(&rcClient);                
                GetWindowRect(hwnd, &rcWindow);
                width = rcClient.right;
                resize.rc.bottom += max(rcWindow.bottom - rcWindow.top - rcClient.bottom, 0);
				resize.rc.bottom += rcInset.bottom + rcInset.top;
				resize.rc.right = rcWindow.right - rcWindow.left;
			} 			
			else 
				resize.rc.right = width;
        }
		else
		{
			// Adjust width by inset and selection bar 
			resize.rc.right = width + rcInset.left + rcInset.right
				+ GetSelBarInPixels();	
		}
  
  		return _ped->TxNotify(EN_REQUESTRESIZE, &resize);
	}
	return S_OK;
}

/*
 *	CDisplay::GetViewRect(RECT &rcView, LPCRECT prcClient)
 *
 *	@mfunc
 *		Compute and return the view rectangle in window's client 
 *      area coordinates.
 *
 *	@comm
 *      prcClient is client rect (in window's client coords), which can be
 *		NULL if we are in-place.
 */
void CDisplay::GetViewRect(
	RECT &	rcView,		//@parm Reference to rect to return
	LPCRECT prcClient)	//@parm Client rect (in window's client coords)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetViewRect");

	_TEST_INVARIANT_

    RECT rcInset;
    
    // If client rect wasn't passed in, get it from host
    if(prcClient)
        rcView = *prcClient;
    else
    {
        AssertSz(_ped->_fInPlaceActive,
			"CDisplay::GetViewRect() - Not in-place and !prcClient");
        _ped->TxGetClientRect(&rcView);
    }

	// Make sure height is set
	_yHeightClient = rcView.bottom - rcView.top;
    
    // Ask host for view inset and convert to device coordinates
    _ped->TxGetViewInset(&rcInset, this);
    
    rcView.left	  += rcInset.left;			// Add in inset offsets
    rcView.top	  += rcInset.top;			// rcView is in device coords
    rcView.right  -= rcInset.right;
    rcView.bottom -= rcInset.bottom;

	// Add in selection bar space
	if (_ped->IsSelectionBarRight())
		rcView.right -= GetSelBarInPixels();
	else
		rcView.left += GetSelBarInPixels();
}


//===============================  Scrolling  ==============================

/*
 *	CDisplay::VScroll(wCode, yPos)
 *
 *	@mfunc
 *		Scroll the view vertically in response to a scrollbar event
 *      >>> Should be called when in-place active only <<<
 *
 *  Note:
 *      No support for vertical scroll in base CDisplay. No action.
 *
 *	@rdesc
 *		LRESULT formatted for WM_VSCROLL message		
 */
LRESULT CDisplay::VScroll(
	WORD wCode,	   //@parm Scrollbar event code
	LONG yPos)	   //@parm Thumb position (yPos < 0 for EM_SCROLL behavior)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::VScroll");

	_TEST_INVARIANT_

    return 0;
}

/*
 *	CDisplay::HScroll(wCode, xPos)
 *
 *	@mfunc
 *		Scroll view horizontally in response to a scrollbar event
 *      >>> Should be called when in-place active only <<<
 */
void CDisplay::HScroll(
	WORD wCode,	   //@parm Scrollbar event code
	LONG xPos)	   //@parm Thumb position 
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::HScroll");

	_TEST_INVARIANT_

	BOOL fTracking = FALSE;
	LONG xScroll = _xScroll;

	if (xPos != 0)
	{
		// Convert x position from scroll bar to offset horizontally
		// in the document.
		xPos = ConvertScrollToXPos(xPos);
	}
    
    AssertSz(_ped->_fInPlaceActive, "CDisplay::HScroll() called when not in place");

	switch(wCode)
	{
	case SB_BOTTOM:
		xScroll = GetWidth();
		break;

	case SB_LINEDOWN:
		// Future: Make this depend on a the current first visible character
		xScroll += GetXWidthSys();
		break;

	case SB_LINEUP:
		// Future: Make this depend on a the current first visible character
		xScroll -= GetXWidthSys();
		break;

	case SB_PAGEDOWN:
		xScroll += _xWidthView;
		break;

	case SB_PAGEUP:
		xScroll -= _xWidthView;
		break;

	case SB_THUMBTRACK:
	case SB_THUMBPOSITION:
		if(xPos < 0)
			return;
		xScroll = xPos;
		fTracking = TRUE;
		break;

	case SB_TOP:
		xScroll = 0;
		break;

	case SB_ENDSCROLL:
		UpdateScrollBar(SB_HORZ);
		return;

	default:
		return;
	}

	if (xScroll < 0)
	{
		// xScroll is the new proposed scrolling position and
		// therefore cannot be less than 0.
		xScroll = 0;
	}

	ScrollView(xScroll, -1, fTracking, FALSE);

	// force position update if we just finished a track
	if(wCode == SB_THUMBPOSITION)
		UpdateScrollBar(SB_HORZ);
}


/*
 *	CDisplayML::SmoothVScroll ( int direction, WORD cLines,
 *								int speedNum, int speedDenom, BOOL fAdditive )
 *
 *	@mfunc
 *		Setup to handle fractional scrolls, at a particular speed. This was
 *		probably initiated via a Magellan mouse roller movement, or a MButton
 *		down message.
 */
void CDisplay::SmoothVScroll ( int direction, WORD cLines, int speedNum, int speedDenom, BOOL fMouseRoller )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::SmoothVScroll");

	int yDelta;
	int cLinesAndDir;

	int	smoothYDelta;

	Assert ( speedDenom );

	if ( IsVScrollEnabled() )						// Can scroll vertically?
	{
		_fFinishSmoothVScroll = FALSE;				// We're smoothing again.

													// Get total pixels.
		if ( CheckInstallSmoothVScroll() )			// Install periodic update
		{
			_totalSmoothVScroll		= 0;
			_nextSmoothVScroll		= 0;
		}
													// Pixels per epoch
		cLinesAndDir = (direction < 0) ? cLines : -cLines;

		if( cLines )
		{
			yDelta = CalcYLineScrollDelta ( cLinesAndDir, FALSE );
		}
		else
		{
			yDelta = (direction < 0 ) ? _yHeightClient : -_yHeightClient;
			cLines = 1;		// for the MulDiv calculation below.
		}

		if ( yDelta )								// If something to scroll.
		{
			smoothYDelta = MulDiv( SMOOTH_PRECISION,// NB-Because no FLOAT type
								MulDiv(yDelta, speedNum, speedDenom), cLines);

			_smoothYDelta				= smoothYDelta;
			if ( fMouseRoller )						// roller event.
			{										//  -> additive.
				_totalSmoothVScroll		+= yDelta;
				_continuedSmoothYDelta	= 0;
				_continuedSmoothVScroll	= 0;
			}										// mButton event
			else
			{
				if ( 0 == _totalSmoothVScroll )
					_totalSmoothVScroll		= yDelta;

				_continuedSmoothYDelta	= smoothYDelta;
				_continuedSmoothVScroll	= yDelta;	
			}
		}
	}
}

/*
 *	CDisplay::SmoothVScrollUpdate()
 *
 *	@mfunc
 *		Supports SmoothVScroll. Scroll a small number of pixels.
 *		We are called via a periodic timing task.
 */
void CDisplay::SmoothVScrollUpdate()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::SmoothVScrollUpdate");

	LONG	yDelta;									//  Magellan mouse.
	BOOL	fImmediateUpdate = FALSE;
	
	_nextSmoothVScroll += _smoothYDelta;
													// Remove fractional amt.
	yDelta = _nextSmoothVScroll / SMOOTH_PRECISION;

													// Don't overshoot.
	if ( 0 == _continuedSmoothVScroll
		&& (	(_totalSmoothVScroll <= 0 && yDelta < _totalSmoothVScroll)
			||	(_totalSmoothVScroll >= 0 && yDelta > _totalSmoothVScroll)) )
	{
		yDelta = _totalSmoothVScroll;
	}
											 
	if ( yDelta )									// Scroll yDelta, the
	{												//  integral amount.
		_totalSmoothVScroll -= yDelta;
		_nextSmoothVScroll -= yDelta * SMOOTH_PRECISION;
		FractionalScrollView( yDelta );
	}
	else if ( 0 == _totalSmoothVScroll )			// Starting to wind down?
	{
		 _nextSmoothVScroll -= _smoothYDelta;
		 fImmediateUpdate = TRUE;
	}
													// Finished scrolling?
	if ( (yDelta <= 0 && _totalSmoothVScroll >= 0) || (yDelta >= 0 && _totalSmoothVScroll <= 0 ) )
	{
		LONG cLinesAndDir;

		if ( _continuedSmoothYDelta )				// mButton continuation.
		{
			_smoothYDelta = _continuedSmoothYDelta;
			_totalSmoothVScroll += _continuedSmoothVScroll;
		}
		else
		{
			if ( _continuedSmoothVScroll )
			{
				_fFinishSmoothVScroll	= TRUE;		// Winding down scroll.     
				_continuedSmoothVScroll = 0;		
													// Last line's remainder... 
				cLinesAndDir = _smoothYDelta < 0 ? -1 : 1;
				_totalSmoothVScroll = CalcYLineScrollDelta ( cLinesAndDir, TRUE );

													// check for line boundry.
				if ( _totalSmoothVScroll
					==	CalcYLineScrollDelta ( cLinesAndDir, FALSE ) )
				{
					_totalSmoothVScroll = 0;
				}

				if ( fImmediateUpdate )				// do 'this' epochs scroll.
					SmoothVScrollUpdate();
			}
			else
			{
				CheckRemoveSmoothVScroll();			// All done, remove timer.
			}
		}
	}
}

/*
 *	CDisplay::FinishSmoothVScroll
 *
 *	@mfunc
 *		Cause smooth scroll to finish off the last fractional lines worth of
 *		scrolling and then stop.
 */
VOID CDisplay::FinishSmoothVScroll( )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::FinishSmoothVScroll");

													// any non-zero value.

	if ( !_fFinishSmoothVScroll && _totalSmoothVScroll )
	{
		_fFinishSmoothVScroll	= TRUE;
		_continuedSmoothVScroll = 1;					
		_continuedSmoothYDelta	= 0;				// So smooth scroll stops.
		_totalSmoothVScroll		= 0;
	}
}

/*
 *	CTxtEdit::CheckInstallSmoothScroll()
 *
 *	@mfunc
 *		Install a new smooth scroll timer if not already scrolling.
 */
BOOL CDisplay::CheckInstallSmoothVScroll()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::CheckInstallSmoothVScroll");

	_TEST_INVARIANT_
	
	BOOL	fJustInstalled = FALSE;

	if(!_fSmoothVScroll && _ped->TxSetTimer(RETID_SMOOTHSCROLL, 25))
	{
		_fSmoothVScroll = TRUE;
		fJustInstalled = TRUE;
	}

	return fJustInstalled;
}

/*
 *	CTxtEdit::CheckRemoveSmoothVScroll ( )
 *
 *	@mfunc
 *		Finish smooth scroll. If not a forced stop, then check
 *		to see if smooth scrolling should continue, and if so, setup
 *		to continue smooth scrolling.
 */
VOID CDisplay::CheckRemoveSmoothVScroll ( )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::CheckRemoveSmoothVScroll");

	_TEST_INVARIANT_

	if(	_fSmoothVScroll )
	{
		ScrollToLineStart( _continuedSmoothVScroll );	// Ensure stopped on a line.

		_ped->TxKillTimer(RETID_SMOOTHSCROLL);
		_fSmoothVScroll = FALSE;
	}
}

/*
 *	CDisplay::LineScroll(cli, cch)
 *
 *	@mfunc
 *		Scroll the view horizontally in response to a scrollbar event
 *
 *  Note:
 *      No support for vertical scroll in base CDisplay. No action.
 */
void CDisplay::LineScroll(
	LONG cli,	//@parm Count of lines to scroll vertically
	LONG cch)	//@parm Count of chars to scroll horizontally
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::LineScroll");

	_TEST_INVARIANT_

    return;
}

void CDisplay::FractionalScrollView (
	LONG yDelta )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::FractionalScrollView");

	_TEST_INVARIANT_

    return;
}

VOID CDisplay::ScrollToLineStart ( LONG iDirection )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::ScrollToLineStart");

	_TEST_INVARIANT_

    return;
}

LONG CDisplay::CalcYLineScrollDelta ( LONG cli, BOOL fFractionalFirst )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::CalcYLineScrollDelta");

	_TEST_INVARIANT_

    return 0;
}

/*
 *	CDisplay::DragScroll(ppt)
 *
 *	@mfunc
 *		Auto scroll when dragging the mouse out of the visible view
 *
 *	Arguments:
 *		ppt 	mouse position (in client coordinates)
 */
BOOL CDisplay::DragScroll(const POINT * ppt)	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::DragScroll");

	_TEST_INVARIANT_

	const DWORD dwTime = GetTickCount();
	BOOL fScrolled = FALSE;
	DWORD dwScroll = 0;
	RECT rc;
    int nScrollInset;

    AssertSz(_ped->_fInPlaceActive, "CDisplay::DragScroll() called when not in-place");

    GetViewRect(rc);
    nScrollInset = (int)W32->GetScrollInset();
	InflateRect(&rc, - nScrollInset, - nScrollInset);

	if(_fVScrollEnabled && (_ped->TxGetScrollBars() & ES_AUTOVSCROLL))
	{
    	const yScroll = ConvertYPosToScrollPos(GetYScroll());

		if(ppt->y <= rc.top)
		{
			dwScroll = dwAutoScrollUp;
		}
		else if(ppt->y > rc.bottom) 
		{
			LONG yMax = GetScrollRange(SB_VERT);
			if(yScroll < yMax)
				dwScroll = dwAutoScrollDown;
		}
	}
	
	if(!dwScroll && _fHScrollEnabled && (_ped->TxGetScrollBars() & ES_AUTOHSCROLL))
	{
    	const xScroll = ConvertXPosToScrollPos(GetXScroll());

		if((ppt->x <= rc.left) && (xScroll > 0))
		{
			dwScroll = dwAutoScrollLeft;
		}
		else if(ppt->x > rc.right) 
		{
			LONG xMax = GetScrollRange(SB_HORZ);
			if(xScroll < xMax)
    			dwScroll = dwAutoScrollRight;
		}
	}

	if(dwScroll)
	{
		if(_dwScrollLast != dwScroll)
		{
			// entered or moved to a different auto scroll area
			// reset delay counter
			TRACEINFOSZ("enter auto scroll area");
			_dwTimeScrollNext = dwTime + cmsecScrollDelay;
		}
		else if(dwTime >= _dwTimeScrollNext)
		{
			WORD wScrollCode = SB_LINEDOWN;

			switch(dwScroll)
			{
			case dwAutoScrollUp:
				wScrollCode = SB_LINEUP;
				// fall through to dwAutoScrollDown
			case dwAutoScrollDown:
				// OnVScroll() doesn't scroll enough for our desires
				VScroll(wScrollCode, 0);
				VScroll(wScrollCode, 0);
				break;

			case dwAutoScrollLeft:
				wScrollCode = SB_LINEUP;
				// fall through to dwAutoScrollRight
			case dwAutoScrollRight:
				// HScroll() doesn't scroll enough for our desires
				HScroll(wScrollCode, 0);
				HScroll(wScrollCode, 0);
				HScroll(wScrollCode, 0);
				HScroll(wScrollCode, 0);
				break;
#ifdef DEBUG
			default:
				Tracef(TRCSEVWARN, "Unexpected dwScroll %lx", dwScroll);
				TRACEERRSZSC("Unexpected dwScroll", E_INVALIDARG);
				break;
#endif
			}
			// reset interval counter
			_dwTimeScrollNext = dwTime + cmsecScrollInterval;
			fScrolled = TRUE;
		}
	}
#ifdef DEBUG
	else if(_dwScrollLast)
		TRACEINFOSZ("moved out of auto scroll area");
#endif
	_dwScrollLast = dwScroll;

	return fScrolled;
}

/*
 *	CDisplay::AutoScroll(pt, xScrollInset, yScrollInset)
 *
 *	@mfunc:
 *		Given the current point, determine whether we need to
 *		scroll the client area.
 *
 *	Requires:
 *		This function should only be called during a drag drop
 *		operation.
 *
 *	@rdesc
 *		True if we are in the drag scrolling hot zone, false otherwise.
 *
 */
#define ScrollUp	0x0001	//These eight macros indicate the areas
#define ScrollDown	0x0010	//of the drag scrolling hot zone that tell
#define ScrollLeft	0x0100	//which direction to scroll.
#define ScrollRight 0x1000	//The last four are ambiguous (the corners)
#define ScrollUL	0x0101	//and require a little extra work.
#define ScrollUR	0x1001
#define ScrollDL	0x0110
#define ScrollDR	0x1010

BOOL CDisplay::AutoScroll(
	POINT pt,				 //@parm Cursor location in client coordinates
	const WORD xScrollInset,
	const WORD yScrollInset)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDisplay::AutoScroll");

	static DWORD hotticks = 0;			//Ticks when we entered hot zone.
	static DWORD lastscrollticks = 0;	//Ticks when we last scroll.
	static DWORD lastticks = 0;			//Ticks when last called.
	DWORD delta;						//Ticks since last called.
	DWORD ticks;						//GetTickCount ticks.
	RECT rcClient;						//Client rect of control.
	WORD wScrollDir = 0;				//Scroll direction.
	BOOL fScroll = FALSE;				//TRUE if we should try to scroll this time.
    BOOL fEnabled = FALSE;              //TRUE if scrolling is possible

	//Get the current ticks and calculate ticks since last called.
	//Note that if _drags does not have valid data this will be a
	//bogus value, but that is handled later.
	ticks = GetTickCount();
	delta = ticks - lastticks;
	lastticks = ticks;

	//Don't do anything if no ticks since last time we were called.
	if (delta)
	{
		// Get our client rect.
		_ped->TxGetClientRect(&rcClient);

		//Find out if we are in the hot zone.
		//Note that if we are in one of the corners
		//we will indicate two scrolling directions.
		//This ambiguity will be sorted out later.
		//For now we just want to know if we are in
		//the zone.
		if (pt.x <= (LONG)(rcClient.left + xScrollInset))
			wScrollDir |= (WORD)ScrollLeft;
		else if (pt.x >= (LONG)(rcClient.right - xScrollInset))
			wScrollDir |= (WORD)ScrollRight;

		if (pt.y <= (LONG)(rcClient.top + yScrollInset))
			wScrollDir |= (WORD)ScrollUp;
		else if (pt.y >= (LONG)(rcClient.bottom - yScrollInset))
			wScrollDir |= (WORD)ScrollDown;
			
		//If we are somewhere in the hot zone.
		if (wScrollDir)
		{
			//If we just entered hotzone remember the current ticks.
			if (!hotticks)
				hotticks = ticks;

			//If we have been in the hot zone long enough, and
			//the required interval since the last scroll has elapsed
			//allow another scroll. Note that if we haven't scrolled yet,
			//lastscrollticks will be zero so the delta is virtually
			//guaranteed to be greater than ScrollInterval.
			if ((ticks - hotticks) >= (DWORD)W32->GetScrollDelay() &&
			    (ticks - lastscrollticks) >= (DWORD)W32->GetScrollInterval())
				fScroll = TRUE;

    		//If we are in one of the corners, we scroll
    		//in the direction of the edge we are closest
    		//to.
    		switch (wScrollDir)
    		{
    			case ScrollUL:
    			{
    				if ((pt.y - rcClient.top) <= (pt.x - rcClient.left))
    					wScrollDir = ScrollUp;
    				else
    					wScrollDir = ScrollLeft;
    				break;
    			}
    			case ScrollUR:
    			{
    				if ((pt.y - rcClient.top) <= (rcClient.right - pt.x))
    					wScrollDir = ScrollUp;
    				else
    					wScrollDir = ScrollRight;
    				break;
    			}
    			case ScrollDL:
    			{
    				if ((rcClient.bottom - pt.y) <= (pt.x - rcClient.left))
    					wScrollDir = ScrollDown;
    				else
    					wScrollDir = ScrollLeft;
    				break;
    			}
    			case ScrollDR:
    			{
    				if ((rcClient.bottom - pt.y) <= (rcClient.right - pt.x))
    					wScrollDir = ScrollDown;
    				else
    					wScrollDir = ScrollRight;
    				break;
    			}
    		}
		}
		else
		{
			//We aren't in the hot zone so reset hotticks as a
			//flag so we know the first time we reenter it.
			hotticks = 0;
		}

        //Do processing for horizontal scrolling if necessary
		if (wScrollDir == ScrollLeft || wScrollDir == ScrollRight)
		{
            LONG xRange, xScroll, dx;

            xScroll = ConvertXPosToScrollPos(GetXScroll());
            xRange = GetScrollRange(SB_HORZ);
			dx = W32->GetScrollHAmount();

            fEnabled = IsHScrollEnabled();
            if (wScrollDir == ScrollLeft)
            {
                fEnabled = fEnabled && (xScroll > 0);
               	xScroll -= dx;
                xScroll = max(xScroll, 0);
            }
            else
            {
                fEnabled = fEnabled && (xScroll < xRange);
				xScroll += dx;
                xScroll = min(xScroll, xRange);
            }

            //Do the actual scrolling if necessary.
			if (fEnabled && fScroll)
			{
                HScroll(SB_THUMBPOSITION, xScroll);
				lastscrollticks = ticks;
			}
		}
        //Do processing for Vertical scrolling if necessary
        else if (wScrollDir == ScrollUp || wScrollDir == ScrollDown)
		{
            LONG yRange, yScroll, dy;

            yScroll = ConvertYPosToScrollPos(GetYScroll());
            yRange = GetScrollRange(SB_VERT);
    		dy = W32->GetScrollVAmount();
	
            fEnabled = IsVScrollEnabled();
            if (wScrollDir == ScrollUp)
            {
                fEnabled = fEnabled && (yScroll > 0);
                yScroll -= dy;
                yScroll = max(yScroll, 0);
            }
            else
            {
                fEnabled = fEnabled && (yScroll < yRange);
    			yScroll += dy;
                yScroll = min(yScroll, yRange);
            }

	        //Do the actual scrolling if necessary.
    		if (fEnabled && fScroll)
			{
				// We need to scroll fractionally because the scroll logic tries
				// to put a full line on the top and if the scroll amount is less
				// than a full line, the scrolling will get stuck on that line.
				ScrollView(_xScroll, yScroll, FALSE, TRUE);
				lastscrollticks = ticks;
			}
		}
	}

	return fEnabled;
}

/*
 *	CDisplay::AdjustToDisplayLastLine(yBase, yScroll)
 *
 *	@mfunc
 *		Calculate the yscroll necessary to get the last line to display
 *
 *	@rdesc
 *		Updated yScroll
 *
 *	@devnote:
 *		This method is only really useful for ML displays. This method
 *		here is a placeholder which does nothing which is useful for
 *		all other displays.
 */
LONG CDisplay::AdjustToDisplayLastLine(
	LONG yBase,			//@parm Actual yScroll to display
	LONG yScroll)		//@parm Proposed amount to scroll
{
	return yScroll;
}

/*
 *	CDisplay::GetScrollRange(nBar)
 *
 *	@mfunc
 *		Returns the max part of a scrollbar range
 *      No scrollbar support in the base class: returns 0.
 *
 *	@rdesc
 *		LONG max part of scrollbar range
 */
LONG CDisplay::GetScrollRange(
	INT nBar) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetScrollRange");

	_TEST_INVARIANT_

    return 0;
}

/*
 *	CDisplay::UpdateScrollBar(nBar, fUpdateRange)
 *
 *	@mfunc
 *		Update either the horizontal or vertial scroll bar
 *		Also figure whether the scroll bar should be visible or not
 *      No scrollbar support in the base class: no action.
 *
 *	@rdesc
 *		BOOL
 */
BOOL CDisplay::UpdateScrollBar(
	INT	 nBar,
	BOOL fUpdateRange)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::UpdateScrollBar");

	_TEST_INVARIANT_

	return TRUE;
}

/*
 *	CDisplay::GetZoomDenominator()
 *
 *	@mfunc
 *		Get zoom denominator  
 *
 *	@rdesc
 *		Returns zoom denominator
 *
 *	@devnote:
 *		FUTURE: (Ricksa) we should investigate how to cache this data since
 *				the display needs to keep a temporary zoom denominator anyway.
 */
LONG CDisplay::GetZoomDenominator() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetZoomDenominator");

	if(_ped->GetZoomDenominator())				// Simple EM_SETZOOM API
		return _ped->GetZoomDenominator();		//  supercedes complicated
												//  Forms^3 API
	// Default zoom to error case. The error case is a very low
	// probability event that we can do nothing to recover. So we 
	// just set the value to something reasonable and continue.
	LONG lZoomDenominator = _yHeightClient;

	// Is temporary zoom denominator set?
	if(INVALID_ZOOM_DENOMINATOR == _lTempZoomDenominator)
	{
		// No - Get extent size from host
		SIZEL sizelExtent;
		if(SUCCEEDED(_ped->TxGetExtent(&sizelExtent)))
		{
			// Convert height to device units. Note that by definition, we
			// can ignore horizontal extents so we do. Use CDevDesc conversion
			// to avoid infinite recursion
			lZoomDenominator = CDevDesc::HimetricYtoDY(sizelExtent.cy);
		}
	}
	else	// Temporary zoom denominator is set: use it
		lZoomDenominator = CDevDesc::HimetricYtoDY(_lTempZoomDenominator);

	return lZoomDenominator > 0 ? lZoomDenominator : 1;
}

/*
 *	CDisplay::GetZoomNumerator()
 *
 *	@mfunc
 *		Get zoom numerator  
 *
 *	@rdesc
 *		Returns zoom numerator
 */
LONG CDisplay::GetZoomNumerator() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetZoomNumerator");

	if(_ped->GetZoomNumerator())				// Simple EM_SETZOOM API
		return _ped->GetZoomNumerator();		//  supercedes complicated
												//  Forms^3 API
	return _yHeightClient > 0 ? _yHeightClient : 1;
}

/*
 *	CDisplay::Zoom(x)
 *
 *	@mfunc
 *		Get zoomed x  
 *
 *	@rdesc
 *		Returns zoomed x
 */
// REVIEW (keithcu) Why does Zoom do anything when we are in print preview?
LONG CDisplay::Zoom(LONG x) const
{
	return MulDiv(x, GetZoomNumerator(), GetZoomDenominator());
}

/*
 *	CDisplay::UnZoom(x)
 *
 *	@mfunc
 *		Get unzoomed x  
 *
 *	@rdesc
 *		Returns unzoomed x
 */
LONG CDisplay::UnZoom(LONG x) const
{
	return MulDiv(x, GetZoomDenominator(), GetZoomNumerator());
}

/*
 *	CDisplay::HimetricXtoDX(xHimetric)
 *
 *	@mfunc
 *		Get device x coordinate corresponding to Himetric x coordinate  
 *
 *	@rdesc
 *		Returns device coordinate
 */
LONG CDisplay::HimetricXtoDX(
	LONG xHimetric) const
{
	return CDevDesc::HimetricXtoDX(Zoom(xHimetric));
}

/*
 *	CDisplay::HimetricYtoDY(yHimetric)
 *
 *	@mfunc
 *		Get device y coordinate corresponding to Himetric y coordinate  
 *
 *	@rdesc
 *		Returns device coordinate
 */
LONG CDisplay::HimetricYtoDY(
	LONG yHimetric) const
{
	return CDevDesc::HimetricYtoDY(Zoom(yHimetric));
}

/*
 *	CDisplay::DXtoHimetricX(dx)
 *
 *	@mfunc
 *		Get Himetric x coordinate corresponding to device x coordinate  
 *
 *	@rdesc
 *		Returns Himetric coordinate
 */
LONG CDisplay::DXtoHimetricX(
	LONG dx) const
{
	return UnZoom(CDevDesc::DXtoHimetricX(dx));
}

/*
 *	CDisplay::DXtoHimetricX(dy)
 *
 *	@mfunc
 *		Get Himetric y coordinate corresponding to device y coordinate  
 *
 *	@rdesc
 *		Returns Himetric coordinate
 */
LONG CDisplay::DYtoHimetricY(
	LONG dy) const
{
	return UnZoom(CDevDesc::DYtoHimetricY(dy));
}

/*
 *	CDisplay::SetClientHeight(yNewClientHeight)
 *
 *	@mfunc
 *		Reset height of client rectangle
 *
 *	@rdesc
 *		Returns previous height of the client rectangle
 */
LONG CDisplay::SetClientHeight(
	LONG yNewClientHeight)	//@parm New height for the client rectangle.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetClientHeight");

	LONG yOldHeight = _yHeightClient;
	_yHeightClient = yNewClientHeight;
	return yOldHeight;
}

/*
 *	CDisplay::GetCachedSize(pdwWidth, pdwHeight)
 *
 *	@mfunc		calculates the cached client size (since it's not really
 *				cached :-)
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
 HRESULT CDisplay::GetCachedSize( 
 	DWORD *pdwWidth,  	//@parm	where to put the width
 	DWORD *pdwHeight)	//@parm where to put the height
 {
 	RECT rcInset;

	_ped->TxGetViewInset(&rcInset, this);

	*pdwHeight = _yHeightClient;
	*pdwWidth  = _xWidthView + rcInset.left + rcInset.right 
		+ GetSelBarInPixels();

	return NOERROR;
}

/*
 *	CDisplay::TransparentHitTest(hdc, prcClient, pt, pHitResult)
 *
 *	@mfunc
 *		Determine if the hit is on a transparent control
 *
 *	@rdesc
 *		Returns HRESULT of call usually S_OK.
 *
 *	@devnote
 *		FUTURE: This code needs to be investigated for possible optimizations.
 *
 *		This code is assumes that all remeasuring needed has been done before 
 *		this routine is called.
 */
HRESULT CDisplay::TransparentHitTest(
	HDC		hdc,		//@parm DC for actual drawing
	LPCRECT prcClient,	//@parm Client rectangle for rendering
	POINT	pt,			//@parm Point to hittest against
	DWORD *	pHitResult)	//@parm	Result of the hit test see TXTHITRESULT 
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::TransparentHitTest");

	COLORREF	 crBackground = _ped->TxGetBackColor();
	HDC			 hdcMem = NULL;
	HRESULT		 hr = E_FAIL;
	int			 iRow;
	COffScreenDC osdc;
	RECT		 rcClient;
	RECT		 rcRender;
	RECT		 rcView;

	// Render view to a memory DC
	// Compute zero based client rectangle
	rcClient.left	= 0;
	rcClient.top	= 0;
	rcClient.right  = prcClient->right  - prcClient->left;
	rcClient.bottom = prcClient->bottom - prcClient->top;

	// Create a memory DC
	hdcMem = osdc.Init(hdc, rcClient.right, rcClient.bottom, crBackground);
	if(!hdcMem)
		goto Cleanup;

	// Initialize display
	osdc.FillBitmap(rcClient.bottom, crBackground);

	// Set the DC to the memory DC
	SetDC(hdcMem);

	// Get view rectangle that we need for rendering
  	GetViewRect(rcView, &rcClient);

	// Adjust point to be relative to the memory display
	pt.x -= prcClient->left;
	pt.y -= prcClient->top;

	// Initalize box around point. Note that we only really need to render
	// the data inside this box because this is the only area that we will
	// test.
	rcRender.top = pt.y - HIT_CLOSE_RECT_INC;
	if (rcRender.top < 0)
		rcRender.top = 0;

	rcRender.bottom = pt.y + HIT_CLOSE_RECT_INC;
	if (rcRender.bottom > rcClient.bottom)
		rcRender.bottom = rcClient.bottom;	

	rcRender.left = pt.x - HIT_CLOSE_RECT_INC;
	if (rcRender.left < 0)
		rcRender.left = 0;

	rcRender.right = pt.x + HIT_CLOSE_RECT_INC;
	if (rcRender.right > rcClient.right)
		rcRender.right = rcClient.right;

    // Now render
    Render(rcView, rcRender);

	// Hit test
	// Assume no hit
	*pHitResult = TXTHITRESULT_TRANSPARENT;

	// At this point we won't fail this
	hr = S_OK;

	// Is there an exact hit?
	if (GetPixel(hdcMem, pt.x, pt.y) != crBackground)
	{
		*pHitResult = TXTHITRESULT_HIT;
		goto Cleanup;
	}

	// Is it close? We determine closeness by putting
	// a 10 x 10 pixel box around the hit point and 
	// seeing if there is a hit there.

	// Loop examining each bit in the box to see if it is on.
	for (iRow = rcRender.top; iRow <= rcRender.bottom; iRow++)
	{
		for (int iCol = rcRender.left; iCol <= rcRender.right; iCol++)
		{
			if (GetPixel(hdcMem, iCol, iRow) != crBackground)
			{
				*pHitResult = TXTHITRESULT_CLOSE;
				goto Cleanup;
			}
		}
	}

Cleanup:
	ResetDC();
	return hr;
}

//============================ ITxNotify Interface ==========================
/*
 *	CDisplay::OnPreReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax)
 *
 *	@mfunc
 *		Preprocess a change in backing store
 *
 *	@devnote
 *		This display doesn't care about before changes
 */
void CDisplay::OnPreReplaceRange( 
	LONG cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG cchDel,		//@parm Count of chars after cp that are deleted
	LONG cchNew,		//@parm Count of chars inserted after cp
	LONG cpFormatMin,	//@parm cpMin  for a formatting change
	LONG cpFormatMax)	//@parm cpMost for a formatting change
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::OnPreReplaceRange");

	// Display doesn't care about before the fact
}

/*
 *	CDisplay::OnPostReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax)
 *
 *	@mfunc
 *		Process a change to the backing store as it applies to the display
 */
void CDisplay::OnPostReplaceRange( 
	LONG cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG cchDel,		//@parm Count of chars after cp that are deleted
	LONG cchNew,		//@parm Count of chars inserted after cp
	LONG cpFormatMin,	//@parm cpMin  for a formatting change
	LONG cpFormatMax)	//@parm cpMost for a formatting change
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::OnPostReplaceRange");

	// There is one NO-OP's for the display:
	// currently loading a file.
	//
	// We NO-OP the load case because loading an RTF file can consist
	// of potentially very many small actions as we peice together
	// the various bits of formatted text.  Once done, the load code
	// will go through and do an update-all to the display.
	Assert (cp != CONVERT_TO_PLAIN);			// Handled with PreReplace notifications

	// Figure out range needed to update
	LONG cpNew = min(cp, cpFormatMin);

	if(CP_INFINITE == cpNew)
	{
		// If both cp's are infinite we don't need to bother with
		// this operation.
		return;
	}

	if(!_ped->_fInPlaceActive)
    {
        // If not active, just invalidate everything
        InvalidateRecalc();
        _ped->TxInvalidateRect(NULL, FALSE);
		_ped->TxUpdateWindow();
        return;
    }

	// Adjust cp for further calculations
	if(CP_INFINITE == cp)
		cp = 0;

	// find the new max end of the original region.
	LONG	cpForEnd = max( (cp + cchDel), cpFormatMax);

	// Number of deleted characters is the difference between the previous two
	LONG cchDelForDisplay = cpForEnd - cpNew;

	// The number deleted is simply number of new characters adjusted by
	// the change in the number of characters.
	LONG cchNewForDisplay = cchDelForDisplay + (cchNew - cchDel);

#ifdef LINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif

	if(_padc)
	{
		// Display is frozen so accumulate the change instead of actually
		// displaying it on the screen.
		_padc->UpdateRecalcRegion(cpNew, cchDelForDisplay, cchNewForDisplay);
		return;
	}		

	// Tell display to update
	CRchTxtPtr tp(_ped, cpNew);

	UpdateView(tp, cchDelForDisplay, cchNewForDisplay);
}

/*
 *	CDisplay::SetWordWrap(fWordWrap)
 *
 *	@mfunc
 *		Sets the no wrap flag
 *
 *	@devnote
 *		We will always allow the property to be set but we will not
 *		necessarily pay attention. In other words, word wrap has no
 *		effect on a single line edit control.
 */
void CDisplay::SetWordWrap(
	BOOL fWordWrap)		//@param TRUE - turn on word wrap.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetWordWrap");

	AssertSz((fWordWrap == TRUE) ||	(fWordWrap == FALSE),
		"CDisplay::SetWordWrap bad input flag");

	// Set nowrap to whatever is coming in.
	_fWordWrap = fWordWrap;
}

/*
 *	CDisplay::GetWordWrap()
 *
 *	@mfunc
 *		Return state of word wrap property
 *
 *	@rdesc
 *		TRUE - word wrap is on
 *		FALSE - word wrap is is off.
 *
 *	@devnote
 *		Derived classes such as CDisplaySL override this.
 */
BOOL CDisplay::GetWordWrap() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetWordWrap");

	return _fWordWrap;
}

/*
 *	CDisplay::GetViewDim()
 *
 *	@mfunc
 *		Return the height & width of view adjusted for view inset
 */
void CDisplay::GetViewDim(
	LONG& widthView,		//@parm Where to return the width
	LONG& heightView)		//@parm Where to return the height
{
	// We build a client rectangle to take advantage of GetViewRect routine
	// which really does all the work for us.
	RECT rcClient;
	rcClient.left = 0;
	rcClient.top = 0;
	rcClient.right = widthView;
	rcClient.bottom = heightView;

	// Take into account inset and selection bar. The parameters here are a bit
	// of a trick. The second parameter gets copied into the first and since
	// we don't need the original client rect we save a rect off the stack.
	GetViewRect(rcClient, &rcClient);

	widthView = rcClient.right - rcClient.left;
	heightView = rcClient.bottom - rcClient.top;
}

/*
 *	CDisplay::SaveUpdateCaret (fScrollIntoView)
 *
 *	@mfunc	Save UpdateCaret parameter so update caret can be called
 *			after the display is thawed.
 *
 *	@rdesc	None.
 *
 *	@devnote
 *			This should only be called if IsFrozen is true.
 */
void CDisplay::SaveUpdateCaret(
	BOOL fScrollIntoView)
{
#ifdef DEBUG
	if (_padc == NULL)
	{
		TRACEERRORSZ("CDisplay::SaveUpdateCaret called on thawed display");
	}
#endif // DEBUG
	if(_padc)
		_padc->SaveUpdateCaret(fScrollIntoView);
}

/*
 *	CDisplay::SetNeedRedisplayOnThaw
 *
 *	@mfunc
 *		Automatically redisplay control on thaw
 */
void CDisplay::SetNeedRedisplayOnThaw(BOOL fNeedRedisplay)
{
	Assert (_padc);
	_padc->SetNeedRedisplayOnThaw(fNeedRedisplay);
}

/*
 *	CDisplay::Freeze
 *
 *	@mfunc
 *		Prevent any updates from occuring in the display
 */
void CDisplay::Freeze()
{
	if(NULL == _padc)
	{
		// Allocate object to keep track of changes
		_padc = new CAccumDisplayChanges();

		// We can now return because the accum object has a reference
		// or the memory allocation failed. If the memory allocation 
		// failed, This really isn't a catastrophe because all it means 
		// is that things will get displayed ugly temporarily, so we can 
		// pretend it didn't happen.
		return;
	}

	// Tell object that an additional freeze has occurred.
	_padc->AddRef();
}

/*
 *	CDisplay::Thaw()
 *
 *	@mfunc
 *		If this is the last thaw, then cause display to be updated.
 *
 */
void CDisplay::Thaw()
{
	BOOL fUpdateCaret, fScrollIntoView, fNeedRedisplay;
	LONG cp, cchNew, cchDel;
	CTxtSelection *psel;

	if(_padc)
	{
		// Release reference to accum object
		if(_padc->Release() == 0)
		{
			// Last thaw so we need to update display

			// Get the changes
			_padc->GetUpdateRegion(&cp, &cchDel, &cchNew, 
				&fUpdateCaret, &fScrollIntoView, &fNeedRedisplay);

			// Clear the object - note we do this before
			// the update just on the off chance that
			// a new freeze manages to get in during the 
			// update of the display.
			delete _padc;
			_padc = NULL;

			if(cp != CP_INFINITE)
			{
				// Display changed
				if(!_ped->fInplaceActive())
				{
					// Are not inplace active so we need to put this operation
					// off till a more appropriate time.

					InvalidateRecalc();
					_ped->TxInvalidateRect(NULL, FALSE);
					_ped->TxUpdateWindow();
					return;
				}
				// Update display
				CRchTxtPtr rtp(_ped, cp);
				if(!UpdateView(rtp, cchDel, cchNew))
					return;							// Update failed
			}

			if (fNeedRedisplay)
				_ped->TxInvalidateRect(NULL, FALSE);

			// Did selection request a caret update?
			if(fUpdateCaret && _ped->fInplaceActive())
			{
				psel = _ped->GetSel();
				psel->UpdateCaret(fScrollIntoView);
			}
		}
	}
}

/*
 *	CDisplay::IsPrinter
 *
 *	@mfunc
 *		Returns whether this is a printer
 *
 *	@rdesc
 *		TRUE - is a display to a printer
 *		FALSE - is not a display to a printer
 *
 *	@devnote
 *		No display except a display	CDisplayPrinter should
 *		ever have a chance to return TRUE to this function.
 */
BOOL CDisplay::IsPrinter() const
{
	return FALSE;
}

/*
 *	CDisplay::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie
 */
void CDisplay::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CDisplay::Zombie");

}

/*
 *	CDisplay::IsHScrollEnabled ()
 *
 *	@mfunc
 *		Return whether horizontal scroll bar is enabled
 *
 *	@rdesc
 *		TRUE - yes
 *		FALSE - no
 *
 *	@devnote
 *		The reason for this routine is that _fHScrollEnabled means
 *		to scroll text and can be set even if there is no scroll
 *		bar. Therefore, we need to look at the host properties
 *		as well to tell use whether this means there are scroll
 *		bars.
 */
BOOL CDisplay::IsHScrollEnabled()	  
{
	return _fHScrollEnabled && ((_ped->TxGetScrollBars() & WS_HSCROLL) != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\dispprt.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	dispprt.cpp	-- Special logic for printer object |
 *  
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Jon Matousek
 */
#include "_common.h"
#include "_dispprt.h"
#include "_edit.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_select.h"

#define PARA_NUMBER_NOT_SET ((WORD) -1)

ASSERTDATA

/*
 *	CDisplayPrinter::CDisplayPrinter(ped, hdc, x, y, prtcon)
 *
 *	@mfunc
 *		Contructs a object that can be used to print a text control
 */
CDisplayPrinter::CDisplayPrinter (
	CTxtEdit* ped, 
	HDC hdc, 			//@parm HDC for drawing
	LONG x, 			//@parm Max width to draw
	LONG y, 			//@parm Max height to draw
	SPrintControl prtcon//@parm Special controls for this print object
)	
		: CDisplayML( ped ), _prtcon(prtcon)
{
	TRACEBEGIN(TRCSUBSYSPRT, TRCSCOPEINTERN, "CDisplayPrinter::CDisplayPrinter");

	Assert ( hdc );

	_fNoUpdateView = TRUE;
	_xWidthMax  = x;
	_yHeightMax = y;
	_wNumber = PARA_NUMBER_NOT_SET;
}

/*
 *	CDisplayPrinter::SetPrintDimensions(prc)
 *
 *	@mfunc
 *		Set area to print.
 */
void CDisplayPrinter::SetPrintDimensions(
	RECT *prc)			//@parm dimensions of current area to print to.
{
	_xWidthMax  = prc->right - prc->left;
	_yHeightMax = prc->bottom - prc->top;
}

/*
 *	CDisplayPrinter::FormatRange(cpFirst, cpMost)
 *
 *	@mfunc
 *		Format a range of text into this display and used only for printing.
 *
 *	@rdesc
 *		actual end of range position (updated)	
 */
LONG CDisplayPrinter::FormatRange(
	LONG cpFirst, 		//@parm Start of text range
	LONG cpMost,		//@parm End of text range
	BOOL fWidowOrphanControl)	//@parm If TRUE, suppress widow/orphan
{
	TRACEBEGIN(TRCSUBSYSPRT, TRCSCOPEINTERN, "CDisplayPrinter::FormatRange");

	LONG		cch;
	WCHAR		ch;
	BOOL		fFirstInPara = TRUE;
	CLine		liTarget;
	CLine *		pliNew = NULL;
	LONG		yHeightRnd;
	LONG		yHeightTgt;
	BOOL		fBindCp = FALSE;
	const CDevDesc *pdd = GetDdTarget() ? GetDdTarget() : this;

	// Set client height for zooming
	_yHeightClient = this->LYtoDY(_yHeightMax);

	// Set maximum in terms of target DC.
	LONG	yMax = pdd->LYtoDY(_yHeightMax);

	if(cpMost < 0)
		cpMost = _ped->GetTextLength();

	CMeasurer me(this);
	
	cpFirst = me.SetCp(cpFirst);		// Validate cpFirst while setting me
	ch = me.GetChar();

	// TODO: COMPATIBILITY ISSUE:  Richedit 1.0 adjusted to before a
	// CRLF/CRCRLF boundary.  if_ped->fUseCRLF(), adjust accordingly

	if(fBindCp)
	{
		cpFirst = me.GetCp();
		me._rpCF.BindToCp(cpFirst);
		me._rpPF.BindToCp(cpFirst);
	}

	_cpMin = cpFirst;
	_cpFirstVisible = cpFirst;
	
	yHeightTgt = 0;
	yHeightRnd = 0;
	if(me.GetCp())
		fFirstInPara = me._rpTX.IsAfterEOP();

	// Clear line CArray
	Clear(AF_DELETEMEM);

	// Assume that we will break on words
	UINT uiBreakAtWord = MEASURE_BREAKATWORD;

	if(_prtcon._fPrintFromDraw)
	{
		// This is from Draw so we want to take inset into account
		LONG xWidthView = _xWidthMax;

		GetViewDim(xWidthView, yMax);
		_xWidthView = (SHORT) xWidthView;

		// Restore client height
		_yHeightClient = this->LYtoDY(_yHeightMax);
	}
	else			// Message-based printing always does word wrap
		SetWordWrap(TRUE);

	// Set paragraph numbering. This is a fairly difficult problem
	// because printing can start anywhere and end anywhere. However,
	// most printing will involve a contiguous range of pages. Therefore,
	// we cache the paragraph number and the cp for that number and
	// only resort to looking in the line array if the cached information
	// has become invalid.
	if ((PARA_NUMBER_NOT_SET == _wNumber) || (cpFirst != _cpForNumber))
	{
		CLinePtr rp(_ped->_pdp);
		rp.RpSetCp(cpFirst, FALSE);
		_wNumber = rp.GetNumber();
		_cpForNumber = cpFirst;
	}
	
	me.SetNumber(_wNumber);
	
	while(me.GetCp() < cpMost)
	{
		// Add one new line
		pliNew = Add(1, NULL);
		if(!pliNew)
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			goto err;
		}

		// Store the current number of the paragraph. We do it
		// here because we have to measure and that potentially
		// updates the number of the paragraph in the measurer
		// for a line that might not be on the page.
		_wNumber = me.GetNumber();

		// Stuff some text into this new line
		if(!pliNew->Measure(me, cpMost - me.GetCp(), -1,
				uiBreakAtWord | (fFirstInPara ? MEASURE_FIRSTINPARA : 0), 
				&liTarget))
		{
			Assert(FALSE);
			goto err;
		}

		// Note, we always put at least one line on a page. Otherwise, if the 
		// first line is too big, we would cause our client to infinite loop
		// because we would never advance the print cp.
		if(_cel > 1 && (yHeightTgt + liTarget._yHeight > yMax))
		{
			cch = -pliNew->_cch;		// Bump last line to next page
			_cel--;						// One less line

#if 0
			CLine *pli = pliNew - 1;	// Point at previous line

			// If this line and the previous one are in the same para and
			// either this one ends in an EOP or the previous one starts
			// a para, bump both to following page (widow/orphan)
			if(fWidowOrphanControl)
			{
				if(_cel > 1 && !fFirstInPara &&
				   (pli->_bFlags & fliFirstInPara || (pliNew->_bFlags & fliHasEOP)))
				{
					cch -= pli->_cch;
					_cel--;					// One less line
					pli--;					// Point to previous line
				}
				if(_cel > 1 && pli->_nHeading)
				{							// Don't end page with a heading
					cch -= pli->_cch;
					_cel--;					// One less line
				}
			}
#endif
			me.Advance(cch);			// Move back over lines discarded
			break;
		}

		fFirstInPara = (pliNew->_bFlags & fliHasEOP);

		yHeightTgt += liTarget._yHeight;
		yHeightRnd += pliNew->_yHeight;
		if (me.GetPrevChar() == FF)
			break;
	}

	// If there was no text, then add a single blank line
	if(!pliNew)
	{
		pliNew = Add(1, NULL);
		if(!pliNew)
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			goto err;
		}
		me.NewLine(fFirstInPara);
		*pliNew = me._li;
	}

	// Update display height
	_yHeight = yHeightRnd;

	// Update display width
	_xWidth = CalcDisplayWidth();

	cpMost = me.GetCp();
	_cpCalcMax = cpMost;
	_yCalcMax = _yHeight;

	// Update paragraph caching information.
	_cpForNumber = cpMost;

	return cpMost;

err:
	Clear(AF_DELETEMEM);
	_xWidth = 0;
	_yHeight = 0;
	return -1;
}

/*
 *	CDisplayPrinter::GetNaturalSize(hdcDraw, hicTarget, dwMode, pwidth, pheight)
 *
 *	@mfunc
 *		Recalculate display to input width & height for TXTNS_FITTOCONTENT.
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 *
 *	@devnote
 *		This assumes that FormatRange was called just prior to this.
 */
HRESULT	CDisplayPrinter::GetNaturalSize(
	HDC hdcDraw,		//@parm DC for drawing
	HDC hicTarget,		//@parm DC for information
	DWORD dwMode,		//@parm Type of natural size required
	LONG *pwidth,		//@parm Width in device units to use for fitting 
	LONG *pheight)		//@parm Height in device units to use for fitting
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayPrinter::GetNaturalSize");

	*pwidth = _xWidth;
	*pheight = _yHeight;
	return S_OK;
}

/*
 *	CDisplayPrinter::IsPrinter()
 *
 *	@mfunc
 *		Returns whether this is a printer
 *
 *	@rdesc
 *		TRUE - is a display to a printer
 *		FALSE - is not a display to a printer
 */
BOOL CDisplayPrinter::IsPrinter() const
{
	AssertSz(_hdc, "CDisplayPrinter::IsPrinter no hdc set");
	
	return GetDeviceCaps(_hdc, TECHNOLOGY) == DT_RASPRINTER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\dispml.cpp ===
/*  
 *	@doc INTERNAL
 *
 *	@module	DISPML.CPP -- CDisplayML class |
 *
 *		This is the Multi-line display engine.  See disp.c for the base class
 *		methods and dispsl.c for the single-line display engine.
 *	
 *	Owner:<nl>
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *		Rick Sailor (for most of RE 2.0)
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_dispml.h"
#include "_edit.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_select.h"
#include "_dfreeze.h"

/*
#include "icecap.h"

class CCapProfile
{
public:
	CCapProfile() { StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID); }
	~CCapProfile() { StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID); }
};
*/
ASSERTDATA

//
//	Invariant support
//
#define DEBUG_CLASSNAME	CDisplayML
#include "_invar.h"

// Timer tick counts for background task
#define cmsecBgndInterval 	300
#define cmsecBgndBusy 		100

// Lines ahead
const LONG cExtraBeforeLazy = 60;

// If we need to calc at least this many characters, then put up a wait
// cursor.  NB!  4096 is not a measured number; it just seemed like a good
// one.
#define NUMCHARFORWAITCURSOR	4096	

#ifndef DEBUG
#define CheckView()
#define	CheckLineArray()
#endif
	

// ===========================  CDisplayML  =====================================================

#ifdef DEBUG
/*
 *	CDisplayML::Invariant
 *
 *	@mfunc	Make sure the display is in a valid state
 *
 *	@rdesc	TRUE if the tests succeeded, FALSE otherwise
 */
BOOL CDisplayML::Invariant(void) const
{
	CDisplay::Invariant();

	return TRUE;
}
#endif // DEBUG

/*
 *	CDisplayML::CalcScrollHeight()
 *
 *	@mfunc	
 *		Calculate the maximum Y scroll position.
 *
 *	@rdesc
 *		Maximum possible scrolling position
 *
 *	@devnote
 *		This routine exists because plain text controls do not have
 *		the auto-EOP and so the scroll height is different than
 *		the height of the control if the text ends in an EOP type
 *		character.
 */
LONG CDisplayML::CalcScrollHeight(LONG yHeight) const
{
	// The max scroll height for plain text controls is calculated
	// differently because they don't have an automatic EOP character.
	if(!_ped->IsRich() && Count())
	{
		// If last character is an EOP, bump scroll height
		CLine *lp = Elem(Count() - 1);	// Get last line in array
		if(lp->_cchEOP)
			yHeight += lp->GetHeight();
	}
	return yHeight;
}

/*
 *	CDisplayML::GetMaxYScroll()
 *
 *	@mfunc	
 *		Calculate the maximum Y scroll position.
 *
 *	@rdesc
 *		Maximum possible scrolling position
 *
 *	@devnote
 *		This routine exists because we may have to come back and modify this 
 *		calculation for 1.0 compatibility. If we do, this routine only needs
 *		to be changed in one place rather than the three at which it is used.
 *
 */
inline LONG CDisplayML::GetMaxYScroll() const
{
	// The following code is turn off because we don't want to support 
	// 1.0 mode unless someone complained about it.  
#if 0		
 	if (_ped->Get10Mode())
	{
		// Ensure last line is always visible
		// (use dy as temp to calculate max scroll)
		yScroll = Elem(max(0, Count() - 1))->_yHeight;

		if(yScroll > _yHeightView)
			yScroll = _yHeightView;

		yScroll = _yHeight - yScroll;
	}
#endif //0

	return CalcScrollHeight(_yHeight);
}

/*
 *	CDisplayML::ConvertScrollToYPos()
 *
 *	@mfunc	
 *		Calculate the real scroll position from the scroll position
 *
 *	@rdesc
 *		Y position from scroll
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the Y position
 *		gets greater than that.
 */
LONG CDisplayML::ConvertScrollToYPos(
	LONG yPos)		//@parm Scroll position 
{
	// Get maximum scroll range
	LONG yRange = GetMaxYScroll();

	// Has maximum scroll range exceeded 16-bits?
	if(yRange >= _UI16_MAX)
	{
		// Yes - Extrapolate to "real" yPos		
		yPos = MulDiv(yPos, yRange, _UI16_MAX);
	}
	return yPos;
}

/*
 *	CDisplayML::ConvertYPosToScrollPos()
 *
 *	@mfunc	
 *		Calculate the scroll position from the Y position in the document.
 *
 *	@rdesc
 *		Scroll position from Y position
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the Y position
 *		gets greater than that.
 *
 */
inline LONG CDisplayML::ConvertYPosToScrollPos(
	LONG yPos)		//@parm Y position in document
{
	// Get maximum scroll range
	LONG yRange = GetMaxYScroll();

	// Has maximum scroll range exceeded 16-bits?
	if(yRange >= _UI16_MAX)
	{
		// Yes - Extrapolate to "real" yPos		
		yPos = MulDiv(yPos, _UI16_MAX, yRange);
	}
	return yPos;
}

CDisplayML::CDisplayML (CTxtEdit* ped)
  : CDisplay (ped), _pddTarget(NULL)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CDisplayML");

	Assert(!_xWidthMax && !_yHeightMax);

	_fMultiLine = TRUE;
}

CDisplayML::~CDisplayML()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::~CDisplayML");

	delete _pddTarget;
}

/*
 *	CDisplayML::Init()
 *
 *	@mfunc	
 *		Init this display for the screen
 *
 *	@rdesc
 *		TRUE iff initialization succeeded
 */
BOOL CDisplayML::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::Init");

	// Initialize our base class
	if(!CDisplay::Init())
		return FALSE;

	AssertSz(_ped, "CDisplayML::Init(): _ped not initialized in display");
	// Verify allocation zeroed memory out
	Assert(!_yCalcMax && !_xWidth && !_yHeight && !_cpMin);
	Assert(!_fBgndRecalc && !_fVScrollEnabled && !_fHScrollEnabled);

	// The printer view is not main, therefore we do this to make
	// sure scroll bars are not created for print views.
	DWORD dwScrollBars = _ped->TxGetScrollBars();

	if(IsMain() && (dwScrollBars & ES_DISABLENOSCROLL))
	{
		if(dwScrollBars & WS_VSCROLL)
		{
			// This causes wlm to assert on the mac. something about 
			// scrollbar being disabled
			_ped->TxSetScrollRange (SB_VERT, 0, 1, TRUE);
			_ped->TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
		}

		// Set horizontal scroll range and pos
		// ??? - CF need fixing for windowless case
		if(dwScrollBars & WS_HSCROLL) 
		{
			_ped->TxSetScrollRange (SB_HORZ, 0, 1, TRUE);
			_ped->TxEnableScrollBar(SB_HORZ, ESB_DISABLE_BOTH);
		}
	}

	SetWordWrap(_ped->TxGetWordWrap());
	_cpFirstVisible = _cpMin;
	
	Assert(!_xScroll && !_yScroll && !_iliFirstVisible &&
		   !_cpFirstVisible && !_dyFirstVisible);

    _TEST_INVARIANT_

	return TRUE;
}


//================================  Device drivers  ===================================
/*
 *	CDisplayML::SetMainTargetDC(hdc, xWidthMax)
 *
 *	@mfunc
 *		Sets a target device for this display and updates view 
 *
 *	@devnote
 *		Target device can't be a metafile (can get char width out of a 
 *		metafile)
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::SetMainTargetDC (
	HDC hdc,			//@parm Target DC, NULL for same as rendering device
	LONG xWidthMax)		//@parm Max line width (not used for screen)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::SetMainTargetDC");

	if(SetTargetDC(hdc))
	{
		// This is here because this is what RE 1.0 did. 
		SetWordWrap(hdc || !xWidthMax);

		// If xWidthMax is greater than zero, then the caller is
		// trying to set the maximum width of the window (for measuring,
		// line breaking, etc.)  However,in order to make our measuring
		// algorithms more reasonable, we force the max size to be
		// *at least* as wide as the width of a character.
		// Note that xWidthMax = 0 means use the view rect width
		_xWidthMax = (xWidthMax <= 0) ? 0 : max(DXtoLX(GetXWidthSys()), 
												xWidthMax);
		// Need to do a full recalc. If it fails, it fails, the lines are
		// left in a reasonable state. No need to call WaitForRecalc()
		// because UpdateView() starts at position zero and we're always
		// calc'd up to there
		CDisplay::UpdateView();

		// Caret/selection has most likely moved
		CTxtSelection *psel = _ped->GetSelNC();
		if(psel) 
			psel->UpdateCaret(FALSE);
		return TRUE;
	}
	return FALSE;
}

// Useful for both main and printing devices. jonmat 6/08/1995
BOOL CDisplayML::SetTargetDC( HDC hdc, LONG dxpInch, LONG dypInch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::SetTargetDC");

	CDevDesc *pddTarget = NULL;

	// Don't allow metafiles to be set as the target device
	if(hdc && GetDeviceCaps(hdc, TECHNOLOGY) == DT_METAFILE)
		return FALSE;

	if(hdc)
	{
		// Allocate device first to see if we can. We don't want to change
		// our state if this is going to fail.
		pddTarget = new CDevDesc(_ped);
		if(!pddTarget)
			return FALSE;				// We couldn't so we are done
	}

	// Remove any cached information for the old target device
	if(_pddTarget)
	{
		delete _pddTarget;
		_pddTarget = NULL;
	}
	if(hdc)
	{
		_pddTarget = pddTarget;			// Update device because we have one
		_pddTarget->SetDC(hdc, dxpInch, dypInch);
	}
	return TRUE;
}

//=================================  Line recalc  ==============================
/*
 *	CDisplayML::RecalcScrollBars()
 *
 *	@mfunc
 *		Recalculate the scroll bars if the view has changed.
 *
 *
 *	@devnote	There is a possibility of recursion here, so we
 *				need to protect ourselves.
 *
 *	To visualize this, consider two types of characters, 'a' characters 
 *	which are small in height and 'A' 's which are really tall, but the same 
 *	width as an 'a'. So if I have
 *
 *	a a A						<nl>
 *	A							<nl>
 *
 *	I'll get a calced size that's basically 2 * heightof(A).
 *	With a scrollbar, this could wordwrap to 
 *
 *	a a							<nl>
 *	A A							<nl>
 *
 *	which is of calced size heightof(A) + heightof(a); this is
 *	obviously less than the height in the first case.
 */
void CDisplayML::RecalcScrollBars()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcScrollBars");

	if(_fViewChanged)
	{
  		_fViewChanged = FALSE;
		UpdateScrollBar(SB_VERT, TRUE);
    	UpdateScrollBar(SB_HORZ, TRUE);
    }
}

/*
 *	CDisplayML::RecalcLines(fWait)
 *
 *	@mfunc
 *		Recalc all line breaks. 
 *		This method does a lazy calc after the last visible line
 *		except for a bottomless control
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::RecalcLines (
	BOOL fWait)		//@parm Recalc lines down to _cpWait/_yWait; then be lazy
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcLines");

	LONG		cliWait = cExtraBeforeLazy;			// Extra lines before being lazy
	BOOL		fDone = TRUE;
	BOOL		fFirstInPara = TRUE;
	CLine *		pliNew = NULL;
	LONG		xWidth;
	LONG		yHeight = 0;
    LONG        cchText = _ped->GetTextLength();
	BOOL		fWaitingForFirstVisible = TRUE;
	LONG		yHeightView = _yHeightView;
	LONG		yHeightScrollOld = GetMaxYScroll();
	LONG		yHeightScrollNew;

	Remove(0, -1);							// Remove all old lines from *this
	_yCalcMax = 0;							// Set both maxes to start of text
	_cpCalcMax = 0;

	// Don't stop at bottom of view if we're bottomless and active
	if(!_ped->TxGetAutoSize() && IsActive())
	{
		// Be lazy - don't bother going past visible portion
		_cpWait = -1;
		_yWait = -1;
		fWait = TRUE;
	}

	// Init measurer at cp = 0
	CMeasurer me(this);
	me.SetNumber(0);
 	
	// The following loop generates new lines
	while(me.GetCp() < cchText)
	{
		// Add one new line
		pliNew = Add(1, NULL);
		if (!pliNew)
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			TRACEWARNSZ("Out of memory Recalc'ing lines");
			goto err;
		}

		// Stuff text into new line
		UINT uiFlags = MEASURE_BREAKATWORD | 
						(fFirstInPara ? MEASURE_FIRSTINPARA : 0);

    	Tracef(TRCSEVINFO, "Measuring new line from cp = %d", me.GetCp());

		if(!pliNew->Measure(me, -1, -1, uiFlags))
		{
			Assert(FALSE);
			goto err;
		}

		fFirstInPara = pliNew->_bFlags & fliHasEOP;
		yHeight += pliNew->GetHeight();
		_cpCalcMax = me.GetCp();

		if(fWait)
		{
			// Do we want to do a background recalc? - the answer is yes if
			// three things are true: (1) We have recalc'd beyond the old first
			// visible character, (2) We have recalc'd beyond the visible 
			// portion of the screen and (3) we have gone beyond the next
			// cExtraBeforeLazy lines to make page down go faster.

			if(fWaitingForFirstVisible)
			{
				if(me.GetCp() > _cpFirstVisible)
				{
					_yWait = yHeight + yHeightView;
					fWaitingForFirstVisible = FALSE;
				}
			}
			else if(yHeight > _yWait && cliWait-- <= 0)
			{
				fDone = FALSE;
				break;
			}
		}
	}

	_yCalcMax = yHeight;
	_fRecalcDone = fDone;
    _fNeedRecalc = FALSE;
	yHeightScrollNew = CalcScrollHeight(yHeight);

	if(fDone && (yHeight != _yHeight || yHeightScrollNew != yHeightScrollOld)
		|| yHeightScrollNew > yHeightScrollOld)
	{
		_fViewChanged = TRUE;
	}

	_yHeight = yHeight;
	xWidth = CalcDisplayWidth();
    if(fDone && xWidth != _xWidth || xWidth > _xWidth)
    {
        _xWidth = xWidth;
		_fViewChanged = TRUE;
    }    

	Tracef(TRCSEVINFO, "CDisplayML::RecalcLine() - Done. Recalced down to line #%d", Count());

	if(!fDone)						// if not done, do rest in background
		fDone = StartBackgroundRecalc();

	if(fDone)
	{
		_yWait = -1;
		_cpWait = -1;
		CheckLineArray();
		_fLineRecalcErr = FALSE;
	}

#ifdef DEBUG
	if( 1 )
    {
		_TEST_INVARIANT_
	}
	//Array memory allocation tracking
	{
	void **pv = (void**)((char*)this + sizeof(CDisplay));
	PvSet(*pv);
	}
#endif

	return TRUE;

err:
	TRACEERRORSZ("CDisplayML::RecalcLines() failed");

	if(!_fLineRecalcErr)
	{
		_cpCalcMax = me.GetCp();
		_yCalcMax = yHeight;
		_fLineRecalcErr = TRUE;
		_ped->GetCallMgr()->SetOutOfMemory();
		_fLineRecalcErr = FALSE;			//  fix up CArray & bail
	}
	return FALSE;
}

/*
 *	CDisplayML::RecalcLines(rtp, cchOld, cchNew, fBackground, fWait, pled)
 *
 *	@mfunc
 *		Recompute line breaks after text modification
 *
 *	@rdesc
 *		TRUE if success
 *
 *	@devnote
 *		Most people call this the trickiest piece of code in RichEdit...
 */						     
BOOL CDisplayML::RecalcLines (
	const CRchTxtPtr &rtp,	//@parm Where change happened
	LONG cchOld,			//@parm Count of chars deleted
	LONG cchNew,			//@parm Count of chars added
	BOOL fBackground,		//@parm This method called as background process
	BOOL fWait,				//@parm Recalc lines down to _cpWait/_yWait; then be lazy
	CLed *pled)				//@parm Returns edit impact on lines (can be NULL)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcLines");

	LONG		cchEdit;
	LONG		cchSkip;
	LONG		cliBackedUp = 0;
	LONG		cliWait = cExtraBeforeLazy;	
	BOOL		fDone = TRUE;
	BOOL		fFirstInPara = TRUE;
	LONG		ili;
	CLed		led;
	LONG		lT;							// long Temporary
	CLine *		pliNew;
	CLinePtr	rpOld(this);
	LONG		xWidth;
	LONG		yHeight;
	LONG		yHeightPrev = 0;
    LONG        cchText = _ped->GetTextLength();
    UINT        uiFlags;
	BOOL 		fReplaceResult;
	BOOL		fTryForMatch = TRUE;
	LONG		yHeightScrollOld = GetMaxYScroll();
	LONG		yHeightScrollNew;
	WORD		wNumber = 0;
	CLineArray	rgliNew;
	DWORD		dwBgndTickMax = fBackground ? GetTickCount() + cmsecBgndBusy : 0;

	if(!pled)
		pled = &led;

#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	LONG cp = rtp.GetCp();

	if(cp > _cpCalcMax)
		Tracef(TRCSEVERR, "rtp %ld, _cpCalcMax %ld", cp, _cpCalcMax);

	AssertSz(cp <= _cpCalcMax, 
		"CDisplayML::RecalcLines Caller didn't setup RecalcLines()");

	AssertSz(!(fWait && fBackground),
		"CDisplayML::RecalcLines wait and background both true");

	AssertSz(!(fWait && (-1 == _cpWait) && (-1 == _yWait)),
		"CDisplayML::RecalcLines background recalc parms invalid");
#endif

	// We will not use background recalc if this is already a background recalc,
	// or if the control is not active or if this is an auto sized control.
	if(!IsActive() || _ped->TxGetAutoSize())
		fWait = FALSE;

	// Init line pointer on old CLineArray and backup to start of line
	rpOld.RpSetCp(rtp.GetCp(), FALSE);
	cchSkip = rpOld.RpGetIch();
	rpOld.RpAdvanceCp(-cchSkip);			// Point rp at 1st char in line

	ili = rpOld;							// Save line # at change for
	if(ili && (IsInOutlineView() ||			//  numbering. Back up if not
		rtp.GetPF()->IsListNumbered()))		//  first number in list or if
	{										//  in OutlineView (Outline
		ili--;								//  symbol may change)
	}

	// Back up at least one line in case we can now fit more on it
	// If on a line border, e.g., just inserted an EOP, backup 2; else 1
	lT = !cchSkip + 1;

	while(lT-- > 0 && rpOld > 0 && (!rpOld[-1]._cchEOP || ili < rpOld))
	{
		cliBackedUp++;
		rpOld--;
		cchSkip += rpOld->_cch;
	}

	// Init measurer at rtp
	CMeasurer me(this, rtp);

	me.Advance(-cchSkip);					// Point at start of text to measure
	cchEdit = cchNew + cchSkip;				// Number of chars affected by edit
	me.SetNumber(rpOld.GetNumber());		// Initialize list number
	
	// Determine whether we're on first line of paragraph
	if(rpOld > 0)
	{
		fFirstInPara = rpOld[-1]._bFlags & fliHasEOP;
	}

	yHeight = YposFromLine(rpOld);

	// Update first-affected and pre-edit-match lines in pled
	pled->_iliFirst = rpOld;
	pled->_cpFirst	= pled->_cpMatchOld	= me.GetCp();
	pled->_yFirst	= pled->_yMatchOld	= yHeight;
	AssertSz(pled->_yFirst >= 0, "CDisplayML::RecalcLines _yFirst < 0");
	
	Tracef(TRCSEVINFO, "Start recalcing from line #%d, cp=%d", pled->_iliFirst, pled->_cpFirst);

	// In case of error, set both maxes to where we are now
	_yCalcMax = yHeight;
	_cpCalcMax = me.GetCp();

	// If we are past the requested area to recalc and background recalc is
	// allowed, then just go directly to background recalc. If there is no
	// height, we just go a head and calculate some lines anyway. This
	// prevents any weird background recalcs from occuring when it is
	// unnecessary to go into background recalc.
	if(fWait && _yWait > 0 && yHeight > _yWait && me.GetCp() > _cpWait)
	{
		_yHeight = yHeight;
		rpOld.Remove(-1);	// Remove all old lines from here on
		StartBackgroundRecalc();		// Start up the background recalc		
		pled->SetMax(this);
		return TRUE;
	}

    pliNew = NULL;

	// The following loop generates new lines for each line we backed
	// up over and for lines directly affected by edit
	while(cchEdit > 0)
	{
		pliNew = rgliNew.Add(1, NULL);		// Add one new line
		if (!pliNew)
		{
			TRACEWARNSZ("CDisplayML::RecalcLines unable to alloc additional CLine in CLineArray");
			goto errspace;
		}

		// Can't reuse old results if we've got a target device
		// For SPEED: it'd be nice to cache a few values when we do have a
		// target device - a good caching heuristic could halve the measuring
		const LONG cchNonWhite = rpOld.IsValid()
							   ? rpOld->_cch - rpOld->_cchWhite
							   : 0;
		uiFlags = MEASURE_BREAKATWORD | (fFirstInPara ? MEASURE_FIRSTINPARA : 0);

		if (cchSkip > 0 && cchSkip >= cchNonWhite && !IsInOutlineView() && 
			!_ped->fUseLineServices() && (!_pddTarget || !_pddTarget->IsValid()))
		{
			me.NewLine(*rpOld);				// Don't remeasure anything we
			me.Advance(cchNonWhite);		//  already have valid info on
			me._li._cch = cchNonWhite;
			me._li._xWidth = rpOld->_xWidth;

			// Clear out any of the old flags _except_ for tabs and OLE or
			// OffScreen. Note that this algorithm is somewhat bogus; there 
			// is no guarantee that the line still matches the flag state.  
			// However,those flags are simply 'hints'--i.e. the line _may_ 
			// be in that state.  Keeping those flags set will result
			// in a minor slowdown for rendering the line.
			me._li._bFlags &= (fliHasTabs | fliHasOle | fliUseOffScreenDC | fliHasSpecialChars);

			if(rpOld->_bFlags & fliOffScreenOnce)
				me._li._bFlags &= ~fliUseOffScreenDC;
			me._li._cchEOP = 0;
			uiFlags |= MEASURE_DONTINIT;	// CLine part of me already init'd
		}

		// Stuff text into new line
    	Tracef(TRCSEVINFO, "Measuring new line from cp = %d", me.GetCp());

		if(!pliNew->Measure(me, -1, -1, uiFlags))
		{
			Assert(FALSE);
			goto err;
		}

		if(!pliNew->_cch)
		{
			TRACEWARNSZ(
           "CDisplayML::RecalcLines measure returned a zero length line");
			goto errspace;
		}

		fFirstInPara = pliNew->_bFlags & fliHasEOP;
		yHeightPrev	 = yHeight;
		yHeight		+= pliNew->GetHeight();
		cchEdit		-= pliNew->_cch;
		AssertSz(cchEdit + me.GetCp() <= cchText,
			"CDisplayML::RecalcLines: want to measure beyond EOD");

		// Calculate on what line the edit started. We do this because
		// we want to render the first edited line off screen so if
		// the line is being edited via the keyboard we don't clip
		// any characters.
		if(cchSkip > 0)
		{
			// Check whether we backed up and the line we are examining
			// changed at all. Even if it didn't change in outline view
			// have to redraw in case outline symbol changes
			if (cliBackedUp && cchSkip >= pliNew->_cch && 
				pliNew->IsEqual(*rpOld) && !IsInOutlineView())
			{
				// Perfect match, this line was not the first edited.
               	Tracef(TRCSEVINFO, "New line matched old line #%d", (LONG)rpOld);

				cchSkip -= rpOld->_cch;

				// Update first affected line and match in pled
				pled->_iliFirst++;
				pled->_cpFirst	  += rpOld->_cch;
				pled->_cpMatchOld += rpOld->_cch;
				pled->_yFirst	  += rpOld->GetHeight();
				AssertSz(pled->_yFirst >= 0, "CDisplayML::RecalcLines _yFirst < 0");
				pled->_yMatchOld  += rpOld->GetHeight();
				cliBackedUp--;
			
				rgliNew.Clear(AF_KEEPMEM);		// Discard new line
				if(!(rpOld++))					// Next line
					cchSkip = 0;
			}
			else								// No match in the line, so 
				cchSkip = 0;					//  this line is the first to
		}										//  be edited

		if(fBackground && GetTickCount() >= dwBgndTickMax)
		{
			fDone = FALSE;						// took too long, stop for now
			goto no_match;
		}

		if (fWait && yHeight > _yWait && me.GetCp() > _cpWait &&
			cliWait-- <= 0)
		{
			// Not really done, just past region we're waiting for
			// so let background recalc take it from here
			fDone = FALSE;
			goto no_match;
		}
	}											// while(cchEdit > 0) { }

   	Tracef(TRCSEVINFO, "Done recalcing edited text. Created %d new lines", rgliNew.Count());

	// Edit lines have been exhausted.  Continue breaking lines,
	// but try to match new & old breaks

	wNumber = me._wNumber;
	while(me.GetCp() < cchText)
	{
		// Assume there are no matches to try for
		BOOL frpOldValid = FALSE;

		// If we run out of runs, then no match is possible. Therefore, 
		// we only try for a match as long as we have runs.
		if(fTryForMatch)
		{
			// We are trying for a match so assume that there
			// is a match after all
			frpOldValid = TRUE;

			// Look for match in old line break CArray
			lT = me.GetCp() - cchNew + cchOld;
			while (rpOld.IsValid() && pled->_cpMatchOld < lT)
			{
				pled->_yMatchOld  += rpOld->GetHeight();
				pled->_cpMatchOld += rpOld->_cch;

				if(!rpOld.NextRun())
				{
					// No more line array entries so we can give up on
					// trying to match for good.
					fTryForMatch = FALSE;
					frpOldValid = FALSE;
					break;
				}
			} 
		}

		// If perfect match, stop.
		if (frpOldValid && rpOld.IsValid() && pled->_cpMatchOld == lT && 
			rpOld->_cch && me._wNumber == rpOld->_bNumber)
		{
           	Tracef(TRCSEVINFO, "Found match with old line #%d", rpOld.GetLineIndex());

			// Update fliFirstInPara flag in 1st old line that matches.  Note
			// that if the new array doesn't have any lines, we have to look
			// into the line array preceding the current change.
			rpOld->_bFlags |= fliFirstInPara;
			if(rgliNew.Count() > 0) 
			{
				if(!(rgliNew.Elem(rgliNew.Count() - 1)->_bFlags & fliHasEOP))
					rpOld->_bFlags &= ~fliFirstInPara;
			}
			else if( rpOld >= pled->_iliFirst && pled->_iliFirst )
			{
				if(!(rpOld[pled->_iliFirst - rpOld -1]._bFlags & fliHasEOP))
					rpOld->_bFlags &= ~fliFirstInPara;
			}

			pled->_iliMatchOld = rpOld;

			// Replace old lines by new ones
			lT = rpOld - pled->_iliFirst;
			rpOld = pled->_iliFirst;
			if(!rpOld.Replace (lT, &rgliNew))
			{
				TRACEWARNSZ("CDisplayML::RecalcLines unable to alloc additional CLines in rpOld");
				goto errspace;
			}
			frpOldValid = rpOld.ChgRun(rgliNew.Count());
			rgliNew.Clear(AF_KEEPMEM);	 		// Clear aux array

			// Remember information about match after editing
			Assert((cp = rpOld.CalculateCp()) == me.GetCp());
			pled->_yMatchNew	= yHeight;
			pled->_yMatchNewTop = yHeightPrev;
			pled->_iliMatchNew	= rpOld;
			pled->_cpMatchNew	= me.GetCp();

			// Compute height and cp after all matches
			_cpCalcMax = me.GetCp();

			if(frpOldValid && rpOld.IsValid())
			{
				do
				{
					yHeight	   += rpOld->GetHeight();
					_cpCalcMax += rpOld->_cch;
				}
				while( rpOld.NextRun() );
			}

			// Make sure _cpCalcMax is sane after the above update
			AssertSz(_cpCalcMax <= cchText, 
				"CDisplayML::RecalcLines match extends beyond EOF");

			// We stop calculating here.Note that if _cpCalcMax < size 
			// of text, this means a background recalc is in progress.
			// We will let that background recalc get the arrays
			// fully in sync.  

			AssertSz(_cpCalcMax == cchText || _fBgndRecalc,
					"CDisplayML::Match less but no background recalc");

			if(_cpCalcMax != cchText)
			{
				// This is going to be finished by the background recalc
				// so set the done flag appropriately.
				fDone = FALSE;
			}
			goto match;
		}

		// Add a new line
		pliNew = rgliNew.Add(1, NULL);
		if(!pliNew)
		{
			TRACEWARNSZ("CDisplayML::RecalcLines unable to alloc additional CLine in CLineArray");
			goto errspace;
		}

    	Tracef(TRCSEVINFO, "Measuring new line from cp = %d", me.GetCp());

		// Stuff some text into new line
		wNumber = me._wNumber;
		if(!pliNew->Measure(me, -1, -1, MEASURE_BREAKATWORD | 
							(fFirstInPara ? MEASURE_FIRSTINPARA : 0)))
		{
			Assert(FALSE);
			goto err;
		}
		
		fFirstInPara = pliNew->_bFlags & fliHasEOP;
		yHeight += pliNew->GetHeight();

		if(fBackground && GetTickCount() >= (DWORD)dwBgndTickMax)
		{
			fDone = FALSE;			// Took too long, stop for now
			break;
		}

		if(fWait && yHeight > _yWait && me.GetCp() > _cpWait
			&& cliWait-- <= 0)
		{							// Not really done, just past region we're
			fDone = FALSE;			//  waiting for so let background recalc
			break;					//  take it from here
		}
	}								// while(me < cchText) ...

no_match:
	// Didn't find match: whole line array from _iliFirst needs to be changed
	pled->_iliMatchOld	= Count(); 
	pled->_cpMatchOld	= cchText;
	pled->_yMatchNew	= yHeight;
	pled->_yMatchNewTop = yHeightPrev;
	pled->_yMatchOld	= _yHeight;
	_cpCalcMax			= me.GetCp();

	// Replace old lines by new ones
	rpOld = pled->_iliFirst;

	// We store the result from the replace because although it can fail the 
	// fields used for first visible must be set to something sensible whether 
	// the replace fails or not. Further, the setting up of the first visible 
	// fields must happen after the Replace because the lines could have 
	// changed in length which in turns means that the first visible position
	// has failed.

	fReplaceResult = rpOld.Replace(-1, &rgliNew);

	// _iliMatchNew & _cpMatchNew are used for first visible constants so we
	// need to set them to something reasonable. In particular the rendering
	// logic expects _cpMatchNew to be set to the first character of the first
	// visible line. rpOld is used because it is convenient.

	// Note we can't use RpBindToCp at this point because the first visible
	// information is messed up because we may have changed the line that
	// the first visible cp is on. 
	rpOld.BindToCp(me.GetCp());
	pled->_iliMatchNew = rpOld.GetLineIndex();
	pled->_cpMatchNew = me.GetCp() - rpOld.RpGetIch();

	if (!fReplaceResult)
	{
		TRACEERRORSZ("CDisplayML::RecalcLines rpOld.Replace() failed");
		goto errspace;
	}

    // Adjust first affected line if this line is gone
    // after replacing by new lines
    if(pled->_iliFirst >= Count() && Count() > 0)
    {
        Assert(pled->_iliFirst == Count());
        pled->_iliFirst = Count() - 1;
		pliNew = Elem(pled->_iliFirst);
        pled->_yFirst -= pliNew->GetHeight();
		AssertSz(pled->_yFirst >= 0, "CDisplayML::RecalcLines _yFirst < 0");
        pled->_cpFirst -= pliNew->_cch;
    }
    
match:
	_fRecalcDone = fDone;
    _fNeedRecalc = FALSE;
	_yCalcMax = yHeight;

	Tracef(TRCSEVINFO, "CDisplayML::RecalcLine(rtp, ...) - Done. Recalced down to line #%d", Count() - 1);

	// Clear wait fields since we want caller's to set them up.
	_yWait = -1;
	_cpWait = -1;

	if(fDone && fBackground)
	{
		TRACEINFOSZ("Background line recalc done");
		_ped->TxKillTimer(RETID_BGND_RECALC);
		_fBgndRecalc = FALSE;
		_fRecalcDone = TRUE;
	}

	// Determine display height and update scrollbar
	yHeightScrollNew = CalcScrollHeight(yHeight);

	if (_fViewChanged ||
		fDone && (yHeight != _yHeight || yHeightScrollNew != yHeightScrollOld)
		|| yHeightScrollNew > yHeightScrollOld) 
	{
	    //!NOTE:
	    // UpdateScrollBar can cause a resize of the window by hiding or showing
	    // scrollbars.  As a consequence of resizing the lines may get recalculated
	    // therefore updating _yHeight to a new value, something != to yHeight.
		_yHeight = yHeight;
   		UpdateScrollBar(SB_VERT, TRUE);
	}
	else
	    _yHeight = yHeight;     // Guarantee heights agree

	// Determine display width and update scrollbar
	xWidth = CalcDisplayWidth();
    if(_fViewChanged || (fDone && xWidth != _xWidth) || xWidth > _xWidth)
    {
        _xWidth = xWidth;
   		UpdateScrollBar(SB_HORZ, TRUE);
    }    

    _fViewChanged = FALSE;

	// If not done, do the rest in background
	if(!fDone && !fBackground)
		fDone = StartBackgroundRecalc();

	if(fDone)
	{
		CheckLineArray();
		_fLineRecalcErr = FALSE;
	}

#ifdef DEBUG
	if( 1 )
    {
		_TEST_INVARIANT_
	}
#endif // DEBUG

	return TRUE;

errspace:
	_ped->GetCallMgr()->SetOutOfMemory();
	_fNeedRecalc = TRUE;
	_cpCalcMax = _yCalcMax = 0;
	_fLineRecalcErr = TRUE;

err:
	if(!_fLineRecalcErr)
	{
		_cpCalcMax = me.GetCp();
		_yCalcMax = yHeight;
	}

	TRACEERRORSZ("CDisplayML::RecalcLines() failed");

	if(!_fLineRecalcErr)
	{
		_fLineRecalcErr = TRUE;
		_ped->GetCallMgr()->SetOutOfMemory();
		_fLineRecalcErr = FALSE;			//  fix up CArray & bail
	}
	pled->SetMax(this);

	return FALSE;
}

/*
 *	CDisplayML::CalcDisplayWidth()
 *
 *	@mfunc
 *		Calculates width of this display by walking line CArray and
 *		returning widest line.  Used for horizontal scrollbar routines.
 *
 *	@rdesc
 *		Widest line width in display
 */
LONG CDisplayML::CalcDisplayWidth ()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CalcDisplayWidth");

	LONG	ili = Count();
	CLine *	pli;
	LONG	xWidth = 0, lineWidth;

	if(ili)
	{
		// Note: pli++ breaks array encapsulation (pli = Elem(ili) doesn't,
		// but is a bit slower)
		pli = Elem(0);
		for(xWidth = 0; ili--; pli++)
		{
			lineWidth = pli->_xLeft + pli->_xWidth + pli->_xLineOverhang;
			xWidth = max(xWidth, lineWidth);
		}
	}
    return xWidth;
}

/*
 *	CDisplayML::StartBackgroundRecalc()
 *
 *	@mfunc
 *		Starts background line recalc (at _cpCalcMax position)
 *
 *	@rdesc
 *		TRUE if done with background recalc
 */
BOOL CDisplayML::StartBackgroundRecalc()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::StartBackgroundRecalc");

	if(_fBgndRecalc)
		return FALSE;					// Already in background recalc

	AssertSz(_cpCalcMax <= _ped->GetTextLength(),
		"CDisplayML::StartBackgroundRecalc _cpCalcMax > Text Length");

	if(_cpCalcMax == _ped->GetTextLength())
		return TRUE;					// Enough chars are recalc'd

	if(!_ped->TxSetTimer(RETID_BGND_RECALC, cmsecBgndInterval))
	{
		// Could not instantiate a timer so wait for recalculation
		WaitForRecalc(_ped->GetTextLength(), -1);
		return TRUE;
	}

	_fRecalcDone = FALSE;
	_fBgndRecalc = TRUE;
	return FALSE;
}

/*
 *	CDisplayML::StepBackgroundRecalc()
 *
 *	@mfunc
 *		Steps background line recalc (at _cpCalcMax position)
 *		Called by timer proc and also when going inactive.
 */
void CDisplayML::StepBackgroundRecalc()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::StepBackgroundRecalc");

    _TEST_INVARIANT_
	
	if(!_fBgndRecalc)					// Not in background recalc,
		return;							//  so don't do anything

	LONG cch = _ped->GetTextLength() - _cpCalcMax;

	// Don't try recalc when processing OOM or had an error doing recalc or
	// if we are asserting.
#ifdef DEBUG
	if(_fInBkgndRecalc || _fLineRecalcErr)
	{
		if(_fInBkgndRecalc)
			TRACEINFOSZ("avoiding reentrant background recalc");
		else
			TRACEINFOSZ("OOM: not stepping recalc");
		return;
	}
#else
	if(_fInBkgndRecalc || _fLineRecalcErr)
		return;
#endif

	_fInBkgndRecalc = TRUE;
	if(!IsActive())
	{
		// Background recalc is over if we are no longer active	because
		// we can no longer get the information we need for recalculating.
		// But, if we are half recalc'd we need to set ourselves up to 
		// recalc again when we go active.
		InvalidateRecalc();
		cch = 0;
	}

	// Background recalc is over if no more chars or no longer active
	if(cch <= 0)
	{
		TRACEINFOSZ("Background line recalc done");
		_ped->TxKillTimer(RETID_BGND_RECALC);
		_fBgndRecalc = FALSE;
		_fRecalcDone = TRUE;
		_fInBkgndRecalc = FALSE;
		CheckLineArray();
		return;
	}

	CRchTxtPtr tp(_ped, _cpCalcMax);
	RecalcLines(tp, cch, cch, TRUE, FALSE, NULL);

	_fInBkgndRecalc = FALSE;
}

/*
 *	CDisplayML::WaitForRecalc(cpMax, yMax)
 *
 *	@mfunc
 *		Ensures that lines are recalced until a specific character
 *		position or ypos.
 *
 *	@rdesc
 *		success
 */
BOOL CDisplayML::WaitForRecalc(
	LONG cpMax,		//@parm Position recalc up to (-1 to ignore)
	LONG yMax)		//@parm ypos to recalc up to (-1 to ignore)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::WaitForRecalc");

    _TEST_INVARIANT_

	if(IsFrozen() || !_ped->fInplaceActive())
		return TRUE;

	BOOL fReturn = TRUE;
	LONG cch;

	if((yMax  < 0 || yMax  >= _yCalcMax) &&
	   (cpMax < 0 || cpMax >= _cpCalcMax))
    {
    	cch = _ped->GetTextLength() - _cpCalcMax;
    	if(cch > 0 || Count() == 0)
    	{
    		HCURSOR hcur = NULL;
			BOOL fSetCursor = (cch > NUMCHARFORWAITCURSOR);

    		_cpWait = cpMax;
    		_yWait = yMax;
		
			if(fSetCursor)
    			hcur = SetCursor(LoadCursor(0, IDC_WAIT));
    		TRACEINFOSZ("Lazy recalc");
		
    		if(!_cpCalcMax || _fNeedRecalc)
			{
    			fReturn = RecalcLines(TRUE);
				RebindFirstVisible();
				if(!fReturn)
					InitVars();
			}
    		else			
    		{
    			CRchTxtPtr rtp(_ped, _cpCalcMax);
    			fReturn = RecalcLines(rtp, cch, cch, FALSE, TRUE, NULL);
    		}

			if(fSetCursor)
    			SetCursor(hcur);
    	}
		else if(!cch)
		{
			// If there was nothing else to calc, make sure that we think
			// recalc is done.
#ifdef DEBUG
			if( !_fRecalcDone )
			{
				TRACEWARNSZ("For some reason we didn't think background "
					"recalc was done, but it was!!");
			}
#endif // DEBUG
			_fRecalcDone = TRUE;
		}
    }

	// If view rect changed, make sure to update scrollbars
	RecalcScrollBars();

	return fReturn;
}

/*
 *	CDisplayML::WaitForRecalcIli(ili)
 *
 *	@mfunc
 *		Wait until line array is recalculated up to line <p ili>
 *
 *	@rdesc
 *		Returns TRUE if lines were recalc'd up to ili
 */
BOOL CDisplayML::WaitForRecalcIli (
	LONG ili)		//@parm Line index to recalculate line array up to
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::WaitForRecalcIli");

	LONG cchGuess;

	while(!_fRecalcDone && ili >= Count())
	{
		// just go ahead and recalc everything.
		cchGuess = _ped->GetTextLength();
		if(IsFrozen() || !WaitForRecalc(cchGuess, -1))
			return FALSE;
	}
	return ili < Count();
}

/*
 *	CDisplayML::WaitForRecalcView()
 *
 *	@mfunc
 *		Ensure visible lines are completly recalced
 *
 *	@rdesc TRUE iff successful
 */
BOOL CDisplayML::WaitForRecalcView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::WaitForRecalcView");

	return WaitForRecalc(-1, _yScroll + _yHeightView);
}

/*
 *	CDisplayML::InitLinePtr ( CLinePtr & plp )
 *
 *	@mfunc
 *		Initialize a CLinePtr properly
 */
void CDisplayML::InitLinePtr (
	CLinePtr & plp )		//@parm Ptr to line to initialize
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::InitLinePtr");

    plp.Init( *this );
}

/*
 *	CDisplayML::GetLineText(ili, pchBuff, cchMost)
 *
 *	@mfunc
 *		Copy given line of this display into a character buffer
 *
 *	@rdesc
 *		number of character copied
 */
LONG CDisplayML::GetLineText(
	LONG ili,			//@parm Line to get text of
	TCHAR *pchBuff,		//@parm Buffer to stuff text into
	LONG cchMost)		//@parm Length of buffer
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetLineText");
    
	_TEST_INVARIANT_

	CTxtPtr tp (_ped, 0);

	// FUTURE (alexgo, ricksa): This is called from EM_GETLINE whose parameter
	// is a WPARAM which is unsigned we need to fix the type of ili.

	if(ili >= 0 && (ili < Count() || WaitForRecalcIli(ili)))
	{
		cchMost = min(cchMost, Elem(ili)->_cch);
		if(cchMost > 0)
		{
			tp.SetCp(CpFromLine(ili, NULL));
			return tp.GetText(cchMost, pchBuff);
		}
	}
	*pchBuff = TEXT('\0');
	return 0;
}

/*
 *	CDisplayML::LineCount
 *
 *	@mfunc	returns the number of lines in this control.  Note that for plain
 *			text mode, we will add on an extra line of the last character is
 *			a CR.  This is for compatibility with MLE
 *
 *	@rdesc	LONG
 */
LONG CDisplayML::LineCount() const
{
	LONG cLine = Count();

	if (!_ped->IsRich() && (!cLine || 	   // If plain text with no lines
		 Elem(cLine - 1)->_cchEOP))		   //  or last line ending with a CR,
	{									   //  then inc line count
		cLine++;
	}
	return cLine;
}

// ================================  Line info retrieval  ====================================

/*
 *	CDisplayML::YposFromLine(ili)
 *
 *	@mfunc
 *		Computes top of line position
 *
 *	@rdesc
 *		top position of given line (relative to the first line)
 */
LONG CDisplayML::YposFromLine(
	LONG ili) 		//@parm Line we're interested in
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::YposFromLine");
    _TEST_INVARIANT_

	if(!WaitForRecalcIli(ili))			// out of range, use last valid line
	{
		ili = Count() - 1;
		ili = (ili > 0) ? ili : 0;
	}

	LONG	cli	= ili - _iliFirstVisible;
	CLine *	pli = Elem(_iliFirstVisible);
	LONG	yPos = _yScroll + _dyFirstVisible;

	while(cli > 0)
	{
		yPos += pli->GetHeight();
		cli--;
		pli++;
	}
	while(cli < 0)
	{	
		pli--;
		yPos -= pli->GetHeight();
		cli++;
	}

	AssertSz(yPos >= 0, "CDisplayML::YposFromLine height less than 0");

	return yPos;
}

/*
 *	CDisplayML::CpFromLine(ili, pyHeight)
 *
 *	@mfunc
 *		Computes cp at start of given line 
 *		(and top of line position relative to this display)
 *
 *	@rdesc
 *		cp of given line
 */
LONG CDisplayML::CpFromLine (
	LONG ili,		//@parm Line we're interested in (if <lt> 0 means caret line)
	LONG *pyHeight)	//@parm Returns top of line relative to display 
					//  	(NULL if don't want that info)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CpFromLine");

    _TEST_INVARIANT_
						
	LONG cli;
	LONG y = _yScroll + _dyFirstVisible;
	LONG cp = _cpFirstVisible;
	CLine *pli;
	LONG iStart = _iliFirstVisible;

	cli = ili - _iliFirstVisible;
	if(cli < 0 && -cli >= ili)
	{
		// Closer to first line than to first visible line,
		// so start at the first line
		cli = ili;
		y = 0;
		cp = 0;
		iStart = 0;
	}
	else if( cli <= 0 )
	{
		CheckView();
		for(ili = _iliFirstVisible-1; cli < 0; cli++, ili--)
		{
			pli = Elem(ili);
			y -= pli->GetHeight();
			cp -= pli->_cch;
		}
		goto end;
	}

	for(ili = iStart; cli > 0; cli--, ili++)
	{
		pli = Elem(ili);
		if(!IsMain() || !WaitForRecalcIli(ili))
			break;
		y += pli->GetHeight();
		cp += pli->_cch;
	}

end:
	if(pyHeight)
		*pyHeight = y;

	return cp;
}

/*
 *	CDisplayML::LineFromYPos(yPos, pyLine, pcpFirst)
 *
 *	@mfunc
 *		Computes line at given y position. Returns top of line ypos
 *		cp at start of line cp, and line index.
 *
 *	@rdesc
 *		index of line found
 */
LONG CDisplayML::LineFromYpos (
	LONG yPos,			//@parm Ypos to look for (relative to first line)
	LONG *pyLine,		//@parm Returns ypos at top of line /r first line (can be NULL)
	LONG *pcpFirst)		//@parm Returns cp at start of line (can be NULL)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::LineFromYpos");

    _TEST_INVARIANT_

	LONG cpLi;
	LONG dy;
	LONG ili = 0;
	LONG yLi;
	CLine *pli;

	if(!WaitForRecalc(-1, _yScroll))
	{
		yLi = 0;
		cpLi = 0;
		goto done;
	}

	cpLi = _cpFirstVisible;
	ili = _iliFirstVisible;
	yLi = _yScroll + _dyFirstVisible;
	dy = yPos - yLi;
	
	if(dy < 0 && -dy <= _yScroll)
	{
		// Closer to first visible line than to first line:
		// go backwards from first visible line.
		while(yPos < yLi && ili > 0)
		{
			pli = Elem(--ili);
			yLi -= pli->GetHeight();
			cpLi -= pli->_cch;
		}
	}
	else
	{
		if(dy < 0)
		{
			// Closer to first line than to first visible line:
			// so start at first line.
			cpLi = _cpMin;
			yLi = 0;
			ili = 0;
		}
		pli = Elem(ili);
		while(yPos > yLi && ili < Count()-1)
		{
			yLi += pli->GetHeight();
			cpLi += pli->_cch;
			ili++;
			pli++;
		}
		if(yPos < yLi && ili > 0)
		{
			ili--;
			pli--;
			yLi -= pli->GetHeight();
			cpLi -= pli->_cch;
		}
	}

done:
	if(pyLine)
		*pyLine = yLi;

	if(pcpFirst)
		*pcpFirst = cpLi;

	return ili;
}

/*
 *	CDisplayML::LineFromCp(cp, fAtEnd)
 *
 *	@mfunc
 *		Computes line containing given cp.
 *
 *	@rdesc
 *		index of line found, -1 if no line at that cp.
 */
LONG CDisplayML::LineFromCp(
	LONG cp,		//@parm cp to look for
	BOOL fAtEnd)	//@parm If true, return previous line for ambiguous cp
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::LineFromCp");
    
	_TEST_INVARIANT_

	CLinePtr rp(this);
	
	if(!WaitForRecalc(cp, -1) || !rp.RpSetCp(cp, fAtEnd))
		return -1;

	return (LONG)rp;
}


//==============================  Point <-> cp conversion  ==============================
/*
 *	CDisplayML::CpFromPoint(pt, prcClient, ptp, prp, fAllowEOL, pHit, pdx)
 *
 *	@mfunc
 *		Determine cp at given point
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		Computed cp, -1 if failed
 */
LONG CDisplayML::CpFromPoint(
	POINT		pt,			//@parm Point to compute cp at (client coords)
	const RECT *prcClient,	//@parm Client rectangle (can be NULL if active).
	CRchTxtPtr * const ptp,	//@parm Returns text pointer at cp (may be NULL)
	CLinePtr * const prp,	//@parm Returns line pointer at cp (may be NULL)
	BOOL		fAllowEOL,	//@parm Click at EOL returns cp after CRLF
	HITTEST *	phit,		//@parm Out parm for hit-test value
	CDispDim *	pdispdim,	//@parm Out parm for display dimensions
	LONG	   *pcpActual)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CpFromPoint");

    _TEST_INVARIANT_

	LONG		cp;
	LONG		cch = 0;
    RECT        rcView;
	HITTEST		hit = HT_Nothing;

	GetViewRect(rcView, prcClient);

	// Get line under hit
	int y = pt.y;
	pt.y += _yScroll - rcView.top;

	LONG yLine;
	LONG ili = LineFromYpos(pt.y, &yLine, &cp);
    if(ili < 0)
        return -1;

	if(y >= rcView.top && y <= rcView.bottom)
	{
	    pt.y -= yLine;

		CLine *pli = Elem(ili);

		AssertSz(pli || !ili, "CDisplayML::CpFromPoint invalid line pointer");

		if(pli)
		{
			CMeasurer me(this);					// Create measurer
			me.SetCp(cp);

			// Transform to galley coordinates

			// Adjust coordinate relative to where the view starts from.
			pt.x -= rcView.left;

			// Is x coordinate within the view?
			if (pt.x >= 0)
			{
				// Adjust by the scroll value
				pt.x += _xScroll;
			}

			// Get character in line
			cch = pli->CchFromXpos(me, pt, pdispdim, &hit, pcpActual);
			// Don't allow click at EOL to select EOL marker and take into
			// account single line edits as well
			if(!fAllowEOL && cch == pli->_cch && pli->_cchEOP)
			{
				// Adjust position on line by amount backed up. OK for
				// me._rpCF and me._rpPF to get out of sync with me._rpTX,
				// since they're not needed for me.GetCp().
				cch += me._rpTX.BackupCpCRLF();
			}
			cp = me.GetCp();
		}
	}
	if(ptp)
        ptp->SetCp(cp);
	if(prp)
		prp->RpSet(ili, cch);
	if (phit)
		*phit = hit;

	return cp;	
}

/*
 *	CDisplayML::PointFromTp(rtp, prcClient, fAtEnd, pt, prp, taMode)
 *
 *	@mfunc
 *		Determine coordinates at given tp
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		line index at cp, -1 if error
 */
LONG CDisplayML::PointFromTp(
	const CRchTxtPtr &rtp,	//@parm Text ptr to get coordinates at
	const RECT *prcClient,	//@parm Client rectangle (can be NULL if active).
	BOOL		fAtEnd,		//@parm Return end of prev line for ambiguous cp
	POINT &		pt,			//@parm Returns point at cp in client coords
	CLinePtr * const prp,	//@parm Returns line pointer at tp (may be null)
	UINT		taMode,		//@parm Text Align mode: top, baseline, bottom
	CDispDim *	pdispdim)	//@parm Out parm for display dimensions
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::PointFromTp");

    _TEST_INVARIANT_

	LONG	 dy = 0;
	RECT	 rcView;
	CLinePtr rp(this);

    if(!WaitForRecalc(rtp.GetCp(), -1) || !rp.RpSetCp(rtp.GetCp(), fAtEnd))
		return -1;

    AssertSz(_ped->_fInPlaceActive || prcClient, 
		"CDisplayML::PointFromTp() called with invalid client rect");

    GetViewRect(rcView, prcClient);

	pt.x = rcView.left - _xScroll;
	pt.y = YposFromLine(rp) - _yScroll + rcView.top;

	CMeasurer me(this, rtp);
	me.Advance(-rp.RpGetIch());		// Backup to start of line		
	me.NewLine(*rp);				// Measure from there to where we are

	LONG xCalc = rp->XposFromCch(me, rp.RpGetIch(), taMode, pdispdim, &dy);

	if(pt.x + xCalc <= rcView.right || !GetWordWrap() || GetTargetDev())
	{
		// Width is in view or there is no wordwrap so just
		// add the length to the point.
		pt.x += xCalc;
	}
	else
	{
		// Remember we ignore trailing spaces at the end of the line in
		// the width, therefore the x value that MeasureText finds can 
		// be greater than the width in the line so we truncate to the 
		// previously calculated width which will ignore the spaces.
		pt.x += rp->_xLeft + rp->_xWidth; // We *don't* worry about xLineOverhang here
	}

	pt.y += dy;

	if(prp)
		*prp = rp;
	return rp;
}


//====================================  Rendering  =======================================

/*
 *	CDisplayML::Render(rcView, rcRender)
 *
 *	@mfunc	
 *		Searches paragraph boundaries around a range
 */
void CDisplayML::Render (
	const RECT &rcView,		//@parm View RECT
	const RECT &rcRender)	//@parm RECT to render (must be container in
							//		client rect)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::Render");

    _TEST_INVARIANT_
								
    LONG	cp;
	BOOL	fLinesToRender = TRUE;
	LONG	lCount = Count();
	CTxtSelection *psel = _ped->GetSelNC();
	POINT	pt;
	LONG	yBottomOfRender;
	LONG	yHeightForBitmap = 0;
	LONG	yHeightForLine;
    LONG	yLine;
	LONG	yRenderHeight = rcRender.top + _yScroll - rcView.top;

    if(psel)
		psel->ClearCchPending();
        
	// Review (murrays) this routine is called twice from disp.cpp (once for
	// rendering and once for transparent hit testing) and once from edit.cpp
	// (for printing).  Only the display rendering needs to notify the 
	// update and it does it there.  So the following is either undesired or
	// redundant, i.e., should be deleted.
	// Fire event "updating"
	//if(IsMain())
	//	_ped->TxNotify(EN_UPDATE, NULL);

	// Calculate line and cp to start display at
   	LONG ili = LineFromYpos(rcRender.top + _yScroll - rcView.top, &yLine, &cp);
	CLine *pli = Elem(ili);
	LONG yLi = pli ? pli->GetHeight() : 0;		// Null == some forms^3 empty control
	yLi = max(yLi, 0);

	if(yRenderHeight > yLine + yLi)
		fLinesToRender = FALSE;

	// Calculate point where text will start being displayed
   	pt.x = rcView.left - _xScroll;
   	pt.y = rcView.top  - _yScroll + yLine;
	yBottomOfRender = BottomOfRender(rcView, rcRender);

	// We only need check for whether we want to offscreen render if the
	// control is not transparent. Remember if the control is transparent,
	// the rendering of mixed character formats  will work because characters
	// in adjoining runs are only truncated if ExtTextOut is trying to clear
	// the display area at the same time.
	if (!IsMetafile() && IsMain() && !IsTransparent())
	{
		// Initialize height counter to first position to display
		yLi = pt.y;

		// Loop through visible lines until we have examined entire
		// line array or we have exceeded visible height
		CLine *pli = Elem(ili);
		for (LONG iliLoop = ili; 
			iliLoop < lCount && yLi < yBottomOfRender; iliLoop++, pli++)
		{
			if(pli->_fCollapsed)
				continue;
			
			yHeightForLine = pli->_yHeight;	// Get local copy of line height
			if(pli->_bFlags & fliUseOffScreenDC)
				yHeightForBitmap = max(yHeightForLine, yHeightForBitmap);

	        yLi += yHeightForLine;
		}
	}

	// Create renderer
	CRenderer re(this);

	// Prepare renderer
	if(!re.StartRender(rcView, rcRender, yHeightForBitmap))
		return;
	
	// Init renderer at start of first line to render
	re.SetCurPoint(pt);
   	cp = re.SetCp(cp);
    yLi = pt.y;

	if(fLinesToRender)
	{
		// Render each line in update rectangle
		for (; ili < lCount; ili++)
		{
			if (!Elem(ili)->Render(re) ||
				re.GetCurPoint().y >= yBottomOfRender)
			{
				break;
			}
#ifdef DEBUG
			cp  += Elem(ili)->_cch;
			yLi += Elem(ili)->GetHeight();

			// Rich controls with password characters stop at EOPs, 
			// so re.GetCp() may be less than cp.
			AssertSz(_ped->IsRich() && _ped->fUsePassword() || re.GetCp() == cp, 
				"CDisplayML::RenderView() - cp out of sync with line table");
			pt = re.GetCurPoint();
			AssertSz(pt.y == yLi,
				"CDisplayML::RenderView() - y out of sync with line table");
#endif
		}
	}
	re.EndRender();						  // Finish rendering
}


//===================================  View Updating  ===================================

/*
 *	CDisplayML::RecalcView(fUpdateScrollBars)
 *
 *	@mfunc
 *		Recalc all lines breaks and update first visible line
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::RecalcView(
	BOOL fUpdateScrollBars, RECT* prc)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcView");

	BOOL fRet = TRUE;
	LONG yHeightOld = _yHeight;
	LONG yScrollHeightOld = GetMaxYScroll();
	LONG xWidthOld = _xWidth;

	// Full recalc lines
	if(!RecalcLines())
	{
		// We're in deep trouble now, the recalc failed. Let's try to get out
		// of this with our head still mostly attached
		InitVars();
		fRet = FALSE;
        goto Done;
	}

	if(!_ped->GetTextLength())			// This is an empty control so
		CreateEmptyLine();				//  create one empty line

    // Force _xScroll = 0 if x scroll range is smaller than the view width
    if(_xWidth <= _xWidthView)
        _xScroll = 0;

	RebindFirstVisible();

	CheckView();

	// We only need to resize if the size needed to display the object has 
	// changed.
	if (yHeightOld != _yHeight || yScrollHeightOld != GetMaxYScroll() ||
		xWidthOld  != _xWidth)
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
		else if (prc && _ped->_fInOurHost)/*bug fix# 5830, forms3 relies on old behavior*/
			_ped->TxGetClientRect(prc);
	}

Done:

    // Now update scrollbars
	if(fUpdateScrollBars)
		RecalcScrollBars();

    return fRet;
}

/*
 *	CDisplayML::UpdateView(&rtp, cchOld, cchNew)
 *
 *	@mfunc
 *		Recalc lines and update the visible part of the display 
 *		(the "view") on the screen.
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::UpdateView(
	const CRchTxtPtr &rtp,	//@parm Text ptr where change happened
	LONG cchOld,				//@parm Count of chars deleted
	LONG cchNew)				//@parm Count of chars inserted
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::UpdateView");

	BOOL fReturn = TRUE;
	BOOL fRecalcVisible = TRUE;
	RECT rcClient;
    RECT rcView;
	CLed led;
	CTxtSelection *psel = _ped->GetSelNC();
	LONG cpStartOfUpdate = rtp.GetCp();
	BOOL fNeedViewChange = FALSE;
	LONG yHeightOld = _yHeight;
	LONG yScrollHeightOld = GetMaxYScroll();
	LONG xWidthOld = _xWidth;
	LONG yScrollOld = _yScroll;
	LONG cpNewFirstVisible;

	if(_fNoUpdateView)
		return fReturn;

	AssertSz(_ped->_fInPlaceActive, "CDisplayML::UpdateView(...) called when inactive");

	if(rtp.GetCp() > _cpCalcMax || _fNeedRecalc)
	{
		// We haven't even calc'ed this far, so don't bother with updating
		// here.  Background recalc will eventually catch up to us.
		return TRUE;
	}

	AssertSz(rtp.GetCp() <= _cpCalcMax, "CDisplayML::UpdateView(...) - rtp > _cpCaclMax");

	_ped->TxGetClientRect(&rcClient);
	GetViewRect(rcView, &rcClient);

	if(psel && !psel->PuttingChar())
		psel->ClearCchPending();

	DeferUpdateScrollBar();

	// In general, background recalc should not start until both the scroll 
	// position is beyond the visible view and the cp is beyond the first visible 
	// character. However, for the recalc we will only wait on the height. 
	// Later calls to WaitForRecalc will wait on cpFirstVisible if that is 
	// necessary.
	_yWait = _yScroll + _yHeightView;
	_cpWait = -1;

	if(!RecalcLines(rtp, cchOld, cchNew, FALSE, TRUE, &led))
	{
		// We're in trouble now, the recalc failed. Let's try to get
		// out of this with our head still mostly attached
		InitVars();
		fRecalcVisible = TRUE;
		fReturn = FALSE;
		_ped->TxInvalidateRect (NULL, FALSE);
		fNeedViewChange = TRUE;
		goto Exit;
	}

	if(!_ped->GetTextLength())
	{
		if(LineCount())					// There are currently elements in
			Clear(AF_DELETEMEM);		//  line array, so zap them

		// This is an empty control so create one empty line
		CreateEmptyLine();
	}

	if(_xWidth <= _xWidthView)
    {
		// x scroll range is smaller than the view width, force x scrolling position = 0
		// we have to redraw all when this means scrolling back to home.
		// Problem lines are lines with trailing spaces crossing _xWidthView. UpdateCaret forces redraw
		// only when such lines are growing, misses shrinking.
		
		if (_xScroll != 0)
			{
			_ped->TxInvalidateRect(NULL, FALSE);			//REVIEW: find a smaller rectange?
			}
			
		_xScroll = 0;

    }

	if(led._yFirst >= _yScroll + _yHeightView)
	{
		// Update is after view: don't do anything
		fRecalcVisible = FALSE;
		AssertNr(VerifyFirstVisible());
		goto finish;
	}
	else if(led._yMatchNew <= _yScroll + _dyFirstVisible &&
			led._yMatchOld <= _yScroll + _dyFirstVisible &&
			_yScroll < _yHeight)
	{
		if (_yHeight != 0)
		{
			// Update is entirely before view: just update scroll position
			// but don't touch the screen
			_yScroll += led._yMatchNew - led._yMatchOld;
			_iliFirstVisible += led._iliMatchNew - led._iliMatchOld;
			_iliFirstVisible = max(_iliFirstVisible, 0);

			_cpFirstVisible += led._cpMatchNew - led._cpMatchOld;
			_cpFirstVisible = min(_ped->GetTextLength(), _cpFirstVisible);
			_cpFirstVisible = max(0, _cpFirstVisible);
			fRecalcVisible = FALSE;
		}
		else
		{
			// Odd outline case. Height of control can be recalc'd to zero due 
			// when outline mode collapses all lines to 0. Example of how to 
			// do this is tell outline to collapse to heading 1 and there is none.
			_yScroll = 0;
			_iliFirstVisible = 0;
			_cpFirstVisible = 0;
		}

		AssertNr(VerifyFirstVisible());
	}
	else
	{
		// Update overlaps visible view
		RECT rc = rcClient;
        RECT rcUpdate;

		// Do we need to resync the first visible?  Note that this if check
		// is mostly an optmization; we could decide to _always_ recompute
		// this _iliFirstVisible if we wanted to.
		if ( cpStartOfUpdate <= _cpFirstVisible || 
			led._iliMatchOld <= _iliFirstVisible ||
			led._iliMatchNew <= _iliFirstVisible ||
			led._iliFirst <= _iliFirstVisible )
		{
			// Edit overlaps the first visible. We try to maintain
			// approximately the same place in the file visible.
			cpNewFirstVisible = _cpFirstVisible;

			if(_iliFirstVisible - 1 == led._iliFirst)
			{
				// Edit occurred on line before visible view. Most likely
				// this means that the first character got pulled back to
				// the previous line so we want that line to be visible.
				cpNewFirstVisible = led._cpFirst;
			}

			// Change first visible entries because CLinePtr::RpSetCp() and
			// YPosFromLine() use them, but they're not valid
			_dyFirstVisible = 0;
			_cpFirstVisible = 0;
			_iliFirstVisible = 0;
			_yScroll = 0;

			// With certain formatting changes, it's possible for 
			// cpNewFirstVisible to be less that what's been calculated so far 
			// in RecalcLines above. Wait for things to catch up.

			WaitForRecalc(cpNewFirstVisible, -1);

			// TODO: make following more efficient (work around rp.CalculateCp()
			// all the way from zero)
			// Recompute scrolling position and first visible values after edit
		    CLinePtr rp(this);
   			rp.RpSetCp(cpNewFirstVisible, FALSE);
   			_yScroll = YposFromLine(rp);
   			_cpFirstVisible = rp.CalculateCp() - rp.RpGetIch();
   			_iliFirstVisible = rp;
		}
		AssertNr(VerifyFirstVisible());

		// Is there a match in the display area? - this can only happen if the
		// old match is on the screen and the new match will be on the screen
		if (led._yMatchOld < yScrollOld + _yHeightView &&
			led._yMatchNew < _yScroll + _yHeightView)
		{
			// We have a match inside visible view
			// Scroll the part that is below the old y pos of the match
			// or invalidate if the new y of the match is now below the view
			rc.top = rcView.top + (INT) (led._yMatchOld - yScrollOld);
			if(rc.top < rc.bottom)
			{
				// Calculate difference between new and old screen positions
				const INT dy = (INT) ((led._yMatchNew - _yScroll)) 
					- (led._yMatchOld - yScrollOld);

				if(dy)
				{
					if(!IsTransparent())
					{
    					_ped->TxScrollWindowEx(0, dy, &rc, &rcView, NULL, &rcUpdate, 0);
		    			_ped->TxInvalidateRect(&rcUpdate, FALSE);
						fNeedViewChange = TRUE;

    					if(dy < 0)
	    				{
		    				rc.top = rc.bottom + dy;
			    			_ped->TxInvalidateRect(&rc, FALSE);
							fNeedViewChange = TRUE;
				    	}
    				}
                    else
                    {
						// Adjust rect since we don't scroll in transparent
						// mode
						RECT	rcInvalidate = rc;
   						rcInvalidate.top += dy;

                        _ped->TxInvalidateRect(&rcInvalidate, FALSE);
						fNeedViewChange = TRUE;
                    }
				}
			}
			else
			{
				rc.top = rcView.top + led._yMatchNew - _yScroll;
				_ped->TxInvalidateRect(&rc, FALSE);
				fNeedViewChange = TRUE;
			}

			// Since we found that the new match falls on the screen, we can
			// safely set the bottom to the new match since this is the most
			// that can have changed.
			rc.bottom = rcView.top 
				+ (INT) (max(led._yMatchNew, led._yMatchOld) - _yScroll);
		}

		rc.top = rcView.top + (INT) (led._yFirst - _yScroll);

		// Set first line edited to be rendered using off-screen bitmap
		if (led._iliFirst < Count() && !IsTransparent() &&
			!(Elem(led._iliFirst)->_bFlags & fliUseOffScreenDC))
		{	
			Elem(led._iliFirst)->_bFlags |= (fliOffScreenOnce |	fliUseOffScreenDC);
		}
		
		// Invalidate part of update that is above match (if any)
		_ped->TxInvalidateRect (&rc, FALSE);
		fNeedViewChange = TRUE;
	}

finish:
	if(fRecalcVisible)
	{
		fReturn = WaitForRecalcView();
		if(!fReturn) 
			return FALSE;
	}
	if(fNeedViewChange)
		_ped->GetHost()->TxViewChange(FALSE);

	CheckView();

	// We only need to resize if size needed to display object has changed
	if (yHeightOld != _yHeight || yScrollHeightOld != GetMaxYScroll() ||
		xWidthOld  != _xWidth)
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
	}
	if(DoDeferredUpdateScrollBar())
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
		DoDeferredUpdateScrollBar();
	}

Exit:
	return fReturn;
}

void CDisplayML::InitVars()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::InitVars");

	_yScroll = _xScroll = 0;
	_iliFirstVisible = 0;
	_cpFirstVisible = _cpMin = 0;
	_dyFirstVisible = 0;
}

/*
 *	CDisplayML::GetCliVisible(pcpMostVisible)
 *
 *	@mfunc	
 *		Get count of visible lines and update _cpMostVisible for PageDown()
 *
 *	@rdesc
 *		count of visible lines
 */
LONG CDisplayML::GetCliVisible(
	LONG* pcpMostVisible, 				//@parm Returns cpMostVisible
	BOOL fLastCharOfLastVisible) const 	//@parm Want cp of last visible char
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetCliVisible");

	LONG cli	 = 0;							// Initialize count
	LONG ili	 = _iliFirstVisible;			// Start with 1st visible line
	LONG yHeight = _dyFirstVisible;
    LONG cp;
	LONG cchWhite = 0;

	for(cp = _cpFirstVisible;
		yHeight < _yHeightView && ili < Count();
		cli++, ili++)
	{
		const CLine* pli = Elem(ili);
		yHeight	+= pli->GetHeight();

		if (fLastCharOfLastVisible)
		{
			if (yHeight > _yHeightView)
			{
				// Back up cp to last visible character
				cp -= cchWhite;
				break;
			}

			// Save last lines white space to adjust cp if
			// this is the last fully displayed line.
			cchWhite = pli->_cchWhite;
		}
		cp += pli->_cch;
	}

    if(pcpMostVisible)
        *pcpMostVisible = cp;

	return cli;
}

//==================================  Inversion (selection)  ============================

/*
 *	CDisplayML::InvertRange(cp, cch)
 *
 *	@mfunc
 *		Invert a given range on screen (for selection)
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::InvertRange (
	LONG cp,					//@parm Active end of range to invert
	LONG cch,					//@parm Signed length of range
	SELDISPLAYACTION selAction)	//@parm Describes what we are doing to the selection
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::InvertRange");

	LONG	 cpMost;
	RECT	 rc;
	RECT     rcView;
	CLinePtr rp(this);
	CRchTxtPtr  rtp(_ped);
	LONG	 y;
	LONG	 cpActive = _ped->GetSel()->GetCp();

    AssertSz(_ped->_fInPlaceActive,
    	"CDisplayML::InvertRange() called when not in-place active");

	if(cch < 0)						// Define cpMost, set cp = cpMin,
	{								//  and cch = |cch|
		cpMost = cp - cch;
		cch = -cch;
	}
	else
	{
		cpMost = cp;
		cp -= cch;
	}

#ifdef LINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif

	// If an object is being inverted, and nothing else is being inverted,
	// delegate to the ObjectMgr.  If fIgnoreObj is TRUE we highlight normally
	if (cch == 1 && _ped->GetObjectCount() &&
		(selAction == selSetNormal || selAction == selSetHiLite))
	{
		CObjectMgr* pobjmgr = _ped->GetObjectMgr();

		rtp.SetCp(cp);
		if(rtp.GetChar() == WCH_EMBEDDING)
		{
			if(pobjmgr)
				pobjmgr->HandleSingleSelect(_ped, cp, selAction == selSetHiLite);
			return TRUE;
		}
	}

	// If display is frozen, just update recalc region and move on.
	if(_padc)
	{
		AssertSz(cp >= 0, "CDisplayML::InvertRange: range (cp) goes below"
				"zero!!" );
		// Make sure these values are bounded.
		if(cp > _ped->GetTextLength())	// Don't bother updating region;
			return TRUE;				//  it's out of bounds

		if(cp + cch > _ped->GetTextLength())
			cch -= cp + cch - _ped->GetTextLength();

		_padc->UpdateRecalcRegion(cp, cch, cch);
		return TRUE;
	}

	if(!WaitForRecalcView())			// Ensure all visible lines are
		return FALSE;					//  recalc'd

	GetViewRect(rcView);				// Get view rectangle
	
	// Compute first line to invert and where to start on it
	if(cp >= _cpFirstVisible)
	{
		POINT pt;
		rtp.SetCp(cp);
		if(PointFromTp(rtp, NULL, FALSE, pt, &rp, TA_TOP) < 0)
			return FALSE;

		rc.left = pt.x;
		rc.top = pt.y;
	}
	else
	{
		cp = _cpFirstVisible;
		rp = _iliFirstVisible;
		rc.left = -1;
		rc.top = rcView.top + _dyFirstVisible;
	}				

	// Loop on all lines of range
	while (cp < cpMost && rc.top < rcView.bottom && rp.IsValid())
	{
		// Calculate rc.bottom first because rc.top takes into account
		// the dy of the first visible on the first loop.
		y = rc.top;
		y += rp->GetHeight();
		rc.bottom = min(y, rcView.bottom);
        rc.top = max(rc.top, rcView.top);

		if(rc.left == -1)
			rc.left = rp->_xLeft - _xScroll + rcView.left;

		//If we are inverting the active end of the selection, draw it offscreen
		//to minimize flicker.
		if (IN_RANGE(cp - rp.RpGetIch(), cpActive, cp - rp.RpGetIch() + rp->_cch) && 
			!IsTransparent() && !(rp->_bFlags & fliUseOffScreenDC))
		{	
			rp->_bFlags |= (fliOffScreenOnce | fliUseOffScreenDC);
		}

		cp += rp->_cch - rp.RpGetIch();

        rc.left = rcView.left;
        rc.right = rcView.right;

	    _ped->TxInvalidateRect(&rc, TRUE);
		rc.top = rc.bottom;
		if(!rp.NextRun())
			break;
	}
	_ped->TxUpdateWindow();				// Make sure window gets repainted
	return TRUE;
}


//===================================  Scrolling  =============================

/*
 *	CDisplay::GetYScroll()
 *
 *	@mfunc
 *		Returns vertical scrolling position
 */
LONG CDisplayML::GetYScroll() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetYScroll");

    return _yScroll;
}

/*
 *	CDisplay::VScroll(wCode, yPos)
 *
 *	@mfunc
 *		Scroll the view vertically in response to a scrollbar event
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		LRESULT formatted for WM_VSCROLL message		
 */
LRESULT CDisplayML::VScroll(
	WORD wCode,		//@parm Scrollbar event code
	LONG yPos)		//@parm Thumb position (yPos <lt> 0 for EM_SCROLL behavior)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::VScroll");

	LONG		cliVisible;
	LONG		dy = 0;
	BOOL		fTracking = FALSE;
	LONG		i;
	const LONG	ili = _iliFirstVisible;
	CLine *		pli = NULL;
	INT			yHeightSys = GetYHeightSys();
	LONG		yScroll = _yScroll;
    
    AssertSz(_ped->_fInPlaceActive, "CDisplay::VScroll() called when not in-place");

	if(yPos)
	{
		// Convert this from 16-bit to 32-bit if necessary.
		yPos = ConvertScrollToYPos(yPos);
	}

	yPos = min(yPos, _yHeight);

	switch(wCode)
	{
	case SB_BOTTOM:
		if(yPos < 0)
			return FALSE;
		WaitForRecalc(_ped->GetTextLength(), -1);
		yScroll = _yHeight;
		break;

	case SB_LINEDOWN:
		cliVisible = GetCliVisible();
		if(_iliFirstVisible + cliVisible < Count()
			&& 0 == _dyFirstVisible)
		{
			i = _iliFirstVisible + cliVisible;
			pli = Elem(i);
			if(IsInOutlineView())
			{	// Scan for uncollapsed line
				for(; pli->_fCollapsed && i < Count();
					pli++, i++);
			}
			if(i < Count())
				dy = pli->_yHeight;
		}
		else if(cliVisible > 1)
		{
			pli = Elem(_iliFirstVisible);
			dy = _dyFirstVisible;
			// TODO: scan until find uncollapsed line
			dy += pli->_yHeight;
		}
		else
			dy = _yHeight - _yScroll;

		if(dy >= _yHeightView)
			dy = yHeightSys;

		// Nothing to scroll, early exit
		if ( !dy )
			return MAKELRESULT(0, TRUE); 

		yScroll += dy;
		break;

	case SB_LINEUP:
		if(_iliFirstVisible > 0)
		{
			pli = Elem(_iliFirstVisible - 1);
			// TODO: scan until find uncollapsed line
			dy = pli->_yHeight;
		}
		else if(yScroll > 0)
			dy = min(yScroll, yHeightSys);

		if(dy > _yHeightView)
			dy = yHeightSys;
		yScroll -= dy;
		break;

	case SB_PAGEDOWN:
		cliVisible = GetCliVisible();
		yScroll += _yHeightView;
		if(yScroll < _yHeight && cliVisible > 0)
		{
			// TODO: Scan until find uncollapsed line
			dy = Elem(_iliFirstVisible + cliVisible - 1)->_yHeight;
			if(dy >= _yHeightView)
				dy = yHeightSys;

			else if(dy > _yHeightView - dy)
			{
				// Go at least a line if line is very big
				dy = _yHeightView - dy;
			}
			yScroll -= dy;
		}
		break;

	case SB_PAGEUP:
		cliVisible = GetCliVisible();
		yScroll -= _yHeightView;

		if (yScroll < 0)
		{
			// Scroll position can't be negative and we don't
			// need to back up to be sure we display a full line.
			yScroll = 0;
		}
		else if(cliVisible > 0)
		{
			// TODO: Scan until find uncollapsed line
			dy = Elem(_iliFirstVisible)->_yHeight;
			if(dy >= _yHeightView)
				dy = yHeightSys;

			else if(dy > _yHeightView - dy)
			{
				// Go at least a line if line is very big
				dy = _yHeightView - dy;
			}

			yScroll += dy;
		}
		break;

	case SB_THUMBTRACK:
	case SB_THUMBPOSITION:

		if(yPos < 0)
			return FALSE;

		yScroll = yPos;
		fTracking = TRUE;
		break;

	case SB_TOP:
		if(yPos < 0)
			return FALSE;
		yScroll = 0;
		break;

	case SB_ENDSCROLL:
		UpdateScrollBar(SB_VERT);
		return MAKELRESULT(0, TRUE);

	default:
		return FALSE;
	}
    
	ScrollView(_xScroll, min(yScroll, max(_yHeight - _yHeightView, 0)), fTracking, TRUE);

	// Force position update if we just finished a track
	if(wCode == SB_THUMBPOSITION)
		UpdateScrollBar(SB_VERT);

	// Return how many lines we scrolled
	return MAKELRESULT((WORD) (_iliFirstVisible - ili), TRUE);
}

/*
 *	CDisplay::LineScroll(cli, cch)
 *
 *	@mfunc
 *		Scroll view vertically in response to a scrollbar event
 */
void CDisplayML::LineScroll(
	LONG cli,		//@parm Count of lines to scroll vertically
	LONG cch)		//@parm Count of characters to scroll horizontally
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::LineScroll");
	
	//Make sure the line to scroll to is valid
	if (cli + _iliFirstVisible >= Count())
	{
        // change line count enough to display the last line
		cli = Count() - _iliFirstVisible;
	}

    // Get the absolute yScroll position by adding the difference of the line
    // we want to go to and the current _yScroll position
	LONG dyScroll = CalcYLineScrollDelta(cli, FALSE);
	if(dyScroll < 0 || _yHeight - (_yScroll + dyScroll) > _yHeightView - dyScroll)
		ScrollView(_xScroll, _yScroll + dyScroll, FALSE, FALSE);
}

/*
 *	CDisplayML::FractionalScrollView (yDelta)
 *
 *	@mfunc
 *		Allow view to be scrolled by fractional lines.
 */
void CDisplayML::FractionalScrollView ( LONG yDelta )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::FractionalScrollView");

	if ( yDelta)
		ScrollView(_xScroll, min(yDelta + _yScroll, max(_yHeight - _yHeightView, 0)), FALSE, TRUE);
}

/*
 *	CDisplayML::ScrollToLineStart(iDirection)
 *
 *	@mfunc
 *		If the view is scrolled so that only a partial line is at the
 *		top, then scroll the view so that the entire view is at the top.
 */
void CDisplayML::ScrollToLineStart(
	LONG iDirection)	//@parm the direction in which to scroll (negative
						// means down the screen
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::ScrollToLineStart");

	// This code originally lined things up on a line. However, it doesn't work
	// very well with big objects especially at the end of the document. I am
	// leaving the call here in case we discover problems later. (a-rsail).

#if 0
	// If _dyFirstVisible is zero, then we're aligned on a line, so
	// nothing more to do.

	if(_dyFirstVisible)
	{
		LONG yScroll = _yScroll + _dyFirstVisible;

		if(iDirection <= 0) 
		{
			yScroll += Elem(_iliFirstVisible)->_yHeight;
		}

		ScrollView(_xScroll, yScroll, FALSE, TRUE);
	}
#endif // 0
}

/*
 *	CDisplayML::CalcYLineScrollDelta (cli, fFractionalFirst)
 *
 *	@mfunc
 *		Given a count of lines, positive or negative, calc the number
 *		of vertical units necessary to scroll the view to the start of
 *		the current line + the given count of lines.
 */
LONG CDisplayML::CalcYLineScrollDelta (
	LONG cli,
	BOOL fFractionalFirst )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CalcYLineScrollDelta");

	LONG yScroll = 0;

	if(fFractionalFirst && _dyFirstVisible)	// Scroll partial for 1st.
	{
		Assert(_dyFirstVisible <= 0);		// get jonmat
		if(cli < 0)
		{
			cli++;
			yScroll = _dyFirstVisible;
		}
		else
		{
			cli--;
			yScroll = Elem(_iliFirstVisible)->_yHeight + _dyFirstVisible;
		}
	}

	if(cli > 0)
	{
		// Scrolling down
		cli = min(cli, Count() - _iliFirstVisible - 1);

		if (!fFractionalFirst && (0 == cli))
		{
			// If we are scrolling down and on the last line but we haven't scrolled to
			// the very bottom, then do so now.
			AssertSz(0 == yScroll, 
				"CDisplayML::CalcYLineScrollDelta last line & scroll");
			yScroll = _yHeight - _yScroll;

			// Limit scroll length to approximately 3 lines.
			yScroll = min(yScroll, 3 * GetYHeightSys());
		}
	}
	else if(cli < 0)
	{
		// Scrolling up
		cli = max(cli, -_iliFirstVisible);

		// At the top.
		if (!fFractionalFirst && (0 == cli))
		{
			// Make sure that we scroll back so first visible is 0.
			yScroll = _dyFirstVisible;

			// Limit scroll length to approximately 3 lines.
			yScroll = max(yScroll, -3 * GetYHeightSys());
		}
	}

	if(cli)
		yScroll += YposFromLine(_iliFirstVisible + cli) - YposFromLine(_iliFirstVisible);
	return yScroll;
}

/*
 *	CDisplayML::ScrollView(xScroll, yScroll, fTracking, fFractionalScroll)
 *
 *	@mfunc
 *		Scroll view to new x and y position
 *
 *	@devnote 
 *		This method tries to adjust the y scroll pos before
 *		scrolling to display complete line at top. x scroll 
 *		pos is adjusted to avoid scrolling all text off the 
 *		view rectangle.
 *
 *		Must be able to handle yScroll <gt> pdp->yHeight and yScroll <lt> 0
 *
 *	@rdesc
 *		TRUE if actual scrolling occurred, 
 *		FALSE if no change
 */
BOOL CDisplayML::ScrollView (
	LONG xScroll,		//@parm New x scroll position
	LONG yScroll,		//@parm New y scroll position
	BOOL fTracking,		//@parm TRUE indicates we are tracking scrollbar thumb
	BOOL fFractionalScroll)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::ScrollView");
						//		(don't update the scrollbar pos)
	BOOL fTryAgain = TRUE;
	RECT rcUpdate;      // ??? we may want use a region here but ScrollView is 
                        // rarely called with both a xScroll and yScroll value.
	LONG xWidthMax;
	LONG dx = 0;
	LONG dy = 0;
    RECT rcView;
	CTxtSelection *psel = _ped->GetSelNC();
	COleObject *pipo;
	BOOL fRestoreCaret = FALSE;


    AssertSz(_ped->_fInPlaceActive, "CDisplayML::ScrollView() called when not in-place");
    GetViewRect(rcView);
    
	if(xScroll == -1)
        xScroll = _xScroll;
	if(yScroll == -1)
        yScroll = _yScroll;
	
	// Determine vertical scrolling pos
	while(1)
	{
		BOOL fNothingBig = TRUE;
		LONG yFirst;
		LONG dyFirst;
		LONG cpFirst;
		LONG iliFirst;
		LONG yHeight;
		LONG iliT;

		yScroll = min(yScroll, GetMaxYScroll());
		yScroll = max(0, yScroll);
		dy = 0;

		// Ensure all visible lines are recalced
		if(!WaitForRecalcView())
			return FALSE;

		// Compute new first visible line
		iliFirst = LineFromYpos(yScroll, &yFirst, &cpFirst);

		if(cpFirst < 0)
		{
			// FUTURE (alexgo) this is pretty bogus, we should try to do
			// better in the next rel.

			TRACEERRORSZ("Display calc hosed, trying again");
			InitVars();
			_fNeedRecalc = TRUE;
			return FALSE;
		}

		if(iliFirst < 0)
		{
			// No line at _yScroll, use last line instead
			iliFirst = max(0, Count() - 1);
			cpFirst = _ped->GetTextLength() - Elem(iliFirst)->_cch;
			yScroll = _yHeight - Elem(iliFirst)->_yHeight;
			yFirst = _yScroll;
		}
		dyFirst = yFirst - yScroll;
		
		// Figure whether there is a big line
		// (more that a third of the view rect)
		for(iliT = iliFirst, yHeight = dyFirst;
			yHeight < _yHeightView && iliT < Count();
			iliT++)
		{
			const CLine* pli = Elem(iliT);
			if(pli->_yHeight >= _yHeightView / 3)
				fNothingBig = FALSE;
			yHeight += pli->_yHeight;
		}

		// If no big line and first pass, try to adjust 
		// scrolling pos to show complete line at top
		if(!fFractionalScroll && fTryAgain && fNothingBig && dyFirst != 0)
		{
			fTryAgain = FALSE;		// prevent any infinite loop

			Assert(dyFirst < 0);

			Tracef(TRCSEVINFO, "adjusting scroll for partial line at %d", dyFirst);
			// partial line visible at top, try to get a complete line showing
			yScroll += dyFirst;

			LONG yHeightLine = Elem(iliFirst)->_yHeight;

			// Adjust the height of the scroll by the height of the first 
			// visible line if we are scrolling down or if we are using the 
			// thumb (tracking) and we are on the last page of the view.
			if ((fTracking && yScroll + _yHeightView + yHeightLine > _yHeight)
				|| (!fTracking && _yScroll <= yScroll))
			{
				// Scrolling down so move down a little more
				yScroll += yHeightLine;
			}
		}
		else
		{
			dy = 0;
			if(yScroll != _yScroll)
			{
				_iliFirstVisible = iliFirst;
				_dyFirstVisible = dyFirst;
				_cpFirstVisible = cpFirst;
				dy = _yScroll - yScroll;
				_yScroll = yScroll;

				AssertSz(_yScroll >= 0, "CDisplayML::ScrollView _yScroll < 0");
				AssertNr(VerifyFirstVisible());
				if(!WaitForRecalcView())
			        return FALSE;
			}
			break;
		}
	}
	CheckView();

	// Determine horizontal scrolling pos.
	
	xWidthMax = _xWidth;

	// REVIEW (Victork) Restricting the range of the scroll is not really needed and could even be bad (bug 6104)
	
	xScroll = min(xScroll, xWidthMax);
	xScroll = max(0, xScroll);

	dx = _xScroll - xScroll;
	if(dx)
		_xScroll = xScroll;

	// Now perform the actual scrolling
	if(IsMain() && (dy || dx))
	{
		// Scroll only if scrolling < view dimensions and we are in-place
		if(IsActive() && !IsTransparent() && 
		    dy < _yHeightView && dx < _xWidthView)
		{
			// FUTURE: (ricksa/alexgo): we may be able to get rid of 
			// some of these ShowCaret calls; they look bogus.
			if (psel && psel->IsCaretShown())
			{
				_ped->TxShowCaret(FALSE);
				fRestoreCaret = TRUE;
			}
			_ped->TxScrollWindowEx((INT) dx, (INT) dy, NULL, &rcView,
				NULL, &rcUpdate, 0);

			_ped->TxInvalidateRect(&rcUpdate, FALSE);

			if(fRestoreCaret)
				_ped->TxShowCaret(FALSE);
		}
		else
			_ped->TxInvalidateRect(&rcView, FALSE);

		if(psel)
			psel->UpdateCaret(FALSE);

		if(!fTracking && dy)
		{
			UpdateScrollBar(SB_VERT);
			_ped->SendScrollEvent(EN_VSCROLL);
		}
		if(!fTracking && dx)
		{
			UpdateScrollBar(SB_HORZ);
			_ped->SendScrollEvent(EN_HSCROLL);
		}
						
		_ped->TxUpdateWindow();

		// FUTURE: since we're now repositioning in place active 
		// objects every time we draw, this call seems to be 
		// superfluous (AndreiB)

		// Tell object subsystem to reposition any in place objects
		if(_ped->GetObjectCount())
		{
			pipo = _ped->GetObjectMgr()->GetInPlaceActiveObject();
			if(pipo)
				pipo->OnReposition( dx, dy );
		}
	}
	return dy || dx;
}

/*
 *	CDisplayML::GetScrollRange(nBar)
 *
 *	@mfunc
 *		Returns the max part of a scrollbar range for scrollbar <p nBar>
 *
 *	@rdesc
 *		LONG max part of scrollbar range
 */
LONG CDisplayML::GetScrollRange(
	INT nBar) const		//@parm Scroll bar to interrogate (SB_VERT or SB_HORZ)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetScrollRange");

    Assert( IsMain() );

	LONG lRange = 0;
    
    if(nBar == SB_VERT && _fVScrollEnabled)
    {
	    if(_ped->TxGetScrollBars() & WS_VSCROLL)
			lRange = GetMaxYScroll();
    }
	else if((_ped->TxGetScrollBars() & WS_HSCROLL) && _fHScrollEnabled)
	{
		// Scroll range is maximum width plus room for the caret.
		lRange = max(0, _xWidth + dxCaret);
    }
	// Since thumb messages are limited to 16-bit, limit range to 16-bit
	lRange = min(lRange, _UI16_MAX);
	return lRange;
}

/*
 *	CDisplayML::UpdateScrollBar(nBar, fUpdateRange)
 *
 *	@mfunc
 *		Update either the horizontal or the vertical scrollbar and
 *		figure whether the scrollbar should be visible or not.
 *
 *	@rdesc
 *		BOOL
 */
BOOL CDisplayML::UpdateScrollBar(
	INT nBar,				//@parm Which scroll bar : SB_HORZ, SB_VERT
	BOOL fUpdateRange)		//@parm Should the range be recomputed and updated
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::UpdateScrollBar");

	// Note: In the old days we didn't allow autosize & scroll bars, so to keep
	// forms working, we need this special logic with respect to autosize.
	if (!IsActive() || _fInRecalcScrollBars ||
		!_ped->fInOurHost() && _ped->TxGetAutoSize())
	{
		// No scroll bars unless we are inplace active and we are not in the
		// process of updating scroll bars already.
		return TRUE;
	}

	const DWORD dwScrollBars = _ped->TxGetScrollBars();
	const BOOL fHide = !(dwScrollBars & ES_DISABLENOSCROLL);
	BOOL fReturn = FALSE;
	BOOL fEnabled = TRUE;
	BOOL fEnabledOld;
	LONG lScroll;
	CTxtSelection *psel = _ped->GetSelNC();
	BOOL fShowCaret = FALSE;

	// Get scrolling position
	if(nBar == SB_VERT)
	{
		if(!(dwScrollBars & WS_VSCROLL))
			return FALSE;

		fEnabledOld = _fVScrollEnabled;
        if(GetMaxYScroll() <= _yHeightView)
            fEnabled = FALSE;
    }
	else
	{
		if(!(dwScrollBars & WS_HSCROLL))
		{
			// Even if we don't have scrollbars, we may allow horizontal
			// scrolling.
			if(!_fHScrollEnabled && _xWidth > _xWidthView)
				_fHScrollEnabled = !!(dwScrollBars & ES_AUTOHSCROLL);

			return FALSE;
		}

		fEnabledOld = _fHScrollEnabled;
        if(_xWidth <= _xWidthView)
            fEnabled = FALSE;
	}

	// Don't allow ourselves to be re-entered.
	// Be sure to turn this to FALSE on exit
	_fInRecalcScrollBars = TRUE;

	// !s beforehand because all true values aren't necessarily equal
	if(!fEnabled != !fEnabledOld)
	{
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
		{
			if (nBar == SB_HORZ)
				_fHScrollEnabled = fEnabled;
			else
				_fVScrollEnabled = fEnabled;
		}

		if(!_fDeferUpdateScrollBar)
		{
    		if(!fHide)
			{
				// Don't hide scrollbar, just disable
    			_ped->TxEnableScrollBar(nBar, fEnabled ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);

				if (!fEnabled)
				{
					// The scroll bar is disabled. Therefore, all the text fits
					// on the screen so make sure the drawing reflects this.
					_yScroll = 0;
					_dyFirstVisible = 0;
					_cpFirstVisible = 0;
					_iliFirstVisible = 0;
					_ped->TxInvalidateRect(NULL, FALSE);
				}
			}
    		else 
    		{
    			fReturn = TRUE;
    			// Make sure to hide caret before showing scrollbar
    			if(psel)
    				fShowCaret = psel->ShowCaret(FALSE);

    			// Hide or show scroll bar
    			_ped->TxShowScrollBar(nBar, fEnabled);
				// The scroll bar affects the window which in turn affects the 
				// display. Therefore, if word wrap, repaint
				_ped->TxInvalidateRect(NULL, TRUE);
				// Needed for bug fix #5521
				_ped->TxUpdateWindow();

    			if(fShowCaret)
    				psel->ShowCaret(TRUE);
            }
		}
	}
	
	// Set scrollbar range and thumb position
	if(fEnabled)
	{
        if(fUpdateRange && !_fDeferUpdateScrollBar)
			_ped->TxSetScrollRange(nBar, 0, GetScrollRange(nBar), FALSE);
        
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
		{
			lScroll = (nBar == SB_VERT)
				? ConvertYPosToScrollPos(_yScroll)
				: ConvertXPosToScrollPos(_xScroll);

			_ped->TxSetScrollPos(nBar, lScroll, TRUE);
		}
	}
	_fInRecalcScrollBars = FALSE;
	return fReturn;
}

/*
 *	CDisplayML::GetNaturalSize(hdcDraw, hicTarget, dwMode, pwidth, pheight)
 *
 *	@mfunc
 *		Recalculate display to input width & height for TXTNS_FITTOCONTENT.
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 */
HRESULT	CDisplayML::GetNaturalSize(
	HDC hdcDraw,		//@parm DC for drawing
	HDC hicTarget,		//@parm DC for information
	DWORD dwMode,		//@parm Type of natural size required
	LONG *pwidth,		//@parm Width in device units to use for fitting 
	LONG *pheight)		//@parm Height in device units to use for fitting
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetNaturalSize");

	HRESULT hr = S_OK;

	// Set the height temporarily so the zoom factor will work out
	LONG yOrigHeightClient = SetClientHeight(*pheight);

	// Adjust height and width by view inset
	LONG widthView  = *pwidth;
	LONG heightView = *pheight;
	GetViewDim(widthView, heightView);

	// Store adjustment so we can restore it to height & width
	LONG widthAdj  = *pwidth  - widthView;
	LONG heightAdj = *pheight - heightView;
 	
	// Init measurer at cp = 0
	CMeasurer me(this);
	CLine liNew;
	LONG xWidth = 0, lineWidth;
	LONG yHeight = 0;
   	LONG cchText = _ped->GetTextLength();
	BOOL fFirstInPara = TRUE;

	LONG xWidthMax = GetWordWrap() ? widthView : -1;

	// The following loop generates new lines
	do 
	{	// Stuff text into new line
		UINT uiFlags = 0;

		// If word wrap is turned on, then we want to break on
		// words, otherwise, measure white space, etc.		
		if(GetWordWrap())
			uiFlags =  MEASURE_BREAKATWORD;

		if(fFirstInPara)
			uiFlags |= MEASURE_FIRSTINPARA;
	
		if(!liNew.Measure(me, -1, xWidthMax, uiFlags))
		{
			hr = E_FAIL;
			goto exit;
		}
		fFirstInPara = liNew._bFlags & fliHasEOP;

		// Keep track of width of widest line
		lineWidth = liNew._xWidth + liNew._xLineOverhang;
		xWidth = max(xWidth, lineWidth);
		yHeight += liNew._yHeight;		// Bump height

	} while (me.GetCp() < cchText);

	// Add caret size to width to guarantee that text fits. We don't
	// want to word break because the caret won't fit when the caller
	// tries a window this size.
	xWidth += dxCaret;

	*pwidth = xWidth;
	*pheight = yHeight;

	// Restore insets so output reflects true client rect needed
	*pwidth += widthAdj;
	*pheight += heightAdj;
		
exit:
	SetClientHeight(yOrigHeightClient);
	return hr;
}

/*
 *	CDisplayML::Clone()
 *
 *	@mfunc
 *		Make a copy of this object
 *
 *	@rdesc
 *		NULL - failed
 *		CDisplay *
 *
 *	@devnote
 *		Caller of this routine is the owner of the new display object.
 */
CDisplay *CDisplayML::Clone() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::Clone");

	CDisplayML *pdp = new CDisplayML(_ped);

	if(pdp)
	{
		// Initialize our base class
		if(pdp->CDisplay::Init())
		{
			pdp->InitFromDisplay(this);
			pdp->_xScroll = _xScroll;
			pdp->_fVScrollEnabled = _fVScrollEnabled;
			pdp->_fHScrollEnabled = _fHScrollEnabled;
			pdp->_fWordWrap = _fWordWrap;
			pdp->_cpFirstVisible = _cpFirstVisible;
			pdp->_iliFirstVisible = _iliFirstVisible;
			pdp->_yScroll = _yScroll;
			pdp->ResetDrawInfo(this);

			if(_pddTarget)
			{
				// Create a duplicate target device for this object
				pdp->SetMainTargetDC(_pddTarget->GetDC(), _xWidthMax);
			}

			// This can't be the active view since it is a clone
			// of some view.
			pdp->SetActiveFlag(FALSE);
		}
	}
	return pdp;
}

void CDisplayML::DeferUpdateScrollBar()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::DeferUpdateScrollBar");

	_fDeferUpdateScrollBar = TRUE;
	_fUpdateScrollBarDeferred = FALSE;
}

BOOL CDisplayML::DoDeferredUpdateScrollBar()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::DoDeferredUpdateScrollBar");

	_fDeferUpdateScrollBar = FALSE;
	if(!_fUpdateScrollBarDeferred)
		return FALSE;

	_fUpdateScrollBarDeferred = FALSE;
	BOOL fHorizontalUpdated = UpdateScrollBar(SB_HORZ, TRUE);
    
	return UpdateScrollBar(SB_VERT, TRUE) || fHorizontalUpdated;
}

LONG CDisplayML::GetMaxPixelWidth(void) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetMaxPixelWidth");

	return _xWidthMax ? LXtoDX(_xWidthMax) : GetViewWidth();
}

/*
 *	CDisplayML::GetMaxXScroll()
 *
 *	@mfunc
 *		Get the maximum x scroll value
 *
 *	@rdesc
 *		Maximum x scroll value
 *
 */
LONG CDisplayML::GetMaxXScroll() const
{
	return _xWidth + dxCaret;
}

/*
 *	CDisplayML::CreateEmptyLine()
 *
 *	@mfunc
 *		Create an empty line
 *
 *	@rdesc
 *		TRUE - iff successful
 */
BOOL CDisplayML::CreateEmptyLine()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CreateEmptyLine");

	// Make sure that this is being called appropriately
	AssertSz(_ped->GetTextLength() == 0,
		"CDisplayML::CreateEmptyLine called inappropriately");

	CMeasurer me(this);					// Create a measurer
	CLine *	  pliNew = Add(1, NULL);	// Add one new line

	if(!pliNew)
	{
		_ped->GetCallMgr()->SetOutOfMemory();
		TRACEWARNSZ("CDisplayML::CreateEmptyLine unable to add CLine to CLineArray");
		return FALSE;
	}

	// Measure the empty line
	if(!pliNew->Measure(me, -1, -1, MEASURE_BREAKATWORD | MEASURE_FIRSTINPARA))
	{
		Assert(FALSE);
		return FALSE;
	}
	return TRUE;
}

/*
 *	CDisplayML::AdjustToDisplayLastLine()
 *
 *	@mfunc
 *		Calculate the yscroll necessary to get the last line to display
 *
 *	@rdesc
 *		Updated yScroll
 *
 */
LONG CDisplayML::AdjustToDisplayLastLine(
	LONG yBase,			//@parm actual yScroll to display
	LONG yScroll)		//@parm proposed amount to scroll
{
	LONG iliFirst;
	LONG yFirst;

	if(yBase >= _yHeight)
	{
		// Want last line to be entirely displayed.
		// Compute new first visible line
		iliFirst = LineFromYpos(yScroll, &yFirst, NULL);

		// Is top line partial?
		if(yScroll != yFirst)
		{
			// Yes - bump scroll to the next line so the ScrollView
			// won't bump the scroll back to display the entire 
			// partial line since we want the bottom to display.
			yScroll = YposFromLine(iliFirst + 1);
		}
	}
	return yScroll;
}

/*
 *	CDisplayML::GetResizeHeight()
 *
 *	@mfunc
 *		Calculates height to return for a request resize
 *
 *	@rdesc
 *		Updated yScroll
 */
LONG CDisplayML::GetResizeHeight() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetResizeHeight");

    return CalcScrollHeight(_yHeight);
}

void CDisplayML::RebindFirstVisible()
{
	LONG cp = _cpFirstVisible;

	// Change first visible entries because CLinePtr::RpSetCp() and
	// YPosFromLine() use them, but they're not valid
	_dyFirstVisible = 0;
	_cpFirstVisible = 0;
	_iliFirstVisible = 0;
	_yScroll = 0;

	// Recompute scrolling position and first visible values after edit
    // force _yScroll = 0 if y scroll range is smaller than the view height
    if(_yHeight > _yHeightView)
    {   	
    	CLinePtr rp(this);
   		rp.RpSetCp(cp, FALSE);
   		_yScroll = YposFromLine(rp);
		// TODO: make following more efficient (work around rp.CalculateCp()
		// all the way from zero)
		// We use rp.GetCp() instead of cp, because cp could now be
		// woefully out of date.  RpSetCp will set us to the closest
		// available cp.
   		_cpFirstVisible = rp.CalculateCp() - rp.RpGetIch();
   		_iliFirstVisible = rp;
	}
}


// ================================  DEBUG methods  ============================================

#ifdef DEBUG
/*
 *	CDisplayML::CheckLineArray()
 *
 *	@mfunc	
 *		DEBUG routine that Asserts unless:
 *			1) sum of all line counts equals count of characters in story
 *			2) sum of all line heights equals height of display galley
 */
void CDisplayML::CheckLineArray() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CheckLineArray");

	LONG ili = Count();

	// If we are marked as needing a recalc or if we are in the process of a
	// background recalc, we cannot verify the line array 
	if(!_fRecalcDone || _fNeedRecalc || !ili)
		return;

	LONG cchText = _ped->GetTextLength();

	if (!cchText)
		return;

	LONG cp = 0;
	BOOL fFirstInPara;
	BOOL fPrevLineEOP = TRUE;
	LONG yHeight = 0;
	CLine const *pli = Elem(0);
	CRchTxtPtr rtp(_ped);

	while(ili--)
	{
		fFirstInPara = (pli->_bFlags & fliFirstInPara) != 0;
		AssertSz(!(fPrevLineEOP	^ fFirstInPara),
			"CDisplayML::CheckLineArray: Invalid first/prev flags");

		AssertSz(pli->_cch,
			"CDisplayML::CheckLineArray: cch == 0");

		yHeight += pli->GetHeight();
		cp		+= pli->_cch;
		fPrevLineEOP = (pli->_bFlags & fliHasEOP) != 0;
		pli++;
	}

	if((cp != cchText) && (cp != _cpCalcMax))
	{
		Tracef(TRCSEVINFO, "sigma (*this)[]._cch = %ld, cchText = %ld", cp, cchText);
		AssertSz(FALSE,
			"CDisplayML::CheckLineArray: sigma(*this)[]._cch != cchText");
	}

	if(yHeight != _yHeight)
	{
		Tracef(TRCSEVINFO, "sigma (*this)[]._yHeight = %ld, _yHeight = %ld", yHeight, _yHeight);
		AssertSz(FALSE,
			"CDisplayML::CheckLineArray: sigma(*this)[]._yHeight != _yHeight");
	}
}

void CDisplayML::DumpLines(
	LONG iliFirst,
	LONG cli)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::DumpLines");

	LONG cch;
	LONG ili;
	TCHAR rgch[512];

	if(Count() == 1)
		wcscpy(rgch, TEXT("1 line"));
	else
		wsprintf(rgch, TEXT("%d lines"), Count());
	
#ifdef UNICODE
    // TraceTag needs to take UNICODE...
#else
	TRACEINFOSZ(TRCSEVINFO, rgch);
#endif

	if(cli < 0)
		cli = Count();
	else
		cli = min(cli, Count());
	if(iliFirst < 0)
		iliFirst = Count() - cli;
	else
		cli = min(cli, Count() - iliFirst);

	for(ili = iliFirst; cli > 0; ili++, cli--)
	{
		const CLine * const pli = Elem(ili);

		wsprintf(rgch, TEXT("Line %d (%ldc%ldw%ldh%x): \""), ili, pli->_cch, 
			pli->_xWidth + pli->_xLineOverhang, pli->_yHeight, pli->_bFlags);
		cch = wcslen(rgch);
		cch += GetLineText(ili, rgch + cch, CchOfCb(sizeof(rgch)) - cch - 4);
		rgch[cch++] = TEXT('\"');
		rgch[cch] = TEXT('\0');
#ifdef UNICODE
        // TraceTag needs to take UNICODE...
#else
    	TRACEINFOSZ(TRCSEVINFO, rgch);
#endif
	}
}

/*
 *	CDisplayML::CheckView()
 *
 *	@mfunc	
 *		DEBUG routine that checks coherence between _iliFirstVisible,
 *		_cpFirstVisible, and _dyFirstVisible
 */
void CDisplayML::CheckView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CheckView");

	LONG yHeight;
	VerifyFirstVisible(&yHeight);

	if(yHeight != _yScroll + _dyFirstVisible)
	{
		Tracef(TRCSEVINFO, "sigma CLine._yHeight = %ld, CDisplay.yFirstLine = %ld", yHeight, _yScroll + _dyFirstVisible);
		AssertSz(FALSE, "CLine._yHeight != VIEW.yFirstLine");
	}
}

/*
 *	CDisplayML::VerifyFirstVisible(pHeight)
 *
 *	@mfunc
 *		DEBUG routine that checks coherence between _iliFirstVisible
 *		and _cpFirstVisible
 *
 *	@rdesc	TRUE if things are hunky dory; FALSE otherwise
 */
BOOL CDisplayML::VerifyFirstVisible(
	LONG *pHeight)
{
	LONG	cchSum;
	LONG	ili = _iliFirstVisible;
	CLine const *pli = Elem(0);
	LONG	yHeight;

	for(cchSum = yHeight = 0; ili--; pli++)
	{
		cchSum  += pli->_cch;
		yHeight += pli->GetHeight();
	}

	if(pHeight)
		*pHeight = yHeight;

	if(cchSum != _cpFirstVisible)
	{
		Tracef(TRCSEVINFO, "sigma CLine._cch = %ld, CDisplay.cpFirstVisible = %ld", cchSum, _cpMin);
		AssertSz(FALSE, "sigma CLine._cch != VIEW.cpMin");

		return FALSE;
	}
	return TRUE;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\dispsl.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	DISPSL.CPP -- CDisplaySL class |
 *
 *		This is the Single-line display engine.  See disp.c for the base class
 *		methods and dispml.c for the Multi-line display engine.
 *	
 *	Owner:<nl>
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_dispsl.h"
#include "_measure.h"
#include "_select.h"
#include "_render.h"
#include "_font.h"
#include "_dfreeze.h"

ASSERTDATA

const LONG CALC_XSCROLL_FROM_FIRST_VISIBLE = -2;

/*
 *	CDisplaySL::CDisplaySL
 *
 *	Purpose	
 *		Constructor
 */
CDisplaySL::CDisplaySL ( CTxtEdit* ped )
  : CDisplay( ped )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::CDisplaySL");

	Assert(!_fMultiLine);
}

/*
 *	CDisplaySL::Init()
 *
 *	@mfunc	
 *		Init this display for the screen
 *
 *	@rdesc
 *		TRUE iff initialization succeeded
 */
BOOL CDisplaySL::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::Init");

	// Initialize our base class
	if(!CDisplay::Init())
		return FALSE;

    SetWordWrap(FALSE);
    return TRUE;
}

/*
 *	CDisplaySL::InitVars()
 *
 */
void CDisplaySL::InitVars()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::InitVars");

    _xScroll = 0;
	SetCpFirstVisible(0);
}

/*
 *	CDisplaySL::RecalcView(fUpdateScrollBars)
 *
 *	@mfunc
 *		Recalc all lines breaks and update first visible line
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplaySL::RecalcView(
	BOOL fUpdateScrollBars, RECT* prc)		//@param TRUE - update scroll bars
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::RecalcView");
	LONG xWidthOld = _xWidth + _xLineOverhang;

    if(!RecalcLine())
        return FALSE;

    if(_fViewChanged)
    {
		if(IsActive() || _xWidth + _xLineOverhang <= GetViewWidth())
		{
			_xScroll = 0;
			SetCpFirstVisible(0);
		}
		else if(CALC_XSCROLL_FROM_FIRST_VISIBLE == _xScroll)
		{
			// In this case we want to set our xScroll by a visible. The
			// only way to get here is if the active view has been cloned
			// for displaying an inactive view.
 			_xScroll = 0;				// Assume that first visible is 0
			if(GetFirstVisibleCp())		// Check first visible
			{
				CMeasurer me(this);		// Start at cp 0
				me.NewLine(*this);		// Measure from there to where we are
		
				// Scroll is length to character
				_xScroll = CLine::XposFromCch(me, GetFirstVisibleCp(), TA_TOP);
			}
		}
		if(fUpdateScrollBars)
       		UpdateScrollBar(SB_HORZ, TRUE);

		_fViewChanged = FALSE;
    }

	// We only resize if width of single line control has changed.
	if(_xWidth + _xLineOverhang != xWidthOld)
	{
		if (FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
		else if (prc && _ped->_fInOurHost) /*bug fix# 5830, forms3 relies on old behavior*/
			_ped->TxGetClientRect(prc);
	}

    return TRUE;
}

/*
 *	CDisplaySL::RecalcLine()
 *
 *	@mfunc
 *		Recalculate a line
 *
 *	@rdesc
 *		TRUE if success <nl>
 *		FALSE if failure <nl>
 */
BOOL CDisplaySL::RecalcLine()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::RecalcLine");

    Assert( _ped );

	// Create a measurer starting at cp = 0
	CMeasurer me(this);

	LONG xWidthOld = CLine::_xWidth + CLine::_xLineOverhang;
	BOOL fMeasured = CLine::Measure(me, -1, -1, MEASURE_FIRSTINPARA);

	if(!fMeasured)
	{
		Assert(FALSE);						// Should succeed
	    InitVars();
	    return FALSE;
	}

	_fNeedRecalc = FALSE;
	_fRecalcDone = TRUE;

	if(_fViewChanged || xWidthOld != (CLine::_xWidth + CLine::_xLineOverhang))
		_fViewChanged = TRUE;

	_fLineRecalcErr = FALSE;
	return fMeasured;
}

/*
 *	CDisplaySL::Render(rcView, rcRender)
 *
 *	@mfunc	
 *		Renders this line
 */
void CDisplaySL::Render(
	const RECT &rcView,		//@parm View RECT
	const RECT &rcRender)	//@parm RECT to render (must be contained in
							//		client rect)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::Render");
    POINT	pt;
	LONG	yHeightBitmap = 0;

	_fRectInvalid = FALSE;

	CRenderer re(this);

	if(!IsMetafile() && !IsTransparent() && (_bFlags & fliUseOffScreenDC))
		yHeightBitmap = _yHeight;

    if(!re.StartRender(rcView, rcRender, yHeightBitmap))
        return;

    // Set renderer at top/left of view rect
    pt.x = rcView.left - _xScroll;
    pt.y = rcView.top;
    re.SetCurPoint(pt);

    // Renderer is set at cp = 0 at the moment
	CLine::Render(re);

	if(_bFlags & fliOffScreenOnce)
		_bFlags &= ~(fliUseOffScreenDC | fliOffScreenOnce);
 
    // If line metrics are not yet up to date, get them from renderer
    if(_xWidth == -1)
    {
        _xWidth			= re._li._xWidth;
		_xLineOverhang	= re._li._xLineOverhang;
        _yHeight		= re._li._yHeight;
        _yDescent		= re._li._yDescent;
    }
    re.EndRender();
}

/*
 *	CDisplaySL::WaitForRecalcIli(ili)
 *
 *	@mfunc
 *		Wait until line array is recalculated up to line <p ili>
 *
 *	@rdesc
 *		Returns TRUE if lines were recalc'd up to ili (TRUE if ili == 0)
 */
BOOL CDisplaySL::WaitForRecalcIli (
	LONG ili)		//@parm Line index to recalculate line array up to
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::WaitForRecalcIli");

    return ili == 0;
}

/*
 *	CDisplaySL::GetScrollRange(nBar)
 *
 *	@mfunc
 *		Returns the max part of a scrollbar range for scrollbar <p nBar>
 *
 *	@rdesc
 *		LONG max part of scrollbar range
 */
LONG CDisplaySL::GetScrollRange(
	INT nBar) const		//@parm Scroll bar to interrogate (SB_VERT or SB_HORZ)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetScrollRange");

    Assert( IsMain() );

	LONG lRange = 0;
    
    if(nBar != SB_VERT && _fHScrollEnabled)
    {
	    if(_ped->TxGetScrollBars() & WS_HSCROLL)
		{
			lRange = max(0, _xWidth + dxCaret);
			lRange = min(lRange, _UI16_MAX);
		}
    }
	return lRange;
}

/*
 *	CDisplaySL::UpdateScrollBar(nBar, fUpdateRange)
 *
 *	@mfunc
 *		Update horizontal scroll bar
 *		Also figure whether the scroll bar should be visible or not
 *
 *	@rdesc
 *		BOOL
 */
BOOL CDisplaySL::UpdateScrollBar (
	INT	 nBar,				//@parm Which scrollbar: SB_HORZ or SB_VERT
	BOOL fUpdateRange)		//@parm Should range be recomputed and updated
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::UpdateScrollBar");

	// Note: In the old days we didn't allow autosize & scroll bars, so to keep
	// forms working, we need this special logic with respect to autosize.
	if (!IsActive() || SB_VERT == nBar ||
		!_ped->fInOurHost() && _ped->TxGetAutoSize())
	{
		// Scroll bars are only updated on active views.
		return FALSE;
	}

	const DWORD dwScrollBars = _ped->TxGetScrollBars();
	const BOOL fHide = !(dwScrollBars & ES_DISABLENOSCROLL);
	BOOL fReturn = FALSE;
	BOOL fEnabled = TRUE;
	BOOL fEnabledOld = FALSE;
	LONG lScroll = 0;
	CTxtSelection *psel = _ped->GetSelNC();

	// Get scrolling position
	if(nBar == SB_HORZ)
	{
		if(!(dwScrollBars & WS_HSCROLL))
		{
			// even if we don't have scrollbars, we may allow horizontal
			// scrolling.

			if(!_fHScrollEnabled)
				_fHScrollEnabled = !!(dwScrollBars & ES_AUTOHSCROLL);
			return FALSE;
		}

		fEnabledOld = _fHScrollEnabled;
		lScroll = ConvertXPosToScrollPos(_xScroll);

        if(_xWidth <= _xWidthView)
            fEnabled = FALSE;
	}

	// !s beforehand because all true values aren't necessarily equal
	if(!fEnabled != !fEnabledOld)
	{
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
		{
			if (nBar == SB_HORZ)
				_fHScrollEnabled = fEnabled;
			else
				_fVScrollEnabled = fEnabled;
		}

		if(!_fDeferUpdateScrollBar)
		{
    		if(!fHide)					// Don't hide scrollbar, just disable
    			_ped->TxEnableScrollBar(nBar, fEnabled ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);
    		else 
    		{
    			fReturn = TRUE;
    			// Make sure to hide caret before showing scrollbar
    			if(psel)
    				psel->ShowCaret(FALSE);

    			// Hide or show scroll bar
    			_ped->TxShowScrollBar(nBar, fEnabled);

    			if(psel)
    				psel->ShowCaret(TRUE);
            }
		}
	}
	
	// Set scrollbar range and thumb position
	if(fEnabled)
	{
        if(fUpdateRange)
        {
			if(!_fDeferUpdateScrollBar)
				_ped->TxSetScrollRange(nBar, 0, GetScrollRange(nBar), FALSE);
        }
        
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
			_ped->TxSetScrollPos(nBar, lScroll, TRUE);
	}
	else if (!_fDeferUpdateScrollBar)
	{
		// This turns off the scroll bar and only needs to happen when a change 
		// occurs so we can count on the change in state check above to set
		// _fUpdateScrollBarDeferred.
		if (!fEnabled && fEnabledOld)
			_ped->TxSetScrollRange(nBar, 0, 0, FALSE);
	}
	return fReturn;
}

BOOL CDisplaySL::IsMain() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::IsMain");

    return TRUE;
}

LONG CDisplaySL::GetMaxWidth() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetMaxWidth");

    return 0;
}

LONG CDisplaySL::GetMaxPixelWidth() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetMaxPixelWidth");

    return GetViewWidth();
}

LONG CDisplaySL::GetMaxHeight() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetMaxHeight");

    return 0;
}

LONG CDisplaySL::GetWidth() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetWidth");

    return CLine::_xWidth + CLine::_xLineOverhang;
}

LONG CDisplaySL::GetHeight() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetHeight");

    return CLine::_yHeight;
}

LONG CDisplaySL::GetResizeHeight() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetResizeHeight");

    return CLine::_yHeight;
}

LONG CDisplaySL::LineCount() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::LineCount");

    return 1; 
}

/*
 *	CDisplaySL::GetCliVisible()
 *
 *	@mfunc
 *		Get count of visible lines and update GetCp()MostVisible for PageDown()
 *
 *	@rdesc
 *		count of visible lines
 */
LONG CDisplaySL::GetCliVisible (
	LONG* pcpMostVisible,				//@parm Returns cpMostVisible
	BOOL fLastCharOfLastVisible) const 	//@parm Want cp of last visible char
										// (ignored here).
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetCliVisible");

    if (pcpMostVisible)
        *pcpMostVisible = CLine::_cch;
    
    return 1;
}

LONG CDisplaySL::GetFirstVisibleLine() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetFirstVisibleLine");

    return 0;
}

/*
 *	CDisplaySL::GetLineText(ili, pchBuff, cchMost)
 *
 *	@mfunc
 *		Copy given line of this display into a character buffer
 *
 *	@rdesc
 *		number of character copied
 */
LONG CDisplaySL::GetLineText (
	LONG	ili,		//@parm Line to get text of
	TCHAR *	pchBuff,	//@parm Buffer to stuff text into
	LONG	cchMost)	//@parm Length of buffer
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetLineText");

    if(ili == 0)
    {
        cchMost = min(cchMost, _ped->GetTextLength());
        if(cchMost > 0)
        {
            CTxtPtr tp(_ped, 0);
            return tp.GetText( cchMost, pchBuff );
        }
    }
    return 0;
}

/*
 *	CDisplaySL::CpFromLine(ili, pyHeight)
 *
 *	@mfunc
 *		Computes cp at start of given line 
 *		(and top of line position relative to this display)
 *
 *	@rdesc
 *		cp of given line; here always 0
 */
LONG CDisplaySL::CpFromLine (
	LONG ili,		//@parm Line we're interested in (if <lt> 0 means caret line)
	LONG *pyLine)	//@parm Returns top of line relative to display 
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::CpFromLine");
					//  	(NULL if don't want that info)
    Assert( ili == 0 );
    
    if(pyLine)
        *pyLine = 0;
    
    return 0;
}

/*
 *	CDisplaySL::LineFromCp(cp, fAtEnd)
 *
 *	@mfunc
 *		Computes line containing given cp.
 *
 *	@rdesc
 *		index of line found; here returns 0 always
 */
LONG CDisplaySL::LineFromCp(
	LONG cp,		//@parm cp to look for
	BOOL fAtEnd)	//@parm If true, return previous line for ambiguous cp
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::LineFromCp");

    return 0;
}

/*
 *	CDisplaySL::CpFromPoint(pt, prcClient, ptp, prp, fAllowEOL, pHit, pdispdim)
 *
 *	@mfunc
 *		Determine cp at given point
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		Computed cp, -1 if failed
 */
LONG CDisplaySL::CpFromPoint(
	POINT		pt,			//@parm Point to compute cp at (client coords)
	const RECT *prcClient,	//@parm Client rectangle (can be NULL if active).
	CRchTxtPtr * const ptp,	//@parm Returns text pointer at cp (may be NULL)
	CLinePtr * const prp,	//@parm Returns line pointer at cp (may be NULL)
	BOOL		fAllowEOL,	//@parm Click at EOL returns cp after CRLF
	HITTEST *	phit,		//@parm Out parm for hit-test value
	CDispDim *	pdispdim,	//@parm Out parm for display dimensions
	LONG	   *pcpActual)	//@parm Out cp that pt is above
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::CpFromPoint");

    RECT  rcView;
	LONG cp = 0;
	LONG cch = 0;

	HITTEST		hit = HT_Nothing;

    GetViewRect(rcView, prcClient);

	if (pt.y >= rcView.top && pt.y <= rcView.bottom)
	{

		// Create measurer at cp(0)
		CMeasurer me(this);

		// Get character in the line
		pt.x += _xScroll - rcView.left;		// Transform to galley coordinates
		pt.y -= rcView.top;
		cch = CLine::CchFromXpos(me, pt, pdispdim, &hit, pcpActual);

		// Don't allow click at EOL to select EOL marker and take into account
		// single line edits as well
		if(!fAllowEOL && cch == CLine::_cch && CLine::_cchEOP)
			me._rpTX.BackupCpCRLF();

		cp = me.GetCp();
	}

	if (phit)
		*phit = hit;
    if(ptp)
        ptp->SetCp(cp);
    if(prp)
        prp->RpSet(0, cch);
 
 	return cp;   
}

/*
 *	CDisplaySL::PointFromTp(tp, fAtEnd, pt, prp, taMode, pdx)
 *
 *	@mfunc
 *		Determine coordinates at given tp
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		line index at cp, -1 if error
 */
LONG CDisplaySL::PointFromTp(
	const CRchTxtPtr &rtp,	//@parm Text ptr to get coordinates at
	const RECT *prcClient,	//@parm Client rectangle (can be NULL if active).
	BOOL		fAtEnd,		//@parm Return end of previous line for ambiguous cp
	POINT &		pt,			//@parm Returns point at cp in client coords
	CLinePtr * const prp,	//@parm Returns line pointer at tp (may be null)
	UINT		taMode,		//@parm Text Align mode: top, baseline, bottom
	CDispDim *	pdispdim)	//@parm Out parm for display dimensions
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::PointFromTp");

	LONG	 dy = 0;
    RECT	 rcView;
    CLinePtr rp(this);

    if(!rp.RpSetCp(rtp.GetCp(), fAtEnd))
        return -1;

    AssertSz(_ped->_fInPlaceActive || prcClient, 
		"CDisplaySL::PointFromTp() called with invalid client rect");

    GetViewRect(rcView, prcClient);

    pt.x = rcView.left - _xScroll;
    pt.y = rcView.top;

    CMeasurer me(this, rtp);
    me.Advance(-rp.RpGetIch());		// Backup to start of line      
    me.NewLine(*rp);				// Measure from there to where we are

	pt.x += CLine::XposFromCch(me, rp.RpGetIch(), taMode, pdispdim, &dy);
	pt.y += dy;

    if(prp)
        *prp = rp;
    return rp;
}

/*
 *	CDisplaySL::UpdateView(&tpFirst, cchOld, cchNew)
 *
 *	@mfunc
 *		Update visible part of display (the "view" on the screen).
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplaySL::UpdateView(
	const CRchTxtPtr &tpFirst,	//@parm Text ptr where change happened
	LONG cchOld,				//@parm Count of chars deleted
	LONG cchNew)				//@parm Count of chars inserted
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::UpdateView");

    BOOL fUpdateScrollBarHorz = FALSE;
    BOOL fReturn = TRUE;
    RECT rcView;
	CTxtSelection *psel = _ped->GetSelNC();
	LONG xWidthOld = _xWidth + _xLineOverhang;
	BOOL fScrollChanged = FALSE;
	RECT rcClient;
	RECT rc;
	LONG yHeightOld = _yHeight;
                                                              
    if (_fNoUpdateView)
        return fReturn;

	AssertSz(_ped->_fInPlaceActive, "CDisplaySL::UpdateView(...) called when inactive");

    _ped->TxGetClientRect(&rcClient);

    GetViewRect(rcView, &rcClient);
    
    if(psel && !psel->PuttingChar())
        psel->ClearCchPending();

    if(!RecalcLine())
    {
        // We're in trouble now, the recalc failed. Let's try to get
		// out of this with our head still mostly attached
        fReturn = FALSE;
    }

	// An update has occurred. If it isn't already off screen make it
	// off screen so that there is no flicker.
	if(!(_bFlags & fliUseOffScreenDC))
		_bFlags |= (fliUseOffScreenDC | fliOffScreenOnce);

    if(_xWidth <= _xWidthView)
    {
        // x scroll range is smaller than the view width
        // force x scrolling position = 0
        _xScroll = 0;
		SetCpFirstVisible(0);
		_fViewChanged = TRUE;
        fUpdateScrollBarHorz = TRUE;
    }

	_fRectInvalid = TRUE;

	// Only resize a Single Line edit control if the width changes
	if(_xWidth + _xLineOverhang != xWidthOld)
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
	}

	// If view changed, update scroll bars
    if(_fViewChanged)
	{
		_fViewChanged = FALSE;
        fScrollChanged = UpdateScrollBar(SB_HORZ);
	}

	if(!fScrollChanged)
	{
		// Scroll bar state did not change so we need to update screen
		// Build an invalidation rectangle. 
		rc = rcClient;
		if(yHeightOld == _yHeight)
		{
			// Height of control did not change so we can minimize the update 
			// rectangle to the height of the control.
			rc.bottom = rcView.top + _yHeight;
		}

		// Tell display to update when it gets a chance
		_ped->TxInvalidateRect(&rc, FALSE);
	}
    return fReturn;
}


/*
 *	CDisplaySL::ScrollView(xScroll, yScroll, fTracking, fFractionalScroll)
 *
 *	@mfunc
 *		Scroll view to new x and y position
 *
 *	@devnote
 *		This method tries to adjust the y scroll pos before
 *		scrolling to display complete line at top. x scroll 
 *		pos is adjusted to avoid scrolling all text off the 
 *		view rectangle.
 *
 *		Must be able to handle yScroll <gt> pdp->yHeight and yScroll <lt> 0
 *
 *	@rdesc
 *		TRUE if actual scrolling occurred, 
 *		FALSE if no change
 */
BOOL CDisplaySL::ScrollView (
	LONG xScroll,		//@parm New x scroll position
	LONG yScroll,		//@parm New y scroll position
	BOOL fTracking,		//@parm TRUE indicates we are tracking scrollbar thumb
	BOOL fFractionalScroll)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::ScrollView");
						//		(don't update the scrollbar pos)
	RECT rcUpdate;      // ??? we may want use a region here but ScrollView is 
                        // rarely called with both a xScroll and yScroll value.
	LONG xWidthMax;
	LONG dx = 0;
    RECT rcView;
	CTxtSelection *psel = _ped->GetSelNC();
	COleObject *pipo;

    AssertSz(_ped->_fInPlaceActive, "CDisplaySL::ScrollView() called when not in-place");
	
	if(xScroll == -1)
		return FALSE;

    GetViewRect(rcView);
	
	// Determine horizontal scrolling pos.
	xWidthMax = _xWidth;
	xScroll = min(xScroll, xWidthMax);
	xScroll = max(0, xScroll);

	dx = _xScroll - xScroll;
	if(dx)
    {
		_xScroll = xScroll;

		// Calculate new first visible
		CMeasurer me(this);				// Create measurer at cp(0)
		POINT pt = {xScroll, 0};
		CDispDim dispdim;
		HITTEST Hit;
		LONG	cpActual;
		CLine::CchFromXpos(me, pt, &dispdim, &Hit, &cpActual);
		
		SetCpFirstVisible(cpActual);	// Save character position
    }

	AssertSz(IsMain(), "CDisplaySL::ScrollView non-main SL control");

	// Now perform the actual scrolling
	if(dx)
	{
		if(!_fRectInvalid)
		{
			// Scroll only if scrolling < view dimensions and we are in-place
			// Note that we only scroll the active view and we can be in-place
			// active and have multiple inactive views.
			if(IsActive() && !IsTransparent() && dx < _xWidthView)
			{
				if(psel)
					psel->ShowCaret(FALSE);

				_ped->TxScrollWindowEx((INT) dx, 0, NULL, &rcView,
						NULL, &rcUpdate, 0);

				_ped->TxInvalidateRect(&rcUpdate, FALSE);
				if(psel)
					psel->ShowCaret(TRUE);
			}
			else
				_ped->TxInvalidateRect(&rcView, FALSE);
		}

		if(psel)
			psel->UpdateCaret(FALSE);

		if(!fTracking && dx)
		{		
			_ped->SendScrollEvent(EN_HSCROLL);
			UpdateScrollBar(SB_HORZ);
		}
				
		_ped->TxUpdateWindow();

		// FUTURE: since we're now repositioning in place active 
		// objects every time we draw, this call seems to be 
		// superfluous (AndreiB)

		// Tell object subsystem to reposition any in place objects
		if(_ped->GetObjectCount())
		{
			pipo = _ped->GetObjectMgr()->GetInPlaceActiveObject();
			if(pipo)
				pipo->OnReposition(dx, 0);
		}
	}
	return dx;
}

/*
 *	CDisplaySL::InvertRange(cp, cch, selAction)
 *
 *	@mfunc
 *		Invert a given range on screen (for selection)
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplaySL::InvertRange (
	LONG	cp,					//@parm Active end of range to invert
	LONG	cch,				//@parm Signed length of range
	SELDISPLAYACTION selAction)	//@parm What we are doing to the selection
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::InvertRange");

	RECT     rcView;
	RECT	 rc;

	if(cch < 0)						//make cch negative, make cp the minimum
		cch = -cch;
	else
		cp -= cch;

#ifdef LINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif

	// If display is frozen, just update recalc region and move on.
	if(_padc)
	{
		AssertSz(cp >= 0, "CDisplayML::InvertRange: range (cp) goes below"
				"zero!!" );
		// Make sure these values are bounded.
		if(cp > _ped->GetTextLength())	// Don't bother updating region;
			return TRUE;				//  it's out of bounds

		if(cp + cch > _ped->GetTextLength())
			cch -= cp + cch - _ped->GetTextLength();

		_padc->UpdateRecalcRegion(cp, cch, cch);
		return TRUE;
	}

	// Ensure all visible lines are recalced
	if(!WaitForRecalcView())
		return FALSE;

	//REVIEW (keithcu) CDisplayML::InvertRange() has a different order WRT
	//frozen displays and OLE objects.
	
	// If an object is being inverted, and that is all that
	// is being inverted, delegate to the ObjectMgr.
	if (cch == 1 && _ped->GetObjectCount() &&
		(selAction == selSetNormal || selAction == selSetHiLite) )
	{
		CObjectMgr* pobjmgr = _ped->GetObjectMgr();
		CTxtPtr		tp(_ped, cp);

		if(tp.GetChar() == WCH_EMBEDDING && pobjmgr)
			pobjmgr->HandleSingleSelect(_ped, cp, selAction == selSetHiLite);
	}

	// Get view rectangle
    AssertSz(_ped->_fInPlaceActive,
		"CDisplaySL::InvertRange() called when not in-place active");

	_ped->TxGetClientRect(&rc);
    GetViewRect(rcView, &rc);
	_ped->TxInvalidateRect(NULL, FALSE);
	return TRUE;
}

/*
 *	CDisplaySL::InitLinePtr (&lp)
 *
 *	@mfunc
 *		Initialize a CLinePtr properly
 */
void CDisplaySL::InitLinePtr (
	CLinePtr & lp )		//@parm Ptr to line to initialize
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::InitLinePtr");

    lp.Init(*this);
}

/*
 *	CDisplaySL::GetNaturalSize(hdcDraw, hicTarget, dwMode, pwidth, pheight)
 *
 *	@mfunc
 *		Recalculate display to input width & height
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 */
HRESULT	CDisplaySL::GetNaturalSize(
	HDC	  hdcDraw,		//@parm DC for drawing
	HDC	  hicTarget,	//@parm DC for information
	DWORD dwMode,		//@parm Type of natural size required
	LONG *pwidth,		//@parm Input/output width parm 
	LONG *pheight)		//@parm	Input/output height parm
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetNaturalSize");

	// Assume this won't work
	HRESULT hr = E_FAIL;

	// Set height temporarily so zoom factor will work out
	LONG yOrigHeightClient = SetClientHeight(*pheight);

	// Adjust height and width by view inset
	LONG widthView  = *pwidth;
	LONG heightView = *pheight;
	GetViewDim(widthView, heightView);

	// Store adjustment so we can restore it to height & width
	LONG widthAdj  = *pwidth  - widthView;
	LONG heightAdj = *pheight - heightView;

	// Recalculate size needed
   	// Create a measurer starting at cp = 0
	CMeasurer me(this);
	CLine	  liNew;

	if(liNew.Measure(me, -1, -1, MEASURE_FIRSTINPARA))
	{
		*pwidth  = liNew._xWidth + liNew._xLineOverhang;
		*pheight = liNew._yHeight;
		hr = S_OK;
	}	

	// Restore insets so output reflects true client rect needed
	*pwidth  += widthAdj + dxCaret;
	*pheight += heightAdj;

	// Restore client height to match current cache
	SetClientHeight(yOrigHeightClient);
    return hr;
}

/*
 *	CDisplaySL::GetWordWrap()
 *
 *	@mfunc
 *		Gets the wrap flag  
 *
 *	@rdesc
 *		TRUE - Word wrap
 *		FALSE - No word Word wrap
 *
 *	@devnote
 *		Single line controls cannot word wrap.
 */
BOOL CDisplaySL::GetWordWrap() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetNoWrap");

	return FALSE;
}

/*
 *	CDisplaySL::Clone()
 *
 *	@mfunc
 *		Make a copy of this object
 *
 *	@rdesc
 *		NULL - failed
 *		CDisplay *
 */
CDisplay *CDisplaySL::Clone() const
{
	CDisplaySL *pdp = new CDisplaySL(_ped);
	if(pdp)
	{
		// Initialize our base class
		if(pdp->CDisplay::Init())
		{
			pdp->InitFromDisplay(this);

			// Setting scroll to 0 means use the first visible character
			pdp->_xScroll = CALC_XSCROLL_FROM_FIRST_VISIBLE;
			pdp->_fVScrollEnabled = _fVScrollEnabled;
			pdp->_fWordWrap = _fWordWrap;
			pdp->ResetDrawInfo(this);
			pdp->SetCpFirstVisible(GetFirstVisibleCp());

			// This can't be active view since it is a clone of some view
			pdp->SetActiveFlag(FALSE);
		}
	}
	return pdp;
}

/*
 *	CDisplaySL::GetMaxXScroll()
 *
 *	@mfunc
 *		Get the maximum x scroll value
 *
 *	@rdesc
 *		Maximum x scroll value
 *
 */
LONG CDisplaySL::GetMaxXScroll() const
{
	return _xWidth + dxCaret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\doc.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module DOC.C	CTxtStory and CTxtArray implementation |
 *	
 *	Original Authors: <nl>
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini	<nl>
 *		Murray Sargent <nl>
 *
 *	History: <nl>
 *		6/25/95	alexgo	Cleanup and reorganization
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_doc.h"
#include "_format.h"

ASSERTDATA

// ===========================  Invariant stuff  ======================

#define DEBUG_CLASSNAME CTxtArray
#include "_invar.h"

// ========================  CTxtArray class  =========================

#ifdef DEBUG

/*
 *	CTxtArray::Invariant
 *
 *	@mfunc	Tests CTxtArray's state
 *
 *	@rdesc	Returns TRUE always; failures are indicated by Asserts
 *			Actually in this routine, we return count of chars in blocks
 *			since we need this value for one check.
 */
BOOL CTxtArray::Invariant() const
{
	static LONG	numTests = 0;
	numTests++;				// How many times we've been called.

	LONG cch = 0;
	LONG iMax = Count();

	if(iMax > 0)
	{
		CTxtBlk *ptb = Elem(0);

		// ptb shouldn't be NULL since we're within Count elements
		Assert(ptb);

		for(LONG i = 0; i < iMax; i++, ptb++)
		{
			LONG cchCurr = ptb->_cch;
			cch += cchCurr;
			
			Assert ( cchCurr >= 0 );
			Assert ( cchCurr <= CchOfCb(ptb->_cbBlock) );

			// While we're here, check range of interblock gaps
			Assert (ptb->_ibGap >= 0);
			Assert (ptb->_ibGap <= ptb->_cbBlock);

			LONG cchGap = CchOfCb(ptb->_ibGap);
			Assert ( cchGap >= 0 );
			Assert ( cchGap <= cchCurr );
		}
	}
	return cch;
}

#endif	// DEBUG

/*
 *	CTxtArray::CTxtArray()
 *	
 *	@mfunc		Text array constructor
 *	
 */
CTxtArray::CTxtArray() : CArray<CTxtBlk> ()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::CTxtArray()");

	AssertSz(CchOfCb(cbBlockMost) - cchGapInitial >= cchBlkInitmGapI * 2, 
		"cchBlockMax - cchGapInitial must be at least (cchBlockInitial - cchGapInitial) * 2");

	Assert(!_cchText && !_iCF && !_iPF);
	// Make sure we have no data to initialize
	Assert(sizeof(CTxtArray) == sizeof(CArray<CTxtBlk>) + sizeof(_cchText) + 2*sizeof(_iCF));
}

/*
 *	CTxtArray::~CTxtArray
 *	
 *	@mfunc		Text array destructor
 */
CTxtArray::~CTxtArray()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::~CTxtArray");

	LONG itb = Count();
	while(itb--)
	{
		Assert(Elem(itb) != NULL);
		Elem(itb)->FreeBlock();
	}
}

/*
 *	CTxtArray::CalcTextLength()
 *	
 *	@mfunc		Computes and return length of text in this text array
 *
 *	@rdesc		Count of character in this text array
 *
 *	@devnote	This call may be computationally expensive; we have to
 *				sum up the character sizes of all of the text blocks in
 *				the array.
 */
LONG CTxtArray::CalcTextLength() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::GetCch");

	_TEST_INVARIANT_
		
	LONG itb = Count();
	if(!itb)
		return 0;

	LONG	 cch;
	CTxtBlk *ptb = Elem(0);

	for(cch = 0; itb--; ptb++) 
		cch += ptb->_cch;

	return cch;
}

/*
 *	CTxtArray::AddBlock(itbNew, cb)
 *	
 *	@mfunc		create new text block
 *	
 *	@rdesc
 *		FALSE if block could not be added
 *		non-FALSE otherwise
 *	
 *	@comm 
 *	Side Effects:  
 *		moves text block array
 */
BOOL CTxtArray::AddBlock(
	LONG	itbNew,		//@parm	index of the new block 
	LONG	cb)			//@parm size of new block; if <lt>= 0, default is used
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::AddBlock");

	_TEST_INVARIANT_

	CTxtBlk *ptb;

	if(cb <= 0)
		cb = cbBlockInitial;

	AssertSz(cb > 0, "CTxtArray::AddBlock() - adding block of size zero");
	AssertSz(cb <= cbBlockMost, "CTxtArray::AddBlock() - block too big");

	ptb = Insert(itbNew, 1);

	if(!ptb || !ptb->InitBlock(cb))
	{	
		TRACEERRSZSC("TXTARRAT::AddBlock() - unable to allocate new block", E_OUTOFMEMORY);
		return FALSE;
	}
	return TRUE;
}

/*
 *	CTxtArray::SplitBlock(itb, ichSplit, cchFirst, cchLast, fStreaming)
 *	
 *	@mfunc		split a text block into two
 *	
 *	@rdesc
 *		FALSE if the block could not be split <nl>
 *		non-FALSE otherwise
 *	
 *	@comm
 *	Side Effects: <nl>
 *		moves text block array
 */
BOOL CTxtArray::SplitBlock(
	LONG itb, 			//@parm	index of the block to split
	LONG ichSplit,	 	//@parm	character index within block at which to split
	LONG cchFirst, 		//@parm desired extra space in first block
	LONG cchLast, 		//@parm desired extra space in new block
	BOOL fStreaming)	//@parm TRUE if streaming in new text
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::SplitBlock");

	_TEST_INVARIANT_

	LPBYTE pbSrc;
	LPBYTE pbDst;
	CTxtBlk *ptb, *ptb1;

	AssertSz(ichSplit > 0 || cchFirst > 0, "CTxtArray::SplitBlock(): splitting at beginning, but not adding anything");

	AssertSz(itb >= 0, "CTxtArray::SplitBlock(): negative itb");
	ptb = Elem(itb);

	// compute size for first half

	AssertSz(cchFirst + ichSplit <= CchOfCb(cbBlockMost),
		"CTxtArray::SplitBlock(): first size too large");
	cchFirst += ichSplit + cchGapInitial;
	cchFirst = min(cchFirst, CchOfCb(cbBlockMost));

	// compute size for second half

	AssertSz(cchLast + ptb->_cch - ichSplit <= CchOfCb(cbBlockMost),
		"CTxtArray::SplitBlock(): second size too large");
	cchLast += ptb->_cch - ichSplit + cchGapInitial;
	cchLast = min(cchLast, CchOfCb(cbBlockMost));

	// Allocate second block and move text to it
	
	// If streaming in, allocate a block that's as big as possible so that
	// subsequent additions of text are faster. We always fall back to
	// smaller allocations so this won't cause unnecessary errors. When
	// we're done streaming we compress blocks, so this won't leave	a
	// big empty gap.  NOTE: ***** moves rgtb *****
	if(fStreaming)
	{
		LONG cb = cbBlockMost;
		const LONG cbMin = CbOfCch(cchLast);

		while(cb >= cbMin && !AddBlock(itb + 1, cb))
			cb -= cbBlockCombine;
		if(cb >= cbMin)
			goto got_block;
	}
	if(!AddBlock(itb + 1, CbOfCch(cchLast)))
	{
		TRACEERRSZSC("CTxtArray::SplitBlock(): unabled to add new block", E_FAIL);
		return FALSE;
	}

got_block:
	ptb1 = Elem(itb+1);	// recompute ptb after rgtb moves
	ptb = Elem(itb);	// recompute ptb after rgtb moves
	ptb1->_cch = ptb->_cch - ichSplit;
	ptb1->_ibGap = 0;
	pbDst = (LPBYTE) (ptb1->_pch - ptb1->_cch) + ptb1->_cbBlock;
	ptb->MoveGap(ptb->_cch); // make sure pch points to a continuous block of all text in ptb.
	pbSrc = (LPBYTE) (ptb->_pch + ichSplit);
	CopyMemory(pbDst, pbSrc, CbOfCch(ptb1->_cch));
	ptb->_cch = ichSplit;
	ptb->_ibGap = CbOfCch(ichSplit);

	// Resize first block
	if(CbOfCch(cchFirst) != ptb->_cbBlock)
	{
//$ FUTURE: don't resize unless growing or shrinking considerably
		if(!ptb->ResizeBlock(CbOfCch(cchFirst)))
		{
			TRACEERRSZSC("TXTARRA::SplitBlock(): unabled to resize block", E_OUTOFMEMORY);
			return FALSE;
		}
	}
	return TRUE;
}

/*
 *	CTxtArray::ShrinkBlocks()
 *	
 *	@mfunc		Shrink all blocks to their minimal size
 */
void CTxtArray::ShrinkBlocks()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::ShrinkBlocks");

	_TEST_INVARIANT_

	LONG itb = Count();
	CTxtBlk *ptb;

	while(itb--)
	{
		ptb = Elem(itb);
		Assert(ptb);
		ptb->ResizeBlock(CbOfCch(ptb->_cch));
	}
}

/*
 *	CTxtArray::RemoveBlocks(itbFirst, ctbDel)
 *	
 *	@mfunc		remove a range of text blocks
 *	
 *	@rdesc
 *		nothing
 *	
 *	@comm Side Effects: <nl>
 *		moves text block array
 */
void CTxtArray::RemoveBlocks(
	LONG itbFirst, 		//@parm index of first block to remove
	LONG ctbDel)			//@parm	number of blocks to remove
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::RemoveBlocks");

	_TEST_INVARIANT_

	LONG itb = itbFirst;
	LONG ctb = ctbDel;

	AssertSz(itb + ctb <= Count(), "CTxtArray::RemoveBlocks(): not enough blocks");

	while(ctb--)
	{
		Assert(Elem(itb) != NULL);
		Elem(itb++)->FreeBlock();
	}
	
	Remove(itbFirst, ctbDel);
}

/*
 *	CTxtArray::CombineBlocks(itb)
 *	
 *	@mfunc		combine adjacent text blocks
 *	
 *	@rdesc
 *		nothing
 *	
 *	@comm 
 *	Side Effects: <nl>
 *		moves text block array
 *	
 *	@devnote
 *		scans blocks from itb - 1 through itb + 1 trying to combine
 *		adjacent blocks
 */
void CTxtArray::CombineBlocks(
	LONG itb)		//@parm	index of the first block modified
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::CombineBlocks");

	_TEST_INVARIANT_

	LONG ctb;
	LONG cbT;
	CTxtBlk *ptb, *ptb1;

	if(itb > 0)
		itb--;

	ctb = min(3, Count() - itb);
	if(ctb <= 1)
		return;

	for(; ctb > 1; ctb--)
	{
		ptb  = Elem(itb);							// Can we combine current
		ptb1 = Elem(itb+1);							//  and next blocks ?
		cbT = CbOfCch(ptb->_cch + ptb1->_cch + cchGapInitial);
		if(cbT <= cbBlockInitial)
		{											// Yes
			if(cbT != ptb->_cbBlock && !ptb->ResizeBlock(cbT))
				continue;
			ptb ->MoveGap(ptb->_cch);				// Move gaps at ends of
			ptb1->MoveGap(ptb1->_cch);				//  both blocks
			CopyMemory(ptb->_pch + ptb->_cch,		// Copy next block text
				ptb1->_pch,	CbOfCch(ptb1->_cch));	//  into current block
			ptb->_cch += ptb1->_cch;
			ptb->_ibGap += CbOfCch(ptb1->_cch);
			RemoveBlocks(itb+1, 1);					// Remove next block
		}
		else
			itb++;
	}
}

/*
 *	CTxtArray::GetChunk(ppch, cch, pchChunk, cchCopy)
 *	
 *	@mfunc
 *		Get content of text chunk in this text array into a string	
 *	
 *	@rdesc
 *		remaining count of characters to get
 */
LONG CTxtArray::GetChunk(
	TCHAR **ppch, 			//@parm ptr to ptr to buffer to copy text chunk into
	LONG cch, 				//@parm length of pch buffer
	TCHAR *pchChunk, 		//@parm ptr to text chunk
	LONG cchCopy) const	//@parm count of characters in chunk
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::GetChunk");

	_TEST_INVARIANT_

	if(cch > 0 && cchCopy > 0)
	{
		if(cch < cchCopy)
			cchCopy = cch;						// Copy less than full chunk
		CopyMemory(*ppch, pchChunk, cchCopy*sizeof(TCHAR));
		*ppch	+= cchCopy;						// Adjust target buffer ptr
		cch		-= cchCopy;						// Fewer chars to copy
	}
	return cch;									// Remaining count to copy
}

const CCharFormat* CTxtArray::GetCharFormat(LONG iCF)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtArray::GetCharFormat");

	const CCharFormat *	pCF;
	
	if(iCF < 0)
		iCF = _iCF;
	Assert(iCF >= 0);

	if(FAILED(GetCharFormatCache()->Deref(iCF, &pCF)))
	{
		AssertSz(FALSE, "CTxtArray::GetCharFormat: couldn't deref iCF");
		pCF = NULL;
	}
	return pCF;
}

const CParaFormat* CTxtArray::GetParaFormat(LONG iPF)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtArray::GetParaFormat");

	const CParaFormat *	pPF;
	
	if(iPF < 0)
		iPF = _iPF;
	Assert(iPF >= 0);

	if(FAILED(GetParaFormatCache()->Deref(iPF, &pPF)))
	{
		AssertSz(FALSE, "CTxtArray::GetParaFormat: couldn't deref iPF");
		pPF = NULL;
	}
	return pPF;
}


// ========================  CTxtBlk class  =================================
/*
 *	CTxtBlk::InitBlock(cb)
 *	
 *	@mfunc
 *		Initialize this text block
 *
 *	@rdesc
 *		TRUE if success, FALSE if allocation failed
 */
BOOL CTxtBlk::InitBlock(
	LONG cb)			//@parm	initial size of the text block
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::InitBlock");

	_pch	= NULL;
	_cch	= 0;
	_ibGap	= 0;
	_cbBlock= cb;

	if(cb)
		_pch = (TCHAR*)PvAlloc(cb, GMEM_ZEROINIT);
	return _pch != 0;
}

/*
 *	CTxtBlk::FreeBlock()
 *	
 *	@mfunc
 *		Free this text block
 *	
 *	@rdesc
 *		nothing
 */
VOID CTxtBlk::FreeBlock()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::FreeBlock");

	FreePv(_pch);
	_pch	= NULL;
	_cch	= 0;
	_ibGap	= 0;
	_cbBlock= 0;
}

/*
 *	CTxtBlk::MoveGap(ichGap)
 *	
 *	@mfunc
 *		move gap in this text block
 *	
 *	@rdesc
 *		nothing
 */
void CTxtBlk::MoveGap(
	LONG ichGap)			//@parm	new position for the gap
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::MoveGap");

	LONG cbMove;
	LONG ibGapNew = CbOfCch(ichGap);
	LPBYTE pbFrom = (LPBYTE) _pch;
	LPBYTE pbTo;

	if(ibGapNew == _ibGap)
		return;

	if(ibGapNew < _ibGap)
	{
		cbMove = _ibGap - ibGapNew;
		pbFrom += ibGapNew;
		pbTo = pbFrom + _cbBlock - CbOfCch(_cch);
	}
	else
	{
		cbMove = ibGapNew - _ibGap;
		pbTo = pbFrom + _ibGap;
		pbFrom = pbTo + _cbBlock - CbOfCch(_cch);
	}

	MoveMemory(pbTo, pbFrom, cbMove);
	_ibGap = ibGapNew;
}


/*
 *	CTxtBlk::ResizeBlock(cbNew)
 *	
 *	@mfunc
 *		resize this text block
 *	
 *	@rdesc	
 *		FALSE if block could not be resized <nl>
 *		non-FALSE otherwise
 *	
 *	@comm
 * 	Side Effects: <nl>
 *		moves text block
 */
BOOL CTxtBlk::ResizeBlock(
	LONG cbNew)		//@parm	the new size
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::ResizeBlock");

	TCHAR *pch;
	LONG cbMove;

	AssertSz(cbNew > 0, "resizing block to size <= 0");
	AssertSz(cbNew <= cbBlockMost, "CTxtBlk::ResizeBlock() - block too big");

	if(cbNew < _cbBlock)
	{
		if(_ibGap != CbOfCch(_cch))
		{
			// move text after gap down so that it doesn't get dropped

			cbMove = CbOfCch(_cch) - _ibGap;
			pch = _pch + CchOfCb(_cbBlock - cbMove);
			MoveMemory(pch - CchOfCb(_cbBlock - cbNew), pch, cbMove);
		}
		_cbBlock = cbNew;
	}
	pch = (TCHAR*)PvReAlloc(_pch, cbNew);
	if(!pch)
		return _cbBlock == cbNew;	// FALSE if grow, TRUE if shrink

	_pch = pch;
	if(cbNew > _cbBlock)
	{
		if(_ibGap != CbOfCch(_cch))		// Move text after gap to end so that
		{								// we don't end up with two gaps
			cbMove = CbOfCch(_cch) - _ibGap;
			pch += CchOfCb(_cbBlock - cbMove);
			MoveMemory(pch + CchOfCb(cbNew - _cbBlock), pch, cbMove);
		}
		_cbBlock = cbNew;
	}
	return TRUE;
}


// ========================  CTxtStory class  ============================
/* 
 *	CTxtStory::CTxtStory
 *
 *	@mfunc	Constructor
 *
 *	@devnote	Automatically allocates a text array.  If we want to have a
 *	completely empty edit control, then don't allocate a story.  NB!
 *	
 */
CTxtStory::CTxtStory()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtStory::CTxtStory");

	_pCFRuns = NULL;
	_pPFRuns = NULL;
}

/*
 *	CTxtStory::~CTxtStory
 *
 *	@mfunc	Destructor
 */
CTxtStory::~CTxtStory()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtStory::~CTxtStory");

	// Remove formatting.
	DeleteFormatRuns();
}

/*
 *	DeleteRuns ()
 *
 *	@mfunc
 *		Helper function for DeleteFormatRuns() below.  Releases
 *		formats used by format run collection before deleting the
 *		collection
 */
void DeleteRuns(CFormatRuns *pRuns, IFormatCache *pf)
{
    if(pRuns)									// Format runs may exist
	{
		LONG n = pRuns->Count();
		if(n)
		{
			CFormatRun *pRun = pRuns->Elem(0);
			for( ; n--; pRun++)
				pf->Release(pRun->_iFormat);	// Free run's format
		}
        delete pRuns;
	}	
}

/*
 *	CTxtStory::DeleteFormatRuns ()
 *
 *	@mfunc	Convert to plain - remove format runs
 */
void CTxtStory::DeleteFormatRuns()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtStory::ConvertToPlain");

	DeleteRuns(_pCFRuns, GetCharFormatCache());
	DeleteRuns(_pPFRuns, GetParaFormatCache());

	_pCFRuns = NULL;
	_pPFRuns = NULL;
}


#ifdef DEBUG
//This dumps the contents of the CTxtStory
//TxtBlk & FormatRun arrays to the debug output.
void CTxtStory::DbgDumpStory(void)
{
	CTxtBlk * pblk;
	CFormatRun * pcfr;
	CFormatRun * ppfr;
	LONG ctxtr = 0;
	LONG ccfr = 0;
	LONG cpfr = 0;
	LONG i;

	ctxtr = _TxtArray.Count();

	if (_pCFRuns)
		ccfr = _pCFRuns->Count();
	if (_pPFRuns)
		cpfr = _pPFRuns->Count();

	for(i = 0; i < ctxtr; i++)
	{
		pblk = (CTxtBlk*)_TxtArray.Elem(i);
		Tracef(TRCSEVNONE, "TxtBlk #%d: cch = %d.", (i + 1), pblk->_cch);
	}	

	for(i = 0; i < ccfr; i++)
	{
		pcfr = (CFormatRun*)_pCFRuns->Elem(i);
		Tracef(TRCSEVNONE, "CFR #%d: cch = %d, iFormat = %d.",(i + 1), pcfr->_cch, pcfr->_iFormat);
	}	

	for(i = 0; i < cpfr; i++)
	{
		ppfr = (CFormatRun*)_pPFRuns->Elem(i);
		Tracef(TRCSEVNONE, "PFR #%d: cch = %d, iFormat = %d.",(i + 1), ppfr->_cch, ppfr->_iFormat);
			
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\drawdata.h ===
class CDrawData 
{
public:

						CDrawData(

						~CDrawData(

	HDC					GetDC();

	HDC					GetTargetDevice();

	DWORD				GetDrawAspect();

	LONG				GetLindex();

	const DVTARGETDEVICE *GetTargetDeviceDesc();

	void				Push(CDrawData *pdd);

	CDrawData *			Pop();

private:

	DWORD 				_dwDrawAspect;

	LONG  				_lindex;

	const DVTARGETDEVICE *_ptd;

	HDC 				_hdcDraw;

	HDC 				_hicTargetDev;

	CDrawData *			_pddNext;
};

inline void CDrawData::Push(CDrawData *pdd)
{
	_pddNext = pdd;
}

inline CDrawData *CDrawData::Pop()
{
	return _pNext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\dragdrp.cpp ===
/*
 *	DRAGDRP.C
 *
 *	Purpose:
 *		Implementation of Richedit's OLE drag drop objects (namely,
 *		the drop target and drop source objects)
 *
 *	Author:
 *		alexgo (4/24/95)
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_dragdrp.h"
#include "_disp.h"
#include "_select.h"
#include "_font.h"
#include "_measure.h"

ASSERTDATA

//
//	CDropSource PUBLIC methods
//

/*
 *	CDropSource::QueryInterface (riid, ppv)
 */

STDMETHODIMP CDropSource::QueryInterface(REFIID riid, void ** ppv)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::QueryInterface");

	if( IsEqualIID(riid, IID_IUnknown) )
	{
		*ppv = (IUnknown *)this;
	}
	else if( IsEqualIID(riid, IID_IDropSource) )
	{
		*ppv = (IDropSource *)this;
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return NOERROR;
}

/*
 *	CDropSource::AddRef
 */
STDMETHODIMP_(ULONG) CDropSource::AddRef()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::AddRef");

	return ++_crefs;
}

/*
 *	CDropSource::Release
 *
 *	@devnote.  Do not even think about making an outgoing call here.
 *			   If you do, be sure make sure all callers use a 
 *			   SafeReleaseAndNULL (null the pointer before releasing)
 *			   technique to avoid re-entrancy problems.
 */
STDMETHODIMP_(ULONG) CDropSource::Release()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CDropSource::QueryContinueDrag (fEscapePressed, grfKeyState)
 *
 *	Purpose:
 *		determines whether or not to continue a drag drop operation
 *
 *	Algorithm:
 *		if the escape key has been pressed, cancel 
 *		if the left mouse button has been release, then attempt to 
 *			do a drop
 */
STDMETHODIMP CDropSource::QueryContinueDrag(BOOL fEscapePressed, 
	DWORD grfKeyState)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::QueryContinueDrag");

    if (fEscapePressed)
	{
        return DRAGDROP_S_CANCEL;
	}
    else if (!(grfKeyState & MK_LBUTTON) && !(grfKeyState & MK_RBUTTON))
	{
        return DRAGDROP_S_DROP;
	}
    else
	{
        return NOERROR;
	}
}

/*
 *	CDropSource::GiveFeedback (dwEffect)
 *
 *	Purpose:
 *		gives feedback during a drag drop operation
 *
 *	Notes:
 *		FUTURE (alexgo): maybe put in some neater feedback effects
 *		than the standard OLE stuff??
 */
STDMETHODIMP CDropSource::GiveFeedback(DWORD dwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::GiveFeedback");

	return DRAGDROP_S_USEDEFAULTCURSORS;
}

/*
 *	CDropSource::CDropSource
 */
CDropSource::CDropSource()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::CDropSource");

	_crefs = 1;
}

//
//	CDropSource PRIVATE methods
//

/*
 *	CDropSource::~CDropSource
 */
CDropSource::~CDropSource()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::~CDropSource");

	;
}


//
//	CDropTarget PUBLIC methods
//

/*
 *	CDropTarget::QueryInterface (riid, ppv)
 */
STDMETHODIMP CDropTarget::QueryInterface (REFIID riid, void ** ppv)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::QueryInterface");

	if( IsEqualIID(riid, IID_IUnknown) )
	{
		*ppv = (IUnknown *)this;
	}
	else if( IsEqualIID(riid, IID_IDropTarget) )
	{
		*ppv = (IDropTarget *)this;
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();

	return NOERROR;
}

/*
 *	CDropTarget::AddRef
 */
STDMETHODIMP_(ULONG) CDropTarget::AddRef()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::AddRef");

	return ++_crefs;
}

/*
 *	CDropTarget::Release()
 */
STDMETHODIMP_(ULONG) CDropTarget::Release()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CDropTarget::DragEnter (pdo, grfKeyState, pt, pdwEffect)
 *
 *	Purpose: 
 *		called when OLE drag drop enters our "window"
 *
 *	Algorithm:
 *		first we check to see if the data object being transferred contains
 *		any data that we support.  Then we verify that the 'type' of drag
 *		is acceptable (i.e., currently, we do not accept links).
 *
 *
 *	FUTURE: (alexgo): we may want to accept links as well.
 */
STDMETHODIMP CDropTarget::DragEnter(IDataObject *pdo, DWORD grfKeyState,
            POINTL pt, DWORD *pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DragEnter");

	// We don't have a position yet.
	_cpCur = -1;

	HRESULT hr = NOERROR;
	DWORD result;
	CTxtSelection *psel;

	// At drag enter time, we should have no cached info about what the data
	// object supports.  This flag should be cleared in DragLeave.  Note
	// that we slightly override _dwFlags, as it's possible for a data object
	// given during drag drop to also generate DOI_NONE.

	if( !_ped )
	{
		return CO_E_RELEASED;
	}
	 
	Assert(_pcallmgr == NULL);
	Assert(_dwFlags == 0);

	_pcallmgr = new CCallMgr(_ped);

	if( !_pcallmgr )
	{
		return E_OUTOFMEMORY;
	}

	// Find out if we can paste the object
	result = _ped->GetDTE()->CanPaste(pdo, 0, RECO_DROP);

	if( result )
	{
		if( result == DF_CLIENTCONTROL )
		{
			_dwFlags |= DF_CLIENTCONTROL;
		}

		// Create the object that implements the drag caret
		_pdrgcrt = new CDropCaret(_ped);

		if ((NULL == _pdrgcrt) || !_pdrgcrt->Init())
		{
			// Initialization failed so go without a caret
			delete _pdrgcrt;
			_pdrgcrt = NULL;
		}
				
		// cache the current selection so we can restore it on return
		psel = _ped->GetSel();
		Assert(psel);

		_cpSel	= psel->GetCp();
		_cchSel	= psel->GetCch();
		_dwFlags |= DF_CANDROP;

		// just call DragOver to handle our visual feedback
		hr = DragOver(grfKeyState, pt, pdwEffect);
	}
	else if (_ped->fInOurHost())
	{
		// Just tell the caller that we can't drop.
		*pdwEffect = DROPEFFECT_NONE;
	}
	else
	{
		// this is new behaviour for Win95 OLE; if we don't 
		// understand anything about the data object given to us,
		// we return S_FALSE to allow our parent to give the
		// drag drop a try.

		// In theory, only forms^3 uses this information and
		// this return exposes an error in NT OLE, therefore,
		// we only do this now when not in our own host.
		
		hr = S_FALSE;
	}

	if( hr != NOERROR )
	{
		delete _pcallmgr;
		_pcallmgr = NULL;
		_dwFlags = 0;
	}

	return hr;
}

/*
 *	CDropTarget::DragOver (grfKeyState, pt, pdwEffect)
 *
 *	Purpose:
 *		handles the visual feedback for a drag drop operation zooming
 *		around over text
 *
 *	FUTURE (alexgo): maybe we should do some snazzy visuals here
 */
STDMETHODIMP CDropTarget::DragOver(DWORD grfKeyState, POINTL pt, 
		DWORD *pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DragOver");

	LONG	cpCur = _cpCur;

	if( !_ped )
	{
		return CO_E_RELEASED;
	}
	Assert(_pcallmgr);

	// note if we're doing right mouse drag drop; note that we 
	// can't do this in UpdateEffect as it's called from Drop
	// as well (and the mouse button is up then!)
	if( (grfKeyState & MK_RBUTTON) )
	{
		_dwFlags |= DF_RIGHTMOUSEDRAG;
	}
	else
	{
		_dwFlags &= ~DF_RIGHTMOUSEDRAG;
	}

	UpdateEffect(grfKeyState, pt, pdwEffect);

	// only draw if we've changed position	
	if( *pdwEffect != DROPEFFECT_NONE 
		&& ((cpCur != _cpCur) 
			|| (_pdrgcrt && _pdrgcrt->NoCaret())))
	{
		DrawFeedback();
	}	

	return NOERROR;
}

/*
 *	CDropTarget::DragLeave
 *
 *	Purpose:
 *		called when the mouse leaves our window during drag drop.  Here we clean
 *		up any temporary state setup for the drag operation.
 */
STDMETHODIMP CDropTarget::DragLeave()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DragLeave");

	CTxtSelection *psel = _ped->GetSel();

	if( !_ped )
	{
		return CO_E_RELEASED;
	}
	Assert(_pcallmgr);

	_dwFlags = 0;

	// now restore the selection

	psel->SetSelection(_cpSel - _cchSel, _cpSel);
	psel->Update(FALSE);

	_cpSel = _cchSel = 0;

	delete _pcallmgr;
	_pcallmgr = NULL;

	delete _pdrgcrt;
	_pdrgcrt = NULL;

	return NOERROR;
}

/*
 *	CDropTarget::Drop (pdo, grfKeyState, pt, pdwEffect)
 *
 *	@mfunc
 *		called when the mouse button is released.  We should attempt
 *		to 'paste' the data object into a selection corresponding to
 *		the mouse location
 *
 *	@devnote
 *		first, we make sure that we can still do a paste (via UpdateEffect).
 *		If so, then set the selection to the current point and then insert
 *		the text.
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDropTarget::Drop(
	IDataObject *pdo,
	DWORD		 grfKeyState, 
	POINTL		 ptl,
	DWORD *		 pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::Drop");

	HRESULT	hr = NOERROR;

	if( !_ped )
		return CO_E_RELEASED;

	Assert(_pcallmgr);
	CDropCleanup cleanup(this);

	// see if we can still drop
	UpdateEffect(grfKeyState, ptl, pdwEffect);

	// UpdateEffect will show a drop cursor but at this point we don't need one
	// so we hide the drop cursor here.
	if (_pdrgcrt)
		_pdrgcrt->HideCaret();

	if (_dwFlags & DF_OVERSOURCE)
	{
		*pdwEffect = DROPEFFECT_NONE;
		_dwFlags = 0;
		return NOERROR;
	}
	
	if(*pdwEffect & (DROPEFFECT_COPY | DROPEFFECT_MOVE | DROPEFFECT_LINK))
	{
		IUndoBuilder *	publdr;
		CGenUndoBuilder undobldr( _ped, UB_AUTOCOMMIT, &publdr);
		// If this is a right mouse drag drop; handle that
		if(_dwFlags & DF_RIGHTMOUSEDRAG)
		{
			hr = HandleRightMouseDrop(pdo, ptl);

			// If S_FALSE is returned, treat drag drop normally
			if( hr != S_FALSE )
				goto Exit;
		}

		// Get an undo builder.  If we already have one cached, that means
		// we are dropping onto the same edit instance that started the drag
		// In this case, we want to use the cached undo builder so that 
		// a drag move can be undone as one "operation".

		if(_publdr)
			publdr = _publdr;

		CTxtSelection *psel = _ped->GetSel();
		psel->SetSelection(_cpCur, _cpCur);
		
		if( !_ped->IsProtectedRange(WM_PASTE, 0, 0, psel) )
		{
			hr = _ped->PasteDataObjectToRange(pdo, (CTxtRange *)psel, 
					0, NULL, publdr, PDOR_DROP);
		}

		// If we are dropping onto ourselves, the UI specifies
		// that we should select the entire range dragged.  We use
		// _publdr as an easy way to tell if the drop originated from
		// this instance

		if(SUCCEEDED(hr) && _pdrgcrt)
		{
			// If the drop worked, then we don't want to restore the area
			// where the drop caret used to be since this is not out of date.
			_pdrgcrt->CancelRestoreCaretArea();
		}		

		// Now set the selection anti-events. If the selection preceded the
		// paste poiont subtract its length from the redo position, since
		// the selection will get deleted if we are doing a DRAGMOVE within
		// this instance.
		LONG cpNext  = psel->GetCp();
		LONG cchNext = cpNext - _cpCur;
		if(_cpSel < _cpCur && _publdr && (*pdwEffect & DROPEFFECT_MOVE))
			cpNext -= abs(_cchSel);

		HandleSelectionAEInfo(_ped, publdr, _cpCur, 0, cpNext, cchNext,
							  SELAE_FORCEREPLACE);
		if(_publdr)
		{
			// If we are doing a drag move, then *don't* set the
			// selection directly on the screen--doing so will result in
			// unsightly UI--we'll set the selection to one spot, draw it
			// and then immediately move the selection somewhere else.

			// In this case, just change where the selection range exists.
			// Floating ranges and the drag-move code in ldte.c will take
			// care of the rest.

			if( *pdwEffect == DROPEFFECT_COPY )
				psel->SetSelection(_cpCur, psel->GetCp());
			else
				psel->Set(psel->GetCp(), cchNext);
		}
		else if(publdr)
		{
			// The drop call landed in us from outside, so we need
			// to fire the appropriate notifications.  First, however,
			// commit the undo builder.

			publdr->SetNameID(UID_DRAGDROP);
			publdr->Done();

			if(SUCCEEDED(hr))
			{
				// Make this window the foreground window after the drop. Note
				// that the host needs to support ITextHost2 to really get to
				// be the foreground window. If they don't this is a no-op.
				_ped->TxSetForegroundWindow();
			}
		}

		// If nothing changed on the drop && the effect is a move, then return
		// failure. This is an ugly hack to improve drag-move scenarios; if
		// nothing happened on the drop, then chances are, you don't want
		// to have the correspong "Cut" happen on the drag source side.
		//
		// Of course, this relies on the drag source responding gracefully to
		// E_FAIL w/o hitting too much trauma.
		if (*pdwEffect == DROPEFFECT_MOVE && 
			!_ped->GetCallMgr()->GetChangeEvent() )
		{
			hr = E_FAIL;
		}
	}

Exit:
	_dwFlags = 0;
	return hr;
}

/*
 *	CDropTarget::CDropTarget (ped)
 *
 */
CDropTarget::CDropTarget(CTxtEdit *ped)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::CDropTarget");

	_ped 		= ped;
	_crefs 		= 1;
	_dwFlags 	= 0;
	_publdr 	= NULL;
	_cpMin		= -1;
	_cpMost		= -1;
	_pcallmgr	= NULL;
}


/*
 *	CDropTarget::SetDragInfo (publdr, cpMin, cpMost)
 *
 *	Purpose:
 *		allows the data transfer engine to cache important information
 *		about a drag drop with this drop target.
 *
 *	Arguments:
 *		publdr		-- the undo builder for the operation.  With this
 *					   intra-instance drag drop operations can be treated
 *					   as a single user action
 *		cpMin		-- the minimim character position of the range that is
 *					   being dragged.  With this and cpMost, we can disable
 *					   dragging into the range that is being dragged!
 *		cpMost		-- the max character position
 *
 *	Notes:
 *		this method must be called again in order to clear the cached info
 *
 *		-1 for cpMin and cpMost will "clear" those values (as 0 is a valid cp)
 */

void CDropTarget::SetDragInfo( IUndoBuilder *publdr, LONG cpMin, LONG cpMost )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::SetDragInfo");

	_publdr = publdr;
	_cpMin 	= cpMin;
	_cpMost	= cpMost;
}

/*
 *	CDropTarget::Zombie
 *
 *	@mfunc	This method clears the state in this drop target object.  It is
 *			used to recover 'gracefully' from reference counting errors
 */
void CDropTarget::Zombie()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::Zombie");

	_ped = NULL;
	if( _pcallmgr )
	{
		delete _pcallmgr;
		_pcallmgr = NULL;
	}
}

//
//	CDropTarget PRIVATE methods
//

/*
 *	CDropTarget::~CDropTarget
 */
CDropTarget::~CDropTarget()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::~CDropTarget");

	;
}

/*
 *	CDropTarget::ConvertScreenPtToClientPt (pptScreen, pptClient)
 *
 *	Purpose:
 *		OLE drag drop sends points in using screen coordinates.  However,
 *		all of our display code internally relies on client coordinates
 *		(i.e. the coordinates relative to the window that we are being
 *		drawn in).  This routine will convert between the two
 *
 *	Notes:
 *		the client coordinates use a POINT structure instead of POINTL.
 *		while nominally they are the same, OLE uses POINTL and the display
 *		engine uses POINT. 
 *
 */

void CDropTarget::ConvertScreenPtToClientPt( POINTL *pptScreen, 
	POINT *pptClient )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::ConvertScreenPtToClientPt");

	POINT ptS;

	pptClient->x = ptS.x = pptScreen->x;
	pptClient->y = ptS.y = pptScreen->y;

	_ped->TxScreenToClient(pptClient);

	return;
}

/*
 *	CDropTarget::UpdateEffect (grfKeyState, pt, pdwEffect)
 *
 *	Purpose:
 *		given the keyboard state and point, and knowledge of what
 *		the data object being transferred can offer, calculate
 *		the correct drag drop feedback.
 *
 *	Requires:
 *		this function should only be called during a drag drop 
 *		operation; doing otherwise will simply result in a return
 *		of DROPEFFECT_NONE.
 *
 */

void CDropTarget::UpdateEffect( DWORD grfKeyState, POINTL ptl, 
		DWORD *pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::UpdateEffect");

	POINT pt;
	BOOL fHot;
	WORD nScrollInset;
	HRESULT hr;
	LPRICHEDITOLECALLBACK const precall = _ped->GetRECallback();

	pt.x = ptl.x;
	pt.y = ptl.y;

	// first, find out where we are
	ConvertScreenPtToClientPt(&ptl, &pt);

	_cpCur = _ped->_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE);

	// if we are on top of the range that is being
	// dragged, then remeber it for later
	_dwFlags &= ~DF_OVERSOURCE;
	if( _cpCur > _cpMin && _cpCur < _cpMost )
	{
		_dwFlags |= DF_OVERSOURCE;
	}

	// Scroll if we need to and remember if we are in the hot zone.
	nScrollInset = W32->GetScrollInset();

	if (_pdrgcrt != NULL)
	{
		_pdrgcrt->HideCaret();
	}

	fHot = _ped->_pdp->AutoScroll(pt, nScrollInset, nScrollInset);

	if (_pdrgcrt != NULL)
	{
		if (((_dwFlags & DF_OVERSOURCE) == 0) && !fHot)
		{
			_pdrgcrt->ShowCaret();
		}
		else
		{
			// The hide above restored the caret so we just
			// need to turn off the caret while we are over the
			// source.
			_pdrgcrt->CancelRestoreCaretArea();
		}
	}

	// Let the client set the effect if it wants, but first, we need
	// to check for protection.

	if( _ped->IsRich() )
	{
		// we don't allow dropping onto protected text.  Note that
		// the _edges_ of a protected range may be dragged to; therefore,
		// we need to check for protection at _cpCur and _cpCur-1.
		// If both cp's are protected, then we are inside a protected
		// range.
		CTxtRange rg(_ped, _cpCur, 0);
		LONG iProt;

		if( (iProt = rg.IsProtected(1)) == CTxtRange::PROTECTED_YES || 
			iProt == CTxtRange::PROTECTED_ASK )
		{
		  	rg.Advance(-1);

			// if we're at the BOD or if the CF of the preceding cp
			// is PROTECTED
			if(!_cpCur || 
				(iProt = rg.IsProtected(-1)) == CTxtRange::PROTECTED_YES ||
				iProt == CTxtRange::PROTECTED_ASK)
			{
				// give the caller a chance to do something if the
				// ENM_PROTECTED mask is set.
				if( iProt == CTxtRange::PROTECTED_YES || 
					!_ped->IsProtectionCheckingEnabled() || 
					_ped->QueryUseProtection(&rg, WM_MOUSEMOVE,0, 0) )
				{ 
					*pdwEffect = DROPEFFECT_NONE;
					goto Exit;
				}
			}
		}
	}

	if( precall )
	{
		hr = precall->GetDragDropEffect(FALSE, grfKeyState, pdwEffect);
		// Note : RichEdit 1.0 does not check the return code of this call.
		// If callback specified a single effect, use it.
		// Otherwise pick one ourselves.

		// trick: (x & (x-1)) is non-zero if more than one bit is set.
		if (!(*pdwEffect & (*pdwEffect - 1) ))
		{
			goto Exit;
		}
	}
	
	// If we don't know anything about the data object or the control
	// is read-only, set the effect to none.
	// If the client is handling this, we don't worry about read-only.
	if (!(_dwFlags & DF_CLIENTCONTROL) &&
		 ( !(_dwFlags & DF_CANDROP) || _ped->TxGetReadOnly()))
	{
		*pdwEffect = DROPEFFECT_NONE;
		_cpCur = -1;
		// no need to do anything else
		return;
	}

	// if we are on top of the range that is being
	// dragged, then we can't drop there!
	if( _dwFlags & DF_OVERSOURCE )
	{
		*pdwEffect = DROPEFFECT_NONE;
		goto Exit;
	}


	// now check the keyboard state and the requested drop effects.

	if( (_dwFlags & DF_CANDROP) )
	{
		// if we can paste plain text, then see if a MOVE or COPY
		// operation was requested and set the right effect.  Note
		// that we prefer MOVEs over COPY's in accordance with OLE
		// UI guidelines.

		// we do not yet support linking
		if( (grfKeyState & MK_CONTROL) && (grfKeyState & MK_SHIFT) )
		{
			//COMPATIBILITY: Richedit 1.0 did not appear to support drag
			//linking correctly.
			*pdwEffect = DROPEFFECT_NONE;
		}
		else if( !(grfKeyState & MK_CONTROL) && 
			(*pdwEffect & DROPEFFECT_MOVE) )
		{
			// if the control key is *not* depressed, then assume a "move"
			// operation (note that shift and alt or no keys will also give
			// a move) iff the source supports move.

			*pdwEffect = DROPEFFECT_MOVE;
		}
		else if( (grfKeyState & MK_CONTROL) && !((grfKeyState & MK_ALT) &&
			(grfKeyState & MK_SHIFT)) && (*pdwEffect & DROPEFFECT_COPY) )
		{
			// if only the control key is down and we're allowed to do a copy,
			// then do a copy
			*pdwEffect = DROPEFFECT_COPY;
		}
		else if( !(grfKeyState & MK_CONTROL) && 
			(*pdwEffect & DROPEFFECT_COPY) )
		{
			// if the control key is *not* depressed, and we are *not* allowed
			// to do a move (note that this if comes below the second one), then
			// do a COPY operation (if available)
			*pdwEffect = DROPEFFECT_COPY;
		}
		else
		{
			// not a combination that we support
			*pdwEffect = DROPEFFECT_NONE;
		}
	}
	else
	{
		*pdwEffect = DROPEFFECT_NONE;
	}

Exit:	

	//Add the scrolling effect if we are in the hot zone.
	if (fHot)
	{
		*pdwEffect |= DROPEFFECT_SCROLL;
	}
}

/*
 *	CDropTarget::DrawFeedback
 *
 *	Purpose:
 *		draws any feeback necessary on the target side (specifically, setting the
 *		cursor
 *
 *	Notes:
 *		assumes _cpCur is correctly set.
 */

void CDropTarget::DrawFeedback(void)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DrawFeedback");

	if (_pdrgcrt != NULL)
	{
		// We need to indicate a drop location because a drop is possible
		_pdrgcrt->DrawCaret(_cpCur);
	}
}

/*
 *	CDropTarget::HandleRightMouseDrop
 *
 *	@mfunc	Handles calling back to the client to get a context menu 
 *			for a right-mouse drag drop.
 *
 *	@rdesc	HRESULT
 */
HRESULT CDropTarget::HandleRightMouseDrop(
	IDataObject *pdo,		//@parm the data object to drop
	POINTL ptl)				//@parm the location of the drop (screen coords)
{
	LPRICHEDITOLECALLBACK precall = NULL;
	CHARRANGE cr = {_cpCur, _cpCur};
	HMENU hmenu = NULL;
	HWND hwnd, hwndParent;

	precall = _ped->GetRECallback();

	if( !precall || _ped->Get10Mode() )
	{
		return S_FALSE;
	}

	// HACK ALERT! evil pointer casting going on here.
	precall->GetContextMenu( GCM_RIGHTMOUSEDROP, (IOleObject *)(void *)pdo, 
			&cr, &hmenu);

	if( hmenu && _ped->TxGetWindow(&hwnd) == NOERROR )
	{
		hwndParent = GetParent(hwnd);
		if( !hwndParent )
		{
			hwndParent = hwnd;
		}

		TrackPopupMenu(hmenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON, 
			ptl.x, ptl.y, 0, hwndParent, NULL);

		return NOERROR;
	}
	
	return S_FALSE;
}

/*
 *	CDropCaret::DrawCaret
 *
 *	Purpose:
 *		Draws a "caret" to indicate where the drop will occur.
 *
 */

CDropCaret::CDropCaret(
	CTxtEdit *ped)			//@parm Edit control
		: _ped(ped), _yHeight(-1), _hdcWindow(NULL)
{
	// Header does all the work
}

/*
 *	CDropCaret::~CDropCaret
 *
 *	Purpose:
 *		Clean up caret object
 *
 */

CDropCaret::~CDropCaret()
{
	if (_hdcWindow != NULL)
	{
		// Restore the any updated window area
		HideCaret();

		// Free the DC we held on to
		_ped->_pdp->ReleaseDC(_hdcWindow);
	}
}

/*
 *	CDropCaret::Init
 *
 *	Purpose:
 *		Do initialization that can fail
 *
 */

BOOL CDropCaret::Init()
{
	// Get the DC for the window
	_hdcWindow = _ped->_pdp->GetDC();

	if (NULL == _hdcWindow)
	{
		// Could not get a DC, we are toast.
		AssertSz(FALSE, "CDropCaret::Init could not get hdc"); 
		return FALSE;
	}

	// Keep pixels per inch since we will need it
	_yPixelsPerInch = GetDeviceCaps(_hdcWindow, LOGPIXELSY);

	// Set the default maximum size
	_yHeightMax = DEFAULT_DROPCARET_MAXHEIGHT;

	// Preallocate a bitmap for saving screen
	return (_osdc.Init(
		_hdcWindow,
		WIDTH_DROPCARET,
		DEFAULT_DROPCARET_MAXHEIGHT,
		CLR_INVALID) != NULL);
}

/*
 *	CDropCaret::DrawCaret (cpCur)
 *
 *	@mfunc
 *		Draws a "caret" to indicate where the drop will occur.
 */
void CDropCaret::DrawCaret(
	LONG cpCur)				//@parm current cp of where drop would occur
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropCaret::DrawCaret");

	CLock		lock;					// Uses global (shared) FontCache
	CDisplay *	pdp = _ped->_pdp;
	POINT		ptNew;
	RECT		rcClient;
	CLinePtr	rp(pdp);
	CRchTxtPtr	rtp(_ped, cpCur);

	// Restore old caret position bits and save new caret position bits
	HideCaret();

	// We no longer have a caret to restore
	_yHeight = -1;

	// Get new cp from point
	pdp->PointFromTp(rtp, NULL, FALSE, ptNew, &rp, TA_TOP | TA_LOGICAL);

	// Get client rectangle
	_ped->TxGetClientRect(&rcClient);
	
	// Figure out height of new caret

	// Get charformat
	const CCharFormat *pCF = rtp.GetCF();

	// Get zoomed height
	LONG dypInch = MulDiv(_yPixelsPerInch, pdp->GetZoomNumerator(), pdp->GetZoomDenominator());
	CCcs *pccs = fc().GetCcs(pCF, dypInch);

	if (NULL == pccs)
	{
		// We can't do anything sensible so give up.
		return;
	}

	// Convert height in charformat to height on screen
	LONG yHeight = pdp->LXtoDX(pCF->_yHeight);
	
	LONG yOffset, yAdjust;
	pccs->GetOffset(pCF, dypInch, &yOffset, &yAdjust);

	// Save new position
	ptNew.y += (rp->_yHeight - rp->_yDescent 
		+ pccs->_yDescent - yHeight - yOffset - yAdjust);

	// Release cache entry since we are done with it.
	pccs->Release();

	// Check if new point is in the client rectangle
	if(!PtInRect(&rcClient, ptNew))
		return;

	// Save new height
	_yHeight = yHeight;

	// Save the new caret position
	_ptCaret.x = ptNew.x;
	_ptCaret.y = ptNew.y;

	// Is current bit map big enough to hold the bit map we want to put in?
	if(yHeight > _yHeightMax)
	{
		// No - reallocate the bitmap.
		if(!_osdc.Realloc(WIDTH_DROPCARET, yHeight))
		{
			// Reallocation failed - no visual feedback for now
			AssertSz(FALSE, "CDropCaret::DrawCaret bitmap reallocation failed");
			return;
		}
		_yHeightMax = yHeight;
	}

	// Save bits at new caret position
	_osdc.Get(_hdcWindow, _ptCaret.x, _ptCaret.y, WIDTH_DROPCARET, yHeight);

	// Actually put caret on screen
	ShowCaret();
}


/*
 *	CDropCaret::ShowCaret
 *
 *	Purpose:
 *		Actually draw caret on the screen
 *
 */

void CDropCaret::ShowCaret()
{
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	BOOL fSuccess;
#endif // DEBUG

	// Don't show the caret if the height says that there is no caret to show.
	if (-1 == _yHeight)
	{
		return;
	}

	// Create a pen
	HPEN hPenCaret = CreatePen(PS_SOLID, WIDTH_DROPCARET, 0);

	if (NULL == hPenCaret)
	{
		// Call failed, this isn't really catastrophic so just don't
		// draw the caret.
		AssertSz(FALSE, "CDropCaret::DrawCaret could not create pen");
		return;
	}

	// Put the dotted pen in the DC
	HPEN hPenOld = (HPEN) SelectObject(_hdcWindow, hPenCaret);
														   
	if (NULL == hPenOld)
	{
		// Call failed, this isn't really catastrophic so just don't
		// draw the caret.
		AssertSz(FALSE, "CDropCaret::DrawCaret SelectObject failed");
		goto DeleteObject;
	}

	// Move the drawing pen to where to draw the caret
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	fSuccess =
#endif // DEBUG

	MoveToEx(_hdcWindow, _ptCaret.x, _ptCaret.y, NULL);

	AssertSz(fSuccess, "CDropCaret::DrawCaret MoveToEx failed");

	// Draw the line
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	fSuccess =
#endif // DEBUG

	LineTo(_hdcWindow, _ptCaret.x, _ptCaret.y + _yHeight);

	AssertSz(fSuccess, "CDropCaret::DrawCaret LineTo failed");

	// Restore the current pen
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	hPenCaret = (HPEN)
#endif // DEBUG

	SelectObject(_hdcWindow, hPenOld);

	AssertSz(hPenCaret != NULL, 
		"CDropCaret::DrawCaret Restore Original Pen failed");

DeleteObject:

	// Dump the pen
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	fSuccess =
#endif // DEBUG

	DeleteObject(hPenCaret);

	AssertSz(fSuccess, 
		"CDropCaret::DrawCaret Could not delete dotted Pen");
}

/*
 *	CDropCaret::HideCaret
 *
 *	Purpose:
 *		Restore caret area after cursor has moved
 *
 */
void CDropCaret::HideCaret()
{
	if (_yHeight != -1)
	{
		_osdc.RenderBitMap(_hdcWindow, _ptCaret.x, _ptCaret.y, WIDTH_DROPCARET, 
			_yHeight);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\edit.cpp ===
/*
 *  @doc INTERNAL
 *
 *  @module EDIT.C - main part of CTxtEdit |
 *
 *      See also textserv.cpp (ITextServices and SendMessage interfaces)
 *      and tomDoc.cpp (ITextDocument interface)
 *
 *  Authors: <nl>
 *      Original RichEdit code: David R. Fulmer <nl>
 *      Christian Fortini, Murray Sargent, Alex Gounares, Rick Sailor,
 *      Jon Matousek
 *
 *  History: <nl>
 *      12/28/95 jonmat-Added support of Magellan mouse and smooth scrolling.
 *
 *  @devnote
 *      Be sure to set tabs at every four (4) columns.  In fact, don't even
 *      think of doing anything else!
 *
 *  Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_dispprt.h"
#include "_dispml.h"
#include "_dispsl.h"
#include "_select.h"
#include "_text.h"
#include "_runptr.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_rtext.h"

#include "_uspi.h"
#include "_urlsup.h"

#ifdef LINESERVICES
#include "_ols.h"
#endif

#include "_txtbrk.h"
#include "_clasfyc.h"

#define CONTROL(_ch) (_ch - 'A' + 1)

ASSERTDATA

// This is not public because we don't really want folks using it.
// ITextServices is a private interface.
EXTERN_C const IID IID_ITextServices = { // 8d33f740-cf58-11ce-a89d-00aa006cadc5
    0x8d33f740,
    0xcf58,
    0x11ce,
    {0xa8, 0x9d, 0x00, 0xaa, 0x00, 0x6c, 0xad, 0xc5}
  };

// {13E670F4-1A5A-11cf-ABEB-00AA00B65EA1}
EXTERN_C const GUID IID_ITextHost =
{ 0x13e670f4, 0x1a5a, 0x11cf, { 0xab, 0xeb, 0x0, 0xaa, 0x0, 0xb6, 0x5e, 0xa1 } };

// {13E670F5-1A5A-11cf-ABEB-00AA00B65EA1}
EXTERN_C const GUID IID_ITextHost2 =
{ 0x13e670f5, 0x1a5a, 0x11cf, { 0xab, 0xeb, 0x0, 0xaa, 0x0, 0xb6, 0x5e, 0xa1 } };

// this is used internally do tell if a data object is one of our own.
EXTERN_C const GUID IID_IRichEditDO =
{ /* 21bc3b20-e5d5-11cf-93e1-00aa00b65ea1 */
    0x21bc3b20,
    0xe5d5,
    0x11cf,
    {0x93, 0xe1, 0x00, 0xaa, 0x00, 0xb6, 0x5e, 0xa1}
};

// Static data members
DWORD CTxtEdit::_dwTickDblClick;    // time of last double-click
POINT CTxtEdit::_ptDblClick;        // position of last double-click

//HCURSOR CTxtEdit::_hcurCross = 0; // We don't implement outline drag move
HCURSOR CTxtEdit::_hcurArrow = 0;
HCURSOR CTxtEdit::_hcurHand = 0;
HCURSOR CTxtEdit::_hcurIBeam = 0;
HCURSOR CTxtEdit::_hcurItalic = 0;
HCURSOR CTxtEdit::_hcurSelBar = 0;

const TCHAR szCRLF[]= TEXT("\r\n");
const TCHAR szCR[]  = TEXT("\r");

WORD    g_wFlags = 0;                   // Keyboard controlled flags

/*
 *  GetKbdFlags(vkey, dwFlags)
 *
 *  @func
 *      return bit mask (RSHIFT, LSHIFT, RCTRL, LCTRL, RALT, or LALT)
 *      corresponding to vkey = VK_SHIFT, VK_CONTROL, or VK_MENU and
 *      dwFlags
 *
 *  @rdesc
 *      Bit mask corresponding to vkey and dwFlags
 */
DWORD GetKbdFlags(
    WORD    vkey,       //@parm Virtual key code
    DWORD   dwFlags)    //@parm lparam of WM_KEYDOWN msg
{
    if(vkey == VK_SHIFT)
        return (LOBYTE(HIWORD(dwFlags)) == 0x36) ? RSHIFT : LSHIFT;

    if(vkey == VK_CONTROL)
        return (HIWORD(dwFlags) & KF_EXTENDED) ? RCTRL : LCTRL;

    Assert(vkey == VK_MENU);

    return (HIWORD(dwFlags) & KF_EXTENDED) ? RALT : LALT;
}

///////////////// CTxtEdit Creation, Initialization, Destruction ///////////////////////////////////////

/*
 *  CTxtEdit::CTxtEdit()
 *
 *  @mfunc
 *      constructor
 */
CTxtEdit::CTxtEdit(
    ITextHost2 *phost,
    IUnknown * punk)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CTxtEdit");

    _unk.Init();
    _punk = (punk) ? punk : &_unk;
    _ldte.Init(this);
    _phost    = phost;
    _cpAccelerator = -1;                    // Default to no accelerator

    // Initialize _iCF and _iPF to something bogus
    Set_iCF(-1);
    Set_iPF(-1);

    // Initialize local maximum text size to window default
    _cchTextMost = cInitTextMax;

    // This actually counts the number of active ped
    W32->AddRef();
}

/*
 *  CTxtEdit::~CTxtEdit()
 *
 *  @mfunc
 *      Destructor
 */
CTxtEdit::~CTxtEdit ()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::~CTxtEdit");

    Assert(!_fMButtonCapture);              // Need to properly transition
                                            //  Magellan mouse if asserts!
    _fSelfDestruct = TRUE;                  // Tell the Call Mgr not to
                                            //  call this any more
    // Flush clipboard first
    _ldte.FlushClipboard();

    if(_pDocInfo)                           // Do this before closing
    {                                       //  down internal structures
        CloseFile(TRUE);                    // Close any open file
        delete _pDocInfo;                   // Delete document info
        _pDocInfo = NULL;
    }

    if(_pdetecturl)
        delete _pdetecturl;

    if (_pbrk)
        delete _pbrk;

    if(_pobjmgr)
        delete _pobjmgr;

    // Release our reference to selection object
    if(_psel)
        _psel->Release();

    // Delete undo and redo managers
    if(_pundo)
        _pundo->Destroy();

    // Release message filter.
    // Note that the attached message filter must have released this document
    // Otherwise we will never get here.
    if (_pMsgFilter)
        _pMsgFilter->Release();

    if(_predo)
        _predo->Destroy();

    ReleaseFormats(Get_iCF(), Get_iPF());   // Release default formats

    delete _pdp;                            // Delete displays
    delete _pdpPrinter;
    _pdp = NULL;                            // Break any further attempts to
                                            //  use display

    if (_fHost2)
    {
        // We are in a windows host - need to deal with the shutdown
        // problem where the window can be destroyed before text
        // services is.
        if (!_fReleaseHost)
        {
            ((ITextHost2*)_phost)->TxFreeTextServicesNotification();
        }
        else
        {
            // Had to keep host alive so tell it we are done with it.
            _phost->Release();
        }
    }

    W32->Release();
}

/*
 *  CTxtEdit::Init (prcClient)
 *
 *  @mfunc
 *      Initializes this CTxtEdit. Called by CreateTextServices()
 *
 *  @rdesc
 *      Return TRUE if successful
 */

BOOL CTxtEdit::Init (
    const RECT *prcClient)      //@parm Client RECT
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::Init");

    CCharFormat         CF;
    DWORD               dwBits = 0;
    DWORD               dwMask;
    LONG                iCF, iPF;
    CParaFormat         PF;
    CCallMgr            callmgr(this);

    static BOOL fOnce = FALSE;
    if (!fOnce)
    {
        CLock lock;
        fOnce = TRUE;
        _fnpPropChg[ 0] = &CTxtEdit::OnRichEditChange;          // TXTBIT_RICHTEXT
        _fnpPropChg[ 1] = &CTxtEdit::OnTxMultiLineChange;       // TXTBIT_MULTILINE
        _fnpPropChg[ 2] = &CTxtEdit::OnTxReadOnlyChange;        // TXTBIT_READONLY
        _fnpPropChg[ 3] = &CTxtEdit::OnShowAccelerator;         // TXTBIT_SHOWACCELERATOR
        _fnpPropChg[ 4] = &CTxtEdit::OnUsePassword;             // TXTBIT_USEPASSWORD
        _fnpPropChg[ 5] = &CTxtEdit::OnTxHideSelectionChange;   // TXTBIT_HIDESELECTION
        _fnpPropChg[ 6] = &CTxtEdit::OnSaveSelection;           // TXTBIT_SAVESELECTION
        _fnpPropChg[ 7] = &CTxtEdit::OnAutoWordSel;             // TXTBIT_AUTOWORDSEL
        _fnpPropChg[ 8] = &CTxtEdit::OnTxVerticalChange;        // TXTBIT_VERTICAL
        _fnpPropChg[ 9] = &CTxtEdit::NeedViewUpdate;            // TXTBIT_SELECTIONBAR
        _fnpPropChg[10] = &CTxtEdit::OnWordWrapChange;          // TXTBIT_WORDWRAP
        _fnpPropChg[11] = &CTxtEdit::OnAllowBeep;               // TXTBIT_ALLOWBEEP
        _fnpPropChg[12] = &CTxtEdit::OnDisableDrag;             // TXTBIT_DISABLEDRAG
        _fnpPropChg[13] = &CTxtEdit::NeedViewUpdate;            // TXTBIT_VIEWINSETCHANGE
        _fnpPropChg[14] = &CTxtEdit::OnTxBackStyleChange;       // TXTBIT_BACKSTYLECHANGE
        _fnpPropChg[15] = &CTxtEdit::OnMaxLengthChange;         // TXTBIT_MAXLENGTHCHANGE
        _fnpPropChg[16] = &CTxtEdit::OnScrollChange;            // TXTBIT_SCROLLBARCHANGE
        _fnpPropChg[17] = &CTxtEdit::OnCharFormatChange;        // TXTBIT_CHARFORMATCHANGE
        _fnpPropChg[18] = &CTxtEdit::OnParaFormatChange;        // TXTBIT_PARAFORMATCHANGE
        _fnpPropChg[19] = &CTxtEdit::NeedViewUpdate;            // TXTBIT_EXTENTCHANGE
        _fnpPropChg[20] = &CTxtEdit::OnClientRectChange;        // TXTBIT_CLIENTRECTCHANGE
    }

    // Set up default CCharFormat and CParaFormat
    if (TxGetDefaultCharFormat(&CF, dwMask) != NOERROR ||
        TxGetDefaultParaFormat(&PF)         != NOERROR ||
        FAILED(GetCharFormatCache()->Cache(&CF, &iCF)) ||
        FAILED(GetParaFormatCache()->Cache(&PF, &iPF)))
    {
        return FALSE;
    }

    GetTabsCache()->Release(PF._iTabs);
    Set_iCF(iCF);                               // Save format indices
    Set_iPF(iPF);

    // Load mouse cursors (but only for first instance)
    if(!_hcurArrow)
    {
        _hcurArrow = LoadCursor(0, IDC_ARROW);
        if(!_hcurHand)
        {
            if (dwMajorVersion < 5)
                _hcurHand   = LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_HAND));
            else
                _hcurHand   = LoadCursor(0, IDC_HAND);
        }
        if(!_hcurIBeam)                         // Load cursor
            _hcurIBeam  = LoadCursor(0, IDC_IBEAM);
        if(!_hcurItalic)
            _hcurItalic = LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_ITALIC));
        if(!_hcurSelBar)
            _hcurSelBar = LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_SELBAR));
    }

#ifdef DEBUG
    // The host is going to do some checking on richtext vs. plain text.
    _fRich = TRUE;
#endif // DEBUG

    if(_phost->TxGetPropertyBits (TXTBITS |     // Get host state flags
        TXTBIT_MULTILINE | TXTBIT_SHOWACCELERATOR,  //  that we cache or need
        &dwBits) != NOERROR)                        //  for display setup
    {
        return FALSE;
    }                                               // Cache bits defined by
    _dwFlags = dwBits & TXTBITS;                    //  TXTBITS mask

    if ((dwBits & TXTBIT_SHOWACCELERATOR) &&        // They want accelerator,
        FAILED(UpdateAccelerator()))                //  so let's get it
    {
        return FALSE;
    }

    _fTransparent = TxGetBackStyle() == TXTBACK_TRANSPARENT;
    if(dwBits & TXTBIT_MULTILINE)                   // Create and initialize
        _pdp = new CDisplayML(this);                //  display
    else
        _pdp = new CDisplaySL(this);
    Assert(_pdp);

    if(!_pdp || !_pdp->Init())
        return FALSE;

    _fUseUndo  = TRUE;
    _fAutoFont = TRUE;
    _fDualFont = TRUE;
    _f10DeferChangeNotify = 0;

    // Set whether we are in our host or not
    ITextHost2 *phost2;
    if(_phost->QueryInterface(IID_ITextHost2, (void **)&phost2) == NOERROR)
    {
        // We assume that ITextHost2 means this is our host
        phost2->Release();
        _fHost2 = TRUE;
    }
    else                                // Get maximum from our host
        _phost->TxGetMaxLength(&_cchTextMost);

    // Add EOP iff Rich Text
    if(IsRich())
    {
        // We should _not_ be in 10 compatibility mode yet.
        // If we transition into 1.0 mode, we'll add a CRLF
        // at the end of the document.
        SetRichDocEndEOP(0);
    }

    // Allow for win.ini control over use of line services
    if (W32->fUseLs())
    {
        OnSetTypographyOptions(TO_ADVANCEDTYPOGRAPHY, TO_ADVANCEDTYPOGRAPHY);
    }

    if (W32->GetDigitSubstitutionMode() != DIGITS_NOTIMPL)
        OrCharFlags(fDIGITSHAPE);       // digit substitution presents

    // Initialize the BiDi property
    // It is set to true if OS is BiDi (the system default LCID is a BiDi language)
    // or if the current keyboard code page is a BiDi code page
    // or if system.ini says we should do it.
    if (W32->OnBiDiOS() ||
        W32->IsBiDiCodePage(GetKeyboardCodePage(0xFFFFFFFF)) ||
        W32->fUseBiDi())
        OrCharFlags(fBIDI);

    _fAutoKeyboard = IsBiDi() && IsBiDiKbdInstalled();
    return TRUE;
}


///////////////////////////// CTxtEdit IUnknown ////////////////////////////////

/*
 *  CTxtEdit::QueryInterface (riid, ppv)
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : E_NOINTERFACE
 *
 *  @devnote
 *      This interface is aggregated. See textserv.cpp for discussion.
 */
HRESULT CTxtEdit::QueryInterface(
    REFIID riid,
    void **ppv)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::QueryInterface");

    return _punk->QueryInterface(riid, ppv);
}

/*
 *  CTxtEdit::AddRef()
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      ULONG - incremented reference count
 */
ULONG CTxtEdit::AddRef(void)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::AddRef");

    return _punk->AddRef();
}

/*
 *  CTxtEdit::Release()
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      ULONG - decremented reference count
 */
ULONG CTxtEdit::Release(void)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::Release");

    return _punk->Release();
}

////////////////////////// Undo Management  //////////////////////////////

/*
 *  CTxtEdit::CreateUndoMgr (dwLim, flags)
 *
 *  @mfunc
 *      Creates an undo stack
 *
 *  @rdesc
 *      Ptr to new IUndoMgr
 */
IUndoMgr *CTxtEdit::CreateUndoMgr(
    DWORD   dwLim,          //@parm Size limit
    USFlags flags)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CreateUndoMgr");

    IUndoMgr *pmgr = NULL;

    if(_fUseUndo)
    {
        pmgr = new CUndoStack(this, dwLim, flags);
        if(!pmgr)
            return NULL;

        if(!pmgr->GetUndoLimit())
        {
            // The undo stack failed to initialize properly (probably
            // lack of memory). Trash it and return NULL.
            pmgr->Destroy();
            return NULL;
        }
        // We may be asked to create a new undo/redo manager
        // before we are completely done with initialization.
        // We need to clean up memory we have already allocated.
        if(flags & US_REDO)
        {
            if(_predo)
                _predo->Destroy();
            _predo = pmgr;
        }
        else
        {
            if(_pundo)
                _pundo->Destroy();
            _pundo = pmgr;
        }
    }
    return pmgr;
}

/*
 *  CTxtEdit::HandleUndoLimit (dwLim)
 *
 *  @mfunc
 *      Handles the EM_SETUNDOLIMIT message
 *
 *  @rdesc
 *      Actual limit to which things were set.
 */
LRESULT CTxtEdit::HandleSetUndoLimit(
    LONG Count)         //@parm Requested limit size
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::HandleSetUndoLimit");

    if (Count == tomSuspend ||              // This option really just
        Count == tomResume)                 //  suspends undo, i.e.,
    {                                       //  doesn't discard existing
        _fUseUndo = (Count == tomResume);   //  antievents
        return _pundo ? _pundo->GetUndoLimit() : 0;
    }

    if(Count < 0)
        Count = DEFAULT_UNDO_SIZE;

    if(!Count)
    {
        _fUseUndo = FALSE;
        if(_pundo)
        {
            _pundo->Destroy();
            _pundo = NULL;
        }
        if(_predo)
        {
            _predo->Destroy();
            _predo = NULL;
        }
    }
    else if(!_pundo)
    {
        _fUseUndo = TRUE;
        // Don't worry about return value; if it's NULL, we're
        // in the same boat as if the API wasn't called (so later
        // on, we might try to allocate the default).
        CreateUndoMgr(Count, US_UNDO);
    }
    else
    {
        Count = _pundo->SetUndoLimit(Count);

        // Setting the undo limit on the undo stack will return to
        // us the actual amount set.  Try to set the redo stack to
        // the same size.  If it can't go that big, too bad.
        if(_predo)
            _predo->SetUndoLimit(Count);
    }
    return Count;
}

/*
 *  CTxtEdit::HandleSetTextMode(mode)
 *
 *  @mfunc  handles setting the text mode
 *
 *  @rdesc  LRESULT; 0 (NOERROR) on success, OLE failure code on failure.
 *
 *  @devnote    the text mode does not have to be fully specified; it
 *          is sufficient to merely specify the specific desired behavior.
 *
 *          Note that the edit control must be completely empty for this
 *          routine to work.
 */
LRESULT CTxtEdit::HandleSetTextMode(
    DWORD mode)         //@parm the desired mode
{
    LRESULT lres = 0;

    // First off, we must be completely empty
    if (GetAdjustedTextLength() ||
        _pundo && _pundo->CanUndo() ||
        _predo && _predo->CanUndo())
    {
        return E_UNEXPECTED;
    }

    // These bits are considered one at a time; thus the absence of
    // any bits does _NOT_ imply any change in behavior.

    // TM_RICHTEXT && TM_PLAINTEXT are mutually exclusive; they cannot
    // be both set.  Same goes for TM_SINGLELEVELUNDO / TM_MULTILEVELUNDO
    // and TM_SINGLECODEPAGE / TM_MULTICODEPAGE
    if((mode & (TM_RICHTEXT | TM_PLAINTEXT)) == (TM_RICHTEXT | TM_PLAINTEXT) ||
       (mode & (TM_SINGLELEVELUNDO | TM_MULTILEVELUNDO)) ==
            (TM_SINGLELEVELUNDO | TM_MULTILEVELUNDO) ||
       (mode & (TM_SINGLECODEPAGE | TM_MULTICODEPAGE)) ==
            (TM_SINGLECODEPAGE | TM_MULTICODEPAGE))
    {
        lres = E_INVALIDARG;
    }
    else if((mode & TM_PLAINTEXT) && IsRich())
        lres = OnRichEditChange(FALSE);

    else if((mode & TM_RICHTEXT) && !IsRich())
        lres = OnRichEditChange(TRUE);

    if(!lres)
    {
        if(mode & TM_SINGLELEVELUNDO)
        {
            if(!_pundo)
                CreateUndoMgr(1, US_UNDO);

            if(_pundo)
            {
                // We can 'Enable' single level mode as many times
                // as we want, so no need to check for it before hand.
                lres = ((CUndoStack *)_pundo)->EnableSingleLevelMode();
            }
            else
                lres = E_OUTOFMEMORY;
        }
        else if(mode & TM_MULTILEVELUNDO)
        {
            // If there's no undo stack, no need to do anything,
            // we're already in multi-level mode
            if(_pundo && ((CUndoStack *)_pundo)->GetSingleLevelMode())
                ((CUndoStack *)_pundo)->DisableSingleLevelMode();
        }

        if(mode & TM_SINGLECODEPAGE)
            _fSingleCodePage = TRUE;

        else if(mode & TM_MULTICODEPAGE)
            _fSingleCodePage = FALSE;
    }

    // We don't want this marked modified after this operation to make us
    // work better in dialog boxes.
    _fModified = FALSE;

    return lres;
}


////////////////////////// Uniscribe Interface //////////////////////////////

/*
 *  GetUniscribe()
 *
 *  @mfunc
 *      returns a pointer to the Uniscribe interface object
 *
 *  @rdesc
 *      Ptr to Uniscribe interface
 */
extern BOOL g_fNoUniscribe;
CUniscribe* GetUniscribe()
{
    if (g_pusp)
        return g_pusp;

    if (g_fNoUniscribe)
        return NULL;

    //Attempt to create the Uniscribe object, but make sure the
    //OS is valid and that we can load the uniscribe DLL.
    int cScripts;
    //Find out if OS is valid, or if delay-load fails
    if (!IsSupportedOS() || FAILED(ScriptGetProperties(NULL, &cScripts)))
    {
        g_fNoUniscribe = TRUE;
        return NULL;
    }

    if (!g_pusp)
        g_pusp = new CUniscribe();

    AssertSz(g_pusp, "GetUniscribe(): Create Uniscribe object failed");
    return g_pusp;
}


////////////////////////// Notification Manager //////////////////////////////

/*
 *  CTxtEdit::GetNotifyMgr()
 *
 *  @mfunc
 *      returns a pointer to the notification manager (creating it if necessary)
 *
 *  @rdesc
 *      Ptr to notification manager
 */
CNotifyMgr *CTxtEdit::GetNotifyMgr()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetNotifyMgr");

    return &_nm;
}


////////////////////////// Object Manager ///////////////////////////////////

/*
 *  CTxtEdit::GetObjectMgr()
 *
 *  @mfunc
 *      returns a pointer to the object manager (creating if necessary)
 *
 *  @rdesc
 *      pointer to the object manager
 */
CObjectMgr *CTxtEdit::GetObjectMgr()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetObjectMgr");

    if(!_pobjmgr)
        _pobjmgr = new CObjectMgr();

    return _pobjmgr;
}


////////////////////////////// Properties - Selection ////////////////////////////////


LONG CTxtEdit::GetSelMin() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSelMin");

    return _psel ? _psel->GetCpMin() : 0;
}

LONG CTxtEdit::GetSelMost() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSelMost");

    return _psel ? _psel->GetCpMost() : 0;
}


////////////////////////////// Properties - Text //////////////////////////////////////

LONG CTxtEdit::GetTextRange(
    LONG    cpFirst,
    LONG    cch,
    TCHAR * pch)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetTextRange");

#ifdef DEBUG
    const LONG cchAsk = cch;
#endif
    CTxtPtr tp(this, cpFirst);
    LONG    cchAdj = GetAdjustedTextLength();

    if(--cch < 0 || cpFirst > cchAdj)
        return 0;

    cch = min(cch, cchAdj - cpFirst);
    if(cch > 0)
    {
        cch = tp.GetText(cch, pch);
        Assert(cch >= 0);
    }
    pch[cch] = TEXT('\0');

#ifdef DEBUG
    if(cch != cchAsk - 1)
        Tracef(TRCSEVINFO, "CTxtEdit::GetTextRange: only got %ld out of %ld", cch, cchAsk - 1);
#endif

    return cch;
}

/*
 *  CTxtEdit::GetTextEx (pgt, pch)
 *
 *  @mfunc
 *      Grabs text according to various params
 *
 *  @rdesc
 *      Count of bytes gotten
 */
LONG CTxtEdit::GetTextEx(
    GETTEXTEX *pgt,     //@parm Info on what to get
    TCHAR *    pch)     //@parm Where to put the text
{
    LONG    cb;
    LONG    cch;
    LONG    cchGet = GetAdjustedTextLength();
    TCHAR * pchUse = pch;
    CTxtPtr tp(this, 0);
    CTempWcharBuf twcb;

    if(pgt->flags & GT_SELECTION)           // Get selected text
    {
        LONG cpMin, cpMost;
        cch = GetSel()->GetRange(cpMin, cpMost);
        cchGet = min(cch, cchGet - cpMin);  // Don't include final EOP
        tp.SetCp(cpMin);
    }

    if(pgt->codepage == (unsigned)-1)   // Use default codepage
        pgt->codepage = GetDefaultCodePage(EM_GETTEXTEX);

    if(pgt->cb == (unsigned)-1)         // Client says its buffer is big enuf
    {
        pgt->cb = cchGet + 1;
        if(W32->IsFECodePage(pgt->codepage) || pgt->codepage == 1200)
            pgt->cb += cchGet;
        else if(pgt->codepage == CP_UTF8 && (_dwCharFlags & ~fASCII))
            pgt->cb *= (_dwCharFlags & fABOVEX7FF) ? 3 : 2;
    }

    // Allocate a big buffer; make sure that we have
    // enough room for lots of CRLFs if necessary
    if(pgt->flags & GT_USECRLF)
        cchGet *= 2;

    if(pgt->codepage != 1200)
    {
        // If UNICODE, copy straight to client's buffer;
        // else, copy to temp buffer and translate cases first
        pchUse = twcb.GetBuf(cchGet + 1);
        if (pch)
            *((char *) pch) = '\0';         // In case something fails
    }
    else                        // Be sure to leave room for NULL terminator
        cchGet = min(UINT(pgt->cb/2 - 1), (UINT)cchGet);

    // Now grab the text.
    if(pgt->flags & GT_USECRLF)
        cch = tp.GetPlainText(cchGet, pchUse, tomForward, FALSE);
    else
        cch = tp.GetText(cchGet, pchUse);

    pchUse[cch] = L'\0';

    // If we're just doing UNICODE, return number of chars written
    if(pgt->codepage == 1200)
        return cch;

    // Oops, gotta translate to ANSI.
    cb = WideCharToMultiByte(pgt->codepage, 0, pchUse, cch + 1, (char *)pch,
            pgt->cb, pgt->lpDefaultChar, pgt->lpUsedDefChar);

    // Don't count NULL terminator for compatibility with WM_GETTEXT.
    return (cb) ? cb - 1 : 0;
}

/*
 *  CTxtEdit::GetTextLengthEx (pgtl)
 *
 *  @mfunc
 *      Calculates text length in various ways.
 *
 *  @rdesc
 *      Text length calculated in various ways
 *
 *  @comm
 *      This function returns an API cp that may differ from the
 *      corresponding internal Unicode cp.
 */
LONG CTxtEdit::GetTextLengthEx(
    GETTEXTLENGTHEX *pgtl)  //@parm Info describing how to calculate length
{
    LONG    cchUnicode = GetAdjustedTextLength();
    LONG    cEOP = 0;
    DWORD   dwFlags = pgtl->flags;
    GETTEXTEX gt;

    if(pgtl->codepage == (unsigned)-1)
        pgtl->codepage = GetDefaultCodePage(EM_GETTEXTLENGTHEX);

    // Make sure the flags are defined appropriately
    if ((dwFlags & GTL_CLOSE)    && (dwFlags & GTL_PRECISE) ||
        (dwFlags & GTL_NUMCHARS) && (dwFlags & GTL_NUMBYTES))
    {
        TRACEWARNSZ("Invalid flags for EM_GETTEXTLENGTHEX");
        return E_INVALIDARG;
    }

    // Note in the following if statement, the second part of the
    // and clause will always be TRUE. At some point in the future
    // fUseCRLF and Get10Mode may become independent, in which case
    // the code below will automatically work without change.
	// NEW: 1.0 mode gets text as is, so don't add count for CRs.
	// (RichEdit 1.0 only inserts Enters as CRLFs; it doesn't "cleanse"
	// other text insertion strings)
	if((dwFlags & GTL_USECRLF) && !fUseCRLF() && !Get10Mode())
	{
		// Important facts for 1.0 mode (REMARK: this is out of date):
        //
        // (1) 1.0 mode implies that the text is stored with fUseCRLF true.
        // fUseCRLF means that the EOP mark can either be a CR or a
        // CRLF - see CTxtRange::CleanseAndReplaceRange for details.
        //
        // (2) 1.0 mode has an invariant that the count of text returned
        // by this call should be enough to hold all the text returned by
        // WM_GETTEXT.
        //
        // (3) The WM_GETEXT call for 1.0 mode will return a buffer in
        // which all EOPs that consist of a CR are replaced by CRLF.
        //
        // Therefore, for 1.0 mode, we must count all EOPs that consist
        // of only a CR and add addition return character to count the
        // LF that will be added into any WM_GETEXT buffer.

        // For 2.0 mode, the code is much easier, just count up all
        // CRs and bump count of each one by 1.

        CTxtPtr tp(this, 0);
        LONG    Results;

        while(tp.FindEOP(tomForward, &Results))
        {
            // If EOP consists of 1 char, add 1 since is returned by a CRLF.
            // If it consists of 2 chars, add 0, since it's a CRLF and is
            // returned as such.
            if(tp.GetCp() > cchUnicode)     // Don't add correction for
                break;                      //  final CR (if any)
            Results &= 3;
            if(Results)
                cEOP += 2 - Results;

            AssertSz(IN_RANGE(1, Results, 2) || !Results && tp.GetCp() == cchUnicode,
                "CTxtEdit::GetTextLengthEx: CRCRLF found in backing store");
        }
        cchUnicode += cEOP;
    }

	// If we're just looking for the number of characters or if it's an
	// 8-bit codepage in RE 1.0 mode, we've already got the count.
	if ((dwFlags & GTL_NUMCHARS) || !dwFlags ||
		Get10Mode() && Is8BitCodePage(pgtl->codepage))
	{
        return cchUnicode;
	}

    // Hmm, they're looking for number of bytes, but don't care about
    // precision, just multiply by two.  If neither PRECISE or CLOSE is
	// specified, default to CLOSE. Note if the codepage is UNICODE and
	// asking for number of bytes, we also just multiply by 2.
    if((dwFlags & GTL_CLOSE) || !(dwFlags & GTL_PRECISE) ||
        pgtl->codepage == 1200)
    {
        return cchUnicode *2;
    }

	// In order to get a precise answer, we need to convert (which is slow!).
    gt.cb = 0;
    gt.flags = (pgtl->flags & GT_USECRLF);
    gt.codepage = pgtl->codepage;
    gt.lpDefaultChar = NULL;
    gt.lpUsedDefChar = NULL;

    return GetTextEx(&gt, NULL);
}

/*
 *  CTxtEdit::GetDefaultCodePage (msg)
 *
 *  @mfunc
 *      Return codepage to use for converting the text in RichEdit20A text
 *      messages.
 *
 *  @rdesc
 *      Codepage to use for converting the text in RichEdit20A text messages.
 */
LONG CTxtEdit::GetDefaultCodePage(
    UINT msg)
{
    LONG CodePage = GetACP();

    // FUTURE: For backward compatibility in Office97, We always use ACP for all these
    // languages. Need review in the future when the world all moves to Unicode.
    if (W32->IsBiDiCodePage(CodePage) || CodePage == CP_THAI || CodePage == CP_VIETNAMESE ||
        W32->IsFECodePage(CodePage) || _fSingleCodePage || msg == EM_GETCHARFORMAT ||
        msg == EM_SETCHARFORMAT)
    {
        return CodePage;
    }

    if(Get10Mode())
        return GetCodePage(GetCharFormat(-1)->_bCharSet);

    return GetKeyboardCodePage();
}

//////////////////////////////  Properties - Formats  //////////////////////////////////

/*
 *  CTxtEdit::HandleStyle (pCFTarget, pCF, dwMask, dwMask2)
 *
 *  @mfunc
 *      If pCF specifies a style choice, initialize pCFTarget with the
 *      appropriate style, apply pCF, and return NOERROR.  Else return
 *      S_FALSE or an error
 *
 *  @rdesc
 *      HRESULT = (pCF specifies a style choice) ? NOERROR : S_FALSE or error code
 */
HRESULT CTxtEdit::HandleStyle(
    CCharFormat *pCFTarget,     //@parm Target CF to receive CF style content
    const CCharFormat *pCF,     //@parm Source CF that may specify a style
    DWORD        dwMask,        //@parm CHARFORMAT2 mask
    DWORD        dwMask2)       //@parm Second mask
{
    if(pCF->fSetStyle(dwMask, dwMask2))
    {
        // FUTURE: generalize to use client style if specified
        *pCFTarget = *GetCharFormat(-1);
        pCFTarget->ApplyDefaultStyle(pCF->_sStyle);
        return pCFTarget->Apply(pCF, dwMask, dwMask2);
    }
    return S_FALSE;
}

/*
 *  CTxtEdit::HandleStyle (pPFTarget, pPF)
 *
 *  @mfunc
 *      If pPF specifies a style choice, initialize pPFTarget with the
 *      appropriate style, apply pPF, and return NOERROR.  Else return
 *      S_FALSE or an error
 *
 *  @rdesc
 *      HRESULT = (pPF specifies a style choice) ? NOERROR : S_FALSE or error code
 */
HRESULT CTxtEdit::HandleStyle(
    CParaFormat *pPFTarget,     //@parm Target PF to receive PF style content
    const CParaFormat *pPF,     //@parm Source PF that may specify a style
    DWORD       dwMask)         //@parm Mask to use in setting CParaFormat
{
    if(pPF->fSetStyle(dwMask))
    {
        // FUTURE: generalize to use client style if specified
        *pPFTarget = *GetParaFormat(-1);
        pPFTarget->ApplyDefaultStyle(pPF->_sStyle);
        return pPFTarget->Apply(pPF, dwMask);
    }
    return S_FALSE;
}

//////////////////////////// Mouse Commands /////////////////////////////////


HRESULT CTxtEdit::OnTxLButtonDblClk(
    INT     x,          //@parm Mouse x coordinate
    INT     y,          //@parm Mouse y coordinate
    DWORD   dwFlags)    //@parm Mouse message wparam
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxLButtonDblClk");

    BOOL            fEnterParaSelMode = FALSE;
    HITTEST         Hit;
    CTxtSelection * psel = GetSel();
    const POINT     pt = {x, y};

    AssertSz(psel, "CTxtEdit::OnTxLButtonDblClk() - No selection object !");

    if (StopMagellanScroll())
        return S_OK;

    _dwTickDblClick = GetTickCount();
    _ptDblClick.x = x;
    _ptDblClick.y = y;

    TxUpdateWindow();       // Repaint window to show any exposed portions

    if(!_fFocus)
    {
        TxSetFocus();                   // Create and display caret
        return S_OK;
    }

    // Find out what the cursor is pointing at
    _pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, &Hit);

    if(Hit == HT_Nothing)
        return S_OK;

    if(Hit == HT_OutlineSymbol)
    {
        CTxtRange rg(*psel);
        rg.ExpandOutline(0, FALSE);
        return S_OK;
    }

    if(Hit == HT_LeftOfText)
        fEnterParaSelMode = TRUE;

    _fWantDrag = FALSE;                 // just to be safe

    // If we are over a link, let the client have a chance to process
    // the message
    if(Hit == HT_Link && HandleLinkNotification(WM_LBUTTONDBLCLK, (WPARAM)dwFlags,
            MAKELPARAM(x, y)))
    {
        return S_OK;
    }

    if(dwFlags & MK_CONTROL)
        return S_OK;

    // Mark mouse down
    _fMouseDown = TRUE;

    if(_pobjmgr && _pobjmgr->HandleDoubleClick(this, pt, dwFlags))
    {
        // The object subsystem handled everything
        _fMouseDown = FALSE;
        return S_OK;
    }

    // Update the selection
    if(fEnterParaSelMode)
        psel->SelectUnit(pt, tomParagraph);
    else
        psel->SelectWord(pt);

    return S_OK;
}

HRESULT CTxtEdit::OnTxLButtonDown(
    INT     x,          //@parm Mouse x coordinate
    INT     y,          //@parm Mouse y coordinate
    DWORD   dwFlags)    //@parm Mouse message wparam
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxLButtonDown");

    BOOL        fEnterLineSelMode = FALSE;
    BOOL        fShift = dwFlags & MK_SHIFT;
    HITTEST     Hit;
    const POINT pt = {x, y};
    COleObject *pobj;
    BOOL        fMustThaw = FALSE;

    const BOOL fTripleClick = GetTickCount() < _dwTickDblClick + W32->GetDCT() &&
                abs(x - _ptDblClick.x) <= W32->GetCxDoubleClk() &&
                abs(y - _ptDblClick.y) <= W32->GetCyDoubleClk();

    if (StopMagellanScroll())
        return S_OK;

    // If click isn't inside view, just activate, don't select

    if(!_fFocus)                    // Sets focus if not already
    {
        // We may be removing an existing selection, so freeze
        // display to avoid flicker
        _pdp->Freeze();
        fMustThaw = TRUE;
        TxSetFocus();               // creates and displays caret
    }

    // Grab selection object
    CTxtSelection * const psel = GetSel();
    AssertSz(psel,"CTxtEdit::OnTxLButtonDown - No selection object !");

    // Find out what cursor is pointing at
    _pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, &Hit);

    if(Hit == HT_LeftOfText)
    {
        // Shift click in sel bar treated as normal click
        if(!fShift)
        {
            // Control selbar click and triple selbar click
            // are select all
            if((dwFlags & MK_CONTROL) || fTripleClick)
            {
                psel->SelectAll();
                goto cancel_modes;
            }
            fEnterLineSelMode = TRUE;
            if(!GetAdjustedTextLength() && !_pdp->IsMultiLine())
            {
                const CParaFormat *pPF = psel->GetPF();
                // Can't see selected para mark when flushed right, so
                // leave selection as an insertion point
                if(pPF->_bAlignment == PFA_RIGHT && !pPF->IsRtlPara())
                    fEnterLineSelMode = FALSE;
            }
        }
    }
    else if(Hit == HT_Nothing)
        goto cancel_modes;

    else if(!fShift)
        psel->CancelModes();

    // Let client have a chance to handle this message if we are over a link
    if(Hit == HT_Link && HandleLinkNotification(WM_LBUTTONDOWN, (WPARAM)dwFlags,
            MAKELPARAM(x, y)))
    {
        goto cancel_modes;
    }

    _fMouseDown = TRUE;                     // Flag mouse down
    if(!fShift && _pobjmgr)
    {
        // Deactivate anybody active, etc.
        ClickStatus status = _pobjmgr->HandleClick(this, pt);
        if(status == CLICK_OBJSELECTED)
        {
            // The object subsystem will handle resizing.
            // if not a resize we will signal start of drag
            pobj = _pobjmgr->GetSingleSelect();

            // Because HandleClick returned true, pobj better be non-null.
            Assert(pobj);

            if (!pobj->HandleResize(pt))
                _fWantDrag = !_fDisableDrag;

            goto cancel_modes;
        }
        else if(status == CLICK_OBJDEACTIVATED)
            goto cancel_modes;
    }

    _fCapture = TRUE;                       // Capture the mouse
    TxSetCapture(TRUE);

    // Check for start of drag and drop
    if(!fTripleClick && !fShift && psel->PointInSel(pt, NULL, Hit)
        && !_fDisableDrag)
    {
        // Assume we want a drag. If we don't CmdLeftUp() needs
        //  this to be set anyway to change the selection
        _fWantDrag = TRUE;

        goto cancel_modes;
    }

    if(fShift)                              // Extend selection from current
    {                                       //  active end to click
        psel->InitClickForAutWordSel(pt);
        psel->ExtendSelection(pt);
    }
    else if(fEnterLineSelMode)              // Line selection mode: select line
        psel->SelectUnit(pt, tomLine);
    else if(fTripleClick || Hit == HT_OutlineSymbol) // paragraph selection mode
        psel->SelectUnit(pt, tomParagraph);
    else
    {
        if (Get10Mode())
            _f10DeferChangeNotify = 1;
        psel->SetCaret(pt);
        _mousePt = pt;
    }

    if(fMustThaw)
        _pdp->Thaw();

    return S_OK;

cancel_modes:
    psel->CancelModes();

    if(_fWantDrag)
    {
        TxSetTimer(RETID_DRAGDROP, W32->GetDragDelay());
        _mousePt = pt;
        _bMouseFlags = (BYTE)dwFlags;
        _fDragged = FALSE;
    }

    if(fMustThaw)
        _pdp->Thaw();

    return S_OK;
}

HRESULT CTxtEdit::OnTxLButtonUp(
    INT     x,              //@parm Mouse x coordinate
    INT     y,              //@parm Mouse y coordinate
    DWORD   dwFlags,        //@parm Mouse message wparam
    int     ffOptions)      //@parm Mouse options, see _edit.h for details
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxLButtonUp");

    CheckRemoveContinuousScroll();

    // Remove capture before test for mouse down since we wait till
    // we get the mouse button up message to release capture since Forms
    // wants it that way.
    if(_fCapture && (ffOptions & LB_RELEASECAPTURE))
    {
        TxSetCapture(FALSE);
        _fCapture = FALSE;
    }

    // we were delaying selection change.  So send it now...
    if (DelayChangeNotification() && (ffOptions & LB_FLUSHNOTIFY))
    {
        AssertSz(Get10Mode(), "Flag should only be set in 10 mode");
        _f10DeferChangeNotify = 0;
        GetCallMgr()->SetSelectionChanged();
    }

    if(!_fMouseDown)
    {
        // We noticed the mouse was no longer down earlier so we don't
        // need to do anything.
        return S_OK;
    }

    const BOOL fSetSel = !!_fWantDrag;
    const POINT pt = {x, y};

    // Cancel Auto Word Sel if on
    CTxtSelection * const psel = GetSel();
    AssertSz(psel,"CTxtEdit::OnLeftUp() - No selection object !");

    psel->CancelModes(TRUE);

    // Reset flags
    _fMouseDown = FALSE;
    _fWantDrag = FALSE;
    _fDragged = FALSE;
    TxKillTimer(RETID_DRAGDROP);
    if(IsInOutlineView())
        psel->Update(FALSE);

    // Let the client handle this message if we are over a
    // link area
    if(HandleLinkNotification(WM_LBUTTONUP, (WPARAM)dwFlags,
            MAKELPARAM(x, y)))
    {
        return NOERROR;
    }

    // If we were in drag & drop, put caret under mouse
    if(fSetSel)
    {
        CObjectMgr* pobjmgr = GetObjectMgr();

        // If we were on an object, don't deselect it by setting the caret
        if(pobjmgr && !pobjmgr->GetSingleSelect())
        {
            psel->SetCaret(pt, TRUE);
            if(!_fFocus)
                TxSetFocus();       // create and display caret
        }
    }
    return S_OK;
}

HRESULT CTxtEdit::OnTxRButtonUp(
    INT     x,          //@parm Mouse x coordinate
    INT     y,          //@parm Mouse y coordinate
    DWORD   dwFlags,    //@parm Mouse message wparam
    int     ffOptions)  //@parm option flag
{
    const POINT pt = {x, y};
    CTxtSelection * psel;
    SELCHANGE selchg;
    HMENU hmenu = NULL;
    IOleObject * poo = NULL;
    COleObject * pobj = NULL;
    IUnknown * pUnk = NULL;
    IRichEditOleCallback * precall = NULL;

    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxRButtonUp");

    // make sure we have the focus
    if(!_fFocus)
        TxSetFocus();

    if(_fWantDrag)
    {
        _fDragged = FALSE;
        _fWantDrag = FALSE;
        TxKillTimer(RETID_DRAGDROP);
    }

    // Grab selection object
    psel = GetSel();
    psel->SetSelectionInfo(&selchg);

    //We need a pointer to the first object, if any, in the selection.
    if(_pobjmgr)
    {
        //If the point is in the selection we need to find out if there
        //are any objects in the selection.  If the point is not in a
        //selection but it is on an object, we need to select the object.
        if(psel->PointInSel(pt, NULL) || (ffOptions & RB_FORCEINSEL))
        {
            pobj = _pobjmgr->GetFirstObjectInRange(selchg.chrg.cpMin,
                selchg.chrg.cpMost);
        }
        else
        {
            //Select the object
            if(_pobjmgr->HandleClick(this, pt) == CLICK_OBJSELECTED)
            {
                pobj = _pobjmgr->GetSingleSelect();
                // Because HandleClick returned true, pobj better be non-null.
                Assert(pobj!=NULL);
                //Refresh our information about the selection
                psel = GetSel();
                psel->SetSelectionInfo(&selchg);
            }
        }
        precall = _pobjmgr->GetRECallback();
    }

    if(pobj)
        pUnk = pobj->GetIUnknown();

    if(pUnk)
        pUnk->QueryInterface(IID_IOleObject, (void **)&poo);

    if(precall)
        precall->GetContextMenu(selchg.seltyp, poo, &selchg.chrg, &hmenu);

    if(hmenu)
    {
        HWND hwnd, hwndParent;
        POINT ptscr;

        if(TxGetWindow(&hwnd) == NOERROR)
        {
            if(!(ffOptions & RB_NOSELCHECK) && !psel->PointInSel(pt, NULL) &&
                !psel->GetCch() && !(ffOptions & RB_FORCEINSEL))
                psel->SetCaret(pt);
            ptscr.x = pt.x;
            ptscr.y = pt.y;
            ClientToScreen(hwnd, &ptscr);

            hwndParent = GetParent(hwnd);
            if(!hwndParent)
                hwndParent = hwnd;

            TrackPopupMenu(hmenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                ptscr.x, ptscr.y, 0, hwndParent, NULL);
        }
        DestroyMenu(hmenu);
    }

    if(poo)
        poo->Release();

    return precall ? S_OK : S_FALSE;
}

HRESULT CTxtEdit::OnTxRButtonDown(
    INT     x,          //@parm Mouse x coordinate
    INT     y,          //@parm Mouse y coordinate
    DWORD   dwFlags)    //@parm Mouse message wparam
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxRButtonDown");

    if (StopMagellanScroll())
        return S_OK;

    CTxtSelection *psel = GetSel();
    const POINT pt = {x, y};

    psel->CancelModes();

    if(psel->PointInSel(pt, NULL) && !_fDisableDrag)
    {
        _fWantDrag = TRUE;

        TxSetTimer(RETID_DRAGDROP, W32->GetDragDelay());
        _mousePt = pt;
        _bMouseFlags = (BYTE)dwFlags;
        _fDragged = FALSE;
        return S_OK;
    }
    return S_FALSE;
}

HRESULT CTxtEdit::OnTxMouseMove(
    INT     x,          //@parm Mouse x coordinate
    INT     y,          //@parm Mouse y coordinate
    DWORD   dwFlags,    //@parm Mouse message wparam
    IUndoBuilder *publdr)
{
    int     dx, dy;
    BOOL    fLButtonDown = FALSE;
    BOOL    fRButtonDown = FALSE;
    DWORD   vkLButton, vkRButton;

    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxMouseMove");

    CTxtSelection * const psel = GetSel();

    if(!_fFocus)
        return S_OK;

    if(_fWantDrag || _fCapture)
    {
        LONG nDragMinDist = W32->GetDragMinDist() + 3;
        dx = _mousePt.x > x ? _mousePt.x - x : x - _mousePt.x;
        dy = _mousePt.y > y ? _mousePt.y - y : y - _mousePt.y;
        if(dx < nDragMinDist && dy < nDragMinDist)
        {
            _bMouseFlags = (BYTE)dwFlags;
            return S_OK;
        }
        _fDragged = _fWantDrag;
    }

    _mousePt.x = x;                                 // Remember for scrolling
    _mousePt.y = y;                                 //  speed, and dir calc.

    // RichEdit 1.0 allows the client to process mouse moves itself if
    // we are over a link (but _not_ doing drag drop).
    if(HandleLinkNotification(WM_MOUSEMOVE, 0, MAKELPARAM(x, y)))
        return NOERROR;

    // If we think the mouse is down and it really is then do special
    // processing.
    if(GetSystemMetrics(SM_SWAPBUTTON))
    {
        vkLButton = VK_RBUTTON;
        vkRButton = VK_LBUTTON;
    }
    else
    {
        vkLButton = VK_LBUTTON;
        vkRButton = VK_RBUTTON;
    }

    fLButtonDown = (GetAsyncKeyState(vkLButton) < 0);
    if(!fLButtonDown)
        fRButtonDown = (GetAsyncKeyState(vkRButton) < 0);

    if(fLButtonDown || fRButtonDown)
    {
        if(_fWantDrag
            && !_fUsePassword
            && !IsProtected(_fReadOnly ? WM_COPY : WM_CUT, dwFlags,
                    MAKELONG(x,y)))
        {
            TxKillTimer(RETID_DRAGDROP);
            _ldte.StartDrag(psel, publdr);
            // the mouse button may still be down, but drag drop is over
            // so we need to _think_ of it as up.
            _fMouseDown = FALSE;

            // similarly, OLE should have nuked the capture for us, but
            // just in case something failed, release the capture.
            TxSetCapture(FALSE);
            _fCapture = FALSE;
        }
        else if(_fMouseDown)
        {
            POINT   pt = _mousePt;

            // We think mouse is down and it is
            if(_ldte.fInDrag())
            {
                // Only do drag scrolling if a drag operation is in progress.
                _pdp->DragScroll(&pt);
            }

            AssertSz(psel,"CTxtEdit::OnMouseMove: No selection object !");
            psel->ExtendSelection(pt);              // Extend the selection

            CheckInstallContinuousScroll ();
        }
    }
    else if (!(GetAsyncKeyState(VK_MBUTTON) < 0) && !mouse.IsAutoScrolling())
    {
        // Make sure we aren't autoscrolling via intellimouse

        if(_fMButtonCapture)
            OnTxMButtonUp (x, y, dwFlags);

        if(_fMouseDown)
        {
            // Although we thought the mouse was down, at this moment it
            // clearly is not. Therefore, we pretend we got a mouse up
            // message and clear our state to get ourselves back in sync
            // with what is really happening.
            OnTxLButtonUp(x, y, dwFlags, LB_RELEASECAPTURE);
        }

    }

    // Either a drag was started or the mouse button was not down. In either
    // case, we want no longer to start a drag so we set the flag to false.
    _fWantDrag = FALSE;
    return S_OK;
}

/*
 *  OnTxMButtonDown (x, y, dwFlags)
 *
 *  @mfunc
 *      The user pressed the middle mouse button, setup to do
 *      continuous scrolls, which may in turn initiate a timer
 *      for smooth scrolling.
 *
 *  @rdesc
 *      HRESULT = S_OK
 */
HRESULT CTxtEdit::OnTxMButtonDown (
    INT     x,          //@parm Mouse x coordinate
    INT     y,          //@parm Mouse y coordinate
    DWORD   dwFlags)    //@parm Mouse message wparam
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxMButtonDown");

#if !defined(NOMAGELLAN)
    POINT   mDownPt = {x,y};

    if(!_fFocus)
        TxSetFocus();

    if(!StopMagellanScroll() && mouse.MagellanStartMButtonScroll(*this, mDownPt))
    {
        TxSetCapture(TRUE);

        _fCapture           = TRUE;                         // Capture the mouse
        _fMouseDown         = TRUE;
        _fMButtonCapture    = TRUE;
    }
#endif

    return S_OK;
}

/*
 *  CTxtEdit::OnTxMButtonUp (x, y, dwFlags)
 *
 *  @mfunc
 *      Remove timers and capture assoicated with a MButtonDown
 *      message.
 *
 *  @rdesc
 *      HRESULT = S_OK
 */
HRESULT CTxtEdit::OnTxMButtonUp (
    INT     x,          //@parm Mouse x coordinate
    INT     y,          //@parm Mouse y coordinate
    DWORD   dwFlags)    //@parm Mouse message wparam
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxMButtonUp");

#if !defined(NOMAGELLAN)
    if (mouse.ContinueMButtonScroll(x, y))
        return S_OK;

    StopMagellanScroll();

#else

    if(_fCapture)
        TxSetCapture(FALSE);

    _fCapture           = FALSE;
    _fMouseDown         = FALSE;
    _fMButtonCapture    = FALSE;

#endif

    return S_OK;
}


/*
 *  CTxtEdit::StopMagellanScroll()
 *
 *  @mfunc
 *      Stops the intellimouse autoscrolling and returns
 *      us back into a normal state
 *
 *  BOOL = TRUE if auto scrolling was turned off : FALSE
 *          Autoscrolling was never turned on
 */
 BOOL CTxtEdit::StopMagellanScroll ()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::StopMagellanScroll");

#if !defined(NOMAGELLAN)
    if (!mouse.IsAutoScrolling())
        return FALSE;

    mouse.MagellanEndMButtonScroll(*this);

    if(_fCapture)
        TxSetCapture(FALSE);

    _fCapture           = FALSE;
    _fMouseDown         = FALSE;
    _fMButtonCapture    = FALSE;
    return TRUE;
#else
    return FALSE;
#endif
}


/*
 *  CTxtEdit::CheckInstallContinuousScroll ()
 *
 *  @mfunc
 *      There are no events that inform the app on a regular
 *      basis that a mouse button is down. This timer notifies
 *      the app that the button is still down, so that scrolling can
 *      continue.
 */
void CTxtEdit::CheckInstallContinuousScroll ()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CheckInstallContinuousScroll");

    if(!_fContinuousScroll && TxSetTimer(RETID_AUTOSCROLL, cmsecScrollInterval))
        _fContinuousScroll = TRUE;
}

/*
 *  CTxtEdit::CheckRemoveContinuousScroll ()
 *
 *  @mfunc
 *      The middle mouse button, or drag button, is up
 *      remove the continuous scroll timer.
 */
void CTxtEdit::CheckRemoveContinuousScroll ()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CheckRemoveContinuousScroll");

    if(_fContinuousScroll)
    {
        TxKillTimer(RETID_AUTOSCROLL);
        _fContinuousScroll = FALSE;
    }
}

/*
 *  OnTxTimer(idTimer)
 *
 *  @mfunc
 *      Handle timers for doing background recalc and scrolling.
 *
 *  @rdesc
 *      HRESULT = (idTimer valid) ? S_OK : S_FALSE
 */
HRESULT CTxtEdit::OnTxTimer(
    UINT idTimer)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxTimer");

    switch (idTimer)
    {
        case RETID_BGND_RECALC:
            _pdp->StepBackgroundRecalc();
            break;

#if !defined(NOMAGELLAN)
        case RETID_MAGELLANTRACK:
            mouse.TrackUpdateMagellanMButtonDown(*this, _mousePt);
            break;
#endif
        case RETID_AUTOSCROLL:                      // Continuous scrolling.
            OnTxMouseMove(_mousePt.x, _mousePt.y,   // Do a select drag scroll.
                          0, NULL);
            break;

#if !defined(NOMAGELLAN)
        case RETID_SMOOTHSCROLL:                    // Smooth scrolling
            if(_fMButtonCapture)                    // HACK, only 1 timer!
            {                                       // delivered on Win95
                                                    // when things get busy.
                mouse.TrackUpdateMagellanMButtonDown(*this, _mousePt);
            }
            if(_pdp->IsSmoothVScolling())           // Test only because of
                _pdp->SmoothVScrollUpdate();        //  above HACK!!
        break;
#endif
        case RETID_DRAGDROP:
            TxKillTimer(RETID_DRAGDROP);
            if (_fWantDrag && _fDragged && !_fUsePassword &&
                !IsProtected(_fReadOnly ? WM_COPY : WM_CUT,
                             _bMouseFlags, MAKELONG(_mousePt.x,_mousePt.y)))
            {
                IUndoBuilder *  publdr;
                CGenUndoBuilder undobldr(this, UB_AUTOCOMMIT, &publdr);
                _ldte.StartDrag(GetSel(), publdr);
                _fWantDrag = FALSE;
                _fDragged = FALSE;
                TxSetCapture(FALSE);
                _fCapture = FALSE;
            }
            break;

        default:
            return S_FALSE;
    }
    return S_OK;
}


/////////////////////////// Keyboard Commands ////////////////////////////////

/*
 *  CTxtEdit::OnTxKeyDown(vkey, dwFlags, publdr)
 *
 *  @mfunc
 *      Handle WM_KEYDOWN message
 *
 *  @rdesc
 *      HRESULT with the following values:
 *
 *      S_OK                if key was understood and consumed
 *      S_MSG_KEY_IGNORED   if key was understood, but not consumed
 *      S_FALSE             if key was not understood or just looked at
 *                                  and in any event not consumed
 */
HRESULT CTxtEdit::OnTxKeyDown(
    WORD          vkey,     //@parm Virtual key code
    DWORD         dwFlags,  //@parm lparam of WM_KEYDOWN msg
    IUndoBuilder *publdr)   //@parm Undobuilder to receive antievents
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxKeyDown");

    if(IN_RANGE(VK_SHIFT, vkey, VK_MENU))
    {
        SetKeyboardFlag(GetKbdFlags(vkey, dwFlags));
        return S_FALSE;
    }

    BOOL  fAlt   = GetKeyboardFlag(ALT, VK_MENU);
    BOOL  fCtrl  = GetKeyboardFlag(CTRL, VK_CONTROL);
    BOOL  fShift = GetKeyboardFlag(SHIFT, VK_SHIFT);

    BOOL  fRet   = FALSE;           // Converted to HRESULT on return
    LONG  nDeadKey = 0;

    if(fCtrl & fShift)                      // Signal NonCtrl/Shift keydown
        SetKeyboardFlag(LETAFTERSHIFT);     //  while Ctrl&Shift are down

    // Handle Hebrew caps and LRM/RLM
    if (IsBiDi())
    {
        if (W32->IsBiDiCodePage(GetKeyboardCodePage(0xFFFFFFFF)))
        {
            _fHbrCaps = FALSE;
            if(IsRich() && W32->UsingHebrewKeyboard())
            {
                WORD wCapital = GetKeyState(VK_CAPITAL);
                _fHbrCaps = ((wCapital & 1) ^ fShift) &&
                            !(wCapital & 0x0080) &&
                            IN_RANGE('A', vkey, 'Z');
                if(_fHbrCaps)
                    W32->ActivateKeyboard(ANSI_INDEX);
            }
        }

        if(vkey == VK_BACK && fShift && W32->OnWin9x())
        {
            // Shift+Backspace generates a LRM | RLM on a BiDi keyboard.
            // Consequently, we must eat the Backspace lest it delete text.
            W32->_fLRMorRLM = 1;
            return S_OK;
        }
    }

    // If dragging or Alt key down, just look for ESCAPE. Note: if Alt key is
    // down, we should never come here (would generate WM_SYSKEYDOWN message).
    if(_fMouseDown)
    {
        if(vkey == VK_ESCAPE)
        {
            // Turn-off autoscroll.
            if (StopMagellanScroll())
                return S_OK;

            POINT pt;
            // Cancel drag select or drag & drop
            GetCursorPos(&pt);
            OnTxLButtonUp(pt.x, pt.y, 0, LB_RELEASECAPTURE | LB_FLUSHNOTIFY);
            return S_OK;
        }
        return OnTxSpecialKeyDown(vkey, dwFlags, publdr);
    }

    CTxtSelection * const psel = GetSel();
    AssertSz(psel,"CTxtEdit::OnKeyDown() - No selection object !");

    if(fCtrl)
    {
        if(OnTxSpecialKeyDown(vkey, dwFlags, publdr) == S_OK)
            return S_OK;

        if(fAlt)                        // This following code doesn't handle
            return S_FALSE;             //  use Ctrl+Alt, which happens for
                                        //  AltGr codes (no WM_SYSKEYDOWN)

        // Shift must not be pressed for these.
        if(!fShift)
        {
            switch(vkey)
            {
            case 'E':
            case 'J':
            case 'R':
            case 'L':
            {
                CParaFormat PF;
                if (vkey == 'E')
                    PF._bAlignment = PFA_CENTER;
                else if (vkey == 'J')
                    PF._bAlignment = PFA_FULL_INTERWORD;
                else if (vkey == 'R')
                    PF._bAlignment = PFA_RIGHT;
                else
                    PF._bAlignment = PFA_LEFT;

                psel->SetParaFormat(&PF, publdr, PFM_ALIGNMENT);
                break;
            }
            case '1':
            case '2':
            case '5':
            {
                CParaFormat PF;
                PF._bLineSpacingRule = tomLineSpaceMultiple;
                PF._dyLineSpacing = (vkey - '0') * 20;
                if (vkey == '5')
                    PF._dyLineSpacing = 30;

                psel->SetParaFormat(&PF, publdr, PFM_LINESPACING);
                break;
            }
            default:
                break;
            }
        }

        switch(vkey)
        {
        case VK_TAB:
            return OnTxChar(VK_TAB, dwFlags, publdr);

        case VK_CLEAR:
        case VK_NUMPAD5:
        case 'A':                       // Ctrl-A => pselect all
            psel->SelectAll();
            break;

        //Toggle Subscript
        case 187: // =
        {
            ITextFont *pfont;
            psel->GetFont(&pfont);
            if (pfont)
            {
                pfont->SetSubscript(tomToggle);
                pfont->Release();
            }
        }
        break;

        case 'C':                       // Ctrl-C => copy
CtrlC:      CutOrCopySelection(WM_COPY, 0, 0, NULL);
            break;

        case 'V':                       // Ctrl-V => paste
CtrlV:      if(IsntProtectedOrReadOnly(WM_PASTE, 0, 0))
            {
                PasteDataObjectToRange(NULL, (CTxtRange *)psel, 0, NULL,
                    publdr, PDOR_NONE);
            }
            break;

        case 'X':                       // Ctrl-X => cut
CtrlX:      CutOrCopySelection(WM_CUT, 0, 0, publdr);
            break;

        case 'Z':                       // Ctrl-Z => undo
            if (_pundo && !_fReadOnly && _fUseUndo)
                PopAndExecuteAntiEvent(_pundo, 0);
            break;

        case 'Y':                       // Ctrl-Y => redo
            if(_predo && !_fReadOnly && _fUseUndo)
                PopAndExecuteAntiEvent(_predo, 0);
            break;

#ifdef DEBUG
            void RicheditDebugCentral(void);
        case 191:
            RicheditDebugCentral();
            break;
#endif

#if defined(DOGFOOD)
        case '1':                       // Shift+Ctrl+1 => start Aimm
            // Activate AIMM by posting a message to RE (Shift+Ctrl+; for now)
            if (fShift && _fInOurHost)
            {
                HWND    hWnd;

                TxGetWindow( &hWnd );

                if (hWnd)
                    PostMessage(hWnd, EM_SETEDITSTYLE, SES_USEAIMM, SES_USEAIMM);
            }
            break;
#endif

        case VK_CONTROL:
            goto cont;

// English keyboard defines
#define VK_APOSTROPHE   0xDE
#define VK_GRAVE        0xC0
#define VK_SEMICOLON    0xBA
#define VK_COMMA        0xBC

        case VK_APOSTROPHE:
            if(fShift)
                g_wFlags ^= KF_SMARTQUOTES;
            else
                nDeadKey = ACCENT_ACUTE;
            break;

        case VK_GRAVE:
            nDeadKey = fShift ? ACCENT_TILDE : ACCENT_GRAVE;
            break;

        case VK_SEMICOLON:
            nDeadKey = ACCENT_UMLAUT;
            break;

        case '6':
            if(!fShift)
                goto cont;
            nDeadKey = ACCENT_CARET;
            break;

        case VK_COMMA:
            nDeadKey = ACCENT_CEDILLA;
            break;

        default:
            goto cont;
        }
        if(nDeadKey)
        {
            // Since deadkey choices vary a bit according to keyboard, we
            // only enable them for English. French, German, Italian, and
            // Spanish keyboards already have a fair amount of accent
            // capability.
            if(PRIMARYLANGID(GetKeyboardLayout(0)) == LANG_ENGLISH)
                SetDeadKey((WORD)nDeadKey);
            else goto cont;
        }
        return S_OK;
    }

cont:
    psel->SetExtend(fShift);

    switch(vkey)
    {
    case VK_BACK:
    case VK_F16:
        if(_fReadOnly)
        {
            Beep();
            fRet = TRUE;
        }
        else if(IsntProtectedOrReadOnly(WM_KEYDOWN, VK_BACK, dwFlags))
        {
            fRet = psel->Backspace(fCtrl, publdr);
        }
        break;

    case VK_INSERT:                             // Ins
        if(fShift)                              // Shift-Ins
            goto CtrlV;                         // Alias for Ctrl-V
        if(fCtrl)                               // Ctrl-Ins
            goto CtrlC;                         // Alias for Ctrl-C

        if(!_fReadOnly)                         // Ins
            _fOverstrike = !_fOverstrike;       // Toggle Ins/Ovr
        fRet = TRUE;
        break;

    case VK_LEFT:                               // Left arrow
    case VK_RIGHT:                              // Right arrow
        fRet = (vkey == VK_LEFT) ^ (psel->GetPF()->IsRtlPara() != 0)
             ? psel->Left (fCtrl)
             : psel->Right(fCtrl);
        break;

    case VK_UP:                                 // Up arrow
        fRet = psel->Up(fCtrl);
        break;

    case VK_DOWN:                               // Down arrow
        fRet = psel->Down(fCtrl);
        break;

    case VK_HOME:                               // Home
        fRet = psel->Home(fCtrl);
        break;

    case VK_END:                                // End
        fRet = psel->End(fCtrl);
        break;

    case VK_PRIOR:                              // PgUp
        // If SystemEditMode and control is single-line, do nothing
        if(!_fSystemEditMode || _pdp->IsMultiLine())
            fRet = psel->PageUp(fCtrl);
        break;

    case VK_NEXT:                               // PgDn
        // If SystemEditMode and control is single-line, do nothing
        if(!_fSystemEditMode || _pdp->IsMultiLine())
            fRet = psel->PageDown(fCtrl);
        break;

    case VK_DELETE:                             // Del
        if(fShift)                              // Shift-Del
            goto CtrlX;                         // Alias for Ctrl-X

        if(IsntProtectedOrReadOnly(WM_KEYDOWN, VK_DELETE, dwFlags))
            psel->Delete(fCtrl, publdr);
        fRet = TRUE;
        break;

    case CONTROL('J'):                          // Ctrl-Return gives Ctrl-J
    case VK_RETURN:                             //  (LF), treat it as return
        // If we are in 1.0 mode we need to handle <CR>'s on WM_CHAR
        if (!Get10Mode())
        {
            if(!_pdp->IsMultiLine())
            {
                Beep();
                return S_FALSE;
            }
            TxSetCursor(0, NULL);

            if(IsntProtectedOrReadOnly(WM_CHAR, VK_RETURN, dwFlags))
                psel->InsertEOP(publdr, (fShift && IsRich() ? VT : 0));

            fRet = TRUE;
        }
        break;

    default:
        return S_FALSE;
    }

    return fRet ? S_OK : S_MSG_KEY_IGNORED;
}

/*
 *  CTxtEdit::CutOrCopySelection(msg, wparam, lparam, publdr)
 *
 *  @mfunc
 *      Handle WM_COPY message and its keyboard hotkey aliases
 *
 *  @rdesc
 *      HRESULT
 */
HRESULT CTxtEdit::CutOrCopySelection(
    UINT   msg,             //@parm Message (WM_CUT or WM_COPY)
    WPARAM wparam,          //@parm Message wparam for protection check
    LPARAM lparam,          //@parm Message lparam for protection check
    IUndoBuilder *publdr)   //@parm Undobuilder to receive antievents
{
    Assert(msg == WM_CUT || msg == WM_COPY);

    if(!_fUsePassword && IsntProtectedOrReadOnly(msg, wparam, lparam))
    {
        CTxtSelection *psel = GetSel();
        psel->CheckTableSelection();
        return msg == WM_COPY
               ? _ldte.CopyRangeToClipboard((CTxtRange *)psel)
               : _ldte.CutRangeToClipboard((CTxtRange *)psel, publdr);
    }
    return NOERROR;
}

#define ENGLISH_UK	 MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK)
#define ENGLISH_EIRE MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_EIRE)

/*
 *  CTxtEdit::OnTxSpecialKeyDown(vkey, dwFlags, publdr)
 *
 *  @mfunc
 *      Handle WM_KEYDOWN message for outline mode
 *
 *  @rdesc
 *      HRESULT with the following values:
 *
 *      S_OK                if key was understood and consumed
 *      S_MSG_KEY_IGNORED   if key was understood, but not consumed
 *      S_FALSE             if key was not understood (and not consumed)
 */
HRESULT CTxtEdit::OnTxSpecialKeyDown(
    WORD          vkey,             //@parm Virtual key code
    DWORD         dwFlags,          //@parm lparam of WM_KEYDOWN msg
    IUndoBuilder *publdr)           //@parm Undobuilder to receive antievents
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxSpecialKeyDown");

    HRESULT hr = S_FALSE;                   // Key not understood yet
    DWORD   dwKbdFlags = GetKeyboardFlags();
    BOOL    fUpdateFormat = TRUE;

    if(!(dwKbdFlags & (CTRL | ALT)))        // All hot keys here have at
        return S_FALSE;                     //  least Ctrl or Alt

    CTxtSelection * const psel = GetSel();
    if(dwKbdFlags & ALT && dwKbdFlags & CTRL)
    {
        // AltGr generates LCTRL | RALT, so don't match hot keys with
        // that combination
        if(dwKbdFlags & LCTRL && dwKbdFlags & RALT)
            return S_FALSE;

//#if 0
        // First they say they want it, then they don't. Leave it ifdef'd out
        // for a bit in case they want it again
        if(vkey == 'E')
        {
			LANGID lid = LANGIDFROMLCID(GetKeyboardLayout(0));
			static const LANGID rgLangID[] =
			{
				ENGLISH_UK, ENGLISH_EIRE, LANG_POLISH, LANG_PORTUGUESE,
				LANG_HUNGARIAN, LANG_VIETNAMESE
			};
			for(LONG i = ARRAY_SIZE(rgLangID); i--; )
			{
				// Don't insert Euro if lid matches any LIDs or PLIDs in rgLangID
				if(lid == rgLangID[i] || PRIMARYLANGID(lid) == rgLangID[i])
					return S_FALSE;
			}
            if(psel->PutChar(EURO, _fOverstrike, publdr))
			{
				SetKeyboardFlag(HOTEURO);		// Setup flag to eat the next WM_CHAR w/ EURO
                hr = S_OK;
			}
        }
        else
//#endif
        if(dwKbdFlags & SHIFT)
            switch(vkey)
            {
#ifdef ENABLE_OUTLINEVIEW
            // FUTURE: OutlineView hot keys postponed (see below)
            case 'N':                       // Alt-Ctrl-N => Normal View
                hr = SetViewKind(VM_NORMAL);
                break;
            case 'O':                       // Alt-Ctrl-O => Outline View
                hr = SetViewKind(VM_OUTLINE);
                break;
#endif
            case VK_F12:                    // Alt-Ctrl-F12 (in case Alt-X taken)
                hr = psel->HexToUnicode(publdr);
                break;

    #if defined(DEBUG)
            case VK_F11:                    // Alt-Ctrl-F11
                if (W32->fDebugFont())
                    psel->DebugFont();
                break;
    #endif
            }
        return hr;
    }

    AssertSz(psel, "CTxtEdit::OnTxSpecialKeyDown() - No selection object !");
    CTxtRange rg(*psel);

    if(!IsRich() || !_pdp->IsMultiLine() || !(dwKbdFlags & SHIFT))
        return S_FALSE;

    if(dwKbdFlags & ALT)                            // Alt+Shift hot keys
    {
        // NB: Alt and Shift-Alt with _graphics_ characters generate a
        // WM_SYSCHAR, which see

#ifdef ENABLE_OUTLINEVIEW
        // FUTURE: These are Outline related hot keys.  We will postpone these features
        // since we have several bugs related to these hot keys
        // Bug 5687, 5689, & 5691
        switch(vkey)
        {
        case VK_LEFT:                               // Left arrow
        case VK_RIGHT:                              // Right arrow
            hr = rg.Promote(vkey == VK_LEFT ? 1 : -1, publdr);
            psel->Update_iFormat(-1);
            psel->Update(FALSE);
            break;

        case VK_UP:                                 // Up arrow
        case VK_DOWN:                               // Down arrow
            hr = MoveSelection(vkey == VK_UP ? -1 : 1, publdr);
            psel->Update(TRUE);
            break;
        }
#endif
        return hr;
    }

    Assert(dwKbdFlags & CTRL && dwKbdFlags & SHIFT);

    // Ctrl+Shift hot keys
    switch(vkey)
    {

#ifdef ENABLE_OUTLINEVIEW
    // FUTUTRE: These are Outline related hot keys.  We will postpone these features
    // since we have several bugs related to these hot keys
    // Bug 5687, 5689, & 5691
    case 'N':                       // Demote to Body
        hr = rg.Promote(0, publdr);
        break;
#endif

    //Toggle superscript
    case 187: // =
    {
        ITextFont *pfont;
        psel->GetFont(&pfont);
        if (pfont)
        {
            pfont->SetSuperscript(tomToggle);
            pfont->Release();
            hr = S_OK;
            fUpdateFormat = FALSE;
        }
        break;
    }

    case 'A':
    {
        ITextFont *pfont;
        psel->GetFont(&pfont);
        if (pfont)
        {
            pfont->SetAllCaps(tomToggle);
            pfont->Release();
            hr = S_OK;
            fUpdateFormat = FALSE;
        }
        break;
    }

    case 'L':                       // Fiddle bullet style
    {
        CParaFormat PF;
        DWORD dwMask = PFM_NUMBERING | PFM_OFFSET;

        PF._wNumbering = psel->GetPF()->_wNumbering + 1;
        PF._wNumbering %= tomListNumberAsUCRoman + 1;
        PF._dxOffset = 0;
        if(PF._wNumbering)
        {
            dwMask |= PFM_NUMBERINGSTYLE | PFM_NUMBERINGSTART;
            PF._wNumberingStyle = PFNS_PERIOD;
            PF._wNumberingStart = 1;
            PF._dxOffset = 360;
        }
        hr = psel->SetParaFormat(&PF, publdr, dwMask);
        break;
    }
#define VK_RANGLE   190
#define VK_LANGLE   188

    case VK_RANGLE:                 // '>' on US keyboards
    case VK_LANGLE:                 // '<' on US keyboards
        hr = OnSetFontSize(vkey == VK_RANGLE ? 1 : -1, publdr)
           ? S_OK : S_FALSE;
        fUpdateFormat = (hr == S_FALSE);
        break;
    }

    if(hr != S_FALSE)
    {
        if (fUpdateFormat)
            psel->Update_iFormat(-1);
        psel->Update(FALSE);
    }
    return hr;
}

/*
 *  CTxtEdit::OnTxChar (vkey, dwFlags, publdr)
 *
 *  @mfunc
 *      Handle WM_CHAR message
 *
 *  @rdesc
 *      HRESULT with the following values:
 *
 *      S_OK                if key was understood and consumed
 *      S_MSG_KEY_IGNORED   if key was understood, but not consumed
 *      S_FALSE             if key was not understood (and not consumed)
 */
HRESULT CTxtEdit::OnTxChar(
    WORD          vkey,     //@parm Translated key code
    DWORD         dwFlags,  //@parm lparam of WM_KEYDOWN msg
    IUndoBuilder *publdr)   //@parm Undobuilder to receive antievents
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxChar");

    // Reset Alt key state if needed
    if (!(HIWORD(dwFlags) & KF_ALTDOWN))
        ResetKeyboardFlag(ALT);

    DWORD dwFlagsPutChar = _fOverstrike | KBD_CHAR;
    if(GetKeyboardFlags() & ALTNUMPAD)
    {
        DWORD Number = GetKeyPadNumber();
        if(Number >= 256 || vkey >= 256)
            vkey = Number;
        ResetKeyboardFlag(ALTNUMPAD | ALT0);
        dwFlagsPutChar &= ~KBD_CHAR;        // Need font binding
    }

    if (_fMouseDown || vkey == VK_ESCAPE || // Ctrl-Backspace generates VK_F16
        vkey == VK_BACK || vkey==VK_F16)    // Eat it since we process it
    {                                       //  in WM_KEYDOWN
        return S_OK;
    }

    CTxtSelection * const psel = GetSel();
    AssertSz(psel,
        "CTxtEdit::OnChar() - No selection object !");
    psel->SetExtend(FALSE);                 // Shift doesn't mean extend for
                                            //  WM_CHAR
    if(_fReadOnly && vkey != 3)             // Don't allow input if read only,
    {                                       //  but allow copy (Ctrl-C)
        if(vkey >= ' ')
            Beep();
        return S_MSG_KEY_IGNORED;
    }

    if(vkey >= ' ' || vkey == VK_TAB)
    {
        TxSetCursor(0, NULL);
        if(IsntProtectedOrReadOnly(WM_CHAR, vkey, dwFlags))
        {
            LONG nDeadKey = GetDeadKey();
            if(nDeadKey)
            {
                LONG ch       = vkey | 0x20;        // Convert to lower case
                BOOL fShift   = vkey != ch;         //  (if ASCII letter)
                //                             a   b    c   d    e   f  g  h    i   j
                const static WORD chOff[] = {0xDF, 0, 0xE7, 0, 0xE7, 0, 0, 0, 0xEB, 0,
                //                      k  l  m    n     o   p  q  r  s  t    u
                                        0, 0, 0, 0xF1, 0xF1, 0, 0, 0, 0, 0, 0xF8};
                SetDeadKey(0);
                if(!IN_RANGE('a', ch, 'u'))         // Not relevant ASCII
                    return S_OK;                    //  letter

                vkey = chOff[ch - 'a'];             // Translate to base char
                if(!vkey)                           // No accents available
                    return S_OK;                    //  in current approach

                if(ch == 'n')
                {
                    if(nDeadKey != ACCENT_TILDE)
                        return S_OK;
                }
                else if(nDeadKey == ACCENT_CEDILLA)
                {
                    if(ch != 'c')
                        return S_OK;
                }
                else                                // aeiou
                {
                    vkey += (WORD)nDeadKey;
                    if (nDeadKey >= ACCENT_TILDE && // eiu with ~ or :
                        (vkey == 0xF0 || vkey & 8))
                    {
                        if(nDeadKey != ACCENT_UMLAUT)// Only have umlauts
                            return S_OK;
                        vkey--;
                    }
                }
                if(fShift)
                    vkey &= ~0x20;
            }

            // need to check if character is LRM | RLM character, if so
            // then convert vkey
            if (W32->_fLRMorRLM && IsBiDi() && IN_RANGE(0xFD, vkey, 0xFE))
            {
                vkey = LTRMARK + (vkey - 0xFD);
            }

            psel->PutChar((TCHAR)vkey, dwFlagsPutChar, publdr);
        }
    }
    else if (Get10Mode() && (vkey == VK_RETURN || vkey == CONTROL('J')))
    {
        // 1.0 handled <CR> on WM_CHAR

        // Just make sure we are entering text into a multiline control
        DWORD dwStyle;
        GetHost()->TxGetPropertyBits(TXTBIT_MULTILINE, &dwStyle);
        if(dwStyle & TXTBIT_MULTILINE)
        {
            TxSetCursor(0, NULL);
            if(IsntProtectedOrReadOnly(WM_CHAR, VK_RETURN, dwFlags))
                psel->InsertEOP(publdr);
        }
    }

    if(_fHbrCaps)
    {
         W32->ActivateKeyboard(HEBREW_INDEX);
         _fHbrCaps = FALSE;
    }
    return S_OK;
}

/*
 *  CTxtEdit::OnTxSysChar (vkey, dwFlags, publdr)
 *
 *  @mfunc
 *      Handle WM_SYSCHAR message
 *
 *  @rdesc
 *      HRESULT with the following values:
 *
 *      S_OK                if key was understood and consumed
 *      S_MSG_KEY_IGNORED   if key was understood, but not consumed
 *      S_FALSE             if key was not understood (and not consumed)
 */
HRESULT CTxtEdit::OnTxSysChar(
    WORD          vkey,     //@parm Translated key code
    DWORD         dwFlags,  //@parm lparam of WM_KEYDOWN msg
    IUndoBuilder *publdr)   //@parm Undobuilder to receive antievents
{
    if(!(HIWORD(dwFlags) & KF_ALTDOWN))
        return S_FALSE;

    BOOL    fWholeDoc = TRUE;
    HRESULT hr = S_FALSE;
    int     level = 0;
    CTxtSelection * const psel = GetSel();

    switch(vkey)
    {
    case VK_BACK:
        return S_OK;

    case 'x':
        hr = psel->HexToUnicode(publdr);
        break;

    case 'X':
        hr = psel->UnicodeToHex(publdr);
        break;

    case '+':
    case '-':
        level = vkey == VK_ADD ? 1 : -1;
        fWholeDoc = FALSE;
        /* Fall through */
    case 'A':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        {
            CTxtRange rg(*psel);
            if(!level)
                level = vkey == 'A' ? 9 : vkey - '0';
            return rg.ExpandOutline(level, fWholeDoc);
        }
    }
    return hr;
}

HRESULT CTxtEdit::OnTxSysKeyDown(
    WORD          vkey,             //@parm Virtual key code
    DWORD         dwFlags,          //@parm lparam of WM_KEYDOWN msg
    IUndoBuilder *publdr)           //@parm Undobuilder to receive antievents
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxSysKeyDown");


    if(IN_RANGE(VK_SHIFT, vkey, VK_MENU))
    {
        SetKeyboardFlag(GetKbdFlags(vkey, dwFlags));
        SetKeyPadNumber(0);             // Init keypad number to 0
        return S_FALSE;
    }

    if (StopMagellanScroll())
        return S_FALSE;

    HRESULT hr = OnTxSpecialKeyDown(vkey, dwFlags, publdr);
    if(hr != S_FALSE)
        return hr;

    if(vkey == VK_BACK && (HIWORD(dwFlags) & KF_ALTDOWN))
    {
        if(_pundo && _pundo->CanUndo() && _fUseUndo)
        {
            if(PopAndExecuteAntiEvent(_pundo, 0) != NOERROR)
                hr = S_MSG_KEY_IGNORED;
        }
        else
            Beep();
    }
    else if(vkey == VK_F10 &&                   // F10
            !(HIWORD(dwFlags) & KF_REPEAT) &&   // Key previously up
            (GetKeyboardFlags() & SHIFT))       // Shift is down
    {
        HandleKbdContextMenu();
    }

    return hr;
}

/////////////////////////////// Other system events //////////////////////////////

HRESULT CTxtEdit::OnContextMenu(LPARAM lparam)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnContextMenu");

    POINT pt;

    pt.x = LOWORD(lparam);
    pt.y = HIWORD(lparam);

    if(TxScreenToClient(&pt))
        return OnTxRButtonUp(pt.x, pt.y, 0, RB_NOSELCHECK);

    return S_FALSE;
}

/*
 *  CTxtEdit::HandleKbdContextMenu ()
 *
 *  @mfunc  decides where to put the context menu on the basis of where the
 *          the selection is.  Useful for shift-F10 and VK_APPS, where
 *          we aren't given a location.
 */
void CTxtEdit::HandleKbdContextMenu()
{
    POINT   pt;
    RECT    rc;
    const CTxtSelection * const psel = GetSel();
    int RbOption = RB_DEFAULT;

    // Figure out where selection ends and put context menu near it
    if(_pdp->PointFromTp(*psel, NULL, FALSE, pt, NULL, TA_TOP) < 0)
        return;

    // Due to various factors, the result of PointFromTp doesn't land
    // in the selection in PointInSel. Therefore, we send in an override
    // here if the selection is non-degenerate and to force the result
    // and thus have the correct context menu appear.

    LONG cpMin;
    LONG cpMost;
    psel->GetRange(cpMin, cpMost);

    if (cpMin != cpMost)
    {
        RbOption = RB_FORCEINSEL;
    }

    // Make sure point is still within bounds of edit control
    _pdp->GetViewRect(rc);

    if (pt.x < rc.left)
        pt.x = rc.left;
    if (pt.x > rc.right - 2)
        pt.x = rc.right - 2;
    if (pt.y < rc.top)
        pt.y = rc.top;
    if (pt.y > rc.bottom - 2)
        pt.y = rc.bottom - 2;

    OnTxRButtonUp(pt.x, pt.y, 0, RbOption);
}


/////////////////////////////// Format Range Commands //////////////////////////////

/*
 *  CTxtEdit::OnFormatRange (pfr, prtcon, hdcMeasure,
 *                           xMeasurePerInch, yMeasurePerInch)
 *  @mfunc
 *      Format the range given by pfr
 *
 *  @comm
 *      This function inputs API cp's that may differ from the
 *      corresponding internal Unicode cp's.
 */
LRESULT CTxtEdit::OnFormatRange(
    FORMATRANGE * pfr,
    SPrintControl prtcon,
    BOOL          fSetupDC)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnFormatRange");

    LONG cpMin  = 0;
    LONG cpMost = 0;

    if(pfr)
    {
        cpMin  = GetCpFromAcp(pfr->chrg.cpMin);
        cpMost = GetCpFromAcp(pfr->chrg.cpMost);
    }
    // Even if there is 0 text, we want to print the control so that it will
    // fill the control with background color.
    // Use Adjusted Text Length.  Embedded objects using RichEdit will get the empty
    // document they expect and will create a default size document.
    if(!pfr || cpMin >= GetAdjustedTextLength() &&
        !prtcon._fPrintFromDraw)
    {   // We're done formatting, get rid of our printer's display context.
        delete _pdpPrinter;
        _pdpPrinter = NULL;

        return GetAcpFromCp(GetAdjustedTextLength());
    }

    LONG cpReturn = -1;
    BOOL fSetDCWorked = FALSE;


    // Fix MFC Print preview in mirrored control
    //
    // MFC CPreviewView sends us a mirrored rendering DC. We need to disable
    // this mirroring effect so our internal state remains consistent with user
    // action. We also need to disable mirrored window mode in CPreviewView
    // window. [wchao - 4/9/1999]
    //

    HDC  hdcLocal = pfr->hdc;
    DWORD dwLayout = GetLayout(hdcLocal);

    if (dwLayout & LAYOUT_RTL)
    {
        HWND hwndView = WindowFromDC(hdcLocal);

        if (hwndView)
        {
            DWORD   dwExStyleView = GetWindowLong(hwndView, GWL_EXSTYLE);

            if (dwExStyleView & WS_EX_LAYOUTRTL)
                SetWindowLong(hwndView, GWL_EXSTYLE, dwExStyleView & ~WS_EX_LAYOUTRTL);
        }

        SetLayout(hdcLocal, 0);
    }

    // First time in with this printer, set up a new display context.
    // IMPORTANT: proper completion of the printing process is required
    // to dispose of this context and begin a new context.
    // This is implicitly done by printing the last character, or
    // sending an EM_FORMATRANGE message with pfr equal to NULL.
    if(!_pdpPrinter)
    {
        _pdpPrinter = new CDisplayPrinter (this, hdcLocal,
                pfr->rc.right  - pfr->rc.left,  // x width  max
                pfr->rc.bottom - pfr->rc.top,   // y height max
                prtcon);

        _pdpPrinter->Init();

        _pdpPrinter->SetWordWrap(TRUE);
        // Future: (ricksa) This is a really yucky way to pass the draw info
        // to the printer but it was quick. We want to make this better.
        _pdpPrinter->ResetDrawInfo(_pdp);

        // Set temporary zoom factor (if there is one).
        _pdpPrinter->SetTempZoomDenominator(_pdp->GetTempZoomDenominator());
    }
    else
        _pdpPrinter->SetPrintDimensions(&pfr->rc);

	LONG dxpInch = 0, dypInch = 0;
    // We set the DC everytime because it could have changed.
    if(GetDeviceCaps(hdcLocal, TECHNOLOGY) != DT_METAFILE)
    {
        // This is not a metafile so do the normal thing
        fSetDCWorked = _pdpPrinter->SetDC(hdcLocal);
    }
    else
    {
        //Forms^3 draws using screen resolution, while OLE specifies HIMETRIC
        dxpInch = fInOurHost() ? 2540 : W32->GetXPerInchScreenDC();
        dypInch = fInOurHost() ? 2540 : W32->GetYPerInchScreenDC();

        if (!fSetupDC)
        {
            RECT rc;
            rc.left = MulDiv(pfr->rcPage.left, dxpInch, LX_PER_INCH);
            rc.right = MulDiv(pfr->rcPage.right, dxpInch, LX_PER_INCH);
            rc.top = MulDiv(pfr->rcPage.top, dypInch, LY_PER_INCH);
            rc.bottom = MulDiv(pfr->rcPage.bottom, dypInch, LY_PER_INCH);

            SetWindowOrgEx(hdcLocal, rc.left, rc.top, NULL);
            SetWindowExtEx(hdcLocal, rc.right, rc.bottom, NULL);
        }

        _pdpPrinter->SetMetafileDC(hdcLocal, dxpInch, dypInch);
        fSetDCWorked = TRUE;
    }

    if(fSetDCWorked)
    {
		//It is illogical to have the target device be the screen and the presentation
		//device be a HIMETRIC metafile.
		LONG dxpInchT = -1, dypInchT = -1;
		if (dxpInch && GetDeviceCaps(pfr->hdcTarget, TECHNOLOGY) == DT_RASDISPLAY)
		{
			dxpInchT = dxpInch;
			dypInchT = dypInch;
		}

        // We set this every time because it could have changed.
        if(_pdpPrinter->SetTargetDC(pfr->hdcTarget, dxpInchT, dypInchT))
        {

            // Format another, single page worth of text.
            cpReturn = _pdpPrinter->FormatRange(cpMin, cpMost, prtcon._fDoPrint);
            if(!prtcon._fPrintFromDraw)
            {
                // After formatting, we know where the bottom is. But we only
                // want to set this if we are writing a page rather than
                // displaying a control on the printer.
                pfr->rc.bottom = INT (pfr->rc.top + _pdpPrinter->DYtoLY(_pdpPrinter->GetHeight()));
            }

            // Remember this in case the host wishes to do its own banding.
            _pdpPrinter->SetPrintView(pfr->rc); // we need to save this for OnDisplayBand.
            _pdpPrinter->SetPrintPage(pfr->rcPage);

            // If we're asked to render, then render the entire page in one go.
            if(prtcon._fDoPrint && (cpReturn > 0 || prtcon._fPrintFromDraw))
            {
                OnDisplayBand(&pfr->rc, prtcon._fPrintFromDraw);

                // Note: we can no longer call OnDisplayBand without reformating.
                _pdpPrinter->Clear(AF_DELETEMEM);
            }
        }
    }

    return cpReturn > 0 ? GetAcpFromCp(cpReturn) : cpReturn;
}

BOOL CTxtEdit::OnDisplayBand(
    const RECT *prc,
    BOOL        fPrintFromDraw)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDisplayBand");

    HDC     hdcPrinter;
    RECT    rc, rcPrint;

    // Make sure OnFormatRange was called and that it actually rendered something.
    if(!_pdpPrinter || !_pdpPrinter->Count())
        return FALSE;

    // Review (murrays): shouldn't the following use LRtoDR()? I.e.,
    // _pdpPrinter->LRtoDR(rc, *prc);
    // Proportionally map to printers extents.
    rc.left     = (INT) _pdpPrinter->LXtoDX(prc->left);
    rc.right    = (INT) _pdpPrinter->LXtoDX(prc->right);
    rc.top      = (INT) _pdpPrinter->LYtoDY(prc->top);
    rc.bottom   = (INT) _pdpPrinter->LYtoDY(prc->bottom);

    rcPrint         = _pdpPrinter->GetPrintView();
    rcPrint.left    = (INT) _pdpPrinter->LXtoDX(rcPrint.left);
    rcPrint.right   = (INT) _pdpPrinter->LXtoDX(rcPrint.right);
    rcPrint.top     = (INT) _pdpPrinter->LYtoDY(rcPrint.top);
    rcPrint.bottom  = (INT) _pdpPrinter->LYtoDY(rcPrint.bottom);

    // Get printer DC because we use it below.
    hdcPrinter = _pdpPrinter->GetDC();

    if(fPrintFromDraw)
    {
        // We need to take view inset into account
        _pdpPrinter->GetViewRect(rcPrint, &rcPrint);
    }

    // Render this band (if there's something to render)
    if(rc.top < rc.bottom)
        _pdpPrinter->Render(rcPrint, rc);

    return TRUE;
}

//////////////////////////////// Protected ranges //////////////////////////////////
/*
 *  CTxtEdit::IsProtected (msg, wparam, lparam)
 *
 *  @mfunc
 *      Find out if selection is protected
 *
 *  @rdesc
 *      TRUE iff 1) control is read-only or 2) selection is protected and
 *      parent query says to protect
 */
BOOL CTxtEdit::IsProtected(
    UINT    msg,        //@parm Message id
    WPARAM  wparam,     //@parm WPARAM from window's message
    LPARAM  lparam)     //@parm LPARAM from window's message
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::IsProtected");

    LONG iDirection = 0;
    CTxtSelection *psel = GetSel();

    if(!psel)
        return FALSE;

    // There are a few special cases to consider, namely backspacing
    // into a protected range, deleting into a protected range, and type
    // with overstrike into a protected range.
    if(msg == WM_KEYDOWN && (wparam == VK_BACK || wparam == VK_F16))
    {
        // Check for format behind selection, if we are trying to
        // backspace an insertion point.
        iDirection = -1;
    }
    else if(msg == WM_KEYDOWN && wparam == VK_DELETE ||
        _fOverstrike && msg == WM_CHAR)
    {
        iDirection = 1;
    }

    // HACK ALERT: we don't do fIsDBCS protection checking for EM_REPLACESEL,
    // EM_SETCHARFORMAT, or EM_SETPARAFORMAT.  Outlook uses these APIs
    // extensively and DBCS protection checking messes them up. N.B. the
    // following if statement assumes that IsProtected returns a tri-value.
    int iProt = psel->IsProtected(iDirection);
    if (iProt == CTxtRange::PROTECTED_YES && msg != EM_REPLACESEL &&
        msg != EM_SETCHARFORMAT && msg != EM_SETPARAFORMAT ||
        iProt == CTxtRange::PROTECTED_ASK && _dwEventMask & ENM_PROTECTED &&
        QueryUseProtection(psel, msg, wparam, lparam))
    {
        return TRUE;
    }
    return FALSE;
}

/*
 *  CTxtEdit::IsntProtectedOrReadOnly (msg, wparam, lparam)
 *
 *  @mfunc
 *      Find out if selection isn't protected or read only. If it is,
 *      ring bell.  For msg = WM_COPY, only protection is checked.
 *
 *  @rdesc
 *      TRUE iff 1) control isn't read-only and 2) selection either isn't
 *      protected or parent query says not to protect
 *
 *  @devnote    This function is useful for UI operations (like typing).
 */
BOOL CTxtEdit::IsntProtectedOrReadOnly(
    UINT   msg,     //@parm Message
    WPARAM wparam,  //@parm Corresponding wparam
    LPARAM lparam)  //@parm Corresponding lparam
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::IsProtectedOrReadOnly");

    if (!IsProtected(msg, wparam, lparam) &&
        (msg == WM_COPY || !_fReadOnly))    // WM_COPY only cares about
    {                                       //  protection
        return TRUE;
    }
    Beep();
    return FALSE;
}

/*
 *  CTxtEdit::IsProtectedRange (msg, wparam, lparam, prg)
 *
 *  @mfunc
 *      Find out if range prg is protected
 *
 *  @rdesc
 *      TRUE iff control is read-only or range is protected and parent
 *      query says to protect
 */
BOOL CTxtEdit::IsProtectedRange(
    UINT        msg,        //@parm Message id
    WPARAM      wparam,     //@parm WPARAM from window's message
    LPARAM      lparam,     //@parm LPARAM from window's message
    CTxtRange * prg)        //@parm Range to examine
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::IsProtectedRange");

    int iProt = prg->IsProtected(0);

    if (iProt == CTxtRange::PROTECTED_YES ||
        (iProt == CTxtRange::PROTECTED_ASK &&
         (_dwEventMask & ENM_PROTECTED) &&
         QueryUseProtection(prg, msg, wparam, lparam)))
    // N.B.  the preceding if statement assumes that IsProtected returns a tri-value
    {
        return TRUE;
    }
    return FALSE;
}

/*
 *  RegisterTypeLibrary
 *
 *  @mfunc
 *      Auxiliary function to ensure the type library is registered if Idispatch is used.
 */
void RegisterTypeLibrary( void )
{
    HRESULT  hRes = NOERROR;
    WCHAR    szModulePath[MAX_PATH];
    ITypeLib *pTypeLib = NULL;

    // Obtain the path to this module's executable file
    W32->GetModuleFileName( hinstRE, szModulePath, MAX_PATH );

    // Load and register the type library resource
    if (LoadRegTypeLib(LIBID_tom, 1, 0, LANG_NEUTRAL, &pTypeLib) != NOERROR)
    {
        hRes = W32->LoadTypeLibEx(szModulePath, REGKIND_REGISTER, &pTypeLib);
    }

    if(SUCCEEDED(hRes) && pTypeLib)
    {
        pTypeLib->Release();
    }
}

/////////////////////////////// Private IUnknown //////////////////////////////

HRESULT __stdcall CTxtEdit::CUnknown::QueryInterface(
    REFIID riid,
    void **ppvObj)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CUnknown::QueryInterface");

    CTxtEdit *ped = (CTxtEdit *)GETPPARENT(this, CTxtEdit, _unk);
    *ppvObj = NULL;

    if(IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITextServices))
        *ppvObj = (ITextServices *)ped;

    else if(IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch *)ped;
        RegisterTypeLibrary();
    }

    else if(IsEqualIID(riid, IID_ITextDocument))
    {
        *ppvObj = (ITextDocument *)ped;
        RegisterTypeLibrary();
    }

    else if(IsEqualIID(riid, IID_ITextDocument2))
        *ppvObj = (ITextDocument2 *)ped;

    else if(IsEqualIID(riid, IID_IRichEditOle))
        *ppvObj = (IRichEditOle *)ped;

    else if(IsEqualIID(riid, IID_IRichEditOleCallback))
    {
        // NB!! Returning this pointer in our QI is
        // phenomenally bogus; it breaks fundamental COM
        // identity rules (granted, not many understand them!).
        // Anyway, RichEdit 1.0 did this, so we better.
        TRACEWARNSZ("Returning IRichEditOleCallback interface, COM "
            "identity rules broken!");

        *ppvObj = ped->GetRECallback();
    }

    if(*ppvObj)
    {
        ((IUnknown *) *ppvObj)->AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

ULONG __stdcall CTxtEdit::CUnknown::AddRef()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CUnknown::AddRef");

    return ++_cRefs;
}

ULONG __stdcall CTxtEdit::CUnknown::Release()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CUnknown::Release");

    // the call manager will take care of deleting our instance if appropriate.
    CTxtEdit *ped = GETPPARENT(this, CTxtEdit, _unk);
    CCallMgr callmgr(ped);

    ULONG culRefs = --_cRefs;

    if(culRefs == 0)
    {
        // Even though we don't delete ourselves now, dump the callback
        // if we have it.  This make implementation a bit easier on clients.

        if(ped->_pobjmgr)
            ped->_pobjmgr->SetRECallback(NULL);

        // Make sure our timers are gone
        ped->TxKillTimer(RETID_AUTOSCROLL);
        ped->TxKillTimer(RETID_DRAGDROP);
        ped->TxKillTimer(RETID_BGND_RECALC);
        ped->TxKillTimer(RETID_SMOOTHSCROLL);
        ped->TxKillTimer(RETID_MAGELLANTRACK);
    }
    return culRefs;
}

/*
 *  ValidateTextRange(pstrg)
 *
 *  @func
 *    Makes sure that an input text range structure makes sense.
 *
 *  @rdesc
 *    Size of the buffer required to accept copy of data or -1 if all the
 *    data in the control is requested.
 *
 *  @comm
 *    This is used both in this file and in the RichEditANSIWndProc
 */
LONG ValidateTextRange(
    TEXTRANGE *pstrg)       //@parm pointer to a text range structure
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "ValidateTextRange");

    // Validate that the input structure makes sense. In the first
    // place it must be big enough. Secondly, the values must sense.
    // Remember that if the cpMost field is -1 and the cpMin field
    // is 0 this means that the call wants the entire buffer.
    if (IsBadReadPtr(pstrg, sizeof(TEXTRANGE))  ||
        ((pstrg->chrg.cpMost < 1 || pstrg->chrg.cpMin < 0 ||
          pstrg->chrg.cpMost <= pstrg->chrg.cpMin) &&
         !(pstrg->chrg.cpMost == -1 && !pstrg->chrg.cpMin)))
    {
        // This isn't valid so tell the caller we didn't copy any data
        return 0;
    }
    // Calculate size of buffer that we need on return
    return pstrg->chrg.cpMost - pstrg->chrg.cpMin;
}


////////////////////////////////////  Selection  /////////////////////////////////////

CTxtSelection * CTxtEdit::GetSel()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSel");

    if(!_psel)
    {
        // There is no selection object available so create it.
        _psel = new CTxtSelection(_pdp);
        if(_psel)
            _psel->AddRef();                    // Set reference count = 1
    }

    // It is caller's responsiblity to notice that an error occurred
    // in allocation of selection object.
    return _psel;
}

void CTxtEdit::DiscardSelection()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::DiscardSelection");

    if(_psel)
    {
        _psel->Release();
        if(_psel)
        {
            // The text services reference is not the last reference to the
            // selection. We could keep track of the fact that text services
            // has released its reference and when text services gets a
            // reference again, do the AddRef there so that if the last
            // reference went away while we were still inactive, the selection
            // object would go away. However, it is seriously doubtful that
            // such a case will be very common. Therefore, just do the simplest
            // thing and put our reference back.
            _psel->AddRef();
        }
    }
}

void CTxtEdit::GetSelRangeForRender(
    LONG *pcpSelMin,
    LONG *pcpSelMost)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSelRangeForRender");

    // If we have no selection or we are not active and the selection
    // has been requested to be hidden, there is no selection so we
    // just return 0's.
    if(!_psel || (!_fInPlaceActive && _fHideSelection))
    {
        *pcpSelMin = 0;
        *pcpSelMost = 0;
        return;
    }

    // Otherwise return the state of the current selection.
    *pcpSelMin  = _psel->GetScrSelMin();
    *pcpSelMost = _psel->GetScrSelMost();
}

LRESULT CTxtEdit::OnGetSelText(
    TCHAR *psz)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetSelText");

    LONG cpMin  = GetSelMin();                  // length + 1 for the null
    LONG cpMost = GetSelMost();
    return GetTextRange(cpMin, cpMost - cpMin + 1, psz);
}

/*
 *  CTxtEdit::OnExGetSel (pcrSel)
 *
 *  @mfunc
 *      Get the current selection acpMin, acpMost packaged in a CHARRANGE.
 *
 *  @comm
 *      This function outputs API cp's that may differ from the
 *      corresponding internal Unicode cp's.
 */
void CTxtEdit::OnExGetSel(
    CHARRANGE *pcrSel)  //@parm Output parm to receive acpMin, acpMost
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnExGetSel");

    pcrSel->cpMin  = GetAcpFromCp(GetSelMin());
    pcrSel->cpMost = GetAcpFromCp(GetSelMost());
}

/*
 *  CTxtEdit::OnGetSel (pacpMin, pacpMost)
 *
 *  @mfunc
 *      Get the current selection acpMin, acpMost.
 *
 *  @rdesc
 *      LRESULT = acpMost > 65535L ? -1 : MAKELRESULT(acpMin, acpMost)
 *
 *  @comm
 *      This function outputs API cp's that may differ from the
 *      corresponding internal Unicode cp's.
 */
LRESULT CTxtEdit::OnGetSel(
    LONG *pacpMin,      //@parm Output parm to receive acpMin
    LONG *pacpMost)     //@parm Output parm to receive acpMost
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetSel");

    CHARRANGE crSel;

    OnExGetSel(&crSel);
    if(pacpMin)
        *pacpMin = crSel.cpMin;
    if(pacpMost)
        *pacpMost = crSel.cpMost;

    return (crSel.cpMost > 65535l)  ? (LRESULT) -1
                : MAKELRESULT((WORD) crSel.cpMin, (WORD) crSel.cpMost);
}

/*
 *  CTxtEdit::OnSetSel (acpMin, acpMost)
 *
 *  @mfunc
 *      Implements the EM_SETSEL message
 *
 *  Algorithm:
 *      There are three basic cases to handle
 *
 *      cpMin < 0,  cpMost ???      -- Collapse selection to insertion point
 *                                     at text end if cpMost < 0 and else at
 *                                     selection active end
 *      cpMin >= 0, cpMost < 0      -- select from cpMin to text end with
 *                                     active end at text end
 *
 *      cpMin >= 0, cpMost >= 0     -- Treat as cpMin, cpMost with active
 *                                     end at cpMost
 *
 *  @comm
 *      This function inputs API cp's that may differ from the
 *      corresponding internal Unicode cp's.
 */
LRESULT CTxtEdit::OnSetSel(
    LONG acpMin,        //@parm Input acpMin
    LONG acpMost)       //@parm Input acpMost
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetSel");

    // Since this is only called from the window proc, we are always active
    Assert(GetSel());

    CTxtSelection * const psel = GetSel();
    LONG cpMin, cpMost;

    if(acpMin < 0)
        cpMin = cpMost = (acpMost < 0) ? tomForward : psel->GetCp();
    else
    {
        cpMin  = GetCpFromAcp(acpMin);
        cpMost = (acpMost < 0) ? tomForward : GetCpFromAcp(acpMost);
    }
    if(Get10Mode() && cpMost < cpMin)   // In 10 mode, ensure
    {                                   //  cpMost >= cpMin.  In
        cpMin ^= cpMost;                //  SetSelection, we set active
        cpMost ^= cpMin;                //  end to cpMost, which can be
        cpMin ^= cpMost;                //  smaller than cpMin, in spite
    }                                   //  of its name.
    psel->SetSelection(cpMin, cpMost);
    return psel->GetCpMost();
}

///////////////////////////////  DROP FILES support  //////////////////////////////////////
#ifndef NODROPFILES

LRESULT CTxtEdit::InsertFromFile (
    LPCTSTR lpFile)
{
    REOBJECT        reobj;
    LPRICHEDITOLECALLBACK const precall = GetRECallback();
    HRESULT         hr = NOERROR;

    if(!precall)
        return E_NOINTERFACE;

    ZeroMemory(&reobj, sizeof(REOBJECT));
    reobj.cbStruct = sizeof(REOBJECT);

    // Get storage for the object from client
    hr = precall->GetNewStorage(&reobj.pstg);
    if(hr)
    {
        TRACEERRORSZ("GetNewStorage() failed.");
        goto err;
    }

    // Create an object site for new object
    hr = GetClientSite(&reobj.polesite);
    if(!reobj.polesite)
    {
        TRACEERRORSZ("GetClientSite() failed.");
        goto err;
    }

    hr = OleCreateLinkToFile(lpFile, IID_IOleObject, OLERENDER_DRAW,
                NULL, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);
    if(hr)
    {
        TRACEERRORSZ("Failure creating link object.");
        goto err;
    }

    reobj.cp = REO_CP_SELECTION;
    reobj.dvaspect = DVASPECT_CONTENT;

    //Get object clsid
    hr = reobj.poleobj->GetUserClassID(&reobj.clsid);
    if(hr)
    {
        TRACEERRORSZ("GetUserClassID() failed.");
        goto err;
    }

    // Let client know what we're up to
    hr = precall->QueryInsertObject(&reobj.clsid, reobj.pstg,
            REO_CP_SELECTION);
    if(hr != NOERROR)
    {
        TRACEERRORSZ("QueryInsertObject() failed.");
        goto err;
    }

    hr = reobj.poleobj->SetClientSite(reobj.polesite);
    if(hr)
    {
        TRACEERRORSZ("SetClientSite() failed.");
        goto err;
    }

    if(hr = InsertObject(&reobj))
    {
        TRACEERRORSZ("InsertObject() failed.");
    }

err:
    if(reobj.poleobj)
        reobj.poleobj->Release();

    if(reobj.polesite)
        reobj.polesite->Release();

    if(reobj.pstg)
        reobj.pstg->Release();

    return hr;
}

typedef void (WINAPI*DRAGFINISH)(HDROP);
typedef UINT (WINAPI*DRAGQUERYFILEA)(HDROP, UINT, LPSTR, UINT);
typedef UINT (WINAPI*DRAGQUERYFILEW)(HDROP, UINT, LPTSTR, UINT);
typedef BOOL (WINAPI*DRAGQUERYPOINT)(HDROP, LPPOINT);

LRESULT CTxtEdit::OnDropFiles(
    HANDLE hDropFiles)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDropFiles");

    UINT    cFiles;
    UINT    iFile;
    char    szFile[MAX_PATH];
    WCHAR   wFile[MAX_PATH];
    POINT   ptDrop;
    CTxtSelection * const psel = GetSel();
    HMODULE     hDLL = NULL;
    DRAGFINISH      fnDragFinish;
    DRAGQUERYFILEA  fnDragQueryFileA;
    DRAGQUERYFILEW  fnDragQueryFileW;
    DRAGQUERYPOINT  fnDragQueryPoint;

    if (_fReadOnly)
        return 0;

    AssertSz((hDropFiles != NULL), "CTxtEdit::OnDropFiles invalid hDropFiles");

    // dynamic load Shell32

    hDLL = LoadLibrary (TEXT("Shell32.DLL"));
    if(hDLL)
    {
        fnDragFinish = (DRAGFINISH)GetProcAddress (hDLL, "DragFinish");
        fnDragQueryFileA = (DRAGQUERYFILEA)GetProcAddress (hDLL, "DragQueryFileA");
        fnDragQueryFileW = (DRAGQUERYFILEW)GetProcAddress (hDLL, "DragQueryFileW");
        fnDragQueryPoint = (DRAGQUERYPOINT)GetProcAddress (hDLL, "DragQueryPoint");
    }
    else
        return 0;

    if(!fnDragFinish || !fnDragQueryFileA || !fnDragQueryFileW || !fnDragQueryPoint)
    {
        AssertSz(FALSE, "Shell32 GetProcAddress failed");
        goto EXIT0;
    }

    (*fnDragQueryPoint) ((HDROP)hDropFiles, &ptDrop);
    if(W32->OnWin9x())
        cFiles = (*fnDragQueryFileA) ((HDROP)hDropFiles, (UINT)-1, NULL, 0);
    else
        cFiles = (*fnDragQueryFileW) ((HDROP)hDropFiles, (UINT)-1, NULL, 0);

    if(cFiles)
    {
        LONG        cp = 0;
        POINT       ptl = ptDrop;
        CRchTxtPtr  rtp(this);
        const CCharFormat   *pCF;

        if(_pdp->CpFromPoint(ptl, NULL, &rtp, NULL, FALSE) >= 0)
        {
            cp = rtp.GetCp();
            pCF = rtp.GetCF();
        }
        else
        {
            LONG iCF = psel->Get_iCF();
            cp = psel->GetCp();
            pCF = GetCharFormat(iCF);
            ReleaseFormats(iCF, -1);
        }

        // Notify user for dropfile
        if(_dwEventMask & ENM_DROPFILES)
        {
            ENDROPFILES endropfiles;

            endropfiles.hDrop = hDropFiles;
            endropfiles.cp = Get10Mode() ? GetAcpFromCp(cp) : cp;
            endropfiles.fProtected = !!(pCF->_dwEffects & CFE_PROTECTED);

            if(TxNotify(EN_DROPFILES, &endropfiles))
                goto EXIT;                  // Ignore drop file

            cp = Get10Mode() ? GetCpFromAcp(endropfiles.cp) : endropfiles.cp;   // Allow callback to update cp
        }
        psel->SetCp(cp);
    }

    for (iFile = 0;  iFile < cFiles; iFile++)
    {
        if(W32->OnWin9x())
        {
            (*fnDragQueryFileA) ((HDROP)hDropFiles, iFile, szFile, MAX_PATH);
            MultiByteToWideChar(CP_ACP, 0, szFile, -1,
                            wFile, MAX_PATH);
        }
        else
            (*fnDragQueryFileW) ((HDROP)hDropFiles, iFile, wFile, MAX_PATH);

        InsertFromFile (wFile);
    }

EXIT:
    (*fnDragFinish) ((HDROP)hDropFiles);

EXIT0:
    FreeLibrary (hDLL);
    return 0;
}

#else // NODROPFILES

LRESULT CTxtEdit::OnDropFiles(HANDLE hDropFiles)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDropFiles");

    return 0;
}

#endif  // NODROPFILES


///////////////////////////////  Exposable methods  //////////////////////////////////////

/*
 *  CTxtEdit::TxCharFromPos (ppt, plres)
 *
 *  @mfunc
 *      Get the acp at the point *ppt.
 *
 *  @rdesc
 *      HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *                (CpFromPoint succeeded) ? S_OK : E_FAIL
 *  @comm
 *      This function outputs an API cp that may differ from the
 *      corresponding internal Unicode cp.
 */
HRESULT CTxtEdit::TxCharFromPos(
    LPPOINT  ppt,   //@parm Point to find the acp for
    LRESULT *plres) //@parm Output parm to receive the acp
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxCharFromPos");

    if(!fInplaceActive())
    {
        // We have no valid display rectangle if this object is not active
        *plres = -1;
        return OLE_E_INVALIDRECT;
    }
    *plres = _pdp->CpFromPoint(*ppt, NULL, NULL, NULL, FALSE);
    if(*plres == -1)
        return E_FAIL;

    *plres = GetAcpFromCp(*plres);
    return S_OK;
}

/*
 *  CTxtEdit::TxPosFromChar (acp, ppt)
 *
 *  @mfunc
 *      Get the point at acp.
 *
 *  @rdesc
 *      HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *                (PointFromTp succeeded) ? S_OK : E_FAIL
 *  @comm
 *      This function inputs an API cp that may differ from the
 *      corresponding internal Unicode cp.
 */
HRESULT CTxtEdit::TxPosFromChar(
    LONG    acp,        //@parm Input cp to get the point for
    POINT * ppt)        //@parm Output parm to receive the point
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxPosFromChar");

    if(!fInplaceActive())
        return OLE_E_INVALIDRECT;

    CRchTxtPtr rtp(this, GetCpFromAcp(acp));

    if(_pdp->PointFromTp(rtp, NULL, FALSE, *ppt, NULL, TA_TOP) < 0)
        return E_FAIL;

    return S_OK;
}

/*
 *  CTxtEdit::TxFindWordBreak (nFunction, acp, plres)
 *
 *  @mfunc
 *      Find word break or classify character at acp.
 *
 *  @rdesc
 *      HRESULT = plRet ? S_OK : E_INVALIDARG
 *
 *  @comm
 *      This function inputs and exports API cp's and cch's that may differ
 *      from the internal Unicode cp's and cch's.
 */
HRESULT CTxtEdit::TxFindWordBreak(
    INT      nFunction, //@parm Word break function
    LONG     acp,       //@parm Input cp
    LRESULT *plres)     //@parm cch moved to reach break
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxFindWordBreak");

    CTxtPtr tp(this, GetCpFromAcp(acp));        // This validates cp
    LONG    cpSave = tp.GetCp();                // Save starting value

    if(!plres)
        return E_INVALIDARG;

    *plres = tp.FindWordBreak(nFunction);

    // WB_CLASSIFY and WB_ISDELIMITER return values; others return offsets
    // this function returns values, so it converts when necessary
    if(nFunction != WB_CLASSIFY && nFunction != WB_ISDELIMITER)
        *plres = GetAcpFromCp(LONG(*plres + cpSave));

    return S_OK;
}

/*
 *  INT CTxtEdit::TxWordBreakProc (pch, ich, cb, action)
 *
 *  @func
 *      Default word break proc used in conjunction with FindWordBreak. ich
 *      is character offset (start position) in the buffer pch, which is cb
 *      bytes in length.  Possible action values are:
 *
 *  WB_CLASSIFY
 *      Returns char class and word break flags of char at start position.
 *
 *  WB_ISDELIMITER
 *      Returns TRUE iff char at start position is a delimeter.
 *
 *  WB_LEFT
 *      Finds nearest word beginning before start position using word breaks.
 *
 *  WB_LEFTBREAK
 *      Finds nearest word end before start position using word breaks.
 *      Used by CMeasurer::Measure()
 *
 *  WB_MOVEWORDLEFT
 *      Finds nearest word beginning before start position using class
 *      differences. This value is used during CTRL+LEFT key processing.
 *
 *  WB_MOVEWORDRIGHT
 *      Finds nearest word beginning after start position using class
 *      differences. This value is used during CTRL+RIGHT key processing.
 *
 *  WB_RIGHT
 *      Finds nearest word beginning after start position using word breaks.
 *      Used by CMeasurer::Measure()
 *
 *  WB_RIGHTBREAK
 *      Finds nearest word end after start position using word breaks.
 *
 *  @rdesc
 *      Character offset from start of buffer (pch) of the word break
 */
INT CTxtEdit::TxWordBreakProc(
    TCHAR * pch,        //@parm Char buffer
    INT     ich,        //@parm Char offset of _cp in buffer
    INT     cb,         //@parm Count of bytes in buffer
    INT     action,     //@parm Type of breaking action
    LONG    cpStart,    //@parm cp for first character in pch
    LONG    cp)         //@parm cp associated to ich
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxWordBreakProc");

    if (_pfnWB)
    {
        // Client overrode the wordbreak proc, delegate the call to it.
        if (!Get10Mode())
        {
            Assert(!_fExWordBreakProc);
            return _pfnWB(pch, ich, cb, action);
        }
        else
        {
            int ret = 0;
            char sz[256];
            char* pach = sz;
            if (cb >= 255)
                pach = new char [cb + 1];

            // this indicates if we have to adjust the pach because the api's for
            // EDITWORDBREAKPROCEX and EDITWORDBREAKPROC are different when looking to the left
            BOOL fAdjustPtr = _fExWordBreakProc && (action == WB_LEFT || action == WB_MOVEWORDLEFT || action == WB_LEFTBREAK);

            // RichEdit 1.0, create a buffer, translate ich and WCTMB
            // pch into the buffer.  Need codepage to use. Then get translate
            // return value. Translations are like GetCachFromCch() and
            // GetCchFromCach()
            if (_fExWordBreakProc)
            {
                Assert(ich == 0 || ich == 1 || ich == CchOfCb(cb));

                // We need to adjust the cp to the starting point of the buffer
                if (!fAdjustPtr)
                {
                    cpStart += ich;
                    pch += ich;
                    cb -= (2 * ich);
                }

                // initialize string w/ zero's so we can determine the length of the string for later
                memset(pach, 0, cb + 1);
            }

            int nLen = CchOfCb(cb);
            CRchTxtPtr rtp(this, cpStart);
            BYTE bCharSet = rtp.GetCF()->_bCharSet;
            if (WideCharToMultiByte(GetCodePage(bCharSet), 0, pch, nLen, pach, cb + 1, NULL, NULL))
            {
                // Documentation stipulates we need to point to the end of the string
                if (fAdjustPtr)
                    pach += strlen(pach);

                if (_fExWordBreakProc)
                    ret = ((EDITWORDBREAKPROCEX)_pfnWB)(pach, nLen, bCharSet, action);
                else
                {
                    ret = ((EDITWORDBREAKPROCA)_pfnWB)(pach, rtp.GetCachFromCch(ich), nLen, action);

                    // need to reset cp position because GetCachFromCch potentially moves the cp
                    if (ich)
                        rtp.SetCp(cpStart);
                }

                // For WB_ISDELIMITER and WB_CLASSIFY don't need to convert back
                // to ich because return value represents a BOOL
                if (action != WB_ISDELIMITER && action != WB_CLASSIFY)
                    ret = rtp.GetCchFromCach(ret);
            }

            // Delete any allocated memory
            if (pach != sz)
                delete [] pach;
            return ret;
        }
    }

    LONG    cchBuff = CchOfCb(cb);
    LONG    cch = cchBuff - ich;
    TCHAR   ch;
    WORD    cType3[MAX_CLASSIFY_CHARS];
    INT     kinsokuClassifications[MAX_CLASSIFY_CHARS];
    WORD *  pcType3;
    INT  *  pKinsoku1, *pKinsoku2;
    WORD *  pwRes;
    WORD    startType3 = 0;
    WORD    wb = 0;
    WORD    wClassifyData[MAX_CLASSIFY_CHARS];  // For batch classifying

    Assert(cchBuff < MAX_CLASSIFY_CHARS);
    Assert(ich >= 0 && ich < cchBuff);


    // Single character actions
    if ( action == WB_CLASSIFY )
    {
        // 1.0 COMPATABILITY - 1.0 returned 0 for apostrohpe's
        TCHAR ch = pch[ich];
        if (Get10Mode() && ( ch ==  0x0027 /*APOSTRPHE*/ ||
            ch == 0xFF07 /*FULLWIDTH APOSTROPHE*/))
        {
            return 0;
        }
        return ClassifyChar(ch);
    }

    if ( action == WB_ISDELIMITER )
        return !!(ClassifyChar(pch[ich]) & WBF_BREAKLINE);

    // Batch classify buffer for whitespace and kinsoku classes
    BatchClassify(pch, cchBuff, cType3, kinsokuClassifications, wClassifyData);

    if (_pbrk && cp > -1)
    {
		cp -= ich;

        for (LONG cbrk = cchBuff-1; cbrk >= 0; --cbrk)
        {
            if (cp + cbrk >= 0 && _pbrk->CanBreakCp(BRK_WORD, cp + cbrk))
            {
                // Mimic class open/close in Kinsoku classification.
                kinsokuClassifications[cbrk] = brkclsOpen;
                if (cbrk > 0)
				{
                    kinsokuClassifications[cbrk-1] = brkclsClose;
                    wClassifyData[cbrk-1] |= WBF_WORDBREAKAFTER;
				}
            }
        }
    }

    // Setup pointers
    pKinsoku2 = kinsokuClassifications + ich;       // Ptr to current  kinsoku
    pKinsoku1 = pKinsoku2 - 1;                      // Ptr to previous kinsoku

    if(!(action & 1))                               // WB_(MOVE)LEFTxxx
    {
        ich--;
        Assert(ich >= 0);
    }
    pwRes    = &wClassifyData[ich];
    pcType3  = &cType3[ich];                        // for ideographics

    switch(action)
    {
    case WB_LEFT:
        for(; ich >= 0 && *pwRes & WBF_BREAKLINE;   // Skip preceding line
            ich--, pwRes--)                         //  break chars
                ;                                   // Empty loop. Then fall
                                                    //  thru to WB_LEFTBREAK
    case WB_LEFTBREAK:
        for(; ich >= 0 && !CanBreak(*pKinsoku1, *pKinsoku2);
            ich--, pwRes--, pKinsoku1--, pKinsoku2--)
                ;                                   // Empty loop
        if(action == WB_LEFTBREAK)                  // Skip preceding line
        {                                           //  break chars
            for(; ich >= 0 && *pwRes & WBF_BREAKLINE;
                ich--, pwRes--)
                    ;                               // Empty loop
        }
        return ich + 1;

    case WB_MOVEWORDLEFT:
        for(; ich >= 0 && (*pwRes & WBF_CLASS) == 2;// Skip preceding blank
            ich--, pwRes--, pcType3--)              //  chars
                ;
        if(ich >= 0)                                // Save starting wRes and
        {                                           //  startType3
            wb = *pwRes--;                          // Really type1
            startType3 = *pcType3--;                // type3
            ich--;
        }
        // Skip to beginning of current word
        while(ich >= 0 && (*pwRes & WBF_CLASS) != 3 &&
            !(*pwRes & WBF_WORDBREAKAFTER) &&
            (IsSameClass(*pwRes, wb, *pcType3, startType3) ||
            !wb && ich && ((ch = pch[ich]) == '\'' || ch == RQUOTE)))
        {
            ich--, pwRes--, pcType3--;
        }
        return ich + 1;


    case WB_RIGHTBREAK:
        for(; cch > 0 && *pwRes & WBF_BREAKLINE;    // Skip any leading line
            cch--, pwRes++)                         //  break chars
                ;                                   // Empty loop
                                                    // Fall thru to WB_RIGHT
    case WB_RIGHT:
        // Skip to end of current word
        for(; cch > 0 && !CanBreak(*pKinsoku1, *pKinsoku2);
            cch--, pKinsoku1++, pKinsoku2++, pwRes++)
                ;
        if(action != WB_RIGHTBREAK)                 // Skip trailing line
        {                                           //  break chars
            for(; cch > 0 && *pwRes & WBF_BREAKLINE;
                cch--, pwRes++)
                    ;
        }
        return cchBuff - cch;

    case WB_MOVEWORDRIGHT:
        if(cch <= 0)                                // Nothing to do
            return ich;

        wb = *pwRes;                                // Save start wRes
        startType3 = *pcType3;                      //  and startType3

        // Skip to end of word
        if (startType3 & C3_IDEOGRAPH ||            // If ideographic or
            (*pwRes & WBF_CLASS) == 3)              //  tab/cell, just
        {
            cch--, pwRes++;                         //  skip one char
        }
        else while(cch > 0 &&
            !(*pwRes & WBF_WORDBREAKAFTER) &&
            (IsSameClass(*pwRes, wb, *pcType3, startType3) || !wb &&
             ((ch = pch[cchBuff - cch]) == '\'' || ch == RQUOTE)))
        {
            cch--, pwRes++, pcType3++;
        }

        for(; cch > 0 &&
            ((*pwRes & WBF_CLASS) == 2              // Skip trailing blank
            || (*pwRes & WBF_WORDBREAKAFTER)); 		// Skip Thai break after
            cch--, pwRes++)                         //  chars
                    ;
        return cchBuff - cch;
    }

    TRACEERRSZSC("CTxtEdit::TxWordBreakProc: unknown action", action);
    return ich;
}


/*
 *  CTxtEdit::TxFindText (flags, cpMin, cpMost, pch, pcpRet)
 *
 *  @mfunc
 *      Find text in direction specified by flags starting at cpMin if
 *      forward search (flags & FR_DOWN nonzero) and cpMost if backward
 *      search.
 *
 *  @rdesc
 *      HRESULT (success) ? NOERROR : S_FALSE
 *
 *  @comm
 *      Caller is responsible for setting cpMin to the appropriate end of
 *      the selection depending on which way the search is proceding.
 */
HRESULT CTxtEdit::TxFindText(
    DWORD       flags,   //@parm Specify FR_DOWN, FR_MATCHCASE, FR_WHOLEWORD
    LONG        cpStart, //@parm Find start cp
    LONG        cpLimit, //@parm Find limit cp
    const WCHAR*pch,     //@parm Null terminated string to search for
    LONG *      pcpMin,  //@parm Out parm to receive start of matched string
    LONG *      pcpMost) //@parm Out parm to receive end of matched string
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxFindText");

    if(Get10Mode())                         // RichEdit 1.0 only searches
    {
        flags |= FR_DOWN;                   //  forward
        if (cpLimit < -1)
            cpLimit = -1;
    }

    DWORD       cchText = GetTextLength();
    LONG        cchToFind;
    const BOOL  fSetCur = (cchText >= 4096);
    HCURSOR     hcur = NULL;                // Init to keep compiler happy

    Assert(pcpMin && pcpMost);

    // Validate parameters
    if(!pch || !(cchToFind = wcslen(pch)) || cpStart < 0 || cpLimit < -1)
        return E_INVALIDARG;                // Nothing to search for

    CTxtPtr tp(this, cpStart);

    if(fSetCur)                             // In case this takes a while...
        hcur = TxSetCursor(LoadCursor(0, IDC_WAIT), NULL);

    *pcpMin  = tp.FindText(cpLimit, flags, pch, cchToFind);
    *pcpMost = tp.GetCp();

    if(fSetCur)
        TxSetCursor(hcur, NULL);

    return *pcpMin >= 0 ? NOERROR : S_FALSE;;
}

/*
 *  CTxtEdit::TxGetLineCount (plres)
 *
 *  @mfunc
 *      Get the line count.
 *
 *  @rdesc
 *      HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *                (WaitForRecalc succeeded) ? S_OK : E_FAIL
 */
HRESULT CTxtEdit::TxGetLineCount(
    LRESULT *plres)     //@parm Output parm to receive line count
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetLineCount");

    AssertSz(plres, "CTxtEdit::TxGetLineCount invalid pcli");

    if(!fInplaceActive())
        return OLE_E_INVALIDRECT;

    if(!_pdp->WaitForRecalc(GetTextLength(), -1))
        return E_FAIL;

    *plres = _pdp->LineCount();
    Assert(*plres > 0);

    return S_OK;
}

/*
 *  CTxtEdit::TxLineFromCp (acp, plres)
 *
 *  @mfunc
 *      Get the line containing acp.
 *
 *  @rdesc
 *      HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *                (LineFromCp succeeded) ? S_OK : E_FAIL
 *  @comm
 *      This function inputs an API cp that may differ from the
 *      corresponding internal Unicode cp.
 */
HRESULT CTxtEdit::TxLineFromCp(
    LONG     acp,       //@parm Input cp
    LRESULT *plres)     //@parm Ouput parm to receive line number
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineFromCp");

    BOOL    fAtEnd = FALSE;
    LONG    cp = 0;

    AssertSz(plres, "CTxtEdit::TxLineFromCp invalid plres");

    if(!fInplaceActive())
    {
        AssertSz(*plres == 0,
            "CTxtEdit::TxLineFromCp error return lres not correct");
        return OLE_E_INVALIDRECT;
    }

    if(acp < 0)                                 // Validate cp
    {
        if(_psel)
        {
            cp = _psel->GetCpMin();
            fAtEnd = !_psel->GetCch() && _psel->CaretNotAtBOL();
        }
    }
    else
    {
        LONG cchText = GetTextLength();
        cp = GetCpFromAcp(acp);
        cp = min(cp, cchText);
    }

    *plres = _pdp->LineFromCp(cp, fAtEnd);

    HRESULT hr = *plres < 0 ? E_FAIL : S_OK;

    // Old messages expect 0 as a result of this call if there is an error.
    if(*plres == -1)
        *plres = 0;

    return hr;
}

/*
 *  CTxtEdit::TxLineLength (acp, plres)
 *
 *  @mfunc
 *      Get the line containing acp.
 *
 *  @rdesc
 *      HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *                (GetSel() succeeded) ? S_OK : E_FAIL
 *  @comm
 *      This function inputs an API cp and outputs an API cch that
 *      may differ from the corresponding internal Unicode cp and cch.
 */
HRESULT CTxtEdit::TxLineLength(
    LONG     acp,       //@parm Input cp
    LRESULT *plres)     //@parm Output parm to receive line length
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineLength");

    LONG cch = 0;
    LONG cp;

    AssertSz(plres,
            "CTxtEdit::TxLineLength Invalid plres parameter");

    if(!fInplaceActive())
        return OLE_E_INVALIDRECT;

    if(acp < 0)
    {
        if(!_psel)
            return E_FAIL;
        cch = _psel->LineLength(&cp);
    }
    else
    {
        cp = GetCpFromAcp(acp);
        if(cp <= GetAdjustedTextLength())
        {
            CLinePtr rp(_pdp);
            rp.RpSetCp(cp, FALSE);
            cp -= rp.GetIch();              // Goto start of line
            cch = rp.GetAdjustedLineLength();
        }
    }
    if(fCpMap())                            // Can be time consuming, so
    {                                       //  don't do it unless asked
        CRchTxtPtr rtp(this, cp);           //  for
        cch = rtp.GetCachFromCch(cch);
    }
    *plres = cch;
    return S_OK;
}

/*
 *  CTxtEdit::TxLineIndex (acp, plres)
 *
 *  @mfunc
 *      Get the line containing acp.
 *
 *  @rdesc
 *      HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *                (LineCount() && WaitForRecalcIli succeeded) ? S_OK : E_FAIL
 *  @comm
 *      This function outputs an API cp that may differ from the
 *      corresponding internal Unicode cp.
 */
HRESULT CTxtEdit::TxLineIndex(
    LONG     ili,       //@parm Line # to find acp for
    LRESULT *plres)     //@parm Output parm to receive acp
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineIndex");

    HRESULT hr;
    AssertSz(plres, "CTxtEdit::TxLineIndex invalid plres");

    *plres = -1;
    if(!fInplaceActive())
        return OLE_E_INVALIDRECT;

    if(ili == -1)
    {
        // Fetch line from the current cp.
        LRESULT lres;                   // For 64-bit compatibility
        hr = TxLineFromCp(-1, &lres);
        if(hr != NOERROR)
            return hr;
        ili = (LONG)lres;
    }

    // ili is a zero-based *index*, whereas count returns the total # of lines.
    // Therefore, we use >= for our comparisions.
    if(ili >= _pdp->LineCount() && !_pdp->WaitForRecalcIli(ili))
        return E_FAIL;

    *plres = GetAcpFromCp(_pdp->CpFromLine(ili, NULL));

    return S_OK;
}

///////////////////////////////////  Miscellaneous messages  ////////////////////////////////////

/*
 *  CTxtEdit::OnFindText (msg, flags, pftex)
 *
 *  @mfunc
 *      Find text.
 *
 *  @rdesc
 *      LRESULT = succeeded ? acpmin : -1
 *
 *  @comm
 *      This function inputs and exports API cp's that may differ
 *      from the internal Unicode cp's.
 */
LRESULT CTxtEdit::OnFindText(
    UINT        msg,
    DWORD       flags,
    FINDTEXTEX *pftex)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnFindText");

    LONG cpMin, cpMost;

    if(TxFindText(flags,
                  GetCpFromAcp(pftex->chrg.cpMin),
                  GetCpFromAcp(pftex->chrg.cpMost),
                  pftex->lpstrText, &cpMin, &cpMost) != S_OK)
    {
        if(msg == EM_FINDTEXTEX || msg == EM_FINDTEXTEXW)
        {
            pftex->chrgText.cpMin  = -1;
            pftex->chrgText.cpMost = -1;
        }
        return -1;
    }

    LONG acpMin  = GetAcpFromCp(cpMin);
    if(msg == EM_FINDTEXTEX || msg == EM_FINDTEXTEXW)   // We send a message
    {                                                   //  back to change
        pftex->chrgText.cpMin  = acpMin;                //  selection to this
        pftex->chrgText.cpMost = GetAcpFromCp(cpMost);
    }
    return (LRESULT)acpMin;
}

LRESULT CTxtEdit::OnGetWordBreakProc()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetWordBreakProc");

    return (LRESULT) _pfnWB;
}

// For plain-text instances, OnGetCharFormat(), OnGetParaFormat(),
// OnSetCharFormat(), and OnSetParaFormat() apply to whole story

LRESULT CTxtEdit::OnGetCharFormat(
    CHARFORMAT2 *pCF2,
    DWORD        dwFlags)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetCharFormat");

    UINT cb = pCF2->cbSize;
    UINT CodePage = 1200;

    if(!IsValidCharFormatW(pCF2))
    {
        if(!IsValidCharFormatA((CHARFORMATA *)pCF2))
            return 0;
        CodePage = GetDefaultCodePage(EM_GETCHARFORMAT);
    }

    if(cb == sizeof(CHARFORMATW) || cb == sizeof(CHARFORMATA))
        dwFlags |= CFM2_CHARFORMAT;             // Tell callees that only
                                                //  CHARFORMAT parms needed
    CCharFormat CF;
    DWORD dwMask = CFM_ALL2;

    if(dwFlags & SCF_SELECTION)
        dwMask = GetSel()->GetCharFormat(&CF, dwFlags);
    else
        CF = *GetCharFormat(-1);

    if(dwFlags & CFM2_CHARFORMAT)               // Maintain CHARFORMAT
    {                                           //  compatibility
        CF._dwEffects &= CFM_EFFECTS;
        dwMask        &= CFM_ALL;
    }

    CF.Get(pCF2, CodePage);
    pCF2->dwMask = dwMask;
    return (LRESULT)dwMask;
}

LRESULT CTxtEdit::OnGetParaFormat(
    PARAFORMAT2 *pPF2,
    DWORD        dwFlags)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetParaFormat");

    if(!IsValidParaFormat(pPF2))
        return 0;

    if(pPF2->cbSize == sizeof(PARAFORMAT))  // Tell callees that only
        dwFlags |= PFM_PARAFORMAT;          //  PARAFORMAT parms needed

    CParaFormat PF;
    DWORD       dwMask = GetSel()->GetParaFormat(&PF, dwFlags);

    if(dwFlags & PFM_PARAFORMAT)
        dwMask &= PFM_ALL;

    PF.Get(pPF2);
    pPF2->dwMask = dwMask;
    return (LRESULT)dwMask;
}

/*
 *  CTxtEdit::OnSetFontSize(yPoint, publdr)
 *
 *  @mfunc
 *      Set new font height by adding yPoint to current height
 *      and rounding according to the table in cfpf.cpp
 *
 *  @rdesc
 *      LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetFontSize(
    LONG yPoint,
    IUndoBuilder *publdr)   //@parm Undobuilder to receive antievents
{
    // TODO: ? Return nonzero if we set a new font size for some text.

    CCharFormat CF;
    CF._yHeight = (SHORT)yPoint;

    return OnSetCharFormat(SCF_SELECTION, &CF, publdr, CFM_SIZE,
                           CFM2_CHARFORMAT | CFM2_USABLEFONT);
}

/*
 *  CTxtEdit::OnSetFont(hfont)
 *
 *  @mfunc
 *      Set new default font from hfont
 *
 *  @rdesc
 *      LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetFont(
    HFONT hfont)            //@parm Handle of font to use for default
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetFont");

    CCharFormat CF;
    if(FAILED(CF.InitDefault(hfont)))
        return 0;

    DWORD dwMask2 = CFM2_CHARFORMAT;
    WPARAM wparam = SCF_ALL;

    if(!GetAdjustedTextLength())
    {
        dwMask2 = CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK;
        wparam = 0;
    }

    return !FAILED(OnSetCharFormat(wparam, &CF, NULL, CFM_ALL, dwMask2));
}

/*
 *  CTxtEdit::OnSetCharFormat(wparam, pCF, publdr, dwMask, dwMask2)
 *
 *  @mfunc
 *      Set new default CCharFormat
 *
 *  @rdesc
 *      LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetCharFormat(
    WPARAM        wparam,   //@parm Selection flag
    CCharFormat * pCF,      //@parm CCharFormat to apply
    IUndoBuilder *publdr,   //@parm Undobuilder to receive antievents
    DWORD         dwMask,   //@parm CHARFORMAT2 mask
    DWORD         dwMask2)  //@parm Second mask
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetCharFormat");

    // This says that if there's a selection that's protected and the
    // parent window wants protection notifications and doesn't want
    // changes with a protected selection, then return 0.  This is more
    // stringent than RE 2.0, but it's more like 1.0.
    if (_psel && _psel->IsProtected(0) == CTxtRange::PROTECTED_ASK &&
        _dwEventMask & ENM_PROTECTED)
    {
        CHARFORMAT CF0;                 // Selection is protected, client
                                        //  wants protect notifications
        CF0.cbSize = sizeof(CHARFORMAT);//  and protected mask is on
        CF0.dwEffects = pCF->_dwEffects;// Concoct CHARFORMAT for query
        CF0.dwMask = dwMask;            // Maybe need more fields...
        if(QueryUseProtection(_psel, EM_SETCHARFORMAT, wparam, (LPARAM)&CF0))
            return 0;                   // No deal
    }

    BOOL fRet = TRUE;

    AssertSz(!_fSelChangeCharFormat || IsRich(),
        "Inconsistent _fSelChangeCharFormat flag");

    if ((wparam & SCF_ALL) ||
        !_fSelChangeCharFormat && _story.GetCFRuns() && !(wparam & SCF_SELECTION))
    {
        CTxtRange rg(this, 0, -GetTextLength());

        if(publdr)
            publdr->StopGroupTyping();

        if ((dwMask & (CFM_CHARSET | CFM_FACE)) == (CFM_CHARSET | CFM_FACE))
        {
            if(GetAdjustedTextLength())
            {
                dwMask2 |= CFM2_MATCHFONT;
                if (_fAutoFontSizeAdjust)
                {
                    dwMask2 |= CFM2_ADJUSTFONTSIZE;
                    if (fUseUIFont())
                        dwMask2 |= CFM2_UIFONT;
                }
            }
            else
                dwMask2 |= CFM2_NOCHARSETCHECK;
        }

        fRet = (rg.SetCharFormat(pCF, 0, publdr, dwMask, dwMask2) == NOERROR);

        // If we have an insertion point, apply format to it as well
        if (_psel && !_psel->GetCch() &&
            _psel->SetCharFormat(pCF, wparam, publdr, dwMask, dwMask2) != NOERROR)
        {
            fRet = FALSE;
        }
    }
    else if(wparam & SCF_SELECTION)
    {
        // Change selection character format unless protected
        if(!_psel || !IsRich())
            return 0;

        return _psel->SetCharFormat(pCF, wparam, publdr, dwMask, dwMask2)
                == NOERROR;
    }

    // Change default character format
    CCharFormat        CF;                  // Local CF to party on
    LONG               iCF;                 // Possible new CF index
    const CCharFormat *pCF1;                // Ptr to current default CF
    ICharFormatCache  *pICFCache = GetCharFormatCache();

    if(FAILED(pICFCache->Deref(Get_iCF(), &pCF1)))  // Get ptr to current
    {                                       //  default CCharFormat
        fRet = FALSE;
        goto Update;
    }
    CF = *pCF1;                             // Copy current default CF
    CF.Apply(pCF, dwMask, dwMask2);         // Modify copy
    if(FAILED(pICFCache->Cache(&CF, &iCF))) // Cache modified copy
    {
        fRet = FALSE;
        goto Update;
    }

#ifdef LINESERVICES
    if (g_pols)
        g_pols->DestroyLine(NULL);
#endif

    pICFCache->Release(Get_iCF());          // Release _iCF regardless
    Set_iCF(iCF);                           //  of whether _iCF = iCF,
                                            //  i.e., only 1 ref count
    if(_psel && !_psel->GetCch() && _psel->Get_iFormat() == -1)
        _psel->UpdateCaret(FALSE);

    if ((dwMask & (CFM_CHARSET | CFM_FACE)) == CFM_FACE &&
        !GetFontName(pCF->_iFont)[0] && GetFontName(CF._iFont)[0] &&
        IsBiDiCharSet(CF._bCharSet))
    {
        // Client requested font/charset be chosen for it according to thread
        // locale. If BiDi, then also set RTL para default
        CParaFormat PF;
        PF._wEffects = PFE_RTLPARA;
        OnSetParaFormat(SPF_SETDEFAULT, &PF, publdr, PFM_RTLPARA | PFM_PARAFORMAT);
    }

Update:
    // FUTURE (alexgo): this may be unnecessary if the display handles
    // updating more automatically.
    _pdp->UpdateView();
    return fRet;
}

/*
 *  CTxtEdit::OnSetParaFormat(wparam, pPF, publdr, dwMask)
 *
 *  @mfunc
 *      Set new default CParaFormat
 *
 *  @rdesc
 *      LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetParaFormat(
    WPARAM       wparam,    //@parm wparam passed thru to IsProtected()
    CParaFormat *pPF,       //@parm CParaFormat to use
    IUndoBuilder *publdr,   //@parm Undobuilder to receive antievents
    DWORD        dwMask)    //@parm Mask to use
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetParaFormat");

    // If we're using context direction in the control, then we disallow
    // the paragraph direction property and the alignment property (unless
    // it's for center alignment).
    if(IsStrongContext(_nContextDir) || IsStrongContext(_nContextAlign))
    {
        Assert(!IsRich());
        if(dwMask & (PFM_RTLPARA | PFM_ALIGNMENT))
        {
            if (IsStrongContext(_nContextAlign) &&
                (pPF->_bAlignment == PFA_LEFT || pPF->_bAlignment == PFA_RIGHT))
            {
                dwMask &= ~PFM_ALIGNMENT;
            }
            if(IsStrongContext(_nContextDir))
                dwMask &= ~PFM_RTLPARA;
        }
    }
    BOOL fMatchKbdToPara = FALSE;

    if(dwMask & PFM_RTLPARA)
    {
        // In plain text allow DIR changes to change DIR and ALIGNMENT
        if(!IsRich())
        {
            // Clear all para masks, except for DIR and ALIGN
            dwMask &= (PFM_RTLPARA | PFM_ALIGNMENT);
            wparam |= SPF_SETDEFAULT;
        }
        if(_psel && _fFocus)
            fMatchKbdToPara = TRUE;
    }
    if(!(wparam & SPF_SETDEFAULT))
    {
        // If DEFAULT flag is specified, don't change selection
        if(!_psel || IsProtected(EM_SETPARAFORMAT, wparam, (LPARAM)pPF))
            return 0;

        LRESULT lres = NOERROR == (pPF->fSetStyle(dwMask)
             ? _psel->SetParaStyle(pPF, publdr, dwMask)
             : _psel->SetParaFormat(pPF, publdr, dwMask));

        // This is a bit funky, but basically, if the text is empty
        // then we also need to set the default paragraph format
        // (done in the code below).  Thus, if we hit a failure or
        // if the document is not empty, go ahead and return.
        // Otherwise, fall through to the default case.
        if(!lres || GetAdjustedTextLength())
        {
            if(fMatchKbdToPara)
                _psel->MatchKeyboardToPara();
            return lres;
        }
    }

    // No text in document or (wparam & SPF_SETDEFAULT): set default format

    LONG               iPF;                     // Possible new PF index
    CParaFormat        PF = *GetParaFormat(-1); // Local PF to party on
    IParaFormatCache  *pPFCache = GetParaFormatCache();

	PF.Apply(pPF, dwMask);						// Modify copy
	if(FAILED(pPFCache->Cache(&PF, &iPF)))		// Cache modified copy
		return 0;
	pPFCache->Release(Get_iPF());				// Release _iPF regardless of
	Set_iPF(iPF);								// Update default format index
	
	if(PF.IsRtlPara())		
		OrCharFlags(fBIDI, publdr);				// BiDi in backing store

	if(!IsRich() && dwMask & PFM_RTLPARA)		// Changing plain-text default PF
	{
		ItemizeDoc(publdr);						// causing re-itemize the whole doc.

        // (#6503) We cant undo the -1 format change in plaintext and that causes
        // many problems when we undo ReplaceRange event happening before the paragraph
        // switches. We better abandon the whole stack for now. (wchao)
        // -FUTURE- We should create an antievent for -1 PF change.
        ClearUndo(publdr);
    }
    _pdp->UpdateView();
    if (_psel)
        _psel->UpdateCaret(!Get10Mode() || _psel->IsCaretInView());
    if(fMatchKbdToPara)
        _psel->MatchKeyboardToPara();
    return TRUE;
}


////////////////////////////////  System notifications  ////////////////////////////////

LRESULT CTxtEdit::OnSetFocus()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetFocus");

    _fFocus = TRUE;

    // Update our idea of the current keyboard layout
    W32->RefreshKeyboardLayout();

    InitKeyboardFlags();

    if(!_psel)
        return 0;

    // _fMouseDown may sometimes be true.
    // This can happen when somebody steals our focus when we were doing
    // something with the mouse down--like processing a click. Thus, we'll
    // never get the MouseUpMessage.
    if(_fMouseDown)
    {
        TRACEWARNSZ("Getting the focus, yet we think the mouse is down");
    }
    _fMouseDown = FALSE;

    // BUG FIX #5369
    // Special case where we don't have a selection (or a caret). We need
    // to display something on focus so display a caret
    _psel->UpdateCaret(_fScrollCaretOnFocus, _psel->GetCch() == 0);
    _fScrollCaretOnFocus = FALSE;

    _psel->ShowSelection(TRUE);

    // if there is an in-place active object, we need to set the focus to
    // it. (in addition to the work that we do; this maintains compatibility
    // with RichEdit 1.0).
    if(_pobjmgr)
    {
        COleObject *pobj = _pobjmgr->GetInPlaceActiveObject();
        if(pobj)
        {
            IOleInPlaceObject *pipobj;

            if(pobj->GetIUnknown()->QueryInterface(IID_IOleInPlaceObject,
                    (void **)&pipobj) == NOERROR)
            {
                HWND hwnd;
                pipobj->GetWindow(&hwnd);

                if(hwnd)
                    SetFocus(hwnd);
                pipobj->Release();
            }
        }
    }

    TxNotify(EN_SETFOCUS, NULL);
    return 0;
}

LRESULT CTxtEdit::OnKillFocus()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnKillFocus");

    StopMagellanScroll();

    if(_pundo)
        _pundo->StopGroupTyping();

    if(_psel)
    {
        // Scroll back to beginning if necessary
        if (_fScrollCPOnKillFocus)
        {
            bool fHideSelectionLocal = _fHideSelection;

            // cannot hide Selection so cp=0 will be scroll into view.
            _fHideSelection = 0;
            OnSetSel(0, 0);
            _fHideSelection = fHideSelectionLocal;
        }

        _psel->DeleteCaretBitmap(TRUE); // Delete caret bitmap if one exists
        if(_fHideSelection)
            _psel->ShowSelection(FALSE);
    }

    _fFocus = FALSE;
    DestroyCaret();
    TxNotify(EN_KILLFOCUS, NULL);

    _fScrollCaretOnFocus = FALSE;       // Just to be safe, clear this
    return 0;
}


#if defined(DEBUG)
void CTxtEdit::OnDumpPed()
{
#ifndef NOPEDDUMP
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDumpPed");

    char sz[256];
    CTxtSelection * const psel = GetSel();
    SELCHANGE selchg;

    psel->SetSelectionInfo(&selchg);

    wsprintfA(sz,
        "cchText = %ld      cchTextMost = %ld\r\n"
        "cpSelActive = %ld      cchSel = %ld\r\n"
        "wSelType = %x      # lines = %ld\r\n"
        "SysDefLCID = %lx   UserDefLCID = %lx",
        GetTextLength(),    TxGetMaxLength(),
        psel->GetCp(),  psel->GetCch(),
        selchg.seltyp,  _pdp->LineCount(),
        GetSystemDefaultLCID(), GetUserDefaultLCID()
    );
    Tracef(TRCSEVINFO, "%s", sz);
    MessageBoxA(0, sz, "ED", MB_OK);
#endif                  // NOPEDDUMP
}
#endif                  // DEBUG


///////////////////////////// Scrolling Commands //////////////////////////////////////

HRESULT CTxtEdit::TxHScroll(
    WORD wCode,
    int xPos)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxHScroll");

    if(!fInplaceActive())
        return OLE_E_INVALIDRECT;

    _pdp->HScroll(wCode, xPos);
    return S_OK;
}

LRESULT CTxtEdit::TxVScroll(
    WORD wCode,
    int yPos)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxVScroll");

    return _pdp->VScroll(wCode, yPos);
}

HRESULT CTxtEdit::TxLineScroll(
    LONG cli,
    LONG cch)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineScroll");

    // Currently cch does nothing in the following call, so we ignore
    // its translation from cach to cch (need to instantiate an rtp
    // for the current line
    _pdp->LineScroll(cli, cch);
    return S_OK;
}

void CTxtEdit::OnScrollCaret()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnScrollCaret");

    if(_psel)
	{
		_psel->SetForceScrollCaret(TRUE);
        _psel->UpdateCaret(TRUE);
		_psel->SetForceScrollCaret(FALSE);
	}
}


///////////////////////////////// Editing messages /////////////////////////////////

void CTxtEdit::OnClear(
    IUndoBuilder *publdr)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnClear");

    if(!_psel || TxGetReadOnly())
    {
        Beep();
        return;
    }

    if(_psel->GetCch() && !IsProtected(WM_CLEAR, 0, 0))
    {
        _psel->StopGroupTyping();
        _psel->ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE);
    }
}

void CTxtEdit::Beep()
{
    if(_fAllowBeep)
        MessageBeep(0);
}


///////////////////////////////////  Miscellaneous  ///////////////////////////////////////////

/*
 *  CTxtEdit::ItemizeDoc(publdr, cchRange)
 *
 *  @mfunc
 *      Helper routine to itemize the cchRange size of document content
 *      called by various clients outside CTxtRange.
 */
void CTxtEdit::ItemizeDoc(
    IUndoBuilder *  publdr,
    LONG            cchRange)
{
    // If cchRange = -1, itemize the whole doc
    if (cchRange == -1)
        cchRange = GetTextLength();

	// We wouldnt itemize if the doc only contains a single EOP
	// because we dont want Check_rpPF being called when the -1
	// PF format hasnt been properly established.
	// This is kind of hack, should be removed in the future.
	//
    if(cchRange && GetAdjustedTextLength())
    {                                       // Only itemize if more than
        CTxtRange rg(this, 0, -cchRange);   //  final EOP
        rg.ItemizeRuns(publdr);
    }

#if 0
	// =FUTURE=
	//		Once we open SPF_SETDEFAULT to public. We shall incorporate this code.
	// Basically, one can change the default paragraph reading order at runtime. All
	// PF runs referencing to -1 PF format then need to be reassigned a new paragraph
	// level value and reitemized.(6-10-99, wchao)
	//
    if(cchRange > 0)
    {
        CTxtRange rg(this, 0, -cchRange);

		// -1 PF format may have changed.
		// We shall make sure that the level of each PF run match the reading order
		// before start itemization.
		//
		if (rg.Check_rpPF())
		{
			LONG	cchLeft = cchRange;
			LONG	cchAdvance = 0;
			LONG	cch;

			while (cchLeft > 0)
			{
				rg._rpPF.GetRun(0)->_level._value = rg.IsParaRTL() ? 1 : 0;

				cch = rg._rpPF.GetCchLeft();

				if (!rg._rpPF.NextRun())
					break;		// no more run

				cchAdvance += cch;
				cchLeft -= cch;
			}

			Assert (cchAdvance + cchLeft == cchRange);

			rg._rpPF.AdvanceCp(-cchAdvance);	// fly back to cp = 0
		}

		// Now we rerun itemization
        rg.ItemizeRuns(publdr);
    }
#endif
}

/*
 *  CTxtEdit::OrCharFlags(dwFlags, publdr)
 *
 *  @mfunc
 *      Or in new char flags and activate LineServices and Uniscribe
 *      if complex script chars occur.
 */
void CTxtEdit::OrCharFlags(
    DWORD dwFlags,
    IUndoBuilder* publdr)
{
    // REVIEW: Should we send a notification for LS turn on?
    // Convert dwFlags to new on flags
    dwFlags &= dwFlags ^ _dwCharFlags;
    if(dwFlags)
    {
        _dwCharFlags |= dwFlags;            // Update flags

        dwFlags &= fCOMPLEX_SCRIPT;

        if(dwFlags && (_dwCharFlags & fCOMPLEX_SCRIPT) == dwFlags)
        {
            // REVIEW: Need to check if Uniscribe and LineServices are available...
            OnSetTypographyOptions(TO_ADVANCEDTYPOGRAPHY, TO_ADVANCEDTYPOGRAPHY);
            ItemizeDoc();

            // FUTURE: (#6838) We cant undo operations before the first itemization.
            ClearUndo(publdr);
            _fAutoKeyboard = IsBiDi();
        }

        UINT    brk = 0;

        if (dwFlags & fNEEDWORDBREAK)
            brk += BRK_WORD;
        if (dwFlags & fNEEDCHARBREAK)
            brk += BRK_CLUSTER;
        if (brk)
        {
            CUniscribe* pusp = Getusp();

            if (!_pbrk && pusp && pusp->IsValid())
            {
                // First time detecting the script that needs word/cluster-breaker
                // (such as Thai, Indic, Lao etc.)
                _pbrk = new CTxtBreaker(this);
                Assert(_pbrk);
            }

            if (_pbrk && _pbrk->AddBreaker(brk))
            {
                // Sync up the breaking array(s)
                _pbrk->Refresh();
            }
        }
    }
}

/*
 *  CTxtEdit::OnSetTypographyOptions(wparam, lparam)
 *
 *  @mfunc
 *      If CTxtEdit isn't a password or accelerator control and wparam
 *      differs from _bTypography, update the latter and the view.
 *
 *  @rdesc
 *      HRESULT = S_OK
 */
HRESULT CTxtEdit::OnSetTypographyOptions(
    WPARAM wparam,      //@parm Typography flags
    LPARAM lparam)      //@parm Typography mask
{
    // Currently only TO_SIMPLELINEBREAK and TO_ADVANCEDTYPOGRAPHY are defined
    if(wparam & ~(TO_SIMPLELINEBREAK | TO_ADVANCEDTYPOGRAPHY))
        return E_INVALIDARG;

    DWORD dwTypography = _bTypography & ~lparam;    // Kill current flag values
    dwTypography |= wparam & lparam;                // Or in new values

    if(_cpAccelerator == -1 && _bTypography != (BYTE)dwTypography)
    {
        _bTypography = (BYTE)dwTypography;
        _pdp->InvalidateRecalc();
        TxInvalidateRect(NULL, FALSE);
    }
    return S_OK;
}

void CTxtEdit::TxGetViewInset(
    LPRECT prc,
    CDisplay *pdp) const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetViewInset");

    // Get inset, which is in HIMETRIC
    RECT rcHiMetricViewInset;

    if(SUCCEEDED(_phost->TxGetViewInset(&rcHiMetricViewInset)))
    {
        LONG vileft   = rcHiMetricViewInset.left;
        LONG vitop    = rcHiMetricViewInset.top;
        LONG viright  = rcHiMetricViewInset.right;
        LONG vibottom = rcHiMetricViewInset.bottom;

        if(!pdp)                        // If no display is specified,
            pdp = _pdp;                 //  use main display

        AssertSz(pdp->IsValid(), "CTxtEdit::TxGetViewInset Device not valid");

        // Convert HIMETRIC to pixels
        prc->left   = vileft   ? pdp->HimetricXtoDX( vileft ) : 0;
        prc->top    = vitop    ? pdp->HimetricYtoDY(rcHiMetricViewInset.top) : 0;
        prc->right  = viright  ? pdp->HimetricXtoDX(rcHiMetricViewInset.right) : 0;
        prc->bottom = vibottom ? pdp->HimetricYtoDY(rcHiMetricViewInset.bottom) : 0;
    }
    else
    {
        // The call to the host failed. While this is highly improbable, we do
        // want to something reasonably sensible. Therefore, we will just pretend
        // there is no inset and continue.
        ZeroMemory(prc, sizeof(RECT));
    }
}

#if 0
// Interchange horizontal and vertical commands
WORD wConvScroll(WORD wparam)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "wConvScroll");

    switch(wparam)
    {
        case SB_BOTTOM:
            return SB_TOP;

        case SB_LINEDOWN:
            return SB_LINEUP;

        case SB_LINEUP:
            return SB_LINEDOWN;

        case SB_PAGEDOWN:
            return SB_PAGEUP;

        case SB_PAGEUP:
            return SB_PAGEDOWN;

        case SB_TOP:
            return SB_BOTTOM;

        default:
            return wparam;
    }
}
#endif

//
//  helper functions. FUTURE (alexgo) maybe we should get rid of
//  some of these
//

/*  FUTURE (murrays): Unless they are called a lot, the TxGetBit routines
    might be done more compactly as:

BOOL CTxtEdit::TxGetBit(
    DWORD dwMask)
{
    DWORD dwBits = 0;
    _phost->TxGetPropertyBits(dwMask, &dwBits);
    return dwBits != 0;
}

e.g., instead of TxGetSelectionBar(), we use TxGetBit(TXTBIT_SELECTIONBAR).
If they are called a lot (like TxGetSelectionBar()), the bits should probably
be cached, since that saves a bunch of cache misses incurred in going over to
the host.

*/

BOOL CTxtEdit::IsLeftScrollbar() const
{
    if(!_fHost2)
        return FALSE;

    DWORD dwStyle, dwExStyle;

    _phost->TxGetWindowStyles(&dwStyle, &dwExStyle);
    return dwExStyle & WS_EX_LEFTSCROLLBAR;
}

TXTBACKSTYLE CTxtEdit::TxGetBackStyle() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetBackStyle");

    TXTBACKSTYLE style = TXTBACK_OPAQUE;
    _phost->TxGetBackStyle(&style);
    return style;
}

BOOL CTxtEdit::TxGetAutoSize() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetAutoSize");

    return (_dwEventMask & ENM_REQUESTRESIZE);
}

BOOL CTxtEdit::TxGetAutoWordSel() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetAutoWordSel");

    DWORD dwBits = 0;
    _phost->TxGetPropertyBits(TXTBIT_AUTOWORDSEL, &dwBits);
    return dwBits != 0;
}

DWORD CTxtEdit::TxGetMaxLength() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetMaxLength");

    // Keep this a DWORD in case client uses a cpMost of 0xFFFFFFFF, which is
    // admittedly a little large, at least for 32-bit address spaces!
    // tomForward would be a more reasonable max length, altho it's also
    // probably larger than possible in a 32-bit address space.
    return _cchTextMost;
}

/*
 *  CTxtEdit::TxSetMaxToMaxText(LONG cExtra)
 *
 *  @mfunc
 *      Set new maximum text length based on length of text and possibly extra chars
 *      to accomodate.
 *
 */
void CTxtEdit::TxSetMaxToMaxText(LONG cExtra)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxSetMaxToMaxText");

    // See if we need to update the text max
    LONG cchRealLen = GetAdjustedTextLength() + cExtra;

    if(_fInOurHost && _cchTextMost < (DWORD)cchRealLen)
        _cchTextMost = cchRealLen;
}

TCHAR CTxtEdit::TxGetPasswordChar() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetPasswordChar");

    if(_fUsePassword)
    {
        TCHAR ch = L'*';
        _phost->TxGetPasswordChar(&ch);

        // We don't allow these characters as password chars
        if(ch < 32 || ch == WCH_EMBEDDING)
            return L'*';
        return ch;
    }
    return 0;
}

DWORD CTxtEdit::TxGetScrollBars() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetScrollBars");

    DWORD dwScroll;
    _phost->TxGetScrollBars(&dwScroll);
    return dwScroll;
}

LONG CTxtEdit::TxGetSelectionBarWidth() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetSelectionBarWidth");

    LONG lSelBarWidth;
    _phost->TxGetSelectionBarWidth(&lSelBarWidth);
    return lSelBarWidth;
}

BOOL CTxtEdit::TxGetWordWrap() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetWordWrap");

    DWORD dwBits = 0;
    _phost->TxGetPropertyBits(TXTBIT_WORDWRAP, &dwBits);
    return dwBits != 0;
}

BOOL CTxtEdit::TxGetSaveSelection() const
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetSaveSelection");

    DWORD dwBits = 0;
    _phost->TxGetPropertyBits(TXTBIT_SAVESELECTION, &dwBits);
    return dwBits != 0;
}

/*
 *  CTxtEdit::ClearUndo()
 *
 *  @mfunc  Clear all undo buffers
 */
void CTxtEdit::ClearUndo(
    IUndoBuilder *publdr)   //@parm the current undo context (may be NULL)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::ClearUndo");

    if(_pundo)
        _pundo->ClearAll();

    if(_predo)
        _predo->ClearAll();

    if(publdr)
        publdr->Discard();
}

/////////////////////////////// ITextHost2 Extensions //////////////////////////////

/*
 *  CTxtEdit::TxIsDoubleClickPending ()
 *
 *  @mfunc  calls host via ITextHost2 to find out if double click is pending.
 *
 *  @rdesc  TRUE/FALSE
 */
BOOL CTxtEdit::TxIsDoubleClickPending()
{
    return _fHost2 ? _phost->TxIsDoubleClickPending() : FALSE;
}

/*
 *  CTxtEdit::TxGetWindow(phwnd)
 *
 *  @mfunc  calls host via ITextHost2 to get current window for this edit
 *          instance.  This is very helpful for OLE object support
 *
 *  @rdesc  HRESULT
 */
HRESULT CTxtEdit::TxGetWindow(
    HWND *phwnd)
{
    return _fHost2 ? _phost->TxGetWindow(phwnd) : E_NOINTERFACE;
}

/*
 *  CTxtEdit::TxSetForegroundWindow ()
 *
 *  @mfunc  calls host via ITextHost2 to make our window the foreground
 *          window. Used to support drag/drop.
 *
 *  @rdesc  HRESULT
 */
HRESULT CTxtEdit::TxSetForegroundWindow()
{
    return _fHost2 ? _phost->TxSetForegroundWindow() : E_NOINTERFACE;
}

/*
 *  CTxtEdit::TxGetPalette()
 *
 *  @mfunc  calls host via ITextHost2 to get current palette
 *
 *  @rdesc  HPALETTE
 */
HPALETTE CTxtEdit::TxGetPalette()
{
    return _fHost2 ? _phost->TxGetPalette() : NULL;
}

/*
 *  CTxtEdit::TxGetFEFlags(pFEFlags)
 *
 *  @mfunc  calls host via ITextHost2 to get current FE settings
 *
 *  @rdesc  HRESULT
 */
HRESULT CTxtEdit::TxGetFEFlags(
    LONG *pFEFlags)
{
    *pFEFlags = 0;                      // In case no ITextHost2 methods

    HRESULT hResult = _fHost2 ? _phost->TxGetFEFlags(pFEFlags) : E_NOINTERFACE;

    if (hResult == NOERROR && Get10Mode())
        *pFEFlags |= tomRE10Mode;

    return hResult;
}

//
//  Event Notification methods
//

/*
 *  CTxtEdit::TxNotify(iNotify, pv)
 *
 *  @mfunc  This function checks bit masks and sends notifications to the
 *          host.
 *
 *  @devnote    Callers should check to see if a special purpose notification
 *          method has already been provided.
 *
 *  @rdesc  S_OK, S_FALSE, or some error
 */
HRESULT CTxtEdit::TxNotify(
    DWORD iNotify,      //@parm Notification to send
    void *pv)           //@parm Data associated with notification
{
    // First, disallow notifications that we handle elsewhere
    Assert(iNotify != EN_SELCHANGE);    //see SetSelectionChanged
    Assert(iNotify != EN_ERRSPACE);     //see SetOutOfMemory
    Assert(iNotify != EN_CHANGE);       //see SetChangedEvent
    Assert(iNotify != EN_HSCROLL);      //see SendScrollEvent
    Assert(iNotify != EN_VSCROLL);      //see SendScrollEvent
    Assert(iNotify != EN_MAXTEXT);      //see SetMaxText
    Assert(iNotify != EN_MSGFILTER);    //this is handled specially
                                        // in TxSendMessage

    // Switch on the event to check masks.

    DWORD dwMask;
    switch(iNotify)
    {
        case EN_DROPFILES:
            dwMask = ENM_DROPFILES;
            goto Notify;

        case EN_PROTECTED:
            dwMask = ENM_PROTECTED;
            goto Notify;

        case EN_REQUESTRESIZE:
            dwMask = ENM_REQUESTRESIZE;
            goto Notify;

        case EN_PARAGRAPHEXPANDED:
            dwMask = ENM_PARAGRAPHEXPANDED;
            goto Notify;

        case EN_IMECHANGE:
            if (!Get10Mode())
                return S_FALSE;
            dwMask = ENM_IMECHANGE;
            goto Notify;

        case EN_UPDATE:
            if (!Get10Mode())
                break;
            dwMask = ENM_UPDATE;
            //FALL THROUGH CASE

        Notify:
            if(!(_dwEventMask & dwMask))
                return NOERROR;



    }

    return _phost->TxNotify(iNotify, pv);
}

/*
 *  CTxtEdit::SendScrollEvent(iNotify)
 *
 *  @mfunc  Sends scroll event if appropriate
 *
 *  @comm   Scroll events must be sent before any view updates have
 *          been requested and only if ENM_SCROLL is set.
 */
void CTxtEdit::SendScrollEvent(
    DWORD iNotify)      //@parm Notification to send
{
    Assert(iNotify == EN_HSCROLL || iNotify == EN_VSCROLL);

    // FUTURE (alexgo/ricksa).  The display code can't really
    // handle this assert yet.  Basically, we're trying to
    // say that scrollbar notifications have to happen
    // _before_ the window is updated.  When we do the
    // display rewrite, try to handle this better.

    // Assert(_fUpdateRequested == FALSE);

    if(_dwEventMask & ENM_SCROLL)
        _phost->TxNotify(iNotify, NULL);
}

/*
 *  CTxtEdit::HandleLinkNotification (msg, wparam, lparam, pfInLink)
 *
 *  @mfunc  Handles sending EN_LINK notifications.
 *
 *  @rdesc  TRUE if the EN_LINK message was sent and
 *          processed successfully.  Typically, that means the
 *          caller should stop whatever processing it was doing.
 */
BOOL CTxtEdit::HandleLinkNotification(
    UINT    msg,        //@parm msg prompting the link notification
    WPARAM  wparam,     //@parm wparam of the message
    LPARAM  lparam,     //@parm lparam of the message
    BOOL *  pfInLink)   //@parm if non-NULL, indicate if over a link
{
    if(pfInLink)
        *pfInLink = FALSE;

    if(!(_dwEventMask & ENM_LINK) || !_fInPlaceActive)
        return FALSE;

    HITTEST Hit;
    POINT   pt = {LOWORD(lparam), HIWORD(lparam)};

    if(msg == WM_SETCURSOR)
    {
        GetCursorPos(&pt);
        if(!_phost->TxScreenToClient(&pt))
            return FALSE;
    }

    LONG cp = _pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, &Hit);

    if(Hit != HT_Link)                  // Not a hyperlink
        return FALSE;

    LONG      cpMin, cpMost;            // It's a hyperlink
    ENLINK    enlink;
    CTxtRange rg(this, cp, 0);

    ZeroMemory(&enlink, sizeof(enlink));
    if (fInOurHost())
    {
        GetWindow((LONG *) &enlink.nmhdr.hwndFrom);
        enlink.nmhdr.idFrom = GetWindowLong(enlink.nmhdr.hwndFrom, GWL_ID);
    }
    enlink.nmhdr.code = EN_LINK;

    if(pfInLink)
        *pfInLink = TRUE;
    rg.Expander(tomLink, TRUE, NULL, &cpMin, &cpMost);

    // Fill in ENLINK data structure for our EN_LINK
    // callback asking client what we should do
    enlink.msg = msg;
    enlink.wParam = wparam;
    enlink.lParam = lparam;
    enlink.chrg.cpMin  = GetAcpFromCp(cpMin);
    enlink.chrg.cpMost = GetAcpFromCp(cpMost);

    return _phost->TxNotify(EN_LINK, &enlink) == S_FALSE;
}

/*
 *  CTxtEdit::QueryUseProtection(prg, msg, wparam, lparam)
 *
 *  @mfunc  sends EN_PROTECTED to the host, asking if we should continue
 *  to honor the protection on a given range of characters
 *
 *  @rdesc  TRUE if protection should be honored, FALSE otherwise
 */
BOOL CTxtEdit::QueryUseProtection(
    CTxtRange *prg,     //@parm range to check for
    UINT    msg,        //@parm msg used
    WPARAM  wparam,     //@parm wparam of the msg
    LPARAM  lparam)     //@parm lparam of the msg
{
    LONG        cpMin, cpMost;
    ENPROTECTED enp;
    BOOL        fRet = FALSE;
    CCallMgr *  pcallmgr = GetCallMgr();

    Assert(_dwEventMask & ENM_PROTECTED);

    if( pcallmgr->GetInProtected() ||
        _fSuppressNotify)       // Don't ask host if we don't want to send notification
        return FALSE;

    pcallmgr->SetInProtected(TRUE);

    ZeroMemory(&enp, sizeof(ENPROTECTED));

    prg->GetRange(cpMin, cpMost);

    enp.msg = msg;
    enp.wParam = wparam;
    enp.lParam = lparam;
    enp.chrg.cpMin  = GetAcpFromCp(cpMin);
    enp.chrg.cpMost = GetAcpFromCp(cpMost);

    if(_phost->TxNotify(EN_PROTECTED, &enp) == S_FALSE)
        fRet = TRUE;

    pcallmgr->SetInProtected(FALSE);

    return fRet;
}


#ifdef DEBUG
//This is a debug api used to dump the document runs.
//If a pointer to the ped is passed, it is saved and
//used.  If NULL is passed, the previously saved ped
//pointer is used.  This allows the "context" to be
//setup by a function that has access to the ped and
//DumpDoc can be called lower down in a function that
//does not have access to the ped.
extern "C" {
void DumpStory(void *ped)
{
    static CTxtEdit *pedSave = (CTxtEdit *)ped;
    if(pedSave)
    {
        CTxtStory * pStory = pedSave->GetTxtStory();
        if(pStory)
            pStory->DbgDumpStory();

        CObjectMgr * pobjmgr = pedSave->GetObjectMgr();
        if(pobjmgr)
            pobjmgr->DbgDump();
    }
}
}
#endif

/*
 *  CTxtEdit::TxGetDefaultCharFormat (pCF)
 *
 *  @mfunc  helper function to retrieve character formats from the
 *          host.  Does relevant argument checking
 *
 *  @rdesc  HRESULT
 */
HRESULT CTxtEdit::TxGetDefaultCharFormat(
    CCharFormat *pCF,       //@parm Character format to fill in
    DWORD &      dwMask)    //@parm Mask supplied by host or default
{
    HRESULT hr = pCF->InitDefault(0);
    dwMask = CFM_ALL2;

    const CHARFORMAT2 *pCF2 = NULL;

    if (_phost->TxGetCharFormat((const CHARFORMAT **)&pCF2) != NOERROR ||
        !IsValidCharFormatW(pCF2))
    {
        return hr;
    }

    dwMask  = pCF2->dwMask;
    DWORD dwMask2 = 0;
    if(pCF2->cbSize == sizeof(CHARFORMAT))
    {
        // Suppress CHARFORMAT2 specifications (except for Forms^3 disabled)
        dwMask  &= fInOurHost() ? CFM_ALL : (CFM_ALL | CFM_DISABLED);
        dwMask2 = CFM2_CHARFORMAT;
    }

    CCharFormat CF;                         // Transfer external CHARFORMAT(2)
    CF.Set(pCF2, 1200);                     //  parms to internal CCharFormat
    return pCF->Apply(&CF, dwMask, dwMask2);
}

/*
 *  CTxtEdit::TxGetDefaultParaFormat (pPF)
 *
 *  @mfunc  helper function to retrieve  paragraph formats.  Does
 *          the relevant argument checking.
 *
 *  @rdesc  HRESULT
 */
HRESULT CTxtEdit::TxGetDefaultParaFormat(
    CParaFormat *pPF)       //@parm Paragraph format to fill in
{
    HRESULT hr = pPF->InitDefault(0);

    const PARAFORMAT2 *pPF2 = NULL;

    if (_phost->TxGetParaFormat((const PARAFORMAT **)&pPF2) != NOERROR ||
        !IsValidParaFormat(pPF2))
    {
        return hr;
    }

    DWORD dwMask  = pPF2->dwMask;
    if(pPF2->cbSize == sizeof(PARAFORMAT))  // Suppress all but PARAFORMAT
    {                                       //  specifications
        dwMask &= PFM_ALL;
        dwMask |= PFM_PARAFORMAT;           // Tell Apply() that PARAFORMAT
    }                                       //  was used

    CParaFormat PF;                         // Transfer external PARAFORMAT(2)
    PF.Set(pPF2);                           //  parms to internal CParaFormat
    return pPF->Apply(&PF, dwMask);         // Apply parms identified by dwMask
}


/*
 *  CTxtEdit::SetContextDirection(fUseKbd)
 *
 *  @mfunc
 *      Determine the paragraph direction and/or alignment based on the context
 *      rules (direction/alignment follows first strong character in the
 *      control) and apply this direction and/or alignment to the default
 *      format.
 *
 *  @comment
 *      Context direction only works for plain text controls. Note that
 *      this routine only switches the default CParaFormat to RTL para if it
 *      finds an RTL char. IsBiDi() will automatically be TRUE for this case,
 *      since each char is checked before entering the backing store.
 */
void CTxtEdit::SetContextDirection(
    BOOL fUseKbd)       //@parm Use keyboard to set context when CTX_NEUTRAL
{
    // It turns out that Forms^3 can send EM_SETBIDIOPTIONS even for non BiDi controls.
    // AssertSz(IsBiDi(), "CTxtEdit::SetContextDirection called for nonBiDi control");
    if(IsRich() || !IsBiDi() || _nContextDir == CTX_NONE && _nContextAlign == CTX_NONE)
        return;

    LONG    cch = GetTextLength();
    CTxtPtr tp(this, 0);
    TCHAR   ch = tp.GetChar();
    WORD    ctx = CTX_NEUTRAL;
    BOOL    fChanged = FALSE;

    // Find first strongly directional character
    while (cch && !IsStrongDirectional(MECharClass(ch)))
    {
        ch = tp.NextChar();
        cch--;
    }

    // Set new context based on first strong character
    if(cch)
        ctx = IsRTL(MECharClass(ch)) ? CTX_RTL : CTX_LTR;

    // Has context direction or alignment changed?
    if (_nContextDir   != CTX_NONE && _nContextDir   != ctx ||
        _nContextAlign != CTX_NONE && _nContextAlign != ctx)
    {
        // Start with current default CParaFormat
        CParaFormat PF = *GetParaFormat(-1);

        // If direction has changed...
        if(_nContextDir != CTX_NONE && _nContextDir != ctx)
        {
            if(ctx == CTX_LTR || ctx == CTX_RTL || fUseKbd)
            {
                if (ctx == CTX_RTL ||
                    ctx == CTX_NEUTRAL && W32->IsBiDiLcid(LOWORD(GetKeyboardLayout(0))))
                {
                    PF._wEffects |= PFE_RTLPARA;
                }
                else
                {
                    Assert(ctx == CTX_LTR || ctx == CTX_NEUTRAL);
                    PF._wEffects &= ~PFE_RTLPARA;
                }
                fChanged = TRUE;
            }
            _nContextDir = ctx;
        }

        // If the alignment has changed...
        if(_nContextAlign != CTX_NONE && _nContextAlign != ctx)
        {
            if(PF._bAlignment != PFA_CENTER)
            {
                if(ctx == CTX_LTR || ctx == CTX_RTL || fUseKbd)
                {
                    if (ctx == CTX_RTL ||
                        ctx == CTX_NEUTRAL && W32->IsBiDiLcid(LOWORD(GetKeyboardLayout(0))))
                    {
                        PF._bAlignment = PFA_RIGHT;
                    }
                    else
                    {
                        Assert(ctx == CTX_LTR || ctx == CTX_NEUTRAL);
                        PF._bAlignment = PFA_LEFT;
                    }
                }
            }
            _nContextAlign = ctx;
        }

        // Modify default CParaFormat
        IParaFormatCache *pPFCache = GetParaFormatCache();
        LONG iPF;

        if(SUCCEEDED(pPFCache->Cache(&PF, &iPF)))
        {
            pPFCache->Release(Get_iPF());   // Release _iPF regardless of
            Set_iPF(iPF);                   // Update default format index

            if (fChanged)
                ItemizeDoc(NULL);

            // Refresh display
            Assert(_pdp);
            if(!_pdp->IsPrinter())
            {
                _pdp->InvalidateRecalc();
                TxInvalidateRect(NULL, FALSE);
            }
        }
    }

    // Reset the first strong cp.
    _cpFirstStrong = tp.GetCp();

    Assert(_nContextDir != CTX_NONE || _nContextAlign != CTX_NONE);
}

/*
 *  CTxtEdit::GetAdjustedTextLength ()
 *
 *  @mfunc
 *      retrieve text length adjusted for the default end-of-document marker
 *
 *  @rdesc
 *      Text length without final EOP
 *
 *  @devnote
 *      For Word and RichEdit compatibility, we insert a CR or CRLF at the
 *      end of every new rich-text control.  This routine calculates the
 *      length of the document _without_ this final EOD marker.
 *
 *      For 1.0 compatibility, we insert a CRLF.  However, TOM (and Word)
 *      requires that we use a CR, from 2.0 on, we do that instead.
 */
LONG CTxtEdit::GetAdjustedTextLength()
{
    LONG cchAdjText = GetTextLength();

    Assert(!Get10Mode() || IsRich());       // No RE10 plain-text controls

    if(IsRich())
        cchAdjText -= fUseCRLF() ? 2 : 1;   // Subtract cch of final EOP

    return cchAdjText;
}

/*
 *  CTxtEdit::Set10Mode()
 *
 *  @mfunc
 *      Turns on the 1.0 compatibility mode bit.  If the control is
 *      rich text, it already has a default 'CR' at the end, which
 *      needs to turn into a CRLF for compatibility with RichEdit 1.0.
 *
 *  @devnote
 *      This function should only be called _immediately_ after
 *      creation of text services and before all other work.  There
 *      are Asserts to help ensure this.  Remark (murrays): why not
 *      allow the change provided the control is empty except for the
 *      final CR?
 *
 *      FUTURE: we might want to split _f10Mode into three flags:
 *      1) _fMapCps     // API cp's are MBCS and need conversion to Unicode
 *      2) _fCRLF       // Use CRLFs for EOPs instead of CRs
 *      3) _f10Mode     // All other RE 1.0 compatibility things
 *
 *      Category 3 includes 1) automatically using FR_DOWN in searches,
 *      2) ignoring direction in CDataTransferObj::EnumFormatEtc(),
 *      3) not resetting _fModified when switching to a new doc,
 */
void CTxtEdit::Set10Mode()
{
    CCallMgr    callmgr(this);
    _f10Mode = TRUE;

    // Make sure nothing important has happened to the control.
    // If these values are non-NULL, then somebody is probably trying
    // to put us into 1.0 mode after we've already done work as
    // a 2.0 control.
    Assert(GetTextLength() == cchCR);
    Assert(_psel == NULL);
    Assert(_fModified == NULL);

    SetRichDocEndEOP(cchCR);

    if(!_pundo)
        CreateUndoMgr(1, US_UNDO);

    if(_pundo)
        ((CUndoStack *)_pundo)->EnableSingleLevelMode();

    // Turn off dual font
    _fDualFont = FALSE;

    // Turn on auto sizing for NTFE systems
    if (OnWinNTFE())
        _fAutoFontSizeAdjust = TRUE;
}

/*
 *  CTxtEdit::SetRichDocEndEOP(cchToReplace)
 *
 *  @mfunc  Place automatic EOP at end of a rich text document.
 */
void CTxtEdit::SetRichDocEndEOP(
    LONG cchToReplace)
{
    CRchTxtPtr rtp(this, 0);

    // Assume this is a 2.0 Doc
    LONG cchEOP = cchCR;
    const WCHAR *pszEOP = szCR;

    if(_f10Mode)
    {
        // Reset update values for a 1.0 doc
        cchEOP = cchCRLF;
        pszEOP = szCRLF;
    }

    rtp.ReplaceRange(cchToReplace, cchEOP, pszEOP, NULL, -1);

    _fModified = FALSE;
    _fSaved = TRUE;
    GetCallMgr()->ClearChangeEvent();
}

/*
 *  CTxtEdit::PopAndExecuteAntiEvent(pundomgr, void *pAE)
 *
 *  @mfunc  Freeze display and execute anti-event
 *
 *  @rdesc  HRESULT from IUndoMgr::PopAndExecuteAntiEvent
 */
HRESULT CTxtEdit::PopAndExecuteAntiEvent(
    IUndoMgr *pundomgr, //@parm Undo manager to direct call to
    void  *pAE)         //@parm AntiEvent for undo manager
{
    HRESULT hr;
    // Let stack based classes clean up before restoring selection
    {
        CFreezeDisplay fd(_pdp);
        CSelPhaseAdjuster   selpa(this);

        hr = pundomgr->PopAndExecuteAntiEvent(pAE);
    }

    if(_psel)
    {
        // Once undo/redo has been executed, flush insertion point formatting
        _psel->Update_iFormat(-1);
        _psel->Update(TRUE);
    }
    return hr;
}

/*
 *  CTxtEdit::PasteDataObjectToRange(pdo, prg, cf, rps, publdr, dwFlags)
 *
 *  @mfunc  Freeze display and paste object
 *
 *  @rdesc  HRESULT from IDataTransferEngine::PasteDataObjectToRange
 */
HRESULT CTxtEdit::PasteDataObjectToRange(
    IDataObject *   pdo,
    CTxtRange *     prg,
    CLIPFORMAT      cf,
    REPASTESPECIAL *rps,
    IUndoBuilder *  publdr,
    DWORD           dwFlags)
{
    HRESULT hr = _ldte.PasteDataObjectToRange(pdo, prg, cf, rps, publdr,
        dwFlags);

    if(_psel)
        _psel->Update(TRUE);           // now update the caret

    return hr;
}

/*
 *  GetECDefaultHeightAndWidth (pts, hdc, lZoomNumerator, lZoomDenominator,
 *                  yPixelsPerInch, pxAveWidth, pxOverhang, pxUnderhang)
 *
 *  @mfunc  Helper for host to get ave char width and height for default
 *          character set for the control.
 *
 *  @rdesc  Height of default character set
 *
 *  @devnote:
 *          This really only s/b called by the window's host.
 */
LONG GetECDefaultHeightAndWidth(
    ITextServices *pts,         //@parm ITextServices to conver to CTxtEdit.
    HDC hdc,                    //@parm DC to use for retrieving the font.
    LONG lZoomNumerator,        //@parm Zoom numerator
    LONG lZoomDenominator,      //@parm Zoom denominator
    LONG yPixelsPerInch,        //@parm Pixels per inch for hdc
    LONG *pxAveWidth,           //@parm Optional ave width of character
    LONG *pxOverhang,           //@parm Optional overhang
    LONG *pxUnderhang)          //@parm Optional underhang
{
    CLock lock;                 // Uses global (shared) FontCache
    // Convert the text-edit ptr
    CTxtEdit *ped = (CTxtEdit *) pts;

    // Get the CCcs that has all the information we need
    yPixelsPerInch = MulDiv(yPixelsPerInch, lZoomNumerator, lZoomDenominator);
    CCcs *pccs = fc().GetCcs(ped->GetCharFormat(-1), yPixelsPerInch);

    if(!pccs)
        return 0;

    if(pxAveWidth)
        *pxAveWidth = pccs->_xAveCharWidth;

    if(pxOverhang)
        *pxOverhang = pccs->_xOverhang;     // Return overhang

    if(pxUnderhang)
        *pxUnderhang = pccs->_xUnderhang;   // Return underhang

    SHORT   yAdjustFE = pccs->AdjustFEHeight(!ped->fUseUIFont() && ped->_pdp->IsMultiLine());
    LONG yHeight = pccs->_yHeight + (yAdjustFE << 1);

    pccs->Release();                        // Release the CCcs
    return yHeight;
}

/*
 *  CTxtEdit::TxScrollWindowEx (dx, dy, lprcScroll, lprcClip, hrgnUpdate,
 *                                  lprcUpdate, fuScroll)
 *  @mfunc
 *      Request Text Host to scroll the content of the specified client area
 *
 *  @comm
 *      This method is only valid when the control is in-place active;
 *      calls while inactive may fail.
 */
void CTxtEdit::TxScrollWindowEx (
    INT     dx,             //@parm Amount of horizontal scrolling
    INT     dy,             //@parm Amount of vertical scrolling
    LPCRECT lprcScroll,     //@parm Scroll rectangle
    LPCRECT lprcClip,       //@parm Clip rectangle
    HRGN    hrgnUpdate,     //@parm Handle of update region
    LPRECT  lprcUpdate,     //@parm Update rectangle
    UINT    fuScroll)       //@parm Scrolling flags
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEEXTERN, "CTxtEdit::TxScrollWindowEx");

    if(_fInPlaceActive)
    {
#if !defined(NOMAGELLAN)
        CMagellanBMPStateWrap bmpOff(*this, NULL);
#endif

        _phost->TxScrollWindowEx(dx, dy, lprcScroll, lprcClip,
                        hrgnUpdate, lprcUpdate, fuScroll);

        // Tell all objects that they may need to update their position
        // RECTs if scrolling occurred.

        if(_pobjmgr)
        {
            RECT rcClient;

            if(!lprcScroll)
            {
                TxGetClientRect(&rcClient);
                lprcScroll = &rcClient;
            }
            _pobjmgr->ScrollObjects(dx, dy, lprcScroll);
        }
    }
}

/*
 *  CTxtEdit::GetAcpFromCp (cp)
 *
 *  @mfunc
 *      Get API cp (acp) from Unicode cp in this text instance. The API cp
 *      may be Unicode, in which case it equals cp, or MBCS, in which case
 *      it's greater than cp if any Unicode characters preceding cp convert
 *      to double-byte characters.  An MBCS cp is the BYTE index of a character
 *      relative to the start of the story, while a Unicode cp is the character
 *      index.  The values are the same if all charsets are represented by
 *      SBCS charsets, e.g., ASCII.  If all characters are represented by
 *      double-byte characters, then acp = 2*cp.
 *
 *  @rdesc
 *      MBCS Acp from Unicode cp in this text instance
 *
 *  @devnote
 *      This could be made more efficient by having the selection maintain
 *      the acp that corresponds to its _rpTX._cp, provided RE 1.0 mode is
 *      active.  Alternatively CTxtEdit could have a _prg that tracks this
 *      value, but at a higher cost (17 DWORDs instead of 1 per instance).
 *
 *      FUTURE: we might want to have a conversion-mode state instead of just
 *      _f10Mode, since some people might want to know use MBCS cp's even in
 *      RE 3.0.  If so, use the corresponding new state flag instead of
 *      Get10Mode() in the following.
 */
LONG CTxtEdit::GetAcpFromCp(
    LONG cp,                //@parm Unicode cp to convert to MBCS cp
    BOOL fPrecise)          //@parm fPrecise flag to get byte count for MBCS
{
    if(!(IsFE() && (fCpMap() || fPrecise))) // RE 2.0 and higher use char-count
        return cp;                          //  cp's, while RE 1.0 uses byte
                                            //  counts
                                            //  bPrecise is for Ansi Apps that want byte counts
                                            //  (e.g. Outlook Subject line)

    CRchTxtPtr rtp(this);                   // Start at cp = 0
    return rtp.GetCachFromCch(cp);
}

LONG CTxtEdit::GetCpFromAcp(
    LONG acp,               //@parm MBCS cp to convert to Unicode cp
    BOOL fPrecise)          //@parm fPrecise flag to get Unicode cp for MBCS
{
    if( acp == -1 || !(IsFE() && (fCpMap() || fPrecise)))
        return acp;

    CRchTxtPtr rtp(this);                   // Start at cp = 0
    return rtp.GetCchFromCach(acp);
}


/*
 *  CTxtEdit::GetViewKind (plres)
 *
 *  @mfunc
 *      get view mode
 *
 *  @rdesc
 *      HRESULT = (plres) ? NOERROR : E_INVALIDARG
 *
 *  @devnote
 *      This could be a TOM property method (along with SetViewMode())
 */
HRESULT CTxtEdit::GetViewKind(
    LRESULT *plres)     //@parm Out parm to receive view mode
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetViewKind");

    if(!plres)
        return E_INVALIDARG;

    *plres = IsInOutlineView() ? VM_OUTLINE : VM_NORMAL;
    return NOERROR;
}

/*
 *  CTxtEdit::SetViewKind (Value)
 *
 *  @mfunc
 *      Turn outline mode on or off
 *
 *  @rdesc
 *      HRESULT = IsRich() ? NOERROR : S_FALSE
 *
 *  @devnote
 *      This could be a TOM property method (along with GetViewMode())
 */
HRESULT CTxtEdit::SetViewKind(
    long Value)     //@parm Turn outline mode on/off for Value nonzero/zero
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::SetViewKind");

    if(!IsRich() || !_pdp->IsMultiLine())
        return S_FALSE;

    Value = (Value == VM_OUTLINE);          // Convert to 1/0
    if(_fOutlineView != Value)
    {
        HCURSOR hcur = TxSetCursor(LoadCursor(0, IDC_WAIT), NULL);
        CTxtSelection *psel = GetSel();

        _fOutlineView = (WORD)Value;
        if(!GetAdjustedTextLength())        // No text in control: in outline
        {                                   //  view, use Heading 1; in normal
            CParaFormat PF;                 //  view, use Normal style
            PF._sStyle = (SHORT)(IsInOutlineView()
                      ? STYLE_HEADING_1 : STYLE_NORMAL);
            psel->SetParaStyle(&PF, NULL, PFM_STYLE);
        }
        else
        {
            // There is text. Make sure there is paragraph formatting.
            _psel->Check_rpPF();
        }

        psel->CheckIfSelHasEOP(-1, 0);
        _pdp->UpdateView();
        psel->Update(TRUE);
        TxSetCursor(hcur, NULL);
    }
    return NOERROR;
}

/*
 *  CTxtEdit::GetViewScale (pValue)
 *
 *  @mfunc
 *      get view zoom scale in percent
 *
 *  @rdesc
 *      HRESULT = (pValue) ? NOERROR : E_INVALIDARG
 *
 *  @devnote
 *      This could be a TOM property method (along with SetViewScale())
 */
HRESULT CTxtEdit::GetViewScale(
    long *pValue)       //@parm Get % zoom factor
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetViewScale");

    if(!pValue)
        return E_INVALIDARG;

    *pValue = 100;
    if(GetZoomNumerator() && GetZoomDenominator())
        *pValue = (100*GetZoomNumerator())/GetZoomDenominator();

    return NOERROR;
}

/*
 *  CTxtEdit::SetViewScale (Value)
 *
 *  @mfunc
 *      Set zoom numerator equal to the scale percentage Value and
 *      zoom denominator equal to 100
 *
 *  @rdesc
 *      NOERROR
 *
 *  @devnote
 *      This could be a TOM property method (along with GetViewScale())
 */
HRESULT CTxtEdit::SetViewScale(
    long Value)     //@parm Set view scale factor
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::SetViewScale");

    if((unsigned)Value > 2000)
        return E_INVALIDARG;

    SetZoomNumerator(Value);
    SetZoomDenominator(100);
    return NOERROR;
}

/*
 *  CTxtEdit::UpdateOutline()
 *
 *  @mfunc
 *      Update selection and screen after ExpandOutline() operation
 *
 *  @comm
 *      This method is only valid when the control is in-place active;
 *      calls while inactive may fail.
 */
HRESULT CTxtEdit::UpdateOutline()
{
    Assert(IsInOutlineView());

    GetSel()->Update(FALSE);
    TxInvalidateRect(NULL, TRUE);
    return NOERROR;
}

/*
 *  CTxtEdit::MoveSelection(lparam, publdr)
 *
 *  @mfunc
 *      Move selected text up/down by the number of paragraphs given by
 *      LOWORD(lparam).
 *
 *  @rdesc
 *      TRUE iff movement occurred
 */
HRESULT CTxtEdit::MoveSelection (
    LPARAM lparam,          //@parm # paragraphs to move by
    IUndoBuilder *publdr)   //@parm undo builder to receive antievents
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtRange::MoveSelection");

    CFreezeDisplay  fd(_pdp);
    CTxtSelection * psel = GetSel();
    LONG            cch;
    LONG            cchSel = psel->GetCch();
    LONG            cpMin, cpMost;
    LONG            cpSel = psel->GetCp();
    IDataObject *   pdo = NULL;
    CTxtRange       rg(*psel);
    LONG            cpNext = 0;
    LONG            cpCur = 0;
    BOOL            fDeleteCR = FALSE;

    if(publdr)
        publdr->StopGroupTyping();

    rg.Expander(tomParagraph, TRUE, NULL, &cpMin, &cpMost);
    CPFRunPtr rp(rg);
    cch = rp.FindExpanded();            // Include subordinate paras
    if(cch < 0)
        cch = tomForward;
    rg.SetExtend(TRUE);
    rg.Advance(cch);
    cpMost = rg.GetCpMost();

    if(lparam > 0 && cpMost == GetTextLength())
    {
        Beep();                         // Already at end
        return S_FALSE;
    }

    HRESULT hr = _ldte.RangeToDataObject(&rg, SF_RTF, &pdo);
    if(hr != NOERROR)
        goto error;

    if(lparam > 0)
        psel->EndOf(tomParagraph, FALSE, NULL);
    else
        psel->StartOf(tomParagraph, FALSE, NULL);

    cpCur = psel->GetCp();
    hr = psel->Move(tomParagraph, lparam, NULL);
    if(psel->GetCp() == cpCur)
    {
        psel->Set(cpSel, cchSel);
        Beep();
        goto error;
    }

    // Since psel->Move() calls psel->Update(), the selection is forced
    // to be in noncollapsed text. Going backward, this might leave the
    // selection just before the EOP of a paragraph, instead of being at the
    // start of the paragraph where it should be.  Going forward it may have
    // tried to reach the EOD, but was adjusted backward. This case gets
    // a bit awkward...
    if(psel->GetCp() < cpCur)                   // Going backward: be sure
        psel->StartOf(tomParagraph, FALSE, NULL);//  end up at start of para

    else if(!psel->_rpTX.IsAfterEOP())          // Going forward and sel
    {                                           //  adjusted backward
        psel->SetExtend(FALSE);
        psel->Advance(tomForward);              // Go to final CR, insert a CR
        CTxtRange rgDel(*psel);                 //  use psel because UI
        rgDel.ReplaceRange(1, szCR, publdr, SELRR_REMEMBERRANGE);
        psel->Advance(1);
        fDeleteCR = TRUE;                       // Remember to delete it
    }

    cpCur = psel->GetCp();
    hr = _ldte.PasteDataObjectToRange(pdo, psel, 0, NULL,
                                      publdr, PDOR_NONE);
    if(hr != NOERROR)
        goto error;

    if(fDeleteCR)                               // Delete CR (final CR becomes
    {                                           //  CR for this para). Don't
        CTxtRange rgDel(*psel);                 //  use psel because UI
        Assert(rgDel._rpTX.IsAfterEOP());       //  restricts it's ability to
        rgDel.Delete(tomCharacter, -1, &cch);   //  delete
    }

    cpNext = psel->GetCp();
    psel->Set(cpCur, 0);
    psel->CheckOutlineLevel(publdr);
    psel->Set(cpNext, 0);
    psel->CheckOutlineLevel(publdr);

    // Now set selection anti-events. If selection preceded paste point,
    // subtract its length from redo position, since selection will get
    // deleted if we are doing a DRAGMOVE within this instance.
    cch = cpMost - cpMin;                       // cch of rg
    if(cpSel < cpCur)
        cpNext -= cch;

    psel->Set(psel->GetCp() + fDeleteCR, cch);  // Include final CR

    // rg.ReplaceRange won't delete final CR, so remember if it's included
    fDeleteCR = rg.GetCpMost() == GetTextLength();
    rg.ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE);

    if(fDeleteCR)                               // Needed to delete final CR
        rg.DeleteTerminatingEOP(publdr);        // Delete one immediately
                                                //  before it instead
    rg.CheckOutlineLevel(publdr);
    if(publdr)
    {
        HandleSelectionAEInfo(this, publdr, cpSel, cchSel, cpNext, cch,
                              SELAE_FORCEREPLACE);
    }
    hr = NOERROR;

error:
    if(pdo)
        pdo->Release();
    return hr;
}

/*
 *  CTxtEdit::SetReleaseHost
 *
 *  @mfunc  Handles notification that edit control must keep its
 *          reference to the host alive.
 *
 *  @rdesc  None.
 */
void CTxtEdit::SetReleaseHost()
{
    _phost->AddRef();
    _fReleaseHost = TRUE;
}

#if !defined(NOMAGELLAN)
/*
 *  CTxtEdit::HandleMouseWheel(wparam, lparam)
 *
 *  @mfunc  Handles scrolling as a result of rotating a mouse roller wheel.
 *
 *  @rdesc  LRESULT
 */
LRESULT CTxtEdit::HandleMouseWheel(
    WPARAM wparam,
    LPARAM lparam)
{
    // This bit of global state is OK
    static LONG gcWheelDelta = 0;
    short zdelta = (short)HIWORD(wparam);
    BOOL fScrollByPages = FALSE;

    // Cancel middle mouse scrolling if it's going.
    OnTxMButtonUp(0, 0, 0);

    // Handle zoom or data zoom
    if((wparam & MK_CONTROL) == MK_CONTROL)
    {
        // bug fix 5760
        // prevent zooming if control is NOT rich or
        // is a single line control
        if (!_pdp->IsMultiLine())
            return 0;

        LONG lViewScale;
        GetViewScale(&lViewScale);
        lViewScale += (zdelta/WHEEL_DELTA) * 10;    // 10% per click
        if(lViewScale <= 500 && lViewScale >= 10)   // Word's limits
        {
            SetViewScale(lViewScale);
            _pdp->UpdateView();
        }
        return 0;
    }

    if(wparam & (MK_SHIFT | MK_CONTROL))
        return 0;

    gcWheelDelta += zdelta;

    if(abs(gcWheelDelta) >= WHEEL_DELTA)
    {
        LONG cLineScroll = W32->GetRollerLineScrollCount();
        if(cLineScroll != -1)
            cLineScroll *= abs(gcWheelDelta)/WHEEL_DELTA;

        gcWheelDelta %= WHEEL_DELTA;

        // -1 means scroll by pages; so simply call page up/down.
        if(cLineScroll == -1)
        {
            fScrollByPages = TRUE;
            if(_pdp)
                _pdp->VScroll(zdelta < 0 ? SB_PAGEDOWN : SB_PAGEUP, 0);
        }
        else
        {
            mouse.MagellanRollScroll(_pdp, zdelta, cLineScroll,
                SMOOTH_ROLL_NUM, SMOOTH_ROLL_DENOM, TRUE);
        }

        // notify through the messagefilter that we scrolled
        if(_dwEventMask & ENM_SCROLLEVENTS)
        {
            MSGFILTER msgfltr;
            ZeroMemory(&msgfltr, sizeof(MSGFILTER));
            msgfltr.msg    = WM_VSCROLL;
            msgfltr.wParam = fScrollByPages ?
                                (zdelta < 0 ? SB_PAGEDOWN: SB_PAGEUP):
                                (zdelta < 0 ? SB_LINEDOWN: SB_LINEUP);

            // We don't check the result of this call --
            // it's not a message we received and we're not going to
            // process it any further
            _phost->TxNotify(EN_MSGFILTER, &msgfltr);
        }
        return TRUE;
    }
    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\format.cpp ===
/*
 *	@doc	INTERNAL
 *	
 *	@module - FORMAT.C
 *		CCharFormatArray and CParaFormatArray classes |
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_format.h"


ASSERTDATA

// ===============================  CFixArrayBase  =================================


CFixArrayBase::CFixArrayBase(
	LONG cbElem)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::CFixArrayBase");
	
	_prgel = NULL; 
	_cel = 0; 
	_ielFirstFree = 0; 
	_cbElem = cbElem + sizeof(LONG_PTR);		// Use LONG_PTR to get proper alignment on Win64
}

/*
 *	CFixArrayBase::Add()
 *
 *	@mfunc	
 *		Return index of new element, reallocing if necessary
 *
 *	@rdesc
 *		Index of new element.
 *
 *	@comm
 *		Free elements are maintained in place as a linked list indexed
 *		by a chain of ref-count entries with their sign bits set and the
 *		rest of the entry giving the index of the next element on the
 *		free list.  The list is terminated by a 0 entry. This approach
 *		enables element 0 to be on the free list.
 */
LONG CFixArrayBase::Add()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::Add");

	char *pel;
	LONG iel, ielRet;

	if(_ielFirstFree)					// Return first element of free list
	{
		ielRet = _ielFirstFree & ~FLBIT;
		_ielFirstFree = RefCount(ielRet);
	}
	else								// All lower positions taken: need 
	{									//  to add another celGrow elements
		pel = (char*)PvReAlloc(_prgel, (_cel + celGrow) * _cbElem);
		if(!pel)
			return -1;

		// Clear out the *end* of the newly allocated memory
		ZeroMemory(pel + _cel*_cbElem, celGrow*_cbElem);

		_prgel = pel;

		ielRet = _cel;					// Return first one added 
		iel = _cel + 1;
		_cel += celGrow;

		// Add elements _cel+1 thru _cel+celGrow-1 to free list. The last
		// of these retains a 0, stored by fZeroFill in Alloc
		_ielFirstFree = iel | FLBIT;

		for(pel = (char *)&RefCount(iel);
			++iel < _cel;
			pel += _cbElem)
		{
			*(INT *)pel = iel | FLBIT;
		}
	}		
	return ielRet;
}

void CFixArrayBase::Free(
	LONG iel)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::Free(iel)");

	// Simply add it to free list
	RefCount(iel) = _ielFirstFree;
	_ielFirstFree = iel | FLBIT;
}

void CFixArrayBase::Free()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::Free()");

#ifdef DEBUG
	// Only do this validation if all the ped's are gone. Visual basic shutsdown apps
	// without freeing all the resources so this safety check is necessary.
	if (0 == W32->GetRefs())
	{
		// Display MessageBox if any CCharFormats, CParaFormats, or CTabs have
		// reference counts > 0.  This only happens if an error has occurred.
		BOOL fComplained = FALSE;
		for(LONG iel = 0; iel < Count(); iel++)
		{
			while(RefCount(iel) > 0)
			{
				if (!fComplained)
				{
					fComplained = TRUE;
					AssertSz(FALSE, _cbElem == sizeof(CCharFormat) + sizeof(LONG_PTR) ? "CCharFormat not free" :
								 _cbElem == sizeof(CParaFormat) + sizeof(LONG_PTR) ? "CParaFormat not free" :
									 "CTabs not free");
				}

				Release(iel);
			}
		}
	}
#endif
	FreePv(_prgel);
	_prgel = NULL;
	_cel = 0;
	_ielFirstFree = 0;
}

HRESULT CFixArrayBase::Deref(
	LONG iel,
	const void **ppel) const
{
	Assert(ppel);
	AssertSz(iel >= 0,
		"CFixArrayBase::Deref: bad element index" );
	AssertSz(*(LONG *)(_prgel + (iel + 1) * _cbElem - 4) > 0,
		"CFixArrayBase::Deref: element index has bad ref count");

	if(!ppel)
		return E_INVALIDARG;

	*ppel = Elem(iel);
	return S_OK;
}

/*
 *	CFixArrayBase::RefCount(iel)
 *
 *	@mfunc
 *		The reference count for an element is stored as a LONG immediately
 *		following the element in the CFixArray. If the element isn't used
 *		i.e., is free, then the reference count is used as a link to the
 *		next free element.  The last free element in this list has a 0
 *		"reference count", which terminates the list.
 *
 *		The ref count follows the element instead of preceding it because
 *		this allows Elem(iel) to avoid an extra addition.  Elem() is used
 *		widely in the code.
 *
 *	@rdesc
 *		Ptr to reference count
 */
LONG & CFixArrayBase::RefCount(
	LONG iel)
{
	Assert(iel < Count());
	return (LONG &)(*(_prgel + (iel + 1) * _cbElem - 4));
}

LONG CFixArrayBase::Release(
	LONG iel)
{
	LONG  cRef = -1;

	if(iel >= 0)							// Ignore default iel
	{
		CLock lock;
		CheckFreeChain();
		AssertSz(RefCount(iel) > 0, "CFixArrayBase::Release(): already free");

		cRef = --RefCount(iel); 
		if(!cRef)							// Entry no longer referenced
			Free(iel);						// Add it to the free chain
	}
	return cRef;
}

LONG CFixArrayBase::AddRef(
	LONG iel)
{
	LONG  cRef = -1;

	if(iel >= 0)
	{
		CLock lock;
		CheckFreeChain();
    	AssertSz(RefCount(iel) > 0, "CFixArrayBase::AddRef(): add ref to free elem");
		cRef = ++RefCount(iel);
	}
	return cRef;
}

LONG CFixArrayBase::Find(
	const void *pel)
{
	CheckFreeChain();
	
	for(LONG iel = 0; iel < Count(); iel++)
	{
		// RefCount < 0 means entry not in use and is index of next free entry.
		// RefCount = 0 marks last free element in list.  _cbElem = sizeof(ELEM)
		// plus sizeof(RefCount), which is a LONG.
		if (RefCount(iel) > 0 &&
			!CompareMemory(Elem(iel), pel, _cbElem - sizeof(LONG_PTR)))
		{
			return iel;
		}
	}
	return -1;
}

HRESULT CFixArrayBase::Cache(
	const void *pel,
	LONG *		piel)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::Cache");

	CLock	lock;
	LONG	iel = Find(pel);

	if(iel >= 0)
		RefCount(iel)++;
	else
	{	
		iel = Add();
		if(iel < 0)
			return E_OUTOFMEMORY;
		CopyMemory(Elem(iel), pel, _cbElem - sizeof(LONG_PTR));
		RefCount(iel) = 1;
	}

	CheckFreeChain();
	
	if(piel)
		*piel = iel;
	
	return S_OK;
}

#ifdef DEBUG

void CFixArrayBase::CheckFreeChainFn(
	LPSTR	szFile,
	INT		nLine)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::CheckFreeChainFn");

	LONG cel = 0;
	LONG iel = _ielFirstFree;
	LONG ielT;

	while(iel)
	{
		Assert(iel < 0);
		ielT = RefCount(iel & ~FLBIT);

		if((LONG)(ielT & ~FLBIT) > _cel)
			Tracef(TRCSEVERR, "AttCheckFreeChainCF(): elem %ld points to out of range elem %ld", iel, ielT);

		iel = ielT;
		if(++cel > _cel)
		{
			AssertSzFn("CFixArrayBase::CheckFreeChain() - CF free chain seems to contain an infinite loop", szFile, nLine);
			return;
		}
	}
}

#endif


// ===========================  CCharFormatArray  ===========================================

HRESULT CCharFormatArray::Deref(
	LONG iCF,
	const CCharFormat **ppCF) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::Deref");

	return CFixArrayBase::Deref(iCF, (const void **)ppCF);
}

LONG CCharFormatArray::Release(
	LONG iCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::ReleaseFormat");

	return CFixArrayBase::Release(iCF);
}

LONG CCharFormatArray::AddRef(
	LONG iCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::AddRefFormat");

	return CFixArrayBase::AddRef(iCF);
}

void CCharFormatArray::Destroy()
{
	delete this;
}

LONG CCharFormatArray::Find(
	const CCharFormat *pCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::Find");

	LONG iCF;

	#define QUICKCRCSEARCHSIZE	15	// Must be 2^n - 1 for quick MOD
									//  operation, it is a simple hash.
 	static struct {
		BYTE	bCRC;
		LONG	iCF;
	} quickCrcSearch[QUICKCRCSEARCHSIZE+1];
 	BYTE	bCRC;
	WORD	hashKey;

	CheckFreeChain();

	// Check our cache before going sequential
	bCRC = (BYTE)pCF->_iFont;
	hashKey = (WORD)(bCRC & QUICKCRCSEARCHSIZE);
	if(bCRC == quickCrcSearch[hashKey].bCRC)
	{
		iCF = quickCrcSearch[hashKey].iCF - 1;
		if (iCF >= 0 && iCF < Count() && RefCount(iCF) > 0 &&
			!CompareMemory(Elem(iCF), pCF, sizeof(CCharFormat)))
		{
			return iCF;
		}
	}

	for(iCF = 0; iCF < Count(); iCF++)
	{
		if(RefCount(iCF) > 0 && !CompareMemory(Elem(iCF), pCF, sizeof(CCharFormat)))
		{
			quickCrcSearch[hashKey].bCRC = bCRC;
			quickCrcSearch[hashKey].iCF = iCF + 1;
			return iCF;
		}
	}
	return -1;
}

HRESULT CCharFormatArray::Cache(
	const CCharFormat *pCF,
	LONG* piCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::Cache");

	CLock lock;
	LONG  iCF = Find(pCF);

	if(iCF >= 0)
		RefCount(iCF)++;
	else
	{
		iCF = Add();
		if(iCF < 0)
			return E_OUTOFMEMORY;
		*Elem(iCF) = *pCF;			// Set entry iCF to *pCF
		RefCount(iCF) = 1;
	}					 

	CheckFreeChain();
	
	if(piCF)
		*piCF = iCF;

	return S_OK;
}


// ===============================  CParaFormatArray  ===========================================

HRESULT CParaFormatArray::Deref(
	LONG iPF,
	const CParaFormat **ppPF) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::Deref");

	return CFixArrayBase::Deref(iPF, (const void **)ppPF);
}

LONG CParaFormatArray::Release(
	LONG iPF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::ReleaseFormat");

	CLock lock;
	LONG  cRef = CFixArrayBase::Release(iPF);

#ifdef TABS
	if(!cRef)
		GetTabsCache()->Release(Elem(iPF)->_iTabs);
#endif
	return cRef;
}

LONG CParaFormatArray::AddRef(
	LONG iPF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::AddRefFormat");

	return CFixArrayBase::AddRef(iPF);
}

void CParaFormatArray::Destroy()
{
	delete this;
}

HRESULT CParaFormatArray::Cache(
	const CParaFormat *pPF,
	LONG *piPF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::Cache");

	HRESULT hr = CFixArrayBase::Cache((const void *)pPF, piPF);
#ifdef TABS
	if(hr == NOERROR && RefCount(*piPF) == 1)
		GetTabsCache()->AddRef(pPF->_iTabs);
#endif
	return hr;
}


// ===============================  CTabsArray  ===========================================

CTabsArray::~CTabsArray()
{
	for(LONG iTabs = 0; iTabs < Count(); iTabs++)
	{
		// It shouldn't be necessary to release any tabs, since when all
		// controls are gone, no reference counts should be > 0.
		while(RefCount(iTabs) > 0)
		{
#ifdef DEBUG
			// Only do this validation if all the ped's are gone. Visual basic shutsdown apps
			// without freeing all the resources so this safety check is necessary.
			AssertSz(0 != W32->GetRefs(), "CTabs not free");
#endif
			Release(iTabs);
		}
	}
}

const LONG *CTabsArray::Deref(
	LONG iTabs) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::Deref");

	return iTabs >= 0 ? Elem(iTabs)->_prgxTabs : NULL;
}

LONG CTabsArray::Release(
	LONG iTabs)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::Release");

	LONG cRef = CFixArrayBase::Release(iTabs);
	if(!cRef)
		FreePv(Elem(iTabs)->_prgxTabs);
	return cRef;
}

LONG CTabsArray::AddRef(
	LONG iTabs)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::AddRef");

	return CFixArrayBase::AddRef(iTabs);
}

LONG CTabsArray::Find(
	const LONG *prgxTabs,
	LONG		cTab)
{
	CheckFreeChain();

	CTabs *pTab;
	
	for(LONG iel = 0; iel < Count(); iel++)
	{
		// RefCount < 0 means entry not in use and is index of next free entry.
		// RefCount = 0 marks last free element in list.  _cbElem = sizeof(ELEM)
		// plus sizeof(RefCount), which is a LONG.
		if(RefCount(iel) > 0)
		{
			pTab = Elem(iel);
			if (pTab->_cTab == cTab &&
				!CompareMemory(pTab->_prgxTabs, prgxTabs, cTab*sizeof(LONG)))
			{
				return iel;
			}
		}
	}
	return -1;
}

LONG CTabsArray::Cache(
	const LONG *prgxTabs,
	LONG		cTab)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::Cache");

	if(!cTab)
		return -1;						// No tabs defined: use default

	CLock	lock;
	LONG	iTabs = Find(prgxTabs, cTab);

	if(iTabs >= 0)
		RefCount(iTabs)++;
	else
	{
		iTabs = Add();
		if(iTabs < 0)					// Out of memory: use default
			return -1;

		CTabs *pTabs = Elem(iTabs);
		LONG   cb = sizeof(LONG)*cTab;

		pTabs->_prgxTabs = (LONG *)PvAlloc(cb, GMEM_FIXED);
		if(!pTabs->_prgxTabs)
			return -1;					// Out of memory: use default
		CopyMemory(pTabs->_prgxTabs, prgxTabs, cb);
		pTabs->_cTab = cTab;
		RefCount(iTabs) = 1;
	}					 
	return iTabs;
}


// ==================================  Factories  ===========================================

static ICharFormatCache *pCFCache = NULL;		// CCharFormat cache
static IParaFormatCache *pPFCache = NULL;	 	// CParaFormat cache
static CTabsArray *	   pTabsCache = NULL;	 	// CTabs cache

ICharFormatCache *GetCharFormatCache()
{
	return pCFCache;
}

IParaFormatCache *GetParaFormatCache()
{
	return pPFCache;
}

CTabsArray *GetTabsCache()
{
	return pTabsCache;
}

HRESULT CreateFormatCaches()					// Called by DllMain()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CreateFormatCaches");
	CLock	lock;

	pCFCache = new CCharFormatArray();
	if(!pCFCache)
		return E_OUTOFMEMORY;
     
    pPFCache = new CParaFormatArray();
	if(!pPFCache)
	{
		delete pCFCache;
		return E_OUTOFMEMORY;
	}

    pTabsCache = new CTabsArray();
	if(!pTabsCache)
	{
		delete pCFCache;
		delete pPFCache;
		return E_OUTOFMEMORY;
	}
	return S_OK;
}

HRESULT DestroyFormatCaches()					// Called by DllMain()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "DeleteFormatCaches");

	if (pCFCache)
		pCFCache->Destroy();
	if (pPFCache)
		pPFCache->Destroy();
	if (pTabsCache)
		delete pTabsCache;
	return NOERROR;
}

/*
 *	ReleaseFormats(iCF, iPF)
 *
 *	@mfunc
 *		Release char and para formats corresponding to the indices <p iCF>
 *		and <p iPF>, respectively
 */
void ReleaseFormats (
	LONG iCF,			//@parm CCharFormat index for releasing
	LONG iPF)			//@parm CParaFormat index for releasing
{
	AssertSz(pCFCache && pPFCache,
		"ReleaseFormats: uninitialized format caches");
	if (iCF != -1)
		pCFCache->Release(iCF);
	if (iPF != -1)
		pPFCache->Release(iPF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\frunptr.cpp ===
/*
 *  @doc    INTERNAL
 *
 *  @module FRUNPTR.C -- FormatRunPtr methods |
 *
 *      common code to handle character and paragraph format runs
 *  
 *  Original Authors: <nl>
 *      Original RichEdit 1.0 code: David R. Fulmer <nl>
 *      Christian Fortini <nl>
 *      Murray Sargent <nl>
 *
 *  History:
 *      6/25/95     alexgo  convert to use Auto-Doc and simplified backing
 *      store model
 *
 *  @devnote
 *      BOR and EOR mean Beginning Of Run and End Of Run, respectively
 *
 *  Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_frunptr.h"
#include "_rtext.h"
#include "_font.h"

ASSERTDATA

//
//  Invariant stuff
//
#define DEBUG_CLASSNAME CFormatRunPtr

#include "_invar.h"

#ifdef DEBUG
/*
 *  CFormatRunPtr::Invariant
 *
 *  @mfunc  Invariant for format run pointers
 *
 *  @rdesc  BOOL
 */
BOOL CFormatRunPtr::Invariant() const
{
    if(IsValid())
    {
        CFormatRun *prun = GetRun(0);
        if(prun && _iRun)
        {
            Assert(prun->_cch > 0);
        }
    }
    else
    {
        Assert(_ich == 0);
    }
    return CRunPtrBase::Invariant();
}
#endif

/*
 *  CFormatRunPtr::InitRuns(ich, cch, iFormat, ppfrs)
 *
 *  @mfunc
 *      Setup this format run ptr for rich-text operation, namely,
 *      allocate CArray<lt>CFormatRun<gt> if not allocated, assign it to this
 *      run ptr's _pRuns, add initial run if no runs are present, and store
 *      initial cch and ich
 *  
 *  @rdesc
 *      TRUE if succeeds
 */
BOOL CFormatRunPtr::InitRuns(
    LONG ich,               //@parm # chars in initial run
    LONG cch,               //@parm char offset in initial run
    CFormatRuns **ppfrs)    //@parm ptr to CFormatRuns ptr
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::InitRuns");

    _TEST_INVARIANT_

    AssertSz( ppfrs,
        "FRP::InitRuns: illegal ptr to runs");
    AssertSz( !IsValid(),
        "FRP::InitRuns: ptr already valid");

    if(!*ppfrs)                                 // Allocate format runs
    {
        _pRuns = (CRunArray *) new CFormatRuns();
        if(!_pRuns)
            goto NoRAM;
        *ppfrs = (CFormatRuns *)_pRuns;
    }
    else                                        // Format runs already alloc'd
        _pRuns = (CRunArray *)*ppfrs;           // Cache ptr to runs

    if(!Count())                                // No runs yet, so add one
    {
        CFormatRun *pRun= Add(1, NULL);
        if(!pRun)
            goto NoRAM;

#ifdef DEBUG
        PvSet(*(void**)_pRuns);
#endif
        _ich            = ich;

        ZeroMemory(pRun, sizeof(*pRun));
        pRun->_cch      = cch;                  // Define its _cch
        pRun->_iFormat  = -1;                   //  and _iFormat
    }
    else
        BindToCp(ich);                          // Format runs are in place

    return TRUE;

NoRAM:
    TRACEERRSZSC("CFormatRunPtr::InitRuns: Out Of RAM", E_OUTOFMEMORY);
    return FALSE;
}


/*
 *  CFormatRunPtr::Delete(cch, pf, cchMove)
 *  
 *  @mfunc
 *      Delete/modify runs starting at this run ptr up to cch chars. <nl>
 *      There are 7 possibilities: <nl>
 *      1.  cch comes out of this run with count left over, i.e.,
 *          cch <lt>= (*this)->_cch - _ich && (*this)->_cch > cch
 *          (simple: no runs deleted/merged, just subtract cch) <nl>
 *      2.  cch comes out of this run and empties run and doc
 *          (simple: no runs left to delete/merge) <nl>
 *      3.  cch comes out of this run and empties run, which is last
 *          (need to delete run, no merge possibility) <nl>
 *      4.  cch comes out of this run and empties run, which is first
 *          (need to delete run, no merge possibility) <nl>
 *      5.  cch exceeds count available in this run and this run is last
 *          (simple: treat as 3.)  <nl>
 *      6.  cch comes out of this run and empties run with runs before
 *          and after (need to delete run; merge possibility) <nl>
 *      7.  cch comes partly out of this run and partly out of later run(s)
 *          (may need to delete and merge) <nl>
 *
 *  @comm
 *      PARAFORMATs have two special cases that use the cchMove argument set
 *      up in CRchTxtPtr::ReplaceRange().
 */
void CFormatRunPtr::Delete(
    LONG          cch,          //@parm # chars to modify format runs for
    IFormatCache *pf,           //@parm IFormatCache ptr for ReleaseFormat
    LONG          cchMove)      //@parm cch to move between runs (always 0 for CF)
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::Delete");

    _TEST_INVARIANT_

    // We should not have any boundary cases for empty or NULL pointers.
    // (i.e. if there's no text, then nobody should be calling delete).

    Assert(IsValid());

    LONG            cchEnd = 0;             // Probably unnecessary: see below
    LONG            cRun = 1;
    BOOL            fLast = (_iRun == Count() - 1);
    LONG            ifmtEnd, ifmtStart;
    CFormatRun *    pRun = Elem(_iRun);
    CFormatRun *    pRunRp;
    LONG            cchChunk = pRun->_cch - _ich;
    CFormatRunPtr   rp(*this);              // Clone this run ptr
    CBiDiLevel      levelStart = {0,0};
    CBiDiLevel      levelEnd = {0,0};

    rp.AdjustBackward();                    // If at BOR, move to prev EOR
    ifmtStart = rp.GetRun(0)->_iFormat;     // to get start format
    levelStart = rp.GetRun(0)->_level;      // and level
    rp = *this;                             // In case RpAdjustCp() backed up

// Process deletes confined to this run first, since their logic tends to
// clutter up other cases

    AssertSz(cch >= 0, "FRP::Delete: cch < 0");

    if(fLast)                               // Handle oversized cch on last
        cch = min(cch, cchChunk);           //  run here

    if(cch <= cchChunk)                     // cch comes out of this run
    {
        pRun->_cch -= cch;
        Assert(pRun->_cch >= 0);
        if(cchMove)                         // If nonzero here, we are
        {                                   //  deleting EOP at end of run
            rp.AdjustForward();             // Adjust rp to beginning of
            goto move;                      //  next run and go move cchMove
        }                                   //  chars back into this run
        if(pRun->_cch)                      // Something left in run: done
            return;
                                            // Note: _ich = 0
        if(!_iRun || fLast)                 // This run is either first
        {                                   //  or last
            AdjustBackward();               // If last, go to prev EOR
            if(_ich)                        // This run is empty so delete
                cRun++;                     // Compensate for cRun-- coming up
            ifmtStart = -2;                 // No runs eligible for merging
        }                                   //  so use unmatchable ifmtStart
        rp.NextRun();                       // Set up to get next _iFormat
    }       
    else
    {
        rp.AdvanceCp(cch);                  // Move clone to end of delete
        pRunRp = rp.GetRun(0);
        cRun = rp._iRun - _iRun             // If at EOR, then need to add
             + (rp._ich == pRunRp->_cch);   //  one more run to delete
        pRun->_cch = _ich;                  // Shorten this run to _ich chars
        pRunRp->_cch -= rp._ich;            // Shorten last run by rp._ich
        rp._ich = 0;

        Assert(pRunRp->_cch >= 0);
        AssertSz(cRun > 0, "FRP: bogus runptr");

        if(!_iRun)                          // First run?
            ifmtStart = -2;                 // Then we cannot merge runs so
    }                                       //  set to unmergable format

    ifmtEnd = -3;                           // Default invalid format at end
    if(rp.IsValid())
    {
        // FUTURE (murrays): probably rp is always valid here now and
        // pRun->_cch is nonzero
        pRun = rp.GetRun(0);
        if (pRun->_cch)                     // run not empty
        {
            ifmtEnd = pRun->_iFormat;       // Remember end format and count
            levelEnd = pRun->_level;
            cchEnd  = pRun->_cch;           //  in case of merge
        }
        else if(rp._iRun != rp.Count() - 1) // run not last
        {
            pRun = rp.GetRun(1);
            ifmtEnd = pRun->_iFormat;       // Remember end format and count
            levelEnd = pRun->_level;
            cchEnd  = pRun->_cch;           //  in case of merge
        }
    }

    rp = *this;                             // Default to delete this run
    if(_ich)                                // There are chars in this run
    {
        if(cchMove + _ich == 0)             // Need to combine all chars of
        {                                   //  this run with run after del,
            pf->AddRef(ifmtEnd);            //  so setup merge below using
            ifmtStart = ifmtEnd;            //  ifmtEnd. This run then takes
            pf->Release(GetRun(0)->_iFormat);
            GetRun(0)->_iFormat = ifmtEnd;  //  place of run after del.
            GetRun(0)->_level = levelEnd;
            cchMove = 0;                    // cchMove all accounted for
        }
        rp.NextRun();                       // Don't delete this run; start
        cRun--;                             //  with next one
    }

    AdjustBackward();                       // If !_ich, go to prev EOR

    if(ifmtEnd >=0 &&                       // Same formats: merge runs
       ifmtEnd == ifmtStart &&
       levelStart == levelEnd)
    {
        GetRun(0)->_cch += cchEnd;          // Add last-run cch to this one's
        Assert(GetRun(0)->_cch >= 0);
        cRun++;                             // Setup to eat last run
    }

    if(cRun > 0)                            // There are run(s) to delete
    {
        rp.Remove(cRun, pf);
        if(!Count())                        // If no more runs, keep this rp
            _ich = _iRun = 0;               //  valid by pointing at cp = 0
    }

move:
    if(cchMove)                             // Need to move some cch between
    {                                       //  this run and next (See
        GetRun(0)->_cch += cchMove;         //  CRchTxtPtr::ReplaceRange())
        rp.GetRun(0)->_cch -= cchMove;

        Assert(GetRun(0)->_cch >= 0);
        Assert(rp.GetRun(0)->_cch >= 0);
        Assert(_iRun < rp._iRun);

        if(!rp.GetRun(0)->_cch)             // If all chars moved out of rp's
            rp.Remove(1, pf);               //  run, delete it

        if(cchMove < 0)                     // Moved -cchMove chars from this
        {                                   //  run to next
            if(!GetRun(0)->_cch)
                Remove(1, pf);
            else
                _iRun++;                    // Keep this run ptr in sync with

            _ich = -cchMove;                //  cp (can't use NextRun() due
        }                                   //  to Invariants)
    }
    AdjustForward();                        // Don't leave ptr at EOR unless
}                                           //  there are no more runs

/*
 *  CFormatRunPtr::InsertFormat(cch, ifmt, pf)
 *  
 *  @mfunc
 *      Insert cch chars with format ifmt into format runs starting at
 *      this run ptr    
 *
 *  @rdesc
 *      count of characters added
 *
 *  @devnote    
 *      It is the caller's responsibility to ensure that we are in the
 *      "normal" or "empty" state.  A format run pointer doesn't know about
 *      CTxtStory, so it can't create the run array without outside help.
 */
LONG CFormatRunPtr::InsertFormat(
    LONG cch,               //@parm # chars to insert
    LONG ifmt,              //@parm format to use
    IFormatCache *pf)       //@parm pointer to IFormatCache to AddRefFormat
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::InsertFormat");

    LONG        cRun;
    CFormatRun *pRun;
    CFormatRun *pRunPrev;
    LONG        cchRun;                     // Current-run length,
    LONG        ich;                        //  offset, and
    LONG        iFormat;                    //  format

    _TEST_INVARIANT_

    Assert(_pRuns);
    if(!IsValid())
    {       
        // Empty run case (occurs when inserting after all text is deleted)
        pRun = Add(1, NULL);
        goto StoreNewRunData;               // (located at end of function)
    }

    // Go to previous run if at a boundary case
    AdjustBackward();
    pRun    = Elem(_iRun);                  // Try other cases
    cchRun  = pRun->_cch;
    iFormat = pRun->_iFormat;
    ich     = _ich;                         

    // Same run case.  Note that there is an additional boundary case; if we
    // are the _end_ of one run, then the next run may have the necessary
    // format.
    if(ifmt == iFormat)                     // IP already has correct fmt
    {
        pRun->_cch  += cch;
        _ich        += cch;                 // Inc offset to keep in sync
        return cch;
    }
    if(_ich == pRun->_cch && _iRun < _pRuns->Count() - 1)
    {
        AdjustForward();
        pRun = Elem(_iRun);

        Assert(pRun);

        if(pRun->_iFormat == ifmt)
        {
            pRun->_cch += cch;
            _ich += cch;
            return cch;
        }
        AdjustBackward();
    }

    // Prior run case (needed when formatting change occurs on line break
    //      and caret is at beginning of new line)
    if(!ich && _iRun > 0 )                  // IP at start of run
    {
        pRunPrev = GetPtr(pRun, -1);
        if( ifmt == pRunPrev->_iFormat)     // Prev run has same format:
        {                                   //  add count to prev run and
            pRunPrev->_cch += cch;
            return cch;
        }
    }

    // Create new run[s] cases.  There is a special case for a format
    // run of zero length: just re-use it.
    if(!pRun->_cch)
    {
        // This assert has been toned down to ignore a plain text control
        // being forced into IME Rich Composition.
        AssertSz( /* FALSE */ pRun->_iFormat == -1 && Count() == 1,
            "CFormatRunPtr::InsertFormat: 0-length run");
        pf->Release(pRun->_iFormat);
    }
    else                                    // Need to create 1 or 2 new
    {                                       //  runs for insertion
        cRun = 1;                           // Default 1 new run
        if(ich && ich < cchRun)             // Not at beginning or end of
            cRun++;                         //  run, so need two new runs

        // The following insert call adds one or two runs at the current
        // position. If the new run is inserted at the beginning or end
        // of the current run, the latter needs no change; however, if
        // the new run splits the current run in two, both pieces have
        // to be updated (cRun == 2 case).

        pRun = Insert(cRun);                // Insert cRun run(s)
        if(!pRun)                           // Out of RAM. Can't insert
        {                                   //  new format, but can keep
            _ich += cch;                    //  run ptr and format runs
            GetRun(0)->_cch += cch;         //  valid.  Note: doesn't
            return cch;                     //  signal any error; no access
        }                                   //  to _ped->_fErrSpace

        if(ich)                             // Not at beginning of run,
        {
            pRunPrev = pRun;                // Previous run is current run
            IncPtr(pRun);                   // New run is next run
            VALIDATE_PTR(pRun);
            pRun->_cch = cch;               // Keep NextRun() invariant happy
            NextRun();                      // Point this runptr at it too
            if(cRun == 2)                   // Are splitting current run
            {                               // _iFormat's are already set
                AssertSz(pRunPrev->_iFormat == iFormat,
                    "CFormatRunPtr::InsertFormat: bad format inserted");
                pRunPrev->_cch = ich;       // Divide up original cch
                GetPtr(pRun, 1)->_cch       //  accordingly
                    = cchRun - ich;
                pf->AddRef(iFormat);        // Addref iFormat for extra run
            }
        }
    }

StoreNewRunData:
    pf->AddRef(ifmt);                       // Addref ifmt
    ZeroMemory(pRun, sizeof(*pRun));
    pRun->_iFormat  = ifmt;                 // Store insert format and count
    pRun->_cch      = cch;                  //  of new run
    _ich            = cch;                  // cp goes at end of insertion

    return cch;
}

/*
 *  CFormatRunPtr::MergeRuns(iRun, pf)
 *  
 *  @mfunc
 *      Merge adjacent runs that have the same format between this run
 *      <md CFormatRunPtr::_iRun> and that for <p iRun>     
 *
 *  @comm
 *      Changes this run ptr
 */
void CFormatRunPtr::MergeRuns(
    LONG iRun,              //@parm last run to check (can preceed or follow
                            // <md CFormatRunPtr::_iRun>)
    IFormatCache *pf)       //@parm pointer to IFormatCache to ReleaseFormat
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::MergeRuns");

    LONG    cch;
    LONG    cRuns       = iRun - _iRun;
    LONG    iDirection  = 1;                // Default going forward
    CFormatRun *pRun;

    _TEST_INVARIANT_

    if(cRuns < 0)
    {
        cRuns = -cRuns;
        iDirection = -1;
    }
    if(!IsValid())                          // Allow starting run to be
    {                                       //  invalid
        Assert(FALSE);                      // I think this is old...
        ChgRun(iDirection);                 
    }

    while(cRuns--)
    {
        if(!GetRun(0)->_cch && !_iRun && _iRun < Count() - 1)
        {
            if(iDirection > 0)
                PrevRun();
            Remove(1, pf);
            continue;
        }

        pRun = GetRun(0);                   // Save the current run

        if(!ChgRun(iDirection))             // Go to next (or prev) run
            return;                         // No more runs to check

        if(pRun->SameFormat(GetRun(0)))
        {                                   // Like formatted runs
            if(iDirection > 0)              // Point at the first of the
                PrevRun();                  //  two runs
            cch = GetRun(0)->_cch;          // Save its count
            Remove(1, pf);                  // Remove it
            GetRun(0)->_cch += cch;         // Add its count to the other's,
        }                                   //  i.e., they're merged
    }
}

/*
 *  CFormatRunPtr::Remove(cRun, flag, pf)
 *  
 *  @mfunc
 *      Remove cRun runs starting at _iRun
 */
void CFormatRunPtr::Remove(
    LONG          cRun,
    IFormatCache *pf)
{
    CFormatRun *pRun = GetRun(0);           // Point at run(s) to delete

    for(LONG j = 0; j < cRun; j++, IncPtr(pRun))
        pf->Release(pRun->_iFormat);        // Decrement run reference count

    CRunPtr<CFormatRun>::Remove(cRun);
}

/*
 *  CFormatRunPtr::SetFormat(ifmt, cch, pf, pLevel)
 *  
 *  @mfunc
 *      Set format for up to cch chars of this run to ifmt, splitting run
 *      as needed, and returning the character count actually processed
 *
 *  @rdesc
 *      character count of run chunk processed, CP_INFINITE on failure
 *      this points at next run
 *
 *  Comments:
 *      Changes this run ptr.  cch must be >= 0.
 *
 *      Note 1) for the first run in a series, _ich may not = 0, and 2) cch
 *      may be <lt>, =, or <gt> the count remaining in the run. The algorithm
 *      doesn't split runs when the format doesn't change.
 */
LONG CFormatRunPtr::SetFormat(
    LONG            ifmt,   //@parm format index to use
    LONG            cch,    //@parm character count of remaining format range
    IFormatCache *  pf,     //@parm pointer to IFormatCache to
    CBiDiLevel*     pLevel) //@parm pointer to BiDi level structure
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::SetFormat");
                            //      AddRefFormat/ReleaseFormat
    LONG            cchChunk;
    LONG            iFormat;
    CFormatRun *    pRun;
    CFormatRun *    pChgRun;    // run that was reformatted
    CBiDiLevel      level;

    _TEST_INVARIANT_

    if(!IsValid())
        return 0;

    pRun        = GetRun(0);                // pRun points at current run in
    cchChunk    = pRun->_cch - _ich;        //  this function
    iFormat     = pRun->_iFormat;
    level       = pRun->_level;
    pChgRun     = pRun;

    AssertSz(cch, "Have to have characters to format!");
    AssertSz(pRun->_cch, "uh-oh, empty format run detected");

    if(ifmt != iFormat || (pLevel && level != *pLevel)) // New and current formats differ
    {
        AssertSz(cchChunk, "Caller did not call AdjustForward");

        if(_ich)                            // Not at either end of run: need
        {                                   //  to split into two runs of
            if(!(pRun = Insert(1)))         //  counts _ich and _pRun->_cch
            {                               //  - _ich, respectively
                return CP_INFINITE;         // Out of RAM: do nothing; just
            }                               //  keep current format
            pRun->_cch      = _ich;
            pRun->_iFormat  = iFormat;      // New run has same format
            pRun->_level    = level;        // and same level
            pf->AddRef(iFormat);            // Increment format ref count
            NextRun();                      // Go to second (original) run
            IncPtr(pRun);                   // Point pRun at current run
            pRun->_cch = cchChunk;          // Note: IncPtr is a bit more
            pChgRun = pRun;
        }                                   //  efficient than GetRun, but
                                            //  trickier to code right
        if(cch < cchChunk)                  // cch doesn't cover whole run:
        {                                   //  need to split into two runs
            if(!(pRun = Insert(1)))
            {
                // Out of RAM, so formatting's wrong, oh well.  We actually
                // "processed" all of the characters, so return that (though
                // the tail end formatting isn't split out right)
                return cch;
            }
            pRun->_cch = cch;               // New run gets the cch
            pRun->_iFormat = ifmt;          //  and the new format
            pChgRun = pRun;
            IncPtr(pRun);                   // Point pRun at current run
            pRun->_cch = cchChunk - cch;    // Set leftover count
        }
        else                                // cch as big or bigger than
        {                                   //  current run
            pf->Release(iFormat);           // Free run's current format
            pRun->_iFormat = ifmt;          // Change it to new format      
            pChgRun = pRun;
        }                                   // May get merged later
        pf->AddRef(ifmt);                   // Increment new format ref count
    }
    else if( cchChunk == 0 )
    {
        pRun->_cch += cch;
        cchChunk = cch;
    }

    // record embedding level to changed run
    if (pLevel)
        pChgRun->_level = *pLevel;

    cch = min(cch, cchChunk);
    AdvanceCp(cch);
    AdjustForward();
    return cch;
}

/*
 *  CFormatRunPtr::GetFormat()
 *
 *  @mfunc
 *      return format index at current run pointer position
 *
 *  @rdesc
 *      current format index
 */
short CFormatRunPtr::GetFormat() const
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::GetFormat");
    _TEST_INVARIANT_

    return IsValid() ? GetRun(0)->_iFormat : -1;
}


/*
 *  CFormatRunPtr::SplitFormat(IFormatCache*)
 *
 *  @mfunc
 *      Split a format run
 *
 *  @rdesc
 *      If succeeded the run pointer moves to the next splitted run
 */
void CFormatRunPtr::SplitFormat(IFormatCache* pf)
{
    if (!_ich || _ich == GetRun(0)->_cch)
        return;

    CFormatRun*     pRun = GetRun(0);
    LONG            iFormat = pRun->_iFormat;
    LONG            cch = pRun->_cch - _ich;
    CBiDiLevel      level = pRun->_level;

    if (pRun = Insert(1))
    {
        pRun->_cch = _ich;
        pRun->_iFormat = iFormat;
        pRun->_level = level;
        pf->AddRef(iFormat);
        NextRun();
        IncPtr(pRun);
        pRun->_cch = cch;
    }
}


/*
 *  CFormatRunPtr::SetLevel(level)
 *
 *  @mfunc
 *      Set run's embedding level
 */
void CFormatRunPtr::SetLevel (CBiDiLevel& level)
{
    if (!IsValid())
    {
        Assert(FALSE);
        return;
    }

    CFormatRun* pRun = GetRun(0);

    if (pRun)
        pRun->_level = level;
}

BYTE CFormatRunPtr::GetLevel (CBiDiLevel* pLevel)
{
    CFormatRun* pRun;

    if (!IsValid() || !(pRun = GetRun(0)))
    {
        Assert(FALSE);

        if (pLevel)
        {
            pLevel->_value = 0;
            pLevel->_fStart = FALSE;
        }
        return 0;
    }

    if (pLevel)
        *pLevel = pRun->_level;

    return pRun->_level._value;
}

/*
 *  CFormatRunPtr::AdjustFormatting(cch, pf)
 *  
 *  @mfunc
 *      Use the same format index for the cch chars at this run ptr
 *      as that immediately preceeding it (if on run edge).
 *
 *  @devnote
 *      This runptr ends up pointing at what was the preceeding run,
 *      since the current run has been moved into the preceeding run.
 *
 *      FUTURE: might be better to take the cch equal to chars in
 *      the following run.
 */ 
void CFormatRunPtr::AdjustFormatting(
    LONG          cch,      //@parm Count of chars to extend formatting
    IFormatCache *pf)       //@parm Format cache ptr for AddRef/Release
{
    if(!IsValid())
        return;                         // Nothing to merge

    CFormatRunPtr rp(*this);
    CBiDiLevel    level;
                                        // Move this run ptr to end of
    AdjustBackward();                   //  preceeding run (if at run edge)
    rp.AdjustForward();                 //  (merge may delete run at entry)
    if(_iRun != rp._iRun)               // On a format edge: copy previous
    {                                   //  format index over
        GetLevel(&level);
        rp.SetFormat(GetFormat(), cch, pf, &level); // Format cch chars at this
        rp.MergeRuns(_iRun, pf);            //  runptr
    }
}


///////////////////////////// CCFRunPtr ///////////////////////////////

CCFRunPtr::CCFRunPtr(const CRchTxtPtr &rtp)
        : CFormatRunPtr(rtp._rpCF)
{
    _ped = rtp.GetPed();
}

CCFRunPtr::CCFRunPtr(const CFormatRunPtr &rp, CTxtEdit *ped)
        : CFormatRunPtr(rp)
{
    _ped = ped;
}

/*
 *  CCFRunPtr::IsMask(dwMask, MaskOp)
 *  
 *  @mfunc
 *      return TRUE according to the mask operation MaskOp operating on
 *      _dwEffects.
 *
 *  @rdesc
 *      TRUE if bits in CCharFormat::dwEffects correspond to those in dwMask
 */
BOOL CCFRunPtr::IsMask(
    DWORD   dwMask,     //@parm Bit mask to use on dwEffects
    MASKOP  MaskOp)     //@parm Logic operation for bits
{
    DWORD dwEffects = _ped->GetCharFormat(GetFormat())->_dwEffects;

    if(MaskOp == MO_EXACT)              // Bit masks must be identical
        return dwEffects == dwMask;

    dwEffects &= dwMask;
    if(MaskOp == MO_OR)                 // TRUE if one or more effect bits
        return dwEffects != 0;          //  identified by mask are on

    if(MaskOp == MO_AND)                // TRUE if all effect bits
        return dwEffects == dwMask;     //  identified by mask are on

    AssertSz(FALSE, "CCFRunPtr::IsMask: illegal mask operation");
    return FALSE;
}

/*
 *  CCFRunPtr::IsInHidden()
 *  
 *  @mfunc
 *      return TRUE if CCharFormat for this run ptr has CFE_HIDDEN bit set
 *
 *  @rdesc
 *      TRUE if CCharFormat for this run ptr has CFE_HIDDEN bit set
 */
BOOL CCFRunPtr::IsInHidden()
{
    AdjustForward();
    BOOL fHidden = IsHidden();
    if(_ich)
        return fHidden;

    AdjustBackward();
    return fHidden && IsHidden();
}

/*
 *  CCFRunPtr::FindUnhidden()
 *  
 *  @mfunc
 *      Find nearest expanded CF going forward. If none, find nearest going
 *      backward.  If none, go to start of document
 *  
 *  @rdesc
 *      cch to nearest expanded CF as explained in function description
 *
 *  @devnote
 *      changes this run ptr
 */
LONG CCFRunPtr::FindUnhidden()
{
    LONG cch = FindUnhiddenForward();

    if(IsHidden())
        cch = FindUnhiddenBackward();

    return cch;
}

/*
 *  CCFRunPtr::FindUnhiddenForward()
 *  
 *  @mfunc
 *      Find nearest expanded CF going forward.  If none, go to EOD
 *  
 *  @rdesc
 *      cch to nearest expanded CF going forward
 *
 *  @devnote
 *      changes this run ptr
 */
LONG CCFRunPtr::FindUnhiddenForward()
{
    LONG cch = 0;

    AdjustForward();
    while(IsHidden())
    {
        cch += GetCchLeft();
        if(!NextRun())
            break;
    }
    return cch;
}

/*
 *  CCFRunPtr::MatchFormatSignature
 *  
 *  @mfunc
 *      Match the current format's font signature with the script (index to codepage).
 *      It takes care single-codepage fonts which implicitly supports ASCII range.
 *
 *  @rdesc
 *      return how font matched
 */

inline int CCFRunPtr::MatchFormatSignature (
    const CCharFormat*  pCF,
    int                 iScript,
    int                 iMatchCurrent,
    DWORD*              pdwFontSig)
{
    DWORD   dwFontSig = 0;

    if (GetFontSignatureFromFace(pCF->_iFont, &dwFontSig) != 0)
    {
        if (pdwFontSig)
            *pdwFontSig = dwFontSig;

        if (iMatchCurrent & MATCH_ASCII && fc().GetInfoFlags(pCF->_iFont).fNonBiDiAscii)
            return MATCH_ASCII;

        if (W32->GetFontSigFromScript(iScript) & ~(fASCII >> 8) & dwFontSig)
            return MATCH_FONT_SIG;
    }
    return 0;
}

/*
 *  CCFRunPtr::GetPreferredFontInfo( cpg, bCharSet, iFont, yHeight, bPitchAndFamily,
 *                                  iFormat, iMatchCurrent )
 *  
 *  @mfunc
 *      Find the preferred font for the given code page around the range.
 *
 *  @rdesc
 *      boolean true if suitable font found, false otherwise.
 */
bool CCFRunPtr::GetPreferredFontInfo(
    int    cpg,
    BYTE&  bRetCharSet,
    SHORT& iFont,
    SHORT& yHeight,             // return in twips
    BYTE&  bPitchAndFamily,
    int    iFormat,
    int    iMatchCurrent)
{
    int                i, iScript;
    bool               fr = false;
    static int const   MAX_FONTSEARCH = 256;
    const CCharFormat *pCF;
    const CCharFormat *pCFCurrent;
    const CCharFormat *pCFPrevious = NULL;
    int                iMatch = 0;          // how signature match?
    DWORD              dwCurrentFontSig = 0;
    SHORT              yNewHeight = 0;
    BYTE               bCharSet = GetCharSet(cpg, &iScript);
    bool               fUseUIFont = _ped->fUseUIFont() || _ped->Get10Mode();

    Assert(!(iMatchCurrent & MATCH_ASCII) || bCharSet == ANSI_CHARSET);

    if(_ped->fUseUIFont())
        pCFCurrent = _ped->GetCharFormat(-1);   // Plain text or UI font specified
    else
        pCFCurrent = _ped->GetCharFormat(iFormat != -1 ? iFormat : GetFormat());

    if ((iMatchCurrent & MATCH_FONT_SIG) &&
        (iMatch = MatchFormatSignature(pCFCurrent, iScript, iMatchCurrent, &dwCurrentFontSig)) != 0)
    {
        pCF = pCFCurrent;                   // Setup to use it
    }
    else
    {
        // Try searching backwards
        if (IsValid())                      // If doc has CF runs
            AdjustBackward();
        i = MAX_FONTSEARCH;                 // Don't be searching for years
        pCF = _ped->GetCharFormat(GetFormat());
        while (i--)
        {
            if (bCharSet == pCF->_bCharSet) // Equal charset ids?
            {
                pCFPrevious = pCF;
                break;
            }
            if (!PrevRun())                 // Done searching?
                break;
            pCF = _ped->GetCharFormat(GetFormat());
        }
        pCF = pCFPrevious;
    }

    // Try match charset if requested
    if(!pCF && iMatchCurrent == MATCH_CURRENT_CHARSET)
    {
        CCcs* pccs = fc().GetCcs(pCFCurrent, W32->GetYPerInchScreenDC());
        if (pccs)
        {
            if (pccs->BestCharSet(bCharSet, 1, MATCH_CURRENT_CHARSET) != 1)
                pCF = pCFCurrent;           // Current font can do it
            pccs->Release();
        }
    }

    // Try default document format
    if (!pCF)
    {
        pCF = _ped->GetCharFormat(-1);
        if (bCharSet != pCF->_bCharSet) // Diff charset ids?
            pCF = NULL;
    }

    yHeight = pCFCurrent->_yHeight;     // assume current height

    if (!pCF)
    {
        // Default to table if no match.
        
        fr = W32->GetPreferredFontInfo(
            cpg, fUseUIFont, iFont, (BYTE&)yNewHeight, bPitchAndFamily );

        if (!_ped->_fAutoFontSizeAdjust && (cpg == CP_THAI || cpg == THAI_INDEX))
            // Kick in font size adjusting in first bind to Thai.
            _ped->_fAutoFontSizeAdjust = TRUE;
    }

    if (pCF)
    {
        // Found previous or current font
        iFont = pCF->_iFont;
        bPitchAndFamily = pCF->_bPitchAndFamily;

        if (pCF == pCFCurrent && (iMatchCurrent & MATCH_FONT_SIG) &&
            (IsFECharSet(pCF->_bCharSet) && W32->IsFECodePageFont(dwCurrentFontSig) ||
             iMatch == MATCH_ASCII && bCharSet == ANSI_CHARSET))
        {
            // The current font matches the requested signature.
            // If it's a FarEast or ASCII font. We leave the charset intact.
            bRetCharSet = pCF->_bCharSet;
            return true;
        }
    }

    if (_ped->_fAutoFontSizeAdjust && iFont != pCFCurrent->_iFont)
    {
        if (IsValid())
        {
            // If the last run format is available. We will scale the size relative to it.

            AdjustBackward();
            if (GetIch() > 0)
            {
                pCFCurrent = _ped->GetCharFormat(GetFormat());
                yHeight = pCFCurrent->_yHeight;
            }
            AdjustForward();
        }

        if (iFont != pCFCurrent->_iFont)
        {
            // Scale the height relative to the preceding format

            if (pCF)
                yNewHeight = GetFontLegitimateSize(iFont, fUseUIFont, cpg);
    
            if (yNewHeight)
            {
                // Get legitimate size of the current font
                SHORT   yDefHeight = GetFontLegitimateSize(pCFCurrent->_iFont, fUseUIFont, GetCodePage(pCFCurrent->_bCharSet));
    
                // Calculate the new height relative to the current height
                if (yDefHeight)
                {
                    if (fUseUIFont)
                    {
                        // For UIFont, we only convert from one preferred size to another preferred size.
                        if (pCFCurrent->_yHeight / TWIPS_PER_POINT == yDefHeight)
                            yHeight = yNewHeight * TWIPS_PER_POINT;
                    }
                    else
                        yHeight = (SHORT)MulDiv(pCFCurrent->_yHeight, yNewHeight, yDefHeight);
                }
            }
        }
    }

    if (!yHeight)
        yHeight = (SHORT)MulDiv(pCFCurrent->_yHeight, yNewHeight, 10);

    return pCF || fr;
}

/*
 *  CCFRunPtr::FindUnhiddenBackward()
 *  
 *  @mfunc
 *      Find nearest expanded CF going backward.  If none, go to BOD
 *  
 *  @rdesc
 *      cch to nearest expanded CF going backward
 *
 *  @devnote
 *      changes this run ptr
 */
LONG CCFRunPtr::FindUnhiddenBackward()
{
    LONG cch = 0;

    AdjustBackward();
    while(IsHidden())
    {
        cch -= GetIch();
        if(!_iRun)
            break;
        _ich = 0;
        AdjustBackward();
    }
    return cch;
}

///////////////////////////// CPFRunPtr ///////////////////////////////

CPFRunPtr::CPFRunPtr(const CRchTxtPtr &rtp)
        : CFormatRunPtr(rtp._rpPF)
{
    _ped = rtp.GetPed();
}

/*
 *  CPFRunPtr::FindHeading(cch, lHeading)
 *  
 *  @mfunc
 *      Find heading with number lHeading (e.g., = 1 for Heading 1) or above
 *      in a range starting at this PFrun pointer.  If successful, this run
 *      ptr points at the matching run; else it remains unchanged.
 *  
 *  @rdesc
 *      cch to matching heading or tomBackward if not found
 *
 *  @devnote
 *      changes this run ptr
 */
LONG CPFRunPtr::FindHeading(
    LONG    cch,        //@parm Max cch to move
    LONG&   lHeading)   //@parm Lowest lHeading to match
{
    LONG    cchSave  = cch;
    LONG    ichSave  = _ich;
    LONG    iRunSave = _iRun;
    LONG    OutlineLevel;

    Assert((unsigned)lHeading <= NHSTYLES);

    if(!IsValid())
        return tomBackward;

    while(TRUE)
    {
        OutlineLevel = GetOutlineLevel();

        if (!(OutlineLevel & 1) &&
            (!lHeading || (lHeading - 1)*2 >= OutlineLevel))
        {
            lHeading = OutlineLevel/2 + 1;  // Return heading # found
            return cchSave - cch;           // Return how far away it was
        }

        if(cch >= 0)
        {
            cch -= GetCchLeft();
            if(cch <= 0 || !NextRun())
                break;
        }           
        else
        {
            cch += GetIch();
            if(cch > 0 || !_iRun)
                break;
            AdjustBackward();
        }
    }

    _ich  = ichSave;
    _iRun = iRunSave;
    return tomBackward;                     // Didn't find desired heading
}

/*
 *  CPFRunPtr::IsCollapsed()
 *  
 *  @mfunc
 *      return TRUE if CParaFormat for this run ptr has PFE_COLLAPSED bit set
 *
 *  @rdesc
 *      TRUE if CParaFormat for this run ptr has PFE_COLLAPSED bit set
 */
BOOL CPFRunPtr::IsCollapsed()
{
    return (_ped->GetParaFormat(GetFormat())->_wEffects & PFE_COLLAPSED) != 0;
}

/*
 *  CPFRunPtr::InTable()
 *  
 *  @mfunc
 *      return TRUE if CParaFormat for this run ptr has PFE_TABLE bit set
 *
 *  @rdesc
 *      TRUE if CParaFormat for this run ptr has PFE_TABLE bit set
 */
BOOL CPFRunPtr::InTable()
{
    return (_ped->GetParaFormat(GetFormat())->_wEffects & PFE_TABLE) != 0;
}

/*
 *  CPFRunPtr::FindExpanded()
 *  
 *  @mfunc
 *      Find nearest expanded PF going forward. If none, find nearest going
 *      backward.  If none, go to start of document
 *  
 *  @rdesc
 *      cch to nearest expanded PF as explained in function description
 *
 *  @devnote
 *      advances this run ptr the amount returned (cch)
 */
LONG CPFRunPtr::FindExpanded()
{
    LONG cch, cchRun;

    for(cch = 0; IsCollapsed(); cch += cchRun)  // Try to find expanded PF
    {                                           //  run going forward
        cchRun = GetCchLeft();
        if(!NextRun())                          // Aren't any
        {
            AdvanceCp(-cch);                    // Go back to starting point
            return FindExpandedBackward();      // Try to find expanded PF
        }                                       //  run going backward
    }
    return cch;
}

/*
 *  CPFRunPtr::FindExpandedForward()
 *  
 *  @mfunc
 *      Find nearest expanded PF going forward.  If none, go to EOD
 *  
 *  @rdesc
 *      cch to nearest expanded PF going forward
 *
 *  @devnote
 *      advances this run ptr the amount returned (cch)
 */
LONG CPFRunPtr::FindExpandedForward()
{
    LONG cch = 0;

    while(IsCollapsed())
    {
        LONG cchLeft = GetCchLeft();
        _ich += cchLeft;                        // Update _ich in case
        cch  += cchLeft;                        //  if(!NextRun()) breaks
        if(!NextRun())
            break;
    }
    return cch;
}

/*
 *  CPFRunPtr::FindExpandedBackward()
 *  
 *  @mfunc
 *      Find nearest expanded PF going backward.  If none, go to BOD
 *  
 *  @rdesc
 *      cch to nearest expanded PF going backward
 *
 *  @devnote
 *      advances this run ptr the amount returned (cch)
 */
LONG CPFRunPtr::FindExpandedBackward()
{
    LONG cch = 0;

    while(IsCollapsed())
    {
        cch -= GetIch();
        _ich = 0;
        if(!_iRun)
            break;
        AdjustBackward();
    }
    return cch;
}

/*
 *  CPFRunPtr::GetOutlineLevel()
 *  
 *  @mfunc
 *      Find outline level this rp is pointing at
 *  
 *  @rdesc
 *      Outline level this rp is pointing at
 */
LONG CPFRunPtr::GetOutlineLevel()
{
    const CParaFormat *pPF = _ped->GetParaFormat(GetFormat());
    LONG OutlineLevel = pPF->_bOutlineLevel;

    AssertSz(IsHeadingStyle(pPF->_sStyle) ^ (OutlineLevel & 1),
        "CPFRunPtr::GetOutlineLevel: sStyle/bOutlineLevel mismatch");

    return OutlineLevel;
}

/*
 *  CPFRunPtr::GetStyle()
 *  
 *  @mfunc
 *      Find style this rp is pointing at
 *  
 *  @rdesc
 *      Style this rp is pointing at
 */
LONG CPFRunPtr::GetStyle()
{
    const CParaFormat *pPF = _ped->GetParaFormat(GetFormat());
    LONG Style = pPF->_sStyle;

    AssertSz(IsHeadingStyle(Style) ^ (pPF->_bOutlineLevel & 1),
        "CPFRunPtr::GetStyle: sStyle/bOutlineLevel mismatch");

    return Style;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\dxfrobj.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	- DXFROBJ.C |
 *
 *		implementation of a generic IDataObject data transfer object.
 *		This object is suitable for use in OLE clipboard and drag drop
 *		operations
 *
 *	Author: <nl>
 *		alexgo (4/25/95)
 *
 *	Revisions: <nl>
 *		murrays (7/13/95) auto-doc'd and added cf_RTF
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_dxfrobj.h"
#include "_range.h"
#include "hash.h"

#define NUMOBJCOPIEDFORWAITCURSOR	1
#ifdef PEGASUS
#define NUMCHARCOPIEDFORWAITCURSOR	4096
#else
#define NUMCHARCOPIEDFORWAITCURSOR	16384
#endif

//
//	Common Data types
//

// If you change g_rgFETC[], change g_rgDOI[] and enum FETCINDEX and CFETC in
// _dxfrobj.h accordingly, and register nonstandard clipboard formats in
// RegisterFETCs(). Order entries in order of most desirable to least, e.g.,
// RTF in front of plain text.

//REVIEW (keithcu) All but the first column is const--separate into 2 data structures?
FORMATETC g_rgFETC[] =
{
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// CF_RTFUTF8
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// cf_RTF
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // RTF with NCRs for nonASCII
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// EmbObject
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// EmbSource
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// ObjDesc
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// LnkSource
	{CF_METAFILEPICT,	NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT},
	{CF_DIB,			NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
	{CF_BITMAP,			NULL, DVASPECT_CONTENT, -1, TYMED_GDI},
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // RTF with no objs
	{CF_UNICODETEXT,	NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
	{CF_TEXT,			NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// Filename
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// CF_RTFASTEXT
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// Text with objs
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE} // Richedit
};

// Keep in sync with above and with FETCINDEX and CFETC
const DWORD g_rgDOI[] =
{
	DOI_CANPASTERICH,						// RTF in UTF8 encoding
	DOI_CANPASTERICH,						// RTF
	DOI_CANPASTERICH,						// RTF with NCRs for nonASCII
	DOI_CANPASTEOLE,						// Embedded Object
	DOI_CANPASTEOLE,						// Embed Source
	DOI_NONE,								// Object Descriptor
	DOI_CANPASTEOLE,						// Link Source
	DOI_CANPASTEOLE,						// Metafile
	DOI_CANPASTEOLE,						// DIB
	DOI_CANPASTEOLE,						// Bitmap
	DOI_CANPASTERICH,						// RTF with no objects
	DOI_CANPASTEPLAIN,						// Unicode plain text
	DOI_CANPASTEPLAIN,						// ANSI plain text
	DOI_CANPASTEOLE,						// Filename
	DOI_CANPASTEPLAIN,						// Pastes RTF as text
	DOI_CANPASTERICH,						// Richedit Text
	DOI_CANPASTERICH						// RichEdit Text w/formatting
};

/*
 *	RegisterFETCs()
 *
 *	@func
 *		Register nonstandard format ETCs.  Called when DLL is loaded
 */
void RegisterFETCs()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "RegisterFETCs");

#ifdef RTF_HASHCACHE
	HashKeyword_Init();			// Init rtf control keyword hash table.
#endif
#ifndef MACPORT
	g_rgFETC[iRtfFETC].cfFormat	// Note: cfFormats are WORDs
			= (WORD)RegisterClipboardFormatA("Rich Text Format");

	g_rgFETC[iRtfUtf8].cfFormat
			= (WORD)RegisterClipboardFormatA("RTF in UTF8");

	g_rgFETC[iRtfNCRforNonASCII].cfFormat
			= (WORD)RegisterClipboardFormatA("RTF with NCRs for nonASCII");

	g_rgFETC[iRtfAsTextFETC].cfFormat
			= (WORD)RegisterClipboardFormatA("RTF As Text");

	g_rgFETC[iRichEdit].cfFormat
			= (WORD)RegisterClipboardFormatA("RICHEDIT");

	g_rgFETC[iObtDesc].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_OBJECTDESCRIPTOR);

	g_rgFETC[iEmbObj].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_EMBEDDEDOBJECT);

	g_rgFETC[iEmbSrc].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_EMBEDSOURCE);

	g_rgFETC[iLnkSrc].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_LINKSOURCE);

	g_rgFETC[iRtfNoObjs].cfFormat
			= (WORD)RegisterClipboardFormatA("Rich Text Format Without Objects");

	g_rgFETC[iTxtObj].cfFormat
			= (WORD)RegisterClipboardFormatA("RichEdit Text and Objects");

	g_rgFETC[iFilename].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_FILENAME);
#else
    // MacPort:  Should we even bother to register the clipboard formats if we
    //           are not going to use WLM clipboard???
	if(!g_rgFETC[iRtfFETC].cfFormat)
    {
		g_rgFETC[iRtfFETC].cfFormat = RegisterClipboardFormatA("RTF ");
		g_rgFETC[iRtfFETC].cfFormat = 'RTF ';
    }

	if(!g_rgFETC[iRtfAsTextFETC].cfFormat)
    {
		g_rgFETC[iRtfAsTextFETC].cfFormat = RegisterClipboardFormatA("RTFT");
		g_rgFETC[iRtfAsTextFETC].cfFormat = 'RTFT';
    }

	if(!g_rgFETC[iRichEdit].cfFormat)
    {
		g_rgFETC[iRichEdit].cfFormat = RegisterClipboardFormatA("RTE ");
		g_rgFETC[iRichEdit].cfFormat = 'RTE ';
    }

	if(!g_rgFETC[iObtDesc].cfFormat)
    {
		g_rgFETC[iObtDesc].cfFormat = RegisterClipboardFormatA(CF_OBJECTDESCRIPTOR);
		g_rgFETC[iObtDesc].cfFormat = cfObjectDescriptor;
    }

	if(!g_rgFETC[iEmbObj].cfFormat)
    {
		g_rgFETC[iEmbObj].cfFormat = RegisterClipboardFormatA(CF_EMBEDDEDOBJECT);
		g_rgFETC[iEmbObj].cfFormat =  cfEmbeddedObject;
    }

	if(!g_rgFETC[iEmbSrc].cfFormat)
    {
		g_rgFETC[iEmbSrc].cfFormat = RegisterClipboardFormatA(CF_EMBEDSOURCE);
		g_rgFETC[iEmbSrc].cfFormat = cfEmbedSource;
    }

	if(!g_rgFETC[iLnkSrc].cfFormat)
    {
		g_rgFETC[iLnkSrc].cfFormat = RegisterClipboardFormatA(CF_LINKSOURCE);
		g_rgFETC[iLnkSrc].cfFormat = cfLinkSource;
    }

	if(!g_rgFETC[iRtfNoObjs].cfFormat)
    {
		g_rgFETC[iRtfNoObjs].cfFormat = RegisterClipboardFormatA("RwoO");
		g_rgFETC[iRtfNoObjs].cfFormat = 'RwoO';
    }

	if(!g_rgFETC[iTxtObj].cfFormat)
    {
		g_rgFETC[iTxtObj].cfFormat = RegisterClipboardFormatA("RTnO");
		g_rgFETC[iTxtObj].cfFormat = 'RTnO';
    }

	if(!g_rgFETC[iFilename].cfFormat)
    {
		g_rgFETC[iFilename].cfFormat = RegisterClipboardFormatA(CF_FILENAME);
		g_rgFETC[iFilename].cfFormat = cfFileName;
    }

	if(!g_rgFETC[iRtfUtf8].cfFormat)
    {
		g_rgFETC[iRtfUtf8].cfFormat = RegisterClipboardFormatA("UTF8 RTF");
		g_rgFETC[iRtfUtf8].cfFormat = 'UTF8 RTF';
    }
#endif
}


//
//	CDataTransferObj PUBLIC methods
//

/*
 *	CDataTransferObj::QueryInterface (riid, ppv)
 *
 *	@mfunc
 *		 QueryInterface for CDataTransferObj
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDataTransferObj::QueryInterface (
	REFIID riid,			// @parm Reference to requested interface ID
	void ** ppv)			// @parm out parm for interface ptr
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::QueryInterface");

	if(!ppv)
		return E_INVALIDARG;

	*ppv = NULL;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

    HRESULT		hresult = E_NOINTERFACE;

	if( IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IDataObject) ||
		IsEqualIID(riid, IID_IRichEditDO) )
	{
		*ppv = this;
		AddRef();
		hresult = NOERROR;
	}

	return hresult;
}

/*
 *	CDataTransferObj::AddRef()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - incremented reference count
 */
STDMETHODIMP_(ULONG) CDataTransferObj::AddRef()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::AddRef");

	return ++_crefs;
}

/*
 *	CDataTransferObj::Release()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - decremented reference count
 */
STDMETHODIMP_(ULONG) CDataTransferObj::Release()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		GlobalFree(_hPlainText);
		GlobalFree(_hRtfText);
		GlobalFree(_hRtfUtf8);
		GlobalFree(_hRtfNCRforNonASCII);
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CDataTransferObj::DAdvise (pFormatetc, advf, pAdvSink, pdwConnection)
 *
 *	@mfunc
 *		establish an advisory connection
 *
 *	@rdesc
 *		HRESULT = OLE_E_ADVISENOTSUPPORTED
 *
 *	@devnote
 *		this is a data transfer object, thus the data is a "snapshot" and
 *		cannot change -- no advises are supported.
 */
STDMETHODIMP CDataTransferObj::DAdvise(
	FORMATETC * pFormatetc,
	DWORD advf,
	IAdviseSink *pAdvSink,
	DWORD *pdwConnection)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::DAdvise");

	return OLE_E_ADVISENOTSUPPORTED;
}

/*
 *	CDataTransferObj::DUnadvise (dwConnection)
 *
 *	@mfunc
 *		destroy an advisory connection
 *
 *	@rdesc
 *		HRESULT = OLE_E_ADVISENOTSUPPORTED
 *
 *	@devnote
 *		this is a data transfer object, thus the data is a "snapshot" and
 *		cannot change -- no advises are supported.
 */
STDMETHODIMP CDataTransferObj::DUnadvise(
	DWORD dwConnection)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::DUnadvise");

	return OLE_E_ADVISENOTSUPPORTED;
}

/*
 *	CDataTransferObj::EnumDAdvise (ppenumAdvise)
 *
 *	@mfunc
 *		enumerate advisory connections
 *
 *	@rdesc
 *		HRESULT = OLE_E_ADVISENOTSUPPORTED
 *
 *	@devnote
 *		this is a data transfer object, thus the data is a "snapshot" and
 *		cannot change -- no advises are supported.
 */
STDMETHODIMP CDataTransferObj::EnumDAdvise(
	IEnumSTATDATA ** ppenumAdvise)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::EnumDAdvise");

	return OLE_E_ADVISENOTSUPPORTED;
}

/*
 *	CDataTransferObj::EnumFormatEtc (dwDirection, ppenumFormatEtc)
 *
 *	@mfunc
 *		returns an enumerator which lists all of the available formats in
 *		this data transfer object
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote
 *		we have no 'set' formats for this object
 */
STDMETHODIMP CDataTransferObj::EnumFormatEtc(
	DWORD dwDirection,					// @parm DATADIR_GET/SET
	IEnumFORMATETC **ppenumFormatEtc)	// @parm out parm for enum FETC interface
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::EnumFormatEtc");

	if(!ppenumFormatEtc)
		return E_INVALIDARG;

	*ppenumFormatEtc = NULL;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	HRESULT hr = NOERROR;


	#ifdef DEBUG
	if (dwDirection == DATADIR_SET && !_ped->Get10Mode())
	{
		Tracef(TRCSEVNONE, "RichEdit 2.0 EnumFormatEtc called with DATADIR_SET");
	}
	#endif

	//Need riched10 compatibility hack to ignore dwDirection
	if(dwDirection == DATADIR_GET || _ped->Get10Mode())
		hr = CEnumFormatEtc::Create(_prgFormats, _cTotal, ppenumFormatEtc);

	return hr;
}

/*
 *	CDataTransferObj::GetCanonicalFormatEtc( pformatetc, pformatetcOut)
 *
 *	@mfunc
 *		from the given formatetc, return a more standard (or canonical)
 *		format.
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL
 *
 *	@devnote
 *		(alexgo): we may need to write this routine if we ever do anything
 *		snazzy with printers
 */
STDMETHODIMP CDataTransferObj::GetCanonicalFormatEtc(
	FORMATETC *pformatetc,
	FORMATETC *pformatetcOut)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetCanonicalFormatEtc");

	return E_NOTIMPL;
}

/*
 *	CDataTransferObj::GetData (pformatetcIn, pmedium)
 *
 *	@mfunc
 *		retrieves data of the specified format
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDataTransferObj::GetData(
	FORMATETC *pformatetcIn, 
	STGMEDIUM *pmedium )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetData");

	FillMemory(pmedium, '\0', sizeof(STGMEDIUM));
	pmedium->tymed	 = TYMED_NULL;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	CLIPFORMAT	cf = pformatetcIn->cfFormat;
	HRESULT		hr = E_OUTOFMEMORY;                     // Default not enuf RAM

	// now handle 'native' richedit formats.
	if( cf && pformatetcIn->tymed & TYMED_HGLOBAL )
	{
		if( cf == CF_UNICODETEXT )
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hPlainText, tPlain));

		else if(cf == CF_TEXT)
			pmedium->hGlobal = TextHGlobalWtoA(TextToHglobal(_hPlainText, tPlain));

		else if(cf == cf_RTF || cf == cf_RTFASTEXT || cf == cf_RTFNOOBJS)
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hRtfText, tRtf));

		else if(cf == cf_RTFUTF8)
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hRtfUtf8, tRtfUtf8));

		else if(cf == cf_RTFNCRFORNONASCII)
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hRtfNCRforNonASCII, tRtfNCRforNonASCII));
			
		else
		    hr = DV_E_FORMATETC;
		
        if (hr == E_OUTOFMEMORY)
        {
    		if( pmedium->hGlobal )						// Succeeded
    		{
    			pmedium->tymed	 = TYMED_HGLOBAL;
    			hr = NOERROR;
    		}
    		return hr;
    	}
	}
	
	if ((cf == cf_EMBEDDEDOBJECT ||
		 cf == cf_EMBEDSOURCE) &&
		(pformatetcIn->tymed & TYMED_ISTORAGE))
	{
        _pObjStg = GetDataForEmbeddedObject( _pOleObj, pmedium->pstg );
		pmedium->tymed = TYMED_ISTORAGE;
		if (NULL == pmedium->pstg)
			pmedium->pstg = _pObjStg;
		hr = _pObjStg != NULL ? NOERROR : hr;
		return hr;
	} 

	// Go through richedit's formats and see if there are any matches
	if( cf == cf_OBJECTDESCRIPTOR &&
			 (pformatetcIn->tymed & TYMED_HGLOBAL) &&
			 _hObjDesc)
	{    
		pmedium->hGlobal = DuplicateHGlobal(_hObjDesc);
		pmedium->tymed = TYMED_HGLOBAL;
		return NOERROR;
	}

    // First propogate the message to the object and see if it handles the format
    if (_pOleObj)
    {
        // Include the formats supported by the object
        IDataObject * pdataobj = NULL;
        if (FAILED(_pOleObj->GetClipboardData(0, &pdataobj)) || pdataobj == NULL)    	        	            
            _pOleObj->QueryInterface(IID_IDataObject, (void**) &pdataobj);
            
        if (pdataobj)
        {
            hr = pdataobj->GetData(pformatetcIn, pmedium);
            pdataobj->Release();

            if (SUCCEEDED(hr))
            {
                if ((cf == cf_EMBEDDEDOBJECT || cf == cf_EMBEDSOURCE) && _pOleObj)
                {
                    OleSaveSiteFlags(pmedium->pstg, _dwFlags, _dwUser, _dvaspect);
                }
                return S_OK;
            }
        }
    }          

	if( cf == CF_METAFILEPICT )
	{
		pmedium->hMetaFilePict = OleDuplicateData(_hMFPict, CF_METAFILEPICT, 0);
		pmedium->tymed = TYMED_MFPICT;
		return NOERROR;
	}

	if( cf == CF_DIB )
	{
		if( _ped->HasObjects() && _cch == 1 )
		{
			COleObject *pobj = _ped->_pobjmgr->GetObjectFromCp(_cpMin);
			if (pobj)
			{
				HGLOBAL hdib = pobj->GetHdata();
				if (hdib)
				{
					pmedium->hGlobal = DuplicateHGlobal(hdib);
					pmedium->tymed = TYMED_HGLOBAL;
				}
			}
		}
		return NOERROR;
	}

	return DV_E_FORMATETC;
}

/*
 *	CDataTransferObj::GetDataForEmbeddedObject (pformatetc, lpstgdest)
 *
 *	@mfunc
 *		retrieves data for embedded object
 *
 *	@rdesc
 *		LPSTORAGE
 *
 */
LPSTORAGE CDataTransferObj::GetDataForEmbeddedObject(
	LPOLEOBJECT	 pOleObj,
	LPSTORAGE	 lpstgdest)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetDataForEmbeddedObject");
	
	HRESULT			 hr, hr1;
	LPPERSISTSTORAGE pperstg;

	if (_pObjStg != NULL && lpstgdest != NULL)
	{
		// We saved the data previously. Copy it to destination.
		hr = _pObjStg->CopyTo(0, NULL, NULL, lpstgdest);
		if (hr == NOERROR)
		{
			lpstgdest->Commit(STGC_DEFAULT);
			return _pObjStg;
		}
		return NULL;
	}

	if (_pObjStg != NULL && lpstgdest == NULL)
	{
		// We saved the data previously.  Return a reference
		_pObjStg->AddRef();
		return _pObjStg;
	}

	// We don't have a saved copy.  Create One.
	hr = pOleObj->QueryInterface( IID_IPersistStorage, (void **) &pperstg );
	if (hr != NOERROR)
		return NULL;

	if (lpstgdest == NULL)
	{
		// It is null.  We have to create our own.
		LPLOCKBYTES lpLockBytes = NULL;
		hr = CreateILockBytesOnHGlobal(NULL, TRUE, // delete on release
									   (LPLOCKBYTES *)&lpLockBytes);
		if (hr != NOERROR)
		{
			pperstg->Release();
			return NULL;
		}
		hr = StgCreateDocfileOnILockBytes(
			lpLockBytes,
			STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
			0,	// reserved
			&lpstgdest
		);
		lpLockBytes->Release();
		if (hr != NOERROR)
		{
			pperstg->Release();
			return NULL;
		}
		_pObjStg = lpstgdest;
	}
	else
	{
		// Force the data to be saved
		_pObjStg = GetDataForEmbeddedObject( _pOleObj, NULL );
		pperstg->Release();
		return GetDataForEmbeddedObject( _pOleObj, lpstgdest );
	}

    // OLE2NOTE: even if OleSave returns an error you should still call 
    // SaveCompleted.
    hr = OleSave( pperstg, lpstgdest, FALSE /* fSameAsLoad */ );
 	hr1 = pperstg->SaveCompleted(NULL);
	if (hr != NOERROR || hr1 != NOERROR)			// Should we use SUCCEED macros ????
		lpstgdest = NULL;

	pperstg->Release();
	return _pObjStg;
}

/*
 *	CDataTransferObj::GetDataorObjectDescriptor (pformatetc, pmedium)
 *
 *	@mfunc
 *		retrieves data for embedded object descriptor
 *
 *	@rdesc
 *		HRESULT
 */
HGLOBAL CDataTransferObj::GetDataForObjectDescriptor(
	LPOLEOBJECT	 pOleObj,
	DWORD		 dwAspect,
	SIZEL*       psizel)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetDataForObjectDescriptor");

	POINTL ptl = {0};
	SIZEL sizel = {0};
	if (psizel)
	{
	    sizel.cx = psizel->cx;
	    sizel.cy = psizel->cy;
	}

	if (_hObjDesc == NULL)
	{
		_hObjDesc = OleGetObjectDescriptorDataFromOleObject(
			pOleObj,
			dwAspect,
			ptl,
			&sizel
		);
	}
	return _hObjDesc;
}

/*
 *	CDataTransferObj::GetDataHere (pformatetc, pmedium)
 *
 *	@mfunc
 *		retrieves data of the specified format into the given medium
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL
 *
 *	@devnote (alexgo): technically, we're supposed to support transfers
 *		into hglobals, but I'd rather not at the moment.
 */
STDMETHODIMP CDataTransferObj::GetDataHere(
	FORMATETC *pformatetc, 
	STGMEDIUM *pmedium)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetDataHere");

	CLIPFORMAT	cf = pformatetc->cfFormat;
	HRESULT		hr = DV_E_FORMATETC;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;
	
	if( (cf == cf_EMBEDDEDOBJECT ||
		 cf == cf_EMBEDSOURCE) &&
		(pformatetc->tymed & TYMED_ISTORAGE))
	{
		// For some reason the NT4.0 and Win95 Shell
		//          ask for the EMBEDSOURCE format.
        _pObjStg = GetDataForEmbeddedObject( _pOleObj, pmedium->pstg );
		pmedium->tymed = TYMED_ISTORAGE;
		if (NULL == pmedium->pstg)
			pmedium->pstg = _pObjStg;
		hr = pmedium->pstg != NULL ? NOERROR : hr;
		return hr;
	}
	
	if( cf == cf_OBJECTDESCRIPTOR &&
			 (pformatetc->tymed & TYMED_HGLOBAL) &&
			 _hObjDesc)
	{
		pmedium->hGlobal = DuplicateHGlobal(_hObjDesc);
		pmedium->tymed = TYMED_HGLOBAL;
		return NOERROR;
	}

	// First propogate the message to the object and see if it handles the format
	if (_pOleObj)
	{
        // Include the formats supported by the object
        IDataObject * pdataobj = NULL;
        if (FAILED(_pOleObj->GetClipboardData(0, &pdataobj)) || pdataobj == NULL)    	        	            
            _pOleObj->QueryInterface(IID_IDataObject, (void**) &pdataobj);
            
        if (pdataobj)
        {
            hr = pdataobj->GetData(pformatetc, pmedium);
            pdataobj->Release();
            if (hr == S_OK)
            {
                if ((cf == cf_EMBEDDEDOBJECT || cf == cf_EMBEDSOURCE) && _pOleObj)
                {
                    OleSaveSiteFlags(pmedium->pstg, _dwFlags, _dwUser, _dvaspect);
                }
                return S_OK;
            }            
        }        
	}
	return E_NOTIMPL;
}

/*
 *	CDataTransferObj::QueryGetData (pformatetc)
 *
 *	@mfunc
 *		Queries whether the given format is available in this data object
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDataTransferObj::QueryGetData(
	FORMATETC *pformatetc )		// @parm FETC to look for
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::QueryGetData");

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	DWORD	cFETC = _cTotal;

	while (cFETC--)				// Maybe faster to search from start
	{
		if( pformatetc->cfFormat == _prgFormats[cFETC].cfFormat && 
			(pformatetc->tymed & _prgFormats[cFETC].tymed) )
		{
			return NOERROR;
		}
	}

	return DV_E_FORMATETC;
}

/*
 *	CDataTransferObj::SetData (pformatetc, pmedium, fRelease)
 *
 *	@mfunc
 *		allows data to be set into this data object
 *
 *	@rdesc
 *		HRESULT = E_FAIL
 *
 *	@devnote
 *		as we are a data transfer object with a "snapshot" of data,
 *		we do not allow it to be replaced
 */
STDMETHODIMP CDataTransferObj::SetData(
	FORMATETC *pformatetc,
	STGMEDIUM *pmedium,
	BOOL fRelease)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::SetData");

	return E_FAIL;
}


/*
 *	CDataTransferObj::OnPreReplaceRange (cp, cchDel, cchNew, cpFormatMin,
 *										 cpFormatMax)
 *
 *	@mfunc	implementation of ITxNotify::OnPreReplaceRange
 *			called before changes are made to the backing store
 */
void CDataTransferObj::OnPreReplaceRange(
	LONG cp, 			//@parm cp of the changes
	LONG cchDel,		//@parm #of chars deleted
	LONG cchNew,		//@parm # of chars added
	LONG cpFormatMin, 	//@parm min cp of formatting changes
	LONG cpFormatMax)	//@parm max cp of formatting changes
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::OnPreReplaceRange");

	if(CONVERT_TO_PLAIN != cp && CP_INFINITE != cp)
	{
		if(cp > _cpMin + _cch)
			return;							// Change beyond our extent

		if(cp + cchDel < _cpMin)
		{
			_cpMin += (cchNew - cchDel);	// Change before our extent
			return;
		}
	}

	// FUTURE (murrays): save only one master format (UTF8 RTF or better
	// CTxtStory) and generate individual ones in GetData and GetDataHere.
	_hPlainText = TextToHglobal(_hPlainText, tPlain);
	_hRtfText	= TextToHglobal(_hRtfText,	 tRtf);
	if(_ped->GetCharFlags() & ~(fLATIN1 | fSYMBOL))
		_hRtfUtf8 = TextToHglobal(_hRtfUtf8, tRtfUtf8);
}

/*
 *	CDataTransferObj::OnPostReplaceRange(cp, cchDel, cchNew, cpFormatMin,
 *										 cpFormatMax)
 *	@mfunc	implementation of ITxNotify::OnPostReplaceRange
 *			called after changes are made to the backing store
 *
 *	@comm	we use this method to keep our cp's up-to-date
 */
void CDataTransferObj::OnPostReplaceRange(
	LONG cp, 			//@parm cp of the changes
	LONG cchDel,		//@parm #of chars deleted
	LONG cchNew,		//@parm # of chars added
	LONG cpFormatMin, 	//@parm min cp of formatting changes
	LONG cpFormatMax)	//@parm max cp of formatting changes
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::OnPostReplaceRange");

	// Nothing to do
	return;
}

/*
 *	CDataTransferObj::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie
 */
void CDataTransferObj::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CDataTransferObj::Zombie");

	_ped = NULL;
}

/*
 *	CDataTransferObj::Create(ped, prg, lStreamFormat)
 *
 *	@mfunc
 *		static function to create CDataTransferObj. Used to force users
 *		not to create this object on the stack, which would break OLE's
 *		liveness rules.
 *
 *	@rdesc
 *		new CDataTransferObj *
 */
CDataTransferObj *CDataTransferObj::Create(
	CTxtEdit *ped,			// @parm ped to which this DataObject belongs
	CTxtRange *prg,			// @parm range for the data object
	LONG lStreamFormat)		// @parm stream format to use in Rtf conversion
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::Create");

	Assert(CFETC == ARRAY_SIZE(g_rgFETC) && CFETC == ARRAY_SIZE(g_rgDOI));

	LONG			ch;
	CNotifyMgr *	pnm;
	CDataTransferObj *pdo = new CDataTransferObj(ped);

	if( !pdo )
	{
		ped->GetCallMgr()->SetOutOfMemory();
		return NULL;
	}

	LONG cpMin, cpMost;
	pdo->_cch = prg->GetRange(cpMin, cpMost);
	pdo->_cpMin = cpMin;

	pdo->_lStreamFormat = lStreamFormat;

	pnm = ped->GetNotifyMgr();
	if(pnm)
		pnm->Add( (ITxNotify *) pdo );

	//Set the object count.
	pdo->_cObjs = 0;
	if( ped->HasObjects() )
		pdo->_cObjs = ped->_pobjmgr->CountObjectsInRange(cpMin, cpMost);

	int cTotal = !ped->IsRich() ? 2 :
					(ped->GetCharFlags() & ~(fLATIN1 | fSYMBOL)) ? 7 : 5;


   	int cExtraFmtEtc = 0;
	COleObject *pobj = NULL;
	FORMATETC rgfetc[255];
	BOOL bValidOleObj = FALSE;

	// We only support 2 formats in the play text case
    if ( !ped->IsRich() )
    {        
        pdo->_cTotal = cTotal;
        pdo->_prgFormats = new FORMATETC[cTotal];
        if (!pdo->_prgFormats)
            goto ErrorExit;
            
		// Plain-text case
		pdo->_prgFormats[0] = g_rgFETC[iAnsiFETC];
		pdo->_prgFormats[1] = g_rgFETC[iUnicodeFETC];
		return pdo;
	}

    // We need to count the number of supported formats
	if (ped->HasObjects() && pdo->_cch == 1 && prg->GetChar(&ch) == NOERROR && ch == WCH_EMBEDDING)
	{
	    pobj = ped->_pobjmgr->GetObjectFromCp(pdo->_cpMin);
	    pdo->_dwFlags = pobj->GetFlags();
        pdo->_dwUser = pobj->GetUser();
        pdo->_dvaspect =pobj->GetAspect();
	    IUnknown * punk = pobj->GetIUnknown();

	    //  We want to query IOleObject on which formats it supports.  And add that to the
	    // FORMATETC array.
	    if (punk &&	punk->QueryInterface(IID_IOleObject,(void **) &pdo->_pOleObj) == NOERROR)
	   	{
	   	    bValidOleObj = TRUE;
	   	    
	        // Include the formats supported by the object
			IDataObject * pdataobj = NULL;
	        if (FAILED(pdo->_pOleObj->GetClipboardData(0, &pdataobj)) || pdataobj == NULL)    	        	            
                pdo->_pOleObj->QueryInterface(IID_IDataObject, (void**) &pdataobj);

            if (pdataobj)
            {
	            IEnumFORMATETC *pifetc = NULL;

	            // 1.0 didn't check the return value of EnumFormatEtc.  This is important because ccMail 
	            // will return an OLE error although it actually succeeds in setting the formatetc
	            if ((SUCCEEDED(pdataobj->EnumFormatEtc( DATADIR_GET, &pifetc)) || ped->Get10Mode()) && pifetc)
	            {
	                AssertSz(pifetc, "IEnumFormatEtc is NULL");
	                
	                // Copy the formats which are supported by the object
	                while((pifetc->Next(1, &rgfetc[cExtraFmtEtc], NULL)) == S_OK && cExtraFmtEtc < 255)
	                    cExtraFmtEtc++;	                
	                pifetc->Release();
	            }
	            pdataobj->Release();
            }
	    }
	}

    pdo->_cTotal = cTotal + cExtraFmtEtc;
	pdo->_prgFormats = new FORMATETC[pdo->_cTotal];
	if (!pdo->_prgFormats) 
	    goto ErrorExit;

    if (pobj)
    {
    	// copy over formats supported by the object itself
    	if (cExtraFmtEtc)
    	    memcpy(pdo->_prgFormats, rgfetc, cExtraFmtEtc * sizeof(FORMATETC));

        // copy formats supported by Richedit as a container
    	// Have an OLE object: offer all OLE formats plus RTF
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iEmbObj];	// EmbeddedObject
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iObtDesc];	// ObjectDescriptor
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iMfPict];	// Metafile
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfFETC];	// RTF 
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfNoObjs];	// RTF with no objects
	}
	else
	{
        // Regular rich-text case
    	pdo->_prgFormats[0] = g_rgFETC[iRtfFETC];		// RTF
    	pdo->_prgFormats[1] = g_rgFETC[iRtfNoObjs];		// RTF with no objects
    	pdo->_prgFormats[2] = g_rgFETC[iRtfAsTextFETC];	// RTF as Text
    	pdo->_prgFormats[3] = g_rgFETC[iAnsiFETC];		// ANSI plain text
    	pdo->_prgFormats[4] = g_rgFETC[iUnicodeFETC];	// Unicode plain text
    	cExtraFmtEtc = 5;
	}


	// We only offer up the six formats that we know how to handle in GetData.
	// The actual values differ somewhat from regular rich text and text
	// with embedded objects
    if (cTotal == 7)
    {
        pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfUtf8];	// RTF in UTF-8
        pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfNCRforNonASCII];
    }

    // Get the embedded object formats now
    if (bValidOleObj)
    {
        SIZEL sizel;
        pobj->GetSizel(sizel);        
        pdo->_hObjDesc = pdo->GetDataForObjectDescriptor( pdo->_pOleObj, pobj->GetDvaspect(), &sizel);
		pdo->_pObjStg = pdo->GetDataForEmbeddedObject( pdo->_pOleObj, NULL );
		pdo->_hMFPict = (HMETAFILE) OleStdGetMetafilePictFromOleObject(	pdo->_pOleObj, 
		                                pobj->GetDvaspect(), NULL, NULL);
    }

    return pdo;

ErrorExit:	
    
	pdo->_cTotal = 0;
	pdo->Release();
	ped->GetCallMgr()->SetOutOfMemory();
	return NULL;
}

/*
 *	CDataTransferObj::TextToHglobal(hText, tKind)
 *
 *	@mfunc
 *		Instantiates text on demand for the data object.
 *
 *	@rdesc
 *		HGLOBAL
 */
HGLOBAL CDataTransferObj::TextToHglobal(
	HGLOBAL &hText,
	TEXTKIND tKind)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::PlainTextToHglobal");

	if (hText == NULL)
	{
		CTxtRange rg(_ped, _cpMin, -_cch);
		if (tKind == tPlain)
		{
			hText = _ped->GetDTE()->UnicodePlainTextFromRange(&rg);
		}
		else if(_ped->IsRich())
		{
			LONG lStreamFormat = _lStreamFormat;
			if(tKind == tRtfUtf8)
				lStreamFormat = LOWORD(lStreamFormat) | SF_USECODEPAGE | (CP_UTF8 << 16);

			else if(tKind == tRtfNCRforNonASCII)
				lStreamFormat |= SF_NCRFORNONASCII;

			hText = _ped->GetDTE()->RtfFromRange(&rg, lStreamFormat);
		}
	}
	return hText;	
}

//
//	CDataTransferObj PRIVATE methods
//

/*
 *	CDataTransferObj::CDataTransferObj()
 *
 *	@mfunc
 *		Private constructor
 */

CDataTransferObj::CDataTransferObj( CTxtEdit *ped )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::CDataTransferObj");

	_ped = ped;
	_crefs = 1;
	_cTotal = CFETC;
	_prgFormats = g_rgFETC;
	_cch = 0;
	_cObjs = 0;
}

/*
 *	CDataTransferObj::~CDataTransferObj
 *
 *	@mfunc
 *		Private destructor
 */
CDataTransferObj::~CDataTransferObj()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::~CDataTransferObj");

	// No need to monitor notifications any more
	CNotifyMgr *pnm;

	if(_ped)
	{
		pnm = _ped->GetNotifyMgr();
		if(pnm)
			pnm->Remove( (ITxNotify *)this );
	}

	if( _prgFormats && _prgFormats != g_rgFETC)
		delete _prgFormats;

	if (_pOleObj)
		_pOleObj->Release();

	if (_pObjStg)
		_pObjStg->Release();

#ifndef NOMETAFILES
	if (_hMFPict)
		(void) DeleteMetaFile(_hMFPict);
#endif

	GlobalFree(_hObjDesc);
}		

//
//	CEnumFormatEtc PUBLIC methods
//

/*
 *	CEnumFormatEtc::QueryInterface (riid, ppvObj)
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		HRESULT
 */

STDMETHODIMP CEnumFormatEtc::QueryInterface(
	REFIID riid,			// @parm Reference to requested interface ID
	void ** ppv)			// @parm out parm for interface ptr
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::QueryInterface");

    HRESULT		hresult = E_NOINTERFACE;

	*ppv = NULL;

    if( IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEnumFORMATETC) )
    {
        *ppv = this;
        AddRef();
        hresult = NOERROR;
    }
    return hresult;
}

/*
 *	CEnumFormatEtc::AddRef()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - incremented reference count
 */

STDMETHODIMP_(ULONG) CEnumFormatEtc::AddRef( )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::AddRef");

 	return ++_crefs;
}

/*
 *	CEnumFormatEtc::Release()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - decremented reference count
 */

STDMETHODIMP_(ULONG) CEnumFormatEtc::Release( )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CEnumFormatEtc::Next (celt, rgelt, pceltFetched)
 *
 *	@mfunc
 *		fetches the next [celt] elements in our formatetc collection
 *
 *	@rdesc
 *		HRESULT
 */

STDMETHODIMP CEnumFormatEtc::Next( ULONG celt, FORMATETC *rgelt,
        ULONG *pceltFetched)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Next");

    HRESULT		hresult = NOERROR;
    ULONG		cFetched;

	if( pceltFetched == NULL && celt != 1 )
    {
        // the spec says that if pceltFetched == NULL, then
        // the count of elements to fetch must be 1
        return E_INVALIDARG;
    }

    // we can only grab as many elements as there are left

    if( celt > _cTotal - _iCurrent )
    {
        cFetched = _cTotal - _iCurrent;
        hresult = S_FALSE;
    }
    else
        cFetched = celt;

    // Only copy if we have elements to copy

    if( cFetched > 0 )
    {
        memcpy( rgelt, _prgFormats + _iCurrent,
            cFetched * sizeof(FORMATETC) );
    }

    _iCurrent += cFetched;

    if( pceltFetched )
        *pceltFetched = cFetched;

    return hresult;
}

/*
 *	CEnumFormatEtc::Skip
 *
 *	@mfunc
 *		skips the next [celt] formats
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CEnumFormatEtc::Skip( ULONG celt )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Skip");

    HRESULT		hresult = NOERROR;

    _iCurrent += celt;

    if( _iCurrent > _cTotal )
    {
        // whoops, skipped too far ahead.  Set us to the max limit.
        _iCurrent = _cTotal;
        hresult = S_FALSE;
    }

    return hresult;
}

/*
 *	CEnumFormatEtc::Reset
 *
 *	@mfunc
 *		resets the seek pointer to zero
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CEnumFormatEtc::Reset( void )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Reset");

    _iCurrent = 0;

    return NOERROR;
}

/*
 *	CEnumFormatEtc::Clone
 *
 *	@mfunc
 *		clones the enumerator
 *
 *	@rdesc
 *		HRESULT
 */

STDMETHODIMP CEnumFormatEtc::Clone( IEnumFORMATETC **ppIEnum )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Clone");
	
    return CEnumFormatEtc::Create(_prgFormats, _cTotal, ppIEnum);
}

/*
 *	CEnumFormatEtc::Create (prgFormats, cTotal, hr)
 *
 *	@mfunc
 *		creates a new format enumerator
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote
 *		*copies* the formats passed in.  We do this as it simplifies
 *		memory management under OLE object liveness rules
 */

HRESULT CEnumFormatEtc::Create( FORMATETC *prgFormats, ULONG cTotal, 
	IEnumFORMATETC **ppenum )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Create");

	CEnumFormatEtc *penum = new CEnumFormatEtc();

	if(penum)
	{
  		// _iCurrent, _crefs are set in the constructor

		if( cTotal > 0 )
		{
			penum->_prgFormats = new FORMATETC[cTotal];
			if( penum->_prgFormats )
			{
				penum->_cTotal = cTotal;
				memcpy(penum->_prgFormats, prgFormats, 
						cTotal * sizeof(FORMATETC));
				*ppenum = penum;
				return NOERROR;
			}	
		}

		delete penum;
	}
	return E_OUTOFMEMORY;
}

//
// CEnumFormatEtc PRIVATE methods
//

/*
 *	CEnumFormatEtc::CEnumFormatEtc()
 *
 *	@mfunc
 *		Private constructor
 */

CEnumFormatEtc::CEnumFormatEtc()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::CEnumFormatEtc");

	_cTotal = 0;
	_crefs	= 1;
	_prgFormats = NULL;
	_iCurrent = 0;
}

/*
 *	CEnumFormatEtc::~CEnumFormatEtc()
 *
 *	@mfunc
 *		Private destructor
 */

CEnumFormatEtc::~CEnumFormatEtc( void )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::~CEnumFormatEtc");

    if( _prgFormats )
        delete _prgFormats;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\font.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module FONT.CPP -- font cache |
 *
 *		Includes font cache, char width cache;
 *		create logical font if not in cache, look up
 *		character widths on an as needed basis (this
 *		has been abstracted away into a separate class
 *		so that different char width caching algos can
 *		be tried.) <nl>
 *		
 *	Owner: <nl>
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Jon Matousek <nl>
 *
 *	History: <nl>
 *		7/26/95		jonmat	cleanup and reorganization, factored out
 *					char width caching code into a separate class.
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */								

#include "_common.h"
#include "_font.h"
#include "_rtfconv.h"	// Needed for GetCodePage
#include "_uspi.h"

#define CLIP_DFA_OVERRIDE   0x40	//  Used to disable Korea & Taiwan font association
#define FF_BIDI		7

ASSERTDATA

// Corresponds to yHeightCharPtsMost in richedit.h
#define yHeightCharMost 32760

// NOTE: this is global across all instances in the same process.
static CFontCache *g_fc;

static FONTINFO *g_pFontInfo = NULL;
static LONG g_cFontInfo = 0;
static LONG g_cFontInfoMax = 0;

//Fonts automatically added to our font table
const WCHAR *szArial			= L"Arial";				// IFONT_ARIAL
const WCHAR *szTimesNewRoman	= L"Times New Roman";	// IFONT_TIMESNEWROMAN
const WCHAR *szSymbol			= L"Symbol";			// IFONT_SYMBOL
const WCHAR *szSystem			= L"System";			// IFONT_SYSTEM
const int cfontsDflt = 4;

//Other fonts that we do use, but aren't automatically added to our font table
const WCHAR *szMicrosSansSerif	= L"Microsoft Sans Serif";
const WCHAR *szMSSansSerif		= L"MS Sans Serif";
const WCHAR *szMangal			= L"Mangal";
const WCHAR *szLatha			= L"Latha";
const WCHAR *szCordiaNew		= L"Cordia New";
const WCHAR *szTahoma			= L"Tahoma";
const WCHAR *szArialUnicode		= L"Arial Unicode MS";
const WCHAR *szWingdings		= L"Wingdings";

#define szFontOfChoice szArial

/*
 *	GetFontNameIndex(pFontName)
 *
 *	@func
 *		return index into global pszFontName table for fontname pFontName.
 *		If fontname isn't in table, add it and return index.
 *
 *	@rdesc
 *		fontname index corresponding to pFontName
 *
 *	@devnote
 *		This uses a linear search, so the most common font names should be
 *		up front. Internally, we use the fontname indices, so the search
 *		isn't done that often.  Note also that the fontname table only grows,
 *		but this is probably OK for most clients.  Else we need ref counting...
 */
SHORT GetFontNameIndex(
	const WCHAR *pFontName)
{
	CLock Lock;					// Wonder how much this slows things down...

	for(LONG i = 0; i < g_cFontInfo; i++)
	{
		// A hash could speed this up if perf turns out poor
		if(!wcscmp(pFontName, g_pFontInfo[i].szFontName))
			return i;
	}

	if(g_cFontInfo + 1 >= g_cFontInfoMax)
	{
		// Note that PvReAlloc() reverts to PvAlloc() if g_pFontInfo is NULL
		FONTINFO *pFI = (FONTINFO *)PvReAlloc((LPVOID)g_pFontInfo,
									sizeof(FONTINFO) * (8 + g_cFontInfo));
		if(!pFI)
			return IFONT_ARIAL;					// Out of memory...

		// Initialize the structure
		ZeroMemory (&pFI[g_cFontInfo], 8 * sizeof(FONTINFO));

												//  attempts to fill them in
		if(!g_cFontInfoMax)						// First allocation
		{
			Assert(IFONT_ARIAL  == 0 && IFONT_TMSNEWRMN == 1 &&
				   IFONT_SYMBOL == 2 && IFONT_SYSTEM == 3);

			pFI[IFONT_ARIAL].szFontName		= szArial;
			pFI[IFONT_TMSNEWRMN].szFontName = szTimesNewRoman;
			pFI[IFONT_SYMBOL].szFontName	= szSymbol;
			pFI[IFONT_SYSTEM].szFontName	= szSystem;
			g_cFontInfo			 = cfontsDflt;
		}
		g_pFontInfo = pFI;
		g_cFontInfoMax += 8;
	}											

	LONG	cb = (wcslen(pFontName) + 1)*sizeof(WCHAR);
	WCHAR *	pch = (WCHAR *)PvAlloc(cb, GMEM_MOVEABLE);

	if(!pch)
		return IFONT_ARIAL;					// Out of memory...

	g_pFontInfo[g_cFontInfo].szFontName = pch;
	CopyMemory((void *)pch, pFontName, cb);
	return g_cFontInfo++;
}

/*
 *	GetFontName(iFont)
 *
 *	@func
 *		return fontname given by g_pFontInfo[iFont].szFontName.
 *
 *	@rdesc
 *		fontname corresponding to fontname index iFont
 */
const WCHAR *GetFontName(
	LONG iFont)
{
	return (iFont < g_cFontInfo) ? g_pFontInfo[iFont].szFontName : NULL;
}

/*
 *	SetFontLegitimateSize(iFont, fUIFont, iSize)
 *
 *	@func
 *		Set the legitimate size (readable smallest size to use) of a given font
 */
BOOL SetFontLegitimateSize(
	LONG 	iFont,
	BOOL	fUIFont,
	BYTE	bSize,
	int		cpg)
{
	if (iFont < g_cFontInfo)
	{
		// Far East wanted to do it per codepage.
		//
		// FUTURE: Bear in mind that this approach is bug-prone. Once there's
		// any new FE font created with different metric from the existing one.
		// Font scaling will not perform well or even broken for such font [wchao].

		g_pFontInfo[iFont].ff.fScaleByCpg = W32->IsFECodePage(cpg);

		if (fUIFont)
		{
			if (!g_pFontInfo[iFont].bSizeUI)
				g_pFontInfo[iFont].bSizeUI = bSize;
			else
				// more than one legit size were updated per font,
				// We fallback to the codepage-driven approach.
				g_pFontInfo[iFont].ff.fScaleByCpg = g_pFontInfo[iFont].bSizeUI != bSize;
		}
		else
		{
			if (!g_pFontInfo[iFont].bSizeNonUI)
				g_pFontInfo[iFont].bSizeNonUI = bSize;
			else
				g_pFontInfo[iFont].ff.fScaleByCpg = g_pFontInfo[iFont].bSizeNonUI != bSize;
		}
		return TRUE;
	}
	return FALSE;
}

BYTE GetFontLegitimateSize(
	LONG	iFont,
	BOOL	fUIFont,
	int		cpg)			// requested size for given codepage
{
	SHORT	iDefFont;
	BYTE	bDefPaf;
	BYTE	yHeight = 0;

	if (iFont < g_cFontInfo && !g_pFontInfo[iFont].ff.fScaleByCpg)
		yHeight = fUIFont ? g_pFontInfo[iFont].bSizeUI : g_pFontInfo[iFont].bSizeNonUI;

	if (!yHeight && fc().GetInfoFlags(iFont).fNonBiDiAscii)
	{
		// non-BiDi ASCII font uses table font (of the same charset) legitimate height

		DWORD	dwSig = GetFontSignatureFromFace(iFont) & ~((fASCII | fFE) >> 8);
		int 	cpg = GetCodePage(GetFirstAvailCharSet(dwSig));
		
		W32->GetPreferredFontInfo(cpg, fUIFont ? true : false, iDefFont, yHeight, bDefPaf);
		SetFontLegitimateSize(iFont, fUIFont ? true : false, yHeight ? yHeight : fUIFont ? 8 : 10, cpg);
	}

	if (!yHeight)
	{
		if (fc().GetInfoFlags(iFont).fThaiDTP)
		{
			cpg = THAI_INDEX;
			fUIFont = FALSE;
		}
		W32->GetPreferredFontInfo(cpg, fUIFont ? true : false, iDefFont, yHeight, bDefPaf);
	}

	return yHeight ? yHeight : fUIFont ? 8 : 10;
}

/*
 *	GetTextCharsetInfoPri(hdc, pFontSig, dwFlags)
 *
 *	@func
 *		Wrapper to GDI's GetTextCharsetInfo. This to handle BiDi old-style fonts
 */
UINT GetTextCharsetInfoPri(
	HDC				hdc,
	FONTSIGNATURE*	pFontSig,
	DWORD			dwFlags)
{
	OUTLINETEXTMETRICA 	otm;
	INT					uCharSet = -1;

	if (pFontSig && GetOutlineTextMetricsA(hdc, sizeof(OUTLINETEXTMETRICA), &otm))
	{
		ZeroMemory (pFontSig, sizeof(FONTSIGNATURE));

		switch (otm.otmfsSelection & 0xFF00)
		{
			case 0xB200:	// Arabic Simplified
			case 0xB300:	// Arabic Traditional
			case 0xB400:	// Arabic Old UDF
				uCharSet = ARABIC_CHARSET; break;
			case 0xB100:	// Hebrew Old style
				uCharSet = HEBREW_CHARSET;
		}
	}
	if (uCharSet == -1)
		uCharSet = GetTextCharsetInfo(hdc, pFontSig, dwFlags);

	if (uCharSet == DEFAULT_CHARSET)
		uCharSet = ANSI_CHARSET;	// never return ambiguous

	return (UINT)uCharSet;
}


/*
 *	GetFontSignatureFromFace(iFont, DWORD* pdwFontSig)
 *
 *	@func
 *		Giving font signature matching the index of given facename.
 *	    This signature may not match the one in Cccs since this is the
 *		signature of the font of given facename. The Cccs one is
 *		per GDI realization.
 *
 *	@rdesc
 *		- font signature if pdwFontSig is NULL.
 *		- If pdwFontSig != NULL. It's a boolean.
 *			ZERO means returned signature is not sensible by following reasons
 *			 1. Bad facename (junk like "!@#$" or name that doesnt exist in the system)
 *			 2. Given face doesnt support even one valid ANSI codepage (symbol fonts i.e, Marlett)
 */
DWORD GetFontSignatureFromFace(
	int 		iFont,
	DWORD*		pdwFontSig)
{
	Assert((unsigned)iFont < (unsigned)g_cFontInfo);

	DWORD 			dwFontSig = g_pFontInfo[iFont].dwFontSig;
	FONTINFO_FLAGS	ff;

	ff.wFlags = g_pFontInfo[iFont].ff.wFlags;

	if(!ff.fCached)
	{
		LOGFONT	lf;
		HDC	  	hdc = GetDC(NULL);
		WCHAR*	pwchTag = lf.lfFaceName;
		int		i = 0;

		ZeroMemory(&lf, sizeof(LOGFONT));
	
		wcscpy(lf.lfFaceName, GetFontName(iFont));

		// exclude Win95's tag name e.g. "Arial(Greek)"
		while (pwchTag[i] && pwchTag[i] != '(')
			i++;
		if(pwchTag[i] && i > 0)
		{
			while (i > 0 && pwchTag[i-1] == 0x20)
				i--;
			pwchTag[i] = 0;
		}

		lf.lfCharSet = DEFAULT_CHARSET;
	
		// obtain a charset supported by given facename
		// to force GDI gives facename priority over charset.
		W32->GetFacePriCharSet(hdc, &lf);	
	
		HFONT hfont = CreateFontIndirect(&lf);
		if(hfont)
		{
			HFONT hfontOld = SelectFont(hdc, hfont);
			WCHAR szNewFaceName[LF_FACESIZE];
	
			GetTextFace(hdc, LF_FACESIZE, szNewFaceName);
	
			if(!wcsicmp(szNewFaceName, lf.lfFaceName) ||		// Got it
				((GetCharFlags(szNewFaceName[0]) & fFE) &&		// or Get back FE font name for English name
				 (GetCharFlags(lf.lfFaceName[0]) & fASCII)))	//	because NT5 supports dual font names.
			{
				CHARSETINFO csi;
	
				// Try to get FONTSIGNATURE data
				UINT 	uCharSet = GetTextCharsetInfoPri(hdc, &(csi.fs), 0);
				DWORD	dwUsb0 = W32->OnWin9x() ? 0 : csi.fs.fsUsb[0];

				if ((csi.fs.fsCsb[0] | dwUsb0) ||
					TranslateCharsetInfo((DWORD *)(DWORD_PTR)uCharSet, &csi, TCI_SRCCHARSET))
				{
					CUniscribe* 	pusp;
					SCRIPT_CACHE	sc = NULL;
					WORD			wGlyph;
	
					dwFontSig = csi.fs.fsCsb[0];

					// Also look at Unicode subrange if available
					// FUTURE: we may want to drive Unicode ranges with a
					// table approach, i.e., use for loop shifting dwUsb0 right
					// to convert each bit into an index into a table of BYTEs
					// that return the appropriate script index for rgCpgCharSet:
					//
					//	for(LONG i = 0; dwUsb0; dwUsb0 >>= 1, i++)
					//	{
					//		static const BYTE iScript[32] = {...};
					//		if(dwUsb0 & 1)
					//			dwFontSig |= W32->GetFontSigFromScript(iScript[i]);
					//	}
					if (dwUsb0 & 0x00008000)
						dwFontSig |= fDEVANAGARI >> 8;
					if (dwUsb0 & 0x00100000)
						dwFontSig |= fTAMIL >> 8;
					if (dwUsb0 & 0x00000400)
						dwFontSig |= fARMENIAN >> 8;
					if (dwUsb0 & 0x04000000)
						dwFontSig |= fGEORGIAN >> 8;

					if((dwFontSig & fCOMPLEX_SCRIPT >> 8) && !(dwFontSig & fHILATIN1 >> 8)
						&& (pusp = GetUniscribe()))
					{
						// signature says no Latin-1 support

						// Search for the 'a' and '0' glyph in the font to determine if the font
						// supports ASCII or European Digit. This is necessary to overcome
						// the font having incomplete font signature.
						//
						if (ScriptGetCMap(hdc, &sc, L"a", 1, 0, &wGlyph) == S_OK)
							dwFontSig |= fASCIIUPR >> 8;

						if (ScriptGetCMap(hdc, &sc, L"0", 1, 0, &wGlyph) == S_OK)
							dwFontSig |= fBELOWX40 >> 8;

						if (!IsBiDiCharSet(uCharSet) &&
							(dwFontSig & (fASCII >> 8)) == fASCII >> 8)
							ff.fNonBiDiAscii = 1;		// non-BiDi ASCII font

						ScriptFreeCache(&sc);
					}

					if (dwFontSig & fHILATIN1 >> 8)
						dwFontSig |= fASCII >> 8;	// fLATIN1 has 3 bits

					// HACK for symbol font. We assign 0x04000(fSYMBOL >> 8) for Symbol font signature.
					if (uCharSet == SYMBOL_CHARSET && !(dwFontSig & 0x3fffffff))
						dwFontSig |= fSYMBOL >> 8;
				}
			}
			else
			{
				ff.fBadFaceName = TRUE;
			}

			TEXTMETRIC tm;

			GetTextMetrics(hdc, &tm);
			ff.fTrueType = tm.tmPitchAndFamily & TMPF_TRUETYPE ? 1 : 0;
			ff.fBitmap = tm.tmPitchAndFamily & (TMPF_TRUETYPE | TMPF_VECTOR | TMPF_DEVICE) ? 0 : 1;

			if (!ff.fBadFaceName && dwFontSig & (fTHAI >> 8))
			{
				// Some heuristic test on Thai fonts.
				// Most Thai fonts will fall to this category currently except for
				// Tahoma and Microsoft Sans Serif.
				ff.fThaiDTP = tm.tmDescent && tm.tmAscent/tm.tmDescent < 3;
			}

			SelectObject(hdc, hfontOld);
			SideAssert(DeleteObject(hfont));
		}
		ReleaseDC(NULL, hdc);
	
		// Cache code pages supported by this font
		ff.fCached = TRUE;
		g_pFontInfo[iFont].dwFontSig = dwFontSig;
		g_pFontInfo[iFont].ff.wFlags = ff.wFlags;
	}

	if (!pdwFontSig)
		return dwFontSig;

	*pdwFontSig = dwFontSig;

	// Exclude bit 30-31 (as system reserved - NT masks 31 as symbol codepage)
	// 22-29 are reserved for alternate ANSI/OEM, as of now we use 21, 22 for Devanagari and Tamil
	return (DWORD)((dwFontSig & 0x3fffffff) && !ff.fBadFaceName);
}

/*
 *	FreeFontNames()
 *
 *	@func
 *		Free fontnames given by g_pFontInfo[i].szFontName allocated by
 *		GetFontNameIndex() as well as g_pFontInfo itself.
 */
void FreeFontNames()
{
	for(LONG i = cfontsDflt; i < g_cFontInfo; i++)
		FreePv((LPVOID)g_pFontInfo[i].szFontName);
	FreePv(g_pFontInfo);
	g_pFontInfo = NULL;
}

SHORT	g_iFontJapanese;
SHORT	g_iFontHangul;
SHORT	g_iFontBig5;
SHORT	g_iFontGB2312;

/*
 *	InitFontCache()
 *	
 *	@func
 *		Initializes font cache.
 *
 *	@devnote
 *		This is exists so reinit.cpp doesn't have to know all about the
 *		font cache.
 */
void InitFontCache()
{
	g_fc = new CFontCache;
	g_fc->Init();
}

/*
 *	FreeFontCache()
 *	
 *	@mfunc
 *		Frees font cache.
 *
 *	@devnote
 *		This is exists so reinit.cpp doesn't have to know all about the
 *		font cache.
 */
void FreeFontCache()
{
	delete g_fc;
	g_fc = NULL;
	FreeFontNames();
}

/*
 *	CFontCache & fc()
 *	
 *	@func
 *		initialize the global g_fc.
 *	@comm
 *		current #defined to store 16 logical fonts and
 *		respective character widths.
 *		
 */
CFontCache & fc()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "fc");
    return *g_fc;
}

FONTINFO_FLAGS CFontCache::GetInfoFlags(int ifont)
{
	if (!g_pFontInfo[ifont].ff.fCached)
		GetFontSignatureFromFace(ifont);

	return g_pFontInfo[ifont].ff;
}


// ===================================  CFontCache  ====================================
/*
 *	CFontCache::Init()
 *	
 *	@mfunc
 *		Initializes font cache.
 *
 *	@devnote
 *		This is not a constructor because something bad seems to happen
 *		if we try to construct a global object.
 */
void CFontCache::Init()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CFontCache::CFontCache");

	_dwAgeNext = 0;
}

/*
 *	CFontCache::MakeHashKey(pCF)
 *	
 *	@mfunc
 *		Build a hash key for quick searches for a CCcs matching
 *		the pCF.
 *		Format:
 *		iFont : 14
 *		Bold/Italic : 2
 *      Height : 16
 *
 */
CCSHASHKEY CFontCache::MakeHashKey(const CCharFormat *pCF)
{
	CCSHASHKEY ccshashkey;
	ccshashkey = pCF->_iFont | ((pCF->_dwEffects & 3) << 14);
	ccshashkey |= pCF->_yHeight << 16;
	return ccshashkey;
}

/*
 *	CFontCache::GetCcs(pCF, dypInch, yPixelsPerInch)
 *	
 *	@mfunc
 *		Search the font cache for a matching logical font and return it.
 *		If a match is not found in the cache,  create one.
 *
 *	@rdesc
 *		A logical font matching the given CHARFORMAT info.
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
CCcs* CFontCache::GetCcs(
	const CCharFormat *const pCF,	//@parm description of desired logical font
	const LONG dypInch,				//@parm Y pixels per inch
	HDC hdc,						//@parm HDC font is to be created for
	BOOL fForceTrueType)			//@parm Force a TrueType font to be used
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CFontCache::GetCcs");
									//  display font
	const CCcs * const	pccsMost = &_rgccs[FONTCACHESIZE - 1];
	CCcs *				pccs;
    CCSHASHKEY			ccshashkey;
	int					iccsHash;

	CCharFormat CF = *pCF;

	if (fForceTrueType)
	{
		//On Win '9x Thai/Vietnamese, you cannot force truetype fonts! Therefore,
		//we will force Tahoma if the font doesn't support the right charset.
		if (W32->OnWin9x())
		{
			UINT acp = GetACP();
			if (acp == 1258 || acp == 874)
			{
				DWORD fontsig = GetFontSignatureFromFace(CF._iFont);
				if (CF._bCharSet == THAI_CHARSET && ((fontsig & fTHAI >> 8) == 0) ||
					CF._bCharSet == VIETNAMESE_CHARSET && ((fontsig & fVIETNAMESE >> 8) == 0) ||
					!g_fc->GetInfoFlags(pCF->_iFont).fTrueType)
				{
					CF._iFont = GetFontNameIndex(szTahoma);
				}
			}
		}
		else if (!g_fc->GetInfoFlags(pCF->_iFont).fTrueType)
			CF._dwEffects |= CFE_TRUETYPEONLY;
	}

	if (hdc == NULL)
		hdc = W32->GetScreenDC();

	// Change CF._yHeight in the case of sub/superscript
	if(CF._dwEffects & (CFE_SUPERSCRIPT | CFE_SUBSCRIPT))
		 CF._yHeight = 2*CF._yHeight/3;

	//Convert CCharFormat into logical units (round)
	CF._yHeight = (CF._yHeight * dypInch + LY_PER_INCH / 2) / LY_PER_INCH;
	if (CF._yHeight == 0)
		CF._yHeight = 1;

	ccshashkey = MakeHashKey(&CF);

	// Check our hash before going sequential.
	iccsHash = ccshashkey % CCSHASHSEARCHSIZE;
	if(ccshashkey == quickHashSearch[iccsHash].ccshashkey)
	{
		pccs = quickHashSearch[iccsHash].pccs;
		if(pccs && pccs->_fValid)
		{
	        if(pccs->Compare(&CF, hdc))
                goto matched;
		}
	}
	else	//Setup this hash hint for next time
		quickHashSearch[iccsHash].ccshashkey = ccshashkey;


	// Sequentially search ccs for same character format
	for(pccs = &_rgccs[0]; pccs <= pccsMost; pccs++)
	{
		if(pccs->_ccshashkey == ccshashkey && pccs->_fValid)
		{
	        if(!pccs->Compare(&CF, hdc))
                continue;

			quickHashSearch[iccsHash].pccs = pccs;

		matched:
			//$ FUTURE: make this work even with wrap around of dwAgeNext
			// Mark as most recently used if it isn't already in use.
			if(pccs->_dwAge != _dwAgeNext - 1)
				pccs->_dwAge = _dwAgeNext++;
			pccs->_cRefs++;		// bump up ref. count
			return pccs;
		}
	}

	// We did not find a match: init a new font cache.
	pccs = GrabInitNewCcs(&CF, hdc);
	quickHashSearch[iccsHash].pccs = pccs;
	pccs->_ccshashkey = ccshashkey;
	pccs->_fForceTrueType = (CF._dwEffects & CFE_TRUETYPEONLY) ? TRUE : FALSE;
	return pccs;
}

/*
 *	CFontCache::GrabInitNewCcs(pCF)
 *	
 *	@mfunc
 *		create a logical font and store it in our cache.
 *
 *	@rdesc
 *		New CCcs created
 */
CCcs* CFontCache::GrabInitNewCcs(
	const CCharFormat * const pCF,	//@parm description of desired logical font
	HDC	hdc)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CFontCache::GrabInitNewCcs");

	DWORD				dwAgeOldest = 0xffffffff;
	CCcs *				pccs;
	const CCcs * const	pccsMost = &_rgccs[FONTCACHESIZE - 1];
	CCcs *				pccsOldest = NULL;

	// Look for unused entry and oldest in use entry
	for(pccs = &_rgccs[0]; pccs <= pccsMost && pccs->_fValid; pccs++)
		if(pccs->_cRefs == 0 && pccs->_dwAge < dwAgeOldest)
		{
			dwAgeOldest = pccs->_dwAge;
			pccsOldest = pccs;
		}

	if(pccs > pccsMost)		// Didn't find an unused entry, use oldest entry
	{
		pccs = pccsOldest;
		if(!pccs)
		{
			AssertSz(FALSE, "CFontCache::GrabInitNewCcs oldest entry is NULL");
			return NULL;
		}
	}
	// Initialize new CCcs
	pccs->_hdc = hdc;
	if(!pccs->Init(pCF))
		return NULL;

	pccs->_cRefs++;
	return pccs;
}

// =============================  CCcs  class  ===================================================
/*
 *	BOOL CCcs::Init()
 *	
 *	@mfunc
 *		Init one font cache object. The global font cache stores
 *		individual CCcs objects.
 */
BOOL CCcs::Init (
	const CCharFormat * const pCF)	//@parm description of desired logical font
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::Init");

	if(_fValid)
		Free();				// recycle already in-use fonts.

	if(MakeFont(pCF))
	{
		_iFont = pCF->_iFont;
		_dwAge = g_fc->_dwAgeNext++;
		_fValid = TRUE;			// successfully created a new font cache.
	}
	return _fValid;
}

/*
 *	void CCcs::Free()
 *	
 *	@mfunc
 *		Free any dynamic memory allocated by an individual font's cache.
 */
void CCcs::Free()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::Free");

	Assert(_fValid);

	_widths.Free();

	if(_hfont)
		DestroyFont();

	if (_sc && g_pusp)
		ScriptFreeCache(&_sc);

	_fValid = FALSE;
	_cRefs = 0;
}

/*
 *	CCcs::BestCharSet(bCharSet, bCharSetDefault)
 *
 *	@mfunc
 *		This function returns the best charset that the currently selected font
 *		is capable of rendering. If the currently selected font cannot support
 *		the requested charset, then the function returns bCharSetDefault, which
 *		is generally taken from the charformat.
 *		
 *	@rdesc
 *		The closest charset to bCharSet that can be rendered by the current
 *		font.
 *
 *	@devnote
 *		Currently this function is only used with plain text, however I don't
 *		believe there is any special reason it couldn't be used to improve
 *		rendering of rich text as well.
 */
BYTE CCcs::BestCharSet(BYTE bCharSet, BYTE bCharSetDefault, int fFontMatching)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::BestCharSet");

	// Does desired charset match currently selected charset or is it
	// supported by the currently selected font?
	if((bCharSet != _bCharSet || !bCharSet) &&
		(fFontMatching == MATCH_CURRENT_CHARSET || !(_dwFontSig & GetFontSig(bCharSet))))
	{
		// If desired charset is not selected and we can't switch to it,
		// switch to fallback charset (probably from backing store).
		return bCharSetDefault;
	}

	// We already match desired charset, or it is supported by the font.
	// Either way, we can just return the requested charset.
	return bCharSet;
}


/* 	
 *	CCcs::FillWidth (ch, dxp)
 *
 *	@mfunc
 *		Fill in this CCcs with metrics info for given device
 *
 *	@rdesc
 *		TRUE if OK, FALSE if failed
 */
BOOL CCcs::FillWidth(
	WCHAR ch, 		//@parm WCHAR character we need a width for.
	LONG &dxp)	//@parm the width of the character
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::FillWidths");
	AssertSz(_hfont, "CCcs::Fill - CCcs has no font");

	HFONT hfontOld = SelectFont(_hdc, _hfont);
	BOOL fRes = _widths.FillWidth(_hdc, ch, _xOverhangAdjust, dxp, _wCodePage, _xAveCharWidth);

	SelectFont(_hdc, hfontOld);
	return fRes;
}

/* 	
 *	BOOL CCcs::MakeFont(pCF)
 *
 *	@mfunc
 *		Wrapper, setup for CreateFontIndirect() to create the font to be
 *		selected into the HDC.
 *
 *	@devnote The pCF here is in logical units
 *
 *	@rdesc
 *		TRUE if OK, FALSE if allocation failure
 */
BOOL CCcs::MakeFont(
	const CCharFormat * const pCF)	//@parm description of desired logical font
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::MakeFont");
	LOGFONT	lf;
	ZeroMemory(&lf, sizeof(lf));

	_bCMDefault = pCF->_dwEffects & CFE_RUNISDBCS ? CVT_LOWBYTE : CVT_NONE;

	_yHeightRequest = pCF->_yHeight;
	_bCharSetRequest = pCF->_bCharSet;

	lf.lfHeight = -_yHeightRequest;

	if(pCF->_wWeight)
		_weight = pCF->_wWeight;
	else
		_weight	= (pCF->_dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;

	lf.lfWeight	 = _weight;
	lf.lfItalic	 = _fItalic = (pCF->_dwEffects & CFE_ITALIC) != 0;
	lf.lfCharSet = _bCMDefault == CVT_LOWBYTE ? ANSI_CHARSET : GetGdiCharSet(pCF->_bCharSet);

	lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
	if (pCF->_dwEffects & CFE_TRUETYPEONLY)
	{
		lf.lfOutPrecision = OUT_TT_ONLY_PRECIS;
		if (!W32->OnWin9x() && g_fc->GetInfoFlags(pCF->_iFont).fTrueType)
			lf.lfOutPrecision = OUT_SCREEN_OUTLINE_PRECIS;
	}
	lf.lfClipPrecision	= CLIP_DEFAULT_PRECIS | CLIP_DFA_OVERRIDE;

	lf.lfPitchAndFamily = _bPitchAndFamily = pCF->_bPitchAndFamily;

	// If family is virtual BiDi family (FF_BIDI), replace by FF_ROMAN
	if((lf.lfPitchAndFamily & 0xF0) == (FF_BIDI << 4))
		lf.lfPitchAndFamily = (FF_ROMAN << 4) | (lf.lfPitchAndFamily & 0xF);

	// If the run is DBCS, that means the font's codepage is not available in
	// this system.  Use the English ANSI codepage instead so we will display
	// ANSI characters correctly.  NOTE: _wCodePage is only used for Win95.
	_wCodePage = (WORD)GetCodePage(lf.lfCharSet);

	wcscpy(lf.lfFaceName, GetFontName(pCF->_iFont));

	// In BiDi system, always create ANSI bitmap font with system charset
	BYTE 	bSysCharSet = W32->GetSysCharSet();

	if (IsBiDiCharSet(bSysCharSet) && lf.lfCharSet == ANSI_CHARSET &&
		fc().GetInfoFlags(pCF->_iFont).fBitmap &&
		!fc().GetInfoFlags(pCF->_iFont).fBadFaceName)
		lf.lfCharSet = bSysCharSet;

	// Reader! A bundle of spagghetti code lies ahead of you!
	// But go on boldly, for these spagghetti are seasoned with
	// lots of comments, and ... good luck to you...

	HFONT	hfontOriginalCharset = NULL;
	BYTE	bOriginalCharset = lf.lfCharSet;
	WCHAR	szNewFaceName[LF_FACESIZE];

	GetFontWithMetrics(&lf, szNewFaceName);

	if(0 != wcsicmp(szNewFaceName, lf.lfFaceName))					
	{
		BOOL fCorrectFont = FALSE;

		if(lf.lfCharSet == SYMBOL_CHARSET)					
		{
			// #1. if the face changed, and the specified charset was SYMBOL,
			//     but the face name exists and suports ANSI, we give preference
			//     to the face name

			lf.lfCharSet = ANSI_CHARSET;

			hfontOriginalCharset = _hfont;
			GetFontWithMetrics(&lf, szNewFaceName);

			if(0 == wcsicmp(szNewFaceName, lf.lfFaceName))
				// That's right, ANSI is the asnwer
				fCorrectFont = TRUE;
			else
				// No, fall back by default; the charset we got was right
				lf.lfCharSet = bOriginalCharset;
		}
		else if(lf.lfCharSet == DEFAULT_CHARSET && _bCharSet == DEFAULT_CHARSET)
		{
			// #2. If we got the "default" font back, we don't know what it means
			// (could be anything) so we veryfy that this guy's not SYMBOL
			// (symbol is never default, but the OS could be lying to us!!!)
			// we would like to veryfy more like whether it actually gave us
			// Japanese instead of ANSI and labeled it "default"...
			// but SYMBOL is the least we can do

			lf.lfCharSet = SYMBOL_CHARSET;
			wcscpy(lf.lfFaceName, szNewFaceName);

			hfontOriginalCharset = _hfont;
			GetFontWithMetrics(&lf, szNewFaceName);

			if(0 == wcsicmp(szNewFaceName, lf.lfFaceName))
				// That's right, it IS symbol!
				// 'correct' the font to the 'true' one,
				//  and we'll get fMappedToSymbol
				fCorrectFont = TRUE;
				
			// Always restore the charset name, we didn't want to
			// question the original choice of charset here
			lf.lfCharSet = bOriginalCharset;
		}
		else if(lf.lfCharSet == ARABIC_CHARSET || lf.lfCharSet == HEBREW_CHARSET)
		{
			DestroyFont();
			wcscpy(lf.lfFaceName, szNewFaceName);
			GetFontWithMetrics(&lf, szNewFaceName);
			fCorrectFont = TRUE;
		}
		else if(_bConvertMode != CVT_LOWBYTE && IsFECharSet(lf.lfCharSet)
			&& !OnWinNTFE() && !W32->OnWin9xFE())
		{
			const WCHAR *pch = NULL;
			if(_bCharSet != lf.lfCharSet && W32->OnWin9x())
			{
				// On Win95 when rendering to PS driver, we'll get something
				// other than what we asked. So try a known font we got from GDI
				switch (lf.lfCharSet)
				{
					case CHINESEBIG5_CHARSET:
						pch = GetFontName(g_iFontBig5);
						break;

					case SHIFTJIS_CHARSET:
						pch = GetFontName(g_iFontJapanese);
						break;

					case HANGEUL_CHARSET:
						pch = GetFontName(g_iFontHangul);
						break;

					case GB2312_CHARSET:
						pch = GetFontName(g_iFontGB2312);
						break;
				}
			}
			else							// FE Font (from Lang pack)
				pch = szNewFaceName;		//  on a nonFEsystem

			if(pch)
				wcscpy(lf.lfFaceName, pch);
			hfontOriginalCharset = _hfont;		

			GetFontWithMetrics(&lf, szNewFaceName);

			if(0 == wcsicmp(szNewFaceName, lf.lfFaceName))
			{
				// That's right, it IS the FE font we want!
				// 'correct' the font to the 'true' one.
				fCorrectFont = TRUE;
				if(W32->OnWin9x())
				{
					// Save up the GDI font names for later printing use
					switch(lf.lfCharSet)
					{
						case CHINESEBIG5_CHARSET:
							g_iFontBig5 = GetFontNameIndex(lf.lfFaceName);
							break;

						case SHIFTJIS_CHARSET:
							g_iFontJapanese = GetFontNameIndex(lf.lfFaceName);
							break;

						case HANGEUL_CHARSET:
							g_iFontHangul = GetFontNameIndex(lf.lfFaceName);
							break;

						case GB2312_CHARSET:
							g_iFontGB2312 = GetFontNameIndex(lf.lfFaceName);
							break;
					}
				}
			}
		}

		if(hfontOriginalCharset)
		{
			// Either keep old font or new one		
			if(fCorrectFont)
			{
				SideAssert(DeleteObject(hfontOriginalCharset));
			}
			else
			{
				// Fall back to original font
				DestroyFont();
				_hfont = hfontOriginalCharset;
				GetMetrics();
			}
			hfontOriginalCharset = NULL;
		}
	}

RetryCreateFont:
	{
		// Could be that we just plain simply get mapped to symbol.
		// Avoid it
		BOOL fMappedToSymbol =	(_bCharSet == SYMBOL_CHARSET &&
								 lf.lfCharSet != SYMBOL_CHARSET);

		BOOL fChangedCharset = (_bCharSet != lf.lfCharSet &&
								lf.lfCharSet != DEFAULT_CHARSET);

		if(fChangedCharset || fMappedToSymbol)
		{
			// Here, the system did not preserve the font language or mapped
			// our non-symbol font onto a symbol font, which will look awful
			// when displayed.  Giving us a symbol font when we asked for a
			// non-symbol font (default can never be symbol) is very bizarre
			// and means that either the font name is not known or the system
			// has gone complete nuts. The charset language takes priority
			// over the font name.  Hence, I would argue that nothing can be
			// done to save the situation at this point, and we have to
			// delete the font name and retry.

			if (fChangedCharset && lf.lfCharSet == THAI_CHARSET && _bCharSet == ANSI_CHARSET)
			{
				// We have charset substitution entries in Thai platforms that
				// will substitute all the core fonts with THAI_CHARSET to
				// ANSI_CHARSET. This is because we dont have Thai in such fonts.
				// Here we'll internally substitute the core font to Thai default
				// font so it matches its underlying THAI_CHARSET request (wchao).

				SHORT	iDefFont;
				BYTE	yDefHeight;
				BYTE	bDefPaf;

				W32->GetPreferredFontInfo(874, TRUE, iDefFont, (BYTE&)yDefHeight, bDefPaf);

				const WCHAR* szThaiDefault = GetFontName(iDefFont);

				if (szThaiDefault)
				{
					DestroyFont();
					wcscpy(lf.lfFaceName, szThaiDefault);
					GetFontWithMetrics(&lf, szNewFaceName);

					goto GetOutOfHere;
				}
			}

			if(!wcsicmp(lf.lfFaceName, szFontOfChoice))
			{
				// We've been here already; no font with an appropriate
				// charset is on the system. Try getting the ANSI one for
				// the original font name. Next time around, we'll null
				// out the name as well!!
				if (lf.lfCharSet == ANSI_CHARSET)
				{
					TRACEINFOSZ("Asking for ANSI ARIAL and not getting it?!");

					// Those Win95 guys have definitely outbugged me
					goto GetOutOfHere;
				}

				DestroyFont();
				wcscpy(lf.lfFaceName, GetFontName(pCF->_iFont));
				lf.lfCharSet = ANSI_CHARSET;
			}
			else
			{
				DestroyFont();
				wcscpy(lf.lfFaceName, szFontOfChoice);
			}
			GetFontWithMetrics(&lf, szNewFaceName);
			goto RetryCreateFont;
		}
    }

GetOutOfHere:
	if (hfontOriginalCharset)
		SideAssert(DeleteObject(hfontOriginalCharset));

	// If we're really really stuck, just get the system font and hope for the best.
	if(!_hfont)
		_hfont = W32->GetSystemFont();

	Assert(_hfont);
	// Cache essential FONTSIGNATURE and GetFontLanguageInfo() information
	_dwFontSig	= 0;

	if(_hfont)
	{
		CHARSETINFO csi;
		HFONT hfontOld = SelectFont(_hdc, _hfont);
		UINT		uCharSet;

		// Try to get FONTSIGNATURE data
		uCharSet = GetTextCharsetInfo(_hdc, &(csi.fs), 0);
		if(!(csi.fs.fsCsb[0] | csi.fs.fsCsb[1] | csi.fs.fsUsb[0]))
		{
			// We should only get here if the font is non-TrueType; See
			// GetTextCharsetInfo() for details. In this case we use
			// TranslateCharsetInfo() to fill in the data for us.
			TranslateCharsetInfo((DWORD *)(DWORD_PTR)uCharSet, &csi, TCI_SRCCHARSET);
		}

		// Cache ANSI code pages supported by this font
		_dwFontSig = csi.fs.fsCsb[0];
		SelectFont(_hdc, hfontOld);
	}

	return TRUE;
}

/*
 *	HFONT CCcs::GetFontWithMetrics (szNewFaceName)
 *	
 *	@mfunc
 *		Get metrics used by the measurer and renderer and the new face name.
 *
 *	@rdesc
 *		HFONT if successful
 */
HFONT CCcs::GetFontWithMetrics (LOGFONT *plf,
	WCHAR* szNewFaceName)
{
	_hfont = CreateFontIndirect(plf);

    if(_hfont)
		GetMetrics(szNewFaceName);

	return (_hfont);
}

/*
 *	CCcs::GetOffset(pCF, lZoomNumerator, lZoomDenominator, pyOffset, pyAdjust);
 *	
 *	@mfunc
 *		Return the offset information for
 *
 *	@rdesc
 *		void
 *
 *	@comm
 *		Return the offset value (used in line height calculations)
 *		and the amount to raise	or lower the text because of superscript
 *		or subscript considerations.
 */
void CCcs::GetOffset(const CCharFormat * const pCF, LONG dypInch,
					 LONG *pyOffset, LONG *pyAdjust)
{
	*pyOffset = 0;
	*pyAdjust = 0;

	if (pCF->_yOffset)
		*pyOffset = MulDiv(pCF->_yOffset, dypInch, LY_PER_INCH);

	if (pCF->_dwEffects & CFE_SUPERSCRIPT)
		*pyAdjust = _yOffsetSuperscript;
	else if (pCF->_dwEffects & CFE_SUBSCRIPT)
		*pyAdjust = _yOffsetSubscript;
}

/*
 *	BOOL CCcs::GetMetrics()
 *	
 *	@mfunc
 *		Get metrics used by the measurer and renderer.
 *
 *	@rdesc
 *		TRUE if successful
 *
 *	@comm
 *		These are in logical coordinates which are dependent
 *		on the mapping mode and font selected into the hdc.
 */
BOOL CCcs::GetMetrics(WCHAR *szNewFaceName)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::GetMetrics");

	HFONT		hfontOld;
	BOOL		fRes = TRUE;
	TEXTMETRIC	tm;

	if (szNewFaceName)
		*szNewFaceName = 0;

	AssertSz(_hfont, "No font has been created.");

	hfontOld = SelectFont(_hdc, _hfont);

    if(!hfontOld)
    {
        DestroyFont();
        return FALSE;
    }

	if (szNewFaceName)
		GetTextFace(_hdc, LF_FACESIZE, szNewFaceName);

	if(!GetTextMetrics(_hdc, &tm))
	{
		SelectFont(_hdc, hfontOld);
    	DestroyFont();
		return FALSE;
	}

	// the metrics, in logical units, dependent on the map mode and font.
	_yHeight		= (SHORT) tm.tmHeight;
	_yDescent		= (SHORT) tm.tmDescent;
	_xAveCharWidth	= (SHORT) tm.tmAveCharWidth;
	_xOverhangAdjust= (SHORT) tm.tmOverhang;

	//FUTURE (keithcu) Get these metrics from the font.
	//FUTURE (keithcu) The height of the line if the font is superscript
	//should be the NORMAL height of the text.
	_yOffsetSuperscript = _yHeight * 2 / 5;
	_yOffsetSubscript = -_yDescent * 3 / 5;

	_xOverhang = 0;
	_xUnderhang	= 0;
	if(_fItalic)
	{
		_xOverhang =  SHORT((tm.tmAscent + 1) >> 2);
		_xUnderhang =  SHORT((tm.tmDescent + 1) >> 2);
	}

	// if fix pitch, the tm bit is clear
	_fFixPitchFont = !(TMPF_FIXED_PITCH & tm.tmPitchAndFamily);

	_bCharSet = tm.tmCharSet;
	_fFECharSet = IsFECharSet(_bCharSet);

	// Use convert-mode proposed by CF, for which we are creating the font and
	// then tweak as necessary below.
	_bConvertMode = _bCMDefault;

	// If SYMBOL_CHARSET is used, use the A APIs with the low bytes of the
	// characters in the run
	if(_bCharSet == SYMBOL_CHARSET)
		_bConvertMode = CVT_LOWBYTE;

	else if (_bConvertMode == CVT_NONE)
		_bConvertMode = W32->DetermineConvertMode(_hdc, tm.tmCharSet );

	W32->CalcUnderlineInfo(_hdc, this, &tm);

	SelectFont(_hdc, hfontOld);
	return fRes;
}

/* 	
 *	CCcs::DestroyFont()
 *
 *	@mfunc
 *		Destroy font handle for this CCcs
 */
void CCcs::DestroyFont()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::DestroyFont");

	// clear out any old font
	if(_hfont)
	{
		SideAssert(DeleteObject(_hfont));
		_hfont = 0;
	}
}

/*
 *	CCcs::Compare (pCF,	lfHeight)
 *
 *	@mfunc
 *		Compares this font cache with the font properties of a
 *      given CHARFORMAT

 *	@devnote The pCF size here is in logical units
 *
 *	@rdesc
 *		FALSE iff did not match exactly.
 */
BOOL CCcs::Compare (
	const CCharFormat * const pCF,	//@parm Description of desired font
	HDC	hdc)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::Compare");

	BOOL result =
		_iFont			== pCF->_iFont &&
		_yHeightRequest	== pCF->_yHeight &&
		(_bCharSetRequest == pCF->_bCharSet || _bCharSet == pCF->_bCharSet) &&
        _weight			== pCF->_wWeight &&
		_fForceTrueType == ((pCF->_dwEffects & CFE_TRUETYPEONLY) ? TRUE : FALSE) &&
	    _fItalic		== ((pCF->_dwEffects & CFE_ITALIC) != 0) &&
		_hdc			== hdc &&
        _bPitchAndFamily == pCF->_bPitchAndFamily &&
		(!(pCF->_dwEffects & CFE_RUNISDBCS) || _bConvertMode == CVT_LOWBYTE);

	return result;
}

// =========================  WidthCache by jonmat  =========================
/*
 *	CWidthCache::CheckWidth(ch, dxp)
 *	
 *	@mfunc
 *		check to see if we have a width for a WCHAR character.
 *
 *	@comm
 *		Used prior to calling FillWidth(). Since FillWidth
 *		may require selecting the map mode and font in the HDC,
 *		checking here first saves time.
 *
 *	@comm
 *		Statistics are maintained to determine when to
 *		expand the cache. The determination is made after a constant
 *		number of calls in order to make calculations faster.
 *
 *	@rdesc
 *		returns TRUE if we have the width of the given WCHAR.
 */
BOOL CWidthCache::CheckWidth (
	const WCHAR ch,	//@parm char, can be Unicode, to check width for.
	LONG &dxp)	//@parm Width of character
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::CheckWidth");
	BOOL	fExist;

	//30,000 FE characters all have the same width
	if (FLookasideCharacter(ch))
	{
		FetchLookasideWidth(ch, dxp);
		return dxp != 0;
	}

	const	CacheEntry * pWidthData = GetEntry ( ch );

	fExist = (ch == pWidthData->ch		// Have we fetched the width?
				&& pWidthData->width);	//  only because we may have ch == 0.

	dxp = fExist ? pWidthData->width : 0;

	if(!_fMaxPerformance)			//  if we have not grown to the max...
	{
		_accesses++;
		if(!fExist)						// Only interesting on collision.
		{
			if(0 == pWidthData->width)	// Test width not ch, 0 is valid ch.
			{
				_cacheUsed++;		// Used another entry.
				AssertSz( _cacheUsed <= _cacheSize+1, "huh?");
			}
			else
				_collisions++;		// We had a collision.

			if(_accesses >= PERFCHECKEPOCH)
				CheckPerformance();	// After some history, tune cache.
		}
	}
#ifdef DEBUG							// Continue to monitor performance
	else
	{
		_accesses++;
		if(!fExist)						// Only interesting on collision.
		{
			if(0 == pWidthData->width)	// Test width not ch, 0 is valid ch.
			{
				_cacheUsed++;		// Used another entry.
				AssertSz( _cacheUsed <= _cacheSize+1, "huh?");
			}
			else
				_collisions++;		// We had a collision.
		}

		if(_accesses > PERFCHECKEPOCH)
		{
			_accesses = 0;
			_collisions = 0;
		}
	}
#endif

	return fExist;
}

/*
 *	CWidthCache::CheckPerformance()
 *	
 *	@mfunc
 *		check performance and increase cache size if deemed necessary.
 *
 *	@devnote
 *		To calculate 25% collision rate, we make use of the fact that
 *		we are only called once every 64 accesses. The inequality is
 *		100 * collisions / accesses >= 25. By converting from 100ths to
 *		8ths, the ineqaulity becomes (collisions << 3) / accesses >= 2.
 *		Substituting 64 for accesses, this becomes (collisions >> 3) >= 2.
 */
void CWidthCache::CheckPerformance()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::CheckPerformance");

	if(_fMaxPerformance)				// Exit if already grown to our max.
		return;

	// Grow the cache when cacheSize > 0 && 75% utilized or approx 25%
	// collision rate
	if (_cacheSize > DEFAULTCACHESIZE &&
		 (_cacheSize >> 1) + (_cacheSize >> 2) < _cacheUsed ||
		(_collisions >> COLLISION_SHIFT) >= 2)
	{
		GrowCache( &_pWidthCache, &_cacheSize, &_cacheUsed );
	}
	_collisions	= 0;				// This prevents wraps but makes
	_accesses	= 0;				//  calc a local rate, not global.
										
	if(_cacheSize >= maxCacheSize)// Note if we've max'ed out
		_fMaxPerformance = TRUE;

	AssertSz( _cacheSize <= maxCacheSize, "max must be 2^n-1");
	AssertSz( _cacheUsed <= _cacheSize+1, "huh?");
}

/*
 *	CWidthCache::GrowCache(ppWidthCache, pCacheSize, pCacheUsed)
 *	
 *	@mfunc
 *		Exponentially expand the size of the cache.
 *
 *	@comm
 *		The cache size must be of the form 2^n as we use a
 *		logical & to get the hash MOD by storing 2^n-1 as
 *		the size and using this as the modulo.
 *
 *	@rdesc
 *		Returns TRUE if we were able to allocate the new cache.
 *		All in params are also out params.
 *		
 */
BOOL CWidthCache::GrowCache(
	CacheEntry **ppWidthCache,	//@parm cache
	INT *		pCacheSize,		//@parm cache's respective size.
	INT *		pCacheUsed)		//@parm cache's respective utilization.
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::GrowCache");

	CacheEntry		*pNewWidthCache, *pOldWidthCache, *pWidthData;
	INT 			j, newCacheSize, newCacheUsed;
	WCHAR			ch;
	
	j = *pCacheSize;						// Allocate cache of 2^n.
	newCacheSize = max ( INITIALCACHESIZE, (j << 1) + 1);
	pNewWidthCache = (CacheEntry *)
			PvAlloc( sizeof(CacheEntry) * (newCacheSize + 1 ), GMEM_ZEROINIT);

	if(pNewWidthCache)
	{
		newCacheUsed = 0;
		*pCacheSize = newCacheSize;			// Update out params.
		pOldWidthCache = *ppWidthCache;
		*ppWidthCache = pNewWidthCache;
		for (; j >= 0; j--)					// Move old cache info to new.
		{
			ch = pOldWidthCache[j].ch;
			if ( ch )
			{
				pWidthData			= &pNewWidthCache [ch & newCacheSize];
				if ( 0 == pWidthData->ch )
					newCacheUsed++;			// Used another entry.
				pWidthData->ch		= ch;
				pWidthData->width	= pOldWidthCache[j].width;
			}
		}
		*pCacheUsed = newCacheUsed;			// Update out param.
											// Free old cache.
		if (pOldWidthCache < &_defaultWidthCache[0] ||
			pOldWidthCache >= &_defaultWidthCache[DEFAULTCACHESIZE+1])
		{
			FreePv(pOldWidthCache);
		}
	}
	return NULL != pNewWidthCache;
}

/*
 *	CWidthCache::FillWidth(hdc, ch, xOverhang, dxp)
 *	
 *	@mfunc
 *		Call GetCharWidth() to obtain the width of the given char.
 *
 *	@comm
 *		The HDC must be setup with the mapping mode and proper font
 *		selected *before* calling this routine.
 *
 *	@rdesc
 *		Returns TRUE if we were able to obtain the widths.
 */
BOOL CWidthCache::FillWidth(
	HDC			hdc,		//@parm Current HDC we want font info for.
	const WCHAR	ch,			//@parm Char to obtain width for.
	const SHORT xOverhang,	//@parm Equivalent to GetTextMetrics() tmOverhang.
	LONG &		dxp,	//@parm Width of character
	UINT		uiCodePage,	//@parm code page for text	
	INT			iDefWidth)	//@parm Default width to use if font calc's zero
							//width. (Handles Win95 problem).
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::FillWidth");

	if (FLookasideCharacter(ch))
	{
		SHORT *pdxp = IN_RANGE(0xAC00, ch, 0xD79F) ? &_dxpHangul : &_dxpHan;
		W32->REGetCharWidth(hdc, ch, pdxp, uiCodePage, xOverhang, iDefWidth);
		dxp = *pdxp;
		return TRUE;
	}

	CacheEntry * pWidthData = GetEntry (ch);
	W32->REGetCharWidth(hdc, ch, &pWidthData->width, uiCodePage, xOverhang, iDefWidth);
	pWidthData->ch = ch;

	dxp = pWidthData->width;
	return TRUE;
}


/*
 *	CWidthCache::Free()
 *	
 *	@mfunc
 *		Free any dynamic memory allocated by the width cache and prepare
 *		it to be recycled.
 */
void CWidthCache::Free()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::Free");

	_fMaxPerformance = FALSE;
	_dxpHangul = _dxpHan = 0;
	_cacheSize		= DEFAULTCACHESIZE;
	_cacheUsed		= 0;
	_collisions		= 0;
	_accesses		= 0;
	if(_pWidthCache != &_defaultWidthCache[0])
	{
		FreePv(_pWidthCache);
		_pWidthCache = &_defaultWidthCache[0];
	}	
	ZeroMemory(_pWidthCache, sizeof(CacheEntry)*(DEFAULTCACHESIZE + 1));
}

/*
 *	CWidthCache::CWidthCache()
 *	
 *	@mfunc
 *		Point the caches to the defaults.
 */
CWidthCache::CWidthCache()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::CWidthCache");

	_pWidthCache = &_defaultWidthCache[0];
}

/*
 *	CWidthCache::~CWidthCache()
 *	
 *	@mfunc
 *		Free any allocated caches.
 */
CWidthCache::~CWidthCache()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::~CWidthCache");

	if (_pWidthCache != &_defaultWidthCache[0])
		FreePv(_pWidthCache);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\hash.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module HASH.C -- RTF control word cache |
 *		#ifdef'ed with RTF_HASHCACHE
 *		
 *	Owner: <nl>
 *		Jon Matousek <nl>
 *
 *	History: <nl>
 *		8/15/95		jonmat first hash-cache for RTF using Brent's Method.
 */
#include "_common.h"

#ifdef RTF_HASHCACHE
					 
#include "hash.h"

ASSERTDATA

extern KEYWORD		rgKeyword[];			// All of the RTF control words.

#define MAX_INAME	3

typedef struct {
	const KEYWORD	*token;
	BOOL			passBit;
} HashEntry;

static HashEntry	*(hashtbl[HASHSIZE]);
static HashEntry	*storage;				// Dynamically alloc for cKeywords.

BOOL				_rtfHashInited = FALSE;

static INT			HashKeyword_Key( const CHAR *szKeyword );

/*
 *	HashKeyword_Insert()
 *	
 *	@func
 *		Insert a KEYWORD into the RTF hash table.
 *	@comm
 *		This function uses the the % for MOD
 *		in order to validate MOD257.
 */
VOID HashKeyword_Insert (
	const KEYWORD *token )//@parm pointer to KEYWORD token to insert.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Insert");

	INT			index, step, position,
				cost, source, sink, index1,
				step1, temp;
	
	BOOL		tmpPassBit;	
	
	static INT	totalKeys = 0;

	CHAR 		*szKeyword;
	
	HashEntry	*np;
	
	AssertSz ( _rtfHashInited, "forgot to call HashKeyword_Init()");
	AssertSz ( totalKeys <= HASHSIZE * 0.7, "prime not large enough to hold total keys");
	
	szKeyword = token->szKeyword;
	
	np = &storage[totalKeys++];
	np->token = token;

	index = HashKeyword_Key(szKeyword) % HASHSIZE;  // Get keys.
	step = 1 + (HashKeyword_Key(szKeyword) % (HASHSIZE-1));

	position = 1;
	cost = HASHSIZE;								// The max collisions for any.
	while(hashtbl[index]!=NULL)						// Find empty slot.
	{
		position++;									// How many collisions.

		// For the keyword stored here, calc # times before it is found.
		temp=1;
		step1= 1+(HashKeyword_Key(hashtbl[index]->token->szKeyword) % (HASHSIZE-1));
		index1= (index+step1)%HASHSIZE;
		while(hashtbl[index1] !=NULL)
		{
			index1=(index1+step1)%HASHSIZE;
			temp++;
		}
		
		// Incremental cost computation, minimizes average # of collisions
		//  for both keywords.
		if (cost>position+temp)
		{
			source=index;
			sink=index1;
			cost=position+temp;
		}
		
		// There will be something stored beyound here, set the passBit.
		hashtbl[index]->passBit=1;

		// Next index to search for empty slot.
		index=(index+step)%HASHSIZE;

	}
	
	if (position<=cost)
	{
		source=sink=index;
		cost=position;
	}
	hashtbl[sink] = hashtbl[source];
	hashtbl[source] = np;
	if (hashtbl[sink] && hashtbl[source])	// jOn hack, we didn't really
	{										//  want to swap pass bits.
		tmpPassBit = hashtbl[sink]->passBit;
		hashtbl[sink]->passBit = hashtbl[source]->passBit;
		hashtbl[source]->passBit = tmpPassBit;
	}

}

/*
 *	static HashKeyword_Key()
 *	
 *	@func
 *		Calculate the hash key.
 *	@comm
 *		Just add up the first few characters.
 *	@rdesc
 *		The hash Key for calculating the index and step.
 */
static INT HashKeyword_Key(
	const CHAR *szKeyword ) //@parm C string to create hash key for.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Key");

	INT i, tot = 0;
	
	/* Just add up first few characters. */
	for (i = 0; i < MAX_INAME && *szKeyword; szKeyword++, i++)
			tot += (UCHAR) *szKeyword;
	return tot;
}	

/*
 *	HashKeyword_Fetch()
 *	
 *	@func
 *		Look up a KEYWORD with the given szKeyword.
 *	@devnote
 *		We have a hash table of size 257. This allows for
 *		the use of very fast routines to calculate a MOD 257.
 *		This gives us a significant increase in performance
 *		over a binary search.
 *	@rdesc
 *		A pointer to the KEYWORD, or NULL if not found.
 */
const KEYWORD *HashKeyword_Fetch (
	const CHAR *szKeyword ) //@parm C string to search for.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Fetch");

	INT 		index, step;
	
	HashEntry *	hashTblPtr;

	BYTE *		pchCandidate;
	BYTE *		pchKeyword;
	
	INT			nComp;

	CHAR		firstChar;

	INT			hashKey;

	AssertSz( HASHSIZE == 257, "Remove custom MOD257.");
	
	firstChar = *szKeyword;
	hashKey = HashKeyword_Key(szKeyword);	// For calc'ing 'index' and 'step'
	
	//index = hashKey%HASHSIZE;				// First entry to search.
	index = MOD257(hashKey);				// This formula gives us 18% perf.

	hashTblPtr = hashtbl[index];			// Get first entry.
	if ( hashTblPtr != NULL )				// Something there?
	{
											// Compare 2 C strings.								
		pchCandidate = (BYTE *)hashTblPtr->token->szKeyword;
		if ( firstChar == *pchCandidate )
		{
			pchKeyword	 = (BYTE *)szKeyword;
			while (!(nComp = *pchKeyword - *pchCandidate)	// Be sure to match
				&& *pchKeyword)								//  terminating 0's
			{
				pchKeyword++;
				pchCandidate++;
			}
											// Matched?
			if ( 0 == nComp )
				return hashTblPtr->token;
		}
		
		if ( hashTblPtr->passBit==1 )		// passBit=>another entry to test
		{

			// step = 1+(hashKey%(HASHSIZE-1));// Calc 'step'
			step = 1 + MOD257_1(hashKey);

											// Get second entry to check.
			index += step;
			index = MOD257(index);
			hashTblPtr = hashtbl[index];

			while (hashTblPtr != NULL )		// While something there.
			{
											// Compare 2 C strings.								
				pchCandidate = (BYTE *)hashTblPtr->token->szKeyword;
				if ( firstChar == *pchCandidate )
				{
					pchKeyword	 = (BYTE *)szKeyword;
					while (!(nComp = *pchKeyword - *pchCandidate)
						&& *pchKeyword)
					{
						pchKeyword++;
						pchCandidate++;
					}
											// Matched?
					if ( 0 == nComp )
						return hashTblPtr->token;
				}

				if ( !hashTblPtr->passBit )// Done searching?
					break;
											// Get next entry.
				index += step;
				index = MOD257(index);
				hashTblPtr = hashtbl[index];
			}
		}
	}
	
	return NULL;
}

/*
 *	HashKeyword_Init()
 *	
 *	@func
 *		Load up and init the hash table with RTF control words.
 *	@devnote
 *		_rtfHashInited will be FALSE if anything here fails.
 */
VOID HashKeyword_Init( )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Init");

	extern SHORT cKeywords;			// How many RTF keywords we currently recognize.

	INT i;

	AssertSz( _rtfHashInited == FALSE, "Only need to init this once.");

									// Create enough storage for cKeywords
	storage = (HashEntry *) PvAlloc( sizeof(HashEntry) * cKeywords, fZeroFill );

									// Load in all of the RTF control words.
	if ( storage )
	{
		_rtfHashInited = TRUE;

		for (i = 0; i < cKeywords; i++ )
		{
			HashKeyword_Insert(&rgKeyword[i]);
		}
#ifdef DEBUG						// Make sure we can fetch all these keywords.
		for (i = 0; i < cKeywords; i++ )
		{
			AssertSz ( &rgKeyword[i] == HashKeyword_Fetch ( rgKeyword[i].szKeyword ),
				"Keyword Hash is not working.");
		}
#endif
	}
}

#endif	// RTF_HASHCACHE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\hash.h ===
#ifndef _HASH_H
#define _HASH_H

#include "tokens.h"

#define		HASHSIZE 	257	// DO NOT CHANGE!
						// this prime has been chosen because
						// there is a fast MOD257
						// if you use the % operator the thing
						// slows down to just about what a binary search is.

#define			MOD257(k) ((k) - ((k) & ~255) - ((k) >> 8) )	// MOD 257
#define			MOD257_1(k) ((k) & 255)	// MOD (257 - 1)

extern BOOL		_rtfHashInited;
VOID			HashKeyword_Init( );

VOID			HashKeyword_Insert ( const KEYWORD *token );
const KEYWORD	*HashKeyword_Fetch ( const CHAR *szKeyword );

#endif	// _HASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\host.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	HOST.C	-- Text Host for CreateWindow() Rich Edit Control |
 *		Implements CTxtWinHost message and ITextHost interfaces
 *		
 *	Original Author: <nl>
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	History: <nl>
 *		8/1/95   ricksa  Documented and brought to new ITextHost definition
 *		10/28/95 murrays cleaned up and moved default char/paraformat cache
 *						 cache code into text services
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "_host.h"
#include "imm.h"
#include "_format.h"
#include "_edit.h"
#include "_cfpf.h"

ASSERTDATA

//////////////////////////// System Window Procs ////////////////////////////
LRESULT CreateAnsiWindow(
	HWND hwnd,
	UINT msg,
	CREATESTRUCTA *pcsa,
	BOOL fIs10)
{
	AssertSz((WM_CREATE == msg) || (WM_NCCREATE == msg),
		"CreateAnsiWindow called with invalid message!");

	CTxtWinHost *phost = (CTxtWinHost *) GetWindowLongPtr(hwnd, ibPed);

	// The only thing we need to convert are the strings,
	// so just do a structure copy and replace the strings.
	CREATESTRUCTW csw = *(CREATESTRUCTW *)pcsa;
	CStrInW strinwName(pcsa->lpszName, GetKeyboardCodePage());
	CStrInW strinwClass(pcsa->lpszClass, CP_ACP);

	csw.lpszName = (WCHAR *)strinwName;
	csw.lpszClass = (WCHAR *)strinwClass;

	if (!phost)
	{
		// No host yet so create it
		phost = CTxtWinHost::OnNCCreate(hwnd, &csw, TRUE, fIs10);
	}

	if (WM_NCCREATE == msg)
	{
		return phost != NULL;
	}

	if (NULL == phost)
	{
		// For WM_CREATE -1 indicates failure
		return -1;
	}

	// Do the stuff specific to create
	return phost->OnCreate(&csw);
		
}

CTxtWinHost *g_phostdel = NULL;

void DeleteDanglingHosts()
{
	CLock lock;
	CTxtWinHost *phostdel = g_phostdel;
	while(phostdel)
	{
		CTxtWinHost *phost = phostdel;
		phostdel = phostdel->_pnextdel;
		CTxtWinHost::OnNCDestroy(phost);
	}
	g_phostdel = NULL;
}

extern "C" LRESULT CALLBACK RichEdit10ANSIWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGINPARAM(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichEdit10ANSIWndProc", msg);

	if ((WM_CREATE == msg) || (WM_NCCREATE == msg))
	{
		return CreateAnsiWindow(hwnd, msg, (CREATESTRUCTA *) lparam, TRUE);
	}

    // ignore WM_DESTROY and wait for WM_NCDESTROY
	if (WM_DESTROY == msg)
	{
		CLock lock;
		CTxtWinHost *phost = (CTxtWinHost *) GetWindowLongPtr(hwnd, ibPed);
		phost->_pnextdel = g_phostdel;
		g_phostdel = phost;
		return 0;
	}

	if (WM_NCDESTROY == msg)
	    msg = WM_DESTROY;

	return W32->ANSIWndProc( hwnd, msg, wparam, lparam, TRUE);
}

LRESULT CALLBACK RichEditANSIWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGINPARAM(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichEditANSIWndProc", msg);

	if ((WM_CREATE == msg) || (WM_NCCREATE == msg))
	{
		return CreateAnsiWindow(hwnd, msg, (CREATESTRUCTA *) lparam, FALSE);
	}

	return W32->ANSIWndProc( hwnd, msg, wparam, lparam, FALSE);

}

/*
 *	RichEditWndProc (hwnd, msg, wparam, lparam)
 *
 *	@mfunc
 *		Handle window messages pertinent to the host and pass others on to
 *		text services.
 *
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CALLBACK RichEditWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichEditWndProc");

	LRESULT lres = 0;
	HRESULT hr;
	SETTEXTEX st;

	CTxtWinHost *phost = hwnd ? (CTxtWinHost *) GetWindowLongPtr(hwnd, ibPed) : NULL;

	#ifdef DEBUG
	Tracef(TRCSEVINFO, "hwnd %lx, msg %lx, wparam %lx, lparam %lx", hwnd, msg, wparam, lparam);
	#endif	// DEBUG

	switch(msg)
	{
	case WM_NCCREATE:
		return CTxtWinHost::OnNCCreate(hwnd, (CREATESTRUCT *)lparam, FALSE, FALSE) != NULL;

	case WM_CREATE:
		// We may be on a system with no WM_NCCREATE (e.g. WinCE)
		if (!phost)
		{
			phost = CTxtWinHost::OnNCCreate(hwnd, (CREATESTRUCT *) lparam, FALSE, FALSE);
		}

		break;

	case WM_DESTROY:
		if(phost)
		{
			CLock lock;
			CTxtWinHost *phostdel = g_phostdel;
			if (phostdel == phost)
				g_phostdel = phost->_pnextdel;
			else
			{
				while (phostdel)
				{
					if (phostdel->_pnextdel == phost)
					{
						phostdel->_pnextdel = phost->_pnextdel;
						break;
					}
					phostdel = phostdel->_pnextdel;
				}
			}

			CTxtWinHost::OnNCDestroy(phost);
		}
		return 0;
	}

	if (!phost)
		return ::DefWindowProc(hwnd, msg, wparam, lparam);

	// In certain out-of-memory situations, clients may try to re-enter us
	// with calls.  Just bail on the call if we don't have a text services
	// pointer.
	if(!phost->_pserv)
		return 0;

	// stabilize ourselves
	phost->AddRef();

	// Handle mouse/keyboard/scroll message-filter notifications
	if(phost->_fKeyMaskSet || phost->_fMouseMaskSet || phost->_fScrollMaskSet)
	{
		// We may need to fire a MSGFILTER notification.  In the tests
		// below, we check to see if mouse, keyboard, or scroll events
		// are hit and enabled for notifications.  If so, we fire the
		// msgfilter notification.  The list of events was generated
		// from	RichEdit 1.0 sources. The code gets all keyboard and
		// mouse actions, whereas the RichEdit 1.0 code only got
		// WM_KEYDOWN, WM_KEYUP, WM_CHAR, WM_SYSKEYDOWN, WM_SYSKEYUP,
		// WM_MOUSEACTIVATE, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_MOUSEMOVE,
		// WM_RBUTTONDBLCLK, WM_RBUTTONDOWN, WM_RBUTTONUP. Note that the
		// following code doesn't send a notification for AltGr characters
		// (LeftCtrl+RightAlt+vkey), since some hosts misinterpret these
		// characters as hot keys.
		if (phost->_fKeyMaskSet && IN_RANGE(WM_KEYFIRST, msg, WM_KEYLAST) &&
				(msg != WM_KEYDOWN ||
				 (GetKeyboardFlags() & (ALT | CTRL)) != (LCTRL | RALT)) || // AltGr
			phost->_fMouseMaskSet && (msg == WM_MOUSEACTIVATE ||
							IN_RANGE(WM_MOUSEFIRST, msg, WM_MOUSELAST)) ||
			phost->_fScrollMaskSet && IN_RANGE(WM_HSCROLL, msg, WM_VSCROLL))
		{
			MSGFILTER msgfltr;

			ZeroMemory(&msgfltr.nmhdr, sizeof(NMHDR));
			msgfltr.msg = msg;
			msgfltr.wParam = wparam;
			msgfltr.lParam = lparam;

			// The MSDN document on MSGFILTER is wrong, if the
			// send message returns 0 (NOERROR via TxNotify in this
			// case), it means process the event.  Otherwise, return.
			//
			// The documentation states the reverse.
			//
			if(phost->TxNotify(EN_MSGFILTER, &msgfltr) == NOERROR)
			{
				// Since client is allowed to modify the contents of
				// msgfltr, we must use the returned values.
				msg	   = msgfltr.msg;
				wparam = msgfltr.wParam;
				lparam = msgfltr.lParam;
			}
			else
			{
				lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
				goto Exit;
			}
		}
	}

	switch(msg)
	{
    case EM_SETEVENTMASK:
		phost->_fKeyMaskSet = !!(lparam & ENM_KEYEVENTS);
		phost->_fMouseMaskSet = !!(lparam & ENM_MOUSEEVENTS);
		phost->_fScrollMaskSet = !!(lparam & ENM_SCROLLEVENTS);
		goto serv;

	case EM_SETSEL:

		// When we are in a dialog box that is empty, EM_SETSEL will not select
		// the final always existing EOP if the control is rich.
		if (phost->_fUseSpecialSetSel &&
			((CTxtEdit *)phost->_pserv)->GetAdjustedTextLength() == 0 &&
			wparam != -1)
		{
			lparam = 0;
			wparam = 0;
		}
		goto serv;

	case WM_CREATE:
		{
			//bug fix #5386
			//need to convert ANSI -> UNICODE for Win9x systems which didn't go through
			//the ANSI wndProc
			if (W32->OnWin9x() && !phost->_fANSIwindow)
			{
				CREATESTRUCT cs = *(CREATESTRUCT*)lparam;
				CStrInW strinwName(((CREATESTRUCTA*)lparam)->lpszName, GetKeyboardCodePage());
				CStrInW strinwClass(((CREATESTRUCTA*)lparam)->lpszClass, CP_ACP);

				cs.lpszName = (WCHAR*)strinwName;
				cs.lpszClass = (WCHAR*)strinwClass;
				
				lres = phost->OnCreate(&cs);
			}
			else
				lres = phost->OnCreate((CREATESTRUCT*)lparam);			
		}
		break;
	
	case WM_KEYDOWN:		
		lres = phost->OnKeyDown((WORD) wparam, (DWORD) lparam);
		if(lres)							// Didn't process code:
			goto serv;						//  give it to text services
		
		break;		

	case WM_GETTEXT:
		GETTEXTEX gt;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gt );
		goto serv;

	case WM_COPYDATA:
		PCOPYDATASTRUCT pcds;
		pcds = (PCOPYDATASTRUCT) lparam;
		if (HIWORD(pcds->dwData) == 1200 &&		// Unicode code page
			LOWORD(pcds->dwData) == WM_SETTEXT)	// Only message we know about
		{
			st.flags = ST_CHECKPROTECTION;
			st.codepage = 1200;
			msg = EM_SETTEXTEX;
			wparam = (WPARAM) &st;
			lparam = (LPARAM) pcds->lpData;
			goto serv;
		}
		else
			lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;

	case WM_GETTEXTLENGTH:
		GETTEXTLENGTHEX gtl;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gtl );
		goto serv;

	case WM_CHAR:
		if(GetKeyboardFlags() & ALTNUMPAD)	// Handle Alt+0ddd in CTxtEdit
			goto serv;						//  so that other hosts also work

		else if (W32->OnWin9x() || phost->_fANSIwindow)
		{
			CW32System::WM_CHAR_INFO wmci;
			wmci._fAccumulate = phost->_fAccumulateDBC != 0;
			W32->AnsiFilter( msg, wparam, lparam, (void *) &wmci, 
				((CTxtEdit *)phost->_pserv)->Get10Mode() );
			if (wmci._fLeadByte)
			{
				phost->_fAccumulateDBC = TRUE;
				phost->_chLeadByte = wparam << 8;
				goto Exit;					// Wait for trail byte
			}
			else if (wmci._fTrailByte)
			{
				wparam = phost->_chLeadByte | wparam;
				phost->_fAccumulateDBC = FALSE;
				phost->_chLeadByte = 0;
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
		}

		lres = phost->OnChar((WORD) wparam, (DWORD) lparam);
		if(lres)							// Didn't process code:
			goto serv;						//  give it to text services
		break;

	case WM_ENABLE:
		if(!wparam ^ phost->_fDisabled)
		{
			// Stated of window changed so invalidate it so it will
			// get redrawn.
			InvalidateRect(phost->_hwnd, NULL, TRUE);
			phost->SetScrollBarsForWmEnable(wparam);
		}
		phost->_fDisabled = !wparam;				// Set disabled flag
		lres = 0;							// Return value for message
											// Fall thru to WM_SYSCOLORCHANGE?
	case WM_SYSCOLORCHANGE:
		phost->OnSysColorChange();
		goto serv;							// Notify text services that
											//  system colors have changed
	case WM_GETDLGCODE:
		lres = phost->OnGetDlgCode(wparam, lparam);
		break;

	case EM_GETOPTIONS:
		lres = phost->OnGetOptions();
		break;

	case EM_GETPASSWORDCHAR:
		lres = phost->_chPassword;
		break;

	case EM_GETRECT:
		phost->OnGetRect((LPRECT)lparam);
		break;

	case EM_HIDESELECTION:
		if(lparam)
		{
			DWORD dwPropertyBits = 0;

			phost->_dwStyle |= ES_NOHIDESEL;
			if(wparam)
			{
				phost->_dwStyle &= ~ES_NOHIDESEL;
				dwPropertyBits = TXTBIT_HIDESELECTION;
			}

			// Notify text services of change in status.
			phost->_pserv->OnTxPropertyBitsChange(TXTBIT_HIDESELECTION,
				dwPropertyBits);
		}
		goto serv;

	case EM_SETBKGNDCOLOR:
		lres = (LRESULT) phost->_crBackground;
		phost->_fNotSysBkgnd = !wparam;
		phost->_crBackground = (COLORREF) lparam;

		if(wparam)
			phost->_crBackground = GetSysColor(COLOR_WINDOW);

		if(lres != (LRESULT) phost->_crBackground)
		{
			// Notify text services that color has changed
			LRESULT	lres1 = 0;
			phost->_pserv->TxSendMessage(WM_SYSCOLORCHANGE, 0, 0, &lres1);
			phost->TxInvalidateRect(NULL, TRUE);
		}
		break;

    case WM_STYLECHANGING:
		// Just pass this one to the default window proc
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;

	case WM_STYLECHANGED:
		//
		// For now, we only interested in GWL_EXSTYLE Transparent mode changed.
		// This is to fix Bug 753 since Window95 is not passing us
		// the WS_EX_TRANSPARENT.
		//
		lres = 1;
		if(GWL_EXSTYLE == wparam)
		{
			LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lparam;
			if(phost->IsTransparentMode() != (BOOL)(lpss->styleNew & WS_EX_TRANSPARENT))
			{
				phost->_dwExStyle = lpss->styleNew;
				((CTxtEdit *)phost->_pserv)->OnTxBackStyleChange(TRUE);

				// Return 0 to indicate we have handled this message
				lres = 0;
			}
		}
		break;

	case EM_SHOWSCROLLBAR:
		{
			Assert(wparam == SB_VERT || wparam == SB_HORZ);
			DWORD dwBit = wparam == SB_VERT ? WS_VSCROLL : WS_HSCROLL;

			phost->_dwStyle |= dwBit;
			if(!lparam)
				phost->_dwStyle &= ~dwBit;

			phost->TxShowScrollBar((int) wparam, lparam);
			if (lparam)
			    phost->TxSetScrollRange((int) wparam, 0, 0, TRUE);
		}
		break;

	case EM_SETOPTIONS:
		phost->OnSetOptions((WORD) wparam, (DWORD) lparam);
		lres = (phost->_dwStyle & ECO_STYLES);
		if(phost->_fEnableAutoWordSel)
			lres |= ECO_AUTOWORDSELECTION;
		break;

	case EM_SETPASSWORDCHAR:
		if(phost->_chPassword != (TCHAR)wparam)
		{
			phost->_chPassword = (TCHAR)wparam;
			phost->_pserv->OnTxPropertyBitsChange(TXTBIT_USEPASSWORD,
				phost->_chPassword ? TXTBIT_USEPASSWORD : 0);
		}
		break;

	case EM_SETREADONLY:
		phost->OnSetReadOnly(BOOL(wparam));
		lres = 1;
		break;

	case EM_SETRECTNP:
	case EM_SETRECT:
		phost->OnSetRect((LPRECT)lparam, wparam == 1, msg == EM_SETRECT);
		break;
		
	case WM_SIZE:
		phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		lres = phost->OnSize(hwnd, wparam, (int)LOWORD(lparam), (int)HIWORD(lparam));
		break;

	case WM_WINDOWPOSCHANGING:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		// richedit 1.0 didn't cause InvalidateRect which OnSunkenWindowPosChanging will do
		if(phost->TxGetEffects() == TXTEFFECT_SUNKEN && !((CTxtEdit *)phost->_pserv)->Get10Mode())
			phost->OnSunkenWindowPosChanging(hwnd, (WINDOWPOS *) lparam);
		break;

	case WM_SETCURSOR:
		//			Only set cursor when over us rather than a child; this
		//			helps prevent us from fighting it out with an inplace child
		if((HWND)wparam == hwnd)
		{
			if(!(lres = ::DefWindowProc(hwnd, msg, wparam, lparam)))
			{
				POINT pt;
				GetCursorPos(&pt);
				::ScreenToClient(hwnd, &pt);
				phost->_pserv->OnTxSetCursor(
					DVASPECT_CONTENT,	
					-1,
					NULL,
					NULL,
					NULL,
					NULL,
					NULL,			// Client rect - no redraw
					pt.x,
					pt.y);
				lres = TRUE;
			}
		}
		break;

	case WM_SHOWWINDOW:
		hr = phost->OnTxVisibleChange((BOOL)wparam);
		break;

	case WM_NCPAINT:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		if(phost->TxGetEffects() == TXTEFFECT_SUNKEN && dwMajorVersion < VERS4)
		{
			HDC hdc = GetDC(hwnd);
			if(hdc)
			{
				phost->DrawSunkenBorder(hwnd, hdc);
				ReleaseDC(hwnd, hdc);
			}
		}
		break;

	case WM_PRINTCLIENT:
	case WM_PAINT:
		{
			PAINTSTRUCT ps;
			HPALETTE hpalOld = NULL;
			HDC hdc = BeginPaint(hwnd, &ps);
			RECT rcClient;

			// Set up the palette for drawing our data
			if(phost->_hpal)
			{
				hpalOld = SelectPalette(hdc, phost->_hpal, TRUE);
				RealizePalette(hdc);
			}

			// Since we are using the CS_PARENTDC style, make sure
			// the clip region is limited to our client window.
			GetClientRect(hwnd, &rcClient);
			SaveDC(hdc);
			IntersectClipRect(hdc, rcClient.left, rcClient.top, rcClient.right,
				rcClient.bottom);

#if 0		// Useful for debugging
			TCHAR rgch[512];
			wsprintf(rgch, TEXT("Paint : (%d, %d, %d, %d)\n"),
							rcClient.left,
							rcClient.top,
							rcClient.right,
							rcClient.bottom);
			OutputDebugString(rgch);
#endif

			phost->_pserv->TxDraw(
				DVASPECT_CONTENT,  		// Draw Aspect
				-1,						// Lindex
				NULL,					// Info for drawing optimazation
				NULL,					// target device information
				hdc,					// Draw device HDC
				NULL, 				   	// Target device HDC
				(const RECTL *) &rcClient,// Bounding client rectangle
				NULL,	                // Clipping rectangle for metafiles
				&ps.rcPaint,			// Update rectangle
				NULL, 	   				// Call back function
				NULL,					// Call back parameter
				TXTVIEW_ACTIVE);		// What view - the active one!

			// Restore palette if there is one
#ifndef PEGASUS
			if(hpalOld)
				SelectPalette(hdc, hpalOld, TRUE);
#endif

			if(phost->TxGetEffects() == TXTEFFECT_SUNKEN && dwMajorVersion < VERS4)
				phost->DrawSunkenBorder(hwnd, hdc);

			RestoreDC(hdc, -1);
			EndPaint(hwnd, &ps);
		}
		break;

	case EM_SETMARGINS:

		phost->OnSetMargins(wparam, LOWORD(lparam), HIWORD(lparam));
		break;

	case EM_SETPALETTE:

		// Application is setting a palette for us to use.
		phost->_hpal = (HPALETTE) wparam;

		// Invalidate the window & repaint to reflect the new palette.
		InvalidateRect(hwnd, NULL, FALSE);
		break;

	default:
serv:
		hr = phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		if(hr == S_FALSE)
		{			
			// Message was not processed by text services so send it
			// to the default window proc.
			lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		}
	}

Exit:
	phost->Release();
	return lres;
}
												
static BOOL GetIconic(
	HWND hwnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetIconic");

	while(hwnd)
	{
		if(IsIconic(hwnd))
			return TRUE;
		hwnd = GetParent(hwnd);
	}
	return FALSE;
}

//////////////// CTxtWinHost Creation/Initialization/Destruction ///////////////////////

/*
 *	CTxtWinHost::OnNCCreate (hwnd, pcs)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message (see remain.c)
 */
CTxtWinHost *CTxtWinHost::OnNCCreate(
	HWND hwnd,
	const CREATESTRUCT *pcs,
	BOOL fIsAnsi,
	BOOL fIs10Mode)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnNCCreate");

#if defined DEBUG && !defined(PEGASUS)
	GdiSetBatchLimit(1);
#endif

	CTxtWinHost *phost = new CTxtWinHost();

	if(!phost)
		return 0;

	CREATESTRUCT cs = *pcs;			// prefer C++ compiler not to modify constant

	//bug fix #5386
	// Window wasn't created with the Richedit20A window class
	// and we are under Win9x, need to convert string to UNICODE
	CStrInW strinwName(((LPSTR)pcs->lpszName), GetKeyboardCodePage());
	CStrInW strinwClass(((LPSTR)pcs->lpszClass), CP_ACP);
	if (!fIsAnsi && W32->OnWin9x())
	{
		cs.lpszName = (WCHAR *)strinwName;
		cs.lpszClass = (WCHAR *)strinwClass;
	}

	// Stores phost in associated window data
	if(!phost->Init(hwnd, (const CREATESTRUCT*)&cs, fIsAnsi, fIs10Mode))
	{
		phost->Shutdown();
		delete phost;
		phost = NULL;
	}
	return phost;
}

/*
 *	CTxtWinHost::OnNCDestroy (phost)
 *
 *	@mfunc
 *		Static global method to handle WM_CREATE message
 *
 *	@devnote
 *		phost ptr is stored in window data (GetWindowLong())
 */
void CTxtWinHost::OnNCDestroy(
	CTxtWinHost *phost)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnNCDestroy");

	phost->Shutdown();
	phost->Release();
}

/*
 *	CTxtWinHost::CTxtWinHost()
 *
 *	@mfunc
 *		constructor
 */
CTxtWinHost::CTxtWinHost()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::CTxtWinHost");

#ifndef NOACCESSIBILITY
    _pTypeInfo = NULL;
#endif

	_fRegisteredForDrop = FALSE;
	_crefs = 1;	
	if(!_fNotSysBkgnd)
		_crBackground = GetSysColor(COLOR_WINDOW);
}

/*
 *	CTxtWinHost::~CTxtWinHost()
 *
 *	@mfunc
 *		destructor
 */
CTxtWinHost::~CTxtWinHost()
{
	AssertSz(_pserv == NULL,
		"CTxtWinHost::~CTxtWinHost - shutdown not called till destructor");

	if(_pserv)
		Shutdown();
}

/*
 *	CTxtWinHost::Shutdown()
 *
 *	@mfunc	Shut down this object, but doesn't delete memory
 */
void CTxtWinHost::Shutdown()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::Shutdown");
	ITextServices *pserv;
	
	HostRevokeDragDrop();					// Revoke our drop target
	
	if(_pserv)
	{
		// Guarantee that no recursive callbacks can happen during shutdown.
		pserv = _pserv;
		_pserv = NULL;

		pserv->OnTxInPlaceDeactivate();
		pserv->Release();

		// Host release was not the final release so notify
		// text services that they need to keep their reference
		// to the host valid.
		if (!_fTextServiceFree)
		{
			((CTxtEdit *)pserv)->SetReleaseHost();

		}
	}


	ImmTerminate();						// Terminate only useful on Mac.
	if(_hwnd)
		SetWindowLongPtr(_hwnd, ibPed, 0);
}

/*
 *	CTxtWinHost::Init (hwnd, pcs)
 *
 *	@mfunc
 *		Initialize this CTxtWinHost
 */
BOOL CTxtWinHost::Init(
	HWND hwnd,					//@parm Window handle for this control
	const CREATESTRUCT *pcs,	//@parm Corresponding CREATESTRUCT
	BOOL fIsAnsi,				//@parm is ansi window
	BOOL fIs10Mode)				//@parm is 1.0 mode window
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::Init");

	AssertSz(!fIs10Mode || (fIsAnsi && fIs10Mode),
		"CTxtWinHost::Init input flags are out of sync!");

	if(!pcs->lpszClass)
		return FALSE;

	// Set pointer back to CTxtWinHost from the window
	if(hwnd)
		SetWindowLongPtr(hwnd, ibPed, (INT_PTR)this);
		
	_hwnd = hwnd;

	// Here we want to keep track of the "RichEdit20A"window class
	// The RICHEDIT window class is handled by a wrapper dll.
	// If the class name is "RICHEDIT", then we need to turn on the
	// RichEdit 1.0 compatibility bit.  IsAnsiWindowClass tests that class as well.
	_fANSIwindow = fIsAnsi;

 	// Edit controls created without a window are multiline by default
	// so that paragraph formats can be
	_dwStyle = ES_MULTILINE;
	_fHidden = TRUE;
	
	if(pcs)
	{
		_hwndParent = pcs->hwndParent;
		_dwExStyle	= pcs->dwExStyle;
		_dwStyle	= pcs->style;

		if (!fIs10Mode)
		{
			// Only set this for 2.0 windows
			// According to the edit control documentation WS_HSCROLL implies that
			// ES_AUTOSCROLL is set and WS_VSCROLL implies that ES_AUTOVSCROLL is
			// set. Here, we make this so.
			if(_dwStyle & WS_HSCROLL)
				_dwStyle |= ES_AUTOHSCROLL;

			// handle default disabled
			if(_dwStyle & WS_DISABLED)
				_fDisabled = TRUE;
		}
		else
		{
		if (GetBkMode(GetDC(hwnd)) == TRANSPARENT)
			{
			_dwExStyle |= WS_EX_TRANSPARENT;
			}
		else
			{
			_dwExStyle &= ~WS_EX_TRANSPARENT;
			}
		}

		if(_dwStyle & WS_VSCROLL)
			_dwStyle |= ES_AUTOVSCROLL;

		_fBorder = !!(_dwStyle & WS_BORDER);

		if((_dwStyle & ES_SUNKEN) || (_dwExStyle & WS_EX_CLIENTEDGE))
			_fBorder = TRUE;

		// handle default passwords
		if(_dwStyle & ES_PASSWORD)
			_chPassword = TEXT('*');

		// On Win95 ES_SUNKEN and WS_BORDER get mapped to WS_EX_CLIENTEDGE
		if(_fBorder && dwMajorVersion >= VERS4)
        {
			_dwExStyle |= WS_EX_CLIENTEDGE;
			SetWindowLong(_hwnd, GWL_EXSTYLE, _dwExStyle);
        }

		// Process some flags for mirrored control
		if (_dwExStyle & WS_EX_LAYOUTRTL)
		{
			// Swap whatever RTL params we have
			_dwStyle = (_dwStyle & ~ES_RIGHT) | (_dwStyle & ES_RIGHT ^ ES_RIGHT);
			_dwExStyle = (_dwExStyle & ~WS_EX_RTLREADING) | (_dwExStyle & WS_EX_RTLREADING ^ WS_EX_RTLREADING);
			_dwExStyle = (_dwExStyle & ~WS_EX_LEFTSCROLLBAR) |
						 (_dwStyle & ES_RIGHT ? WS_EX_LEFTSCROLLBAR : 0);
	
			// Disable mirroring layout to avoid GDI mirroring mapping mode
			_dwExStyle &= ~WS_EX_LAYOUTRTL;
	
			SetWindowLong(_hwnd, GWL_STYLE, _dwStyle);
			SetWindowLong(_hwnd, GWL_EXSTYLE, _dwExStyle);
		}
	}

	// Create Text Services component
	// Watch out for sys param and sys font initialization!!  see below.
	if(FAILED(CreateTextServices()))
		return FALSE;

	_xInset = (char)W32->GetCxBorder();
	_yInset = (char)W32->GetCyBorder();

	if (!_fBorder)
	{
		_xInset += _xInset;
		_yInset += _yInset;
	}

	// At this point the border flag is set and so is the pixels per inch
	// so we can initalize the inset.
	// This must be done after CreatingTextServices so sys params are valid
	SetDefaultInset();

	// Set alignment and paragraph direction
	PARAFORMAT PF2;
	
	PF2.dwMask = 0;

	BOOL fRCAlign = _dwStyle & (ES_RIGHT | ES_CENTER) || _dwExStyle & WS_EX_RIGHT;
	if(fRCAlign)
	{
		PF2.dwMask |= PFM_ALIGNMENT;
		PF2.wAlignment = (WORD)(_dwStyle & ES_CENTER ? PFA_CENTER : PFA_RIGHT);	// right or center-aligned
	}

	if(_dwExStyle & WS_EX_RTLREADING)
	{
		PF2.dwMask |= PFM_RTLPARA;
		PF2.wEffects = PFE_RTLPARA;		// RTL reading order
	}

	if (PF2.dwMask)
	{
		PF2.cbSize = sizeof(PARAFORMAT2);
		//  tell text services
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF2, NULL);
	}

	if (fIs10Mode)
	{
		 ((CTxtEdit *)_pserv)->Set10Mode();
		 // Remove the WS_VSCROLL and WS_HSCROLL initially
        if (_hwnd && !(_dwStyle & ES_DISABLENOSCROLL))
        {
            SetScrollRange(_hwnd, SB_VERT, 0, 0, TRUE);
    		SetScrollRange(_hwnd, SB_HORZ, 0, 0, TRUE);
            DWORD dwStyle = _dwStyle & ~(WS_VSCROLL | WS_HSCROLL);
            SetWindowLong(_hwnd, GWL_STYLE, dwStyle);

            // bug fix:
            // On some systems, ie Digital PII-266, we don't get a WM_PAINT message
            // when we change the window style.  So force a WM_PAINT into the message queue
            InvalidateRect(_hwnd, NULL, TRUE);
        }
    }

	// Set window text
	if(pcs && pcs->lpszName)
	{
		if(FAILED(_pserv->TxSetText((TCHAR *)pcs->lpszName)))
		{
			SafeReleaseAndNULL((IUnknown **)&_pserv);
			return FALSE;
		}
	}

	if(_dwStyle & ES_LOWERCASE)
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_LOWERCASE,
							  SES_LOWERCASE | SES_UPPERCASE, NULL);

	if(!ImmInitialize())			// Mac Only
	{
		#if defined(DEBUG) && defined(MACPORT)
		OutputDebugString(TEXT("Could not register Imm ImmInitializeForMac.\r\n"));
		#endif	// DEBUG
	}

	return TRUE;
}

HRESULT CTxtWinHost::CreateTextServices()
{
	IUnknown *pUnk;
	HRESULT	  hr = ::CreateTextServices(NULL, this, &pUnk);

	if(hr != NOERROR)
		return hr;

	// Get text services interface
	hr = pUnk->QueryInterface(IID_ITextServices, (void **)&_pserv);

	// Regardless of whether the previous call succeeded or failed, we are
	// done with the private interface.
	pUnk->Release();

	if(hr == NOERROR)
	{
		((CTxtEdit *)_pserv)->_fInOurHost = TRUE;
		// FE extended styles might set the fFE bit
		if(_dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR))
			_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_BIDI, SES_BIDI, NULL);
	}

	return hr;
}

/*
 *	CTxtWinHost::OnCreate (pcs)
 *
 *	@mfunc
 *		Handle WM_CREATE message
 *
 *	@rdesc
 *		LRESULT = -1 if failed to in-place activate; else 0
 */
LRESULT CTxtWinHost::OnCreate(
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnCreate");

	RECT rcClient;

	// sometimes, these values are -1 (from windows itself); just treat them
	// as zero in that case
	LONG cy = (pcs->cy < 0) ? 0 : pcs->cy;
	LONG cx = (pcs->cx < 0) ? 0 : pcs->cx;

	rcClient.top = pcs->y;
	rcClient.bottom = rcClient.top + cy;
	rcClient.left = pcs->x;
	rcClient.right = rcClient.left + cx;
	
	// Notify Text Services that we are in place active
	if(FAILED(_pserv->OnTxInPlaceActivate(&rcClient)))
		return -1;

	DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
	
	// Hide all scrollbars to start	
	if(_hwnd && !(dwStyle & ES_DISABLENOSCROLL) && !((CTxtEdit *)_pserv)->Get10Mode())
	{
		SetScrollRange(_hwnd, SB_VERT, 0, 0, TRUE);
		SetScrollRange(_hwnd, SB_HORZ, 0, 0, TRUE);

		dwStyle &= ~(WS_VSCROLL | WS_HSCROLL);
		SetWindowLong(_hwnd, GWL_STYLE, dwStyle);		
	}

	if(!(dwStyle & (ES_READONLY | ES_NOOLEDRAGDROP)))
	{
		// This isn't a read only window or a no drop window,
		// so we need a drop target.
		HostRegisterDragDrop();
	}

	_usIMEMode = 0;	
	if(dwStyle & ES_NOIME)
	{
		_usIMEMode = ES_NOIME;
		// Tell textservices to turnoff ime
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_NOIME, SES_NOIME, NULL);	
	}
	else if(dwStyle & ES_SELFIME)
		_usIMEMode = ES_SELFIME;

	return 0;
}


/////////////////////////////////  IUnknown ////////////////////////////////

HRESULT CTxtWinHost::QueryInterface(REFIID riid, void **ppv)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::QueryInterface");

  	if(IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown *)(ITextHost2*)this;

	else if(IsEqualIID(riid, IID_ITextHost) )
		*ppv = (ITextHost *)(CTxtWinHost*)this;

	else if(IsEqualIID(riid, IID_ITextHost2) )
		*ppv = (ITextHost2 *)(CTxtWinHost*)this;

	else
		*ppv = NULL;

	if(*ppv)
	{
		AddRef();
		return NOERROR;
	}
	return E_NOINTERFACE;
}

ULONG CTxtWinHost::AddRef(void)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::AddRef");

	return ++_crefs;
}

ULONG CTxtWinHost::Release(void)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::Release");

	--_crefs;

	if(!_crefs)
	{
#ifndef NOACCESSIBILITY
        if(_pTypeInfo)
        {
            _pTypeInfo->Release();
            _pTypeInfo = NULL;
        }
#endif
		delete this;
		return 0;
	}
	return _crefs;
}


//////////////////////////////// Activation ////////////////////////////////

//////////////////////////////// Properties ////////////////////////////////


TXTEFFECT CTxtWinHost::TxGetEffects() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::TxGetEffects");

	if((_dwStyle & ES_SUNKEN) || (_dwExStyle & WS_EX_CLIENTEDGE))
		return TXTEFFECT_SUNKEN;

	return TXTEFFECT_NONE;
}

///////////////////////////////  Keyboard Messages  //////////////////////////////////

/*
 *	CTxtWinHost::OnKeyDown (vkey, dwFlags)
 *
 *	@mfunc
 *		Handle WM_KEYDOWN messages that need to send a message to the parent
 *		window (may happen when control is in a dialog box)
 *
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CTxtWinHost::OnKeyDown(
	WORD	vkey,			//@parm WM_KEYDOWN wparam (virtual key code)
	DWORD	dwFlags)		//@parm WM_KEYDOWN flags
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnKeyDown");

	if(!_fInDialogBox) 					// Not in a dialog box
		return 1;						// Signal key-down msg not processed

	DWORD dwKeyFlags = GetKeyboardFlags();

	switch(vkey)
	{
	case VK_ESCAPE:
		PostMessage(_hwndParent, WM_CLOSE, 0, 0);
		return 0;
	
	case VK_RETURN:
		if(!(dwKeyFlags & CTRL) && !(_dwStyle & ES_WANTRETURN))
		{
			// Send to default button
			HWND	hwndT;
			LRESULT id = SendMessage(_hwndParent, DM_GETDEFID, 0, 0);

			if(LOWORD(id) && (hwndT = GetDlgItem(_hwndParent, LOWORD(id))))
			{
				SendMessage(_hwndParent, WM_NEXTDLGCTL, (WPARAM) hwndT, (LPARAM) 1);
				if(GetFocus() != _hwnd)
					PostMessage(hwndT, WM_KEYDOWN, (WPARAM) VK_RETURN, 0);
			}
			return 0;
		}
		break;

	case VK_TAB:
		if(!(dwKeyFlags & CTRL))
		{
			SendMessage(_hwndParent, WM_NEXTDLGCTL,
								!!(dwKeyFlags & SHIFT), 0);
			return 0;
		}
		break;
	}

	return 1;
}

/*
 *	CTxtWinHost::OnChar (vkey, dwFlags)
 *
 *	@mfunc
 *		Eat some WM_CHAR messages for a control in a dialog box
 *
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CTxtWinHost::OnChar(
	WORD	vkey,			//@parm WM_CHAR wparam (translated key code)
	DWORD	dwFlags)		//@parm WM_CHAR flags
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnChar");

	if(!_fInDialogBox || (GetKeyboardFlags() & CTRL))
		return 1;
	
	switch(vkey)
	{
	case 'J' - 0x40:					// Ctrl-Return generates Ctrl-J (LF):
	case VK_RETURN:						//  treat it as an ordinary return
		// We need to filter-out cases where we don't want to insert <cr> in
		// 1.0 mode here since the info isn't available within the ped
		if (((CTxtEdit*)_pserv)->Get10Mode())
		{
			if (_fInDialogBox && dwFlags != MK_CONTROL && !(_dwStyle & ES_WANTRETURN))
				return 0;
				
			if (!(_dwStyle & ES_MULTILINE))
			{
				//richedit beeps in this case
				((CTxtEdit*)_pserv)->Beep();
				return 0;
			}
		}
		else if (!(_dwStyle & ES_WANTRETURN))
			return 0;					// Signal char processed (eaten)		
		break;

	case VK_TAB:
		return 0;
	}
	
	return 1;							// Signal char not processed
}


/////////////////////////////////  View rectangle //////////////////////////////////////

void CTxtWinHost::OnGetRect(
	LPRECT prc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnGetRect");

	RECT rcInset;
	LONG lSelBarWidth = 0;

	if(_fEmSetRectCalled)
	{
		// Get the selection bar width and add it back to the view inset so
		// we return the rectangle that the application set.
		TxGetSelectionBarWidth(&lSelBarWidth);
	}

	// Get view inset (in HIMETRIC)
	TxGetViewInset(&rcInset);

	// Get client rect in pixels
	TxGetClientRect(prc);

	// Modify the client rect by the inset converted to pixels
	prc->left	+= W32->HimetricXtoDX(rcInset.left + lSelBarWidth, W32->GetXPerInchScreenDC());
	prc->top	+= W32->HimetricYtoDY(rcInset.top, W32->GetYPerInchScreenDC());
	prc->right	-= W32->HimetricXtoDX(rcInset.right, W32->GetXPerInchScreenDC());
	prc->bottom -= W32->HimetricYtoDY(rcInset.bottom, W32->GetYPerInchScreenDC());
}

void CTxtWinHost::OnSetRect(
	LPRECT prc,				//@parm Desired formatting RECT
	BOOL fNewBehavior,		//@parm If TRUE, prc is inset RECT directly
	BOOL fRedraw)			//@parm If TRUE, redraw after setting RECT
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSetRect");

	RECT rcClient;
	LONG lSelBarWidth;
	
	// Assuming this is not set to the default, turn on special EM_SETRECT
	// processing. The important part of this is that we subtract the selection
	// bar from the view inset because the EM_SETRECT rectangle does not
	// include the selection bar.
	_fEmSetRectCalled = TRUE;

	if(!prc)
	{
		// We are back to the default so turn off special EM_SETRECT procesing.
		_fEmSetRectCalled = FALSE;
		SetDefaultInset();
	}
	else	
	{
		// For screen display, the following intersects new view RECT
		// with adjusted client area RECT
		TxGetClientRect(&rcClient);

		// Adjust client rect. Factors in space for borders
		if(_fBorder)
		{																					
			rcClient.top		+= _yInset;
			rcClient.bottom 	-= _yInset - 1;
			rcClient.left		+= _xInset;
			rcClient.right		-= _xInset;
		}
	
		if(!fNewBehavior)
		{
			// Intersect new view rectangle with adjusted client area rectangle
			if(!IntersectRect(&_rcViewInset, &rcClient, prc))
				_rcViewInset = rcClient;
		}
		else
			_rcViewInset = *prc;

		// Get selection bar width
		TxGetSelectionBarWidth(&lSelBarWidth);

		// Compute inset in pixels and convert to HIMETRIC.
		_rcViewInset.left = W32->DXtoHimetricX(_rcViewInset.left - rcClient.left, W32->GetXPerInchScreenDC())
			- lSelBarWidth;
		_rcViewInset.top = W32->DYtoHimetricY(_rcViewInset.top - rcClient.top, W32->GetYPerInchScreenDC());
		_rcViewInset.right = W32->DXtoHimetricX(rcClient.right
			- _rcViewInset.right, W32->GetXPerInchScreenDC());
		_rcViewInset.bottom = W32->DYtoHimetricY(rcClient.bottom
			- _rcViewInset.bottom, W32->GetYPerInchScreenDC());
	}
	if(fRedraw)
	{
		_pserv->OnTxPropertyBitsChange(TXTBIT_VIEWINSETCHANGE,
			TXTBIT_VIEWINSETCHANGE);
	}
}


///////////////////////////////  System notifications  //////////////////////////////////

void CTxtWinHost::OnSysColorChange()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSysColorChange");

	if(!_fNotSysBkgnd)
		_crBackground = GetSysColor(COLOR_WINDOW);
	TxInvalidateRect(NULL, TRUE);
}

/*
 *	CTxtWinHost::OnGetDlgCode (wparam, lparam)
 *
 *	@mfunc
 *		Handle some WM_GETDLGCODE messages
 *
 *	#rdesc
 *		LRESULT = dialog code
 */
LRESULT CTxtWinHost::OnGetDlgCode(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnGetDlgCode");

	LRESULT lres = DLGC_WANTCHARS | DLGC_WANTARROWS | DLGC_WANTTAB;

	if(_dwStyle & ES_MULTILINE)
		lres |= DLGC_WANTALLKEYS;

	if(!(_dwStyle & ES_SAVESEL))
		lres |= DLGC_HASSETSEL;

	// HACK: If we get one of these messages then we turn on the special
	// EM_SETSEL behavior. The problem is that _fInDialogBox gets turned
	// on after the EM_SETSEL has occurred.
	_fUseSpecialSetSel = TRUE;

	/*
	** -------------------------------------------- JEFFBOG HACK ----
	** Only set Dialog Box Flag if GETDLGCODE message is generated by
	** IsDialogMessage -- if so, the lParam will be a pointer to the
	** message structure passed to IsDialogMessage; otherwise, lParam
	** will be NULL.  Reason for the HACK alert:  the wParam & lParam
	** for GETDLGCODE is still not clearly defined and may end up
	** changing in a way that would throw this off
	** -------------------------------------------- JEFFBOG HACK ----
	 */
	if(lparam)
		_fInDialogBox = TRUE;

	/*
	** If this is a WM_SYSCHAR message generated by the UNDO keystroke
	** we want this message so we can EAT IT in remain.c, case WM_SYSCHAR:
	 */
	if (lparam &&
		(((LPMSG)lparam)->message == WM_SYSCHAR)  &&
		(((LPMSG)lparam)->lParam & SYS_ALTERNATE) &&	
		wparam == VK_BACK)
	{
		lres |= DLGC_WANTMESSAGE;
	}

	return lres;
}


/////////////////////////////////  Other messages  //////////////////////////////////////

LRESULT CTxtWinHost::OnGetOptions() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnGetOptions");

	LRESULT lres = (_dwStyle & ECO_STYLES);

	if(_fEnableAutoWordSel)
		lres |= ECO_AUTOWORDSELECTION;
	
	return lres;
}

void CTxtWinHost::OnSetOptions(
	WORD  wOp,
	DWORD eco)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSetOptions");

	DWORD		dwChangeMask = 0;
	DWORD		dwProp = 0;
	DWORD		dwStyle;
	DWORD		dwStyleNew = _dwStyle;
	const BOOL	fAutoWordSel = !!(eco & ECO_AUTOWORDSELECTION);		
	BOOL		bNeedToTurnOffIME = FALSE;

	// We keep track of the bits changed and then if any have changed we
	// query for all of our property bits and then send them. This simplifies
	// the code because we don't have to set all the bits specially. If the
	// code is changed to make the properties more in line with the new
	// model, we want to look at this code again.

	// Single line controls can't have a selection bar or do vertical writing
	if(!(_dwStyle & ES_MULTILINE))
		eco &= ~ECO_SELECTIONBAR;

	Assert((DWORD)fAutoWordSel <= 1);			// Make sure that BOOL is 1/0
	dwStyle = (eco & ECO_STYLES);

	switch(wOp)
	{
	case ECOOP_SET:
		dwStyleNew			= (dwStyleNew & ~ECO_STYLES) | dwStyle;
		_fEnableAutoWordSel = fAutoWordSel;
		break;

	case ECOOP_OR:
		dwStyleNew |= dwStyle;					// Setting a :1 flag = TRUE
		if(fAutoWordSel)						//  or FALSE is 1 instruction
			_fEnableAutoWordSel = TRUE;			// Setting it to a BOOL
		break;									//  averages 9 instructions!

	case ECOOP_AND:
		dwStyleNew &= (dwStyle | ~ECO_STYLES);
		if(!fAutoWordSel)
			_fEnableAutoWordSel = FALSE;
		break;

	case ECOOP_XOR:
		dwStyleNew ^= dwStyle;
		if(fAutoWordSel)
			_fEnableAutoWordSel ^= 1;
		break;
	}

	if(_fEnableAutoWordSel != (unsigned)fAutoWordSel)
		dwChangeMask |= TXTBIT_AUTOWORDSEL;

	if(dwStyleNew != _dwStyle)
	{
		DWORD dwChange = dwStyleNew ^ _dwStyle;

		AssertSz(!(dwChange & ~ECO_STYLES), "non-eco style changed");
		_dwStyle = dwStyleNew;
		SetWindowLong(_hwnd, GWL_STYLE, dwStyleNew);

		if(dwChange & ES_NOHIDESEL)	
			dwChangeMask |= TXTBIT_HIDESELECTION;

		// These two local variables to use to keep track of
		// previous setting of ES_READONLY
		BOOL bReadOnly = (_dwStyle & ES_READONLY);

		if(dwChange & ES_READONLY)
		{
			dwChangeMask |= TXTBIT_READONLY;

			// Change drop target state as appropriate.
			if(dwStyleNew & ES_READONLY)
				HostRevokeDragDrop();

			else
				HostRegisterDragDrop();
			
			bReadOnly = (dwStyleNew & ES_READONLY);
		}

		if(dwChange & ES_VERTICAL)
			dwChangeMask |= TXTBIT_VERTICAL;

		if(dwChange & ES_NOIME)
		{
			_usIMEMode = (dwStyleNew & ES_NOIME) ? ES_NOIME : 0;
			bNeedToTurnOffIME = (_usIMEMode ==ES_NOIME);
		}
		else if(dwChange & ES_SELFIME)
			_usIMEMode = (dwStyleNew & ES_SELFIME) ? ES_SELFIME : 0;
		
		// No action required for ES_WANTRETURN nor for ES_SAVESEL
		// Do this last
		if(dwChange & ES_SELECTIONBAR)
			dwChangeMask |= TXTBIT_SELBARCHANGE;
	}

	if (dwChangeMask)
	{
		TxGetPropertyBits(dwChangeMask, &dwProp);
		_pserv->OnTxPropertyBitsChange(dwChangeMask, dwProp);
	}

	if (bNeedToTurnOffIME)
		// Tell textservices to turnoff ime
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_NOIME, SES_NOIME, NULL);	
}

void CTxtWinHost::OnSetReadOnly(
	BOOL fReadOnly)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSetReadOnly");

	DWORD dwT = GetWindowLong(_hwnd, GWL_STYLE);
	DWORD dwUpdatedBits = 0;

	if(fReadOnly)
	{
		dwT |= ES_READONLY;
		_dwStyle |= ES_READONLY;

		// Turn off Drag Drop
		HostRevokeDragDrop();
		dwUpdatedBits |= TXTBIT_READONLY;
	}
	else
	{
		dwT		 &= ~ES_READONLY;
		_dwStyle &= ~ES_READONLY;

		// Turn drag drop back on
		HostRegisterDragDrop();	
	}

	_pserv->OnTxPropertyBitsChange(TXTBIT_READONLY, dwUpdatedBits);

	SetWindowLong(_hwnd, GWL_STYLE, dwT);
}


////////////////////////////////////  Helpers  /////////////////////////////////////////

void CTxtWinHost::SetDefaultInset()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::SetDefaultInset");

	// Generate default view rect from client rect
	if(_fBorder)
	{
		// Factors in space for borders
  		_rcViewInset.top	= W32->DYtoHimetricY(_yInset, W32->GetYPerInchScreenDC());
   		_rcViewInset.bottom	= W32->DYtoHimetricY(_yInset - 1, W32->GetYPerInchScreenDC());
   		_rcViewInset.left	= W32->DXtoHimetricX(_xInset, W32->GetXPerInchScreenDC());
   		_rcViewInset.right	= W32->DXtoHimetricX(_xInset, W32->GetXPerInchScreenDC());
	}
	else
	{
		// Default the top and bottom inset to 0 and the left and right
		// to the size of the border.
		_rcViewInset.top = 0;
		_rcViewInset.bottom = 0;
		_rcViewInset.left = W32->DXtoHimetricX(W32->GetCxBorder(), W32->GetXPerInchScreenDC());
		_rcViewInset.right = W32->DXtoHimetricX(W32->GetCxBorder(), W32->GetXPerInchScreenDC());
	}
}


/////////////////////////////////  Far East Support  //////////////////////////////////////

//#ifdef WIN95_IME
HIMC CTxtWinHost::TxImmGetContext()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::TxImmGetContext");

	HIMC himc;

	Assert(_hwnd);
	himc = ImmGetContext(_hwnd);
	return himc;
}

void CTxtWinHost::TxImmReleaseContext(
	HIMC himc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::TxImmReleaseContext");

	Assert(_hwnd);
	ImmReleaseContext(_hwnd, himc);
}

//#endif

void CTxtWinHost::HostRevokeDragDrop()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::HostRevokeDragDrop");

	if(_fRegisteredForDrop)
	{
		// Note that if the revoke fails we want to know about this in debug
		// builds so we can fix any problems. In retail, we can't really do
		// so we just ignore it.
#ifdef DEBUG
		HRESULT hr =
#endif // DEBUG

			RevokeDragDrop(_hwnd);

#ifdef DEBUG
		TESTANDTRACEHR(hr);
#endif // DEBUG

		_fRegisteredForDrop = FALSE;
	}
}

void CTxtWinHost::HostRegisterDragDrop()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::RegisterDragDrop");

	IDropTarget *pdt;

	if(!_fRegisteredForDrop && _pserv->TxGetDropTarget(&pdt) == NOERROR)
	{
		// The most likely reason for RegisterDragDrop to fail is some kind of
		// bug in our program.

		HRESULT hr = RegisterDragDrop(_hwnd, pdt);

		if(hr == NOERROR)
			_fRegisteredForDrop = TRUE;

#ifndef PEGASUS
		pdt->Release();
#endif
	}
}


static void DrawRectFn(
	HDC hdc,
	RECT *prc,
	INT icrTL,
	INT icrBR,
	BOOL fBot,
	BOOL fRght)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "DrawRectFn");

	COLORREF cr = GetSysColor(icrTL);
	COLORREF crSave = SetBkColor(hdc, cr);
	RECT rc = *prc;

	// top
	rc.bottom = rc.top + 1;
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

	// left
	rc.bottom = prc->bottom;
	rc.right = rc.left + 1;
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

	if(icrTL != icrBR)
	{
		cr = GetSysColor(icrBR);
		SetBkColor(hdc, cr);
	}

	// right
	rc.right = prc->right;
	rc.left = rc.right - 1;
	if(!fBot)
		rc.bottom -= W32->GetCyHScroll();
	if(fRght)
		ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

	// bottom
	if(fBot)
	{
		rc.left = prc->left;
		rc.top = rc.bottom - 1;
		if(!fRght)
			rc.right -= W32->GetCxVScroll();
		ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
	}
	SetBkColor(hdc, crSave);
}

#define cmultBorder 1

void CTxtWinHost::OnSunkenWindowPosChanging(
	HWND hwnd,
	WINDOWPOS *pwndpos)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSunkenWindowPosChanging");

	if(IsWindowVisible(hwnd))
	{
		RECT rc;
		HWND hwndParent;

		GetWindowRect(hwnd, &rc);
		InflateRect(&rc, W32->GetCxBorder() * cmultBorder, W32->GetCyBorder() * cmultBorder);
		hwndParent = GetParent(hwnd);
		MapWindowPoints(HWND_DESKTOP, hwndParent, (POINT *) &rc, 2);
		InvalidateRect(hwndParent, &rc, FALSE);
	}
}

void CTxtWinHost::DrawSunkenBorder(
	HWND hwnd,
	HDC hdc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::DrawSunkenBorder");
	BOOL fVScroll = (_dwStyle & WS_VSCROLL);
	BOOL fHScroll = (_dwStyle & WS_HSCROLL);

	RECT rc;
	RECT rcParent;
	HWND hwndParent;

	// if we're not visible, don't do anything.
	if(!IsWindowVisible(hwnd))
		return;

	GetWindowRect(hwnd, &rc);
	hwndParent = GetParent(hwnd);
	rcParent = rc;
	MapWindowPoints(HWND_DESKTOP, hwndParent, (POINT *)&rcParent, 2);
	InflateRect(&rcParent, W32->GetCxBorder(), W32->GetCyBorder());
	OffsetRect(&rc, -rc.left, -rc.top);

	if(_pserv)
	{
		// If we have a text control then get whether it thinks there are
		// scroll bars.
		_pserv->TxGetHScroll(NULL, NULL, NULL, NULL, &fHScroll);
		_pserv->TxGetVScroll(NULL, NULL, NULL, NULL, &fVScroll);
	}


	// Draw inner rect
	DrawRectFn(hdc, &rc, icr3DDarkShadow, COLOR_BTNFACE,
		!fHScroll, !fVScroll);

	// Draw outer rect
	hwndParent = GetParent(hwnd);
	hdc = GetDC(hwndParent);
	DrawRectFn(hdc, &rcParent, COLOR_BTNSHADOW, COLOR_BTNHIGHLIGHT,
		TRUE, TRUE);
	ReleaseDC(hwndParent, hdc);
}

LRESULT CTxtWinHost::OnSize(
	HWND hwnd,
	WORD fwSizeType,
	int  nWidth,
	int  nHeight)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSize");

	BOOL fIconic = GetIconic(hwnd);
	DWORD dw = TXTBIT_CLIENTRECTCHANGE;
	if(_sWidth != nWidth && !fIconic && !_fIconic)
	{
		_sWidth = (short)nWidth;				// Be sure to update _sWidth
		dw = TXTBIT_EXTENTCHANGE;
	}

	if(!_fVisible)
	{
		if(!fIconic)
			_fResized = TRUE;
	}
	else if(!fIconic)
	{
		// We use this property because this will force a recalc.
		// We don't actually recalc on a client rect change because
		// most of the time it is pointless. We force one here because
		// some applications use size changes to calculate the optimal
		// size of the window.
		_pserv->OnTxPropertyBitsChange(dw, dw);

		if(_fIconic)
		{
			TRACEINFOSZ("Restoring from iconic");
			InvalidateRect(hwnd, NULL, FALSE);
		}
			
		// Draw borders
		if(TxGetEffects() == TXTEFFECT_SUNKEN && dwMajorVersion < VERS4)
			DrawSunkenBorder(hwnd, NULL);
	}
	_fIconic = fIconic;						// Update _fIconic
	return 0;
}

HRESULT CTxtWinHost::OnTxVisibleChange(
	BOOL fVisible)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnTxVisibleChange");

	_fVisible = fVisible;

	if(!_fVisible && _fResized)
	{
		RECT rc;
		// Control was resized while hidden, need to really resize now
		TxGetClientRect(&rc);
		_fResized = FALSE;
		_pserv->OnTxPropertyBitsChange(TXTBIT_CLIENTRECTCHANGE,
				TXTBIT_CLIENTRECTCHANGE);
	}
	return S_OK;
}


//////////////////////////// ITextHost Interface  ////////////////////////////

// @doc EXTERNAL
/*
 *	CTxtWinHost::TxGetDC()
 *
 *	@mfunc
 *		Abstracts GetDC so Text Services does not need a window handle.
 *
 *	@rdesc
 *		A DC or NULL in the event of an error.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
HDC CTxtWinHost::TxGetDC()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetDC");

	Assert(_hwnd);
	return ::GetDC(_hwnd);
}

/*
 *	CTxtWinHost::TxReleaseDC (hdc)
 *
 *	@mfunc
 *		Release DC gotten by TxGetDC.
 *
 *	@rdesc	
 *		1 - HDC was released. <nl>
 *		0 - HDC was not released. <nl>
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
int CTxtWinHost::TxReleaseDC(
	HDC hdc)				//@parm	DC to release
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxReleaseDC");

	Assert(_hwnd);
	return ::ReleaseDC (_hwnd, hdc);
}

/*
 *	CTxtWinHost::TxShowScrollBar (fnBar, fShow)
 *
 *	@mfunc
 *		Shows or Hides scroll bar in Text Host window
 *
 *	@rdesc
 *		TRUE on success, FALSE otherwise
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxShowScrollBar(
	INT  fnBar, 		//@parm	Specifies scroll bar(s) to be shown or hidden
	BOOL fShow)			//@parm	Specifies whether scroll bar is shown or hidden
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxShowScrollBar");

	Assert(_hwnd);
	LONG nMax;

	if(fnBar == SB_HORZ)
		_pserv->TxGetHScroll(NULL, &nMax, NULL, NULL, NULL);
	else
		_pserv->TxGetVScroll(NULL, &nMax, NULL, NULL, NULL);

	return W32->ShowScrollBar(_hwnd, fnBar, fShow, nMax);
}

/*
 *	CTxtWinHost::TxEnableScrollBar (fuSBFlags, fuArrowflags)
 *
 *	@mfunc
 *		Enables or disables one or both scroll bar arrows
 *		in Text Host window.
 *
 *	@rdesc
 *		If the arrows are enabled or disabled as specified, the return
 *		value is TRUE. If the arrows are already in the requested state or an
 *		error occurs, the return value is FALSE.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.	
 */
BOOL CTxtWinHost::TxEnableScrollBar (
	INT fuSBFlags, 		//@parm Specifies scroll bar type	
	INT fuArrowflags)	//@parm	Specifies whether and which scroll bar arrows
						//		are enabled or disabled
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxEnableScrollBar");

	Assert(_hwnd);
	return W32->EnableScrollBar(_hwnd, fuSBFlags, fuArrowflags);
}

/*
 *	CTxtWinHost::TxSetScrollRange (fnBar, nMinPos, nMaxPos, fRedraw)
 *
 *	@mfunc
 *		Sets the minimum and maximum position values for the specified
 *		scroll bar in the text host window.
 *
 *	@rdesc
 *		If the arrows are enabled or disabled as specified, the return value
 *		is TRUE. If the arrows are already in the requested state or an error
 *		occurs, the return value is FALSE.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxSetScrollRange(
	INT	 fnBar, 		//@parm	Scroll bar flag
	LONG nMinPos, 		//@parm	Minimum scrolling position
	INT  nMaxPos, 		//@parm	Maximum scrolling position
	BOOL fRedraw)		//@parm	Specifies whether scroll bar should be redrawn
{						//		to reflect change
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetScrollRange");

	Assert(_hwnd);

	if(NULL == _pserv)
	{
		// We are initializing so do this instead of callback
		return ::SetScrollRange(_hwnd, fnBar, nMinPos, nMaxPos, fRedraw);
	}
	SetScrollInfo(fnBar, fRedraw);
	return TRUE;
}

/*
 *	CTxtWinHost::TxSetScrollPos (fnBar, nPos, fRedraw)
 *
 *	@mfunc
 *		Tells Text host to set the position of the scroll box (thumb) in the
 *		specified scroll bar and, if requested, redraws the scroll bar to
 *		reflect the new position of the scroll box.
 *
 *	@rdesc
 *		TRUE on success; FALSE otherwise.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxSetScrollPos (
	INT		fnBar, 		//@parm	Scroll bar flag
	INT		nPos, 		//@parm	New position in scroll box
	BOOL	fRedraw)	//@parm	Redraw flag
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetScrollPos");

	Assert(_hwnd);

	if(NULL == _pserv)
	{
		// We are initializing so do this instead of callback
		return ::SetScrollPos(_hwnd, fnBar, nPos, fRedraw);
	}
	SetScrollInfo(fnBar, fRedraw);
	return TRUE;
}

/*
 *	CTxtWinHost::TxInvalidateRect (prc, fMode)
 *
 *	@mfunc
 *		Adds a rectangle to the Text Host window's update region
 *
 *	@comm
 *		This function may be called while inactive; however the host
 *		implementation is free to invalidate an area greater than
 *		the requested rect.
 */
void CTxtWinHost::TxInvalidateRect(
	LPCRECT	prc, 		//@parm	Address of rectangle coordinates
	BOOL	fMode)		//@parm	Erase background flag
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxInvalidateRect");

	Assert(_hwnd);

	if(!_fVisible)
	{
		// There doesn't seem to be a deterministic way to determine whether
		// our window is visible or not via message notifications. Therefore,
		// we check this each time incase it might have changed.
		_fVisible = IsWindowVisible(_hwnd);

		if(_fVisible)
			OnTxVisibleChange(TRUE);
	}

	// Don't bother with invalidating rect if we aren't visible
	if(_fVisible)
	{
		if(IsTransparentMode())
		{
			RECT	rcParent;
			HWND	hParent = ::GetParent (_hwnd);
		
			Assert(hParent);

	 		// For transparent mode, we need to invalidate the parent
			// so it will paint the background.
			if(prc)
				rcParent = *prc;
			else
				TxGetClientRect(&rcParent);	

			::MapWindowPoints(_hwnd, hParent, (LPPOINT)&rcParent, 2);
			::InvalidateRect(hParent, &rcParent, fMode);
//			::HideCaret(_hwnd);
		}
		::InvalidateRect(_hwnd, prc, fMode);
	}
}

/*
 *	CTxtWinHost::TxViewChange (fUpdate)
 *
 *	@mfunc
 *		Notify Text Host that update region should be repainted.
 *	
 *	@comm
 *		It is the responsibility of the text services to call
 *		TxViewChanged every time it decides that it's visual representation
 *		has changed, regardless of whether the control is active or
 *		not. If the control is active, the text services has the additional
 *		responsibility of making sure the controls window is updated.
 *		It can do this in a number of ways: 1) get a DC for the control's
 *		window and start blasting pixels (TxGetDC and TxReleaseDC), 2)
 *		invalidate the control's window (TxInvalidate), or 3) scroll
 *		the control's window (TxScrollWindowEx).
 *
 *		Text services can choose to call TxViewChange after it has
 *		performed any operations to update the active view and pass a
 *		true along with the call.  By passing true, the text host
 *		calls UpdateWindow to make sure any unpainted areas of the
 *		active control are repainted.
 */
void CTxtWinHost::TxViewChange(
	BOOL fUpdate)		//@parm TRUE = call update window
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxViewChange");

	Assert(_hwnd);

	// Don't bother with paint since we aren't visible
	if(_fVisible)
	{
		// For updates requests that are FALSE, we will let the next WM_PAINT
		// message pick up the draw.
		if(fUpdate)
		{
			if(IsTransparentMode())
			{
				HWND	hParent = GetParent (_hwnd);
				Assert(hParent);

	 			// For transparent mode, we need to update the parent first
				// before we can update ourself.  Otherwise, what we painted will
				// be erased by the parent's background later.
				::UpdateWindow (hParent);
			}
			::UpdateWindow (_hwnd);
		}
	}
}

/*
 *	CTxtWinHost::TxCreateCaret (hbmp, xWidth, yHeight)
 *
 *	@mfunc
 *		Create new shape for Text Host's caret
 *
 *	@rdesc
 *		TRUE on success, FALSE otherwise.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxCreateCaret(
	HBITMAP hbmp, 		//@parm Handle of bitmap for caret shape	
	INT xWidth, 		//@parm	Caret width
	INT yHeight)		//@parm	Caret height
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxCreateCaret");

	Assert(_hwnd);
	return ::CreateCaret (_hwnd, hbmp, xWidth, yHeight);
}

/*
 *	CTxtWinHost::TxShowCaret (fShow)
 *
 *	@mfunc
 *		Make caret visible/invisible at caret position in Text Host window.
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxShowCaret(
	BOOL fShow)			//@parm Flag whether caret is visible
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxShowCaret");

	return fShow ? ::ShowCaret(_hwnd)  :  ::HideCaret(_hwnd);
}

/*
 *	CTxtWinHost::TxSetCaretPos (x, y)
 *
 *	@mfunc
 *		Move caret position to specified coordinates in Text Host window.
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxSetCaretPos(
	INT x, 				//@parm	Horizontal position (in client coordinates)
	INT y)				//@parm	Vertical position (in client coordinates)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetCaretPos");

	return ::SetCaretPos(x, y);
}

/*
 *	CTxtWinHost::TxSetTimer (idTimer, uTimeout)
 *
 *	@mfunc
 *		Request Text Host to creates a timer with specified time out.
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 */
BOOL CTxtWinHost::TxSetTimer(
	UINT idTimer, 		//@parm Timer identifier	
	UINT uTimeout)		//@parm	Timeout in msec
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetTimer");

	Assert(_hwnd);	
	return ::SetTimer(_hwnd, idTimer, uTimeout, NULL);
}

/*
 *	CTxtWinHost::TxKillTimer (idTimer)
 *
 *	@mfunc
 *		Destroy specified timer
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This method may be called at any time irrespective of active versus
 *		inactive state.
 */
void CTxtWinHost::TxKillTimer(
	UINT idTimer)		//@parm	id of timer
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxKillTimer");

	Assert(_hwnd);			
	::KillTimer(_hwnd, idTimer);
}

/*
 *	CTxtWinHost::TxScrollWindowEx (dx, dy, lprcScroll, lprcClip, hrgnUpdate,
 *									lprcUpdate, fuScroll)
 *	@mfunc
 *		Request Text Host to scroll the content of the specified client area
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
void CTxtWinHost::TxScrollWindowEx (
	INT		dx, 			//@parm	Amount of horizontal scrolling
	INT		dy, 			//@parm	Amount of vertical scrolling
	LPCRECT lprcScroll, 	//@parm	Scroll rectangle
	LPCRECT lprcClip,		//@parm	Clip rectangle
	HRGN	hrgnUpdate, 	//@parm	Handle of update region
	LPRECT	lprcUpdate,		//@parm	Update rectangle
	UINT	fuScroll)		//@parm	Scrolling flags
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxScrollWindowEx");

	Assert(_hwnd);
	::ScrollWindowEx(_hwnd, dx, dy, lprcScroll, lprcClip, hrgnUpdate, lprcUpdate, fuScroll);
}

/*
 *	CTxtWinHost::TxSetCapture (fCapture)
 *
 *	@mfunc
 *		Set mouse capture in Text Host's window.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may do nothing.
 */
void CTxtWinHost::TxSetCapture(
	BOOL fCapture)		//@parm	Whether to get or release capture
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetCapture");

	Assert(_hwnd);
	if (fCapture)
		::SetCapture(_hwnd);
	else
		::ReleaseCapture();
}

/*
 *	CTxtWinHost::TxSetFocus ()
 *
 *	@mfunc
 *		Set focus in text host window.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
void CTxtWinHost::TxSetFocus()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetFocus");

	Assert(_hwnd);
	::SetFocus(_hwnd);
}

/*
 *	CTxtWinHost::TxSetCursor (hcur, fText)
 *
 *	@mfunc
 *		Establish a new cursor shape in the Text Host's window.
 *
 *	@comm
 *		This method may be called at any time, irrespective of
 *		active vs. inactive state.
 *
 *		ITextHost::TxSetCursor should be called back by the Text Services
 *		to actually set the mouse cursor. If the fText parameter is TRUE,
 *		Text Services is trying to set the "text" cursor (cursor over text
 *		that is not selected, currently an IBEAM). In that case, the host
 *		can set it to whatever the control MousePointer property is. This is
 *		required by VB compatibility since, via the MousePointer property,
 *		the VB programmer has control over the shape of the mouse cursor,
 *		whenever it would normally be set to an IBEAM.
 */
void CTxtWinHost::TxSetCursor(
	HCURSOR hcur,		//@parm	Handle to cursor
	BOOL	fText)		//@parm Indicates caller wants to set text cursor
						//		(IBeam) if true.
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetCursor");

	::SetCursor(hcur);
}

/*
 *	CTxtWinHost::TxScreenToClient (lppt)
 *
 *	@mfunc
 *		Convert screen coordinates to Text Host window coordinates.
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 */
BOOL CTxtWinHost::TxScreenToClient(
	LPPOINT lppt)		//@parm	Coordinates for point
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxScreenToClient");

	Assert(_hwnd);
	return ::ScreenToClient(_hwnd, lppt);	
}

/*
 *	CTxtWinHost::TxClientToScreen (lppt)
 *
 *	@mfunc
 *		Convert Text Host coordinates to screen coordinates
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This call is valid at any time, although it is allowed to
 *		fail.  In general, if text services has coordinates it needs
 *		to translate from client coordinates (e.g. for TOM's
 *		PointFromRange method) the text services will actually be
 *		visible.
 *
 *		However, if no conversion is possible, then the method will fail.
 */
BOOL CTxtWinHost::TxClientToScreen(
	LPPOINT lppt)		//@parm	Client coordinates to convert.
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxClientToScreen");

	Assert(_hwnd);
	return ::ClientToScreen(_hwnd, lppt);
}

/*
 *	CTxtWinHost::TxActivate (plOldState)
 *
 *	@mfunc
 *		Notify Text Host that control is active
 *
 *	@rdesc	
 *		S_OK 	- call succeeded. <nl>
 *		E_FAIL	- activation is not possible at this time
 *
 *	@comm
 *		It is legal for the host to refuse an activation request;
 *		the control may be minimized and thus invisible, for instance.
 *
 *		The caller should be able to gracefully handle failure to activate.
 *
 *		Calling this method more than once does not cumulate; only
 *		once TxDeactivate call is necessary to deactive.
 *
 *		This function returns an opaque handle in <p plOldState>. The caller
 *		(Text Services) should hang onto this handle and return it in a
 *		subsequent call to TxDeactivate.
 */
HRESULT CTxtWinHost::TxActivate(
	LONG *plOldState)	//@parm Where to put previous activation state
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxActivate");

	return S_OK;
}

/*
 *	CTxtWinHost::TxDeactivate (lNewState)
 *
 *	@mfunc
 *		Notify Text Host that control is now inactive
 *
 *	@rdesc	
 *		S_OK - call succeeded. <nl>
 *		E_FAIL				   <nl>
 *
 *	@comm
 *		Calling this method more than once does not cumulate
 */
HRESULT CTxtWinHost::TxDeactivate(
	LONG lNewState)		//@parm	New state (typically value returned by
						//		TxActivate
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxDeactivate");

	return S_OK;
}
	
/*
 *	CTxtWinHost::TxGetClientRect (prc)
 *
 *	@mfunc
 *		Retrive client coordinates of Text Host's client area.
 *
 *	@rdesc
 *		HRESULT = (success) ? S_OK : E_FAIL
 */
HRESULT CTxtWinHost::TxGetClientRect(
	LPRECT prc)		//@parm	Where to put client coordinates
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetClientRect");

	Assert(_hwnd && prc);
	return ::GetClientRect(_hwnd, prc) ? S_OK : E_FAIL;
}

/*
 *	CTxtWinHost::TxGetViewInset	(prc)
 *
 *	@mfunc
 *		Get inset for Text Host window.  Inset is the "white space"
 *		around text.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 *
 *	@comm
 *		The Inset rectangle is not strictly a rectangle.  The top, bottom,
 *		left, and right fields of the rect structure indicate how far in
 *		each direction drawing should be inset. Inset sizes are in client
 *		coordinates.
 */
HRESULT CTxtWinHost::TxGetViewInset(
	LPRECT prc)			//@parm Where to put inset rectangle	
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetViewInset");

	Assert(prc);

	*prc = _rcViewInset;
	return NOERROR;	
}

/*
 *	CTxtWinHost::TxGetCharFormat (ppCF)
 *
 *	@mfunc
 *		Get Text Host's default character format
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL (not needed in simple Windows host, since text
 *		services provides desired default)
 *
 *	@comm
 *		The callee retains ownwership of the charformat returned.  However,
 *		the pointer returned must remain valid until the callee notifies
 *		Text Services via OnTxPropertyBitsChange that the default character
 *		format has changed.
 */
HRESULT CTxtWinHost::TxGetCharFormat(
	const CHARFORMAT **ppCF) 		//@parm	Where to put ptr to default
									//		character format
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetCharFormat");

	return E_NOTIMPL;
}

/*
 *	CTxtWinHost::TxGetParaFormat (ppPF)
 *
 *	@mfunc
 *		Get Text Host default paragraph format
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL (not needed in simple Windows host, since text
 *		services provides desired default)
 *
 *	@comm
 *		The host object (callee) retains ownership of the PARAFORMAT returned.
 *		However, the pointer returned must remain valid until the host notifies
 *		Text Services (the caller) via OnTxPropertyBitsChange that the default
 *		paragraph format has changed.
 */
HRESULT CTxtWinHost::TxGetParaFormat(
	const PARAFORMAT **ppPF) 	//@parm Where to put ptr to default
								//		paragraph format
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetParaFormat");

	return E_NOTIMPL;
}

/*
 *	CTxtWinHost::TxGetSysColor (nIndex)
 *
 *	@mfunc
 *		Get specified color identifer from Text Host.
 *
 *	@rdesc
 *		Color identifier
 *
 *	@comm
 *		Note that the color returned may be *different* than the
 *		color that would be returned from a call to GetSysColor.
 *		This allows hosts to override default system behavior.
 *
 *		Needless to say, hosts should be very careful about overriding
 *		normal system behavior as it could result in inconsistent UI
 *		(particularly with respect to Accessibility	options).
 */
COLORREF CTxtWinHost::TxGetSysColor(
	int nIndex)			//@parm Color to get, same parameter as
						//		GetSysColor Win32 API
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetSysColor");

	if (!_fDisabled ||
		nIndex != COLOR_WINDOW && nIndex != COLOR_WINDOWTEXT)
	{
		// This window is not disabled or the color is not interesting
		// in the disabled case.
		return (nIndex == COLOR_WINDOW && _fNotSysBkgnd)
			? _crBackground : GetSysColor(nIndex);
	}

	// Disabled case
	if (COLOR_WINDOWTEXT == nIndex)
	{
		// Color of text for disabled window
		return GetSysColor(COLOR_GRAYTEXT);
	}

	// Background color for disabled window
	return GetSysColor(COLOR_3DFACE);
	
}

/*
 *	CTxtWinHost::TxGetBackStyle	(pstyle)
 *
 *	@mfunc
 *		Get Text Host background style.
 *
 *	@rdesc
 *		HRESULT = S_OK
 *
 *	@xref	<e TXTBACKSTYLE>
 */
HRESULT CTxtWinHost::TxGetBackStyle(
	TXTBACKSTYLE *pstyle)  //@parm Where to put background style
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetBackStyle");

	*pstyle = (_dwExStyle & WS_EX_TRANSPARENT)
			? TXTBACK_TRANSPARENT : TXTBACK_OPAQUE;
	return NOERROR;
}

/*
 *	CTxtWinHost::TxGetMaxLength	(pLength)
 *
 *	@mfunc
 *		Get Text Host's maximum allowed length.
 *
 *	@rdesc
 *		HRESULT = S_OK	
 *
 *	@comm
 *		This method parallels the EM_LIMITTEXT message.
 *		If INFINITE (0xFFFFFFFF) is returned, then text services
 *		will use as much memory as needed to store any given text.
 *
 *		If the limit returned is less than the number of characters
 *		currently in the text engine, no data is lost.  Instead,
 *		no edits will be allowed to the text *other* than deletion
 *		until the text is reduced to below the limit.
 */
HRESULT CTxtWinHost::TxGetMaxLength(
	DWORD *pLength) 	//@parm Maximum allowed length, in number of
						//		characters
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetMaxLength");
	AssertSz(FALSE, "CTxtWinHost::TxGetMaxLength why is this being called?");
	return NOERROR;
}

/*
 *	CTxtWinHost::TxGetScrollBars (pdwScrollBar)
 *
 *	@mfunc
 *		Get Text Host's scroll bars supported.
 *
 *	@rdesc
 *		HRESULT = S_OK
 *
 *	@comm
 *		<p pdwScrollBar> is filled with a boolean combination of the
 *		window styles related to scroll bars.  Specifically, these are:
 *
 *			WS_VSCROLL	<nl>
 *			WS_HSCROLL	<nl>
 *			ES_AUTOVSCROLL	<nl>
 *			ES_AUTOHSCROLL	<nl>
 *			ES_DISABLENOSCROLL	<nl>
 */
HRESULT CTxtWinHost::TxGetScrollBars(
	DWORD *pdwScrollBar) 	//@parm Where to put scrollbar information
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetScrollBars");

	*pdwScrollBar =  _dwStyle & (WS_VSCROLL | WS_HSCROLL | ES_AUTOVSCROLL |
						ES_AUTOHSCROLL | ES_DISABLENOSCROLL);
	return NOERROR;
}

/*
 *	CTxtWinHost::TxGetPasswordChar (pch)
 *
 *	@mfunc
 *		Get Text Host's password character.
 *
 *	@rdesc
 *		HRESULT = (password character not enabled) ? S_FALSE : S_OK
 *
 *	@comm
 *		The password char will only be shown if the TXTBIT_USEPASSWORD bit
 *		is enabled in TextServices.  If the password character changes,
 *		re-enable the TXTBIT_USEPASSWORD bit via
 *		ITextServices::OnTxPropertyBitsChange.
 */
HRESULT CTxtWinHost::TxGetPasswordChar(
	TCHAR *pch)		//@parm Where to put password character
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetPasswordChar");

	*pch = _chPassword;
	return NOERROR;
}

/*
 *	CTxtWinHost::TxGetAcceleratorPos (pcp)
 *
 *	@mfunc
 *		Get special character to use for underlining accelerator character.
 *
 *	@rdesc
 *		Via <p pcp>, returns character position at which underlining
 *		should occur.  -1 indicates that no character should be underlined.
 *		Return value is an HRESULT (usually S_OK).
 *
 *	@comm
 *		Accelerators allow keyboard shortcuts to various UI elements (like
 *		buttons.  Typically, the shortcut character is underlined.
 *
 *		This function tells Text Services which character is the accelerator
 *		and thus should be underlined.  Note that Text Services will *not*
 *		process accelerators; that is the responsiblity of the host.
 *
 *		This method will typically only be called if the TXTBIT_SHOWACCELERATOR
 *		bit is set in text services.
 *
 *		Note that *any* change to the text in text services will result in the
 *		invalidation of the accelerator underlining.  In this case, it is the
 *		host's responsibility to recompute the appropriate character position
 *		and inform text services that a new accelerator is available.
 */
HRESULT CTxtWinHost::TxGetAcceleratorPos(
	LONG *pcp) 		//@parm Out parm to receive cp of character to underline
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetAcceleratorPos");

	*pcp = -1;
	return S_OK;
} 										

/*
 *	CTxtWinHost::OnTxCharFormatChange
 *
 *	@mfunc
 *		Set default character format for the Text Host.
 *
 *	@rdesc
 *		S_OK - call succeeded.	<nl>
 *		E_INVALIDARG			<nl>
 *		E_FAIL					<nl>
 */
HRESULT CTxtWinHost::OnTxCharFormatChange(
	const CHARFORMAT *pcf) //@parm New default character format	
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::OnTxCharFormatChange");

	return S_OK;
}

/*
 *	CTxtWinHost::OnTxParaFormatChange
 *
 *	@mfunc
 *		Set default paragraph format for the Text Host.
 *
 *	@rdesc
 *		S_OK - call succeeded.	<nl>
 *		E_INVALIDARG			<nl>
 *		E_FAIL					<nl>
 */
HRESULT CTxtWinHost::OnTxParaFormatChange(
	const PARAFORMAT *ppf) //@parm New default paragraph format	
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::OnTxParaFormatChange");

	return S_OK;
}

/*
 *	CTxtWinHost::TxGetPropertyBits (dwMask, dwBits)
 *
 *	@mfunc
 *		Get the bit property settings for Text Host.
 *
 *	@rdesc
 *		S_OK
 *
 *	@comm
 *		This call is valid at any time, for any combination of
 *		requested property bits.  <p dwMask> may be used by the
 *		caller to request specific properties.	
 */
HRESULT CTxtWinHost::TxGetPropertyBits(
	DWORD dwMask,		//@parm	Mask of bit properties to get
	DWORD *pdwBits)		//@parm Where to put bit values
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetPropertyBits");

// FUTURE: Obvious optimization is to save bits in host the same way that
// they are returned and just return them instead of this mess.

	// Note: this RichEdit host never sets TXTBIT_SHOWACCELERATOR or
	// TXTBIT_SAVESELECTION. They are currently only used by Forms^3 host.
	// This host is always rich text.

	DWORD dwProperties = TXTBIT_RICHTEXT | TXTBIT_ALLOWBEEP;

#ifdef DEBUG
	// make sure that TS doesn't think it's plain text mode when
	// we return TXTBIT_RICHTEXT
	if((dwMask & TXTBIT_RICHTEXT) && _pserv)
	{
		DWORD mode;
		mode = _pserv->TxSendMessage(EM_GETTEXTMODE, 0, 0, NULL);
		Assert(mode == TM_RICHTEXT);
	}
#endif // DEBUG

	if(_dwStyle & ES_MULTILINE)
		dwProperties |= TXTBIT_MULTILINE;

	if(_dwStyle & ES_READONLY)
		dwProperties |= TXTBIT_READONLY;

	if(_dwStyle & ES_PASSWORD)
		dwProperties |= TXTBIT_USEPASSWORD;

	if(!(_dwStyle & ES_NOHIDESEL))
		dwProperties |= TXTBIT_HIDESELECTION;

	if(_fEnableAutoWordSel)
		dwProperties |= TXTBIT_AUTOWORDSEL;

	if(!(_dwStyle & ES_AUTOHSCROLL))
		dwProperties |= TXTBIT_WORDWRAP;

	if(_dwStyle & ES_NOOLEDRAGDROP)
		dwProperties |= TXTBIT_DISABLEDRAG;

	*pdwBits = dwProperties & dwMask;
	return NOERROR;
}

/*
 *	CTxtWinHost::TxNotify (iNotify,	pv)
 *
 *	@mfunc
 *		Notify Text Host of various events.  Note that there are
 *		two basic categories of events, "direct" events and
 *		"delayed" events.  Direct events are sent immediately as
 *		they need some processing: EN_PROTECTED is a canonical
 *		example.  Delayed events are sent after all processing
 *		has occurred; the control is thus in a "stable" state.
 *		EN_CHANGE, EN_ERRSPACE, EN_SELCHANGED are examples
 *		of delayed notifications.
 *
 *
 *	@rdesc	
 *		S_OK - call succeeded <nl>
 *		S_FALSE	-- success, but do some different action
 *		depending on the event type (see below).
 *
 *	@comm
 *		The notification events are the same as the notification
 *		messages sent to the parent window of a richedit window.
 *		The firing of events may be controlled with a mask set via
 *		the EM_SETEVENTMASK message.
 *
 *		In general, is legal to make any calls to text services while
 *		processing this method; however, implementors are cautioned
 *		to avoid excessive recursion.
 *
 *		Here is the complete list of notifications that may be
 *		sent and a brief description of each:
 *
 *		<p EN_CHANGE>		Sent when some data in the edit control
 *		changes (such as text or formatting).  Controlled by the
 *		ENM_CHANGE event mask.  This notification is sent _after_
 *		any screen updates have been requested.
 *
 *		<p EN_CORRECTTEXT>	PenWin only; currently unused.
 *
 *		<p EN_DROPFILES>	If the client registered the edit
 *		control via DragAcceptFiles, this event will be sent when
 *		a WM_DROPFILES or DragEnter(CF_HDROP) message is received.
 *		If S_FALSE is returned, the drop will be ignored, otherwise,
 *		the drop will be processed.  The ENM_DROPFILES mask
 *		controls this event notification.
 *
 *		<p EN_ERRSPACE>		Sent when the edit control cannot
 *		allocate enough memory.  No additional data is sent and
 *		there is no mask for this event.
 *
 *		<p EN_HSCROLL>		Sent when the user clicks on an edit
 *		control's horizontal scroll bar, but before the screen
 *		is updated.  No additional data is sent.  The ENM_SCROLL
 *		mask controls this event.
 *
 *		<p EN_IMECHANGE>	unused
 *
 *		<p EN_KILLFOCUS>	Sent when the edit control looses focus.
 *		No additional data is sent and there is no mask.
 *
 *		<p EN_MAXTEXT>	Sent when the current text insertion
 *		has exceeded the specified number of characters for the
 *		edit control.  The text insertion has been truncated.
 *		There is no mask for this event.
 *
 *		<p EN_MSGFILTER>	NB!!! THIS MESSAGE IS NOT SENT TO
 *		TxNotify, but is included here for completeness.  With
 *		ITextServices::TxSendMessage, client have complete
 *		flexibility in filtering all window messages.
 *	
 *		Sent on a keyboard or mouse event
 *		in the control.  A MSGFILTER data structure is sent,
 *		containing the msg, wparam and lparam.  If S_FALSE is
 *		returned from this notification, the msg is processed by
 *		TextServices, otherwise, the message is ignored.  Note
 *		that in this case, the callee has the opportunity to modify
 *		the msg, wparam, and lparam before TextServices continues
 *		processing.  The ENM_KEYEVENTS and ENM_MOUSEEVENTS masks
 *		control this event for the respective event types.
 *
 *		<p EN_OLEOPFAILED> 	Sent when an OLE call fails.  The
 *		ENOLEOPFAILED struct is passed with the index of the object
 *		and the error code.  Mask value is nothing.
 *		
 *		<p EN_PROTECTED>	Sent when the user is taking an
 *		action that would change a protected range of text.  An
 *		ENPROTECTED data structure is sent, indicating the range
 *		of text affected and the window message (if any) affecting
 *		the change.  If S_FALSE is returned, the edit will fail.
 *		The ENM_PROTECTED mask controls this event.
 *
 *		<p EN_REQUESTRESIZE>	Sent when a control's contents are
 *		either smaller or larger than the control's window size.
 *		The client is responsible for resizing the control.  A
 *		REQRESIZE structure is sent, indicating the new size of
 *		the control.  NB!  Only the size is indicated in this
 *		structure; it is the host's responsibility to do any
 *		translation necessary to generate a new client rectangle.
 *		The ENM_REQUESTRESIZE mask controls this event.
 *
 *		<p EN_SAVECLIPBOARD> Sent when an edit control is being
 *		destroyed, the callee should indicate whether or not
 *		OleFlushClipboard should be called.  Data indicating the
 *		number of characters and objects to be flushed is sent
 *		in the ENSAVECLIPBOARD data structure.
 *		Mask value is nothing.
 *
 *		<p EN_SELCHANGE>	Sent when the current selection has
 *		changed.  A SELCHANGE data structure is also sent, which
 *		indicates the new selection range at the type of data
 *		the selection is currently over.  Controlled via the
 *		ENM_SELCHANGE mask.
 *
 *		<p EN_SETFOCUS>	Sent when the edit control receives the
 *		keyboard focus.  No extra data is sent; there is no mask.
 *
 *		<p EN_STOPNOUNDO>	Sent when an action occurs for which
 *		the control cannot allocate enough memory to maintain the
 *		undo state.  If S_FALSE is returned, the action will be
 *		stopped; otherwise, the action will continue.
 *
 *		<p EN_UPDATE>	Sent before an edit control requests a
 *		redraw of altered data or text.  No additional data is
 *		sent.  This event is controlled via the ENM_UPDATE mask.
 *
 *		<p EN_VSCROLL>	Sent when the user clicks an edit control's
 *		vertical scrollbar bar before the screen is updated.
 *		Controlled via the ENM_SCROLL mask; no extra data is sent.
 *
 *		<p EN_LINK>		Sent when a mouse event (or WM_SETCURSOR) happens
 *		over a range of text that has the EN_LINK mask bit set.
 *		An ENLINK data structure will be sent with relevant info.
 */
HRESULT CTxtWinHost::TxNotify(
	DWORD iNotify,		//@parm	Event to notify host of.  One of the
						//		EN_XXX values from Win32, e.g., EN_CHANGE
	void *pv)			//@parm In-only parameter with extra data.  Type
						//		dependent on <p iNotify>
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxNotify");

	HRESULT		hr = NOERROR;
	LONG		nId;
	NMHDR *		phdr;
	REQRESIZE *	preq;
	RECT		rcOld;

	// We assume here that TextServices has already masked out notifications,
	// so if we get one here, it should be sent
	if(_hwndParent)
	{
		nId = GetWindowLong(_hwnd, GWL_ID);
		// First, handle WM_NOTIFY style notifications
		switch(iNotify)
		{
		case EN_REQUESTRESIZE:
			// Need to map new size into correct rectangle
			Assert(pv);
			GetWindowRect(_hwnd, &rcOld);
			MapWindowPoints(HWND_DESKTOP, _hwndParent, (POINT *) &rcOld, 2);
			
			preq = (REQRESIZE *)pv;
			preq->rc.top	= rcOld.top;
			preq->rc.left	= rcOld.left;
			preq->rc.right	+= rcOld.left;
			preq->rc.bottom += rcOld.top;

			// FALL-THROUGH!!
					
		case EN_DROPFILES:
		case EN_MSGFILTER:
		case EN_OLEOPFAILED:
		case EN_PROTECTED:
		case EN_SAVECLIPBOARD:
		case EN_SELCHANGE:
		case EN_STOPNOUNDO:
		case EN_LINK:
		case EN_OBJECTPOSITIONS:
		case EN_DRAGDROPDONE:
	
			if(pv)						// Fill out NMHDR portion of pv
			{
				phdr = (NMHDR *)pv;
  				phdr->hwndFrom = _hwnd;
				phdr->idFrom = nId;
				phdr->code = iNotify;
			}

			if(SendMessage(_hwndParent, WM_NOTIFY, (WPARAM) nId, (LPARAM) pv))
				hr = S_FALSE;
			break;

		default:
			SendMessage(_hwndParent, WM_COMMAND,
					GET_WM_COMMAND_MPS(nId, _hwnd, iNotify));
		}
	}

	return hr;
}

/*
 *	CTxtWinHost::TxGetExtent (lpExtent)
 *
 *	@mfunc
 *		Return native size of the control in HIMETRIC
 *
 *	@rdesc
 *		S_OK	<nl>
 *		some failure code <nl>
 *
 *	@comm
 *		This method is used by Text Services to implement zooming.
 *		Text Services would derive the zoom factor from the ratio between
 *		the himetric and device pixel extent of the client rectangle.
 *	
 *		[vertical zoom factor] = [pixel height of the client rect] * 2540
 *		/ [himetric vertical extent] * [pixel per vertical inch (from DC)]
 *	
 *		If the vertical and horizontal zoom factors are not the same, Text
 *		Services could ignore the horizontal zoom factor and assume it is
 *		the same as the vertical one.
 */
HRESULT CTxtWinHost::TxGetExtent(
	LPSIZEL lpExtent) 	//@parm  Extent in himetric
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetExtent");

	AssertSz(lpExtent, "CTxtWinHost::TxGetExtent Invalid lpExtent");

	// We could implement the TxGetExtent in the following way. However, the
	// call to this in ITextServices is implemented in such a way that it
	// does something sensible in the face of an error in this call. That
	// something sensible is that it sets the extent equal to the current
	// client rectangle which is what the following does in a rather convoluted
	// manner. Therefore, we dump the following and just return an error.


#if 0
	// The window's host extent is always the same as the client
	// rectangle.
	RECT rc;
	HRESULT hr = TxGetClientRect(&rc);

	// Get our client rectangle
	if(SUCCEEDED(hr))
	{
		// Calculate the length & convert to himetric
		lpExtent->cx = DXtoHimetricX(rc.right - rc.left, W32->GetXPerInchScreenDC());
		lpExtent->cy = DYtoHimetricY(rc.bottom - rc.top, W32->GetYPerInchScreenDC());
	}

	return hr;
#endif // 0

	return E_NOTIMPL;
}

/*
 *	CTxtWinHost::TxGetSelectionBarWidth (lSelBarWidth)
 *
 *	@mfunc
 *		Returns size of selection bar in HIMETRIC
 *
 *	@rdesc
 *		S_OK	<nl>
 */
HRESULT	CTxtWinHost::TxGetSelectionBarWidth (
	LONG *lSelBarWidth)		//@parm  Where to return selection bar width
							// in HIMETRIC
{
	*lSelBarWidth = (_dwStyle & ES_SELECTIONBAR) ? W32->GetDxSelBar() : 0;
	return S_OK;
}

//
//	ITextHost2 methods
//

/*
 *	CTxtWinHost::TxIsDoubleClickPending
 *
 *	@mfunc	Look into the message queue for this hwnd and see if a
 *			double click is pending.  This enables TextServices to
 *			effeciently transition between two inplace active objects.
 *
 *	@rdesc	BOOL
 */
BOOL CTxtWinHost::TxIsDoubleClickPending()
{
	MSG msg;

	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN,
			"CTxtWinHost::TxIsDoubleClickPending");

	if(PeekMessage(&msg, _hwnd, WM_LBUTTONDBLCLK, WM_LBUTTONDBLCLK,
			PM_NOREMOVE | PM_NOYIELD))
	{
		return TRUE;
	}
	return FALSE;
}

/*
 *	CTxtWinHost::TxGetWindow
 *
 *	@mfunc	Fetches the window associated with this control (or
 *			set of controls potentially).  Useful for answering
 *			IOleWindow::GetWindow.
 *
 *	@rdesc	HRESULT
 */
HRESULT CTxtWinHost::TxGetWindow(HWND *phwnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::GetWindow");
	
	*phwnd = _hwnd;
	return NOERROR;
}	


/*
 *	CTxtWinHost::SetForegroundWindow
 *
 *	@mfunc	Sets window to foreground window & gives the focus
 *
 *	@rdesc	NOERROR - succeeded
 *			E_FAIL - failed.
 */
HRESULT CTxtWinHost::TxSetForegroundWindow()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN,
		"CTxtWinHost::SetForegroundWindow");

	if(!SetForegroundWindow(_hwnd))
		SetFocus(_hwnd);

	return NOERROR;
}	


/*
 *	CTxtWinHost::TxGetPalette
 *
 *	@mfunc	Returns application specific palette if there is one
 *
 *	@rdesc	~NULL - there was one
 *			NULL - use default palette
 */
HPALETTE CTxtWinHost::TxGetPalette()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN,
		"CTxtWinHost::TxGetPalette");

	return _hpal;
}	


/*
 *	CTxtWinHost::TxGetFEFlags
 *
 *	@mfunc	return FE settings
 *
 *	@rdesc	NOERROR - succeeded
 *			E_FAIL - failed.
 */
HRESULT CTxtWinHost::TxGetFEFlags(LONG *pFEFlags)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN,
		"CTxtWinHost::TxGetFEFlags");

	if (!pFEFlags)
		return E_INVALIDARG;
	*pFEFlags = 0;

	if (_usIMEMode == ES_NOIME)
		*pFEFlags |= ES_NOIME;
	if (_usIMEMode == ES_SELFIME)
		*pFEFlags |= ES_SELFIME;

	return NOERROR;
}


// Helper function in edit.cpp
LONG GetECDefaultHeightAndWidth(
	ITextServices *pts,
	HDC hdc,
	LONG lZoomNumerator,
	LONG lZoomDenominator,
	LONG yPixelsPerInch,
	LONG *pxAveWidth,
	LONG *pxOverhang,
	LONG *pxUnderhang);


/*
 *	CTxtWinHost::OnSetMargins
 *
 *	@mfunc	Handle EM_SETMARGINS message
 *
 *	@rdesc	None.
 */
void CTxtWinHost::OnSetMargins(
	DWORD fwMargin,		//@parm Type of requested operation
	DWORD xLeft,		//@parm Where to put left margin
	DWORD xRight)		//@parm Where to put right margin
{
	LONG xLeftMargin = -1;
	LONG xRightMargin = -1;
	HDC hdc;

	if(EC_USEFONTINFO == fwMargin)
	{
		// Get the DC since it is needed for the call
		hdc = GetDC(_hwnd);

		// Multiline behaves differently than single line
		if (_dwStyle & ES_MULTILINE)
		{
			// Multiline - over/underhange controls margin
			GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
				W32->GetYPerInchScreenDC(), NULL,
				&xLeftMargin, &xRightMargin);
		}
		else
		{
			// Single line edit controls set the margins to
			// the average character width on both left and
			// right.
			GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
				W32->GetYPerInchScreenDC(), &xLeftMargin, NULL, NULL);

			xRightMargin = xLeftMargin;
		}
		ReleaseDC(_hwnd, hdc);
	}
	else
	{
		// The request is for setting exact pixels.
		if(EC_LEFTMARGIN & fwMargin)
			xLeftMargin = xLeft;

		if(EC_RIGHTMARGIN & fwMargin)
			xRightMargin = xRight;
	}

	// Set left margin if so requested
	if (xLeftMargin != -1)
		_rcViewInset.left =	W32->DXtoHimetricX(xLeftMargin, W32->GetXPerInchScreenDC());

	// Set right margin if so requested
	if (xRightMargin != -1)
		_rcViewInset.right = W32->DXtoHimetricX(xRightMargin, W32->GetXPerInchScreenDC());

	if (xLeftMargin != -1 || xRightMargin != -1)
		_pserv->OnTxPropertyBitsChange(TXTBIT_VIEWINSETCHANGE, TXTBIT_VIEWINSETCHANGE);
}

/*
 *	CTxtWinHost::SetScrollInfo
 *
 *	@mfunc	Set scrolling information for the scroll bar.
 */
void CTxtWinHost::SetScrollInfo(
	INT fnBar,			//@parm	Specifies scroll bar to be updated
	BOOL fRedraw)		//@parm whether redraw is necessary
{
	// Set up the basic structure for the call
	SCROLLINFO si;
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_ALL;

	AssertSz(_pserv != NULL,
		"CTxtWinHost::SetScrollInfo called with NULL _pserv");

	// Call back to the control to get the parameters
	if(fnBar == SB_HORZ)
	{
		_pserv->TxGetHScroll((LONG *) &si.nMin, (LONG *) &si.nMax,
			(LONG *) &si.nPos, (LONG *) &si.nPage, NULL);
	}
	else
	{
		_pserv->TxGetVScroll((LONG *) &si.nMin,
			(LONG *) &si.nMax, (LONG *) &si.nPos, (LONG *) &si.nPage, NULL);
	}

	// Do the call
	::SetScrollInfo(_hwnd, fnBar, &si, fRedraw);
}

/*
 *	CTxtWinHost::SetScrollBarsForWmEnable
 *
 *	@mfunc	Enable/Disable scroll bars
 *
 *	@rdesc	None.
 */
void CTxtWinHost::SetScrollBarsForWmEnable(
	BOOL fEnable)		//@parm Whether scrollbars s/b enabled or disabled.
{
	if(!_pserv)						// If no edit object,
		return;						//  no scrollbars

	BOOL fHoriz = FALSE;
	BOOL fVert = FALSE;
	UINT wArrows = fEnable ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH;

	_pserv->TxGetHScroll(NULL, NULL, NULL, NULL, &fHoriz);
	_pserv->TxGetVScroll(NULL, NULL, NULL, NULL, &fVert);

	if(fHoriz)						// There is a horizontal scroll bar
		W32->EnableScrollBar(_hwnd, SB_HORZ, wArrows);

	if(fVert)						// There is a vertical scroll bar
		W32->EnableScrollBar(_hwnd, SB_VERT, wArrows);
}

/*
 *	CTxtWinHost::SetScrollBarsForWmEnable
 *
 *	@mfunc	Notification that Text Services is released.
 *
 *	@rdesc	None.
 */
void CTxtWinHost::TxFreeTextServicesNotification()
{
	_fTextServiceFree = TRUE;
}

/*
 *	CTxtWinHost::TxGetEditStyle
 *
 *	@mfunc	Get Edit Style flags
 *
 *	@rdesc	NOERROR is data available.
 */
HRESULT CTxtWinHost::TxGetEditStyle(
	DWORD dwItem,
	DWORD *pdwData)
{
	if (!pdwData)
		return E_INVALIDARG;
	
	*pdwData = 0;

	if (dwItem & TXES_ISDIALOG && _fInDialogBox)
		*pdwData |= TXES_ISDIALOG;

	return NOERROR;
}

/*
 *	CTxtWinHost::TxGetWindowStyles
 *
 *	@mfunc	Return window style bits
 *
 *	@rdesc	NOERROR is data available.
 */
HRESULT CTxtWinHost::TxGetWindowStyles(DWORD *pdwStyle, DWORD *pdwExStyle)
{
	if (!pdwStyle || !pdwExStyle)
		return E_INVALIDARG;

	*pdwStyle = _dwStyle;
	*pdwExStyle = _dwExStyle;

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\iaccess.cpp ===
/*
 *	IACCESS.CPP 
 *
 *  Purpose:
 *      Implemenation of IAccessibility for listbox and combobox
 *		
 *	Original Author: 
 *		Jerry Kim
 *
 *	History: <nl>
 *		01/04/99 - v-jerrki Created
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_host.h"
#include "_cbhost.h"

#ifndef NOACCESSIBILITY

extern LRESULT CALLBACK RichListBoxWndProc(HWND, UINT, WPARAM, LPARAM);

#define InitPv(pv)              *pv = NULL
#define InitPlong(plong)        *plong = 0
#define InitPvar(pvar)           pvar->vt = VT_EMPTY
#define ValidateFlags(flags, valid)         (!((flags) & ~(valid)))
#define InitAccLocation(px, py, pcx, pcy)   {InitPlong(px); InitPlong(py); InitPlong(pcx); InitPlong(pcy);}

#ifdef _WIN64
#define HwndFromHWNDID(lId)         (HWND)((DWORD_PTR)(lId) & ~0x80000000)
#else
#define HwndFromHWNDID(lId)         (HWND)((lId) & ~0x80000000)
#endif // _WIN64

// this is for ClickOnTheRect
typedef struct tagMOUSEINFO
{
    int MouseThresh1;
    int MouseThresh2;
    int MouseSpeed;
}
MOUSEINFO, FAR* LPMOUSEINFO;

#define IsHWNDID(lId)               ((lId) & 0x80000000)

//////////////////////// Accessibility Utility Functions ///////////////////////////

namespace MSAA
{

// --------------------------------------------------------------------------
//
//  InitTypeInfo()
//
//  This initializes our type info when we need it for IDispatch junk.
//
// --------------------------------------------------------------------------
HRESULT InitTypeInfo(ITypeInfo** ppiTypeInfo)
{
    Assert(ppiTypeInfo);

    if (*ppiTypeInfo)
        return S_OK;

    // Try getting the typelib from the registry
    ITypeLib    *piTypeLib;    
    HRESULT hr = LoadRegTypeLib(LIBID_Accessibility, 1, 0, 0, &piTypeLib);

    if (FAILED(hr))
        hr = LoadTypeLib(OLESTR("OLEACC.DLL"), &piTypeLib);

    if (SUCCEEDED(hr))
    {
        hr = piTypeLib->GetTypeInfoOfGuid(IID_IAccessible, ppiTypeInfo);
        piTypeLib->Release();

        if (!SUCCEEDED(hr))
            *ppiTypeInfo = NULL;
    }
    return(hr);
}


// --------------------------------------------------------------------------
//
//  ValidateChild()
//
// --------------------------------------------------------------------------
BOOL ValidateChild(VARIANT *pvar, int ctChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "ValidateChild");
    
    // Missing parameter, a la VBA
TryAgain:
    switch (pvar->vt)
    {
        case VT_VARIANT | VT_BYREF:
            W32->VariantCopy(pvar, pvar->pvarVal);
            goto TryAgain;

        case VT_ERROR:
            if (pvar->scode != DISP_E_PARAMNOTFOUND)
                return(FALSE);
            // FALL THRU

        case VT_EMPTY:
            pvar->vt = VT_I4;
            pvar->lVal = 0;
            break;

        case VT_I4:
            if ((pvar->lVal < 0) || (pvar->lVal > ctChild))
                return(FALSE);
            break;

        default:
            return(FALSE);
    }

    return(TRUE);
}


// --------------------------------------------------------------------------
//
//  ValidateSelFlags()
//
//  Validates selection flags.
// this makes sure the only bits set are in the valid range and that you don't
// have any invalid combinations.
// Invalid combinations are
// ADDSELECTION and REMOVESELECTION
// ADDSELECTION and TAKESELECTION
// REMOVESELECTION and TAKESELECTION
// EXTENDSELECTION and TAKESELECTION
//
// --------------------------------------------------------------------------
BOOL ValidateSelFlags(long flags)
{
    if (!ValidateFlags((flags), SELFLAG_VALID))
        return (FALSE);

    if ((flags & SELFLAG_ADDSELECTION) && 
        (flags & SELFLAG_REMOVESELECTION))
        return FALSE;

    if ((flags & SELFLAG_ADDSELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    if ((flags & SELFLAG_REMOVESELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    if ((flags & SELFLAG_EXTENDSELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    return TRUE;
}

// --------------------------------------------------------------------------
//
//  GetStringResource(UINT id, WCHAR* psz, int nSize)
//
//  Gets the string resource for a given id and puts it in the passed buffer
//
// --------------------------------------------------------------------------
HRESULT GetStringResource(UINT id, BSTR* pbstr)
{
    
    WCHAR sz[MAX_PATH] = L"\0";

    if (!pbstr)
        return S_FALSE;

/*     
    // UNDONE:
    //  Need a workaround for this localization issue

    if (Win9x())
    {
        if (!LoadStringA(hinstResDll, id, sz, MAX_PATH))
            return(E_OUTOFMEMORY);

        // On Win9x we get ansi so convert it
        int cchUText = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)sz, -1, NULL, 0) + 1;
        *pbstr = SysAllocStringLen(NULL, cchUText);
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)psz, -1, *pbstr, cchUText);
    }
    else
    {
        if (!LoadStringW(hinstResDll, id, sz, MAX_PATH))
            return(E_OUTOFMEMORY);    
        *pbstr = SysAllocString(sz);
    }
*/

#define STR_DOUBLE_CLICK            1
#define STR_DROPDOWN_HIDE           2
#define STR_DROPDOWN_SHOW           3
#define STR_ALT                     4
#define STR_COMBOBOX_LIST_SHORTCUT  5

    switch (id)
    {
        case STR_DOUBLE_CLICK:
            //"Double Click"
            wcscpy(sz, L"Double Click");
            break;
            
        case STR_DROPDOWN_HIDE:
            //"Hide"
            wcscpy(sz, L"Hide");
            break;
            
        case STR_DROPDOWN_SHOW:
            //"Show"
            wcscpy(sz, L"Show");
            break;

        case STR_ALT:
            //"Alt+"
            wcscpy(sz, L"Alt+");
            break;
            
        case STR_COMBOBOX_LIST_SHORTCUT:
            //"Alt+Down Arrow"
            wcscpy(sz, L"Alt+Down Arrow");
            break;

        default:
            AssertSz(FALSE, "id not found!!");
    }

    *pbstr = SysAllocString(sz);
    if (!*pbstr)
        return(E_OUTOFMEMORY);
        
    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  HWND GetAncestor(HWND hwnd, UINT gaFlags)
//
//  This gets the ancestor window where
//      GA_PARENT   gets the "real" parent window
//      GA_ROOT     gets the "real" top level parent window (not inc. owner)r
//
//      * The _real_ parent.  This does NOT include the owner, unlike
//          GetParent().  Stops at a top level window unless we start with
//          the desktop.  In which case, we return the desktop.
//      * The _real_ root, caused by walking up the chain getting the
//          ancestor.
//
//  NOTE:
//      User32.exe provides a undocumented function similar to this but
//  it doesn't exist in NT4.  Also, GA_ROOT works differently on Win98 so
//  I copied this over from msaa
// --------------------------------------------------------------------------
HWND GetAncestor(HWND hwnd, UINT gaFlags)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetAncestor");
    
    HWND hwndDesktop = GetDesktopWindow();
    if (hwnd == hwndDesktop || !::IsWindow(hwnd))
        return(NULL);
        
    DWORD dwStyle = GetWindowLong (hwnd, GWL_STYLE);

    HWND	hwndParent;
    switch (gaFlags)
    {
        case GA_PARENT:
            if (dwStyle & WS_CHILD)
                hwndParent = GetParent(hwnd);
            else
                hwndParent = GetWindow(hwnd, GW_OWNER);
    		hwnd = hwndParent;
            break;
            
        case GA_ROOT:
            if (dwStyle & WS_CHILD)
                hwndParent = GetParent(hwnd);
            else
                hwndParent = GetWindow(hwnd, GW_OWNER);
            while (hwndParent != hwndDesktop && hwndParent != NULL)
            {
                hwnd = hwndParent;
                dwStyle = GetWindowLong(hwnd, GWL_STYLE);
                if (dwStyle & WS_CHILD)
                    hwndParent = GetParent(hwnd);
                else
                    hwndParent = GetWindow(hwnd, GW_OWNER);
            }
            break;

        default:
            AssertSz(FALSE, "Invalid flag");
    }    
    return(hwnd);
}


// --------------------------------------------------------------------------
//
//  GetTextString(HWND hwnd, BSTR* bstr)
//
//  Parameters: hwnd of the window to get the text from
//
// --------------------------------------------------------------------------
HRESULT GetTextString(HWND hwnd, BSTR* pbstr)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetTextString");
    
    WCHAR   sz[MAX_PATH + 1];
    WCHAR   *psz = sz;

    int cchText = SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0);

    // allocate memory from heap if stack buffer is insufficient
    if (cchText >= MAX_PATH)
        psz = new WCHAR[cchText + 1];

    if (!psz)
        return E_OUTOFMEMORY;

    // retrieve text
    HRESULT hres = S_OK;
    SendMessage(hwnd, WM_GETTEXT, cchText + 1, (LPARAM)psz);

    if (!*psz)
        *pbstr = NULL;
    else
    {
        *pbstr = SysAllocString(psz);
        if (!*pbstr)
            hres = E_OUTOFMEMORY;
    }
    
    // free memory if memory was allocated from heap
    if (psz != sz)
        delete [] psz;

    return hres;
}


// --------------------------------------------------------------------------
//
//  HRESULT GetLabelString(HWND hwnd, BSTR* pbstr)
//
//  This walks backwards among peer windows to find a static field.  It stops
//  if it gets to the front or hits a group/tabstop, just like the dialog 
//  manager does.
//
//  RETURN:
//   HRESULT ? S_OK on success : S_FALSE or COM error on failure
// --------------------------------------------------------------------------
HRESULT GetLabelString(HWND hwnd, BSTR* pbstr)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetLabelString");
    
    HWND hwndLabel = hwnd;
    while (hwndLabel = ::GetWindow(hwndLabel, GW_HWNDPREV))
    {
        LONG lStyle = GetWindowLong(hwndLabel, GWL_STYLE);

        // Skip if invisible
        if (!(lStyle & WS_VISIBLE))
            continue;

        // Is this a static dude?
        LRESULT lResult = SendMessage(hwndLabel, WM_GETDLGCODE, 0, 0L);
        if (lResult & DLGC_STATIC)
        {
            // Great, we've found our label.
            return GetTextString(hwndLabel, pbstr);
        }

        // Is this a tabstop or group?  If so, bail out now.
        if (lStyle & (WS_GROUP | WS_TABSTOP))
            break;
    }

    return S_FALSE;
}


// --------------------------------------------------------------------------
//
//  HRESULT StripMnemonic(BSTR bstrSrc, WCHAR** pchAmp, BOOL bStopOnAmp)
//
//  This removes the mnemonic prefix.  However, if we see '&&', we keep
//  one '&'.
//
// --------------------------------------------------------------------------
HRESULT StripMnemonic(BSTR bstrSrc, WCHAR** pchAmp, BOOL bStopOnAmp)
{   
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "StripMnemonic");
    
    const WCHAR amp = L'&';
    
    if (pchAmp)
        *pchAmp = NULL;
    
    WCHAR *psz = (WCHAR*)bstrSrc;
    while (*psz)
    {
        if (*psz == amp)
        {
            if (*(psz + 1) == amp)
                psz++;
            else
            {
                if (pchAmp)
                    *pchAmp = psz;
                break;
            }
        }
        psz++;
    }

    // Start moving all the character up 1 position
    if (!bStopOnAmp)    
        while (*psz)
            *psz = *++psz;

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  HRESULT GetWindowName(HWND hwnd, BSTR* pbstrName)
//
// --------------------------------------------------------------------------
HRESULT GetWindowName(HWND hwnd, BSTR* pbstrName)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetWindowName");
        
    // If use a label, do that instead
    if (S_OK != GetLabelString(hwnd, pbstrName) || !*pbstrName)
        return S_FALSE;

    // Strip out the mnemonic.
    return StripMnemonic(*pbstrName, NULL, FALSE);
}


// --------------------------------------------------------------------------
//
//  HRESULT GetWindowShortcut(HWND hwnd, BSTR* pbstrShortcut)
//
// --------------------------------------------------------------------------
HRESULT GetWindowShortcut(HWND hwnd, BSTR* pbstrShortcut)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetWindowShortcut");
    
    if (S_OK != GetLabelString(hwnd, pbstrShortcut) || !*pbstrShortcut)
        return S_FALSE;

    WCHAR *pch;
    StripMnemonic(*pbstrShortcut, &pch, TRUE);

    // Is there a mnemonic?
    if (pch)
    {   
        // Get a localized "Alt+" string
        BSTR pbstrAlt = NULL;
        HRESULT hr = GetStringResource(STR_ALT, &pbstrAlt);
        if (hr != S_OK || !pbstrAlt)
            return hr;
            
        // Make a string of the form "Alt+ch".
        WCHAR   szKey[MAX_PATH];
        wcsncpy (szKey, pbstrAlt, MAX_PATH);
        WCHAR   *pchTemp = szKey + wcslen(szKey);

        // Copy shortcut character
        *pchTemp = *pch;
        *(++pchTemp) = L'\0';

        // Release allocated string allocate space for new string
        SysFreeString(pbstrAlt);
        *pbstrShortcut = SysAllocString(pchTemp);
        return (*pbstrShortcut ? S_OK : E_OUTOFMEMORY);
    }

    return(S_FALSE);
}

// --------------------------------------------------------------------------
//
//  GetWindowObject()
//
//  Gets an immediate child object.
//
// --------------------------------------------------------------------------
HRESULT GetWindowObject(HWND hwndChild, VARIANT * pvar)
{
    pvar->vt = VT_EMPTY;
    IDispatch * pdispChild = NULL;
    HRESULT hr = W32->AccessibleObjectFromWindow(hwndChild, OBJID_WINDOW, IID_IDispatch,
        (void **)&pdispChild);

    if (!SUCCEEDED(hr))
        return(hr);
    if (!pdispChild)
        return(E_FAIL);

    pvar->vt = VT_DISPATCH;
    pvar->pdispVal = pdispChild;

    return(S_OK);
}

} //namespace


//////////////////////// ListBox CListBoxSelection Methods ///////////////////////////

// --------------------------------------------------------------------------
//
//  CListBoxSelection::CListBoxSelection()
//
//  We AddRef() once plistFrom so that it won't go away out from us.  When
//  we are destroyed, we will Release() it.
//
// --------------------------------------------------------------------------
CListBoxSelection::CListBoxSelection(int iChildCur, int cSelected, LPINT lpSelection)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::CListBoxSelection");
    
    _idChildCur = iChildCur;

    _cRef = 1;
    _piSel = new int[cSelected];
    if (!_piSel)
        _cSel = 0;
    else
    {
        _cSel = cSelected;
        memcpy(_piSel, lpSelection, cSelected*sizeof(int));
    }
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::~CListBoxSelection()
//
// --------------------------------------------------------------------------
CListBoxSelection::~CListBoxSelection()
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::~CListBoxSelection");
    
    // Free item memory
    if (_piSel)
    {
        delete [] _piSel;
        _piSel = NULL;
    }
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::QueryInterface()
//
//  We only respond to IUnknown and IEnumVARIANT!  It is the responsibility
//  of the caller to loop through the items using IEnumVARIANT interfaces,
//  and get the child IDs to then pass to the parent object (or call 
//  directly if VT_DISPATCH--not in this case they aren't though).
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::QueryInterface(REFIID riid, void** ppunk)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::QueryInterface");
    
    *ppunk = NULL;

    if ((riid == IID_IUnknown) || (riid == IID_IEnumVARIANT))
    {
        *ppunk = this;
    }
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN) *ppunk)->AddRef();
    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::AddRef()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListBoxSelection::AddRef(void)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::AddRef");
    
    return(++_cRef);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Release()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListBoxSelection::Release(void)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Release");
    
    if ((--_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return(_cRef);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Next()
//
//  This returns a VT_I4 which is the child ID for the parent listbox that
//  returned this object for the selection collection.  The caller turns
//  around and passes this variant to the listbox object to get acc info
//  about it.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Next(ULONG celt, VARIANT* rgvar, ULONG *pceltFetched)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Next");
    
    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    // reset temporary variable to beginning
    VARIANT *pvar = rgvar;
    long cFetched = 0;
    long iCur = _idChildCur;

    // Loop through our items
    while ((cFetched < (long)celt) && (iCur < _cSel))
    {
        VariantInit(pvar);
        pvar->vt = VT_I4;
        pvar->lVal = _piSel[iCur] + 1;

        cFetched++;
        iCur++;
        pvar++;
    }

    // Initialize the variant after the last valid one just
    // in case the client is looping based on invalid variants
    if ((ULONG)cFetched < celt)
        VariantInit(pvar);

    // Advance the current position
    _idChildCur = iCur;

    // Fill in the number fetched
    if (pceltFetched)
        *pceltFetched = cFetched;

    // Return S_FALSE if we grabbed fewer items than requested
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Skip()
//
// -------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Skip(ULONG celt)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Skip");
    
    _idChildCur += celt;
    if (_idChildCur > _cSel)
        _idChildCur = _cSel;

    // We return S_FALSE if at the end.
    return((_idChildCur >= _cSel) ? S_FALSE : S_OK);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Reset()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Reset(void)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Reset");
    
    _idChildCur = 0;
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Clone(IEnumVARIANT **ppenum)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Clone");
    
    InitPv(ppenum);
    CListBoxSelection * plistselnew = new CListBoxSelection(_idChildCur, _cSel, _piSel);
    if (!plistselnew)
        return(E_OUTOFMEMORY);

    return(plistselnew->QueryInterface(IID_IEnumVARIANT, (void**)ppenum));
}

//////////////////////// ListBox IAccessible Methods //////////////////////////////
/*
 *	CLstBxWinHost::InitTypeInfo()
 *
 *	@mfunc
 *		Retrieves type library
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
HRESULT CLstBxWinHost::InitTypeInfo()
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::InitTypeInfo");
    return MSAA::InitTypeInfo(&_pTypeInfo);
}


/*
 *	CLstBxWinHost::get_accName(VARIANT varChild, BSTR *pbstrName)
 *
 *	@mfunc
 *		SELF ? label of control : item text 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CLstBxWinHost::get_accName(VARIANT varChild, BSTR *pbstrName)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accName");
    
    InitPv(pbstrName);

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
    {
        if (_fLstType == kCombo)
            return  _pcbHost->get_accName(varChild, pbstrName);
        else
            return(MSAA::GetWindowName(_hwnd, pbstrName));
    }
    else
    {
        // Get the item text.
        LRESULT lres = RichListBoxWndProc(_hwnd, LB_GETTEXTLEN, varChild.lVal-1, 0);

        // First Check for error
        if (lres == LB_ERR)
            return S_FALSE;
       
        if (lres > 0)
        {
            // allocate some buffer
            *pbstrName = SysAllocStringLen(NULL, lres + 1);
            if (!*pbstrName)
                return E_OUTOFMEMORY;
                
            RichListBoxWndProc(_hwnd, LB_GETTEXT, varChild.lVal-1, (LPARAM)*pbstrName);
        }
    }
    return(S_OK);
}


/*
 *	CLstBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
 *
 *	@mfunc
 *		Retrieves the object's Role property. 
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accRole");
    
    InitPvar(pvarRole);

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return E_INVALIDARG;

    pvarRole->vt = VT_I4;

    if (varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_LISTITEM;
    else
        pvarRole->lVal = ROLE_SYSTEM_LIST;

    return S_OK;
}


/*
 *	CLstBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
 *
 *	@mfunc
 *		Retrieves the current state of the object or child item.  
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accState");
    
    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return E_INVALIDARG;

    InitPvar(pvarState);
    if (varChild.lVal == CHILDID_SELF)
    {
        pvarState->vt = VT_I4;
        pvarState->lVal = 0;

        if (!IsWindowVisible(_hwnd))
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

        if (!IsWindowEnabled(_hwnd))
            pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

        if (_fFocus)
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;

        if (::GetForegroundWindow() == MSAA::GetAncestor(_hwnd, GA_ROOT))
            pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        return S_OK;
    }


    --varChild.lVal;

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    // Is this item selected?
    if (IsSelected(varChild.lVal))
        pvarState->lVal |= STATE_SYSTEM_SELECTED;

    // Does it have the focus?  Remember that we decremented the lVal so it
    // is zero-based like listbox indeces.
    if (_fFocus)
    {
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        if (varChild.lVal == GetCursor())
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;            
    }

    // Is the listbox read-only?
    long lStyle = GetWindowLong(_hwnd, GWL_STYLE);

    if (lStyle & LBS_NOSEL)
        pvarState->lVal |= STATE_SYSTEM_READONLY;
    else
    {
        pvarState->lVal |= STATE_SYSTEM_SELECTABLE;

        // Is the listbox multiple and/or extended sel?  NOTE:  We have
        // no way to implement accSelect() EXTENDSELECTION so don't.
        if (lStyle & LBS_MULTIPLESEL)
            pvarState->lVal |= STATE_SYSTEM_MULTISELECTABLE;
    }

    // Is the item in view?
    //
	// SMD 09/16/97 Offscreen things are things never on the screen,
	// and that doesn't apply to this. Changed from OFFSCREEN to
	// INVISIBLE.
	RECT    rcItem;
    if (!RichListBoxWndProc(_hwnd, LB_GETITEMRECT, varChild.lVal, (LPARAM)&rcItem))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    return S_OK;
}

/*
 *	CLstBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
 *
 *	@mfunc
 *		Retrieves an object's KeyboardShortcut property.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accKeyboardShortcut");
    
    // Validate
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if ((varChild.lVal == 0) && _fLstType != kCombo)
    {
        InitPv(pszShortcut);
        return(MSAA::GetWindowShortcut(_hwnd, pszShortcut));
    }
    return(DISP_E_MEMBERNOTFOUND);
}


/*
 *	CLstBxWinHost::get_accFocus(VARIANT *pvarChild)
 *
 *	@mfunc
 *		Retrieves the child object that currently has the keyboard focus.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accFocus(VARIANT *pvarChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accFocus");
    
    InitPvar(pvarChild);

    // Are we the focus?
    if (_fFocus)
    {
        pvarChild->vt = VT_I4;
        if (GetCursor() >= 0)
            pvarChild->lVal = GetCursor() + 1;
        else
            pvarChild->lVal = 0;
        return S_OK;
    }
    else
        return S_FALSE;
}


/*
 *	CLstBxWinHost::get_accSelection(VARIANT *pvarSelection)
 *
 *	@mfunc
 *		Retrieves the selected children of this object. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accSelection(VARIANT *pvarSelection)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accSelection");

    InitPvar(pvarSelection);

    int cSel = RichListBoxWndProc(_hwnd, LB_GETSELCOUNT, 0, 0);
    
    if (cSel <= 1)
    {
        // cSelected is -1, 0, or 1.  
        //      -1 means this is a single sel listbox.  
        //      0 or 1 means this is multisel
        if (GetCursor() < 0)
            return S_FALSE;
            
        pvarSelection->vt = VT_I4;
        pvarSelection->lVal = GetCursor() + 1;
        return(S_OK);
    }

    // Allocate memory for the list of item IDs
    int * plbs = new int[cSel];
    if (!plbs)
        return(E_OUTOFMEMORY);
    
    // Multiple items; must make a collection
    // Get the list of selected item IDs
    int j = 0;
    for (long i = 0; i < GetCount(); i++)
    {
		if (IsSelected(i) == TRUE)
		    plbs[j++] = i;
	}
			
    CListBoxSelection *plbsel = new CListBoxSelection(0, cSel, plbs);
    delete [] plbs;

    // check if memory allocation failed
    if (!plbsel)
        return(E_OUTOFMEMORY);
        
    pvarSelection->vt = VT_UNKNOWN;
    return plbsel->QueryInterface(IID_IUnknown, (void**)&(pvarSelection->punkVal));
}


/*
 *	CLstBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefAction)
 *
 *	@mfunc
 *		Retrieves a string containing a localized sentence that describes the object's default action. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefAction)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accDefaultAction");
    
    InitPv(pszDefAction);

    // Validate.
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if (varChild.lVal)
        return (MSAA::GetStringResource(STR_DOUBLE_CLICK, pszDefAction));

    return(DISP_E_MEMBERNOTFOUND);
}


/*
 *	CLstBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
 *
 *	@mfunc
 *		Retrieves the object's current screen location (if the object was placed on 
 *  the screen) and optionally, the child element. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accLocation");
    
    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    // Validate params
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return E_INVALIDARG;

    RECT    rc;
    if (!varChild.lVal)
        GetClientRect(_hwnd, &rc);
    else if (!RichListBoxWndProc(_hwnd, LB_GETITEMRECT, varChild.lVal-1, (LPARAM)&rc))
        return S_OK;

    // Convert coordinates to screen coordinates
    *pcxWidth = rc.right - rc.left;
    *pcyHeight = rc.bottom - rc.top;    
    
    ClientToScreen(_hwnd, (LPPOINT)&rc);
    *pxLeft = rc.left;
    *pyTop = rc.top;

    return S_OK;
}

/*
 *	CLstBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarHit)
 *
 *	@mfunc
 *		Retrieves the child object at a given point on the screen. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarHit)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accHitTest");
    
    InitPvar(pvarHit);

    // Is the point in our client area?
    POINT   pt = {xLeft, yTop};
    ScreenToClient(_hwnd, &pt);

    RECT    rc;
    GetClientRect(_hwnd, &rc);

    if (!PtInRect(&rc, pt))
        return(S_FALSE);

    // What item is here?
    long l = GetItemFromPoint(&pt);
    pvarHit->vt = VT_I4;
    pvarHit->lVal = (l >= 0) ? l + 1 : 0;
    
    return(S_OK);
}


/*
 *	CLstBxWinHost::accDoDefaultAction(VARIANT varChild)
 *
 *	@mfunc
 *		Performs the object's default action. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accDoDefaultAction(VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accDoDefaultAction");
    
    // Validate
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if (varChild.lVal)
    {        
        // this will check if WindowFromPoint at the click point is the same
	    // as m_hwnd, and if not, it won't click. Cool!
	    
        RECT	rcLoc;
	    HRESULT hr = accLocation(&rcLoc.left, &rcLoc.top, &rcLoc.right, &rcLoc.bottom, varChild);
	    if (!SUCCEEDED (hr))
		    return (hr);

        // Find Center of rect
        POINT ptClick;
    	ptClick.x = rcLoc.left + (rcLoc.right/2);
    	ptClick.y = rcLoc.top + (rcLoc.bottom/2);

    	// check if hwnd at point is same as hwnd to check
    	if (WindowFromPoint(ptClick) != _hwnd)
    		return DISP_E_MEMBERNOTFOUND;

        W32->BlockInput(TRUE);
        
        // Get current cursor pos.
        POINT ptCursor;
        DWORD dwMouseDown, dwMouseUp;
        GetCursorPos(&ptCursor);
    	if (GetSystemMetrics(SM_SWAPBUTTON))
    	{
    		dwMouseDown = MOUSEEVENTF_RIGHTDOWN;
    		dwMouseUp = MOUSEEVENTF_RIGHTUP;
    	}
    	else
    	{
    		dwMouseDown = MOUSEEVENTF_LEFTDOWN;
    		dwMouseUp = MOUSEEVENTF_LEFTUP;
    	}

        // Get delta to move to center of rectangle from current
        // cursor location.
        ptCursor.x = ptClick.x - ptCursor.x;
        ptCursor.y = ptClick.y - ptCursor.y;

        // NOTE:  For relative moves, USER actually multiplies the
        // coords by any acceleration.  But accounting for it is too
        // hard and wrap around stuff is weird.  So, temporarily turn
        // acceleration off; then turn it back on after playback.

        // Save mouse acceleration info
        MOUSEINFO	miSave, miNew;
        if (!SystemParametersInfo(SPI_GETMOUSE, 0, &miSave, 0))
        {
            W32->BlockInput(FALSE);
            return (DISP_E_MEMBERNOTFOUND);
        }

        if (miSave.MouseSpeed)
        {
            miNew.MouseThresh1 = 0;
            miNew.MouseThresh2 = 0;
            miNew.MouseSpeed = 0;

            if (!SystemParametersInfo(SPI_SETMOUSE, 0, &miNew, 0))
            {
                W32->BlockInput(FALSE);
                return (DISP_E_MEMBERNOTFOUND);
            }
        }

        // Get # of buttons
        int nButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);

        // mouse move to center of start button
        INPUT		rgInput[6];
        rgInput[0].type = INPUT_MOUSE;
        rgInput[0].mi.dwFlags = MOUSEEVENTF_MOVE;
        rgInput[0].mi.dwExtraInfo = 0;
        rgInput[0].mi.dx = ptCursor.x;
        rgInput[0].mi.dy = ptCursor.y;
        rgInput[0].mi.mouseData = nButtons;

        int i = 1;

        // MSAA's order of double click is 
        // WM_LBUTTONDOWN
        // WM_LBUTTONUP
        // WM_LBUTTONDOWN
        // WM_LBUTTONUP
        while (i <= 4)
        {
            if (i % 2)
                rgInput[i].mi.dwFlags = dwMouseDown;
            else
                rgInput[i].mi.dwFlags = dwMouseUp;
                
            rgInput[i].type = INPUT_MOUSE;
            rgInput[i].mi.dwExtraInfo = 0;
            rgInput[i].mi.dx = 0;
            rgInput[i].mi.dy = 0;
            rgInput[i].mi.mouseData = nButtons;

            i++;
        }
        
    	// move mouse back to starting location
        rgInput[i].type = INPUT_MOUSE;
        rgInput[i].mi.dwFlags = MOUSEEVENTF_MOVE;
        rgInput[i].mi.dwExtraInfo = 0;
        rgInput[i].mi.dx = -ptCursor.x;
        rgInput[i].mi.dy = -ptCursor.y;
        rgInput[i].mi.mouseData = nButtons;

        i++;
        if (!W32->SendInput(i, rgInput, sizeof(INPUT)))
            MessageBeep(0);

        // Restore Mouse Acceleration
        if (miSave.MouseSpeed)
            SystemParametersInfo(SPI_SETMOUSE, 0, &miSave, 0);

        W32->BlockInput (FALSE);
	    return (S_OK);
    }
    return(DISP_E_MEMBERNOTFOUND);
}


/*
 *	CLstBxWinHost::accSelect(long selFlags, VARIANT varChild)
 *
 *	@mfunc
 *		Modifies the selection or moves the keyboard focus according to the specified flags.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accSelect(long selFlags, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accSelect");
    
    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()) || !MSAA::ValidateSelFlags(selFlags))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(S_FALSE);

    varChild.lVal--;

    long lStyle = GetWindowLong(_hwnd, GWL_STYLE);
    if (lStyle & LBS_NOSEL)
        return DISP_E_MEMBERNOTFOUND;

    if (!IsSingleSelection())
    {
        // get the focused item here in case we change it. 
        int nFocusedItem = GetCursor();

	    if (selFlags & SELFLAG_TAKEFOCUS) 
        {
            if (!_fFocus)
                return(S_FALSE);

            RichListBoxWndProc (_hwnd, LB_SETCARETINDEX, varChild.lVal, 0);
        }

        // reset and select requested item
	    if (selFlags & SELFLAG_TAKESELECTION)
	    {
	        // deselect the whole range of items
            RichListBoxWndProc(_hwnd, LB_SETSEL, FALSE, -1);
            // Select this one
            RichListBoxWndProc(_hwnd, LB_SETSEL, TRUE, varChild.lVal);
        }

        if (selFlags & SELFLAG_EXTENDSELECTION)
        {
            if ((selFlags & SELFLAG_ADDSELECTION) || (selFlags & SELFLAG_REMOVESELECTION))
                RichListBoxWndProc (_hwnd, LB_SELITEMRANGE, (selFlags & SELFLAG_ADDSELECTION), 
                             MAKELPARAM(nFocusedItem, varChild.lVal));
            else
            {
                BOOL bSelected = RichListBoxWndProc (_hwnd, LB_GETSEL, nFocusedItem, 0);
                RichListBoxWndProc (_hwnd, LB_SELITEMRANGE, bSelected, MAKELPARAM(nFocusedItem,varChild.lVal));
            }
        }
        else // not extending, check add/remove
        {
            if ((selFlags & SELFLAG_ADDSELECTION) || (selFlags & SELFLAG_REMOVESELECTION))
                RichListBoxWndProc(_hwnd, LB_SETSEL, (selFlags & SELFLAG_ADDSELECTION), varChild.lVal);
        }
        // set focus to where it was before if SELFLAG_TAKEFOCUS not set
        if ((selFlags & SELFLAG_TAKEFOCUS) == 0)
            RichListBoxWndProc (_hwnd, LB_SETCARETINDEX, nFocusedItem, 0);
    }
    else // listbox is single select
    {
        if (selFlags & (SELFLAG_ADDSELECTION | SELFLAG_REMOVESELECTION | SELFLAG_EXTENDSELECTION))
            return (E_INVALIDARG);

        // single select listboxes do not allow you to set the
        // focus independently of the selection, so we send a 
        // LB_SETCURSEL for both TAKESELECTION and TAKEFOCUS
	    if ((selFlags & SELFLAG_TAKESELECTION) || (selFlags & SELFLAG_TAKEFOCUS))
            RichListBoxWndProc(_hwnd, LB_SETCURSEL, varChild.lVal, 0);
    } // end if listbox is single select
	
    return(S_OK);
}


/*
 *	CLstBxWinHost::accNavigate(long dwNavDir, VARIANT varStart, VARIANT *pvarEnd)
 *
 *	@mfunc
 *		Retrieves the next or previous sibling or child object in a specified direction.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accNavigate(long dwNavDir, VARIANT varStart, VARIANT *pvarEnd)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accNavigate");

    InitPvar(pvarEnd);

    // Validate parameters
    if (!MSAA::ValidateChild(&varStart, GetCount()))
        return(E_INVALIDARG);

    // Is this something for the client (or combobox) to handle?
    long lEnd = 0;
    if (dwNavDir == NAVDIR_FIRSTCHILD)
    {
        lEnd = GetCount() ? 1 : 0;
    }
    else if (dwNavDir == NAVDIR_LASTCHILD)
        lEnd = GetCount();
    else if (varStart.lVal == CHILDID_SELF)
    {   
        // NOTE:
        // MSAA tries to make a distinction for controls by implementing 2 different types of
        // interfaces for controls.
        // OBJID_WINDOW - will include the windows border along with the client.  This control
        //              should be perceived from a dialog or some window containers perspective.
        //              Where the control is just an abstract entity contained in the window container
        // OBJID_CLIENT - only includes the client area.  This interface is only concerned with 
        //              the control itself and disregards the outside world
        IAccessible* poleacc = NULL;
        HRESULT hr = W32->AccessibleObjectFromWindow(_hwnd, OBJID_WINDOW, IID_IAccessible, (void**)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);

        // Ask it to navigate
        VARIANT varStart;
        VariantInit(&varStart);
        varStart.vt = VT_I4;
        varStart.lVal = OBJID_CLIENT;

        hr = poleacc->accNavigate(dwNavDir, varStart, pvarEnd);

        // Release our parent
        poleacc->Release();
        return(hr);
    }
    else
    {
        //long lT = varStart.lVal - 1;
        switch (dwNavDir)
        {
            // We're a single column list box only so ignore
            // these flags
            //case NAVDIR_RIGHT:
            //case NAVDIR_LEFT:
            //    break;

            case NAVDIR_PREVIOUS:
            case NAVDIR_UP:
                // Are we in the top-most row?
                lEnd = varStart.lVal - 1;
                break;

            case NAVDIR_NEXT:
            case NAVDIR_DOWN:
                lEnd = varStart.lVal + 1;
                if (lEnd > GetCount())
                    lEnd = 0;
                break;
        }
    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
    }

    return(lEnd ? S_OK : S_FALSE);
}


/*
 *	CLstBxWinHost::get_accParent(IDispatch **ppdispParent)
 *
 *	@mfunc
 *		Retrieves the IDispatch interface of the current object's parent. 
 *  Return S_FALSE and set the variable at ppdispParent to NULL. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CLstBxWinHost::get_accParent(IDispatch **ppdispParent)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accParent");

    AssertSz(ppdispParent != NULL, "null pointer");
    if (ppdispParent == NULL)
        return S_FALSE;
        
    InitPv(ppdispParent);
    HWND hwnd;
    if (_fLstType != kCombo)
    {
        hwnd = MSAA::GetAncestor(_hwnd, GA_PARENT);
        AssertSz(hwnd, "Invalid Hwnd");
        if (!hwnd)
            return S_FALSE;
    }
    else
    {
        if (_pcbHost)
        {
            hwnd = _pcbHost->_hwnd;
            Assert(hwnd);
        }
        else
            return S_FALSE;
        
    }

    HRESULT hr = W32->AccessibleObjectFromWindow(hwnd, OBJID_CLIENT, IID_IDispatch,
                                          (void **)ppdispParent);

#ifdef DEBUG
    if (FAILED(hr))
        Assert(FALSE);
#endif
    return hr;
}


/*
 *	CLstBxWinHost::get_accChildCount(long *pcCount)
 *
 *	@mfunc
 *		Retrieves the number of children belonging to the current object. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CLstBxWinHost::get_accChildCount(long *pcCount)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accChildCount");

    *pcCount = GetCount();
    return(S_OK);
}


//////////////////////// Combobox IAccessible Methods ////////////////////////////// 
// COMBOBOXES
#define INDEX_COMBOBOX                  0
#define INDEX_COMBOBOX_ITEM             1
#define INDEX_COMBOBOX_BUTTON           2
#define INDEX_COMBOBOX_LIST             3

#define CCHILDREN_COMBOBOX              3

/*
 *	CCmbBxWinHost::InitTypeInfo()
 *
 *	@mfunc
 *		Retrieves type library
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
HRESULT CCmbBxWinHost::InitTypeInfo()
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::InitTypeInfo");
    return MSAA::InitTypeInfo(&_pTypeInfo);
}

/*
 *	CCmbBxWinHost::get_accName(VARIANT varChild, BSTR *pszName)
 *
 *	@mfunc
 *		Retrieves the Name property for this object. 
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accName(VARIANT varChild, BSTR *pszName)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accName");
    
    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    // The name of the combobox, the edit inside of it, and the dropdown
    // are all the same.  The name of the button is Drop down/Pop up
    InitPv(pszName);
    if (varChild.lVal != INDEX_COMBOBOX_BUTTON)
        return(MSAA::GetWindowName(_hwnd, pszName));
    else
    {
        if (IsWindowVisible(_hwndList))
            return (MSAA::GetStringResource(STR_DROPDOWN_HIDE, pszName));
        else
            return(MSAA::GetStringResource(STR_DROPDOWN_SHOW, pszName));
    }
}

/*
 *	CCmbBxWinHost::get_accValue(VARIANT varChild, BSTR *pszValue)
 *
 *	@mfunc
 *		Retrieves the object's Value property.  
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accValue(VARIANT varChild, BSTR *pszValue)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accValue");
    
    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
        case INDEX_COMBOBOX_ITEM:
            InitPv(pszValue);
            LRESULT lres;
            _pserv->TxSendMessage(WM_GETTEXTLENGTH, 0, 0, &lres);

            // If windows text length is 0 then MSAA searches
            // for the label associated with the control
            if (lres <= 0)
                return MSAA::GetLabelString(_hwnd, pszValue);
                
            GETTEXTEX gt;
            memset(&gt, 0, sizeof(GETTEXTEX));
            gt.cb = (lres + 1) * sizeof(WCHAR);
            gt.codepage = 1200;
            gt.flags = GT_DEFAULT;

            *pszValue = SysAllocStringLen(NULL, lres + 1);
            if (!*pszValue)
                return E_OUTOFMEMORY;
                
            _pserv->TxSendMessage(EM_GETTEXTEX, (WPARAM)&gt, (LPARAM)*pszValue, &lres);
            return S_OK;
    }
    return DISP_E_MEMBERNOTFOUND;
}


/*
 *	CCmbBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
 *
 *	@mfunc
 *		Retrieves the object's Role property.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accRole");
    
    // Validate--this does NOT accept a child ID.
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    
    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
            pvarRole->lVal = ROLE_SYSTEM_COMBOBOX;
            break;

        case INDEX_COMBOBOX_ITEM:
            if (_cbType == kDropDown)
                pvarRole->lVal = ROLE_SYSTEM_TEXT;
            else
                pvarRole->lVal = ROLE_SYSTEM_STATICTEXT;
            break;

        case INDEX_COMBOBOX_BUTTON:
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            break;

        case INDEX_COMBOBOX_LIST:
            pvarRole->lVal = ROLE_SYSTEM_LIST;
            break;

        default:
            AssertSz(FALSE, "Invalid ChildID for child of combo box" );
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
 *
 *	@mfunc
 *		Retrieves the current state of the object or child item.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accState");
    
    // Validate--this does NOT accept a child ID.
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    VARIANT var;
    HRESULT hr;
    IAccessible* poleacc;
    InitPvar(pvarState);
    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    HWND hwndActive = GetForegroundWindow();
    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX_BUTTON:
            if (_fMousedown)
                pvarState->lVal |= STATE_SYSTEM_PRESSED;
            break;

        case INDEX_COMBOBOX_ITEM:
            if (_cbType == kDropDownList)
            {              
                if (hwndActive == MSAA::GetAncestor(_hwnd, GA_ROOT))
                    pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
                if (_fFocus)
                    pvarState->lVal |= STATE_SYSTEM_FOCUSED;
                break;
            }
            
            // FALL THROUGH CASE
            
        case INDEX_COMBOBOX:
            if (!(_dwStyle & WS_VISIBLE))
                pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

            if (_dwStyle & WS_DISABLED)
                pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

            if (_fFocus)
                pvarState->lVal |= STATE_SYSTEM_FOCUSED;

            if (hwndActive == MSAA::GetAncestor(_hwnd, GA_ROOT))
                pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
            break;            

        case INDEX_COMBOBOX_LIST:
            {

                // First we incorporate the state of the window in general
                //
                VariantInit(&var);
                if (FAILED(hr = MSAA::GetWindowObject(_hwndList, &var)))
                    return(hr);

                Assert(var.vt == VT_DISPATCH);

                // Get the child acc object
                poleacc = NULL;
                hr = var.pdispVal->QueryInterface(IID_IAccessible,
                    (void**)&poleacc);
                var.pdispVal->Release();

                if (FAILED(hr))
                {
                    Assert(FALSE);
                    return(hr);
                }

                // Ask the child its state
                VariantInit(&var);
                hr = poleacc->get_accState(var, pvarState);
                poleacc->Release();
                if (FAILED(hr))
                {
                    Assert(FALSE);
                    return(hr);
                }

                // The listbox is always going to be floating
                //
                pvarState->lVal |= STATE_SYSTEM_FLOATING;

                if (_plbHost->_fDisabled)
                    pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;
                else
                    pvarState->lVal &= ~STATE_SYSTEM_UNAVAILABLE;

                if (_fListVisible)
                    pvarState->lVal &= ~STATE_SYSTEM_INVISIBLE;
                else
                    pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
                    
                break;
            }
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
 *
 *	@mfunc
 *		Retrieves an object's KeyboardShortcut property.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accKeyboardShortcut");
    
    // Shortcut for combo is label's hotkey.
    // Shortcut for dropdown (if button) is Alt+F4.
    // CWO, 12/5/96, Alt+F4? F4, by itself brings down the combo box,
    //                       but we add "Alt" to the string.  Bad!  Now use 
    //                       down arrow and add Alt to it via HrMakeShortcut()
    //                       As documented in the UI style guide.
    //
    // As always, shortcuts only apply if the container has "focus".  In other
    // words, the hotkey for the combo does nothing if the parent dialog
    // isn't active.  And the hotkey for the dropdown does nothing if the
    // combobox/edit isn't focused.
  

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    InitPv(pszShortcut);
    if (varChild.lVal == INDEX_COMBOBOX)
    {
        return(MSAA::GetWindowShortcut(_hwnd, pszShortcut));
    }
    else if (varChild.lVal == INDEX_COMBOBOX_BUTTON)
    {
        return(MSAA::GetStringResource(STR_COMBOBOX_LIST_SHORTCUT, pszShortcut));
    }
    return DISP_E_MEMBERNOTFOUND;
}


/*
 *	CCmbBxWinHost::get_accFocus(VARIANT *pvarFocus)
 *
 *	@mfunc
 *		Retrieves the child object that currently has the keyboard focus.  
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accFocus(VARIANT *pvarFocus)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accFocus");
    
    InitPvar(pvarFocus);
    // Is the current focus a child of us?
    if (_fFocus)
    {
        pvarFocus->vt = VT_I4;
        pvarFocus->lVal = 0;
    }
    else 
    {
        // NOTE:
        //  We differ here in we don't get the foreground thread's focus window.  Instead,
        //  we just get the current threads focus window
        HWND hwnd = GetFocus();
        if (IsChild(_hwnd, hwnd))            
            return(MSAA::GetWindowObject(hwnd, pvarFocus));
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction)
 *
 *	@mfunc
 *		Retrieves a string containing a localized sentence that describes the object's
 *  default action.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accDefaultAction");
    
    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    if ((varChild.lVal != INDEX_COMBOBOX_BUTTON)/* || _fHasButton*/)
        return DISP_E_MEMBERNOTFOUND;

    // Default action of button is to press it.  If pressed already, pressing
    // it will pop dropdown back up.  If not pressed, pressing it will pop
    // dropdown down.
    InitPv(pszDefaultAction);

    if (IsWindowVisible(_hwndList))
        return(MSAA::GetStringResource(STR_DROPDOWN_HIDE, pszDefaultAction));
    else
        return(MSAA::GetStringResource(STR_DROPDOWN_SHOW, pszDefaultAction));
}


/*
 *	CCmbBxWinHost::accSelect(long flagsSel, VARIANT varChild)
 *	@mfunc
 *		Modifies the selection or moves the keyboard focus according to the specified 
 *  flags.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accSelect(long flagsSel, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accSelect");
    
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX) || !MSAA::ValidateSelFlags(flagsSel))
        return(E_INVALIDARG);

    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
 *	@mfunc
 *		Retrieves the object's current screen location (if the object was placed on 
 *   the screen) and optionally, the child element.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accLocation");
    
    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    RECT rc;
    HWND hwnd = _hwnd;
    switch (varChild.lVal)
    {        
        case INDEX_COMBOBOX_BUTTON:
            //if (!m_fHasButton)
            //    return(S_FALSE);
            rc = _rcButton;
            *pcxWidth = rc.right - rc.left;
            *pcyHeight = rc.bottom - rc.top;
            ClientToScreen(_hwnd, (LPPOINT)&rc);
            break;

        case INDEX_COMBOBOX_ITEM:
            //  Need to verify this is the currently selected item.
            //  if no item is selected then pass the rect of the first item in the list
            _plbHost->LbGetItemRect((_plbHost->GetCursor() < 0) ? 0 : _plbHost->GetCursor(), &rc);
            
            *pcxWidth = rc.right - rc.left;
            *pcyHeight = rc.bottom - rc.top;   
            ClientToScreen(_hwndList, (LPPOINT)&rc);
            break;

        case INDEX_COMBOBOX_LIST:
            hwnd = _hwndList;
            // fall through!!!
            
        case 0: //default window
            GetWindowRect(hwnd, &rc);
            // copy over dimensions            
            *pcxWidth = rc.right - rc.left;
            *pcyHeight = rc.bottom - rc.top;
            break;

        default:
            AssertSz(FALSE, "Invalid ChildID for child of combo box" );
            return (S_OK);
    }
    
    *pxLeft = rc.left;
    *pyTop = rc.top;
    return(S_OK);
}


/*
 *	CCmbBxWinHost::accNavigate(long dwNav, VARIANT varStart, VARIANT* pvarEnd)
 *
 *	@mfunc
 *		Retrieves the next or previous sibling or child object in a specified 
 *  direction.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accNavigate(long dwNav, VARIANT varStart, VARIANT* pvarEnd)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accNavigate");


    InitPvar(pvarEnd);

    // Validate parameters
    if (!MSAA::ValidateChild(&varStart, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    long lEnd = 0;
    if (dwNav == NAVDIR_FIRSTCHILD)
    {
        lEnd =  INDEX_COMBOBOX_ITEM;
        goto GetTheChild;
    }
    else if (dwNav == NAVDIR_LASTCHILD)
    {
        dwNav = NAVDIR_PREVIOUS;
        varStart.lVal = CCHILDREN_COMBOBOX + 1;
    }
    else if (!varStart.lVal)
    {
        // NOTE:
        // MSAA tries to make a distinction for controls by implementing 2 different types of
        // interfaces for controls.
        // OBJID_WINDOW - will include the windows border along with the client.  This control
        //              should be perceived from a dialog or some window containers perspective.
        //              Where the control is just an abstract entity contained in the window container
        // OBJID_CLIENT - only includes the client area.  This interface is only concerned with 
        //              the control itself and disregards the outside world
        IAccessible* poleacc = NULL;
        HRESULT hr = W32->AccessibleObjectFromWindow(_hwnd, OBJID_WINDOW, IID_IAccessible, (void**)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);

        // Ask it to navigate
        VARIANT varStart;
        VariantInit(&varStart);
        varStart.vt = VT_I4;
        varStart.lVal = OBJID_CLIENT;

        hr = poleacc->accNavigate(dwNav, varStart, pvarEnd);

        // Release our parent
        poleacc->Release();
        return(hr);
    }

    // Map HWNDID to normal ID.  We work with both (it is easier).
    if (IsHWNDID(varStart.lVal))
    {
        HWND hWndTemp = HwndFromHWNDID(varStart.lVal);

        if (hWndTemp == _hwnd)
            varStart.lVal = INDEX_COMBOBOX_ITEM;
        else if (hWndTemp == _hwndList)
            varStart.lVal = INDEX_COMBOBOX_LIST;
        else
            // Don't know what the heck this is
            return(S_FALSE);
    }

    switch (dwNav)
    {
        case NAVDIR_UP:
            if (varStart.lVal == INDEX_COMBOBOX_LIST)
                lEnd = INDEX_COMBOBOX_ITEM;
            break;

        case NAVDIR_DOWN:
            if ((varStart.lVal != INDEX_COMBOBOX_LIST) && _fListVisible)
                lEnd = INDEX_COMBOBOX_LIST;
            break;

        case NAVDIR_LEFT:
            if (varStart.lVal == INDEX_COMBOBOX_BUTTON)
                lEnd = INDEX_COMBOBOX_ITEM;
            break;

        case NAVDIR_RIGHT:
            if ((varStart.lVal == INDEX_COMBOBOX_ITEM)/* && !(cbi.stateButton & STATE_SYSTEM_INVISIBLE)*/)
               lEnd = INDEX_COMBOBOX_BUTTON;
            break;

        case NAVDIR_PREVIOUS:
            lEnd = varStart.lVal - 1;
            if ((lEnd == INDEX_COMBOBOX_LIST) && !_fListVisible)
                --lEnd;
            break;

        case NAVDIR_NEXT:
            lEnd = varStart.lVal + 1;
            if (lEnd > CCHILDREN_COMBOBOX || ((lEnd == INDEX_COMBOBOX_LIST) && !_fListVisible))
                lEnd = 0;
            break;
    }

GetTheChild:
    if (lEnd)
    {
        // NOTE:
        // MSAA tries to make a distinction for controls by implementing 2 different types of
        // interfaces for controls.
        // OBJID_WINDOW - will include the windows border along with the client.  This control
        //              should be perceived from a dialog or some window containers perspective.
        //              Where the control is just an abstract entity contained in the window container
        // OBJID_CLIENT - only includes the client area.  This interface is only concerned with 
        //              the control itself and disregards the outside world
        if ((lEnd == INDEX_COMBOBOX_ITEM)/* && cbi.hwndItem*/)
            return(MSAA::GetWindowObject(_hwnd, pvarEnd));
        else if ((lEnd == INDEX_COMBOBOX_LIST)/* && cbi.hwndList*/)
            return(MSAA::GetWindowObject(_hwndList, pvarEnd));

        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
        return(S_OK);
    }

    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarEnd)
 *
 *	@mfunc
 *		Retrieves the child object at a given point on the screen.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarEnd)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accHitTest");
    
    POINT   pt;
    RECT    rc;

    InitPvar(pvarEnd);

    pt.x = xLeft;
    pt.y = yTop;

    // Check list first, in case it is a dropdown.
    GetWindowRect(_hwndList, &rc);
    if (_fListVisible && PtInRect(&rc, pt))
        return(MSAA::GetWindowObject(_hwndList, pvarEnd));
    else
    {
        ScreenToClient(_hwnd, &pt);
        GetClientRect(_hwnd, &rc);        

        if (PtInRect(&_rcButton, pt))
        {
            pvarEnd->vt = VT_I4;
            pvarEnd->lVal = INDEX_COMBOBOX_BUTTON;
        }
        else
        {
            if (!PtInRect(&rc, pt))
                return(S_FALSE);
            pvarEnd->vt = VT_I4;
            pvarEnd->lVal = 0;
        }
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::accDoDefaultAction(VARIANT varChild)
 *
 *	@mfunc
 *		Performs the object's default action.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accDoDefaultAction(VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accDoDefaultAction");
    
    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    if ((varChild.lVal == INDEX_COMBOBOX_BUTTON)/* && m_fHasButton*/)
    {
        if (_fListVisible)
            PostMessage(_hwnd, WM_KEYDOWN, VK_RETURN, 0);
        else
            PostMessage(_hwnd, CB_SHOWDROPDOWN, TRUE, 0);

        return(S_OK);
    }
    return DISP_E_MEMBERNOTFOUND;
}


/*
 *	CCmbBxWinHost::get_accSelection(VARIANT *pvarChildren)
 *
 *	@mfunc
 *		Retrieves the selected children of this object.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accSelection(VARIANT *pvarChildren)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accSelection");
    
    InitPvar(pvarChildren);
    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::get_accParent(IDispatch **ppdispParent)
 *
 *	@mfunc
 *		Retrieves the IDispatch interface of the current object's parent. 
 *  Return S_FALSE and set the variable at ppdispParent to NULL. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CCmbBxWinHost::get_accParent(IDispatch **ppdispParent)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accParent");
    
    InitPv(ppdispParent);

    if (_hwnd)
    {
        HWND hwnd = MSAA::GetAncestor(_hwnd, GA_PARENT);
        if (hwnd)
            return W32->AccessibleObjectFromWindow(hwnd, OBJID_WINDOW,
                    IID_IDispatch, (void **)ppdispParent);
    }
    
    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::get_accChildCount(long *pcountChildren)
 *
 *	@mfunc
 *		Retrieves the number of children belonging to the current object. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CCmbBxWinHost::get_accChildCount(long *pcountChildren)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accChildCount");
    if (pcountChildren)
        *pcountChildren = CCHILDREN_COMBOBOX;
    return S_OK;
}


/*
 *	CCmbBxWinHost::get_accChild(VARIANT varChild, IDispatch **ppdispChild)
 *
 *	@mfunc
 *		Retrieves the number of children belonging to the current object. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CCmbBxWinHost::get_accChild(VARIANT varChild, IDispatch **ppdispChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accChild");
    
    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    InitPv(ppdispChild);
    HWND hwndChild = NULL;
    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
            return E_INVALIDARG;

        //case INDEX_COMBOBOX_ITEM:
        //   hwndChild = _hwnd;
        //   break;

        case INDEX_COMBOBOX_LIST:
            hwndChild = _hwndList;
            break;
    }

    if (!hwndChild)
        return(S_FALSE);
    else
        return(W32->AccessibleObjectFromWindow(hwndChild, OBJID_WINDOW, IID_IDispatch, (void**)ppdispChild));
}


//////////////////////// CTxtWinHost IDispatch Methods ///////////////////////////
// --------------------------------------------------------------------------
//
//  CTxtWinHost::GetTypeInfoCount()
//
//  This hands off to our typelib for IAccessible().  Note that
//  we only implement one type of object for now.  BOGUS!  What about IText?
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::GetTypeInfoCount(UINT * pctInfo)
{
    HRESULT hr = InitTypeInfo();
    if (SUCCEEDED(hr))
    {
        InitPv(pctInfo);
        *pctInfo = 1;
    }
    return(hr);
}



// --------------------------------------------------------------------------
//
//  CTxtWinHost::GetTypeInfo()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::GetTypeInfo(UINT itInfo, LCID lcid,
    ITypeInfo ** ppITypeInfo)
{
    HRESULT hr = InitTypeInfo();
    if (SUCCEEDED(hr))
    {
        if (ppITypeInfo == NULL)
            return(E_POINTER);

        InitPv(ppITypeInfo);

        if (itInfo != 0)
            return(TYPE_E_ELEMENTNOTFOUND);
        _pTypeInfo->AddRef();
        *ppITypeInfo = _pTypeInfo;
    }
    return(hr);
}



// --------------------------------------------------------------------------
//
//  CTxtWinHost::GetIDsOfNames()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::GetIDsOfNames(REFIID riid,
    OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgDispID)
{
    HRESULT hr = InitTypeInfo();
    if (!SUCCEEDED(hr))
        return(hr);

    return(_pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispID));
}



// --------------------------------------------------------------------------
//
//  CTxtWinHost::Invoke()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::Invoke(DISPID dispID, REFIID riid,
    LCID lcid, WORD wFlags, DISPPARAMS * pDispParams,
    VARIANT* pvarResult, EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
    HRESULT hr = InitTypeInfo();
    if (!SUCCEEDED(hr))
        return(hr);

    return(_pTypeInfo->Invoke((IAccessible *)this, dispID, wFlags,
        pDispParams, pvarResult, pExcepInfo, puArgErr));
}



#endif // NOACCESSIBILITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\ldte.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	LDTE.C - RichEdit Light Data Transfer Engine |
 *
 *		This file contains data transfer code using IDataObject
 *
 *	Author: <nl>
 *		alexgo (4/25/95)
 *
 *	Revisions: <nl>
 *		murrays (7/6/95) auto-doc'd and added RTF support
 *
 *	FUTURE (AlexGo): <nl>
 *		Maybe merge this class with CTxtRange to make more efficient use of
 *		the this ptr.  All but two methods use a CTxtRange and one of these
 *		could be global.  The two are:
 *
 *		GetDropTarget( IDropTarget **ppDropTarget )
 *		GetDataObjectInfo(IDataObject *pdo, DWORD *pDOIFlags) // Can be global
 *
 *		In general, a range can spawn data objects, which need to have a clone
 *		of the range in case the range is moved around.  The contained range
 *		is used for delayed rendering.  A prenotification is sent to the data
 *		object just before the data object's data is to be changed.  The data
 *		object then renders the data in its contained range, whereupon the
 *		object becomes independent of the range and destroys the range.
 *
 *	@devnote
 *		We use the word ANSI in a general way to mean any multibyte character
 *		system as distinguished from 16-bit Unicode.  Technically, ANSI refers
 *		to a specific single-byte character system (SBCS).  We translate
 *		between "ANSI" and Unicode text using the Win32
 *		MultiByteToWideChar() and WideCharToMultiByte() APIs.
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_range.h"
#include "_ldte.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_edit.h"
#include "_disp.h"
#include "_select.h"
#include "_dragdrp.h"
#include "_dxfrobj.h"
#include "_rtfwrit.h"
#include "_rtfread.h"
#include "_urlsup.h"

ASSERTDATA


//Local Prototypes
DWORD CALLBACK WriteHGlobal(WRITEHGLOBAL *pwhg, LPBYTE pbBuff, LONG cb, LONG *pcb);

#define	SFF_ADJUSTENDEOP	0x80000000
//
// LOCAL METHODS
//

/*
 *	ReadHGlobal(dwCookie, pbBuff, cb, pcb)
 *
 *	@func
 *		EDITSTREAM callback for reading from an hglobal
 *
 *	@rdesc
 *		es.dwError
 */
DWORD CALLBACK ReadHGlobal(
	DWORD_PTR	dwCookie,		// @parm dwCookie
	LPBYTE	pbBuff,				// @parm Buffer to fill
	LONG	cb,					// @parm Buffer length
	LONG *	pcb)				// @parm Out parm for # bytes stored
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "ReadHGlobal");

	READHGLOBAL * const prhg = (READHGLOBAL *)dwCookie;

	cb = min(cb, prhg->cbLeft);
	CopyMemory(pbBuff, prhg->ptext, cb);
	prhg->cbLeft -= cb;
	prhg->ptext  += cb;

	if(pcb)
		*pcb = cb;
	return NOERROR;	
}

/*
 *	WriteHGlobal(pwhg, pbBuff, cb, pcb)
 *
 *	@func
 *		EDITSTREAM callback for writing ASCII to an hglobal
 *
 *	@rdesc
 *		error (E_OUTOFMEMORY or NOERROR)
 */
DWORD CALLBACK WriteHGlobal(
	DWORD_PTR	dwCookie,		// @parm dwCookie
	LPBYTE	pbBuff,				// @parm Buffer to write from
	LONG	cb,					// @parm Buffer length
	LONG *	pcb)				// @parm Out parm for # bytes written
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "WriteHGlobal");

	WRITEHGLOBAL * const pwhg = (WRITEHGLOBAL *)dwCookie;

	HGLOBAL		hglobal = pwhg->hglobal;
	LPSTR		pstr;

	if(pwhg->cch + cb > pwhg->cb)			// Less than requested cb in
	{										//  current Alloc
		ULONG cbNewSize = GROW_BUFFER(pwhg->cb, cb);
		hglobal = GlobalReAlloc(hglobal, cbNewSize, GMEM_MOVEABLE);
		if(!hglobal)	
			return (DWORD)E_OUTOFMEMORY;
		pwhg->hglobal = hglobal;			// May be superfluous...
		pwhg->cb = cbNewSize;
	}
	pstr = (LPSTR)GlobalLock(hglobal);
	if(!pstr)
		return (DWORD)E_OUTOFMEMORY;

	CopyMemory(pstr + pwhg->cch, pbBuff, cb);
	GlobalUnlock(hglobal);
	pwhg->cch += cb;
	if(pcb)
		*pcb = cb;
	return NOERROR;	
}


//
// PUBLIC METHODS
//

/*
 *	GetCharFlags(ch, bDefaultCharset)
 *
 *	@func
 *		Return flags set if ch is in first 256 Unicodes, complex-script,
 *		BiDi (RTL), FE.  Also flags identifying which charset is likely.
 *		These flags correspond to those in the font signature.
 *
 *	@rdesc
 *		Flags saying if ch is complex-script, BiDi (RTL), or FE
 *
 *		=FUTURE= should be constructed as a 2-level lookup.
 */
DWORD GetCharFlags(
	DWORD	ch,
	BYTE	bDefaultCharset)
{
	if(ch < 0x100)						// Latin1: divide into 3 bits
		return	ch > 0x7F ? fHILATIN1 :
				ch < 0x40 ? fBELOWX40 : fASCIIUPR;

	if(ch < 0x590)
	{
		if(ch >= 0x530)
			return fARMENIAN;

		if(ch >= 0x400)
			return fCYRILLIC;

		if(ch >= 0x370)
			return fGREEK;

		if(ch >= 0x300)					// Combining diacritical marks
			return fCOMBINING;			

		return (ch < 0x250) ? fLATIN2 : fOTHER;
	}
	// Complex scripts start at 0x590 with Hebrew (aside from combining)
	if(ch <= 0x10FF)					// Complex scripts end at 0x10FF
	{									//  (at least in Feb, 1998)
		if(ch < 0x900)
		{
			return	fBIDI |
					(ch < 0x600 ? fHEBREW :
					 ch < 0x700 ? fARABIC : 0);
		}
		if(ch < 0xE00)
		{
			return	(ch < 0x980 ? fDEVANAGARI :
					 ch < 0xB80 ? 0 :
					 ch < 0xC00 ? fTAMIL : 0);
		}
		if(ch < 0xF00)
			return ch < 0xE80 ? fTHAI : 0;

		return ch >= 0x10A0 ? fGEORGIAN : fOTHER;
	}
	if(ch < 0x3100)
	{
		if(ch > 0x3040)
			return fKANA;

		if(ch >= 0x3000)
			goto CLASSIFY_CHINESE;

		if(IN_RANGE(RTLMARK, ch, 0x202E) && (ch == RTLMARK ||
			IN_RANGE(0x202A, ch, 0x202E)))
		{
			return fBIDI;
		}

		if(ch <= 0x11FF)						// Hangul Jamo
			return fHANGUL;

		if(ch == EURO || ch == 0x2122)			// Euro or TM
			return fHILATIN1;

		if(ch == 0x20AA)						// Hebrew currency sign
			return fBIDI | fHEBREW;

		if (W32->IsFESystem() || IsFECharSet(bDefaultCharset))
			goto CLASSIFY_CHINESE;

		if (IN_RANGE(0x200b, ch, 0x200d))		// ZWSP, ZWNJ, ZWJ
			return fUNIC_CTRL;

		if (ch == 0x2016 || ch == 0x2236)
		{
			// Some hack to make Word2000 happy
			WCHAR	wch = ch;

			if (VerifyFEString(CP_CHINESE_TRAD, &wch, 1, TRUE) == CP_CHINESE_TRAD)
				return fBIG5;	
			
			if (VerifyFEString(CP_CHINESE_SIM, &wch, 1, TRUE) == CP_CHINESE_SIM)
				return fCHINESE;
		}

		return fOTHER;
	}
	if(ch < 0xD800)
	{		
		if (ch < 0x3400)
		{
			if (IN_RANGE(0x3130, ch, 0x318F) ||	// Hangul Compatibility Jamo
				IN_RANGE(0x3200, ch, 0x321F) ||	// Parenthesized Hangul
				IN_RANGE(0x3260, ch, 0x327F))	// Circled Hangul
				return fHANGUL;				

			if (IN_RANGE(0x032D0, ch, 0x337F))	// Circled & Squared Katakana words
				return fKANA;

			goto CLASSIFY_CHINESE;
		}
						
		if (ch < 0xAC00)
			goto CLASSIFY_CHINESE;

		return fHANGUL;
	}

	if (ch < 0xE000)
		return fSURROGATE;			// Surrogate

	if(ch < 0xF900)					// Private Use Area
	{
		if(IN_RANGE(0xF000, ch, 0xF0FF))
			return fSYMBOL;

		if (W32->IsFESystem())
			goto CLASSIFY_USER;

		return fOTHER;
	}

	if(ch < 0xFF00)
	{
		if(IN_RANGE(0xFE30, ch, 0xFE4F))		// CJK Vertical variants
			goto CLASSIFY_CHINESE;	

		if(IN_RANGE(0xF900, ch, 0xFAFF))		// CJK characters
			goto CLASSIFY_CHINESE;	

		return fOTHER;
	}

	if(IN_RANGE(0xFF00, ch, 0xFFEF))		
	{										
		if (ch < 0xFF60 || ch >= 0xFFE0 ||		// Fullwidth ASCII or Fullwidth symbols
			ch == 0xFF64)						// special case Half-width ideographic comma
			goto CLASSIFY_CHINESE;		
							
		return ch < 0xFFA0 ? fKANA : fHANGUL;	// Halfwidth Katakana/Hangul		
	}
	return fOTHER;

CLASSIFY_CHINESE:
	if (bDefaultCharset)
	{
		switch (bDefaultCharset)
		{
			case SHIFTJIS_CHARSET:
				return fKANA;

			case HANGEUL_CHARSET:
				return fHANGUL;

			case CHINESEBIG5_CHARSET:
				return fBIG5;

			case GB2312_CHARSET:
				return fCHINESE;
		}
	}

CLASSIFY_USER:
	switch (W32->GetFEFontInfo())
	{
		case CP_JAPAN:
			return fKANA;

		case CP_KOREAN:
			return fHANGUL;

		case CP_CHINESE_TRAD:
			return fBIG5;

		default:
		// case CP_CHINESE_SIM:
			return fCHINESE;

	}
}

/*
 *	CLightDTEngine::CLightDTEngine()
 *
 *	@mfunc
 *		Constructor for Light Data Transfer Engine
 */
CLightDTEngine::CLightDTEngine()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CLightDTEngine");

	_ped = NULL;
	_pdt = NULL;
	_pdo = NULL;
	_fUseLimit = FALSE;
	_fOleless = FALSE;
}

/*
 *	CLightDTEngine::~CLightDTEngine
 *
 *	@mfunc
 *		Handles all necessary clean up for the object..
 */
CLightDTEngine::~CLightDTEngine()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::~CLightDTEngine");

	if( _pdt )
	{
		_pdt->Zombie();
		_pdt->Release();
		_pdt = NULL;
	}
	Assert(_pdo == NULL);
}

/*
 *	CLightDTEngine::Destroy()
 *
 *	@mfunc
 *		Deletes this instance
 */
void CLightDTEngine::Destroy()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::Destroy");

	delete this;
}

/*
 *	CLightDTEngine::CopyRangeToClipboard ( prg )
 *
 *	@mfunc
 *		Copy the text of the range prg to the clipboard using Win32 APIs
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::CopyRangeToClipboard(
	CTxtRange *prg )				// @parm range to copy to clipboard
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CopyRangeToClipboard");

	HRESULT hresult = E_FAIL;
	IDataObject *pdo = NULL;
	IRichEditOleCallback * precall = _ped->GetRECallback();
	BOOL fSingleObject;
	CHARRANGE chrg;

	prg->GetRange(chrg.cpMin, chrg.cpMost);

	if (chrg.cpMin >= chrg.cpMost)
	{
		// We can't copy an insertion point to the clipboard so we are done.
		return NOERROR;
	}

	fSingleObject = chrg.cpMost - chrg.cpMin == 1 &&
		_ped->HasObjects() &&
		_ped->_pobjmgr->CountObjectsInRange(chrg.cpMin, chrg.cpMost);
	if(precall)
	{
		// Give the callback a chance to give us it's own IDataObject
		hresult = precall->GetClipboardData(&chrg, RECO_COPY, &pdo);
	}

	// If we didn't get an IDataObject from the callback, build our own
	if(hresult != NOERROR)
	{
		// If the range is empty, don't bother creating it.  Just
		// leave the clipboard alone and return
		if( prg->GetCch() == 0 )
		{
			_ped->Beep();
			return NOERROR;
		}

		hresult = RangeToDataObject(prg, SF_TEXT | SF_RTF, &pdo);
	}

	// NB: it's important to check both hresult && pdo; it is legal for
	// our client to say "yep, I handled the copy, but there was nothing
	// to copy".
	if( hresult == NOERROR && pdo )
	{
		hresult = OleSetClipboard(pdo);
		if( hresult != NOERROR )
		{
			HWND hwnd;
			_fOleless = TRUE;
			// Ole less clipboard support
			if (_ped->TxGetWindow(&hwnd) == NOERROR &&
				::OpenClipboard(hwnd) &&
				::EmptyClipboard()
			)
			{
				::SetClipboardData(cf_RTF, NULL);

				::SetClipboardData(CF_UNICODETEXT, NULL);
				if(_ped->GetCharFlags() & ~(fLATIN1 | fSYMBOL))
				{
					::SetClipboardData(cf_RTFUTF8, NULL);
					::SetClipboardData(cf_RTFNCRFORNONASCII, NULL);
				}
				::SetClipboardData(CF_TEXT, NULL);

				if (fSingleObject)
					::SetClipboardData(CF_DIB, NULL);
				::CloseClipboard();
				hresult = NOERROR;				// To cause replace range to happen
			}
		}
        if(_pdo)
			_pdo->Release();
		_pdo = pdo;
	}
	return hresult;
}

/*
 *	CLightDTEngine::CutRangeToClipboard( prg, publdr );
 *	
 *	@mfunc
 *		Cut text of the range prg to the clipboard
 *
 *	@devnote
 *		If publdr is non-NULL, anti-events for the cut operation should be
 *		stuffed into this collection
 *
 *	@rdesc
 *		HRESULT from CopyRangeToClipboard()
 *
 *	@devnote
 *		First copy the text to the clipboard, then delete it from the range
 */
HRESULT CLightDTEngine::CutRangeToClipboard(
	CTxtRange *	  prg,			// @parm Range to cut to clipboard
	IUndoBuilder *publdr )		// @parm Undo builder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CutRangeToClipboard");

	Assert(!_ped->TxGetReadOnly());

	prg->AdjustEndEOP(NONEWCHARS);				// Don't include trailing EOP
												//  in some selection cases
	HRESULT hr = CopyRangeToClipboard(prg);

	if( publdr )
	{
		publdr->SetNameID(UID_CUT);
		publdr->StopGroupTyping();
	}

	if(hr == NOERROR)							// Delete contents of range
		prg->Delete(publdr, SELRR_REMEMBERRANGE);	

	return hr;
}


/*
 *	CLightDTEngine::FlushClipboard()
 *
 *	@mfunc	flushes the clipboard (if needed).  Typically called during
 *			shutdown.
 *
 *	@rdesc	void
 */
void CLightDTEngine::FlushClipboard()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::FlushClipboard");
	ENSAVECLIPBOARD ens;

	if( _pdo )
	{
		if( OleIsCurrentClipboard(_pdo) == NOERROR )
		{
			CDataTransferObj *pdo = NULL;

			// check to see if we have to flush the clipboard.
			ZeroMemory(&ens, sizeof(ENSAVECLIPBOARD));

			// check to make sure the object is one of ours before accessing
			// the memory.  EVIL HACK ALERT.  'nuff said.

			if( _pdo->QueryInterface(IID_IRichEditDO, (void **)&pdo )
				== NOERROR && pdo  )
			{
				ens.cObjectCount = pdo->_cObjs;
				ens.cch = pdo->_cch;
				pdo->Release();
			}

			if( _ped->TxNotify(EN_SAVECLIPBOARD, &ens) == NOERROR )
				OleFlushClipboard();

			else
				OleSetClipboard(NULL);
		}
		_pdo->Release();
		_pdo = NULL;
	}
}

/*
 *	CLightDTEngine::CanPaste(pdo, cf, flags)
 *
 *	@mfunc
 *		Determines if clipboard format cf is one we can paste.
 *
 *	@rdesc
 *		BOOL - true if we can paste cf into range prg OR DF_CLIENTCONTROL
 *		if the client is going to handle this one.
 *
 *	@devnote
 *		we check the clipboard ourselves if cf is 0. Primarily, this
 *		is for backwards compatibility with Richedit1.0's EM_CANPASTE
 *		message.
 *
 */
DWORD CLightDTEngine::CanPaste(
	IDataObject *pdo,	// @parm Data object to check; if NULL use clipboard
	CLIPFORMAT cf, 		// @parm clipboard format to query about; if 0, use
						//		 best available.
	DWORD flags)		// @parm flags
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CanPaste");

	IRichEditOleCallback *precall = _ped->GetRECallback();
	CLIPFORMAT	cf0 = cf;
	DWORD		cFETC = CFETC;
	HRESULT		hr = NOERROR;
	DWORD		ret = FALSE;

#ifndef MACPORT								
	if( pdo == NULL && precall )
#else
	if( pdo == NULL)
#endif
	{
		// don't worry about errors
		OleGetClipboard(&pdo);
	}
	else if( pdo )
	{
		// So we can make just one 'Release' call below
		pdo->AddRef();
	}
	
	if( precall && pdo )
	{
		hr = precall->QueryAcceptData(pdo, &cf, flags, 0, NULL);

		if( SUCCEEDED(hr) && (hr != S_OK && hr != DATA_S_SAMEFORMATETC ) )
		{
			ret = DF_CLIENTCONTROL;
			goto Exit;
		}
		else if( FAILED(hr) && hr != E_NOTIMPL )
			goto Exit;

		else if(SUCCEEDED(hr))
		{
			// We should go on and check ourselves unless the client
			// modified the format when it shouldn't have
			if(cf0 && cf0 != cf)
				goto Exit;
		}

		// otherwise, continue with our normal checks
	}

    if(_ped->TxGetReadOnly())		    // Can't paste if read only
		goto Exit;

	while(cFETC--)						// Does cf = format we can paste or
	{									//  is selection left up to us?
		cf0 = g_rgFETC[cFETC].cfFormat;
	    if( cf == cf0 || !cf )
		{
			// Either we hit the format requested, or no format
			// was requested.  Now see if the format matches what
			// we could handle in principle.  There are three
			// basic categories:
			//		1. we are rich text and have an OLE callback;
			//		then we can handle pretty much everything.
			//		2. we are rich text but have no OLE callback.
			//		then we can handle anything but OLE specific
			//		formats.
			//		3. we are plain text only.  Then we can only
			//		handle plain text formats.

			if( (_ped->_fRich || (g_rgDOI[cFETC] & DOI_CANPASTEPLAIN)) &&
				(precall || !(g_rgDOI[cFETC] & DOI_CANPASTEOLE)))
			{
				// once we get this far, make sure the data format
				// is actually available.
				if( (pdo && pdo->QueryGetData(&g_rgFETC[cFETC]) == NOERROR ) ||
					(!pdo && IsClipboardFormatAvailable(cf0)) )
				{
					ret = TRUE;			// Return arbitrary non zero value.
					break;
				}
			}
		}
    }	

Exit:
	if(pdo)
		pdo->Release();

	return ret;
}

/*
 *	CLightDTEngine::RangeToDataObject (prg, lStreamFormat, ppdo)
 *
 *	@mfunc
 *		Create data object (with no OLE-formats) for the range prg
 *
 *	@rdesc
 *		HRESULT	= !ppdo ? E_INVALIDARG :
 *				  pdo ? NOERROR : E_OUTOFMEMORY
 */
HRESULT CLightDTEngine::RangeToDataObject(
	CTxtRange *		prg,			// @parm Range to get DataObject for
	LONG			lStreamFormat,	// @parm stream format to use for loading
	IDataObject **	ppdo)			// @parm Out parm for DataObject
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::RangeToDataObject");

	if(!ppdo)
		return E_INVALIDARG;

	CDataTransferObj *pdo = CDataTransferObj::Create(_ped, prg, lStreamFormat);

	*ppdo = pdo;
	return pdo ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	CLightDTEngine::RenderClipboardFormat(wFmt)
 *
 *	@mfunc
 *		Renders current clipboard data object in specified format. (Ole less transfer)
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::RenderClipboardFormat(
	WPARAM wFmt)
{
	HRESULT hr = S_OK;
	if(_fOleless &&
		(wFmt == cf_RTF || wFmt == CF_UNICODETEXT || wFmt == CF_DIB || wFmt == CF_TEXT))
	{
		Assert(_pdo);
		STGMEDIUM med;
		DWORD iFETC = iUnicodeFETC;
		if (wFmt == cf_RTF)
			iFETC = iRtfFETC;
		else if (wFmt == CF_DIB)
			iFETC = iDIB;
		else if (wFmt == CF_TEXT)
			iFETC = iAnsiFETC;
		med.tymed = TYMED_HGLOBAL;
		med.pUnkForRelease = NULL;
		med.hGlobal = NULL;
		hr = _pdo->GetData(&g_rgFETC[iFETC], &med);
		hr = hr || ::SetClipboardData(wFmt, med.hGlobal) == NULL;
	}
	return hr;		// Pretend we did the right thing.
}

/*
 *	CLightDTEngine::RenderAllClipboardFormats()
 *
 *	@mfunc
 *		Renders current clipboard data object (text and RTF). (Ole less transfer)
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::RenderAllClipboardFormats()
{
	HRESULT hr;
	if(_fOleless)
	{
		HWND howner = ::GetClipboardOwner();
		HWND hwnd;
		if (howner &&
			_ped->TxGetWindow(&hwnd) == NOERROR &&
			howner == hwnd &&
			::OpenClipboard(hwnd))
		{
			::EmptyClipboard();
			hr = RenderClipboardFormat(cf_RTF);
			hr = hr || RenderClipboardFormat(CF_UNICODETEXT);
			hr = hr || RenderClipboardFormat(CF_DIB);
			hr = hr || RenderClipboardFormat(CF_TEXT);
			::CloseClipboard();
			return hr;
		}
	}
	return S_OK;		// Pretend we did the right thing.
}

/*
 *	CLightDTEngine::DestroyClipboard()
 *
 *	@mfunc
 *		Destroys the clipboard data object
 *
 *	@rdesc
 *		HRESULT
 *
 */
HRESULT CLightDTEngine::DestroyClipboard()
{
	// Nothing to do.  This should work together with our Flush clipboard logic
	return S_OK;
}

/*
 *	CLightDTEngine::HGlobalToRange(dwFormatIndex, hGlobal, ptext, prg, publdr)
 *
 *	@mfunc
 *		Copies the contents of the given string (ptext) to the given range.
 *		The global memory handle may or may not point to the string depending
 *		on the format
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::HGlobalToRange(
	DWORD		dwFormatIndex,
	HGLOBAL		hGlobal,
	LPTSTR		ptext,
	CTxtRange *	prg,
	IUndoBuilder *publdr)
{
	READHGLOBAL	rhg;
	EDITSTREAM	es;	
	HCURSOR		hcur = NULL;

	// If RTF, wrap EDITSTREAM around hGlobal & delegate to LoadFromEs()
	if (dwFormatIndex == iRtfNoObjs || dwFormatIndex == iRtfFETC ||
		dwFormatIndex == iRtfUtf8 || dwFormatIndex == iRtfNCRforNonASCII)
	{
		Assert(hGlobal != NULL);
		rhg.ptext		= (LPSTR)ptext;			// Start at beginning
		rhg.cbLeft		= GlobalSize(hGlobal);	//  with full length
		es.dwCookie		= (DWORD_PTR)&rhg;		// The read "this" ptr
		es.dwError		= NOERROR;				// No errors yet
		es.pfnCallback	= ReadHGlobal;			// The read method
		// Want wait cursor to display sooner
		bool fSetCursor = rhg.cbLeft > NUMPASTECHARSWAITCURSOR;
		if (fSetCursor)
			hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
		LoadFromEs(prg, SFF_SELECTION | SF_RTF, &es, TRUE, publdr);
		if (fSetCursor)
			SetCursor(hcur);
		return es.dwError;
	}

	Assert( dwFormatIndex == iRtfAsTextFETC ||
			dwFormatIndex == iAnsiFETC ||
			dwFormatIndex == iUnicodeFETC );

	LONG 	cchMove, cchNew;

	cchNew = prg->CleanseAndReplaceRange(-1, ptext, TRUE, publdr, NULL, &cchMove, RR_ITMZ_NONE);

	if(prg->GetCch() && prg->IsSel())
		return E_FAIL;						// Paste failed due to UI rules

	if(_ped->IsRich() && !_ped->Get10Mode())// If rich text,
		prg->DeleteTerminatingEOP(publdr);	//  if new text ends with EOP,

	prg->ItemizeReplaceRange(cchNew, cchMove, publdr, TRUE);		// itemize w/ UnicodeBidi
											//  select and delete that EOP
	return NOERROR;							//  to agree with Word
}

/*
 *	CLightDTEngine::DIBToRange(hGlobal, prg, publdr)
 *
 *	@mfunc
 *		Inserts dib data from the clipboard into range in the control
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::DIBToRange(
	HGLOBAL			hGlobal,
	CTxtRange *		prg,	
	IUndoBuilder *	publdr)
{
	HRESULT         hresult = DV_E_FORMATETC;
	REOBJECT        reobj = { 0 };
	LPBITMAPINFO	pbmi = (LPBITMAPINFO) GlobalLock(hGlobal);
	WCHAR           ch = WCH_EMBEDDING;

	reobj.clsid = CLSID_StaticDib;
	reobj.sizel.cx =
		(LONG) _ped->_pdp->DXtoHimetricX( pbmi->bmiHeader.biWidth );
	reobj.sizel.cy =
		(LONG) _ped->_pdp->DYtoHimetricY( pbmi->bmiHeader.biHeight );
	_ped->GetClientSite(&reobj.polesite);

	COleObject *pobj = (COleObject *)reobj.polesite;
	COleObject::ImageInfo *pimageinfo = new COleObject::ImageInfo;
	pobj->SetHdata(hGlobal);
	pimageinfo->xScale = 100;
	pimageinfo->yScale = 100;
	pimageinfo->xExtGoal = reobj.sizel.cx;
	pimageinfo->yExtGoal = reobj.sizel.cy;
	pimageinfo->cBytesPerLine = 0;
	pobj->SetImageInfo(pimageinfo);
	
	// FUTURE: Why are we not testing for NULL earlier before we assign it to pobj? v-honwch
	// Also, do we need to release interfaces inside reobj (poleobj, polesite, pstg) before exit?
	if (!reobj.polesite )
		return hresult;

	// Put object into the edit control
	reobj.cbStruct = sizeof(REOBJECT);
	reobj.cp = prg->GetCp();
	reobj.dvaspect = DVASPECT_CONTENT;
	reobj.dwFlags = REO_RESIZABLE;

	// Since we are loading an object, it shouldn't be blank
	reobj.dwFlags &= ~REO_BLANK;

	prg->Set_iCF(-1);	
	prg->ReplaceRange(1, &ch, publdr, SELRR_IGNORE);
	hresult = _ped->GetObjectMgr()->InsertObject(reobj.cp, &reobj, NULL);

	return hresult;
}

/*
 *	CLightDTEngine::PasteDataObjectToRange (pdo, prg, cf, rps, pubdlr, dwFlags)
 *
 *	@mfunc
 *		Inserts data from the data object pdo into the range prg. If the
 *		clipboard format cf is not NULL, that format is used; else the highest
 *		priority clipboard format is used.  In either case, any text that
 *		already existed in the range is replaced.  If pdo is NULL, the
 *		clipboard is used.
 *
 *	@rdesc
 *		HRESULT
 *
 */
HRESULT CLightDTEngine::PasteDataObjectToRange(
	IDataObject *	pdo,		// @parm Data object to paste
	CTxtRange *		prg,		// @parm Range into which to paste
	CLIPFORMAT		cf,			// @parm ClipBoard format to paste
	REPASTESPECIAL *rps,		// @parm Special paste info
	IUndoBuilder *	publdr,		// @parm Undo builder to receive antievents
	DWORD			dwFlags)	// @parm DWORD packed flags
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::PasteDataObjectToRange");

	if(prg->GetPF()->InTable())
	{
		if(prg->GetPrevChar() == CELL && prg->_rpTX.GetChar() == CR)
		{
			if(prg->IsSel())
			{
				_ped->Beep();
				return E_FAIL;
			}
			prg->SetExtend(FALSE);		// Illegal paste point
			prg->Advance(-1);			
		}
		if(prg->IsSel())
		{
			if(prg->fHasCell())			// Can only paste inside single cell
				return E_FAIL;
		}
		else if(prg->GetCch())			// Would use _fSelHasCell, but isn't
			return E_FAIL;				//  maintained unless _fSel is TRUE
	}

	BOOL		f10Mode = _ped->Get10Mode();
	HGLOBAL		hGlobal = NULL;
	HRESULT		hresult = DV_E_FORMATETC;
	HGLOBAL		hUnicode = NULL;
	DWORD		i;
	STGMEDIUM	medium = {0, NULL};
	IDataObject *pdoSave = pdo;
	FORMATETC *	pfetc = g_rgFETC;
	LPTSTR		ptext = NULL;
	LPRICHEDITOLECALLBACK const precall = _ped->GetRECallback();
	BOOL		fThawDisplay = FALSE;
	BOOL        bFormatFound = FALSE;   // flag which determines if a matching cf format
	                                    // was found in g_rgFETC (1.0 compatibility)


	if(!pdo)								// No data object: use clipboard
	{
		hresult = OleGetClipboard(&pdo);
		if(FAILED(hresult))
		{
			// Ooops.  No Ole clipboard support
			// Need to use direct clipboard access
			HWND howner = ::GetClipboardOwner();
			HWND hwnd;
			if (howner &&
				_ped->TxGetWindow(&hwnd) == NOERROR &&
				howner == hwnd)
			{
				// We are cut/pasting within the same richedit instance
				// Use our cached clipboard data object
				pdo = _pdo;
				if(!pdo)		// Some failure
				{
					_ped->Beep();
					return hresult;
				}
				pdo->AddRef();
			}
			else
			{
				// Oh Oh We need to transfer from clipboard without data object
				// Data must be coming from another window instance
				if (_ped->TxGetWindow(&hwnd) == NOERROR &&
					::OpenClipboard(hwnd)
				)
				{
					HGLOBAL		hUnicode = NULL;

					DWORD dwFmt = iRtfUtf8;				// Try for UTF8 RTF
					_ped->_pdp->Freeze();
					if(!f10Mode)
					{
						hGlobal = ::GetClipboardData(cf_RTFUTF8);
						if (hGlobal == NULL)				// Wasn't there, so
						{									//  try for RTF
							hGlobal = ::GetClipboardData(cf_RTFNCRFORNONASCII);
							dwFmt = iRtfNCRforNonASCII;
						}
					}
					if (hGlobal == NULL)				// Wasn't there, so
					{									//  try for RTF
						hGlobal = ::GetClipboardData(cf_RTF);
						dwFmt = iRtfFETC;
					}
					if (hGlobal == NULL && !f10Mode)	// Wasn't there either
					{									//  so try for plain
						hGlobal = ::GetClipboardData(CF_UNICODETEXT);
						dwFmt = iUnicodeFETC;
					}
					if (hGlobal == NULL)				// Wasn't there either
					{									//  so try for plain text
						hGlobal = ::GetClipboardData(CF_TEXT);
						dwFmt = iAnsiFETC;
					}
					if (hGlobal)
					{
						if (dwFmt == iAnsiFETC)
						{
							// Convert Ansi plain text to Unicode
							hUnicode = TextHGlobalAtoW(hGlobal);
							if (hUnicode)
								ptext = (LPTSTR)GlobalLock(hUnicode);
						}
						else
							ptext = (LPTSTR)GlobalLock(hGlobal);

						if (ptext)
							hresult = HGlobalToRange(dwFmt, hGlobal, ptext, prg, publdr);
						else
							hresult = E_OUTOFMEMORY;

						if (hUnicode)
						{
							// Free plain text buffer
							GlobalUnlock(hUnicode);
							GlobalFree(hUnicode);
						}
						else
							GlobalUnlock(hGlobal);
					}
					else								// hGlobal == NULL Try for bitmaps
					{
						hGlobal = ::GetClipboardData(CF_DIB);
						if (hGlobal)
							hresult =  DIBToRange(hGlobal, prg, publdr);
					}
					_ped->_pdp->Thaw();
					::CloseClipboard();
				}
				if (FAILED(hresult))
					_ped->Beep();
				return hresult;
			}
		}
	}

	// Paste an object uses the limit text calculation
	_fUseLimit = TRUE;

	//Call QueryAcceptData unless caller has specified otherwise
	if(!(dwFlags & PDOR_NOQUERY) && precall)
	{
		CLIPFORMAT cfReq = cf;
		HGLOBAL hmeta = NULL;

		if(rps)
			hmeta = (HGLOBAL)((rps->dwAspect == DVASPECT_ICON) ? rps->dwParam : NULL);

		// Ask callback if it likes the data object and cfReq.

		hresult = precall->QueryAcceptData(
			pdo,
			&cfReq,
			(dwFlags & PDOR_DROP) ? RECO_DROP : RECO_PASTE,
			TRUE,
			hmeta);

		if(hresult == DATA_S_SAMEFORMATETC)
		{
			// Allow callback to return DATA_S_SAMEFORMATETC if it only
			// wants cf as passed in - we don't really care because
			// any non-zero CLIPFORMAT causes us to only accept that format.
			hresult = S_OK;
		}

		if(hresult == S_OK || hresult == E_NOTIMPL)
		{
			// Callback either liked it or didn't implement the method.
			// It may have changed the format while it was at it.
			// Treat a change of cf to zero as acceptance of the original.
			// In any event, we will try to handle it.

			// If a specific CLIPFORMAT was originally requested and the
			// callback changed it, don't accept it.
			if(cfReq && cf && (cf != cfReq))
			{
				hresult = DV_E_FORMATETC;
				goto Exit;
			}

			// If a specific CLIPFORMAT was originally requested and the
			// callback either left it alone or changed it to zero,
			// make sure we use the original.  If no CLIPFORMAT was
			// originally requested, make sure we use what came back
			// from the callback.
			if(!cf)
				cf = cfReq;
		}
		else
		{
			// Some success other than S_OK && DATA_S_SAMEFORMATETC.
			// The callback has handled the paste.  OR some error
			// was returned.
			goto Exit;
		}
	}

	// Even if the rich edit client wants CF_TEXT
	// If the data object supports CF_UNICODETEXT, we should prefer it.
	// as long as we are not in 1.0 mode
	if(cf == CF_TEXT && !f10Mode)
	{
		FORMATETC fetc = {CF_UNICODETEXT, NULL, 0, -1, TYMED_NULL};
		
		if(pdo->QueryGetData(&fetc) == S_OK)
			cf = CF_UNICODETEXT;
	}

	if (_ped->TxGetReadOnly())			// Should check for range protection
	{
		hresult = E_ACCESSDENIED;
		goto Exit;
	}

	// At this point we freeze the display
	fThawDisplay = TRUE;
	_ped->_pdp->Freeze();

	if( publdr )
	{
		publdr->StopGroupTyping();
		publdr->SetNameID(UID_PASTE);
	}

    for( i = 0; i < CFETC; i++, pfetc++ )
	{
		// Make sure the format is either 1.) a plain text format
		// if we are in plain text mode or 2.) a rich text format
		// or 3.) matches the requested format.

		if( cf && cf != pfetc->cfFormat )
			continue;

		if( _ped->IsRich() || (g_rgDOI[i] & DOI_CANPASTEPLAIN) )
		{
			// Make sure format is available
			if( pdo->QueryGetData(pfetc) != NOERROR )
			    continue;			

			// If we have a format that uses an hGlobal get and lock it
			if (i == iRtfFETC  || i == iRtfAsTextFETC ||
				i == iAnsiFETC || i == iRtfNoObjs	  ||
				!f10Mode && (i == iUnicodeFETC || i == iRtfUtf8 || i == iRtfNCRforNonASCII))
			{
				if( pdo->GetData(pfetc, &medium) != NOERROR )
					continue;

                hGlobal = medium.hGlobal;
				ptext = (LPTSTR)GlobalLock(hGlobal);
				if( !ptext )
				{
					ReleaseStgMedium(&medium);

					hresult = E_OUTOFMEMORY;
					goto Exit;
				}

				// 1.0 COMPATBILITY HACK ALERT!  RichEdit 1.0 has a bit of
				// "error recovery" for parsing rtf files; if they aren't
				// valid rtf, it treats them as just plain text.
				// Unfortunately, apps like Exchange depend on this behavior,
				// i.e., they give RichEdit plain text data, but call it rich
				// text anyway.  Accordingly, we emulate 1.0 behavior here by
				// checking for an rtf signature.
				if ((i == iRtfFETC || i == iRtfNoObjs || i == iRtfUtf8) &&
					!IsRTF((char *)ptext))
				{
					i = iAnsiFETC;			// Not RTF, make it ANSI text
				}
			}			
			else if (f10Mode && (i == iUnicodeFETC || i == iRtfUtf8))
			{
				// This else handles the case where we want to keep searching
				// for a goood format.  i.e. Unicode in 10 Mode
				continue;
			}

			// Don't delete trail EOP in some cases
			prg->AdjustEndEOP(NONEWCHARS);
			
			// Found a format we want.
			bFormatFound = TRUE;

			switch(i)									
			{											
			case iRtfNoObjs:							
			case iRtfFETC:								
			case iRtfUtf8:								
			case iRtfNCRforNonASCII:								
				hresult = HGlobalToRange(i, hGlobal, ptext, prg, publdr);
				break;
	
			case iRtfAsTextFETC:
			case iAnsiFETC:								// ANSI plain text		
				hUnicode = TextHGlobalAtoW(hGlobal);
				ptext	 = (LPTSTR)GlobalLock(hUnicode);
				if(!ptext)
				{
					hresult = E_OUTOFMEMORY;			// Unless out of RAM,
					break;								//  fall thru to
				}										//  Unicode case
														
			case iUnicodeFETC:							// Unicode plain text
				// Ok to pass in NULL for hglobal since argument won't be used
				hresult = HGlobalToRange(i, NULL, ptext, prg, publdr);
				if(hUnicode)							// For iAnsiFETC case
				{
					GlobalUnlock(hUnicode);
					GlobalFree(hUnicode);
				}			
				break;

			case iObtDesc:	 // Object Descriptor
				continue;	 // To search for a good format.
				             // the object descriptor hints will be used
				             // when the format is found.

			case iEmbObj:	 // Embedded Object
			case iEmbSrc:	 // Embed Source
			case iLnkSrc:	 // Link Source
			case iMfPict:	 // Metafile
			case iDIB:		 // DIB
			case iBitmap:	 // Bitmap
			case iFilename:	 // Filename
				hresult = CreateOleObjFromDataObj(pdo, prg, rps, i, publdr);
				break;

			// COMPATIBILITY ISSUE (v-richa) iTxtObj is needed by Exchange and
			// as a flag for Wordpad.  iRichEdit doesn't seem to be needed by
			// anyone but might consider implementing as a flag.
			case iRichEdit:	 // RichEdit
			case iTxtObj:	 // Text with Objects
				break;
			default:
				// Ooops didn't find a format after all
				bFormatFound = FALSE;
				break;
			}

			//If we used the hGlobal unlock it and free it.
			if(hGlobal)
			{
				GlobalUnlock(hGlobal);
				ReleaseStgMedium(&medium);
			}
			break;							//Break out of for loop
		}
	}

    // richedit 1.0 returned an error if an unsupported FORMATETC was
    // found.  This behaviour is expected by ccMail so it can handle the
    // format itself
	if (!bFormatFound && f10Mode)
	    hresult = DV_E_FORMATETC;

Exit:
	if (fThawDisplay)
		_ped->_pdp->Thaw();

	if(!pdoSave)							// Release data object
		pdo->Release();						//  used for clipboard

	return hresult;						
}	

/*
 *	CLightDTEngine::GetDropTarget (ppDropTarget)
 *
 *	@mfunc
 *		creates an OLE drop target
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote	The caller is responsible for AddRef'ing this object
 *				if appropriate.
 */
HRESULT CLightDTEngine::GetDropTarget(
	IDropTarget **ppDropTarget)		// @parm outparm for drop target
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::GetDropTarget");

	if(!_pdt)
	{
		_pdt = new CDropTarget(_ped);
		// the AddRef done by the constructor will be
		// undone by the destructor of this object
	}

	if(ppDropTarget)
		*ppDropTarget = _pdt;

	return _pdt ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	CLightDTEngine::StartDrag (psel, publdr)
 *
 *	@mfunc
 *		starts the main drag drop loop
 *
 */	
HRESULT CLightDTEngine::StartDrag(
	CTxtSelection *psel,		// @parm Selection to drag from
	IUndoBuilder *publdr)		// @parm undo builder to receive antievents
{
#ifndef PEGASUS
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::StartDrag");

	LONG			cch, cch1;
	LONG			cp1, cpMin, cpMost;
	DWORD			dwEffect = 0;
	HRESULT			hr;
	IDataObject *	pdo = NULL;
	IDropSource *	pds;
	IRichEditOleCallback * precall = _ped->GetRECallback();

	// If we're doing drag drop's, we should have our own drop target
	// It's possible that _pdt will be NULL at this point--some clients
	// will delay instantiation of our drop target until a drop target
	// in the parent window decides that ours is needed.  However, since
	// we need it just to initiate drag drop, go ahead and create one
	// here.

	if( _pdt == NULL )
	{
		hr = GetDropTarget(NULL);
		if(hr != NOERROR)
			return hr;
	}

	psel->CheckTableSelection();

	if(precall)
	{
		CHARRANGE chrg;

		// give the callback a chance to give us its own IDataObject
		psel->GetRange(chrg.cpMin, chrg.cpMost);
		hr = precall->GetClipboardData(&chrg, RECO_COPY, &pdo);
	}
	else
	{
		// we need to build our own data object.
		hr = S_FALSE;
	}

	// If we didn't get an IDataObject from the callback, build our own
	if(hr != NOERROR || pdo == NULL)
	{										// Don't include trailing EOP
		psel->AdjustEndEOP(NONEWCHARS);		//  in some selection cases
		hr = RangeToDataObject(psel, SF_TEXT | SF_RTF, &pdo);
		if(hr != NOERROR)
			return hr;
	}

	cch = psel->GetRange(cpMin, cpMost);	// NB: prg is the selection
	cp1 = psel->GetCp();					// Save active end and signed
	cch1 = psel->GetCch();					//  length for Undo antievent
	CTxtRange rg(_ped, cpMost, cch);		// Use range copy to float over
											// mods made to backing store
	// The floating range that we just created on the stack needs to
	// think that it's protected, so it won't change size.
	rg.SetDragProtection(TRUE);

	pds = new CDropSource();
	if(pds == NULL)
	{
		pdo->Release();
		return E_OUTOFMEMORY;
	}

	// Cache some info with our own drop target
	_pdt->SetDragInfo(publdr, cpMin, cpMost);


	// Set allowable effects
	dwEffect = DROPEFFECT_COPY;
	if(!_ped->TxGetReadOnly())
		dwEffect |= DROPEFFECT_MOVE;
	
	// Let the client decide what it wants.
	if(precall)
		hr = precall->GetDragDropEffect(TRUE, 0, &dwEffect);

	if(!FAILED(hr) || hr == E_NOTIMPL)
	{
		// Start drag-drop operation
		psel->AddRef();					// Stabilize Selection around DoDragDrop
		hr = DoDragDrop(pdo, pds, dwEffect, &dwEffect);
		psel->Release();
	}

	// Clear drop target
	_pdt->SetDragInfo(NULL, -1, -1);

	// Handle 'move' operations	
	if( hr == DRAGDROP_S_DROP && (dwEffect & DROPEFFECT_MOVE) )
	{
		// We're going to delete the dragged range, so turn off protection.
		rg.SetDragProtection(FALSE);
		if( publdr )
		{
			LONG cpNext, cchNext;

			if(_ped->GetCallMgr()->GetChangeEvent() )
			{
				cpNext = cchNext = -1;
			}
			else
			{
				cpNext = rg.GetCpMin();
				cchNext = 0;
			}

			HandleSelectionAEInfo(_ped, publdr, cp1, cch1, cpNext, cchNext,
								  SELAE_FORCEREPLACE);
		}
		
		// Delete the data that was moved.  The selection will float
		// to the new correct location.
		rg.Delete(publdr, SELRR_IGNORE);

		// The update that happens implicitly by the update of the range may
		// have the effect of scrolling the window. This in turn may have the
		// effect in the drag drop case of scrolling non-inverted text into
		// the place where the selection was. The logic in the selection
		// assumes that the selection is inverted and so reinverts it to turn
		// off the selection. Of course, it is obvious what happens in the
		// case where non-inverted text is scrolled into the selection area.
		// To simplify the processing here, we just say the whole window is
		// invalid so we are guaranteed to get the right painting for the
		// selection.
		// FUTURE: (ricksa) This solution does have the disadvantage of causing
		// a flash during drag and drop. We probably want to come back and
		// investigate a better way to update the screen.
		_ped->TxInvalidateRect(NULL, FALSE);

		// Display is updated via notification from the range

		// Update the caret
		psel->Update(TRUE);
	}
	else if( hr == DRAGDROP_S_DROP && _ped->GetCallMgr()->GetChangeEvent() &&
		(dwEffect & DROPEFFECT_COPY) && publdr)
	{
		// if we copied to ourselves, we want to restore the selection to
		// the original drag origin on undo
		HandleSelectionAEInfo(_ped, publdr, cp1, cch1, -1, -1,
				SELAE_FORCEREPLACE);
	}

	if(SUCCEEDED(hr))
		hr = NOERROR;

	pdo->Release();
	pds->Release();

	// we do this last since we may have re-used some 'paste' code which
	// will stomp the undo name to be UID_PASTE.
	if( publdr )
		publdr->SetNameID(UID_DRAGDROP);

	if(_ped->GetEventMask() & ENM_DRAGDROPDONE)
	{
		NMHDR	hdr;
		ZeroMemory(&hdr, sizeof(NMHDR));
		_ped->TxNotify(EN_DRAGDROPDONE, &hdr);
	}

	return hr;
#else
	return 0;
#endif
}

/*
 *	CLightDTEngine::LoadFromEs (prg, lStreamFormat, pes, fTestLimit, publdr)
 *
 *	@mfunc
 *		Load data from the stream pes into the range prg according to the
 *		format lStreamFormat
 *
 *	@rdesc
 *		LONG -- count of characters read
 */
LONG CLightDTEngine::LoadFromEs(
	CTxtRange *	prg,			// @parm range to load into
	LONG		lStreamFormat,	// @parm stream format to use for loading
	EDITSTREAM *pes,			// @parm edit stream to load from
	BOOL		fTestLimit,		// @parm Whether to test text limit
	IUndoBuilder *publdr)		// @parm undo builder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::LoadFromEs");

#ifdef DEBUG
	// FUTURE: Currently freezing the display prior to loading text
	// is simply an optimization. This may become a requirement in the
	// future. If this does become a requirement then we'll want to
	// exit with an error.
	if( !_ped->_pdp->IsFrozen() )
	{
		TRACEWARNSZ("CLightDTEngine::LoadFromEs	display not frozen");
	}
#endif // DEBUG

	LONG		cch = 0;				// Default no chars read
	IAntiEvent *pae = NULL;

	if(publdr)
		publdr->StopGroupTyping();

	// Other components, such as the display and backing store, will
	// be able to make optimizations if they know that we are streaming
	// in text or RTF data.

	if(lStreamFormat & SF_RTF)						// RTF case must precede
	{												//  TEXT case (see SF_x
		if(!_ped->IsRich())							//  values)
			return 0;

		LONG cpMin, cpMost;

		// Here we do something a bit unusual for performance reasons.
		// Instead of letting the rtf reader generate its own undo actions,
		// we take care of it ourselves.  Instead of generating actions
		// for each little operation, we simply generate a "big" anti-event
		// for the whole shebang

		// There is a subtlty w.r.t. to paragraph format runs.  By inserting
		// text with para formatting, it's possible that we will modify the
		// para formatting of the _current_ paragraph.  Thus, it's necessary
		// to remember what the formatting currently is for undo.  Note that
		// it may actually not be changed; but we go ahead and generate an
		// anti-event anyways.  Note that we only need to do this if cpMin is
		// the middle of a paragraph
		
		CTxtPtr tp(prg->_rpTX);
		if(prg->GetCch() > 0)
			tp.AdvanceCp(-prg->GetCch());
		
		if(publdr && !tp.IsAfterEOP())
		{
			tp.FindEOP(tomBackward);
			cpMin = tp.GetCp();
			tp.FindEOP(tomForward);
			cpMost = tp.GetCp();
			
			// We must be in rich text mode, so we must be able to always
			// find a paragraph.
			Assert(cpMost > cpMin);

			if (prg->_rpPF.IsValid())
			{
				CFormatRunPtr rpPF(prg->_rpPF);
				rpPF.AdvanceCp(cpMin - prg->GetCp());
					
				pae = gAEDispenser.CreateReplaceFormattingAE( _ped, rpPF,
							cpMost - cpMin, GetParaFormatCache(), ParaFormat);
				if(pae)
					publdr->AddAntiEvent(pae);
			}

			// Also create the charformat anti-event for the current paragraph
			// to preserve BiDi level. We cannot check fBiDi here since we may be running
			// on US platform inserting a BiDi rtf.
			if (prg->_rpCF.IsValid())
			{
				CFormatRunPtr rpCF(prg->_rpCF);
				rpCF.AdvanceCp(cpMin - prg->GetCp());
				
				pae = gAEDispenser.CreateReplaceFormattingAE( _ped, rpCF,
							cpMost - cpMin, GetCharFormatCache(), CharFormat);
				if(pae)
					publdr->AddAntiEvent(pae);
			}
		}

		// First, clear range
		if(prg->GetCch())
		{
			prg->ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE);

			if (prg->GetCch() != 0)
			{
				// Text deletion failed because range didn't collapse. Our work
				// here is done.
				return 0;
			}
		}

		Assert(prg->GetCch() == 0);

		cpMin = prg->GetCp();
		_ped->SetStreaming(TRUE);
		CRTFRead rtfRead(prg, pes, lStreamFormat);

		cch	= rtfRead.ReadRtf();

		cpMost = prg->GetCp();
		Assert(pes->dwError != 0 || cpMost >= cpMin);

		// If nothing changed, get rid of any anti-events (like the formatting
		// one) that we may have "speculatively" added

		if(publdr && !_ped->GetCallMgr()->GetChangeEvent())
			publdr->Discard();

		if(publdr && cpMost > cpMin)
		{
			// If some text was added, create an anti-event for
			// it and add it in.

			AssertSz(_ped->GetCallMgr()->GetChangeEvent(),
				"Something changed, but nobody set the change flag");

			pae = gAEDispenser.CreateReplaceRangeAE(_ped, cpMin, cpMost, 0,
						NULL, NULL, NULL);

			HandleSelectionAEInfo(_ped, publdr, -1, -1, cpMost, 0,
						SELAE_FORCEREPLACE);
			if(pae)
				publdr->AddAntiEvent(pae);
		}
	}
	else if(lStreamFormat & SF_TEXT)
	{
		_ped->SetStreaming(TRUE);
		cch = ReadPlainText(prg, pes, fTestLimit, publdr, lStreamFormat);
	}
	_ped->SetStreaming(FALSE);

	// Before updating the selection, try the auto-URL detect.  This makes
	// two cases better: 1. a long drag drop is now faster and 2. the
	// selection _iFormat will now be udpated correctly for cases of
	// copy/paste of a URL.

	if(_ped->GetDetectURL())
		_ped->GetDetectURL()->ScanAndUpdate(publdr);

	// The caret belongs in one of two places:
	//		1. if we loaded into a selection, at the end of the new text
	//		2. otherwise, we loaded an entire document, set it to cp 0
	//
	// ReadPlainText() and ReadRtf() set prg to an insertion point
	// at the end, so if we loaded a whole document, reset it.
	CTxtSelection *psel = _ped->GetSelNC();
	if(psel)
	{
		if(!(lStreamFormat & SFF_SELECTION))
		{
			psel->Set(0,0);
			psel->Update(FALSE);
		}
		psel->Update_iFormat(-1);
	}

	if (!fTestLimit)
	{
		// If we don't limit the text then we adjust the text limit
		// if we have exceeded it.
		_ped->TxSetMaxToMaxText();
	}
	return cch;
}

/*
 *	CLightDTEngine::SaveToEs (prg, lStreamFormat, pes)
 *
 *	@mfunc
 *		save data into the given stream
 *
 *	@rdesc
 *		LONG -- count of characters written
 */
LONG CLightDTEngine::SaveToEs(
	CTxtRange *	prg,			// @parm range to drag from
	LONG		lStreamFormat,	// @parm stream format to use for saving
	EDITSTREAM *pes )			// @parm edit stream to save to
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::SaveToEs");

	LONG cch = 0;								// Default no chars written

	if(lStreamFormat & SF_RTF)					// Be sure to check for SF_RTF
	{											//  before checking for SF_TEXT
		CRTFWrite rtfWrite( prg, pes, lStreamFormat );
	
		cch = rtfWrite.WriteRtf();
	}
	else if(lStreamFormat & (SF_TEXT | SF_TEXTIZED))
		cch = WritePlainText(prg, pes, lStreamFormat);
	else
	{
		Assert(FALSE);
	}
	return cch;
}

/*
 *	CLightDTEngine::UnicodePlainTextFromRange (prg)
 *
 *	@mfunc
 *		Fetch plain text from a range and put it in an hglobal
 *
 *	@rdesc
 *		an allocated HGLOBAL.
 *
 *	@devnote
 *		FUTURE: Export bullets as does Word for plain text
 */
HGLOBAL CLightDTEngine::UnicodePlainTextFromRange(
	CTxtRange *prg)				// @parm range to get text from
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::UnicodePlainTextFromRange");

	LONG	cpMin, cpMost;
	LONG	cch = prg->GetRange(cpMin, cpMost);
	LONG	cchT = 2*(cch + 1);
	HGLOBAL	hText;
	TCHAR *	pText;
	CTxtPtr tp(_ped, cpMin);

	hText = GlobalAlloc(GMEM_FIXED,						// Allocate 2* in
						cchT * sizeof(TCHAR) );			//  case all CRs
	if(!hText)
		return NULL;

	pText = (TCHAR *)GlobalLock(hText);
	if(!pText)
		return NULL;

	if(cch)
	{
		cch = tp.GetPlainText(cchT, pText, cpMost, FALSE);
		AssertSz(cch <= cchT,
			"CLightDTEngine::UnicodePlainTextFromRange: got too much text");
	}

	*(pText + cch) = '\0';
	
	GlobalUnlock(hText);

	HGLOBAL	hTemp = GlobalReAlloc(hText, 2*(cch + 1), GMEM_MOVEABLE);

	if(!hTemp)
		GlobalFree(hText);

	return hTemp;
}

/*
 *	CLightDTEngine::AnsiPlainTextFromRange (prg)
 *
 *	@mfunc
 *		Retrieve an ANSI copy of the text in the range prg
 *
 *	@rdesc
 *		HRESULT
 */
HGLOBAL CLightDTEngine::AnsiPlainTextFromRange(
	CTxtRange *prg)				// @parm range to get text from
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::AnsiPlainTextFromRange");

	HGLOBAL hUnicode;
	HGLOBAL hAnsi;

	// FUTURE (alexgo): if we implement the option to store text as 8-bit
	// chars, then we can make this routine more efficient

	hUnicode = UnicodePlainTextFromRange(prg);
	hAnsi = TextHGlobalWtoA(hUnicode);

	GlobalFree(hUnicode);
	return hAnsi;
}

/*
 *	CLightDTEngine::RtfFromRange (prg, lStreamFormat)
 *
 *	@mfunc
 *		Fetch RTF text from a range and put it in an hglobal
 *
 *	@rdesc
 *		an allocated HGLOBAL.
 */
HGLOBAL CLightDTEngine::RtfFromRange(
	CTxtRange *	prg,			// @parm Range to get RTF from
	LONG 		lStreamFormat)	// @parm stream format to use for loading
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::RtfFromRange");

	WRITEHGLOBAL whg;
	EDITSTREAM	 es = {(DWORD_PTR)&whg, NOERROR, WriteHGlobal};
	DWORD		 cb	= 2*abs(prg->GetCch()) + 100;	// Rough estimate

	whg.cb			= cb;
	whg.hglobal		= GlobalAlloc(GMEM_FIXED, cb);
	if(!whg.hglobal)
		return NULL;		
	whg.cch			= 0;					// Nothing written yet
	SaveToEs(prg, lStreamFormat & ~SF_TEXT, &es);
	if(es.dwError)
	{
		GlobalFree(whg.hglobal);
		return NULL;
	}
	
	HGLOBAL	hTemp = GlobalReAlloc(whg.hglobal, whg.cch, GMEM_MOVEABLE);
	
	if (!hTemp)		
		GlobalFree(whg.hglobal);			// Fail ReAlloc...

	return hTemp;
}


//
// PROTECTED METHODS
//

#define READSIZE 	4096 - 2
#define WRITESIZE	2048

/*
 *	CLightDTEngine::ReadPlainText (prg, pes, publdr, lStreamFormat)
 *
 *	@mfunc
 *		Replaces contents of the range prg with the data given in the edit
 *		stream pes. Handles multibyte sequences that overlap stream buffers.
 *
 *	@rdesc
 *		Count of bytes read (to be compatible with RichEdit 1.0)
 *
 *	@devnote
 *		prg is modified; at the return of the call, it will be a degenerate
 *		range at the end of the read in text.
 *
 *		Three kinds of multibyte/char sequences can overlap stream buffers:
 *		DBCS, UTF-8, and CRLF/CRCRLF combinations. DBCS and UTF-8 streams are
 *		converted by MultiByteToWideChar(), which cannot convert a lead byte
 *		(DBCS and UTF-8) that occurs at the end of the buffer, since the
 *		corresponding trail byte(s) will be in the next buffer.  Similarly,
 *		in RichEdit 2.0 mode, we convert CRLFs to CRs and CRCRLFs to blanks,
 *		so one or two CRs at the end of the buffer require knowledge of the
 *		following char to determine if they are part of a CRLF or CRCRLF.
 *
 *		To handle these overlapped buffer cases, we move the ambiguous chars
 *		to the start of the next buffer, rather than keeping them as part of
 *		the current buffer.  At the start of the buffer, the extra char(s)
 *		needed for translation follow immediately.
 */
LONG CLightDTEngine::ReadPlainText(
	CTxtRange *	  prg, 			// @parm range to read to
	EDITSTREAM *  pes,			// @parm edit stream to read from
	BOOL		  fTestLimit,	// @parm whether limit testing is needed
	IUndoBuilder *publdr,		// @parm undo builder to receive antievents
	LONG		  lStreamFormat)// @parm Stream format
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::ReadPlainText");

	CTxtEdit *ped = _ped;
	LONG	  cbRead;
	LONG 	  cbReadTotal = 0;	// No bytes read yet
	LONG	  cchConv;
	LONG	  cchMove = 0;
	LONG	  cCR = 0;			// Count of CRs from preceding buffer
	LONG	  cCRPrev = 0;		// Count used while calc'ing new cCR
	LONG	  cpMin;
	BOOL	  fContinue = TRUE;	// Keep reading so long as TRUE
	BYTE *	  pb;				// Byte ptr to szBuf or wszBuf
	CCallMgr *pCallMgr = ped->GetCallMgr();
	TCHAR *	  pch;				// Ptr to wszBuf
	UINT	  uCpg = GetStreamCodePage(lStreamFormat);
	CFreezeDisplay	fd(ped->_pdp);

	// Just put a big buffer on the stack.  Thankfully, we only
	// run on 32bit OS's.  4K is a good read size for NT file caching.
	char 	szBuf[READSIZE];
	WCHAR	wszBuf[READSIZE+2];	// Allow for moving end CRs to start

	// Empty the range
	if(prg->GetCch())
		prg->ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE, &cchMove);			

	cpMin = prg->GetCp();							// Save initial cp for
													//  BreakRuns() at end
	pb = (uCpg == 1200) ? (BYTE *)(wszBuf + 2)		// Setup Unicode or MBCS
						: (BYTE *)szBuf;
	LONG j = 0;										// Haven't read anything,
													//  so no lead byte left
	while(fContinue)								//  from previous read
	{
		LONG jPrev = j;								// Save byte(s) left over
		LONG cbSkip = 0;							//  from previous read

		pes->dwError = (*pes->pfnCallback)(			// Read next bufferful,
				pes->dwCookie, pb + j, 				//  bypassing any lead
				READSIZE - j, &cbRead);				//  bytes

		if(pes->dwError || !cbRead && !cCR)
			break;									// Error or done

		if(!cbReadTotal && cbRead >= 3 && W32->IsUTF8BOM(pb))
		{
			uCpg = CP_UTF8;
			cbSkip = 3;								// Bypass 3 bytes
		}
		// Adjust cbRead with previous leading byte(s)
		cbRead += j;
		j = 0;										
		
		cchConv = cbRead/2;							// Default Unicode cch
		if(uCpg != 1200 && cbRead)					// Multibyte of some kind
		{
			Assert(pb == (BYTE *)szBuf && !j);		// Just in case...

			// Check if last byte is a leading byte
			if(uCpg == CP_UTF8)
			{
				// Note: Unlike UTF-8, UTF-7 can be in the middle of a long
				// sequence, so it can't be converted effectively in chunks
				// and we don't handle it
				LONG cb = cbRead - 1;
				BYTE b;
				BYTE bLeadMax = 0xDF;

				// Find UTF-8 lead byte
				while((b = (BYTE)szBuf[cb - j]) >= 0x80)
				{
					j++;
					if(b >= 0xC0)					// Break on UTF-8 lead
					{								//  byte
						if(j > 1 && (b <= bLeadMax || b >= 0xF8))
							j = 0;					// Full UTF-8 char or
						break;						//  illegal sequence
					}
					if(j > 1)
					{
						if(j == 5)					// Illegal UTF-8
						{
							j = 0;
							break;
						}
						*(char *)&bLeadMax >>= 1;
					}
				}
			}
			else
			{
				LONG temp = cbRead - 1;

				// GetTrailBytesCount() can return 1 for some trail bytes
				// esp. for GBX.  So, we need to keep on checking until
				// we hit a non-lead byte character.  Then, based on
				// how many bytes we went back, we can determine if the
				// last byte is really a Lead byte.
				while (temp && GetTrailBytesCount((BYTE)szBuf[temp], uCpg))
					temp--;

				if(temp && ((cbRead-1-temp) & 1))
					j = 1;
			}

			// We don't want to pass the lead byte or partial UTF-8 to
			// MultiByteToWideChar() because it will return bad char.
		    cchConv = MBTWC(uCpg, 0, szBuf + cbSkip, cbRead - j - cbSkip,
							&wszBuf[2], READSIZE, NULL);

			for(LONG i = j; i; i--)					// Copy down partial
				szBuf[j - i] = szBuf[cbRead - i];	//  multibyte sequence
		}
		cbReadTotal += cbRead - j - jPrev;

		// Cleanse (CRLFs -> CRs, etc.), limit, and insert the data. Have
		// to handle CRLFs and CRCRLFs that overlap two successive buffers.
		Assert(cCR <= 2);
		pch = &wszBuf[2 - cCR];						// Include CRs from prev

		if(!ped->_pdp->IsMultiLine())				// Single-line control
		{
			Assert(!cCR);
		}
		else
		{								
			wszBuf[0] = wszBuf[1] = CR;				// Store CRs for cchCR > 0
			cCRPrev = cCR;							// Save prev cchCR
			cCR = 0;								// Default no CR this buf

			Assert(ARRAY_SIZE(wszBuf) >= cchConv + 2);

			// Need to +2 since we are moving data into wszBuf[2]
			if(cchConv && wszBuf[cchConv + 2 - 1] == CR)
			{										// There's at least one
				cCR++;								// Set it up for next buf
				if (cchConv > 1 &&					//  in case CR of CRLF
					wszBuf[cchConv + 2 - 2] == CR)	// Got 2nd CR; might be
				{									//  first CR of CRCRLF so
					cCR++;							//  setup for next buffer
				}
			}										
			cchConv += cCRPrev - cCR;				// Add in count from prev
		}											//  next
		Assert(!prg->GetCch());						// Range is IP
		prg->CleanseAndReplaceRange(cchConv, pch, fTestLimit, publdr, pch, NULL, RR_ITMZ_NONE);

		if(pCallMgr->GetMaxText() || pCallMgr->GetOutOfMemory())
		{
			// Out of memory or reached the max size of our text control.
			// In either case, return STG_E_MEDIUMFULL (for compatibility
			// with RichEdit 1.0)
			pes->dwError = (DWORD)STG_E_MEDIUMFULL;
			break;
		}
	}
	prg->ItemizeReplaceRange(prg->GetCp() - cpMin, cchMove, publdr, TRUE);

	return cbReadTotal;
}

/*
 *	CLightDTEngine::WritePlainText (prg, pes, lStreamFormat)
 *
 *	@mfunc
 *		Writes plain text from the range into the given edit stream
 *
 *	@rdesc
 *		Count of bytes written
 */
LONG CLightDTEngine::WritePlainText(
	CTxtRange *	prg,			// @parm range to write from
	EDITSTREAM *pes,			// @parm edit stream to write to
	LONG		lStreamFormat)	// @parm Stream format
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::WritePlainText");

	LONG		cbConverted;		// Bytes for output stream
	LONG		cbWrite;			// Incremental byte count
	LONG		cbWriteTotal = 0;	// No chars written yet
	LONG		cpMin, cpMost;
	LONG		cch = prg->GetRange(cpMin, cpMost);
	BOOL		fAdjustCRLF = TRUE;	// Adjust first time through loop
	BOOL		fTextize = lStreamFormat & SF_TEXTIZED;
	LPBYTE		pb;					// Byte ptr to szBuf or wszBuf
	COleObject *pobj;				// Ptr to embedded object
	CTxtPtr		tp(_ped, cpMin);	// tp to walk prg with
	UINT		uCpg = GetStreamCodePage(lStreamFormat);

	// DBCS has up to 2 times as many chars as WCHARs. UTF-8 has 3 BYTES for
	// all codes above 0x7ff. UTF-7 has even more due to shift in/out codes.
	// We don't support UTF-7, since can't use WCTMB with UTF-7 chunks

	char		szBuf[3*WRITESIZE];	// Factor of 2 works with DBCS, 3 with UTF-8
	WCHAR		wszBuf[WRITESIZE];

	pes->dwError = NOERROR;							// No error yet

	pb = (uCpg == 1200) ? (BYTE *)wszBuf			// Setup Unicode or MBCS
						: (BYTE *)szBuf;

	LONG cchText = _ped->GetAdjustedTextLength();
	cpMost = min(cpMost, cchText);					// Don't write final CR
	while(tp.GetCp() < cpMost)
	{
		if (fTextize && tp.GetChar() == WCH_EMBEDDING)
		{
			Assert(_ped->GetObjectCount());

			pobj = _ped->GetObjectMgr()->GetObjectFromCp(tp.GetCp());
			tp.AdvanceCp(1);						// Advance past object
			if(pobj)
			{
				cbWriteTotal += pobj->WriteTextInfoToEditStream(pes);
				continue;							// If no object at cp,
			}										//  just ignore char
		}											
		cch	= tp.GetPlainText(WRITESIZE, wszBuf, cpMost, fTextize, fAdjustCRLF);
		if(!cch)
			break;									// No more to do
		fAdjustCRLF = FALSE;						// Already adjusted 

		cbConverted = 2*cch;						// Default Unicode byte ct
		if(uCpg != 1200)							// Multibyte of some kind
		{
			cbConverted = MbcsFromUnicode(szBuf, 3*WRITESIZE, wszBuf, cch, uCpg,
								UN_CONVERT_WCH_EMBEDDING);

			// FUTURE: report some kind of error if default char used,
			// i.e., data lost in conversion
		
			// Did the conversion completely fail? As a fallback, we might try
			// the system code page, or just plain ANSI...
		
			if (!cbConverted)
			{
				uCpg = GetLocaleCodePage();
				cbConverted = MbcsFromUnicode(szBuf, 3*WRITESIZE, wszBuf, cch, uCpg,
												UN_CONVERT_WCH_EMBEDDING);
			}

			if (!cbConverted)
			{
				uCpg = CP_ACP;
				cbConverted = MbcsFromUnicode(szBuf, 3*WRITESIZE, wszBuf, cch, uCpg,
												UN_CONVERT_WCH_EMBEDDING);
			}
		}

		pes->dwError = (*pes->pfnCallback)(pes->dwCookie, pb,
							cbConverted,  &cbWrite);
		if(!pes->dwError && cbConverted != cbWrite)	// Error or ran out of
			pes->dwError = (DWORD)STG_E_MEDIUMFULL;	//  target storage

		if(pes->dwError)
			break;
		cbWriteTotal += cbWrite;
	}

	AssertSz(tp.GetCp() >= cpMost,
		"CLightDTEngine::WritePlainText: not all text written");

	return cbWriteTotal;
}

/*
 *	CLightDTEngine::GetStreamCodePage (lStreamFormat)
 *
 *	@mfunc
 *		Returns code page given by lStreamFormat or CTxtEdit::_pDocInfo
 *
 *	@rdesc
 *		HRESULT
 */
LONG CLightDTEngine::GetStreamCodePage(
	LONG lStreamFormat)
{
	// FUTURE: support 1201, i.e., big-endian Unicode?
	if(lStreamFormat & SF_UNICODE)
		return 1200;

	if(lStreamFormat & SF_USECODEPAGE)
		return HIWORD(lStreamFormat);

	if (W32->IsFESystem())
		return GetACP();

	return CP_ACP;
}

/*
 *	CLightDTEngine::CreateOleObjFromDataObj ( pdo, prg, rps, iformatetc, pubdlr )
 *
 *	@mfunc
 *		Creates an ole object based on the data object pdo, and
 *		pastes the object into the range prg. Any text that already
 *		existed in the range is replaced.
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::CreateOleObjFromDataObj(
	IDataObject *	pdo,		// @parm Data object from which to create
	CTxtRange *		prg,		// @parm Range in which to place
	REPASTESPECIAL *rps,		// @parm Special paste info
	INT				iformatetc,	// @parm Index in g_rgFETC
	IUndoBuilder *	publdr)		// @parm Undo builder to receive antievents
{
#ifndef PEGASUS
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CreateOleObjFromDataObj");

	HRESULT			hr = NOERROR;
	REOBJECT		reobj;
	SIZEL			sizel;
	FORMATETC		formatetc;
	DWORD			dwDrawAspect = 0;
	HGLOBAL			hMetaPict = NULL;
	LPRICHEDITOLECALLBACK const precall = _ped->GetRECallback();
	LPOBJECTDESCRIPTOR lpod = NULL;
	STGMEDIUM		medObjDesc;
	BOOL			fStatic = (iformatetc == iMfPict || iformatetc == iDIB ||
							   iformatetc == iBitmap);
	BOOL			fFilename = (iformatetc == iFilename);
    DUAL_FORMATETC	tmpFormatEtc;

	if(!precall)
		return E_NOINTERFACE;

	ZeroMemory(&medObjDesc, sizeof(STGMEDIUM));
	ZeroMemory(&sizel, sizeof(SIZEL));
	ZeroMemory(&reobj, sizeof(REOBJECT));

	if(fStatic)
		dwDrawAspect = DVASPECT_CONTENT;

	if(fFilename)
		dwDrawAspect = DVASPECT_ICON;

	if(rps && !dwDrawAspect)
	{
		dwDrawAspect = rps->dwAspect;
		if(rps->dwAspect == DVASPECT_ICON)
			hMetaPict = (HGLOBAL)rps->dwParam;
	}

	// If no aspect was specified, pick up the object descriptor hints
	if(!dwDrawAspect)
	{
		// Define ObjectDescriptor data
		formatetc.cfFormat = cf_OBJECTDESCRIPTOR;
		formatetc.ptd = NULL;
		formatetc.dwAspect = DVASPECT_CONTENT;
		formatetc.lindex = -1;
		formatetc.tymed = TYMED_HGLOBAL;

		if(pdo->GetData(&formatetc, &medObjDesc) == NOERROR)
		{
			HANDLE	hGlobal = medObjDesc.hGlobal;

			lpod = (LPOBJECTDESCRIPTOR)GlobalLock(hGlobal);
			if(lpod)
			{
				dwDrawAspect = lpod->dwDrawAspect;
			}
			GlobalUnlock(hGlobal);
			ReleaseStgMedium(&medObjDesc);
		}
	}

	if(!dwDrawAspect)
		dwDrawAspect = DVASPECT_CONTENT;

	if(fStatic)
	{
		reobj.clsid	= ((iformatetc == iMfPict) ?
			CLSID_StaticMetafile : CLSID_StaticDib);
	}

	// COMPATIBILITY ISSUE: Compatibility Issue from Richedit 1.0 - Raid 16456:
	// Don't call GetData(CF_EMBEDSOURCE)
	// on 32-bit Excel. Also clsidPictPub.
	//	if(iformatetc == iformatetcEmbSrc && (ObFIsExcel(&clsid) ||
	//		IsEqualCLSID(&clsid, &clsidPictPub)))
	//	else
	//		ObGetStgFromDataObj(pdataobj, &medEmbed, iformatetc);

	// Get storage for the object from the application
	hr = precall->GetNewStorage(&reobj.pstg);
	if(hr)
	{
		TRACEERRORSZ("GetNewStorage() failed.");
		goto err;
	}

	// Create an object site for the new object
	hr = _ped->GetClientSite(&reobj.polesite);
	if(!reobj.polesite)
	{
		TRACEERRORSZ("GetClientSite() failed.");
		goto err;
	}


	ZeroMemory(&tmpFormatEtc, sizeof(DUAL_FORMATETC));
	tmpFormatEtc.ptd = NULL;
	tmpFormatEtc.dwAspect = dwDrawAspect;
	tmpFormatEtc.lindex = -1;

	//Create the object
	if(fStatic)
	{
		hr = OleCreateStaticFromData(pdo, IID_IOleObject, OLERENDER_DRAW,
				&tmpFormatEtc, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);
	}
	else if(iformatetc == iLnkSrc || (_ped->Get10Mode() && iformatetc == iFilename))
	{
		hr = OleCreateLinkFromData(pdo, IID_IOleObject, OLERENDER_DRAW,
				&tmpFormatEtc, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);
	}
	else
	{
		hr = OleCreateFromData(pdo, IID_IOleObject, OLERENDER_DRAW,
				&tmpFormatEtc, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);
	}

	if(hr)
	{
		TRACEERRORSZ("Failure creating object.");
		goto err;
	}


	//Get the clsid of the object.
	if(!fStatic)
	{
		hr = reobj.poleobj->GetUserClassID(&reobj.clsid);
		if(hr)
		{
			TRACEERRORSZ("GetUserClassID() failed.");
			goto err;
		}
	}

	//Deal with iconic aspect if specified.
	if(hMetaPict)
	{
		BOOL fUpdate;

		hr = OleStdSwitchDisplayAspect(reobj.poleobj, &dwDrawAspect,
										DVASPECT_ICON, hMetaPict, FALSE,
										FALSE, NULL, &fUpdate);
		if(hr)
		{
			TRACEERRORSZ("OleStdSwitchDisplayAspect() failed.");
			goto err;
		}

		// If we successully changed the aspect, recompute the size.
		hr = reobj.poleobj->GetExtent(dwDrawAspect, &sizel);

		if(hr)
		{
			TRACEERRORSZ("GetExtent() failed.");
			goto err;
		}
	}

	// Try to retrieve the previous saved RichEdit site flags.
	if( ObjectReadSiteFlags(&reobj) != NOERROR )
	{
		// Set default for site flags
		reobj.dwFlags = REO_RESIZABLE;
	}

	// First, clear the range
	prg->Delete(publdr, SELRR_REMEMBERRANGE);

	reobj.cbStruct = sizeof(REOBJECT);
	reobj.cp = prg->GetCp();
	reobj.dvaspect = dwDrawAspect;
	reobj.sizel = sizel;

	//COMPATIBILITY ISSUE: from Richedit 1.0 - don't Set the Extent,
	//instead Get the Extent below in ObFAddObjectSite
	//hr = reobj.poleobj->SetExtent(dwDrawAspect, &sizel);

	hr = reobj.poleobj->SetClientSite(reobj.polesite);
	if(hr)
	{
		TRACEERRORSZ("SetClientSite() failed.");
		goto err;
	}

	if(hr = _ped->InsertObject(&reobj))
	{
		TRACEERRORSZ("InsertObject() failed.");
	}

err:
	if(reobj.poleobj)
		reobj.poleobj->Release();

	if(reobj.polesite)
		reobj.polesite->Release();

	if(reobj.pstg)
		reobj.pstg->Release();

	return hr;
#else
	return 0;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\lbhost.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	LBHOST.CPP -- Text Host for CreateWindow() Rich Edit 
 *		List Box Control | 
 *		Implements CLstBxWinHost message
 *		
 *	Original Author: 
 *		Jerry Kim
 *
 *	History: <nl>
 *		12/15/97 - v-jerrki Created
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "_host.h"
#include "imm.h"
#include "_format.h"
#include "_edit.h"
#include "_cfpf.h"
#include "_cbhost.h"

ASSERTDATA

#ifdef DEBUG
const UINT db_rgLBUnsupportedStyle[] = {
	LBS_MULTICOLUMN,
	LBS_NODATA,			
	LBS_NOREDRAW,
	LBS_NOSEL,
	LBS_OWNERDRAWVARIABLE,
	LBS_WANTKEYBOARDINPUT,
	0
};

const UINT db_rgLBUnsupportedMsg[] = {		
	LB_GETHORIZONTALEXTENT,
	LB_GETLOCALE,
	LB_SETLOCALE,
	LB_GETHORIZONTALEXTENT,
	LB_INITSTORAGE,
	LB_ITEMFROMPOINT,
	LB_SETANCHORINDEX,
	LB_SETHORIZONTALEXTENT,
	LB_SETCOLUMNWIDTH,
	LB_ADDFILE,
	LB_DIR,
	EM_GETLIMITTEXT,
	EM_POSFROMCHAR,
	EM_CHARFROMPOS,
	EM_SCROLLCARET,
	EM_CANPASTE,
	EM_DISPLAYBAND,
	EM_EXGETSEL,
	EM_EXLIMITTEXT,
	EM_EXLINEFROMCHAR,
	EM_EXSETSEL,
	EM_FINDTEXT,
	EM_FORMATRANGE,
	EM_GETEVENTMASK,
	EM_GETOLEINTERFACE,
	EM_GETPARAFORMAT,
	EM_GETSELTEXT, 
	EM_HIDESELECTION,
	EM_PASTESPECIAL,
	EM_REQUESTRESIZE,
	EM_SELECTIONTYPE,
	EM_SETBKGNDCOLOR,
	EM_SETEVENTMASK,
	EM_SETOLECALLBACK,
	EM_SETTARGETDEVICE,
	EM_STREAMIN,
	EM_STREAMOUT,
	EM_GETTEXTRANGE,
	EM_FINDWORDBREAK,
	EM_SETOPTIONS,
	EM_GETOPTIONS,
	EM_FINDTEXTEX,
#ifdef _WIN32
	EM_GETWORDBREAKPROCEX,
	EM_SETWORDBREAKPROCEX,
#endif

	/* Richedit v2.0 messages */
	EM_SETUNDOLIMIT,
	EM_REDO,
	EM_CANREDO,
	EM_GETUNDONAME,
	EM_GETREDONAME,
	EM_STOPGROUPTYPING,
	EM_SETTEXTMODE,
	EM_GETTEXTMODE,
	EM_AUTOURLDETECT,
	EM_GETAUTOURLDETECT,
	EM_GETTEXTEX,
	EM_GETTEXTLENGTHEX,
	EM_SHOWSCROLLBAR,	
	/* Far East specific messages */
	EM_SETPUNCTUATION,
	EM_GETPUNCTUATION,
	EM_SETWORDWRAPMODE,
	EM_GETWORDWRAPMODE,
	EM_SETIMECOLOR,
	EM_GETIMECOLOR,
	EM_SETIMEOPTIONS,
	EM_GETIMEOPTIONS,
	EM_CONVPOSITION,
	EM_SETLANGOPTIONS,
	EM_GETLANGOPTIONS,
	EM_GETIMECOMPMODE,
	EM_FINDTEXTW,
	EM_FINDTEXTEXW,

	/* RE3.0 FE messages */
	EM_RECONVERSION,
	EM_SETIMEMODEBIAS,
	EM_GETIMEMODEBIAS,
	/* Extended edit style specific messages */
	0
};

// Checks if the style is in the passed in array
BOOL LBCheckStyle(UINT msg, const UINT* rg)
{
	for (int i = 0; rg[i]; i++)
		if (rg[i] & msg)
		{
			AssertSz(FALSE, "Unsupported style recieved");
			return TRUE;
		}
	return FALSE;
}

// Checks if the msg is in the passed in array
BOOL LBCheckMessage(UINT msg, const UINT* rg)
{
	for (int i = 0; rg[i]; i++)
		if (rg[i] == msg)
		{
			AssertSz(FALSE, "Unsupported message recieved");
			return TRUE;
		}
	return FALSE;
}

#define CHECKSTYLE(msg) if (LBCheckStyle(msg, db_rgLBUnsupportedStyle)) Assert(FALSE && "Unsupported Style")
#define CHECKMESSAGE(msg) if (LBCheckMessage(msg, db_rgLBUnsupportedMsg)) Assert(FALSE && "Unsupported Message")
#else
#define CHECKSTYLE(msg)	
#define CHECKMESSAGE(msg)
#endif

// internal listbox messages
#define LB_KEYDOWN WM_USER+1

// UNDONE:
//	Should this go into _w32sys.h??
#ifndef CSTR_LESS_THAN
// 
//  Compare String Return Values. 
// 
#define CSTR_LESS_THAN            1           // string 1 less than string 2 
#define CSTR_EQUAL                2           // string 1 equal to string 2 
#define CSTR_GREATER_THAN         3           // string 1 greater than string 
#endif


// UNDONE : LOCALIZATION
// these vary by country!  For US they are VK_OEM_2 VK_OEM_5.
//       Change lboxctl2.c MapVirtualKey to character - and fix the spelling?
#define VERKEY_SLASH     0xBF   /* Vertual key for '/' character */
#define VERKEY_BACKSLASH 0xDC   /* Vertual key for '\' character */

// Used for Listbox notifications
#define LBNOTIFY_CANCEL 	1
#define LBNOTIFY_SELCHANGE 	2
#define LBNOTIFY_DBLCLK		4

// Used for LBSetSelection
#define LBSEL_SELECT	1
#define LBSEL_NEWANCHOR	2
#define LBSEL_NEWCURSOR	4
#define LBSEL_RESET		8
#define LBSEL_HIGHLIGHTONLY 16

#define LBSEL_DEFAULT (LBSEL_SELECT | LBSEL_NEWANCHOR | LBSEL_NEWCURSOR | LBSEL_RESET)

// Used for keyboard and mouse messages
#define LBKEY_NONE 0
#define LBKEY_SHIFT	1
#define LBKEY_CONTROL 2
#define LBKEY_SHIFTCONTROL 3

extern const TCHAR szCR[];

// Timer id when mouse is captured
#define ID_LB_CAPTURE	28988
#define ID_LB_CAPTURE_DEFAULT 250

// Timer id when type search is required
#define ID_LB_SEARCH	28989
#define ID_LB_SEARCH_DEFAULT 750	//.75 seconds is the value for winnt

// Size of allocated string
#define LBSEARCH_MAXSIZE 256

// Helper function in edit.cpp
LONG GetECDefaultHeightAndWidth(
	ITextServices *pts,
	HDC hdc,
	LONG lZoomNumerator,
	LONG lZoomDenominator,
	LONG yPixelsPerInch,
	LONG *pxAveWidth,
	LONG *pxOverhang,
	LONG *pxUnderhang);

// helper function for compare string.  This function checks for null strings
// because CStrIn doesn't like initializing string with zero length
int CompareStringWrapper( 
	LCID  Locale,			// locale identifier 
	DWORD  dwCmpFlags,		// comparison-style options 
	LPCWSTR  lpString1,		// pointer to first string 
	int  cch1,			// size, in bytes or characters, of first string 
	LPCWSTR  lpString2,		// pointer to second string 
	int  cch2 			// size, in bytes or characters, of second string  
)
{
	// check if one of the 2 strings is 0-length if so then
	// no need to proceed the one with the 0-length is the less
	if (!cch1 || !cch2)
	{
		if (cch1 < cch2)
			return CSTR_LESS_THAN;
		else if (cch1 > cch2)
			return CSTR_GREATER_THAN;
		return CSTR_EQUAL;
	}
	return CompareString(Locale, dwCmpFlags, lpString1, cch1, lpString2, cch2);	
}

template<class CLbData> CLbData
CDynamicArray<CLbData>::_sDummy = {0, 0};

//////////////////////////// System Window Procs ////////////////////////////
/*
 *	RichListBoxWndProc (hwnd, msg, wparam, lparam)
 *
 *	@mfunc
 *		Handle window messages pertinent to the host and pass others on to
 *		text services. 
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CALLBACK RichListBoxWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichListBoxWndProc");

	LRESULT	lres = 0;
	HRESULT hr;
	CLstBxWinHost *phost = (CLstBxWinHost *) GetWindowLongPtr(hwnd, ibPed);

	#ifdef DEBUG
	Tracef(TRCSEVINFO, "hwnd %lx, msg %lx, wparam %lx, lparam %lx", hwnd, msg, wparam, lparam);
	#endif	// DEBUG

	switch(msg)
	{
	case WM_NCCREATE:
		return CLstBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *)lparam);

	case WM_CREATE:
		// We may be on a system with no WM_NCCREATE (e.g. WINCE)
		if (!phost)
		{
			(void) CLstBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *) lparam);
			phost = (CLstBxWinHost *) GetWindowLongPtr(hwnd, ibPed);
		}
		break;

	case WM_DESTROY:
		if(phost)
			CLstBxWinHost::OnNCDestroy(phost);
		return 0;
	}

	if (!phost)
		return ::DefWindowProc(hwnd, msg, wparam, lparam);

	// in certain out-of-memory situations, clients may try to re-enter us 
	// with calls.  Just bail on the call if we don't have a text services
	// pointer.
	if(!phost->_pserv)
		return 0;

	// stabilize ourselves
	phost->AddRef();

	CHECKMESSAGE(msg);

	long nTemp = 0;
	switch(msg)
	{
	///////////////////////Painting. Messages///////////////////////////////
	case WM_NCPAINT:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		phost->OnSysColorChange();
		if(phost->TxGetEffects() == TXTEFFECT_SUNKEN && dwMajorVersion < VERS4 &&
			phost->_fLstType != CLstBxWinHost::kCombo)
		{
			HDC hdc = GetDC(hwnd);
			if(hdc)
			{
				phost->DrawSunkenBorder(hwnd, hdc);
				ReleaseDC(hwnd, hdc);
			}
		}
		break;

	case WM_PRINTCLIENT:
	case WM_PAINT:
		{
			PAINTSTRUCT ps;
			RECT rc;
 			HPALETTE hpalOld = NULL;
			HDC hdc = BeginPaint(hwnd, &ps);
			RECT rcClient;			
			
			// Since we are using the CS_PARENTDC style, make sure
			// the clip region is limited to our client window.
			GetClientRect(hwnd, &rcClient);

			// Set up the palette for drawing our data
			if(phost->_hpal)
			{
				hpalOld = SelectPalette(hdc, phost->_hpal, TRUE);
				RealizePalette(hdc);
			}

			SaveDC(hdc);
			IntersectClipRect(hdc, rcClient.left, rcClient.top, rcClient.right,
				rcClient.bottom);
				
			if (!phost->_fOwnerDraw)
			{	
				

				phost->_pserv->TxDraw(
					DVASPECT_CONTENT,  		// Draw Aspect
					-1,						// Lindex
					NULL,					// Info for drawing optimazation
					NULL,					// target device information
					hdc,					// Draw device HDC
					NULL, 				   	// Target device HDC
					(const RECTL *) &rcClient,// Bounding client rectangle
					NULL, 					// Clipping rectangle for metafiles
					&ps.rcPaint,			// Update rectangle
					NULL, 	   				// Call back function
					NULL,					// Call back parameter
					TXTVIEW_ACTIVE);		// What view - the active one!

				// Restore palette if there is one
#ifndef PEGASUS
				if(hpalOld)
					SelectPalette(hdc, hpalOld, TRUE);
#endif
				if(phost->TxGetEffects() == TXTEFFECT_SUNKEN && dwMajorVersion < VERS4 &&
					phost->_fLstType != CLstBxWinHost::kCombo)
					phost->DrawSunkenBorder(hwnd, hdc);
			}
			else
			{
				// Owner draw
				int nViewsize = phost->GetViewSize();
				int nCount = phost->GetCount();
				int nTopidx = phost->GetTopIndex();
				
				// notify each visible item and then the one which has the focus
				int nBottom = min(nCount, nTopidx + nViewsize);
				if (nBottom >= nCount || !phost->IsItemViewable(nBottom))
					nBottom--;
				for (int i = nTopidx; i <= nBottom; i++) 
				{
					// get Rect of region and see if it intersects
			    	phost->LbGetItemRect(i, &rc);
			    	if (IntersectRect(&rc, &rc, &ps.rcPaint))
			    	{
						//first erase the background and notify parent to draw
						FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
			    		phost->LbDrawItemNotify(hdc, i, ODA_DRAWENTIRE, phost->IsSelected(i) ? ODS_SELECTED : 0);
			    	}
			    }

				// Now draw onto the area where drawing may not have been done or erased
				int nDiff = nCount - nTopidx;
				if (nDiff < nViewsize || 
					(phost->_fNoIntegralHeight && nDiff == nViewsize))
				{
					rc = rcClient;
					if (nDiff < 0)
						nDiff *= -1;  // lets be positive

					rc.top = nDiff * phost->GetItemHeight();
					if (IntersectRect(&rc, &rc, &ps.rcPaint))
						FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
				}
		    
#ifndef PEGASUS
				if(hpalOld)
					SelectPalette(hdc, hpalOld, TRUE);
#endif
			}
			RestoreDC(hdc, -1);

			// Check if we need to draw the focus rect by checking if the focus rect intersects
			// the painting rect
			phost->LbGetItemRect(phost->GetCursor(), &rc);

			// NOTE: Bug #5431
			// This bug could be fixed by replacing the hDC to NULL
			// The hdc can be clipped from BeginPaint API.  So just pass in NULL
			// when drawing focus rect
			phost->SetCursor(hdc, phost->GetCursor(), FALSE);			
			EndPaint(hwnd, &ps);
		}
		break;

	/////////////////////////Mouse Messages/////////////////////////////////
	case WM_RBUTTONDOWN:
	case WM_RBUTTONDBLCLK:
	case WM_MBUTTONDBLCLK:
	case WM_MBUTTONDOWN:
		break;

	case WM_LBUTTONDBLCLK:
		phost->_fDblClick = 1;
		/* Fall through case */
	case WM_LBUTTONDOWN:
		if (!phost->_fFocus)
			SetFocus(hwnd);
		phost->OnLButtonDown(wparam, lparam);
		break;
		
	case WM_MOUSEMOVE:
		if (!phost->GetCapture())
			break;
		phost->OnMouseMove(wparam, lparam);
		break;
		
	case WM_LBUTTONUP:	
		if (!phost->GetCapture())
			break;
		phost->OnLButtonUp(wparam, lparam, LBN_SELCHANGE);
		break;

	case WM_MOUSEWHEEL:
		if (wparam & (MK_SHIFT | MK_CONTROL))
			goto defwndproc;

		lres = phost->OnMouseWheel(wparam, lparam);
		break;

	///////////////////////KeyBoard Messages////////////////////////////////
	case WM_KEYDOWN:
		phost->OnKeyDown(LOWORD(wparam), lparam, 0);
		break;

	case WM_CHAR:
		if (W32->OnWin9x() || phost->_fANSIwindow)
		{
			CW32System::WM_CHAR_INFO wmci;
			wmci._fAccumulate = phost->_fAccumulateDBC != 0;
			W32->AnsiFilter( msg, wparam, lparam, (void *) &wmci );
			if (wmci._fLeadByte)
			{
				phost->_fAccumulateDBC = TRUE;
				phost->_chLeadByte = wparam << 8;
				goto Exit;					// Wait for trail byte
			}
			else if (wmci._fTrailByte)
			{
				// UNDONE:
				// Need to see what we should do in WM_IME_CHAR
				wparam = phost->_chLeadByte | wparam;
				phost->_fAccumulateDBC = FALSE;
				phost->_chLeadByte = 0;
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
		}
		
		phost->OnChar(LOWORD(wparam), lparam);
		break;
		
	case WM_TIMER:
		if (phost->OnTimer(wparam, lparam))
			goto serv;			
		break;		

	case LBCB_TRACKING:
		phost->OnCBTracking(wparam, lparam);
		break;

	//UNDONE:
	//	Messages should be ordered from most often called --> least often called
	//		
	case LB_GETITEMRECT:
		Assert(lparam);
		lres = -1;
		if (((wparam < (unsigned)phost->GetCount()) && 
			phost->IsItemViewable((long)wparam)) || wparam == (unsigned int)-1 ||
			wparam == 0 && phost->GetCount() == 0)
			lres = phost->LbGetItemRect(wparam, (RECT*)lparam);
		break;
	
	///////////////////////ListBox Messages/////////////////////////////////
	case LB_GETITEMDATA:
		if ((unsigned)phost->GetCount() <= wparam) 
			lres = LB_ERR;
		else
			lres = phost->GetData(wparam);
		break;
		
	case LB_SETITEMDATA:
		lres = LB_ERR;
		if ((int)wparam >= -1 && (int)wparam < phost->GetCount())
		{
			// if index is -1 this means all the dataItems are set
			// to the value
			lres = 1;
			if (wparam == -1)
				phost->LbSetItemData(0, phost->GetCount() - 1, lparam);
			else
				phost->LbSetItemData(wparam, wparam, lparam);
		}
		break;
	
	case LB_GETSELCOUNT:
		if (lparam != NULL || wparam != 0)
		{
			lres = LB_ERR;
			break;
		}
		wparam = phost->GetCount();
		// FALL through case
		
	case LB_GETSELITEMS:
		// retrieves all the selected items in the list
		lres = LB_ERR;
		if (!phost->IsSingleSelection())
		{
			int j = 0;
			int nMin = min(phost->GetCount(), (int)wparam);
			for (int i = 0; i < nMin; i++)
				if (phost->IsSelected(i))
				{
					if (lparam)
						((int*)lparam)[j] = i;
					j++;
				}
			lres = j;
		}
		break;
		
	case LB_GETSEL:
		// return the select state of the passed in index
		lres = LB_ERR;
		if ((int)wparam >= 0 && (int)wparam < phost->GetCount())
			lres = phost->IsSelected((long)wparam);		
		break;
		
	case LB_GETCURSEL:
		// Get the current selection
		lres = LB_ERR;
		if (!phost->IsSingleSelection())
			lres = phost->GetCursor();
		else		
		{
			if (phost->IsSelected(phost->GetCursor()))
				lres = phost->GetCursor();				
		}
		break;
		
	case LB_GETTEXTLEN:
		// Retieves the text at the requested index
		lres = LB_ERR;
		if (wparam < (unsigned)phost->GetCount())
			lres = phost->GetString(wparam, (PWCHAR)NULL);
		break;

	case LB_GETTEXT:			
		// Retieves the text at the requested index
		lres = LB_ERR;
		if ((int)lparam != NULL && (int)wparam >= 0 && (int)wparam < phost->GetCount())
			lres = phost->GetString(wparam, (PWCHAR)lparam);
		break;
		
	case LB_RESETCONTENT:
		// Reset the contents
		lres = phost->LbDeleteString(0, phost->GetCount() - 1);
		break;
		
	case LB_DELETESTRING:
		// Delete requested item
		lres = phost->LbDeleteString(wparam, wparam);
		break;
		
	case LB_ADDSTRING:
		lres = phost->LbInsertString((phost->_fSort) ? -2 : -1, (LPCTSTR)lparam);
		break;
		
	case LB_INSERTSTRING:
		lres = LB_ERR;
		if (wparam <= (unsigned long)phost->GetCount() || (signed int)wparam == -1 || wparam == 0)
			lres = phost->LbInsertString(wparam, (LPCTSTR)lparam);
		break;		

	case LB_GETCOUNT:
		// retrieve the count
		lres = phost->GetCount();
		break;
		
	case LB_GETTOPINDEX:
		// Just return the top index
		lres = phost->GetTopIndex();
		break;

	case LB_GETCARETINDEX:
		lres = phost->GetCursor();
		break;

	case LB_GETANCHORINDEX:
		lres = phost->GetAnchor();
		break;
		
	case LB_FINDSTRINGEXACT:
		// For NT compatibility
		wparam++;
		
		// Find and select the item matching the string text
		if ((int)wparam >= phost->GetCount() || (int)wparam < 0)
			wparam = 0;

		lres = phost->LbFindString(wparam, (LPCTSTR)lparam, TRUE);
		if (0 <= lres)
			break;
				
		lres = LB_ERR;
		break;
		
	case LB_FINDSTRING:	
		// For NT compatibility
		wparam++;
		
		// Find and select the item matching the string text
		if (wparam >= (unsigned)phost->GetCount())
			wparam = 0;

		lres = phost->LbFindString(wparam, (LPCTSTR)lparam, FALSE);
		if (0 > lres)
			lres = LB_ERR;
		break;
	
	case LB_SELECTSTRING:
		if (phost->IsSingleSelection())
		{			
			// For NT compatibility
			wparam++;
			
			// Find and select the item matching the string text
			if ((int)wparam >= phost->GetCount() || (int)wparam < 0)
				wparam = 0;

			lres = phost->LbFindString(wparam, (LPCTSTR)lparam, FALSE);
			if (0 <= lres)
			{
				// bug fix #5260 - need to move to selected item first
				// Unselect last item and select new one
				Assert(lres >= 0 && lres < phost->GetCount());
				if (phost->LbShowIndex(lres, FALSE) && phost->LbSetSelection(lres, lres, LBSEL_DEFAULT, lres, lres))
				{
#ifndef NOACCESSIBILITY
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);

					phost->_dwWinEvent = EVENT_OBJECT_SELECTION;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
#endif	
					break;
				}
			}						
		}
		// If failed then let it fall through to the LB_ERR
		lres = LB_ERR;
		break;
		
	case LB_SETSEL:
		// We only update the GetAnchor() and _nCursor if we are selecting an item
		if (!phost->IsSingleSelection())
		{
			// We need to return zero to mimic system listbox
			if (!phost->GetCount())
				break;

			//bug fix #4265
			int nStart = lparam;
			int nEnd = lparam;
			int nAnCur = lparam;
			if (lparam == (unsigned long)-1)
			{
				nAnCur = phost->GetCursor();
				nStart = 0;
				nEnd = phost->GetCount() - 1;
			}
			if (phost->LbSetSelection(nStart, nEnd, (BOOL)wparam ? 
				LBSEL_SELECT | LBSEL_NEWANCHOR | LBSEL_NEWCURSOR : 0, nAnCur, nAnCur))
			{
#ifndef NOACCESSIBILITY
				if (lparam == (unsigned long)-1)
				{
					phost->_dwWinEvent = EVENT_OBJECT_SELECTIONWITHIN;
				}
				else if (wparam)
				{
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
					phost->_dwWinEvent = EVENT_OBJECT_SELECTION;
				}
				else
				{
					phost->_nAccessibleIdx = lparam + 1;
					phost->_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
				}
				phost->_fNotifyWinEvt = TRUE;
				phost->TxNotify(phost->_dwWinEvent, NULL);
#endif
				break;
			}
		}

		// We only get here if error occurs or list box is a singel sel Listbox
		lres = LB_ERR;
		break;

	case LB_SELITEMRANGEEX:
		// For this message we need to munge the messages a little bit so it
		// conforms with LB_SETITEMRANGE
		if ((int)lparam > (int)wparam)
		{
			nTemp = MAKELONG(wparam, lparam);
			wparam = 1;
			lparam = nTemp;
		}
		else
		{
			nTemp = MAKELONG(lparam, wparam);
			wparam = 0;
			lparam = nTemp;			
		}	
		/* Fall through case */

	case LB_SELITEMRANGE:				
		// We have to make sure the range is valid
		if (LOWORD(lparam) >= phost->GetCount())
		{
			if (HIWORD(lparam) >= phost->GetCount())
				//nothing to do so exit without error
				break;
			lparam = MAKELONG(HIWORD(lparam), phost->GetCount() - 1);
		}
		else if (HIWORD(lparam) > LOWORD(lparam))
		{
			// NT swaps the start and end value if start > end
			lparam = MAKELONG(LOWORD(lparam), HIWORD(lparam) < phost->GetCount() ? 
				HIWORD(lparam) : phost->GetCount()-1);
		}

		// Item range messages do not effect the GetAnchor() nor the _nCursor
		if (!phost->IsSingleSelection() && phost->LbSetSelection(HIWORD(lparam), 
				LOWORD(lparam), LBSEL_RESET | ((wparam) ? LBSEL_SELECT : 0), 0, 0))
		{
#ifndef NOACCESSIBILITY
			phost->_dwWinEvent = EVENT_OBJECT_SELECTIONWITHIN;
			phost->_fNotifyWinEvt = TRUE;
			phost->TxNotify(phost->_dwWinEvent, NULL);
#endif		
			break;
		}

		// We only get here if error occurs or list box is a singel sel Listbox
		lres = LB_ERR;
		break;

	case LB_SETCURSEL:
		// Only single selection list box can call this!!
		if (phost->IsSingleSelection())
		{
			// -1 should return LB_ERR and turn off any selection

			// special flag indicating no items should be selected
			if (wparam == (unsigned)-1)
			{	
				// turn-off any selections
				int nCurrentCursor = phost->GetCursor();
				phost->LbSetSelection(phost->GetCursor(), phost->GetCursor(), LBSEL_RESET, 0, 0);
				phost->SetCursor(NULL, -1, phost->_fFocus);
#ifndef NOACCESSIBILITY
				if (nCurrentCursor != -1)
				{
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_nAccessibleIdx = nCurrentCursor + 1;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
					phost->_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
					phost->_nAccessibleIdx = nCurrentCursor + 1;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
				}
#endif
			}
			else if (wparam < (unsigned)(phost->GetCount()))
			{
				if ((int)wparam == phost->GetCursor() && phost->IsSelected((int)wparam) && 
				    phost->IsItemViewable((signed)wparam) ||
					phost->LbShowIndex(wparam, FALSE) /* bug fix #5260 - need to move to selected item first */
					&& phost->LbSetSelection(wparam, wparam, LBSEL_DEFAULT, wparam, wparam))
				{
					lres = (unsigned)wparam;
#ifndef NOACCESSIBILITY
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
					phost->_dwWinEvent = EVENT_OBJECT_SELECTION;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
#endif
					break;
				}
			}
		}
		// If failed then let it fall through to the LB_ERR
		lres = LB_ERR;
		break;

	case LB_SETTOPINDEX:
		// Set the top index
		if ((!phost->GetCount() && !wparam) || phost->LbSetTopIndex(wparam) >= 0)
			break;

		// We get here if something went wrong
		lres = LB_ERR;
		break;

	case LB_SETITEMHEIGHT:
		if (!phost->LbSetItemHeight(LOWORD(lparam)))
			lres = LB_ERR;
		break;	

	case LB_GETITEMHEIGHT:
		lres = LB_ERR;
		if ((unsigned)phost->GetCount() > wparam || wparam == 0 || wparam == (unsigned)-1)
			lres = phost->GetItemHeight();
		break;

	case LB_SETCARETINDEX:
        if (((phost->GetCursor() == -1) || (!phost->IsSingleSelection()) &&
                    (phost->GetCount() > (INT)wparam)))
        {
            /*
             * Set's the Cursor to the wParam
             * if lParam, then don't scroll if partially visible
             * else scroll into view if not fully visible
             */
            if (!phost->IsItemViewable(wparam) || lparam)
            {
                phost->LbShowIndex(wparam, FALSE);
                phost->SetCursor(NULL, wparam, TRUE);
            }
            lres = 0;            
        } 
        else        
            return LB_ERR;            
        break;

	case EM_SETTEXTEX:
		lres = LB_ERR;
		if (lparam)
			lres = phost->LbBatchInsert((WCHAR*)lparam);	
		break;

	////////////////////////Windows Messages////////////////////////////////
	case WM_VSCROLL:
		phost->OnVScroll(wparam, lparam);
		break;

	case WM_CAPTURECHANGED:
		lres = phost->OnCaptureChanged(wparam, lparam);
		if (!lres)
			break;
		goto serv;

	case WM_KILLFOCUS:
		lres = 1;
		phost->_fFocus = 0;
		phost->SetCursor(NULL, phost->GetCursor(), TRUE);	// force the removal of focus rect
		phost->InitSearch();
		phost->InitWheelDelta();
		if (phost->_fLstType == CLstBxWinHost::kCombo)
			phost->OnCBTracking(LBCBM_END, 0);	//this will internally release the mouse capture
			phost->TxNotify(LBN_KILLFOCUS, NULL);
		break;
		
	case WM_SETFOCUS:
		lres = 1;
		phost->_fFocus = 1;
		phost->SetCursor(NULL, (phost->GetCursor() < 0) ? -2 : phost->GetCursor(), 
			FALSE);  // force the displaying of the focus rect
		phost->TxNotify(LBN_SETFOCUS, NULL);
		break;

	case WM_SETCURSOR:
		lres = phost->OnSetCursor();
		if (lres)
			break;
		goto serv;

	case WM_CREATE:
		lres = phost->OnCreate((CREATESTRUCT*)lparam);
		break;
			   
    case WM_GETDLGCODE:	
		phost->_fInDialogBox = TRUE;
		lres |= DLGC_WANTARROWS | DLGC_WANTCHARS;
        break;

	////////////////////////System setting messages/////////////////////
	case WM_SETTINGCHANGE:
	case WM_SYSCOLORCHANGE:
		phost->OnSysColorChange();
		//	Need to update the edit controls colors!!!!
		goto serv;							// Notify text services that
											//  system colors have changed
											
	case EM_SETPALETTE:
		// Application is setting a palette for us to use.
		phost->_hpal = (HPALETTE) wparam;

		// Invalidate the window & repaint to reflect the new palette.
		InvalidateRect(hwnd, NULL, FALSE);
		break;

	/////////////////////////Misc. Messages/////////////////////////////////
	case WM_ENABLE:
		if(!wparam ^ phost->_fDisabled)
		{
			// Stated of window changed so invalidate it so it will
			// get redrawn.
			InvalidateRect(phost->_hwnd, NULL, TRUE);
			phost->SetScrollBarsForWmEnable(wparam);
		}
		phost->_fDisabled = !wparam;				// Set disabled flag		
											// Fall thru to WM_SYSCOLORCHANGE?

    case WM_STYLECHANGING:
		// Just pass this one to the default window proc
		goto defwndproc;
		break;

	case WM_STYLECHANGED:
		// FUTURE:
		//	We should support style changes after the control has been created
		//  to be more compatible with the system controls
		//
		// For now, we only interested in GWL_EXSTYLE Transparent mode changed.
		// This is to fix Bug 753 since Window95 is not passing us
		// the WS_EX_TRANSPARENT.
		// 
		lres = 1;
		if(GWL_EXSTYLE == wparam)
		{
			LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lparam;
			if(phost->IsTransparentMode() != (BOOL)(lpss->styleNew & WS_EX_TRANSPARENT))
			{
				phost->_dwExStyle = lpss->styleNew;
				((CTxtEdit *)phost->_pserv)->OnTxBackStyleChange(TRUE);

				// Return 0 to indicate we have handled this message
				lres = 0;
			}
		}
		break;

	case WM_SIZE:
		// Check if we have to recalculate the height of the listbox
		// Note if window is resized we will receive another WM_SIZE message
		// upon which the RecalcHeight will fail and we will proceed
		// normally
		if (phost->RecalcHeight(LOWORD(lparam), HIWORD(lparam)))
			break;
		phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		lres = phost->OnSize(hwnd, wparam, (int)LOWORD(lparam), (int)HIWORD(lparam));
		break;

	case WM_WINDOWPOSCHANGING:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		if(phost->TxGetEffects() == TXTEFFECT_SUNKEN)
			phost->OnSunkenWindowPosChanging(hwnd, (WINDOWPOS *) lparam);
		break;

	case WM_SHOWWINDOW:
		if ((phost->GetViewSize() == 0 || phost->_fLstType == CLstBxWinHost::kCombo) && wparam == 1)
		{
			// we need to do this because if we are part of a combo box
			// we won't get the size message because listbox may not be visible at time of sizing
			RECT rc;
			GetClientRect(hwnd, &rc);
			phost->_fVisible = 1;
			phost->RecalcHeight(rc.right, rc.bottom);
			
			//Since we may not get the WM_SIZE message for combo boxes we need to
			// do this in WM_SHOWWINDOW: bug fix #4080
			if (phost->_fLstType == CLstBxWinHost::kCombo)
			{
				phost->_pserv->TxSendMessage(WM_SIZE, SIZE_RESTORED, MAKELONG(rc.right, rc.bottom), NULL);
				phost->OnSize(hwnd, SIZE_RESTORED, rc.right, rc.bottom);
			}
		}

		hr = phost->OnTxVisibleChange((BOOL)wparam);
		break;

	case LB_SETTABSTOPS:
		msg = EM_SETTABSTOPS;
		goto serv;

	case WM_ERASEBKGND:
		lres = 1;
		break;

	case EM_SETPARAFORMAT:
		wparam = SPF_SETDEFAULT;
		goto serv;
		
	case EM_SETCHARFORMAT:
		wparam = SCF_ALL;	//wparam for this message should always be SCF_ALL
		goto serv;

	case WM_GETTEXT:
		GETTEXTEX gt;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gt );
		goto serv;

	case WM_GETTEXTLENGTH:
		GETTEXTLENGTHEX gtl;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gtl );
		goto serv;

#ifndef NOACCESSIBILITY
	case WM_GETOBJECT:	
		IUnknown* punk;
		phost->QueryInterface(IID_IUnknown, (void**)&punk);
		Assert(punk);
		lres = W32->LResultFromObject(IID_IUnknown, wparam, (LPUNKNOWN)punk);
		AssertSz(!FAILED((HRESULT)lres), "WM_GETOBJECT message FAILED\n");
		punk->Release();
		break;
#endif		

	default:
serv:
		hr = phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		if(hr == S_FALSE)
		{			
defwndproc:
			// Message was not processed by text services so send it
			// to the default window proc.
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		}
	}

	// Special border processing. The inset changes based on the size of the
	// defautl character set. So if we got a message that changes the default
	// character set, we need to update the inset.
	if ((msg == WM_SETFONT && wparam) || msg == EM_SETCHARFORMAT)
	{
		// need to recalculate the height of each item
		phost->ResizeInset();

		// need to resize the window to update internal window variables
		RECT rc;
		GetClientRect(phost->_hwnd, &rc);
		phost->RecalcHeight(rc.right, rc.bottom);		
	}
Exit:
	phost->Release();
	return lres;
}
												 

//////////////// CTxtWinHost Creation/Initialization/Destruction ///////////////////////
#ifndef NOACCESSIBILITY
/*
 *	CLstBxWinHost::OnNCCreate (hwnd, pcs)
 *
 *	@mfunc
 *		
 */
HRESULT CLstBxWinHost::QueryInterface(REFIID riid, void **ppv)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::QueryInterface");

  	if(riid == IID_IAccessible)
		*ppv = (IAccessible*)this;
    else if (riid == IID_IDispatch)
		*ppv = (IDispatch*)(IAccessible*)this;
    else if (IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown*)(IAccessible*)this;
    else
        return CTxtWinHost::QueryInterface(riid, ppv);

	AddRef();		
	return NOERROR;
        
}
#endif

/*
 *	CLstBxWinHost::OnNCCreate (hwnd, pcs)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message (see remain.c)
 */
LRESULT CLstBxWinHost::OnNCCreate(
	HWND hwnd,
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnNCCreate");

#if defined DEBUG && !defined(PEGASUS) 
	GdiSetBatchLimit(1);
#endif

	CLstBxWinHost *phost = new CLstBxWinHost();
	Assert(phost);
	if(!phost)
		return 0;
	
	if(!phost->Init(hwnd, pcs))					// Stores phost in associated
	{											//  window data
		Assert(FALSE);
		phost->Shutdown();
		delete phost;
		return FALSE;
	}
	return TRUE;
}

/*
 *	CLstBxWinHost::OnNCDestroy (phost)
 *
 *	@mfunc
 *		Static global method to handle WM_CREATE message
 *
 *	@devnote
 *		phost ptr is stored in window data (GetWindowLong())
 */
void CLstBxWinHost::OnNCDestroy(
	CLstBxWinHost *phost)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnNCDestroy");

	// We need to send WM_DELETEITEM messages for owner draw list boxes
	if (phost->_fOwnerDraw && phost->_nCount)
	{
		phost->LbDeleteItemNotify(0, phost->_nCount - 1);		
	}
	if (phost->_pwszSearch)
		delete phost->_pwszSearch;

	// set the combobox's listbox hwnd pointer to null so combo box won't try 
	// to delete the window twice
	if (phost->_pcbHost)
	{
		phost->_pcbHost->_hwndList = NULL;
		phost->_pcbHost->Release();
	}
	
	phost->Shutdown();
	phost->Release();
}

/*
 *	CLstBxWinHost::CLstBxWinHost()
 *
 *	@mfunc
 *		constructor
 */
CLstBxWinHost::CLstBxWinHost() : CTxtWinHost(), _nCount(0), _fSingleSel(0), _nidxSearch(0), 
	_pwszSearch(NULL), _pcbHost(NULL)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::CTxtWinHost");
#ifndef NOACCESSIBILITY
	_dwWinEvent = 0;				// Win Event code (ACCESSIBILITY use)
	_nAccessibleIdx = -1;			// Index (ACCESSIBILITY use)
#endif
}

/*
 *	CLstBxWinHost::~CLstBxWinHost()
 *
 *	@mfunc
 *		destructor
 */
CLstBxWinHost::~CLstBxWinHost()
{
}

/*
 *	CLstBxWinHost::Init (hwnd, pcs)
 *
 *	@mfunc
 *		Initialize this CLstBxWinHost
 */
BOOL CLstBxWinHost::Init(
	HWND hwnd,					//@parm Window handle for this control
	const CREATESTRUCT *pcs)	//@parm Corresponding CREATESTRUCT
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::Init");

	if(!pcs->lpszClass)
		return FALSE;
		
	// Set pointer back to CLstBxWinHost from the window
	if(hwnd)
		SetWindowLongPtr(hwnd, ibPed, (INT_PTR)this);
		
	_hwnd = hwnd;
	_fHidden = TRUE;
	
	if(pcs)
	{
		_hwndParent = pcs->hwndParent;
		_dwExStyle	= pcs->dwExStyle;
		_dwStyle	= pcs->style;

		CHECKSTYLE(_dwStyle);
		
		//	Internally WinNT defines a LBS_COMBOBOX to determine
		//	if the list box is part of a combo box.  So we will use
		//	the same flag and value!!
		if (_dwStyle & LBS_COMBOBOX)
		{
			AssertSz(pcs->hMenu == (HMENU)CB_LISTBOXID && pcs->lpCreateParams,
				"invalid combo box parameters");
			if (pcs->hMenu != (HMENU)CB_LISTBOXID || !pcs->lpCreateParams)
				return -1;
				
			_pcbHost = (CCmbBxWinHost*) pcs->lpCreateParams;
			_pcbHost->AddRef();
			_fLstType = kCombo;
			_fSingleSel = 1;
		}
		else
		{
			//	NOTE:
			//	  The order in which we check the style flags immulate
			//	WinNT's order.  So please verify with NT order before
			//	reaaranging order.

			//	determine the type of list box
			//if (_dwStyle & LBS_NOSEL)			//Not implemented but may be in the future
			//	_fLstType = kNoSel;
			//else
			_fSingleSel = 0;
			if (_dwStyle & LBS_EXTENDEDSEL)
				_fLstType = kExtended;
			else if (_dwStyle & LBS_MULTIPLESEL)
				_fLstType = kMultiple;
			else
			{
				_fLstType = kSingle;
				_fSingleSel = 1;
			}
		}

		_fNotify = ((_dwStyle & LBS_NOTIFY) != 0);

		if (!(_dwStyle & LBS_HASSTRINGS))
		{
			_dwStyle |= LBS_HASSTRINGS;
			SetWindowLong(_hwnd, GWL_STYLE, _dwStyle);
		}


		_fDisableScroll = 0;
		if (_dwStyle & LBS_DISABLENOSCROLL)
		{
			_fDisableScroll = 1;

			// WARNING!!!
			// ES_DISABLENOSCROLL is equivalent to LBS_NODATA
			// Since we don'w support LBS_NODATA this should be 
			// fine.  But in the event we do want to support this 
			// in the future we will have to override the
			// TxGetScrollBars member function and return the 
			// proper window style

			// set the equivalent ES style
			_dwStyle |= ES_DISABLENOSCROLL;
		}			

		_fNoIntegralHeight = ((_dwStyle & LBS_NOINTEGRALHEIGHT) != 0);
		_fOwnerDraw = ((_dwStyle & LBS_OWNERDRAWFIXED) != 0);
		_fSort = ((_dwStyle & LBS_SORT) != 0);
				
		//	We should always have verticle scroll & never horizontal scroll
		//_dwStyle |= ES_AUTOVSCROLL;
		_dwStyle &= ~(WS_HSCROLL);
				
		_fBorder = !!(_dwStyle & WS_BORDER);
		if(_dwExStyle & WS_EX_CLIENTEDGE)
			_fBorder = TRUE;

		// handle default disabled
		if(_dwStyle & WS_DISABLED)
			_fDisabled = TRUE;
	}

	// Create Text Services component
	if(FAILED(CreateTextServices()))
		return FALSE;

	_yInset = 0;
	_xInset = 0; //_xWidthSys / 2;

	// Shut-off the undo stack since listbox don't have undo's
	((CTxtEdit*)_pserv)->HandleSetUndoLimit(0);

	// Set alignment
	PARAFORMAT PF2;	
	PF2.dwMask = 0;

	if(_dwExStyle & WS_EX_RIGHT)
	{
		PF2.dwMask |= PFM_ALIGNMENT;
		PF2.wAlignment = PFA_RIGHT;	// right or center-aligned
	}
	
	if(_dwExStyle & WS_EX_RTLREADING)
	{
		PF2.dwMask |= PFM_RTLPARA;
		PF2.wEffects = PFE_RTLPARA;		// RTL reading order
	}

	if (PF2.dwMask)
	{
		PF2.cbSize = sizeof(PARAFORMAT2);
		//  tell text services
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF2, NULL);
	}

	// Tell textservices to select the entire background
	_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_EXTENDBACKCOLOR, SES_EXTENDBACKCOLOR, NULL);

	// disable ime for listbox
	_pserv->TxSendMessage(EM_SETEDITSTYLE, 0, SES_NOIME, NULL);

	// Tell textservices to turn-on auto font sizing
	_pserv->TxSendMessage(EM_SETLANGOPTIONS, 0, IMF_AUTOFONT | IMF_AUTOFONTSIZEADJUST | IMF_UIFONTS, NULL);

	// NOTE: 
	// It is important we call this after
	// ITextServices is created because this function relies on certain
	// variable initialization to be performed on the creation by ITextServices
	// At this point the border flag is set and so is the pixels per inch
	// so we can initalize the inset.  
	_rcViewInset.left = 0;
	_rcViewInset.bottom = 0;
	_rcViewInset.right = 0;
	_rcViewInset.top = 0;
	
	return TRUE;
}

/*
 *	CLstBxWinHost::OnCreate (pcs)
 *
 *	@mfunc
 *		Handle WM_CREATE message
 *
 *	@rdesc
 *		LRESULT = -1 if failed to in-place activate; else 0
 */
LRESULT CLstBxWinHost::OnCreate(
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnCreate");

	RECT rcClient;

	// sometimes, these values are -1 (from windows itself); just treat them
	// as zero in that case
	LONG cy = (pcs->cy < 0) ? 0 : pcs->cy;
	LONG cx = (pcs->cx < 0) ? 0 : pcs->cx;

	rcClient.top = pcs->y;
	rcClient.bottom = rcClient.top + cy;
	rcClient.left = pcs->x;
	rcClient.right = rcClient.left + cx;

	DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
	
	// init variables
	UpdateSysColors();
	_idCtrl = (UINT)(DWORD_PTR)pcs->hMenu;
	_fKeyMaskSet = 0;
	_fMouseMaskSet = 0;
	_fScrollMaskSet = 0;
	_nAnchor = _nCursor = -1;
	_nOldCursor = -1;
	_fMouseDown = 0;
	_nTopIdx = 0;
	_fSearching = 0;
	_nyFont = _nyItem = 1;
	_fNoResize = 1;
	_stvidx = -1;	
	InitWheelDelta();

	// Hide all scrollbars to start unless the disable scroll flag
	// is set
	if(_hwnd && !_fDisableScroll)
	{
		SetScrollRange(_hwnd, SB_VERT, 0, 0, TRUE);
		SetScrollRange(_hwnd, SB_HORZ, 0, 0, TRUE);

		dwStyle &= ~(WS_VSCROLL | WS_HSCROLL);
		SetWindowLong(_hwnd, GWL_STYLE, dwStyle);
	}
	
	// Notify Text Services that we are in place active
	if(FAILED(_pserv->OnTxInPlaceActivate(&rcClient)))
		return -1;	

	// Initially the font height is the item height	
	ResizeInset();
	Assert(_yInset == 0); // _yInset should be zero since listbox's doesn't have yinsets

	//We never want to display the selection or caret so tell textservice this
	_pserv->TxSendMessage(EM_HIDESELECTION, TRUE, FALSE, NULL);

	//Set the indents to 2 pixels like system listboxes	
	SetListIndent(2);
		
	_fNoResize = 0;
	_usIMEMode = ES_NOIME;
	return 0;
}

/*
 *	CLstBxWinHost::SetListIndent(int)
 *
 *	@mfunc
 *		Sets the left indent of a paragraph to the equivalent point value of nLeft, nLeft is
 *	given in device-coordinate pixels.
 *
 *	#rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::SetListIndent(int nLeft)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetListIndent");

	LRESULT lres;
	PARAFORMAT2 pf2;

	// tranlate the nLeft pixel value to point value
	long npt = MulDiv(nLeft, 1440, W32->GetXPerInchScreenDC());

	//format message struct
	pf2.cbSize = sizeof(PARAFORMAT2);
	pf2.dwMask = PFM_STARTINDENT;
	pf2.dxStartIndent = npt;

	// indent first line
	_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&pf2, &lres);

	return lres;
}

///////////////////////////////  Helper Functions  ////////////////////////////////// 
/*
 *	CLstBxWinHost::FindString(long, LPCTSTR, BOOL)
 *
 *	@mfunc
 *		This function checks a given index matches the search string
 *
 *	#rdesc
 *		BOOL = Match ? TRUE : FALSE
 */
BOOL CLstBxWinHost::FindString(long idx, LPCTSTR szSearch, BOOL bExact)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::FindString");

	Assert(_nCount);	

	// allocate string buffer into stack
	WCHAR sz[1024];
	WCHAR *psz = sz;
	
	if ( (wcslen(szSearch) + 3 /* 2 paragraphs and a NULL*/) > 1024)
		psz = new WCHAR[wcslen(szSearch) + 3 /* 2 paragraphs and a NULL*/];
	Assert(psz);

	if (psz == NULL)
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return FALSE;
	}

	// format the string the way we need it
	wcscpy(psz, szSearch);
	if (bExact)
		wcscat(psz, szCR);		
	BOOL bMatch = FALSE;	
	ITextRange *pRange = NULL;
	BSTR bstrQuery = SysAllocString(psz);
	if (!bstrQuery)
		goto CleanExit;

	if (psz != sz)
		delete [] psz;
	
	// Set starting position for the search
	long cp, cp2;
	if (!GetRange(idx, idx, &pRange))
	{
		SysFreeString(bstrQuery);
		return FALSE;
	}
	
	CHECKNOERROR(pRange->GetStart(&cp));
	CHECKNOERROR(pRange->FindTextStart(bstrQuery, 0, FR_MATCHALEFHAMZA | FR_MATCHKASHIDA | FR_MATCHDIAC, NULL));
	CHECKNOERROR(pRange->GetStart(&cp2));
	bMatch = (cp == cp2);

CleanExit:
	if (bstrQuery)
		SysFreeString(bstrQuery);
	if (pRange)
		pRange->Release();
	return bMatch;	
}

/*
 *	CLstBxWinHost::MouseMoveHelper(int)
 *
 *	@mfunc
 *		Helper function for the OnMouseMove function.  Performs
 *		the correct type of selection given an index to select
 *
 *	#rdesc
 *		void
 */
void CLstBxWinHost::MouseMoveHelper(int idx, BOOL bSelect)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::MouseMoveHelper");

	int ff = LBSEL_RESET | LBSEL_NEWCURSOR;
	if (bSelect)
		ff |= LBSEL_SELECT;
		
	switch (_fLstType)
	{
	case kSingle:
	case kCombo:
	case kExtended:										// perform the extended selection		
		if (LbSetSelection(_fLstType == kExtended ? _nAnchor : idx, idx, ff, idx, 0))
		{
#ifndef NOACCESSIBILITY
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);

			if (_fLstType == kCombo)
			{
				_dwWinEvent = bSelect ? EVENT_OBJECT_SELECTION : EVENT_OBJECT_SELECTIONREMOVE;
				_fNotifyWinEvt = TRUE;
				TxNotify(_dwWinEvent, NULL);
			}
#endif
		}

		break;			

	case kMultiple:
		// Just change the cursor position
		SetCursor(NULL, idx, TRUE);
#ifndef NOACCESSIBILITY
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);
#endif
		break;	
	}
}
	
/*
 *	CLstBxWinHost::ResizeInset
 *
 *	@mfunc	Recalculates rectangle for a font change.
 *
 *	@rdesc	None.
 */
void CLstBxWinHost::ResizeInset()
{
	// Create a DC
	HDC hdc = GetDC(_hwnd);
	// Get the inset information
	LONG xAveCharWidth = 0;
	LONG yCharHeight = GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
		W32->GetYPerInchScreenDC(), &xAveCharWidth, NULL, NULL);

	ReleaseDC(_hwnd, hdc);

	// update our internal font and item height information with the new font
	if (_nyItem == _nyFont)
	{
		// We need to set the new font height before calling set item height
		// so set item height will set exact height rather than space after
		// for the default paragraph
		_nyFont = yCharHeight;
		SetItemsHeight(yCharHeight, TRUE);
	}
	else		
		_nyFont = yCharHeight;
}


/*
 *	CLstBxWinHost::RecalcHeight(int, int)
 *
 *	@mfunc
 *		Resized the height so no partial text will be displayed
 *
 *	#rdesc
 *		BOOL = window has been resized ? TRUE : FALSE
 */
BOOL CLstBxWinHost::RecalcHeight(int nWidth, int nHeight)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::RecalcHeight");

	// NOTE: We should also exit if nWidth == 0 but PPT does some
	// sizing tests which we cause it to fail because before we
	// just exited when nWidth was 0. (bug fix #4196)
	// Check if any resizing should be done in the first place
	if (_fNoResize || !nHeight || IsIconic(_hwnd))
		return FALSE;
  	
	// get # of viewable items
	Assert(_yInset == 0);
	_nViewSize = max(1, (nHeight / max(_nyItem, 1)));
	
   	// Calculate the viewport
   	_rcViewport.left = 0;//(_fBorder) ? _xInset : 0;
   	_rcViewport.bottom = nHeight;
	_rcViewport.right = nWidth;
   	_rcViewport.top	= 0;
   	
	// bug fix don't do anything if the height is smaller then our font height
	if (nHeight <= _nyItem)
		return FALSE;

	if (_nyItem && (nHeight % _nyItem) && !_fNoIntegralHeight)
	{   	
		// we need to get the window rect before we can call SetWindowPos because
		// we have to include the scrollbar if the scrollbar is visible
		RECT rc;
		::GetWindowRect(_hwnd, &rc);

		// instead of worrying about the dimensions of the client edge and stuff we
		// figure-out the difference between the window size and the client size and add
		// that to the end of calculating the new height
		int nDiff = max(rc.bottom - rc.top - nHeight, 0);

		nHeight = (_nViewSize * _nyItem) + nDiff;
	
		// Resize the window
		SetWindowPos(_hwnd, HWND_TOP, 0, 0, rc.right - rc.left, nHeight,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOSENDCHANGING);
		return TRUE;
	}
	else
	{
	    // bug fix #6011
	    // we need to force the display to update the width since it doesn't do it on
	    // WM_SIZE
	    _sWidth = nWidth;
	    _pserv->OnTxPropertyBitsChange(TXTBIT_EXTENTCHANGE, TXTBIT_EXTENTCHANGE);

        // We may need to adjust the top index if suddenly the viewsize becomes larger
        // and causes empty space to be displayed at the bottom
        int idx = GetTopIndex();
	    if ((GetCount() - max(0, idx)) < _nViewSize)
	        idx = GetCount() - _nViewSize;
		
		//bug fix #4374
		// We need to make sure our internal state is in sync so update the top index
		// based on the new _nViewSize		
		SetTopViewableItem(max(0, idx));
	}
	return FALSE;	
}

/*
 *	CLstBxWinHost::SortInsertList(WCHAR* pszDst, WCHAR* pszSrc)
 *
 *	@mfunc
 *		inserts a list of strings rather than one at a time with addstring
 *
 *	#rdesc
 *		int = amount of strings inserted;
 */
 int CLstBxWinHost::SortInsertList(WCHAR* pszDst, WCHAR* pszSrc)
 {
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SortInsertList");
	 
 	Assert(pszSrc != NULL);
 	Assert(pszDst != NULL); 	
 	const int ARRAY_DEFAULT = 256;
 	
 	//calculate the amount of strings to be inserted
 	CHARSORTINFO rg[ARRAY_DEFAULT];
 	int nMax = ARRAY_DEFAULT;
 	int nLen = wcslen(pszSrc);
 	CHARSORTINFO* prg = rg;
 	memset(rg, 0, sizeof(rg));
 	
 	//insert first item in list to head or array
 	prg[0].str = pszSrc;
 	int i = 1;

 	// go through store strings into array and replace <CR> with NULL
 	WCHAR* psz = nLen + pszSrc - 1;	//start at end of list 	

	int nSz = 0;
	while (psz >= pszSrc)
	{		
	 	if (*psz == *szCR)
	 	{
	 		// Check if we need to allocate memory since we hit the maximum amount
	 		// allowed in array
	 		if (i == nMax)
	 		{
	 			int nSize = nMax + ARRAY_DEFAULT;
	 			CHARSORTINFO* prgTemp = new CHARSORTINFO[nSize];

	 			// Check if memory allocation failed
	 			Assert(prgTemp);
	 			if (!prgTemp)
	 			{
	 				if (prg != rg)
	 					delete [] prg;
	 					
	 				TxNotify((unsigned long)LBN_ERRSPACE, NULL);
	 				return LB_ERR;
	 			}

				// copy memory from 1 array to the next
				memcpy(prgTemp, prg, sizeof(CHARSORTINFO) * nMax);

	 			// delete any previously allocated memory
	 			if (prg != rg)
	 				delete [] prg;

				// set pointers and max to new values
	 			prg = prgTemp;
	 			nMax = nSize;
	 		}
	 		
	 		// record position of string into array
		 	prg[i].str = psz + 1;
		 	prg[i].sz = nSz;
		 	i++;
		 	nSz = 0;
		}
		else
			nSz++;
			
		psz--;		
	}
	prg[0].sz = nSz;	// update the size of first index since we didn't do it before
	
	i--; // set i to last valid index

 	//now sort the array of items
 	QSort(prg, 0, i);

	//create string list with the newly sorted list
	WCHAR* pszOut = pszDst;
	for (int j = 0; j <= i; j++)
	{
		memcpy(pszOut, (prg + j)->str, (prg + j)->sz * sizeof(WCHAR));
		pszOut = pszOut + (prg + j)->sz;
		*pszOut++ = L'\r';
 	}
	*(--pszOut) = L'\0';

	// delete any previously allocated memory
	if (prg != rg)
	 	delete [] prg;

	return ++i;
 } 


/*
 *	CLstBxWinHost::QSort(CHARSORTINFO rg[], int nStart, int nEnd)
 *
 *	@mfunc
 *		recursively quick sorts a given list of strings
 *
 *	#rdesc
 *		int = SHOULD ALWAYS RETURN TRUE;
 */
int CLstBxWinHost::QSort(CHARSORTINFO rg[], int nStart, int nEnd)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::QSort");
	
	// it's important these values are what they are since we use < and >
	Assert(CSTR_LESS_THAN == 1);
	Assert(CSTR_EQUAL == 2);
	Assert(CSTR_GREATER_THAN == 3);

	if (nStart >= nEnd)
		return TRUE;

	// for statisical efficiency lets use the item in the middle of the array for 
	// the sentinal	
	int mid = (nStart + nEnd) / 2;
	CHARSORTINFO tmp = rg[mid];
	rg[mid] = rg[nEnd];
	rg[nEnd] = tmp;


	int x = nStart;
	int y = nEnd - 1;

	WCHAR* psz = rg[nEnd].str;
	int nSz = rg[nEnd].sz;	
	for(;;)
	{	
		while ((x < nEnd) && CompareStringWrapper(LOCALE_USER_DEFAULT, NORM_IGNORECASE, rg[x].str, rg[x].sz, 
			   psz, nSz) == CSTR_LESS_THAN)
			   x++;

		while ((y > x) && CompareStringWrapper(LOCALE_USER_DEFAULT, NORM_IGNORECASE, rg[y].str, rg[y].sz, 
			   psz, nSz) == CSTR_GREATER_THAN)
			   y--;

		// swap elements
		if (x >= y)
			break;

		//if we got here then we need to swap the indexes
		tmp = rg[x];
		rg[x] = rg[y];
		rg[y] = tmp;

		// move to next index
		x++;
		y--;
	}
	tmp = rg[x];
	rg[x] = rg[nEnd];
	rg[nEnd] = tmp;

	QSort(rg, nStart, x - 1);
	QSort(rg, x + 1, nEnd);

	return TRUE;
}

/*
 *	CLstBxWinHost::CompareIndex(LPCTSTR, int)
 *
 *	@mfunc
 *		Recursive function which returns the insertion index of a sorted list
 *
 *	#rdesc
 *		int = position to insert string
 */
int CLstBxWinHost::CompareIndex(LPCTSTR szInsert, int nIndex)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::CompareIndex");
	Assert(0 <= nIndex && nIndex < _nCount);
	
	// Get the string at a given index
	// compare the string verses the index
	ITextRange* pRange;
	if (!GetRange(nIndex, nIndex, &pRange))
		return -1;

	// Exclude the paragraph character at the end
	long lcid;
	if (NOERROR != pRange->MoveEnd(tomCharacter, -1, NULL))
	{
		pRange->Release();
		return -1;
	}

	// we need to get the locale for the comparison
	// we will just use the locale of the string we want to compare with
	ITextFont* pFont;
	if (NOERROR != pRange->GetFont(&pFont))
	{
		pRange->Release();
		return -1;
	}
	
	// UNDONE:
	//	move the lcid stuff to be part of the initialization
	BSTR bstr;
	int nRet;
	CHECKNOERROR(pFont->GetLanguageID(&lcid));
	CHECKNOERROR(pRange->GetText(&bstr));
	
	if (!bstr)
		nRet = CSTR_GREATER_THAN;
	else if (!szInsert || !*szInsert)
	    nRet = CSTR_LESS_THAN;
	else
	{
		nRet = CompareString(lcid, NORM_IGNORECASE, szInsert, wcslen(szInsert), 
								bstr, wcslen(bstr));
 		SysFreeString(bstr);
	}
 	pFont->Release();
 	pRange->Release();
 	return nRet;

CleanExit:
 	Assert(FALSE);
 	pFont->Release();
 	pRange->Release();
 	return -1;
}

/*
 *	CLstBxWinHost::GetSortedPosition(LPCTSTR, int, int)
 *
 *	@mfunc
 *		Recursive function which returns the insertion index of a sorted list
 *
 *	#rdesc
 *		int = position to insert string
 */
int CLstBxWinHost::GetSortedPosition(LPCTSTR szInsert, int nStart, int nEnd)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetSortedPosition");

	Assert(nStart <= nEnd);
	
	// Start at the middle of the list
	int nBisect = (nStart + nEnd) / 2;
	int fResult = CompareIndex(szInsert, nBisect);
	if (fResult == CSTR_LESS_THAN)
	{
		if (nStart == nBisect)
			return nBisect;
		else
			return GetSortedPosition(szInsert, nStart, nBisect - 1); // [nStart, nBisect)
	}
	else if (fResult == CSTR_GREATER_THAN)
	{
		if (nEnd == nBisect)
			return nBisect + 1;
		else
			return GetSortedPosition(szInsert, nBisect + 1, nEnd);   // (nBisect, nStart]
	}
	else /*fResult == 0 (found match)*/
		return nBisect;
}

/*
 *	CLstBxWinHost::SetScrollInfo
 *
 *	@mfunc	Set scrolling information for the scroll bar.
 */
void CLstBxWinHost::SetScrollInfo(
	INT fnBar,			//@parm	Specifies scroll bar to be updated
	BOOL fRedraw)		//@parm whether redraw is necessary
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetScrollInfo");

	Assert(_pserv);

	// Call back to the control to get the parameters	
	if(fnBar == SB_VERT)
	{
		// Bug Fix #4913
		// if the scrollbar is disabled and count is less than the view size
		// then there is nothing to do so just exit out		
		if (GetCount() <= _nViewSize)
		{
			if (_fDisableScroll)
			{
				// Since listboxes changes height according to its content textservice
				// might of turned-on the scrollbar during an insert string.  Make sure
				// the scrollbar is disabled
				TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
			}
			else
				TxShowScrollBar(SB_VERT, FALSE);
			return;
		}
		else
			TxEnableScrollBar(SB_VERT, ESB_ENABLE_BOTH);

		// Set up the basic structure for the call
		SCROLLINFO si;
		si.cbSize = sizeof(SCROLLINFO);
		si.fMask = SIF_ALL;
		RECT rc;
		TxGetClientRect(&rc);
		
		// For owner draw cases we have to set the scroll positioning
		// ourselves		
		if (_fOwnerDraw)
		{
			Assert(GetCount() >= 0);

			// We don't do anything here if 
			// 1) item height is smaller than font height 
			// 2) count is less than _nViewSize
			if ((_nyItem < _nyFont) && GetCount() <= _nViewSize)
			{
				if (!_fDisableScroll)
					TxShowScrollBar(SB_VERT, FALSE);				
				return;
			}
		
			si.nMin = 0;
			si.nMax = _nyItem * GetCount();
			si.nPos = _nyItem * max(GetTopIndex(), 0);
			
		}
		else
			_pserv->TxGetVScroll((LONG *) &si.nMin, (LONG *) &si.nMax, 
				(LONG *) &si.nPos, (LONG *) &si.nPage, NULL);
		
		// need to take care of cases where items are partially exposed
		if (si.nMax)
		{			
			si.nPage = rc.bottom;	//our scrollbar range is based on pixels so just use the 
									//height of the window for the page size
			si.nMax += (rc.bottom % _nyItem);

			// We need to decrement the max by one so maximum scroll pos will match
			// what the listbox should be the maximum value
			si.nMax--;
		}
			
		// Do the call
		::SetScrollInfo(_hwnd, fnBar, &si, fRedraw);
	}	
}

/* 
 *	CLstBxWinHost::TxGetScrollBars (pdwScrollBar)
 *
 *	@mfunc
 *		Get Text Host's scroll bars supported.
 *
 *	@rdesc
 *		HRESULT = S_OK
 *
 *	@comm
 *		<p pdwScrollBar> is filled with a boolean combination of the 
 *		window styles related to scroll bars.  Specifically, these are:
 *
 *			WS_VSCROLL	<nl>
 *			WS_HSCROLL	<nl>
 *			ES_AUTOVSCROLL	<nl>
 *			ES_AUTOHSCROLL	<nl>
 *			ES_DISABLENOSCROLL	<nl>
 */
HRESULT CLstBxWinHost::TxGetScrollBars(
	DWORD *pdwScrollBar) 	//@parm Where to put scrollbar information
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxGetScrollBars");

	*pdwScrollBar =  _dwStyle & (WS_VSCROLL | ((_fDisableScroll) ?  ES_DISABLENOSCROLL : 0));
	return NOERROR;
}

/*
 *	CLstBxWinHost::TxGetEffects()
 *
 *	@mfunc
 *		Indicates if a sunken window effect should be drawn
 *
 *	#rdesc
 *		HRESULT = (_fBorder) ? TXTEFFECT_SUNKEN : TXTEFFECT_NONE
 */
TXTEFFECT CLstBxWinHost::TxGetEffects() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::TxGetEffects");

	return (_fBorder) ? TXTEFFECT_SUNKEN : TXTEFFECT_NONE;
}

/* 
 *	CLstBxWinHost::TxNotify (iNotify,	pv)
 *
 *	@mfunc
 *		Notify Text Host of various events.  Note that there are
 *		two basic categories of events, "direct" events and 
 *		"delayed" events.  All listbox notifications are post-action
 *
 *
 *	@rdesc	
 *		S_OK - call succeeded <nl>
 *		S_FALSE	-- success, but do some different action
 *		depending on the event type (see below).
 *
 *	@comm
 *		The notification events are the same as the notification
 *		messages sent to the parent window of a listbox window.
 *
 *		<LBN_DBLCLK> user double-clicks an item in teh list box
 *
 *		<LBN_ERRSPCAE> The list box cannot allocate enough memory to 
 *		fulfill a request
 *
 *		<LBN_KILLFOCUS> The list box loses the keyboard focus
 *
 *		<LBN_CANCEL> The user cancels te selection of an item in the list
 *		box
 *
 *		<LBN_SELCHANGE> The selection in a list box is about to change
 *
 *		<LBN_SETFOCUS> The list box receives the keyboard focus
 *
 */
HRESULT CLstBxWinHost::TxNotify(
	DWORD iNotify,		//@parm	Event to notify host of.  One of the
						//		EN_XXX values from Win32, e.g., EN_CHANGE
	void *pv)			//@parm In-only parameter with extra data.  Type
						//		dependent on <p iNotify>
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxNotify");

	HRESULT	hr = NOERROR;
	
	// Filter-out all the messages except Listbox notification messages

	// If _fNotifyWinEvt is true, we only need to do NotifyWinEvent
	if (_fNotify && !_fNotifyWinEvt)		// Notify parent?
	{
		Assert(_hwndParent);
		switch (iNotify)
		{		
			case LBN_DBLCLK:
			case LBN_ERRSPACE:
			case LBN_KILLFOCUS:
			case LBN_SELCANCEL:
			case LBN_SELCHANGE:
			case LBN_SETFOCUS:
				hr = SendMessage(_hwndParent, WM_COMMAND, 
							GET_WM_COMMAND_MPS(_idCtrl, _hwnd, iNotify));						
		}
	}

	_fNotifyWinEvt = 0;

#ifndef NOACCESSIBILITY
	DWORD	dwLocalWinEvent = _dwWinEvent;
	int		nLocalIdx = _nAccessibleIdx;
	_dwWinEvent = 0;
	if (nLocalIdx == -1)
		nLocalIdx = _nCursor+1;
	_nAccessibleIdx = -1;
	if (iNotify == LBN_SELCHANGE || dwLocalWinEvent)
		W32->NotifyWinEvent(dwLocalWinEvent ? dwLocalWinEvent : EVENT_OBJECT_SELECTION, _hwnd, _idCtrl, nLocalIdx);

#endif
	return hr;
}


/*
 *	CLstBxWinHost::TxGetPropertyBits(DWORD, DWORD *)
 *
 *	@mfunc
 *		returns the proper style.  This is a way to fool the edit 
 *		control to behave the way we want it to
 *
 *	#rdesc
 *		HRESULT = always NOERROR
 */
 HRESULT CLstBxWinHost::TxGetPropertyBits(DWORD dwMask, DWORD *pdwBits)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::TxGetPropertyBits");

	// Note: the rich edit host will never set TXTBIT_SHOWACCELERATOR or
	// TXTBIT_SAVESELECTION. Those are currently only used by forms^3 host.

	// This host is always rich text.
	*pdwBits = (TXTBIT_RICHTEXT | TXTBIT_MULTILINE | TXTBIT_HIDESELECTION | 
				TXTBIT_DISABLEDRAG | TXTBIT_USECURRENTBKG) & dwMask;
	
	return NOERROR;
}

/* 
 *	CLstBxWinHost::TxShowScrollBar (fnBar, fShow)
 *
 *	@mfunc
 *		Shows or Hides scroll bar in Text Host window 
 *
 *	@rdesc
 *		TRUE on success, FALSE otherwise
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CLstBxWinHost::TxShowScrollBar(
	INT  fnBar, 		//@parm	Specifies scroll bar(s) to be shown or hidden
	BOOL fShow)			//@parm	Specifies whether scroll bar is shown or hidden
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxShowScrollBar");

	// There maybe cases where the item height is smaller than the font size
	// which means the notifications from ITextServices is wrong because
	// it uses the wrong line height.  We will use the following case
	// 1a) if _nyItem >= _nyFont OR
	// 1b) if window style is LBS_DISABLESCROLL OR
	// 1c) We are showing the scrollbar w/ current count greater than viewsize OR
	// 1d) We are hiding the scrollbar w/ current count <= viewsize
	Assert(fShow == TRUE || fShow == FALSE);
	if (_nyItem >= _nyFont || _fDisableScroll || fShow == (GetCount() > _nViewSize))
		return CTxtWinHost::TxShowScrollBar(fnBar, fShow);
	return FALSE;
}

/* 
 *	CLstBxWinHost::TxEnableScrollBar (fuSBFlags, fuArrowflags)
 *
 *	@mfunc
 *		Enables or disables one or both scroll bar arrows 
 *		in Text Host window.
 *
 *	@rdesc
 *		If the arrows are enabled or disabled as specified, the return 
 *		value is TRUE. If the arrows are already in the requested state or an 
 *		error occurs, the return value is FALSE. 
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.	
 */
BOOL CLstBxWinHost::TxEnableScrollBar (
	INT fuSBFlags, 		//@parm Specifies scroll bar type	
	INT fuArrowflags)	//@parm	Specifies whether and which scroll bar arrows
						//		are enabled or disabled
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxEnableScrollBar");

	// There may be cases where the item height is smaller than the font size
	// which means the notifications from ITextServices is wrong.  We have to perform
	// some manual checking for owner draw listboxes. The following cases will be valid
	// 1. If the listbox is NOT owner draw
	// 2. If the message is to disable the control
	// 3. If the count is greater than the viewsize
	if (!_fOwnerDraw || ESB_ENABLE_BOTH != fuArrowflags || GetCount() > _nViewSize)
		return CTxtWinHost::TxEnableScrollBar(fuSBFlags, fuArrowflags);
	return FALSE;
}


/*
 *	CLstBxWinHost::SetItemsHeight(int, BOOL)
 *
 *	@mfunc
 *		Sets the items height for all items
 *
 *	#rdesc
 *		int = number of paragraphs whose fontsize has been changed
 */
 int CLstBxWinHost::SetItemsHeight(int nHeight, BOOL bUseExact)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetItemsHeight");
	
 	// Calculate the new size in points
 	long nptNew = MulDiv(nHeight, 1440, W32->GetYPerInchScreenDC());
 	long nptMin = MulDiv(_nyFont, 1440, W32->GetYPerInchScreenDC());

	// NOTE:
	// This diverges from what the system list box does but there isn't a way
	// to set the height of a item to smaller than what the richedit will allow and
	// is not ownerdraw.  If it is owner draw make sure our height is not zero
	if (((nptNew < nptMin && !_fOwnerDraw) || nHeight <= 0) && !bUseExact)
		nptNew = nptMin;

	// Start setting the new height
	Freeze();
	long nPt;
	PARAFORMAT2 pf2;
	pf2.cbSize = sizeof(PARAFORMAT2);

	if (bUseExact)
	{
		pf2.dwMask = PFM_LINESPACING;
		pf2.bLineSpacingRule = 4;
		pf2.dyLineSpacing = nPt = nptNew;
	}
	else
	{		
		pf2.dwMask = PFM_SPACEAFTER;
		pf2.dySpaceAfter = max(nptNew - nptMin, 0);
		nPt = pf2.dySpaceAfter + nptMin;
	}

	// Set the default paragraph format
	LRESULT lr;
	_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (WPARAM)&pf2, &lr);
	
	// set the item height
	if (lr)
		_nyItem = (_fOwnerDraw && nHeight > 0) ? nHeight : 
					MulDiv(nPt, W32->GetYPerInchScreenDC(), 1440);

	Unfreeze();
	return lr;
 }

/*
 *	CLstBxWinHost::UpdateSysColors()
 *
 *	@mfunc
 *		update the system colors in the event they changed or for initialization
 *		purposes
 *
 *	#rdesc
 *		<none>
 */
 void CLstBxWinHost::UpdateSysColors()
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::UpdateSysColors");

 	// Update the system colors
 	_crDefBack = ::GetSysColor(COLOR_WINDOW);
 	_crSelBack = ::GetSysColor(COLOR_HIGHLIGHT);
 	_crDefFore = ::GetSysColor(COLOR_WINDOWTEXT);
 	_crSelFore = ::GetSysColor(COLOR_HIGHLIGHTTEXT); 	
 }
 
/*
 *	CLstBxWinHost::UpdateViewArea()
 *
 *	@mfunc
 *		Gets the height of each item and keeps an internal record of it
 *
 *	#rdesc
 *		<none>
 */
 void CLstBxWinHost::UpdateViewArea()
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::UpdateViewArea");

 	Assert(_pserv);

	_nyItem = 1;	// set to default value for right now
	
 	//Set the range to the first item
	ITextRange* pRange;
	if (NOERROR != ((CTxtEdit*)_pserv)->Range(0, 0, &pRange))
		return;
	Assert(pRange);
	
	// get rect of window
	TxGetClientRect(&_rcViewport);

	// calculate the height of each item
	long x;
	CHECKNOERROR(pRange->GetPoint(tomStart | TA_BOTTOM | TA_LEFT, &x, &_nyItem));

	_nyItem -= _rcViewport.top;		
	
 CleanExit:
 	pRange->Release();	
 	return;
 }


/*
 *	CLstBxWinHost::SetCursor(HDC, int, BOOL)
 *
 *	@mfunc
 *		Sets the cursor position, if it's valid and draws the focus rectangle if
 *		the control has focus.  The BOOL is used to determine if the previous
 *		cursor drawing needs to be removed
 *
 *	#rdesc
 *		<none>
 */
 void CLstBxWinHost::SetCursor(HDC hdc, int idx, BOOL bErase)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetCursor");
 	
 	Assert(idx >= -2 && idx < _nCount);
	
	// Get the hdc if it wasn't passed in
	BOOL bReleaseDC = (hdc == NULL);
 	if (bReleaseDC)
 		hdc = TxGetDC();
	Assert(hdc);
	
	RECT rc;
	// don't draw outside the client rect draw the rectangle
	TxGetClientRect(&rc);
	IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
	
 	// Check if we have to remove the previous position
 	if ((idx != _nCursor && _fFocus && idx >= -1) || bErase)
 	{	
 		if (_fOwnerDraw)
 			LbDrawItemNotify(hdc, _nCursor, ODA_FOCUS, (IsSelected(max(_nCursor, 0)) ? ODS_SELECTED : 0));
 		else if (IsItemViewable(max(0, _nCursor)))
		{
	 		LbGetItemRect(max(_nCursor, 0), &rc);
	 		::DrawFocusRect(hdc, &rc);
	 	}
 	}

	// special flag meaning to set the cursor to the top index
	// if there are items in the listbox
	if (idx == -2)
	{
		if (GetCount())
		{
			idx = max(_nCursor, 0);
			if (!IsItemViewable(idx))
				idx = GetTopIndex();
		}
		else
			idx = -1;
	}

	_nCursor = idx;

	// Only draw the focus rect if the cursor item is
	// visible in the list box
	if (_fFocus)
	{
		if (_fOwnerDraw)
 			LbDrawItemNotify(hdc, max(0, _nCursor), ODA_FOCUS, ODS_FOCUS | (IsSelected(max(0, _nCursor)) ? ODS_SELECTED : 0));
 		else if (IsItemViewable(max(0, idx)))
		{
			// Now draw the rectangle
	 		LbGetItemRect(max(0,_nCursor), &rc);
	 		::DrawFocusRect(hdc, &rc);
	 	}
	}
	
 	if (bReleaseDC)
 		TxReleaseDC(hdc);
 }

/*
 *	CLstBxWinHost::InitSearch()
 *
 *	@mfunc
 *		Sets the array to its initial state
 *
 *	#rdesc
 *		<none>
 */
 void CLstBxWinHost::InitSearch()
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::InitSearch");

	_fSearching = 0;
 	_nidxSearch = 0;
 	if (_pwszSearch)
 		*_pwszSearch = 0;
 }
 
/*
 *	CLstBxWinHost::PointInRect(const POINT*)
 *
 *	@mfunc
 *		Determines if the given point is inside the listbox windows rect
 *		The point parameter should be in client coordinates.
 *
 *	#rdesc
 *		BOOL = inside listbox window rectangle ? TRUE : FALSE
 */
 BOOL CLstBxWinHost::PointInRect(const POINT * ppt)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::PointInRect");
 	Assert(ppt);
 	
 	RECT rc;
	::GetClientRect(_hwnd, &rc);
	return PtInRect(&rc, *ppt);
 }

/*
 *	CLstBxWinHost::GetItemFromPoint(POINT*)
 *
 *	@mfunc
 *		Retrieves the nearest viewable item from a passed in point.
 *		The point should be in client coordinates.
 *
 *	#rdesc
 *		int = item which is closest to the given in point, -1 if there 
 *			  are no items in the list box
 */
 int CLstBxWinHost::GetItemFromPoint(const POINT * ppt)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetItemFromPoint");

	// perform error checking first
	if (_nCount == 0)
		return -1;

	int y = (signed short)ppt->y;

 	// make sure y is in a valid range
 	if (y < _rcViewport.top)
 		y = 0;
 	else if (y > _rcViewport.bottom)
 		y = _rcViewport.bottom - 1;

	//need to factor in the possibility an item may not fit entirely into the window view
	Assert(_nyItem);
	int idx = GetTopIndex() + (int)(max(0,(y - 1)) / max(1,_nyItem));

	Assert(IsItemViewable(idx));
 	return (idx < _nCount ? idx : _nCount - 1);
 }
 
/*
 *	CLstBxWinHost::ResetContent()
 *
 *	@mfunc
 *		Deselects all the items in the list box
 *
 *	#rdesc
 *		BOOL = If everything went fine ? TRUE : FALSE
 */
 BOOL CLstBxWinHost::ResetContent()
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::ResetContent");

	Assert(_fOwnerDraw == 0);
	
	// lets try to be smart about reseting the colors by only select a range
	// from the first selection found to the last selection found

	int nStart = _nCount - 1;
	int nEnd = -1;
 	for (int i = 0; i < _nCount; i++)
 	{
		if (_rgData[i]._fSelected)
		{
			_rgData[i]._fSelected = 0;

			if (nStart > i)
				nStart = i;
			if (nEnd < i)
				nEnd = i;
		}
 		
 	}

	Assert(nStart <= nEnd || ((nStart == _nCount - 1) && (nEnd == -1)));
	if (nStart > nEnd)
		return TRUE;

 	return (_nCount > 0) ? SetColors((unsigned)tomAutoColor, (unsigned)tomAutoColor, nStart, nEnd) : FALSE;
 }
 
/*
 *	CLstBxWinHost::GetString(long, PWCHAR)
 *
 *	@mfunc
 *		Retrieve the string at the requested index.  PWSTR can be null
 *		if only the text length is requires
 *
 *	#rdesc
 *		long = successful ? length of string : -1
 */
 long CLstBxWinHost::GetString(long nIdx, PWCHAR szOut)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetString");

 	Assert(0 <= nIdx && nIdx < _nCount);
 	if (nIdx < 0 || _nCount <= nIdx)
 		return -1;

	long l = -1;
	long lStart;
	long lEnd;
 	ITextRange* pRange;
 	BSTR bstr;
 	if (!GetRange(nIdx, nIdx, &pRange))
 		return -1;
 		
 	// Need to move one character to the left to unselect the paragraph marker.
 	Assert(pRange);
 	CHECKNOERROR(pRange->MoveEnd(tomCharacter, -1, &lEnd));
	CHECKNOERROR(pRange->GetStart(&lStart));
	CHECKNOERROR(pRange->GetEnd(&lEnd));

	// Get the string
	if (szOut)
	{
		if (_dwStyle & LBS_HASSTRINGS)
		{
			CHECKNOERROR(pRange->GetText(&bstr));
			if (bstr)
			{
				wcscpy(szOut, bstr);
				SysFreeString(bstr);
			}
			else
				wcscpy(szOut, L"");	// we got an empty string!
		}
		else
			(*(long*)szOut) = GetData(nIdx);
	}
	l = lEnd - lStart;

CleanExit:
 	pRange->Release();
 	return l;
 }
 
/*
 *	CLstBxWinHost::InsertString(long, LPCTSTR)
 *
 *	@mfunc
 *		Insert the string at the requested location.  If the
 *		requested index is larger than _nCount then the function
 *		will fail.  The string is inserted with CR appended to
 *		to the front and back of the string
 *
 *	#rdesc
 *		BOOL = successfully inserted ? TRUE : FALSE
 */
 BOOL CLstBxWinHost::InsertString(long nIdx, LPCTSTR szInsert)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::InsertString");

	Assert(szInsert);
	Assert(0 <= nIdx && nIdx <= _nCount);

	// allocate string buffer into stack
	WCHAR sz[1024];
	WCHAR *psz = sz;
	
	if ( (wcslen(szInsert) + 3 /* 2 paragraphs and a NULL*/) > 1024)
		psz = new WCHAR[wcslen(szInsert) + 3 /* 2 paragraphs and a NULL*/];
	Assert(psz);
	
	if (psz == NULL)
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return FALSE;
	}
	
	*psz = NULL;
	if (nIdx == _nCount && _nCount)
		wcscpy(psz, szCR);

	// copy string and add <CR> at the end
	wcscat(psz, szInsert);

	// don't add the carriage return if the entry point is the end
	if (nIdx < _nCount)
		wcscat(psz, szCR);			
	
 	BOOL bRet = FALSE;
 	ITextRange * pRange = NULL;
	int fFocus = _fFocus;
	long idx = nIdx;
	BSTR bstr = SysAllocString(psz);
	if (!bstr)
		goto CleanExit;
	Assert(bstr);

	if (psz != sz)
		delete [] psz;
	
 	// Set the range to the point where we want to insert the string 	
	
	// make sure the requested range is a valid one
	if (nIdx == _nCount)
		idx = max(idx - 1, 0);

 	if (!GetRange(idx, idx, &pRange))
 	{
 		SysFreeString(bstr);
 		return FALSE;
 	}

 	// Collapse the range to the start if insertion is in the middle or top
	// of list, collapse range to the end if we are inserting at the end of the list
	CHECKNOERROR(pRange->Collapse((idx == nIdx)));

	// Need to assume the item was successfully added because during SetText TxEnable(show)Scrollbar
	// gets called which looks at the count to determine if we should display the scroll bar
	_nCount++;

	//bug fix #5411
	// Check if we have focus, if so we need to remove the focus rect first and update the cursor positions	
	_fFocus = 0;
	SetCursor(NULL, (idx > GetCursor() || GetCursor() < 0) ? GetCursor() : GetCursor() + 1, fFocus);
	_fFocus = fFocus;


	//For ownerdraw cases where the item height is less than the font we need to manually
	//enable the scrollbar if we need the scrollbar and the scrollbar is disabled.
	if ((_nyItem < _nyFont) && (_fDisableScroll) && (_nCount - 1 == _nViewSize))
		TxEnableScrollBar(SB_VERT, ESB_ENABLE_BOTH);

#ifdef _DEBUG
	if (bstr && wcslen(bstr))
		Assert(FALSE);
#endif

	if (NOERROR != (pRange->SetText(bstr)))	
	{
		_nCount--;
		
		//Unsuccessful in adding the string so disable the scrollbar if we enabled it
		if ((_nyItem < _nyFont) && (_fDisableScroll) && (_nCount == _nViewSize))
			TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
			
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		goto CleanExit;
	} 

	//We need to update the top index after a string is inserted
	if (idx < GetTopIndex())
		_nTopIdx++;
		
	bRet = TRUE;
 	
CleanExit:
	if (bstr)
 		SysFreeString(bstr);
	if (pRange)
 		pRange->Release();
 	return bRet;
 }

/*
 *	BOOL CLstBxWinHost::RemoveString(long, long)
 *
 *	@mfunc
 *		Prevents TOM from drawing
 *
 *	#rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::RemoveString(long nStart, long nEnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::RemoveString");

	Assert(nStart <= nEnd);
	Assert(nStart < _nCount && nEnd < _nCount);

	// Remove item from richedit
	Freeze();
	ITextRange* pRange;
	if (!GetRange(nStart, nEnd, &pRange))
	{
		Unfreeze();
		return FALSE;
	}
	long l;
	
	// Since we can't erase the last paragraph marker we will erase
	// the paragraph marker before the item if it's not the first item
	HRESULT hr;
	if (nStart != 0)
	{
		hr = pRange->MoveStart(tomCharacter, -1, &l);
		Assert(hr == NOERROR);
		hr = pRange->MoveEnd(tomCharacter, -1, &l);
		Assert(hr == NOERROR);
	}

	if (NOERROR != pRange->Delete(tomCharacter, 0, &l) && _nCount > 1)
	{
		Unfreeze();
		pRange->Release();
		return FALSE;
	}
	pRange->Release();
	int nOldCt = _nCount;
	_nCount -= (nEnd - nStart) + 1;

	// Because we delete the paragraph preceeding the item
	// rather than following the item we need to update 
	// the paragraph which followed the item. bug fix #4074	
	long nFmtPara = max(nStart -1, 0);
	if (!_fOwnerDraw && (IsSelected(nEnd) != IsSelected(nFmtPara) || _nCount == 0))
	{		
		DWORD dwFore = (unsigned)tomAutoColor;
		DWORD dwBack = (unsigned)tomAutoColor;		
		if (IsSelected(nFmtPara) && _nCount)
		{
			dwFore = _crSelFore;
			dwBack = _crSelBack;		
		}
		SetColors(dwFore, dwBack, nFmtPara, nFmtPara);
	}

	// update our internal listbox records	
	int j = nEnd + 1;
	for(int i = nStart; j < nOldCt; i++, j++)
	{
		_rgData[i]._fSelected = _rgData.Get(j)._fSelected;
		_rgData[i]._dwData = _rgData.Get(j)._dwData;		
	}

	//bug fix #5397 
	//we need to reset the internal array containing information
	//about previous items
	while (--j >= _nCount)
	{
		_rgData[j]._fSelected = 0;
		_rgData[j]._dwData = 0;
	}
		
	if (_nCount > 0)
	{
		// update the cursor			
		if (nStart <= _nCursor)
			_nCursor--;
		_nCursor = min(_nCursor, _nCount - 1);

		if (_fLstType == kExtended)
		{
			if (_nCursor < 0)
			{
				_nOldCursor = min(_nAnchor, _nCount - 1);
				_nAnchor = -1;
			}
			else if (_nAnchor >= 0)
			{
				if (nStart <= _nAnchor && _nAnchor <= nEnd)
				{
					// Store the old anchor for future use
					_nOldCursor = min(_nAnchor, _nCount - 1);
					_nAnchor = -1;
				}
			}
		}

		if (_fOwnerDraw)
		{
			RECT rcStart;
			RECT rcEnd;
			LbGetItemRect(nStart, &rcStart);
			LbGetItemRect(nEnd, &rcEnd);
			rcStart.bottom = rcEnd.bottom;
			if (IntersectRect(&rcStart, &rcStart, &_rcViewport))
			{
				// the list will get bumped up so we need to redraw
				// everything from the top to the bottom
				rcStart.bottom = _rcViewport.bottom;
				::InvalidateRect(_hwnd, &rcStart, TRUE);				
			}
		}
	}
	else
	{
		SetTopViewableItem(0);
		_nAnchor = -1;
		_nCursor = -1;
	}

	//For ownerdraw cases where the item height is less than the font we need to manually
	//enable the scrollbar if we need the scrollbar and the scrollbar is disabled.
	if ((_nyItem < _nyFont) && (_fDisableScroll) && 
		(_nCount <= _nViewSize) && (nOldCt > _nViewSize))
		TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
	
	LbDeleteItemNotify(nStart, nEnd);
	Assert(GetTopIndex() >= 0);
	if (_nCount)
		LbShowIndex(min(GetTopIndex(), _nCount - 1), FALSE);
	Unfreeze();
	return TRUE;
}
 
/*
 *	inline CLstBxWinHost::Freeze()
 *
 *	@mfunc
 *		Prevents TOM from drawing
 *
 *	#rdesc
 *		<none>
 */
void CLstBxWinHost::Freeze()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::Freeze");
	long l;
	((CTxtEdit*)_pserv)->Freeze(&l);
}

/*
 *	inline CLstBxWinHost::FreezeCount()
 *
 *	@mfunc
 *		Returns the current freeze count
 *
 *	#rdesc
 *		<none>
 */
short CLstBxWinHost::FreezeCount() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetFreezeCount");
	return ((CTxtEdit*)_pserv)->GetFreezeCount();
}

/*
 *	inline CLstBxWinHost::Unfreeze()
 *
 *	@mfunc
 *		Allows TOM to update itself
 *
 *	#rdesc
 *		<none>
 */
void CLstBxWinHost::Unfreeze()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::Unfreeze");
	long l;
	((CTxtEdit*)_pserv)->Unfreeze(&l);

    // HACK ALERT!
    // When ITextRange::ScrollIntoView starts caching the scroll position
    // in cases where the display is frozen the following code can be removed
    
    // We could have failed in ITextRange::ScrollIntoView
    // Check if we did and try calling it again
	if (!l && _stvidx >= 0)
	{
	    ScrollToView(_stvidx);
	    _stvidx = -1;
	}
}

/*
 *	CLstBxWinHost::ScrollToView(long)
 *
 *	@mfunc
 *		Sets the given index to be at the top of 
 *		the viewable window space
 *
 *	#rdesc
 *		BOOL = if function succeeded ? TRUE : FALSE
 */
BOOL CLstBxWinHost::ScrollToView(long nTop)
{
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetTopViewableItem");

	//Get the range which contains the item desired
	BOOL bVal = FALSE;
	ITextRange* pRange = NULL;
	
	if (!GetRange(nTop, nTop, &pRange))
	    return bVal;
    Assert(pRange);	 

    CHECKNOERROR(pRange->Collapse(1));
	CHECKNOERROR(pRange->ScrollIntoView(tomStart + /* TA_STARTOFLINE */ 32768));
	bVal = TRUE;

CleanExit:
	pRange->Release();

    // HACK ALERT!
    // When ITextRange::ScrollIntoView starts caching the scroll position
    // in cases where the display is frozen the following code can be removed
    
	//if we failed record the index we failed to scroll to	
	if (!bVal && FreezeCount())
	    _stvidx = nTop;
	return bVal;	
}

/*
 *	CLstBxWinHost::SetTopViewableItem(long)
 *
 *	@mfunc
 *		Sets the given index to be at the top of 
 *		the viewable window space
 *
 *	#rdesc
 *		BOOL = if function succeeded ? TRUE : FALSE
 */
 BOOL CLstBxWinHost::SetTopViewableItem(long nTop)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetTopViewableItem");

	// if we don't have any items in the list box then just set the topindex to 
	// zero
	if (_nCount == 0)
	{
		Assert(nTop == 0);
		_nTopIdx = 0;
		return TRUE;
	}
	
	// don't do anything if the requested top index is greater
	// then the amount of items in the list box
 	Assert(nTop < _nCount);
 	if (nTop >= _nCount)
 		return FALSE;

	// Don't do this if it's ownerdraw
	if (!_fOwnerDraw)
	{
		// Since we erase and draw the focus rect here
		// cache the focus rect info and don't bother with the
		// focus rect stuff until later
		int fFocus = _fFocus;
		_fFocus = 0;
		if (fFocus && IsItemViewable(GetCursor()))
			SetCursor(NULL, GetCursor(), TRUE);
		
	 	//Get the range which contains the item desired
		long nOldIdx = _nTopIdx;
		_nTopIdx = nTop;
	 	if (!ScrollToView(nTop))
		{
            // HACK ALERT!
            // When ITextRange::ScrollIntoView starts caching the scroll position
            // in cases where the display is frozen the following code can be removed            
            if (_stvidx >= 0)
                return TRUE;

            // Something went wrong and we weren't able to display the index requested
            // reset top index
			_nTopIdx = nOldIdx;		
		}

		// Note:
		//	If the cursor was not viewable then we don't attempt
		// to display the focus rect because we never erased it 
		_fFocus = fFocus;
		if (_fFocus & IsItemViewable(GetCursor()))
		{
			// Now we need to redraw the focus rect which we erased
			SetCursor(NULL, GetCursor(), FALSE);
		}
	}
	else
	{				
		int dy = (_nTopIdx - nTop) * _nyItem;
		RECT rc;
		TxGetClientRect(&rc);
		_nTopIdx = nTop;
		TxScrollWindowEx(0, dy, NULL, &rc, NULL, NULL, 
				SW_INVALIDATE | SW_ERASE | SW_SCROLLCHILDREN);
		SetScrollInfo(SB_VERT, TRUE); // we update the scrollbar manually if we are in ownerdraw mode
		UpdateWindow(_hwnd);
 	}
		
	return TRUE;
 }
 
/*
 *	CLstBxWinHost::GetRange(long, long, ITextRange**)
 *
 *	@mfunc
 *		Sets the range given the top and bottom index
 *		by storing the range into ITextRange
 *
 *	#rdesc
 *		BOOL = if function succeeded ? TRUE : FALSE
 */
BOOL CLstBxWinHost::GetRange(long nTop, long nBottom, ITextRange** ppRange)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetRange");

	// do some error checking
	if (nTop < 0 || nTop > _nCount || nBottom < 0 || nBottom > _nCount)
		return FALSE;
		
	Assert(ppRange);
	if (NOERROR != ((CTxtEdit*)_pserv)->Range(0, 0, ppRange))
	{
		Assert(FALSE);
		return FALSE;
	}
	Assert(*ppRange);

	// convert index to a 1-based index
	nTop++;
	nBottom++;
	long l;
	CHECKNOERROR((*ppRange)->SetIndex(tomParagraph, nTop, 1));
	if (nBottom > nTop)
	{
		CHECKNOERROR((*ppRange)->MoveEnd(tomParagraph, nBottom - nTop, &l));
	}

	return TRUE;
CleanExit:
	Assert(FALSE);
	(*ppRange)->Release();
	*ppRange = NULL;
	return FALSE;
}

/*
 *	CLstBxWinHost::SetColors(DWORD, DWORD, long, long)
 *
 *	@mfunc
 *		Sets the background color for the givin range of paragraphs.  This
 *		only operates in terms of paragraphs.
 *
 *	#rdesc
 *		BOOL = if function succeeded in changing different color
 */
BOOL CLstBxWinHost::SetColors(DWORD dwFgColor, DWORD dwBgColor, long nParaStart, long nParaEnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetColors");

	Assert(_fOwnerDraw == 0);
	
	//Get the range of the index
	ITextRange* pRange;
	if (!GetRange(nParaStart, nParaEnd, &pRange))
		return FALSE;

	BOOL bRet = FALSE;	
	ITextFont* pFont;
	
#ifdef DEBUG	
	// Check if the background and foreground really is different
	// for debugging purposes
	CHECKNOERROR(pRange->GetFont(&pFont));
	Assert(pFont);
	if (nParaStart == nParaEnd && _fLstType != kCombo)
	{
		long lColor;
		CHECKNOERROR(pFont->GetBackColor(&lColor));
		Assert((DWORD)lColor != dwBgColor || _nCount == 0);
		CHECKNOERROR(pFont->GetForeColor(&lColor));
		Assert((DWORD)lColor != dwFgColor || _nCount == 0);
	}
	pFont->Release();
#endif //_DEBUG

	// Set the background and forground color
	if (NOERROR != pRange->GetFont(&pFont))
	{
		pRange->Release();
		return FALSE;
	}	
	
	Assert(pFont);
	CHECKNOERROR(pFont->SetBackColor(dwBgColor));
	CHECKNOERROR(pFont->SetForeColor(dwFgColor));

	bRet = TRUE;
CleanExit:
	// Release pointers
	pFont->Release();
	pRange->Release();
	return bRet;

}

/////////////////////////////  Message Map Functions  ////////////////////////////////
/*
 *	void CLstBxWinHost::OnSetCursor()
 *
 *	@mfunc
 *		Handles the WM_SETCURSOR message.
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnSetCursor()
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnSetCursor");

	// Just make sure the cursor is an arrow if it's over us
	TxSetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)), NULL);
	return 1;
 }

/*
 *	void CLstBxWinHost::OnSysColorChange()
 *
 *	@mfunc
 *		Handles the WM_SYSCOLORCHANGE message.
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 void CLstBxWinHost::OnSysColorChange()
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnSysColorChange");

	if (!_fOwnerDraw)
	{
	 	// set the new colors
 		COLORREF crDefBack = _crDefBack;
 		COLORREF crDefFore = _crDefFore;
 		COLORREF crSelBack = _crSelBack;
 		COLORREF crSelFore = _crSelFore;
 		
 		// update colors
 		UpdateSysColors();

		// optimization check; don't do anything if there are no elements
		if (_nCount <= 0)
			return;

	 	// Only update the list box if colors changed
	 	if (crDefBack != _crDefBack || crDefFore != _crDefFore ||
	 		crSelBack != _crSelBack || crSelFore != _crSelFore)
	 	{
	 		//Bug fix #4847
	 		// notify parent first
 			CTxtWinHost::OnSysColorChange();
 			
			int nStart = 0;
			int nEnd = 0;
			BOOL bSelection = _rgData.Get(0)._fSelected;

	 		for (int i = 1; i < _nCount; i++)
	 		{
				if (_rgData.Get(i)._fSelected != (unsigned)bSelection)
				{
					// Update the colors only for selections
					if (bSelection)
						SetColors(_crSelFore, _crSelBack, nStart, nStart + nEnd);

					// Update our cache to reflect the value of our current index
					bSelection = _rgData.Get(i)._fSelected;
					nStart = i;
					nEnd = 0;
				}
				else
					nEnd++;
	 		}

			// there was some left over so change the color for these
			if (bSelection)
				SetColors(_crSelFore, _crSelBack, nStart, nStart + nEnd);
	 	}
	 }
 }
 
/*
 *	LRESULT CLstBxWinHost::OnChar(WORD, DWORD)
 *
 *	@mfunc
 *		Handles the WM_CHAR message.
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnChar(WORD vKey, DWORD lparam)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnChar");

 	// don't do anything if list box is empty or in the middle of
 	// a mouse down
 	if (_fMouseDown || _nCount == 0)
 		return 0;

 	BOOL fControl = (GetKeyState(VK_CONTROL) < 0);

	int nSel = -1;
 	switch (vKey)
 	{
 	case VK_ESCAPE:
 		InitSearch();
 		return 0;
 		
 	case VK_BACK:
 		if (_pwszSearch && _nidxSearch)
 		{
 			if (_nidxSearch > 0)
 				_nidxSearch--;
 			_pwszSearch[_nidxSearch] = NULL;
 			break;	// we break out of case because we still want to perform the search
 		}
 		return 0;		
 	
 	case VK_SPACE:
 		if (_fLstType == kMultiple)
 			return 0;
 		/* Fall through case */
 		
 	default:
 		// convert CTRL+char to char
 		if (fControl && vKey < 0x20)
 			vKey += 0x40;

		// don't go beyond the search array size
 		if (_nidxSearch >= LBSEARCH_MAXSIZE)
 		{
 			((CTxtEdit*)_pserv)->Beep();
 			return 0;
 		}

		// allocate string if not already allocated
		if (_pwszSearch == NULL)
			_pwszSearch = new WCHAR[LBSEARCH_MAXSIZE];

		// error checking
		if (_pwszSearch == NULL)
		{
			((CTxtEdit*)_pserv)->Beep();
			Assert(FALSE && "Unable to allocate search string");
			return 0;
		}		

		// put the input character into string array
 		_pwszSearch[_nidxSearch++] = (WCHAR)vKey;
 		_pwszSearch[_nidxSearch] = NULL;
 	}

	if (_fSort)
	{		
		nSel = (_fSearching) ? _nCursor + 1 : 0;

		// Start the search for a string
 		TxSetTimer(ID_LB_SEARCH, ID_LB_SEARCH_DEFAULT);
		_fSearching = 1;
	}
	else
	{
		_nidxSearch = 0;
		nSel = _nCursor + 1;
	}

	// Make sure our index isn't more than the items we have
	if (nSel >= _nCount)
		nSel = 0;

	int nRes = LbFindString(nSel, _pwszSearch, FALSE);
	if (nRes < 0)
	{
		if (_pwszSearch)
		{
			if (_nidxSearch > 0)
				_nidxSearch--;
			if (_nidxSearch == 1 && _pwszSearch[0] == _pwszSearch[1])
			{
				_pwszSearch[1] = NULL;
				nRes = LbFindString(nSel, _pwszSearch, FALSE);
			}
		}
	}

	// If a matching string is found then select it
	if (nRes >= 0)
		OnKeyDown(nRes, 0, 1);

	//	If Hi-Ansi need to send a wm_syskeyup message to ITextServices to 
	// stabalize the state
	if (0x80 <= vKey && vKey <= 0xFF && !HIWORD(GetKeyState(VK_MENU)))
	{
		LRESULT lres;
		_pserv->TxSendMessage(WM_SYSKEYUP, VK_MENU, 0xC0000000, &lres);
	}	
	
 	return 0;
 }

 
/*
 *	LRESULT CLstBxWinHost::OnKeyDown(WPARAM, LPARAM, INT)
 *
 *	@mfunc
 *		Handles the WM_KEYDOWN message.  The BOOL ff is used as a flag for calls
 *	made internally and not responsive to the WM_KEYDOWN message.  Since this
 *	function is used for other things, ie helper to dealing with the WM_CHAR message.
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnKeyDown(WPARAM vKey, LPARAM lparam, int ff)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnKeyDown");

    // Ignore keyboard input if we are in the middle of a mouse down deal or
    // if there are no items in the listbox. Note that we let F4's go
    // through for combo boxes so that the use can pop up and down empty
    // combo boxes.
 	if (_fMouseDown || (_nCount == 0 && vKey != VK_F4))
 		return 1;

	// Check if the shift key is down for Extended listbox style only
 	int ffShift = 0;
 	if (_fLstType == kExtended)
 		ffShift = HIWORD(GetKeyState(VK_SHIFT));

 	// Special case!
 	// Check if this function is called as a helper
 	int nSel = (ff) ? vKey : -1;

#if 0 	
 	if (_fNotify && ff == 0)
 	{
 		// NOTE: LBS_WANTKEYBOARDINPUT
 		//  To support LBS_WANTKEYBOARDINPUT the following comment has to be done
	 	//	Need to send parentwindow the keydown message
 		// According to documenation we notify the parent the key was pressed
 		// if the parent returns -2 then we don't do anything and immediately exit out
 		// if the parent returns >=0 then we just jump to that index else
 		// we just continue with the default procedure.
 	}
#endif

	TxKillTimer(ID_LB_CAPTURE);
 	if (nSel < 0)
 	{
 		// Need to set the selection so find the new selection
 		// based on the virtual key pressed
 		switch (vKey)
 		{
 		// UNDONE: Later, not language independent!!!
 		// Need to find-out how NT5.0 determines the slash issue??
 		
 		case VERKEY_BACKSLASH:
 			// Deselect everything if we are in extended mode
 			if (HIWORD(GetKeyState(VK_CONTROL)) && _fLstType == kExtended)
 			{
 				// NOTE:
 				//	Winnt loses the anchor and performing a shift+<vkey> 
 				//  doesn't select any items.  Instead, it just moves the
 				//  cursor w/o selecting the current cursor
 				_nAnchor = -1;
 				LbSetSelection(_nCursor, _nCursor, LBSEL_RESET | LBSEL_SELECT, 0, 0); 
 				TxNotify(LBN_SELCHANGE, NULL);
 			} 			
 			return 1;

 		case VK_DIVIDE:
 		case VERKEY_SLASH:
 			// Select everything if we are in extended mode
 			if (HIWORD(GetKeyState(VK_CONTROL)) && _fLstType == kExtended)
 			{
 				// NOTE:
 				//  Winnt behaves as we expect.  In other words the anchor
 				//  isn't changed and neither is the cursor
 				LbSetSelection(0, _nCount - 1, LBSEL_SELECT, 0, 0);
 				TxNotify(LBN_SELCHANGE, NULL);
 			}
 			return 1;
 		
 		case VK_SPACE:
 			// just get out if there is nothing to select
 			if (_nCursor < 0 && !GetCount())
 				return 1;
 			// Just select current item
 			nSel = _nCursor;
 			break;
 			
 		case VK_PRIOR:
 			// move the cursor up enough so the current item which the cursor
 			// is pointing to is at the bottom and the new cursor position is at the top
 			nSel = _nCursor - _nViewSize + 1;
 			if (nSel < 0)
 				nSel = 0;
 			break;
 			
 		case VK_NEXT:
 			// move the cursor down enough so the current item which the cursor
 			// is point is at the top and the new cursor position is at the bottom
 			nSel = _nCursor + _nViewSize - 1;
 			if (nSel >= _nCount)
 				nSel = _nCount - 1;
 			break; 			

 		case VK_HOME:
 			// move to the top of the list
 			nSel = 0;
 			break;
 			
 		case VK_END:
 			// move to the bottom of the list
 			nSel = _nCount - 1;
 			break;

 		case VK_LEFT:
 		case VK_UP:
 			nSel = (_nCursor > 0) ? _nCursor - 1 : 0;
 			break;

 		case VK_RIGHT:
 		case VK_DOWN:
 			nSel = (_nCursor < _nCount - 1) ? _nCursor + 1 : _nCount - 1;
 			break;

 		case VK_RETURN:
 		case VK_F4:
 		case VK_ESCAPE:
 			if (_fLstType == kCombo)
 			{
	 			Assert(_pcbHost);
	 			int nCursor = (vKey == VK_RETURN) ? GetCursor() : _nOldCursor;
	 			_pcbHost->SetSelectionInfo(vKey == VK_RETURN, nCursor);
	 			LbSetSelection(nCursor, nCursor, LBSEL_RESET | 
	 				((nCursor == -1) ? 0 : LBSEL_NEWCURSOR | LBSEL_SELECT), nCursor, nCursor);
				OnCBTracking(LBCBM_END, 0); // we need to do this because we may have some extra messages
											// in our message queue which can change the selections
	 			::SendMessage(_hwndParent, LBCB_TRACKING, 0, 0);
	 		}
 			// NOTE:
 			//	We differ from Winnt here in that we expect the
 			// combobox window handler to do all the positioning and 
 			// showing of the list box.  So when we get this message
 			// and we are part of a combobox we should notify the 
 			// combobox and in turn the combobox should immediately close us.
 			//return 1;

 		//case VK_F8: // not suppported 

 		// We need to return this to pserv to process these keys
		/*
		case VK_MENU:
 		case VK_CONTROL:
 		case VK_SHIFT:
 			return 1;
 		*/
 		
 		default:
 			return 1; 		
 		}
 	}

 	// There can be cases where nSel = -1; _nCursor = -1 && _nViewSize = 1
 	// make sure the selection index is valid
 	if (nSel < 0)
 	    nSel = 0;

 	// Should the cursor be set at the top or bottom of the list box??
 	BOOL bTop = (_nCursor > nSel) ? TRUE : FALSE;
 	Freeze();
 	if (_fLstType == kMultiple)
 	{
		if (vKey == VK_SPACE)
		{
			BOOL fSel = IsSelected(nSel);
			if (LbSetSelection(nSel, nSel, LBSEL_NEWCURSOR | (IsSelected(nSel) ? 0 : LBSEL_SELECT), nSel, 0))
			{
#ifndef NOACCESSIBILITY
				_dwWinEvent = EVENT_OBJECT_FOCUS;
				_fNotifyWinEvt = TRUE;
				TxNotify(_dwWinEvent, NULL);
				if (fSel)
					_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
#endif
			}
		}
		else
		{
			SetCursor(NULL, nSel, TRUE);
#ifndef NOACCESSIBILITY
			_dwWinEvent = EVENT_OBJECT_FOCUS;
#endif
		}
	}
 	else
 	{ 	
	 	if (ffShift && _fLstType == kExtended)
	 	{	 		
	 		// Set the anchor if it already isn't set
	 		_nOldCursor = -1;
			if (_nAnchor < 0)
				_nAnchor = nSel;
	
			LbSetSelection(_nAnchor, nSel, LBSEL_RESET | LBSEL_SELECT | LBSEL_NEWCURSOR, nSel, 0);
	 	}
	 	else
	 	{
	 		// if the selected item is already selected then
	 		// just exit out
	 		if (_nCursor == nSel && IsSelected(_nCursor))
	 		{
	 		    Unfreeze();
	 			return 1;
	 		}

	 		LbSetSelection(nSel, nSel, LBSEL_DEFAULT, nSel, nSel);
	 	}
	}
	// LbShowIndex eventually calls ScrollToView which fails if display is frozen
	Unfreeze();
	
	// Make sure the selection is visible
	LbShowIndex(nSel, bTop);
	

	// key presses qualify as ok selections so we have to update the old cursor position		
	TxNotify(LBN_SELCHANGE, NULL);

	_nOldCursor = _nCursor;
	return 1;
 }
 
/*
 *	LRESULT CLstBxWinHost::OnTimer(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_TIMER message
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnTimer(WPARAM wparam, LPARAM lparam)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnTimer");

	// Check which timer we have
	switch (wparam)
	{
	case ID_LB_CAPTURE:
		// for mouse movements let mousemove handler deal with it
		if (_fCapture)
		{
			POINT pt;
			::GetCursorPos(&pt);
			// Must convert to client coordinates to mimic the mousemove call
			TxScreenToClient(&pt);
			OnMouseMove(0, MAKELONG(pt.x, pt.y));
		}
		break;

	case ID_LB_SEARCH:
		// for type search.  If we get here means > 2 seconds elapsed before last
		// character was typed in so reset type search and kill the timer
		InitSearch();
		TxKillTimer(ID_LB_SEARCH);
		break;

	default:
		return 1;	
	}
	return 0;
 }
 
/*
 *	LRESULT CLstBxWinHost::OnVScroll(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_VSCROLL message
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnVScroll(WPARAM wparam, LPARAM lparam)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnVScroll");

	if (_nCount <= _nViewSize)
		return 0;

	int nCmd = LOWORD(wparam);
	int nIdx = 0;
	switch (nCmd)
	{
	case SB_TOP:
		nIdx = 0;
		break;
		
	case SB_BOTTOM:
		nIdx = _nCount - _nViewSize;
		if (nIdx < 0)
			nIdx = 0;
		break;
	
	case SB_LINEDOWN:
		nIdx = GetTopIndex() + 1;
		break;		
		
	case SB_LINEUP:
		nIdx = GetTopIndex() - 1;
		if (nIdx < 0)
			nIdx = 0;
		break;
		
	case SB_PAGEDOWN:
		nIdx = GetTopIndex() + _nViewSize;
		if (nIdx > (_nCount - _nViewSize))
			nIdx = _nCount - _nViewSize;
		break;
		
	case SB_PAGEUP:
		nIdx = GetTopIndex() - _nViewSize;
		if (nIdx < 0)
			nIdx = 0;
		break;

	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		// NOTE:
		//	if the list box is expected to hold more that 0xffff items
		//  then we need to modify this code to call GetScrollInfo.		
		nIdx =  HIWORD(wparam) / _nyItem;
		break;

		// Don't need to do anything for this case
	case SB_ENDSCROLL:
		return 0;	
	}
		
	LbSetTopIndex(nIdx);
 	return 0;
 }


 /*
 *	LRESULT CLstBxWinHost::OnCaptureChanged(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_CAPTURECHANGED message
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnCaptureChanged(WPARAM wparam, LPARAM lparam)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnCaptureChanged");
	
	if (_fCapture)
	{
		POINT pt;
		::GetCursorPos(&pt);
		::ScreenToClient(_hwnd, &pt);

		// prevent us from trying to release capture since we don't have
		// it anyways by set flag and killing timer
		_fCapture = 0;
		TxKillTimer(ID_LB_CAPTURE);		
		OnLButtonUp(0, MAKELONG(pt.y, pt.x), LBN_SELCANCEL);
	}
	return 0;
 }

//FUTURE:
// Do we need to support ReadModeHelper? 

/*
 *	LRESULT CLstBxWinHost::OnMouseWheel(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_MOUSEWHEEL message
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnMouseWheel(WPARAM wparam, LPARAM lparam)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnMouseWheel");

	// we don't to any zooms or anything of the sort
	if ((wparam & MK_CONTROL) == MK_CONTROL)
		return 1;

	// Check if the scroll is ok w/ the listbox requirements
    LRESULT lReturn = 1;
    short delta = (short)(HIWORD(wparam));
   	_cWheelDelta -= delta;   	
    if ((abs(_cWheelDelta) >= WHEEL_DELTA) && (_nCount > _nViewSize) && (_dwStyle & WS_VSCROLL )) 
    {
		// shut-off timer for right now
		TxKillTimer(ID_LB_CAPTURE);

		Assert(delta != 0);
        	
		int nlines = W32->GetRollerLineScrollCount();
		if (nlines == -1)
		{
			OnVScroll(MAKELONG((delta < 0) ? SB_PAGEUP : SB_PAGEDOWN, 0), 0);
		}
		else
		{
			//Calculate the number of lines to scroll
			nlines *= _cWheelDelta/WHEEL_DELTA;

			//Perform some bounds checking
			nlines = min(_nViewSize - 1, nlines);
	        int nIdx = max(0, nlines + GetTopIndex());
	        nIdx = min(nIdx, _nCount - _nViewSize);        	
	        if (nIdx != GetTopIndex()) 
	        {
	        	// Scroll bar is based in pixels so figure-out the pixel value
	            OnVScroll(MAKELONG(SB_THUMBPOSITION, nIdx * _nyItem), 0);
	        }
		}		
        OnVScroll(MAKELONG(SB_ENDSCROLL, 0), 0);
        _cWheelDelta %= WHEEL_DELTA;
    }
    return lReturn;
 }

/*
 *	LRESULT CLstBxWinHost::OnLButtonUp(WPARAM, LPARAM, int)
 *
 *	@mfunc
 *		Handles the WM_LBUTTONUP and WM_CAPTURECHANGED message
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnLButtonUp(WPARAM wparam, LPARAM lparam, int ff)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnLButtonUp");

	// if mouse wasn't down then exit out
	if (!_fMouseDown)
		return 0;
	_fMouseDown = 0;

	POINT pt;
	POINTSTOPOINT(pt, lparam);
 	if (_fLstType == kCombo)
 	{
 		Assert(_fCapture);
 		// Check if user clicked outside the list box
 		// if so this signifies the user cancelled and we
 		// should send a message to the parentwindow
		if (!PointInRect(&pt))
 		{	
			//User didn't click in listbox so reselect old item
			LbSetSelection(_nOldCursor, _nOldCursor, LBSEL_DEFAULT, _nOldCursor, _nOldCursor);
			ff = 0;
 		}
 		else
			ff = LBN_SELCHANGE;	//item changed so notify parent
 		
 		_pcbHost->SetSelectionInfo(ff == LBN_SELCHANGE, GetCursor());
		OnCBTracking(LBCBM_END, 0);
		::PostMessage(_hwndParent, LBCB_TRACKING, LBCBM_END, 0);
 	}
 	else
 	{
 		// Kill any initializations done by mouse down... 
		_fMouseDown = 0;
		_nOldCursor = -1;
	}
	
 	if (_fCapture)
 	{
 		TxKillTimer(ID_LB_CAPTURE);
		_fCapture = 0;
 		TxSetCapture(FALSE); 	
 	}

	if (ff)
	{
#ifndef NOACCESSIBILITY
		if (ff == LBN_SELCHANGE)
		{
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);
			if (!IsSelected(_nCursor))
			{
				_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
			}
		}
#endif
		// Send notification if a notification exists
		TxNotify(ff, NULL);
	}
	return 1;
 }

/*
 *	LRESULT CLstBxWinHost::OnMouseMove(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_MOUSEMOVE message and possibly the
 *		WM_TIMER message for tracking mouse movements
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
 LRESULT CLstBxWinHost::OnMouseMove(WPARAM wparam, LPARAM lparam)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnMouseMove");

	// bug fix #4998
 	// Check if previous mouse position is the same as current, if it is
 	// then this is probably a bogus message from PPT.
	POINT pt;
	POINTSTOPOINT(pt, lparam);
 	if (_nPrevMousePos == lparam && PtInRect(&_rcViewport, pt))
 		return 0;
 	_nPrevMousePos = lparam;
 	
 	// This routine will only start the autoscrolling of the listbox
 	// The autoscrolling is done using a timer where the and the elapsed
 	// time is determined by how far the mouse is from the top and bottom
 	// of the listbox.  The farther from the listbox the faster the timer
 	// will be.  This function relies on the timer to scroll and select
 	// items.	
	// We get here if mouse cursor is in the list box.
	int idx = GetItemFromPoint(&pt);

 	// We only do the following if mouse is down	
 	if (_fMouseDown)
 	{ 	
	 	int y = (short)pt.y;
		if (y < 0 || y > _rcViewport.bottom - 1)
		{	
		 	// calculate the new timer settings		 	
		 	int dist = y < 0 ? -y : (y - _rcViewport.bottom + 1);
		 	int nTimer = ID_LB_CAPTURE_DEFAULT - (int)((WORD)dist << 4);
				
			// Scroll up or down depending on the mouse pos relative
			// to the list box
			idx = (y <= 0) ? max(0, idx - 1) : min(_nCount - 1, idx + 1);
			if (idx >= 0 && idx < _nCount)
			{	
				// The ordering of this is VERY important to prevent screen
				// flashing...
				if (idx != _nCursor)
					MouseMoveHelper(idx, (_fLstType == kCombo) ? FALSE : TRUE);
				OnVScroll(MAKELONG((y < 0) ? SB_LINEUP : SB_LINEDOWN, 0), 0);
			}
			// reset timer
			TxSetTimer(ID_LB_CAPTURE, (5 > nTimer) ? 5 : nTimer);
			return 0;
		}
		// Don't select if we are part of a combo box and mouse is outside client area
		else if (_fLstType == kCombo && (pt.x < 0 || pt.x > _rcViewport.right - 1))
			return 0;
	}
	else if (!PointInRect(&pt))
	{
		return 0;		
	}
	
	if (idx != _nCursor || (_fLstType == kCombo && idx >= 0 && !IsSelected(idx)))
	{			
		// Prevent flashing by not redrawing if index
		// didn't change
		Assert(idx >= 0);
		MouseMoveHelper(idx, TRUE);
	}
	return 0;
 }
 
/*
 *	LRESULT CLstBxWinHost::OnLButtonDown(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_LBUTTONDOWN message
 *
 *	#rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnLButtonDown(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnLButtonDown");
	
	POINT pt;
	POINTSTOPOINT(pt, lparam);

	if (_fCapture)
	{
		// Need to check if the listbox is part of a combobox, if so
		// then we need to notify the parent class.
		if (_fLstType == kCombo)
		{
			// Need to perform the following
			// - check if click is within client area of combo box if not then
			//		behave as if user cancelled
			if (!PointInRect(&pt))
			{
				// reset our double click flag because we could be double clicking on the scrollbar
				_fDblClick = 0;
				
				// check if the scroll bar was clicked
				// mouse message won't get posted unless we release it 
				// for a short while
				TxClientToScreen(&pt);				

				// check if user clicked on the scrollbar
				if (HTVSCROLL == SendMessage(_hwnd, WM_NCHITTEST, 0, MAKELONG(pt.x, pt.y)))
				{
					if (_fCapture)
					{
						_fCapture = 0;
						TxSetCapture(FALSE);
					}

					SendMessage(_hwnd, WM_NCLBUTTONDOWN, HTVSCROLL, MAKELONG(pt.x, pt.y));

					TxSetCapture(TRUE);
					_fCapture = 1;
				}
				else
				{
					// if user didn't click the scrollbar then notify parent and stop
					// tracking else just get out
					Assert(_pcbHost);
					_pcbHost->SetSelectionInfo(FALSE, _nOldCursor);
					LbSetSelection(_nOldCursor, _nOldCursor, LBSEL_RESET | 
						((_nOldCursor == -1) ? 0 : LBSEL_NEWCURSOR | LBSEL_SELECT), 
						_nOldCursor, _nOldCursor);
					OnCBTracking(LBCBM_END, 0);
					SendMessage(_hwndParent, LBCB_TRACKING, 0, 0);
				}				
				return 0;
			}
		}
	}	
	
	int idx = GetItemFromPoint(&pt);
	if (idx <= -1)
	{
		_fDblClick = 0;
		return 0;
	}

	_fMouseDown = 1;

	// if the message was a double click message than don't need to go
	// any further just fake a mouseup message to get back to a normal
	// state	
	if (_fDblClick)
	{
		_fDblClick = 0;
		OnLButtonUp(wparam, lparam, LBN_DBLCLK);
		return 0;
	}
		
	// Set the timer in case the user scrolls outside the listbox
	if (!_fCapture)
	{
		TxSetCapture(TRUE);
		_fCapture = 1;
		TxSetTimer(ID_LB_CAPTURE, ID_LB_CAPTURE_DEFAULT);	
	}

	int ffVirtKey = LBKEY_NONE;
	if (_fLstType == kExtended)
	{
		if (HIWORD(GetKeyState(VK_SHIFT)))
			ffVirtKey |= LBKEY_SHIFT;
		if (HIWORD(GetKeyState(VK_CONTROL)))
			ffVirtKey |= LBKEY_CONTROL;
	}

	int ff = 0;
	int i = 0;
	int nStart = idx;
	int nEnd = idx;
	int nAnchor = _nAnchor;
	switch (ffVirtKey)
	{	
	case LBKEY_NONE:
		// This case accounts for listbox styles with kSingle, kMultiple, and 
		// kExtended w/ no keys pressed
		if (_fLstType == kMultiple)
		{
			ff = (IsSelected(idx) ? 0 : LBSEL_SELECT) | LBSEL_NEWANCHOR | LBSEL_NEWCURSOR;			
		}
		else
		{
			// keep a copy of the old cursor position around for combo cancells			
			ff = LBSEL_DEFAULT;
		}
		nAnchor = idx;
		break;
		
	case LBKEY_SHIFT:		
		// Now select all the items between the anchor and the current selection
		// The problem is LbSetSelection expects the first index to be less then
		// or equal to the second index so we have to manage the Anchor and index
		// ourselves..				
		ff = LBSEL_SELECT | LBSEL_RESET | LBSEL_NEWCURSOR;
		i = !(IsSelected(_nAnchor));
		if (_nAnchor == -1)
		{
			ff |= LBSEL_NEWANCHOR;
			nAnchor = idx;
		}
		else if (_nAnchor > idx)
		{
			nEnd = _nAnchor - i;			
		}
		else if (_nAnchor < idx)
		{
			nEnd = _nAnchor + i;
		}
		else if (i) // _nAnchor == idx && idx IS selected
		{
			ff = LBSEL_RESET;
			nStart = 0;
			nEnd = 0;
		}
		break;
		
	case LBKEY_CONTROL:
		// Toggle the selected item and set the new anchor and cursor
		// positions
		ff = LBSEL_NEWCURSOR | LBSEL_NEWANCHOR | (IsSelected(idx) ? 0 : LBSEL_SELECT);
		nAnchor = idx;
		break;
		
	case LBKEY_SHIFTCONTROL:
		// De-select any items between the cursor and the anchor (excluding the anchor)
		// and select or de-select the new items between the anchor and the cursor

		// Set the anchor if it already isn't set
		if (_nAnchor == -1)
			_nAnchor = (_nOldCursor >= 0) ? _nOldCursor : idx;
			
		// Just deselect all items between the cursor and the anchor
		if (_nCursor != _nAnchor)
		{
			// remove selection from old cursor position to the current anchor position
			LbSetSelection(_nCursor, (_nCursor > _nAnchor) ? _nAnchor + 1 : _nAnchor - 1, 0, 0, 0);
		}

		// Check if we used a temporary anchor if so then set the anchor to
		// idx because we don't want the temporary anchor to be the actual anchor
		if (_nOldCursor >= 0)
		{
			_nOldCursor = -1;
			_nAnchor = idx;
		}

		// Set the state of all items between the new Cursor (idx) and 
		// the anchor to the state of the anchor
		ff = LBSEL_NEWCURSOR | (IsSelected(_nAnchor) ? LBSEL_SELECT : 0);
		nEnd = _nAnchor;
		break;
	default:
		Assert(FALSE && "Should not be here!!");		
	}

	if (LbSetSelection(nStart, nEnd, ff, idx, nAnchor))
	{
#ifndef NOACCESSIBILITY
		_dwWinEvent = EVENT_OBJECT_FOCUS;
		_fNotifyWinEvt = TRUE;
		TxNotify(_dwWinEvent, NULL);
#endif
	}

	return 0;
}

///////////////////////////  ComboBox Helper Functions  ////////////////////////////// 
/*
 * void CLstBxWinHost::OnCBTracking(WPARAM, LPARAM)
 *
 * @mfunc
 * 	This should be only called by the combo box.  This is a general message used
 *  to determine the state the listbox should be in
 * #rdesc
 *	void
 */
void CLstBxWinHost::OnCBTracking(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnCBTracking");

	Assert(_pcbHost);
	Assert(_hwndParent);

	switch (wparam)
	{
	// lparam = Set focus to listbox
	case LBCBM_PREPARE:
		Assert(IsWindowVisible(_hwnd));
		_fMouseDown = FALSE;		
		if (lparam & LBCBM_PREPARE_SAVECURSOR)
			_nOldCursor = GetCursor();
		if (lparam & LBCBM_PREPARE_SETFOCUS)
		{
			_fFocus = 1;
			TxSetFocus();
		}
		InitWheelDelta();
		break;

	// lparam = mouse is down
	case LBCBM_START:
		Assert(IsWindowVisible(_hwnd));
		_fMouseDown = !!lparam;
		TxSetCapture(TRUE);
		_fCapture = 1;
		break;		

	// lparam = Keep capture
	case LBCBM_END:
		TxKillTimer(ID_LB_CAPTURE);
		_fFocus = 0;
		if (_fCapture)
		{			
			_fCapture = FALSE;
			TxSetCapture(FALSE);
		}
		break;
	default:
		AssertSz(FALSE, "ALERT: Custom message being used by someone else");
	}	

}


///////////////////////////////  ListBox Functions  ////////////////////////////////// 
/*
 * void CLstBxWinHost::LbDeleteItemNotify(int, int)
 *
 * @mfunc
 * Sends message to the parent an item has been deleted.  This function should be
 *	called whenever the LB_DELETESTRING message is recieved or if the listbox is
 *	being destroyed and the listbox is owner draw
 *
 * #rdesc
 *	void
 */
void CLstBxWinHost::LbDeleteItemNotify(int nStart, int nEnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbDeleteItemNotify");
	
	// Initialize structure
	UINT ctlType;		
	DELETEITEMSTRUCT ds;
	switch (_fLstType)
	{
		case kSingle:
		case kMultiple:
		case kExtended:
			ctlType = ODT_LISTBOX;
			break;
		default:
			ctlType = ODT_COMBOBOX;
	}
	
	for(long i = nStart; i <= nEnd; i++)
	{		
		// We do this just in case the user decides to change
		// the structure
		ds.CtlType = ctlType;
		ds.CtlID = _idCtrl;
		ds.hwndItem = _hwnd;
		ds.itemData = GetData(i);
		ds.itemID = i;
		::SendMessage(_hwndParent, WM_DELETEITEM, _idCtrl, (LPARAM)&ds);
	}
}


/*
 * void CLstBxWinHost::LbDrawItemNotify(HDC, int, UINT, UINT)
 *
 * @mfunc
 * This fills the draw item struct with some constant data for the given
 * item.  The caller will only have to modify a small part of this data
 * for specific needs.
 *
 * #rdesc
 *	void
 */
void CLstBxWinHost::LbDrawItemNotify(HDC hdc, int nIdx, UINT itemAction, UINT itemState)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbDrawItemNotify");
	
	// Only send the message if the item is viewable
	if (!IsItemViewable(nIdx))
		return;
		
    //Fill the DRAWITEMSTRUCT with the unchanging constants
	DRAWITEMSTRUCT dis;
    dis.CtlType = ODT_LISTBOX;
    dis.CtlID = _idCtrl;

    // Use -1 if an invalid item number is being used.  This is so that the app
    // can detect if it should draw the caret (which indicates the lb has the
    // focus) in an empty listbox
    dis.itemID = (UINT)(nIdx < _nCount ? nIdx : -1);
    dis.itemAction = itemAction;
    dis.hwndItem = _hwnd;
    dis.hDC = hdc;
    dis.itemState = itemState |
            (UINT)(_fDisabled ? ODS_DISABLED : 0);

    // Set the app supplied data
    if (_nCount == 0) 
    {
        // If no items, just use 0 for data.  This is so that we
        // can display a caret when there are no items in the listbox.
        dis.itemData = 0L;
    } 
    else 
    {
    	Assert(nIdx < _nCount);
        dis.itemData = GetData(nIdx);
    }

	LbGetItemRect(nIdx, &(dis.rcItem));

    /*
     * Set the window origin to the horizontal scroll position.  This is so that
     * text can always be drawn at 0,0 and the view region will only start at
     * the horizontal scroll offset. We pass this as wparam
     */
    SendMessage(_hwndParent, WM_DRAWITEM, _idCtrl, (LPARAM)&dis);
}

/*
 *	BOOL CLstBxWinHost::LbSetItemHeight(int)
 *
 *	@mfunc
 *		Sets the height of the items within the given range [0, _nCount -1]
 *
 *	#rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::LbSetItemHeight(int nHeight)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetItemHeight");

	// Set the height of the items if there are between [1,255] : bug fix #4783
	if (nHeight < 256 && nHeight > 0)
	{
		if (SetItemsHeight(nHeight, FALSE))
		{
			//bug fix #4214
			//need to recalculate how many items are viewable, IN ITS ENTIRETY, 
			//using the current window size
			RECT rc;
			TxGetClientRect(&rc);
			_nViewSize = max(rc.bottom / max(_nyItem, 1), 1);		
			return TRUE;
		}
	}
	return FALSE;
}

/*
 *	BOOL CLstBxWinHost::LbGetItemRect(int, RECT*)
 *
 *	@mfunc
 *		Returns the rectangle coordinates of a requested index
 *		The coordinates will be in client coordinates
 *
 *	#rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::LbGetItemRect(int idx, RECT* prc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbGetItemRect");

	Assert(prc);
	Assert(idx >= -1);

#ifdef _DEBUG
	if (_nCount > 0)
		Assert(idx < _nCount);
	else
		Assert(idx == _nCount);
#endif //_DEBUG

	if (idx == -1)
		idx = 0;

	TxGetClientRect(prc);
	prc->top = (idx - GetTopIndex()) * _nyItem + _rcViewport.top;
	prc->left = 0; 
	prc->bottom = prc->top + _nyItem;

	return TRUE;
}

	
/*
 *	BOOL CLstBxWinHost::LbSetItemData(long, long, long)
 *
 *	@mfunc
 *		Given a range [nStart,nEnd] the data for these items
 *		will be set to nValue
 *	#rdesc
 *		void
 */
void CLstBxWinHost::LbSetItemData(long nStart, long nEnd, long nValue)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetItemData");
	
	Assert(nStart >= 0 && nStart < _nCount);
	Assert(nEnd >= 0 && nEnd < _nCount);
	Assert(nStart <= nEnd);
	
	int nMin = min(nEnd + 1, _nCount);
	for (int i = nStart; i < nMin; i++)
		_rgData[i]._dwData = nValue;
}

/*
 *	long CLstBxWinHost::LbDeleteString(long, long)
 *
 *	@mfunc
 *		Delete the string at the requested range.
 *	#rdesc
 *		long = # of items in the list box.  If failed -1
 */
 long CLstBxWinHost::LbDeleteString(long nStart, long nEnd)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbDeleteString");
 	
 	if ((nStart > nEnd) || (nStart < 0) || (nEnd >= _nCount))
		return -1;

	if (!RemoveString(nStart, nEnd))
		return -1;

	// set the top index to fill the window
	LbSetTopIndex(max(nStart -1, 0));

#ifndef NOACCESSIBILITY
		_dwWinEvent = EVENT_OBJECT_DESTROY;
		_fNotifyWinEvt = TRUE;
		TxNotify(_dwWinEvent, NULL);
#endif
		
	return _nCount;
 }
 
/*
 *	CLstBxWinHost::LbInsertString(long, LPCTSTR)
 *
 *	@mfunc
 *		Insert the string at the requested index.  If long >= 0 then the
 *	string insertion is at the requested index. If long == -2 insertion
 *	is at the position which the string would be alphabetically in order.
 *	If long == -1 then string is added to the bottom of the list
 *
 *	#rdesc
 *		long = If inserted, the index (paragraph) which the string
 *			was inserted.  If not inserted returns -1;
 */
long CLstBxWinHost::LbInsertString(long nIdx, LPCTSTR szText)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbInsertString");

	Assert(nIdx >= -2);
	Assert(szText);
	
	if (nIdx == -2)
	{
		if (_nCount > 0)
			nIdx = GetSortedPosition(szText, 0, _nCount - 1);
		else
			nIdx = 0; //nothing inside listbox
	}
	else if (nIdx == -1)
		nIdx = GetCount();	// Insert string to the bottom of list if -1

	if (InsertString(nIdx, szText))
	{
		// If the index was previously selected unselect the newly 
		// added item
		for (int i = _nCount - 1; i > nIdx; i--)
		{
			_rgData[i]._fSelected = _rgData.Get(i - 1)._fSelected;

			// bug fix #4916
			_rgData[i]._dwData = _rgData.Get(i - 1)._dwData;
		}
		_rgData[nIdx]._fSelected = 0;
		_rgData[nIdx]._dwData = 0;		// Need to Initialize data back to zero

		if (!_fOwnerDraw)
		{
			// if we inserted at the middle or top then check 1 index down to see if the item
			// was selected, if we inserted at the bottom then check 1 index up to see if the item
			// was selected.  If the item was selected we need to change the colors to default
			// because we inherit the color properties from the range which we inserted into
			if (_nCount > 1)
			{
				if (((nIdx < _nCount - 1) && _rgData.Get(nIdx + 1)._fSelected) ||
					(nIdx == (_nCount - 1) && _rgData.Get(nIdx - 1)._fSelected))
					SetColors((unsigned)tomAutoColor, (unsigned)tomAutoColor, nIdx, nIdx);
			}
		}
		else
		{					
			// Force redraw of items if owner draw and new item is viewable
			if (IsItemViewable(nIdx))
			{
				RECT rc;
				LbGetItemRect(nIdx, &rc);
				rc.bottom = _rcViewport.bottom;
				InvalidateRect(_hwnd, &rc, TRUE);
			}
		}
#ifndef NOACCESSIBILITY
		_dwWinEvent = EVENT_OBJECT_CREATE;
		_fNotifyWinEvt = TRUE;
		_nAccessibleIdx = nIdx + 1;
		TxNotify(_dwWinEvent, NULL);
#endif
		return nIdx;
	}
	else
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return -1;
	}
}
 
/*
 *	CLstBxWinHost::LbFindString(long, LPCTSTR, BOOL)
 *
 *	@mfunc
 *		Searches the story for a given string.  The
 *		starting position will be determined by the index nStart.
 *		This routine expects the units to be in tomParagraph.
 *		If bExact is TRUE then the paragraph must match the BSTR.
 *
 *	#rdesc
 *		long = If found, the index (paragraph) which the string
 *			was found in.  If not found returns -1;
 */
long CLstBxWinHost::LbFindString(long nStart, LPCTSTR szSearch, BOOL bExact)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbFindString");

	Assert(szSearch);
	Assert(nStart <= _nCount);
	
	int nSize = wcslen(szSearch);
	// If string is empty and not finding exact match then just return -1 like
	// the system control.  We don't have to worry about the exact match case
	// because it will work properly
	if (nStart >= _nCount || (nSize == 0 && !bExact))
		return -1;

	// allocate string buffer into stack
	WCHAR sz[1024];
	WCHAR *psz = sz;
	
	if ((nSize + 3) > 1024)
		psz = new WCHAR[nSize + 3 /* 2 paragraphs and a NULL*/];
	Assert(psz);

	if (psz == NULL)
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return FALSE;
	}

	// format the string the way we need it
	wcscpy(psz, szCR);
	wcscat(psz, szSearch);
	if (bExact)
		wcscat(psz, szCR);		
	long lRet = -1;
	long l, cp;
	ITextRange *pRange = NULL;
	BSTR bstrQuery = SysAllocString(psz);
	if(!bstrQuery)
		goto CleanExit;
	if (psz != sz)
		delete [] psz;
	
	// Set starting position for the search
	if (!GetRange(nStart, _nCount - 1, &pRange))
	{
		SysFreeString(bstrQuery);
		return lRet;
	}
	
	CHECKNOERROR(pRange->GetStart(&cp));
	if (cp > 0)
	{
		// We need to use the paragraph marker from the previous
		// paragraph when searching for a string
		CHECKNOERROR(pRange->SetStart(--cp));	
	}
	else
	{
		// Special case:
		// Check if the first item matchs
		if (FindString(0, szSearch, bExact))
		{
			lRet = 0;
			goto CleanExit;
		}
	}

	if (NOERROR != pRange->FindTextStart(bstrQuery, 0, FR_MATCHALEFHAMZA | FR_MATCHKASHIDA | FR_MATCHDIAC, &l))
	{
		// Didn't find the string...
		if (nStart > 0)
		{
			if (!FindString(0, szSearch, bExact))
			{
				// Start the search from top of list to the point where
				// we last started the search			
				CHECKNOERROR(pRange->SetRange(0, ++cp));
				CHECKNOERROR(pRange->FindTextStart(bstrQuery, 0, 0, &l));
			}
			else
			{
				// First item was a match
				lRet = 0;
				goto CleanExit;
			}
		}
		else
			goto CleanExit;
	}

	// If we got down here then we have a match.
	// Get the index and convert to listbox index
	CHECKNOERROR(pRange->MoveStart(tomCharacter, 1, &l));
	CHECKNOERROR(pRange->GetIndex(tomParagraph, &lRet));
	lRet--;	// index is 1 based so we need to changed it to zero based

CleanExit:
	if (bstrQuery)
		SysFreeString(bstrQuery);
	if (pRange)
		pRange->Release();
	return lRet;
 }
 
/*
 *	CLstBxWinHost::LbShowIndex(int, BOOL)
 *
 *	@mfunc
 *		Makes sure the requested index is within the viewable space.
 *		In cases where the item is not in the viewable space bTop is
 *		used to determine the requested item should be at the top
 *		of the list else list box will scrolled enough to display the
 *		item.
 *		NOTE:
 *			There can be situations where bTop will fail.  These 
 *		situations occurr of the top index requested prevents the list
 *		box from being completely filled with items.  For more info
 *		read the comments for LBSetTopIndex.
 *
 *	#rdesc
 *		BOOL = Successfully displays the item ? TRUE : FALSE
 */
 BOOL CLstBxWinHost::LbShowIndex(long nIdx, BOOL bTop)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbShowIndex");

	// Make sure the requested item is within valid bounds
	Assert(nIdx >= 0 && nIdx < _nCount);
	
	int delta = nIdx - GetTopIndex();

	// If item is already visible then just return TRUE
	if (0 <= delta && delta < _nViewSize)
		return TRUE;

	if ((delta) >= _nViewSize && !bTop && _nViewSize)
	{
		nIdx = nIdx - _nViewSize + 1;
	}

	return (LbSetTopIndex(nIdx) < 0) ? FALSE : TRUE;
 }

/*
 *	CLstBxWinHost::LbSetTopIndex(long)
 *
 *	@mfunc
 *		Tries to make the requested item the top index in the list box.
 *		If making the requested item the top index prevents the list box
 *		from using the viewable region to its fullest then and alternative
 *		top index will be used which will display the requested index
 *		but NOT as the top index.  This ensures conformancy with the system
 *		list box and makes full use of the dislayable region.
 *
 *	#rdesc
 *		long = returns the new top index if successful.  If failed returns -1
 */
 long CLstBxWinHost::LbSetTopIndex(long nIdx)
 {
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetTopIndex");
		
	// Make sure the requested item is within valid bounds
 	if (nIdx < 0 || nIdx >= _nCount)
 		return -1;
		
	// Always try to display a full list of items in the list box
	// This may mean we have to adjust the requested top index if
	// the requested top index will leave blanks at the end of the
	// viewable space
	if (_nCount - _nViewSize < nIdx)
		nIdx = max(0, _nCount - _nViewSize);

	// Just check to make sure we not already at the top 
	if (GetTopIndex() == nIdx)
		return nIdx;

	if (!SetTopViewableItem(nIdx))
		nIdx = -1;

	return nIdx;
 }

/*
 *	CLstBxWinHost::LbBatchInsert(WCHAR* psz)
 *
 *	@mfunc
 *		Inserts the given list of items into listbox.  The listbox is reset prior to adding
 *	the items into the listbox
 *
 *	#rdesc
 *		int = # of items in the listbox if successful else LB_ERR
 */
int CLstBxWinHost::LbBatchInsert(WCHAR* psz)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbBatchInsert");

	// make sure we get some sort of string
	if (!psz)
		return LB_ERR;
		
	WCHAR* pszOut = psz;
	LRESULT nRet = LB_ERR;
	BSTR bstr = NULL;
	ITextRange* pRange = NULL;
	int nCount = 0;
	
	if (_fSort)
	{
		pszOut = new WCHAR[wcslen(psz) + 1];
		Assert(pszOut);

		if (!pszOut)
		{
			TxNotify((unsigned long)LBN_ERRSPACE, NULL);
			return LB_ERR;
		}

		nCount = SortInsertList(pszOut, psz);
		if (nCount == LB_ERR)
			goto CleanExit;
	}
	else
	{
		//bug fix #5130 we need to know how much we are going to insert
		//prior to inserting because we may be getting showscrollbar message
		//during insertion
		WCHAR* pszTemp = psz;
		while(*pszTemp)
		{
			if (*pszTemp == L'\r')
				nCount++;
			pszTemp++;
		}
		nCount++;
	}

	//clear listbox and insert new list into listbox
	LbDeleteString(0, GetCount() - 1);

	bstr = SysAllocString(pszOut);
	if(!bstr)
		goto CleanExit;
	
	// Insert string into list	
	CHECKNOERROR(((CTxtEdit*)_pserv)->Range(0, 0, &pRange));

	//bug fix #5130
	// preset our _nCount for scrollbar purposes
	_nCount = nCount;	
	CHECKNOERROR(pRange->SetText(bstr));

#ifdef DEBUG
    // We can't trust the code below because ITextServices performs a background recalc
    // and so returns the incorrect line count
	// update our count
	// I'm leaving it here for debugging purposes of ITextServices
	_pserv->TxSendMessage(EM_GETLINECOUNT, 0, 0, &nRet);
	AssertSz(_nCount == nRet, "Textserv line count doesn't match listbox interal line count");
#endif
    nRet = nCount;

CleanExit:
	if (pszOut != psz)
		delete [] pszOut;

	if (bstr)
		SysFreeString(bstr);

	if (pRange)
		pRange->Release();
	return nRet;
}


 

/*
 *	CLstBxWinHost::LbSetSelection(long, long, int)
 *
 *	@mfunc
 *		Given the range of nStart to nEnd set the selection state of each item
 *		This function will also update the anchor and cursor position
 *		if requested.
 *
 *	#rdesc
 *		BOOL = If everything went fine ? TRUE : FALSE
 */
BOOL CLstBxWinHost::LbSetSelection(long nStart, long nEnd, int ffFlags, long nCursor, long nAnchor)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetSelection");

	if (!_fOwnerDraw)
	{
		Freeze();
	
		// de-select all items
		if ((ffFlags & LBSEL_RESET))
		{
			if (!ResetContent())
			{
				Unfreeze();
				return FALSE;
			}

			// Reset, check if anything else needs to be done
			// else just exit out
			if (ffFlags == LBSEL_RESET)
			{
				Unfreeze();
				return TRUE;
			}
		}
	}
	
	// NOTE:
	//	This should be one big critical section because we rely on certain
	// member variables not changing during the process of this function

	// Check if we are changing the selection and if we have focus
	// if we do then we first need to xor out the focus rect from
	// old cursor
	RECT rc;
	HDC hdc;
	hdc = TxGetDC();
	Assert(hdc);
	// don't draw outside the client rect draw the rectangle
	TxGetClientRect(&rc);
	IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

	if ((ffFlags & LBSEL_NEWCURSOR) && _fFocus)
	{
 		// If owner draw notify parentwindow
 		if (_fOwnerDraw)
 			LbDrawItemNotify(hdc, max(_nCursor, 0), ODA_FOCUS, IsSelected(_nCursor) ? ODS_SELECTED : 0);				
 		else
 		{
 			LbGetItemRect(_nCursor, &rc);
 			::DrawFocusRect(hdc, &rc);
 		}
	}
		
	//	check if all item should be selected
	if (nStart == -1 && nEnd == 0)
	{
		nStart = 0;
		nEnd = _nCount - 1;
	}
	else if (nStart > nEnd)	
	{
		// reshuffle so nStart is <= nEnd;
		long temp = nEnd;
		nEnd = nStart;
		nStart = temp;
	}

	// Check for invalid values
	if (nStart < -1 || nEnd >= _nCount)
	{
		if (!_fOwnerDraw)
			Unfreeze();

		// mimic system listbox behaviour
		if (nEnd >= _nCount)
			return FALSE;
		else
			return TRUE;
	}

	// Prepare the state we want to be in
	unsigned int bState;	
	DWORD dwFore;
	DWORD dwBack;
	if (ffFlags & LBSEL_SELECT)
	{
		bState = ODS_SELECTED;	//NOTE ODS_SELECTED must equal 1
		dwFore = _crSelFore;
		dwBack = _crSelBack;

		if (_fSingleSel)
			nEnd = nStart;
	}
	else 
	{
		bState = 0;
		dwFore = (unsigned)tomAutoColor;
		dwBack = (unsigned)tomAutoColor;
	}

	// A little optimization check
	// Checks to see if the state is really being changed if not then don't bother
	// calling SetColor, works only when nStart == nEnd;
	// The list box will not change the background color if nSame is true
	int nSame = (nStart == nEnd && nStart != -1) ? (_rgData.Get(nStart)._fSelected == bState) : FALSE;

	BOOL bRet = TRUE;
	if (_fOwnerDraw)
	{
		if (ffFlags & LBSEL_RESET || !bState)
		{
			// There are cases where we don't necessarily reset all the items
			// in the list but rather the range which was given.  The following
			// takes care of this case
			int ff = ffFlags & LBSEL_RESET;
			int i = (ff) ? 0 : nStart;
			int nStop = (ff) ? _nCount : nEnd + 1;
		 	for (; i < nStop; i++)
		 	{
		 		// Don't unselect an item which is going to be
		 		// selected in the next for loop
		 		if (!bState || (i < nStart || i > nEnd) &&
		 			(_rgData.Get(i)._fSelected != 0))
		 		{
		 			// Only send a unselect message if the item
		 			// is viewable
		 			_rgData[i]._fSelected = 0;
			 		if (IsItemViewable(i))
			 			LbDrawItemNotify(hdc, i, ODA_SELECT, 0);			 		
			 	}
		 	}
		}

		if (bState)
		{
			// We need to loop through and notify the parent
			// The item has been deselected or selected
			for (int i = max(0, nStart); i <= nEnd; i++)
			{		
				if (_rgData.Get(i)._fSelected != 1)
				{
					_rgData[i]._fSelected = 1;
					if (IsItemViewable(i))
						LbDrawItemNotify(hdc, i, ODA_SELECT, ODS_SELECTED);					
				}
			}
		}
		
	}
	else if (!nSame)
	{
		// Update our internal records	
		for (int i = max(0, nStart); i <= nEnd; i++)
			_rgData[i]._fSelected = bState;	
		bRet = SetColors(dwFore, dwBack, nStart, nEnd);
	}

    // Update the cursor and anchor positions
	if (ffFlags & LBSEL_NEWANCHOR)
		_nAnchor = nAnchor;

	// Update the cursor position
	if (ffFlags & LBSEL_NEWCURSOR)
		_nCursor = nCursor;

	// Draw the focus rect
	if (_fFocus)
	{
		if (_fOwnerDraw)
 			LbDrawItemNotify(hdc, _nCursor, ODA_FOCUS, ODS_FOCUS | 
 				(IsSelected(_nCursor) ? ODS_SELECTED : 0));	
 		else
 		{
			LbGetItemRect(_nCursor, &rc);
	 		::DrawFocusRect(hdc, &rc);
	 	} 		
	}

	TxReleaseDC(hdc);
		
	// This will automatically update the window
	if (!_fOwnerDraw)
	{
		Unfreeze();
		// We need to do this because we are making so many changes
		// ITextServices might get confused
		ScrollToView(GetTopIndex());		
	}
	
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\line.cpp ===
/*
 *	LINE.CPP
 *	
 *	Purpose:
 *		CLine class
 *	
 *	Authors:
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_line.h"
#include "_measure.h"
#include "_render.h"
#include "_disp.h"
#include "_edit.h"

ASSERTDATA

/*
 *	CLine::Measure(&me, cchMax, xWidth, uiFlags, pliTarget)
 *
 *	@mfunc
 *		Computes line break (based on target device) and fills
 *		in this CLine with resulting metrics on rendering device
 *
 *	@rdesc 
 *		TRUE if OK
 *
 *	@devnote
 *		me is moved past line (to beginning of next line).  Note: CLock is
 *		needed in the main four routines (Measure, MeasureText, CchFromXPos,
 *		and RenderLine), since they use the global (shared) fc().GetCcs()
 *		facility and may use the LineServices global g_plsc and g_pols.
 */
BOOL CLine::Measure(
	CMeasurer& me,			//@parm Measurer pointing at text to measure
	LONG	   cchMax,		//@parm Max cch to measure
    LONG	   xWidth,		//@parm Width of line in device units
	UINT	   uiFlags,		//@parm Flags
	CLine *	   pliTarget)	//@parm Returns target-device line metrics (optional)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLine::Measure");

	CLock	lock;
	BOOL	fFirstInPara = uiFlags & MEASURE_FIRSTINPARA;
	BOOL	fMultiLine = me.GetPdp()->IsMultiLine();
	BOOL	fRet;

	if(fMultiLine && fFirstInPara && me.GetPrevChar() == VT)
	{
		fFirstInPara = FALSE;
		uiFlags &= ~MEASURE_FIRSTINPARA;
	}

	if(!(uiFlags & MEASURE_DONTINIT))
		me.NewLine(fFirstInPara);

	else if(fFirstInPara)
		me._li._bFlags |= fliFirstInPara;

	BYTE bNumber = me._wNumber < 256	// Store current para # offset
				 ? me._wNumber : 255;
	me._li._bNumber = bNumber;
	
#ifdef LINESERVICES
	CMeasurer *pmeSave;
	COls *	   pols = me.GetPols(&pmeSave);	// Try for LineServices object
	if(pols)								// Got it: use LineServices
	{
		fRet = pols->MeasureLine(xWidth, pliTarget);
		pols->SetMeasurer(pmeSave);			// Restore previous pme
	}
	else									// LineServices not active
#endif
		fRet = me.MeasureLine(cchMax, xWidth, uiFlags, pliTarget);

	if(!fRet)
		return FALSE;

	*this = me._li;							// Copy over line info

	if(!fMultiLine)							// Single-line controls can't
		return TRUE;						//  have paragraph numbering

	if(me.IsInOutlineView())
	{
		if(IsHeadingStyle(me._pPF->_sStyle))	// Store heading number if relevant
			_nHeading = (BYTE)(-me._pPF->_sStyle - 1);

		if(me._pPF->_wEffects & PFE_COLLAPSED)	// Cache collapsed bit
			_fCollapsed = TRUE;
	}

	_bNumber = bNumber;
	
	if(_bFlags & fliHasEOP)					// Check for new para number
	{
		const CParaFormat *pPF = me.GetPF();

		me._wNumber	  = (WORD)pPF->UpdateNumber(me._wNumber, me._pPF);
		_fNextInTable = pPF->InTable() && me.GetCp() < me.GetTextLength();
	}
	return TRUE;
}
	
/*
 *	CLine::Render(&re)
 *
 *	@mfunc
 *		Render visible part of this line
 *
 *	@rdesc
 *		TRUE iff successful
 *
 *	@devnote
 *		re is moved past line (to beginning of next line).
 *		FUTURE: the RenderLine functions return success/failure.
 *		Could do something on failure, e.g., be specific and fire
 *		appropriate notifications like out of memory.
 */
BOOL CLine::Render(
	CRenderer& re)			//@parm Renderer to use
{
	if(_fCollapsed)						// Line is collapsed in Outline view
	{
		re.Advance(_cch);				// Bypass line
		return TRUE;
	}

	BOOL	fRet;
	CLock	lock;
	POINT	pt = re.GetCurPoint();

#ifdef LINESERVICES
	CMeasurer *pmeSave;
	COls *pols = re.GetPols(&pmeSave);	// Try for LineServices object
	if(pols)
	{
		fRet = pols->RenderLine(*this);
		pols->SetMeasurer(pmeSave);		// Restore previous pme
	}
	else
#endif
		fRet = re.RenderLine(*this);

	pt.y += GetHeight();				// Advance to next line	position
	re.SetCurPoint(pt);
	return fRet;
}

/*
 *	CLine::CchFromXPos(&me, x, pdispdim, pHit)
 *
 *	@mfunc
 *		Computes cch corresponding to x position in a line.
 *		Used for hit testing.
 *
 *	@rdesc 
 *		cch found up to the x coordinate x	
 *
 *	@devnote
 *		me is moved to the cp at the cch offset returned
 */
LONG CLine::CchFromXpos(
	CMeasurer& me,		//@parm Measurer position at start of line
	POINT	 pt,		//@parm pt.x is x coord to search for
	CDispDim*pdispdim,	//@parm Returns display dimensions
	HITTEST *phit,		//@parm Returns hit type at x	
	LONG	*pcpActual) const //@parm actual CP above with display dimensions
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLine::CchFromXpos");
	
#ifdef Boustrophedon
	//if(_pPF->_wEffects & PFE_BOUSTROPHEDON)
	{
		RECT rcView;
		me.GetPed()->_pdp->GetViewRect(rcView, NULL);
		pt.x = rcView.right - pt.x;
	}
#endif
	CLock		lock;
	const BOOL	fFirst = _bFlags & fliFirstInPara;
	*phit =		HT_Text;
	LONG		cpActual = me.GetCp();
	CDispDim	dispdim;
	
	me._li = *this;
	me._li._cch = 0;					// Default zero count

	*phit = me.HitTest(pt.x);

	if(*phit == HT_Text || *phit == HT_RightOfText) // To right of left margin
	{
		me.NewLine(fFirst);

#ifdef LINESERVICES
		CMeasurer *pmeSave;
		COls *pols = me.GetPols(&pmeSave);// Try for LineServices object
		if(pols)						// Got it: use LineServices
		{
			pols->CchFromXpos(pt, &dispdim, &cpActual);
			pols->SetMeasurer(pmeSave);		// Restore previous pme
		}
		else
#endif
			if(me.Measure(pt.x - _xLeft, _cch,
						  MEASURE_BREAKBEFOREWIDTH | MEASURE_IGNOREOFFSET 
						  | (fFirst ? MEASURE_FIRSTINPARA : 0)) >= 0)
			{
				LONG xWidthBefore = me._li._xWidth;
				cpActual = me.GetCp();
				if (me._li._cch < _cch)
				{
					dispdim.dx = me._xAddLast;
					if (pt.x - _xLeft > xWidthBefore + dispdim.dx / 2)
					{
						me.Advance(1);
						me._li._cch++;
						me._li._xWidth += dispdim.dx;
					}
				}
			}

		me._rpCF.AdjustBackward();
		DWORD dwEffects = me.GetCF()->_dwEffects;
		if(dwEffects & CFE_LINK)
			*phit = HT_Link;
		else if(dwEffects & CFE_ITALIC)
			*phit = HT_Italic;

#ifdef UNICODE_SURROGATES
		// Until we support UTF-16 surrogate characters, don't allow hit in
		// middle of a surrogate pair
		if(IN_RANGE(0xDC00, me.GetChar(), 0xDFFF))
		{										
			me.Advance(1);						
			me._li._cch++;							
		}											
#endif
	}

	if (pdispdim)
		*pdispdim = dispdim;
	if (pcpActual)
		*pcpActual = cpActual;

	return me._li._cch;
}

/*
 *	CLine::XposFromCch(&me, cch, taMode, pdispdim, pdy)
 *
 *	@mfunc
 *		Measures cch characters starting from this text ptr, returning
 *		the width measured and setting yOffset = y offset relative to
 *		top of line and dx = halfwidth of character at me.GetCp() + cch.
 *		Used for caret placement and object location. pdx returns offset
 *		into the last char measured (at me.GetCp + cch) if taMode includes
 *		TA_CENTER (dx = half the last char width) or TA_RIGHT (dx = whole
 *		char width). pdy returns the vertical offset relative to the top
 *		of the line if taMode includes TA_BASELINE or TA_BOTTOM.
 *
 *	@rdesc 
 *		width of measured text
 *
 *	@devnote
 *		me may be moved.  
 */
LONG CLine::XposFromCch(
	CMeasurer&	me,			//@parm Measurer pointing at text to measure
	LONG		cch,		//@parm Max cch to measure
	UINT		taMode,		//@parm Text-align mode
	CDispDim *	pdispdim,	//@parm display dimensions
	LONG *		pdy) const	//@parm dy offset due to taMode
{
	CLock	lock;
	LONG	xWidth;
	BOOL	fPols = FALSE;
	CDispDim dispdim;
	LONG	dy = 0;

#ifdef LINESERVICES
	CMeasurer *pmeSave;
	COls *pols = me.GetPols(&pmeSave);	// Try for LineServices object
	if(pols)
	{									// Got it: use LineServices
		if(cch)							
			taMode &= ~TA_STARTOFLINE;	// Not start of line
		if(cch != _cch)
			taMode &= ~TA_ENDOFLINE;	// Not end of line

		xWidth = pols->MeasureText(cch, taMode, &dispdim);
		pols->SetMeasurer(pmeSave);		// Restore previous pme
		fPols = TRUE;
	}
	else
#endif
		xWidth = me.MeasureText(cch) + _xLeft;

	if(taMode != TA_TOP)
	{
		// Check for vertical calculation request
		if(taMode & TA_BASELINE)			// Matches TA_BOTTOM and
		{									//  TA_BASELINE
			if(!_fCollapsed)
			{
				dy = _yHeight;
				AssertSz(_yHeight != -1, "control has no height; used to use default CHARFORMAT");
				if((taMode & TA_BASELINE) == TA_BASELINE)
					dy -= _yDescent;		// Need "== TA_BASELINE" to
			}								//  distinguish from TA_BOTTOM
		}
		// Check for horizontal calculation request
		if(taMode & TA_CENTER && !fPols)	// If align to center or right of
		{
			if (cch == 0)
				dispdim.dx = me.MeasureText(1) + _xLeft - xWidth;
			else
				dispdim.dx = me._xAddLast;		//  char, get char width
		}
	}

	if (!fPols)
	{
		if((taMode & TA_CENTER) == TA_CENTER)
			xWidth += dispdim.dx / 2;
		else if (taMode & TA_RIGHT)
			xWidth += dispdim.dx;
	}

	if (pdispdim)
		*pdispdim = dispdim;
	if (pdy)
		*pdy = dy;

	return xWidth;
}
	
/*
 *	CLine::GetHeight()
 *
 *	@mfunc
 *		Get line height unless in outline mode and collasped, in
 *		which case get 0.
 *
 *	@rdesc
 *		Line height (_yHeight), unless in outline mode and collapsed,
 *		in which case 0.
 */
LONG CLine::GetHeight() const
{
	return _fCollapsed ? 0 : _yHeight;
}

BOOL CLine::IsEqual(CLine& li)
{
	// CF - I dont know which one is faster
	// MS3 - CompareMemory is certainly smaller
	// return !CompareMemory (this, pli, sizeof(CLine) - 4);
	return _xLeft == li._xLeft &&
		   _xWidth == li._xWidth && 
		   _yHeight == li._yHeight &&
		   _yDescent == li._yDescent &&
			_cch == li._cch &&
		   _cchWhite == li._cchWhite;	
}


// =====================  CLinePtr: Line Run Pointer  ==========================


CLinePtr::CLinePtr(CDisplay *pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::CLinePtr");

	_pdp = pdp;
	_pLine = NULL;
	_pdp->InitLinePtr(* this);
}

void CLinePtr::Init (CLine & line)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::Init");

	_pRuns = 0;
	_pLine = &line;
	_iRun = 0;
	_ich = 0;
}

void CLinePtr::Init (CLineArray & line_arr)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::Init");

	_pRuns = (CRunArray *) & line_arr;
	_iRun = 0;
	_ich = 0;
}

void CLinePtr::RpSet(LONG iRun, LONG ich)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpSet");

	// See if this is a multi-line ptr
    if(_pRuns)
        CRunPtr<CLine>::SetRun(iRun, ich);
    else
    {
        // single line, just reinit and set _ich
        AssertSz(iRun == 0, "CLinePtr::RpSet() - single line and iRun != 0");
	    _pdp->InitLinePtr(* this);		//  to line 0
	    _ich = ich;
    }
}

// Move runptr by a certain number of cch/runs

BOOL CLinePtr::RpAdvanceCp(LONG cch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpAdvanceCp");

	// See if this is a multi-line ptr

	if(_pRuns)
		return (cch == CRunPtr<CLine>::AdvanceCp(cch));

	return RpAdvanceCpSL(cch);
}
	
BOOL CLinePtr::operator --(int)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::operator --");

	return _pRuns ? PrevRun() : OperatorPostDeltaSL(-1);
}

BOOL CLinePtr::operator ++(int)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::operator ++");

	return _pRuns ? NextRun() : OperatorPostDeltaSL(+1);
}

/*
 *	CLinePtr::RpAdvanceCpSL(cch)
 *
 *	@mfunc
 *		move this line pointer forward or backward on the line
 *
 *	@rdesc
 *		TRUE iff could advance cch chars within current line
 */
BOOL CLinePtr::RpAdvanceCpSL(
	LONG cch)	 //@parm signed count of chars to advance by
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpAdvanceCpSL");

	Assert(!_pRuns);
	
	if(!_pLine)
		return FALSE;

	_ich += cch;

	if(_ich < 0)
	{
		_ich = 0;
		return FALSE;
	}

	if(_ich > _pLine->_cch)
	{
		_ich = _pLine->_cch;
		return FALSE;
	}

	return TRUE;
}

/*
 *	CLinePtr::OperatorPostDeltaSL(Delta)
 *
 *	Purpose:
 *		Implement line-ptr ++ and -- operators for single-line case
 *
 *	Arguments:
 *		Delta	1 for ++ and -1 for --
 *
 *	Return:
 *		TRUE iff this line ptr is valid
 */
BOOL CLinePtr::OperatorPostDeltaSL(LONG Delta)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::OperatorPostDeltaSL");

	AssertSz(_iRun <= 1 && !_pRuns,
		"LP::++: inconsistent line ptr");

	if(_iRun == -Delta)						// Operation validates an
	{										//  invalid line ptr by moving
		_pdp->InitLinePtr(* this);			//  to line 0
		return TRUE;
	}
	
	_iRun = Delta;							// Operation invalidates this line
	_ich = 0;								//  ptr (if it wasn't already)

	return FALSE;
}

CLine *	CLinePtr::operator ->() const		
{
	return _pRuns ? (CLine *)_pRuns->Elem(_iRun) : _pLine;
}

CLine * CLinePtr::GetLine() const
{	
    return _pRuns ? (CLine *)_pRuns->Elem(_iRun) : _pLine;
}

CLine &	CLinePtr::operator *() const      
{	
    return *(_pRuns ? (CLine *)_pRuns->Elem(_iRun) : _pLine);
}

CLine & CLinePtr::operator [](LONG dRun)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::operator []");

	if(_pRuns)
		return *(CLine *)CRunPtr<CLine>::GetRun(dRun);

	AssertSz(dRun + _iRun == 0 ,
		"LP::[]: inconsistent line ptr");

	return  *(CLine *)CRunPtr<CLine>::GetRun(_iRun);
}

BOOL CLinePtr::IsValid() 
{ 
	return !_pRuns ? _pLine != NULL : CRunPtrBase::IsValid(); 
}

/*
 *	CLinePtr::RpSetCp(cp, fAtEnd)
 *
 *	Purpose	
 *		Set this line ptr to cp allowing for ambigous cp and taking advantage
 *		of _cpFirstVisible and _iliFirstVisible
 *
 *	Arguments:
 *		cp		position to set this line ptr to
 *		fAtEnd	if ambiguous cp:
 *				if fAtEnd = TRUE, set this line ptr to end of prev line;
 *				else set to start of line (same cp, hence ambiguous)
 *	Return:
 *		TRUE iff able to set to cp
 */
BOOL CLinePtr::RpSetCp(
	LONG cp,
	BOOL fAtEnd)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpSetCp");

	_ich = 0;
	if(!_pRuns)
	{
		// This is a single line so just go straight to the single
		// line advance logic. It is important to note that the
		// first visible character is irrelevent to the cp advance
		// for single line displays.
		return RpAdvanceCpSL(cp);
	}

	BOOL fRet;
	LONG cpFirstVisible = _pdp->GetFirstVisibleCp();

	if(cp > cpFirstVisible / 2)
	{											// cpFirstVisible closer than 0
		_iRun = _pdp->GetFirstVisibleLine();
		fRet = RpAdvanceCp(cp - cpFirstVisible);
	}
	else
		fRet = (cp == CRunPtr<CLine>::BindToCp(cp));	// Start from 0

	if(fAtEnd)									// Ambiguous-cp caret position
		AdjustBackward();						//  belongs at prev EOL

	return fRet;
}

/*
 *	CLinePtr::FindParagraph(fForward)
 *
 *	@mfunc	
 *		Move this line ptr to paragraph (fForward) ? end : start,
 *		and return change in cp
 *
 *	@rdesc
 *		change in cp
 */
LONG CLinePtr::FindParagraph(
	BOOL fForward)		//@parm TRUE move to para end; else to para start
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::FindParagraph");

	LONG	cch;
	CLine *	pLine = GetLine();

	if(!fForward)							// Go to para start
	{
		cch = 0;							// Default already at para start
		if (RpGetIch() != pLine->_cch ||
			!(pLine->_bFlags & fliHasEOP))	// It isn't at para start
		{
			cch = -RpGetIch();				// Go to start of current line
			while(!(pLine->_bFlags & fliFirstInPara) && (*this) > 0)
			{
				(*this)--;					// Go to start of prev line
				pLine = GetLine();
				cch -= pLine->_cch;			// Subtract # chars in line
			}
			_ich = 0;						// Leave *this at para start
		}
	}
	else									// Go to para end
	{
		cch = GetCchLeft();					// Go to end of current line

		while(((*this) < _pdp->LineCount() - 1 ||
				_pdp->WaitForRecalcIli((LONG)*this + 1))
			  && !((*this)->_bFlags & fliHasEOP))
		{
			(*this)++;						// Go to start of next line
			cch += (*this)->_cch;			// Add # chars in line
		}
		_ich = (*this)->_cch;				// Leave *this at para end
	}
	return cch;
}

/*
 *	CLinePtr::GetAdjustedLineLength
 *
 *	@mfunc	returns the length of the line _without_ EOP markers
 *
 *	@rdesc	LONG; the length of the line
 */
LONG CLinePtr::GetAdjustedLineLength()
{
	CLine * pline = GetLine();

	return pline->_cch - pline->_cchEOP;
}

/*
 *	CLinePtr::GetCchLeft()
 *
 *	@mfunc
 *		Calculate length of text left in run starting at the current cp.
 *		Complements GetIch(), which	is length of text up to this cp. 
 *
 *	@rdesc
 *		length of text so calculated
 */
LONG CLinePtr::GetCchLeft() const
{
	return _pRuns ? CRunPtrBase::GetCchLeft() : _pLine->_cch - _ich;
}

/*
 *	CLinePtr::GetNumber()
 *
 *	@mfunc
 *		Get paragraph number 
 *
 *	@rdesc
 *		paragraph number
 */
WORD CLinePtr::GetNumber()
{
	if(!IsValid())
		return 0;

	_pLine = GetLine();
	if(!_iRun && _pLine->_bNumber > 1)
		_pLine->_bNumber = 1;

	return _pLine->_bNumber;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\ime.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module ime.cpp -- support for Win95 IME API |
 *	
 *		Most everything to do with FE composition string editing passes
 *		through here.
 *	
 *	Authors: <nl>
 *		Jon Matousek <nl>
 *		Hon Wah Chan <nl>
 *		Justin Voskuhl <nl>
 * 
 *	History: <nl>
 *		10/18/1995		jonmat	Cleaned up level 2 code and converted it into
 *								a class hierarchy supporting level 3.
 *
 *	Copyright (c) 1995-1997 Microsoft Corporation. All rights reserved.
 */				
#include "_common.h"
#include "_cmsgflt.h"				 
#include "_ime.h"
#include "imeapp.h"

#define HAVE_COMPOSITION_STRING() ( 0 != (lparam & (GCS_COMPSTR | GCS_COMPATTR)))
#define CLEANUP_COMPOSITION_STRING() ( 0 == lparam )
#define HAVE_RESULT_STRING() ( 0 != (lparam & GCS_RESULTSTR))

ASSERTDATA

/*
 *	HRESULT StartCompositionGlue (CTextMsgFilter &TextMsgFilter)
 *	
 *	@func
 *		Initiates an IME composition string edit.
 *	@comm
 *		Called from the message loop to handle WM_IME_STARTCOMPOSITION.
 *		This is a glue routine into the IME object hierarchy.
 *
 *	@devnote
 *		We decide if we are going to do a level 2 or level 3 IME
 *		composition string edit. Currently, the only reason to 
 *		create a level 2 IME is if the IME has a special UI, or it is
 *		a "near caret" IME, such as the ones found in PRC and Taiwan.
 *		Near caret simply means that a very small window opens up
 *		near the caret, but not on or at the caret.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT StartCompositionGlue (
	CTextMsgFilter &TextMsgFilter)				// @parm containing message filter.

{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "StartCompositionGlue");

	if(TextMsgFilter.IsIMEComposition() && TextMsgFilter._ime->IsTerminated())
	{
		delete TextMsgFilter._ime;
		TextMsgFilter._ime = NULL;
	}

	if(!TextMsgFilter.IsIMEComposition())
	{
		if(TextMsgFilter._pTextSel->CanEdit(NULL) == NOERROR &&
			!(TextMsgFilter._lFEFlags & ES_NOIME))
		{
			// Hold notification if needed
			if (!(TextMsgFilter._fIMEAlwaysNotify))
				TextMsgFilter._pTextDoc->SetNotificationMode(tomFalse);	
	
			// If a special UI, or IME is "near caret", then drop into lev. 2 mode.
			DWORD imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_PROPERTY, TextMsgFilter._fUsingAIMM);
			
			// use Unicode if not running under Win95
			TextMsgFilter._fUnicodeIME =
				(imeProperties & IME_PROP_UNICODE) && !W32->OnWin95();

			if ((imeProperties & IME_PROP_SPECIAL_UI) ||
				!(imeProperties & IME_PROP_AT_CARET))
			{
				TextMsgFilter._ime = new CIme_Lev2(TextMsgFilter);		// level 2 IME.
			}
			else
				TextMsgFilter._ime = new CIme_Lev3(TextMsgFilter);		// level 3 IME->TrueInline.
		}
		else													// Protect or read-only or NOIME:
			TextMsgFilter._ime = new CIme_Protected;			// Ignore all ime input
	}
	else
	{
		// Ignore further StartCompositionMsg.
		// Hanin 5.1 CHT symbol could cause multiple StartCompoisitonMsg.
		return S_OK;								
	}

	if(TextMsgFilter.IsIMEComposition())					
	{
		long		lSelFlags;
		HRESULT		hResult;
		
		hResult = TextMsgFilter._pTextSel->GetFlags(&lSelFlags);
		if (hResult == NOERROR)
		{
			TextMsgFilter._fOvertypeMode = !!(lSelFlags & tomSelOvertype);		
			if (TextMsgFilter._fOvertypeMode)
				TextMsgFilter._pTextSel->SetFlags(lSelFlags & ~tomSelOvertype);	// Turn off overtype mode
		}
		
		TextMsgFilter._pTextDoc->IMEInProgress(tomTrue);				// Inform client IME compostion in progress

		return TextMsgFilter._ime->StartComposition(TextMsgFilter);		// Make the method call.
	}
	else
		TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);

	
	return S_FALSE;
}

/*
 *	HRESULT CompositionStringGlue (const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *	
 *	@func
 *		Handle all intermediary and final composition strings.
 *
 *	@comm
 *		Called from the message loop to handle WM_IME_COMPOSITION.
 *		This is a glue routine into the IME object hierarchy.
 *		We may be called independently of a WM_IME_STARTCOMPOSITION
 *		message, in which case we return S_FALSE to allow the
 *		DefWindowProc to return WM_IME_CHAR messages.
 *
 *	@devnote
 *		Side Effect: the _ime object may be deleted if composition
 *		string processing is finished.
 *		
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CompositionStringGlue (
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CompositionStringGlue");

	HRESULT hr = S_FALSE;

	if(TextMsgFilter.IsIMEComposition())						// A priori fHaveIMMProcs.
	{
		TextMsgFilter._ime->_compMessageRefCount++;			// For proper deletion.
													// Make the method call.
		hr = TextMsgFilter._ime->CompositionString(lparam, TextMsgFilter);

		TextMsgFilter._ime->_compMessageRefCount--;			// For proper deletion.
		Assert (TextMsgFilter._ime->_compMessageRefCount >= 0);

		CheckDestroyIME (TextMsgFilter);						// Finished processing?
	}
	else // even when not in composition mode, we may receive a result string.
	{
	
		DWORD imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_PROPERTY, TextMsgFilter._fUsingAIMM);
		long		lSelFlags;
		HRESULT		hResult;
		long		cpMin, cpMax;

		TextMsgFilter._pTextDoc->IMEInProgress(tomTrue);				// Inform client IME compostion in progress

		hResult = TextMsgFilter._pTextSel->GetFlags(&lSelFlags);
		if (hResult == NOERROR)
		{
			TextMsgFilter._fOvertypeMode = !!(lSelFlags & tomSelOvertype);		
			if (TextMsgFilter._fOvertypeMode)
				TextMsgFilter._pTextSel->SetFlags(lSelFlags & ~tomSelOvertype);	// Turn off overtype mode
		}

		// use Unicode if not running under Win95
		TextMsgFilter._fUnicodeIME =
			(imeProperties & IME_PROP_UNICODE) && !W32->OnWin95();
		
		TextMsgFilter._pTextSel->GetStart(&cpMin);
		TextMsgFilter._pTextSel->GetEnd(&cpMax);
		
		if (cpMin != cpMax)			
			TextMsgFilter._pTextSel->SetText(NULL);							// Delete current selection

		CIme::CheckKeyboardFontMatching (cpMin, TextMsgFilter, NULL);
		hr = CIme::CheckInsertResultString(lparam, TextMsgFilter);

		if(TextMsgFilter._fOvertypeMode)
			TextMsgFilter._pTextSel->SetFlags(lSelFlags | tomSelOvertype);	// Turn on overtype mode

		TextMsgFilter._pTextDoc->IMEInProgress(tomFalse);					// Inform client IME compostion is done
	}

	return hr;
}

/*
 *	HRESULT EndCompositionGlue (CTextMsgFilter &TextMsgFilter, BOOL fForceDelete)
 *
 *	@func
 *		Composition string processing is about to end.
 *
 *	@comm
 *		Called from the message loop to handle WM_IME_ENDCOMPOSITION.
 *		This is a glue routine into the IME object hierarchy.
 *
 *	@devnote
 *		The only time we have to handle WM_IME_ENDCOMPOSITION is when the
 *		user changes input method during typing.  For such case, we will get
 *		a WM_IME_ENDCOMPOSITION message without getting a WM_IME_COMPOSITION
 *		message with GCS_RESULTSTR later.  So, we will call CompositionStringGlue
 *		with GCS_RESULTSTR to let CompositionString to get rid of the string. 
 *		
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT EndCompositionGlue (
	CTextMsgFilter &TextMsgFilter,				// @parm the containing message filter.
	BOOL fForceDelete)							// @parm forec to terminate
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "EndCompositionGlue");

	if(TextMsgFilter.IsIMEComposition())
	{
		// ignore the EndComposition message if necessary.  We may 
		// get this from 3rd party IME - EGBRIGDE after we have received
		// both result and composition strings.  
		if ( !(TextMsgFilter._ime->_fIgnoreEndComposition) )
		{
			// Set this flag. If we are still in composition mode, then
			// let the CompositionStringGlue() to destroy the ime object.
			TextMsgFilter._ime->_fDestroy = TRUE;

			if (!fForceDelete)				
				CompositionStringGlue(GCS_COMPSTR , TextMsgFilter);	// Remove any remaining composition string.

			// Finished with IME, destroy it.
			CheckDestroyIME(TextMsgFilter);

			// Turn on undo
			TextMsgFilter._pTextDoc->Undo(tomResume, NULL);

			// Inform client IME compostion is done
			TextMsgFilter._pTextDoc->IMEInProgress(tomFalse);				
		}
		else
		{
			// reset this so we will handle next EndComp msg
			TextMsgFilter._ime->_fIgnoreEndComposition = FALSE;
		}

		if(!TextMsgFilter.IsIMEComposition() && TextMsgFilter._fOvertypeMode)
		{
			long		lSelFlags;
			HRESULT		hResult;
			ITextSelection	*pLocalTextSel = TextMsgFilter._pTextSel;
			BOOL		fRelease = FALSE;

			if (!pLocalTextSel)
			{
				// Get the selection
				TextMsgFilter._pTextDoc->GetSelectionEx(&pLocalTextSel);
				fRelease = TRUE;
			}

			if (pLocalTextSel)
			{
				hResult = pLocalTextSel->GetFlags(&lSelFlags);
				if (hResult == NOERROR)
					pLocalTextSel->SetFlags(lSelFlags | tomSelOvertype);	// Turn on overtype mode

				if (fRelease)
					pLocalTextSel->Release();
			}
		}
	}
	return S_FALSE;
}

/*
 *	HIMC LocalGetImmContext ( CTextMsgFilter &TextMsgFilter )
 *
 *	@func
 *		Get Imm Context from host 
 *
 */
HIMC LocalGetImmContext(
	CTextMsgFilter &TextMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEMessage");
	
	HIMC		hIMC = NULL;							// Host's IME context.
	HRESULT		hResult;

	hResult = TextMsgFilter._pTextDoc->GetImmContext((long *)&hIMC);

	if (hResult != NOERROR)
		hIMC = ImmGetContext(TextMsgFilter._hwnd);		// Get host's IME context.

	return hIMC;	
}

/*
 *	void LocalReleaseImmContext ( CTextMsgFilter &TextMsgFilter, HIMC hIMC )
 *
 *	@func
 *		call host to Release Imm Context
 *
 */
void LocalReleaseImmContext(
	CTextMsgFilter &TextMsgFilter, 
	HIMC hIMC )
{
	HRESULT		hResult;

	hResult = TextMsgFilter._pTextDoc->ReleaseImmContext((long)hIMC);

	if (hResult != NOERROR)
		ImmReleaseContext(TextMsgFilter._hwnd, hIMC);
}

/*
 *	long IMEShareToTomUL ( UINT ulID )
 *
 *	@func
 *		Convert IMEShare underline to Tom underline.
 *
 *	@rdesc
 *		Tom underline value
 */
long IMEShareToTomUL ( 
	UINT ulID )
{
	long lTomUnderline;

	switch (ulID)
	{
		case IMESTY_UL_NONE:
			lTomUnderline = tomNone;
			break;

		case IMESTY_UL_DOTTED:
			lTomUnderline = tomDotted;
			break;

		case IMESTY_UL_THICK:
		case IMESTY_UL_THICKLOWER:
			lTomUnderline = tomThick;
			break;

		case IMESTY_UL_DITHLOWER:
		case IMESTY_UL_THICKDITHLOWER:
			lTomUnderline = tomWave;
			break;

		// case IMESTY_UL_SINGLE:
		// case IMESTY_UL_LOWER:
		default:
			lTomUnderline = tomSingle;
			break;
	}

	return lTomUnderline;
}

/*
 *	void IMEMessage (CTextMsgFilter &TextMsgFilter , UINT uMsg, BOOL bPostMessage)
 *
 *	@func
 *		Either post or send message to IME 
 *
 */
BOOL IMEMessage(
	CTextMsgFilter &TextMsgFilter,
	UINT uMsg,
	WPARAM	wParam,
	LPARAM	lParam,
	BOOL bPostMessage)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEMessage");
	
	HIMC	hIMC;									// Host's IME context.
	HWND	hwndIME;
	BOOL	retCode = FALSE;
	HWND	hHostWnd = TextMsgFilter._hwnd;
	long	hWnd;

	if (!hHostWnd)									// Windowless mode...
	{		
		if (TextMsgFilter._pTextDoc->GetWindow(&hWnd) != S_OK || !hWnd)
			return FALSE;
		hHostWnd = (HWND)(DWORD_PTR)hWnd;
	}

	hIMC = LocalGetImmContext(TextMsgFilter);		// Get host's IME context.

	if(hIMC)
	{
		hwndIME = ImmGetDefaultIMEWnd(hHostWnd, TextMsgFilter._fUsingAIMM);
		LocalReleaseImmContext(TextMsgFilter, hIMC);

		// check if we want to send or post message
		if (hwndIME)
		{
			if (bPostMessage)
				retCode = PostMessage(hwndIME, uMsg, wParam, lParam);
			else
				retCode = SendMessage(hwndIME, uMsg, wParam, lParam);
		}
	}

	return retCode;
}


/*
 *	void CheckDestroyIME (CTextMsgFilter &TextMsgFilter)
 *
 *	@func
 *		Check for IME and see detroy if it needs it..
 *
 */
void CheckDestroyIME (
	CTextMsgFilter &TextMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CheckDestroyIME");
	
	if(TextMsgFilter.IsIMEComposition() && TextMsgFilter._ime->_fDestroy)
	{
		if(0 == TextMsgFilter._ime->_compMessageRefCount)
		{
			if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)	
			{
				TextMsgFilter._pTextDoc->SetCaretType(tomNormalCaret);		// Reset Block caret mode	
				TextMsgFilter._fHangulToHanja = FALSE;					// Reset korean conversion mode
			}

		 	delete TextMsgFilter._ime;									// All done with object.
			TextMsgFilter._ime = NULL;

			TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);		// Turn on Notification
		}
	}
}

/*
 *	void PostIMECharGlue (CTextMsgFilter &TextMsgFilter)
 *
 *	@func
 *		Called after processing a single WM_IME_CHAR in order to
 *		update the position of the IME's composition window. This
 *		is glue code to call the CIME virtual equivalent.
 */
void PostIMECharGlue (
	CTextMsgFilter &TextMsgFilter)				// @parm containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "PostIMECharGlue");

	if(TextMsgFilter.IsIMEComposition())
		TextMsgFilter._ime->PostIMEChar(TextMsgFilter);
}

/*
 *	BOOL	IMEMouseCheck(CTextMsgFilter &TextMsgFilter, UINT *pmsg, 
 *				WPARAM *pwparam, LPARAM *plparam, LRESULT *plres)
 *
 *	@func
 *		Called when receiving a mouse event.  Need to pass this event
 *		to MSIME98 for composition handling
 *
 */
HRESULT IMEMouseCheck(
	CTextMsgFilter &TextMsgFilter,	// @parm MsgFilter
	UINT *pmsg,						// @parm the message 
	WPARAM *pwparam,				// @parm WParam
	LPARAM *plparam,				// @parm LParam
	LRESULT *plres)					// @parm Lresult			
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEMouseCheck");

	BOOL retCode = FALSE;
	if(TextMsgFilter.IsIMEComposition())
	{
		retCode = TextMsgFilter._ime->IMEMouseOperation(TextMsgFilter, *pmsg);

		if ( retCode == FALSE && WM_MOUSEMOVE != *pmsg )
			TextMsgFilter._ime->TerminateIMEComposition(TextMsgFilter, CIme::TERMINATE_NORMAL);
	}

	return retCode ? S_OK : S_FALSE;
}

/*
 *	HRESULT IMENotifyGlue (const WPARAM wparam, const LPARAM lparam,
 *				CTextMsgFilter &TextMsgFilter)
 *
 *	@func
 *		IME is going to change some state.
 *
 *	@comm
 *		Currently we are interested in knowing when the candidate
 *		window is about to be opened.
 *		
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT IMENotifyGlue (
	const WPARAM wparam,		// @parm associated with message.
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMENotifyGlue");

	if (TextMsgFilter._fRE10Mode &&
		(wparam == IMN_SETCONVERSIONMODE ||
		wparam == IMN_SETSENTENCEMODE ||
		wparam == IMN_SETOPENSTATUS))
	{
		TextMsgFilter._pTextDoc->Notify(EN_IMECHANGE);			
	}
	else if(TextMsgFilter.IsIMEComposition())						// A priori fHaveIMMProcs.
		return TextMsgFilter._ime->IMENotify(wparam, lparam, TextMsgFilter, FALSE);// Make the method call
	
	return S_FALSE;
}

/*
 *	void IMECompositionFull (&TextMsgFilter)
 *
 *	@func
 *		Current IME Composition window is full.
 *
 *	@comm
 *		Called from the message loop to handle WM_IME_COMPOSITIONFULL.
 *		This message applied to Level 2 only.  We will use the default 
 *		IME Composition window.
 */
void IMECompositionFull (
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMECompositionFull");

	if(TextMsgFilter.IsIMEComposition())
	{
		HIMC 				hIMC	= LocalGetImmContext(TextMsgFilter);
		COMPOSITIONFORM		cf;

		if(hIMC)
		{																									 
			// No room for text input in the current level 2 IME window, 
			// fall back to use the default IME window for input.
			cf.dwStyle = CFS_DEFAULT;
			ImmSetCompositionWindow(hIMC, &cf, TextMsgFilter._fUsingAIMM);	// Set composition window.
			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.
		}
 	}
}

/*
 *	LRESULT OnGetIMECompositionMode (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Returns whether or not IME composition is being handled by RE,
 *		and if so, what level of processing.
 *		
 *	@rdesc
 *		One of ICM_NOTOPEN, ICM_LEVEL2_5, ICM_LEVEL2_SUI, ICM_LEVEL2, ICM_LEVEL3.
 */
LRESULT OnGetIMECompositionMode (
	CTextMsgFilter &TextMsgFilter)	  	// @parm containing message filter.
{
	LRESULT lres = ICM_NOTOPEN;

	if(TextMsgFilter.IsIMEComposition())
	{
		if(IME_LEVEL_2 == TextMsgFilter._ime->_imeLevel)
		{
			DWORD imeProperties;

			imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_PROPERTY, TextMsgFilter._fUsingAIMM);
			if(imeProperties & IME_PROP_AT_CARET)
				lres = ICM_LEVEL2_5;				// level 2.5.
			else if	(imeProperties & IME_PROP_SPECIAL_UI)
				lres = ICM_LEVEL2_SUI;				// special UI.
			else
				lres = ICM_LEVEL2;					// stock level 2.
		}
		else if(IME_LEVEL_3 == TextMsgFilter._ime->_imeLevel) 
			lres = ICM_LEVEL3;
	}

	return lres;
}


/*
 *	void CIme::CheckKeyboardFontMatching (long cp, CTextMsgFilter &TextMsgFilter, ITextFont	*pTextFont)
 *	
 *	@mfunc
 *		Setup current font to matches the keyboard Codepage.
 *
 *	@comm
 *		Called from CIme_Lev2::CIme_Lev2 and CompositionStringGlue
 *
 *	@devnote
 *		We need to switch to a preferred font for the keyboard during IME input.
 *		Otherwise, we will display garbage.
 *		
 */
void CIme::CheckKeyboardFontMatching (
	long cp,
	CTextMsgFilter &TextMsgFilter, 
	ITextFont	*pTextFont)
{
	long	lPitchAndFamily;
	HRESULT	hResult;
	BSTR	bstr = NULL;
	long	lValue;
	long	lNewFontSize=0;
	float	nFontSize;
	ITextFont *pLocalFont = NULL;


	if (!pTextFont)
	{	
		// No font supplied, get current font from selection
		hResult = TextMsgFilter._pTextSel->GetFont(&pLocalFont);			
		
		if (hResult != S_OK || !pLocalFont)		// Can't get font, forget it
			return;			

		pTextFont = pLocalFont;
	}

	// Check if current font matches the keyboard
	lValue = tomCharset;
	hResult = pTextFont->GetLanguageID(&lValue);

	if (hResult == S_OK)
		if ((BYTE)(lValue) == (BYTE)GetCharSet(TextMsgFilter._uKeyBoardCodePage))
			goto Exit;								// Current font is fine

	hResult = pTextFont->GetSize(&nFontSize);

	if (hResult != S_OK)
		goto Exit;

	hResult = TextMsgFilter._pTextDoc->GetPreferredFont(cp, 
		TextMsgFilter._uKeyBoardCodePage, tomMatchFontCharset, 
		GetCodePage((BYTE)(lValue)), (long)nFontSize,
		&bstr, &lPitchAndFamily, &lNewFontSize);

	if (hResult == S_OK)
	{			
		if (bstr)
			pTextFont->SetName(bstr);

		// Set the font charset and Pitch&Family by overloading the SetLanguageID i/f			
		lValue = tomCharset + (((BYTE)lPitchAndFamily) << 8) + 
			(BYTE)GetCharSet(TextMsgFilter._uKeyBoardCodePage);

		pTextFont->SetLanguageID(lValue);				
		
		if (lNewFontSize)
			pTextFont->SetSize((float)lNewFontSize);
	}

Exit:
	if (pLocalFont)
			pLocalFont->Release();
	
	if (bstr)
		SysFreeString(bstr);
}

/*
 *	INT CIme::GetCompositionStringInfo(HIMC hIMC, DWORD dwIndex,
 *			  WCHAR *szCompStr, INT cchMax, BYTE *attrib, INT cbAttrib
 *			  LONG cchAttrib, UINT kbCodePage, BOOL bUnicodeIME)
 *
 *	@mfunc
 *		For WM_IME_COMPOSITION string processing to get the requested
 *		composition string, by type, and convert it to Unicode.
 *
 *	@devnote
 *		We must use ImmGetCompositionStringA because W is not supported
 *		on Win95.
 *		
 *	@rdesc
 *		INT-cch of the Unicode composition string.
 *		Out param in szCompStr.
 */
INT CIme::GetCompositionStringInfo(
	HIMC hIMC,			// @parm IME context provided by host.
	DWORD dwIndex,		// @parm The type of composition string.
	WCHAR *szCompStr,	// @parm Out param, unicode result string.
	INT cchMax,			// @parm The cch for the Out param.
	BYTE *attrib,		// @parm Out param, If attribute info is needed.
	INT cbMax,			// @parm The cb of the attribute info.
	LONG *cpCursor,		// @parm Out param, returns the CP of cusor.
	LONG *cchAttrib,	// @parm how many attributes returned.
	UINT kbCodePage,	// @parm codepage
	BOOL bUnicodeIME,	// @parm Unciode IME
	BOOL bUsingAimm)	// @parm Using Aimm
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::GetCompositionStringInfo");

	BYTE	compStr[256], attribInfo[256];
	INT		i, j, iMax, cchCompStr=0, cbAttrib, cursor;
	INT		cchAnsiCompStr=0;

	Assert(hIMC && szCompStr);

	if(cpCursor)									// Init cursor out param.
		*cpCursor = -1;
	if(cchAttrib)
		*cchAttrib = 0;
	
													// Get composition string.
	if (bUnicodeIME)
		cchCompStr = ImmGetCompositionStringW(hIMC, dwIndex, szCompStr, cchMax, bUsingAimm )/sizeof(WCHAR);
	else
		cchAnsiCompStr = ImmGetCompositionStringA(hIMC, dwIndex, compStr, 255, bUsingAimm);

	if(cchAnsiCompStr > 0 || cchCompStr > 0)		// If valid data.
	{
		if (!bUnicodeIME)
		{
			Assert(cchAnsiCompStr >> 1 < cchMax - 1);		// Convert to Unicode.
			cchCompStr = UnicodeFromMbcs(szCompStr, cchMax,
					(CHAR *) compStr, cchAnsiCompStr, kbCodePage);
		}

		if(attrib || cpCursor)						// Need cursor or attribs?
		{			
			if (bUnicodeIME)
			{										// Get Unicode Cursor cp.
				cursor = ImmGetCompositionStringW(hIMC, GCS_CURSORPOS, NULL, 0, bUsingAimm);
													// Get Unicode attributes.
				cbAttrib = ImmGetCompositionStringW(hIMC, GCS_COMPATTR,
								attribInfo, 255, bUsingAimm);

				iMax = max(cursor, cbAttrib);
				iMax = min(iMax, cchCompStr);
			}
			else
			{										// Get DBCS Cursor cp.
				cursor = ImmGetCompositionStringA(hIMC, GCS_CURSORPOS, NULL, 0, bUsingAimm);
													// Get DBCS attributes.
				cbAttrib = ImmGetCompositionStringA(hIMC, GCS_COMPATTR,
								attribInfo, 255, bUsingAimm);

				iMax = max(cursor, cbAttrib);
				iMax = min(iMax, cchAnsiCompStr);
			}

			if(NULL == attrib)
				cbMax = cbAttrib;

			for(i = 0, j = 0; i <= iMax && j < cbMax; i++, j++)
			{
				if(cursor == i)
					cursor = j;

				if(!bUnicodeIME && GetTrailBytesCount(compStr[i], kbCodePage))
					i++;

				if(attrib && i < cbAttrib)
					*attrib++ = attribInfo[i];
			}
													// attrib cch==unicode cch
			Assert(0 >= cbAttrib || j-1 == cchCompStr);

			if(cursor >= 0 && cpCursor)				// If client needs cursor
				*cpCursor = cursor;					//  or cchAttrib.
			if(cbAttrib >= 0 && cchAttrib)
				*cchAttrib = j-1;
		}
	}
	else
	{
		if(cpCursor)			
			*cpCursor = 0;
		cchCompStr = 0;
	}
	return cchCompStr;
}

/*
 *	void CIme::SetCompositionFont (CTextMsgFilter &TextMsgFilter, ITextFont *pTextFont)
 *
 *	@mfunc
 *		Important for level 2 IME so that the composition window
 *		has the correct font. The lfw to lfa copy is due to the fact that
 *		Win95 does not support the W)ide call.
 *		It is also important for both level 2 and level 3 IME so that
 *		the candidate list window has the proper. font.
 */
void CIme::SetCompositionFont (
	CTextMsgFilter &TextMsgFilter,		// @parm the containing message filter.
	ITextFont *pTextFont) 		 		// @parm ITextFont for setting lfa.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::SetCompositionFont");
	
	HIMC 		hIMC;
	LOGFONTA	lfa;

	if (pTextFont)
	{
		hIMC = LocalGetImmContext(TextMsgFilter);
		if (hIMC)
		{
			// Build the LOGFONT based on pTextFont
			float	FontSize;
			long	lValue;
			BSTR	bstr;

			memset (&lfa, 0, sizeof(lfa));

			if (pTextFont->GetSize(&FontSize) == NOERROR)			
				lfa.lfHeight = (LONG) FontSize;			
			
			if (pTextFont->GetBold(&lValue) == NOERROR && lValue == tomTrue)
				lfa.lfWeight = FW_BOLD;

			if (pTextFont->GetItalic(&lValue) == NOERROR && lValue == tomTrue)
				lfa.lfItalic = TRUE;

			lfa.lfCharSet = (BYTE)GetCharSet(TextMsgFilter._uKeyBoardCodePage);

			lValue = tomCharset;
			if (pTextFont->GetLanguageID(&lValue) == NOERROR && 
				lfa.lfCharSet == (BYTE)lValue)
				lfa.lfPitchAndFamily = (BYTE)(lValue >> 8);

			if (pTextFont->GetName(&bstr) == NOERROR)
			{
				MbcsFromUnicode(lfa.lfFaceName, sizeof(lfa.lfFaceName), bstr,
					-1, CP_ACP, UN_NOOBJECTS);	

				SysFreeString(bstr);
			}

			ImmSetCompositionFontA( hIMC, &lfa, TextMsgFilter._fUsingAIMM );

			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.		
		}
	}
}

/*
 *	void CIme::SetCompositionForm (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Important for level 2 IME so that the composition window
 *		is positioned correctly. 
 *
 *	@comm
 *		We go through a lot of work to get the correct height. This requires
 *		getting information from the font cache and the selection.
 */
void CIme::SetCompositionForm (
	CTextMsgFilter &TextMsgFilter)	   	// @parm the containing text edit.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::SetCompositionForm");

	HIMC 				hIMC;
	COMPOSITIONFORM		cf;

	if(IME_LEVEL_2 == GetIMELevel())
	{
		hIMC = LocalGetImmContext(TextMsgFilter);					// Get IME context.
		
		if(hIMC)
		{				
			// get the location of cpMin
			cf.ptCurrentPos.x = cf.ptCurrentPos.y = 0;
			TextMsgFilter._pTextSel->GetPoint( tomStart+tomClientCoord+TA_BOTTOM+TA_LEFT,
				&(cf.ptCurrentPos.x), &(cf.ptCurrentPos.y) );			
			
			// Set-up bounding rect. for the IME (lev 2) composition window, causing
			// composition text to be wrapped within it.
			cf.dwStyle = CFS_RECT;
			TextMsgFilter._pTextDoc->GetClientRect(tomIncludeInset+tomClientCoord,
				&(cf.rcArea.left), &(cf.rcArea.top),
				&(cf.rcArea.right), &(cf.rcArea.bottom));		 

			// Make sure the starting point is not
			// outside the rcArea.  This happens when
			// there is no text on the current line and the user 
			// has selected a large font size.
			if(cf.ptCurrentPos.y < cf.rcArea.top)
				cf.ptCurrentPos.y = cf.rcArea.top;
			else if(cf.ptCurrentPos.y > cf.rcArea.bottom)
				cf.ptCurrentPos.y = cf.rcArea.bottom; 

			if(cf.ptCurrentPos.x < cf.rcArea.left)
				cf.ptCurrentPos.x = cf.rcArea.left;
			else if(cf.ptCurrentPos.x > cf.rcArea.right)
				cf.ptCurrentPos.x = cf.rcArea.right;

			ImmSetCompositionWindow(hIMC, &cf, TextMsgFilter._fUsingAIMM);	// Set composition window.

			LocalReleaseImmContext(TextMsgFilter, hIMC);				// Done with IME context.
		}
	}
}



/*
 *
 *	CIme::TerminateIMEComposition (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc	Terminate the IME Composition mode using CPS_COMPLETE
 *	@comm	The IME will generate WM_IME_COMPOSITION with the result string
 * 
 */
void CIme::TerminateIMEComposition(
	CTextMsgFilter &TextMsgFilter, 			// @parm the containing message filter.
	TerminateMode mode)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::TerminateIMEComposition");
	DWORD dwTerminateMethod;

	HIMC hIMC = LocalGetImmContext(TextMsgFilter);

	if(TextMsgFilter.IsIMEComposition() && TextMsgFilter._ime->IsTerminated())
	{
		// Turn if off now
		EndCompositionGlue(TextMsgFilter, TRUE);
		return;
	}

	_fIMETerminated = TRUE;

	if (mode == TERMINATE_FORCECANCEL)
		TextMsgFilter._pTextDoc->IMEInProgress(tomFalse);		// Inform client IME compostion is done

	dwTerminateMethod = CPS_COMPLETE;
	if (IME_LEVEL_2 == GetIMELevel()  ||	// force cancel for near-caret IME
		mode == TERMINATE_FORCECANCEL ||	// caller wants force cancel
		TextMsgFilter._fIMECancelComplete)				// Client wants force cancel
	{
		dwTerminateMethod = CPS_CANCEL;
	}
	
	// force the IME to terminate the current session
	if(hIMC)
	{
		BOOL retCode;

		retCode = ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, 
			dwTerminateMethod, 0, TextMsgFilter._fUsingAIMM);
		
		if(!retCode && !TextMsgFilter._fIMECancelComplete)
		{
			// CPS_COMPLETE fail, try CPS_CANCEL.  This happen with some ime which do not support
			// CPS_COMPLETE option (e.g. ABC IME version 4 with Win95 simplified Chinese)
			retCode = ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_CANCEL, 0, TextMsgFilter._fUsingAIMM);

		}

		LocalReleaseImmContext(TextMsgFilter, hIMC);
	}
	else
	{
		// for some reason, we didn't have a context, yet we thought we were still in IME
		// compostition mode.  Just force a shutdown here.
		EndCompositionGlue(TextMsgFilter, TRUE);
	}
}


/*
 *	CIme_Lev2::CIme_Lev2()
 *
 *	@mfunc
 *		CIme_Lev2 Constructor/Destructor.
 *
 *	@comm
 *		Needed to make sure _iFormatSave was handled properly.
 *
 */
CIme_Lev2::CIme_Lev2(	
	CTextMsgFilter &TextMsgFilter)		// @parm the containing message filter.
{
	long		cpMin, cpMax, cpLoc;
	HRESULT		hResult;
	ITextFont	*pCurrentFont = NULL;

	_pTextFont = NULL;
	_cIgnoreIMECharMsg = 0;

	// setup base Font format for later use during composition
	hResult	= TextMsgFilter._pTextSel->GetStart(&cpMin);
	cpLoc = cpMin;	

	if (TextMsgFilter._fHangulToHanja)
		cpMax = cpMin + 1;				// Select the Hangul character
	else
		hResult	= TextMsgFilter._pTextSel->GetEnd(&cpMax);

	_fSkipFirstOvertype = FALSE;
	if (cpMax != cpMin)
	{
		// selection case, get format for at cpMin
		ITextRange *pTextRange;
		HRESULT		hResult;
				
		hResult = TextMsgFilter._pTextDoc->Range(cpMin, cpMin+1, &pTextRange);
		Assert (pTextRange != NULL);
		
		if (hResult == NOERROR && pTextRange)
		{
			pTextRange->GetFont(&pCurrentFont);
			Assert(pCurrentFont != NULL);		
			pTextRange->Release();
			cpLoc = cpMin+1;
		}	

		if (!TextMsgFilter._fHangulToHanja)
			_fSkipFirstOvertype = TRUE;			// For Korean Overtype support
	}
	
	if (!pCurrentFont)
		TextMsgFilter._pTextSel->GetFont(&pCurrentFont);

	Assert(pCurrentFont != NULL);

	pCurrentFont->GetDuplicate(&_pTextFont);		// duplicate the base format for later use
	pCurrentFont->Release();
	Assert(_pTextFont != NULL);
	
	// setup font to match current keyboard
	CIme::CheckKeyboardFontMatching (cpLoc, TextMsgFilter, _pTextFont);

	_fIgnoreEndComposition = FALSE;
	
	_fIMETerminated = FALSE;
}

CIme_Lev2::~CIme_Lev2()
{
	if ( _pTextFont )
		_pTextFont->Release();
}

/*
 *	HRESULT CIme_Lev2::StartComposition(CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Begin IME Level 2 composition string processing.		
 *
 *	@comm
 *		Set the font, and location of the composition window which includes
 *		a bounding rect and the start position of the cursor. Also, reset
 *		the candidate window to allow the IME to set its position.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev2::StartComposition(
	CTextMsgFilter &TextMsgFilter)		// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::StartComposition");

	_imeLevel = IME_LEVEL_2;

	SetCompositionFont(TextMsgFilter, _pTextFont);	// Set font, & comp window.
	SetCompositionForm(TextMsgFilter);

	return S_FALSE;									// Allow DefWindowProc
}													//  processing.

/*
 *	HRESULT CIme_Lev2::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 2 WM_IME_COMPOSITION messages.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing.  
 *		
 *		Side effect: 
 *			The Host needs to mask out the lparam before calling DefWindowProc to
 *			prevent unnessary WM_IME_CHAR messages.
 */
HRESULT CIme_Lev2::CompositionString (
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::CompositionString");

	_cIgnoreIMECharMsg = 0;
	if(HAVE_RESULT_STRING())
	{
		if (_pTextFont)
		{
			// setup the font before insert final string
			ITextFont *pFETextFont=NULL;

			_pTextFont->GetDuplicate(&pFETextFont);
			Assert(pFETextFont != NULL);

			TextMsgFilter._pTextSel->SetFont(pFETextFont);
			pFETextFont->Release();
		}

		TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);

		CheckInsertResultString(lparam, TextMsgFilter, &_cIgnoreIMECharMsg);
		SetCompositionForm(TextMsgFilter);			// Move Composition window.
		
	}

	// Always return S_FALSE so the DefWindowProc will handle the rest.
	// Host has to mask out the ResultString bit to avoid WM_IME_CHAR coming in.
	return S_FALSE;																	
}

/*
 *	HRESULT CIme::CheckInsertResultString (const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		handle inserting of GCS_RESULTSTR text, the final composed text.
 *
 *	@comm
 *		When the final composition string arrives we grab it and set it into the text.
 *
 *	@devnote
 *		A GCS_RESULTSTR message can arrive and the IME will *still* be in
 *		composition string mode. This occurs because the IME's internal
 *		buffers overflowed and it needs to convert the beginning of the buffer
 *		to clear out some room.	When this happens we need to insert the
 *		converted text as normal, but remain in composition processing mode.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme::CheckInsertResultString (
	const LPARAM lparam,			// @parm associated with message.
	CTextMsgFilter &TextMsgFilter,	// @parm the containing message filter.
	short	*pcch)					// @parm number of character read
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CheckInsertResultString");

	HRESULT			hr = S_FALSE;
	HIMC 			hIMC;
	INT				cch;
	WCHAR			szCompStr[256];

	if(CLEANUP_COMPOSITION_STRING() || HAVE_RESULT_STRING())	// If result string..
	{
		hIMC = LocalGetImmContext(TextMsgFilter);				// Get host's IME context.

		cch = 0;
		if(hIMC)												// Get result string.
		{
			cch = GetCompositionStringInfo(hIMC, GCS_RESULTSTR, 
							szCompStr,
							sizeof(szCompStr)/sizeof(szCompStr[0]),
							NULL, 0, NULL, NULL, TextMsgFilter._uKeyBoardCodePage, 
							TextMsgFilter._fUnicodeIME, TextMsgFilter._fUsingAIMM);

			if (pcch)
				*pcch = (short)cch;

			cch = min (cch, 255);
			szCompStr[cch] = L'\0';
			LocalReleaseImmContext(TextMsgFilter, hIMC);		// Done with IME context.
		}
			
		// Don't need to replace range when there isn't any text. Otherwise, the character format is
		// reset to previous run.
		if(cch)
		{
			BSTR bstr = SysAllocString(szCompStr);
			if (!bstr)
				return E_OUTOFMEMORY;
			TextMsgFilter._pTextSel->TypeText(bstr);
			SysFreeString(bstr);
		}
		hr = S_OK;												// Don't want WM_IME_CHARs.
		
	}

	return hr;
}

/*
 *	HRESULT CIme_Lev2::IMENotify(const WPARAM wparam, const LPARAM lparam,
 *					CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 2 WM_IME_NOTIFY messages.
 *
 *	@comm
 *		Currently we are only interested in knowing when to reset
 *		the candidate window's position.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev2::IMENotify(
	const WPARAM wparam,			// @parm associated with message.
	const LPARAM lparam,			// @parm associated with message.
	CTextMsgFilter &TextMsgFilter,	// @parm the containing message filter.
	BOOL fIgnore)					// @parm Level3 Chinese Composition window only
{
 	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::IMENotify");

	if(IMN_OPENCANDIDATE == wparam)
	{
		Assert (0 != lparam);

		HIMC			hIMC;							// Host's IME context.

		INT				index;							// Candidate window index.
		CANDIDATEFORM	cdCandForm;

		hIMC = LocalGetImmContext(TextMsgFilter);				// Get host's IME context.

		if(hIMC)
		{
													// Convert bitID to INDEX.
			for (index = 0; index < 32; index++)	//  because API.
			{
				if((1 << index) & lparam)
					break;
			}
			Assert (((1 << index) & lparam) == lparam);	// Only 1 set?
			Assert (index < 32);						
													// Reset to CFS_DEFAULT
			if(ImmGetCandidateWindow(hIMC, index, &cdCandForm, TextMsgFilter._fUsingAIMM)
					&& CFS_DEFAULT != cdCandForm.dwStyle)
			{
				cdCandForm.dwStyle = CFS_DEFAULT;
				ImmSetCandidateWindow(hIMC, &cdCandForm, TextMsgFilter._fUsingAIMM);
			}

			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.
		}
	}	

	return S_FALSE;									// Allow DefWindowProc
}													//  processing.

/*
 *	void CIme_Lev2::PostIMEChar (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Called after processing a single WM_IME_CHAR in order to
 *		update the position of the IME's composition window.		
 *
 */
void CIme_Lev2::PostIMEChar (
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
 	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::PostIMEChar");

	SetCompositionForm(TextMsgFilter);						// Move Composition window.
}

/*
 *	CIme_Lev3::CIme_Lev3()
 *
 *	@mfunc
 *		CIme_Lev3 Constructor/Destructor.
 *
 */
CIme_Lev3::CIme_Lev3(	
	CTextMsgFilter &TextMsgFilter) : CIme_Lev2 ( TextMsgFilter )
{
	_sIMESuportMouse = 0;		// initial to 0 so we will check mouse operation if need
	_wParamBefore = 0;
	_fUpdateWindow = FALSE;
}

/*
 *	HRESULT CIme_Lev3::StartComposition(CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Begin IME Level 3 composition string processing.		
 *
 *	@comm
 *		For rudimentary processing, remember the start and
 *		length of the selection. Set the font in case the
 *		candidate window actually uses this information.
 *
 *	@rdesc
 *		This is a rudimentary solution for remembering were
 *		the composition is in the text. There needs to be work
 *		to replace this with a composition "range".
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev3::StartComposition(
	CTextMsgFilter &TextMsgFilter)			// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::StartComposition");
	long	cpMin;
	TextMsgFilter._pTextSel->GetStart(&cpMin);

	_ichStart = cpMin;
	_cchCompStr		= 0;
	_imeLevel		= IME_LEVEL_3;

	SetCompositionFont (TextMsgFilter, _pTextFont);	

	// Delete current selection
	TextMsgFilter._pTextSel->SetText(NULL);
	
	// turn off undo
	TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);

	if (_pTextFont)
	{
		_pTextFont->GetForeColor(&_crTextColor);
		_pTextFont->GetBackColor(&_crBkColor);
	}

	return S_OK;									// No DefWindowProc
}													//  processing.

/*
 *	HRESULT CIme_Lev3::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 3 WM_IME_COMPOSITION messages.
 *
 *	@comm
 *		Display all of the intermediary composition text as well as the final
 *		reading.
 *
 *	@devnote
 *		This is a rudimentary solution for replacing text in the backing store.
 *		Work is left to do with the undo list, underlining, and hiliting with
 *		colors and the selection.	
 *		
 *	@devnote
 *		A GCS_RESULTSTR message can arrive and the IME will *still* be in
 *		composition string mode. This occurs because the IME's internal
 *		buffers overflowed and it needs to convert the beginning of the buffer
 *		to clear out some room.	When this happens we need to insert the
 *		converted text as normal, but remain in composition processing mode.
 *
 *		Another reason, GCS_RESULTSTR can occur while in composition mode
 *		for Korean because there is only 1 correct choice and no additional 
 *		user intervention is necessary, meaning that the converted string can
 *		be sent as the result before composition mode is finished.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev3::CompositionString(
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::CompositionString");
	
	long	cpMin;
	
	_fIgnoreEndComposition = FALSE;

	if (_fUpdateWindow)
	{
		TextMsgFilter._pTextDoc->UpdateWindow();
		_fUpdateWindow = FALSE;
	}

 	if(CLEANUP_COMPOSITION_STRING() || HAVE_RESULT_STRING())	// Any final readings?
	{
		long	lCount;

		if (!CLEANUP_COMPOSITION_STRING())
			TextMsgFilter._pTextDoc->Freeze(&lCount);				// Turn off display

		if (_cchCompStr)
		{		
			ITextRange *pTextRange = NULL;

			// Create a range to delete composition text
			TextMsgFilter._pTextDoc->Range(_ichStart, _ichStart + _cchCompStr, &pTextRange);
			Assert (pTextRange != NULL);

			// delete composition text
			pTextRange->SetText(NULL);
			pTextRange->Release();
			_cchCompStr	= 0;							//  be in composition mode.
		};

		// setup the font before insert final string
		ITextFont *pFETextFont;

		_pTextFont->GetDuplicate(&pFETextFont);
		Assert(pFETextFont != NULL);

		TextMsgFilter._pTextSel->SetFont(pFETextFont);
		pFETextFont->Release();

		// turn on undo
		TextMsgFilter._pTextDoc->Undo(tomResume, NULL);

		// Turn on Notification again
		TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);

		// get final string
		CheckInsertResultString(lparam, TextMsgFilter);
		
		if (!CLEANUP_COMPOSITION_STRING())
			TextMsgFilter._pTextDoc->Unfreeze(&lCount);				// Turn on display

		// Reset as we may still in Composition
		TextMsgFilter._pTextSel->GetStart(&cpMin);	
		_ichStart = cpMin;

		// turn off undo for Korean IME since we will get Composition string message
		// again without getting EndComposition
		if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)
		{
			TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);							
		}
	}

	if(HAVE_COMPOSITION_STRING())						// In composition mode?
	{
		HIMC	hIMC;
		INT		cchOld = _cchCompStr;
		LONG	cpCursor = 0, cchAttrib = 0;
		LONG	i, j;				// For applying attrib effects.
		WCHAR	szCompStr[256];
		BYTE	startAttrib, attrib[256];
		BSTR	bstr = NULL;
		ITextRange *pTextRange = NULL;
		long	cpMax;
		long	lCount;

		_cchCompStr = 0;

		hIMC = LocalGetImmContext(TextMsgFilter);			// Get host's IME context.

		if(hIMC)								// Get composition string.
		{
			_cchCompStr = GetCompositionStringInfo(hIMC, GCS_COMPSTR, 
					szCompStr, sizeof(szCompStr)/sizeof(szCompStr[0]),
					attrib, sizeof(attrib)/sizeof(attrib[0]), 
					&cpCursor, &cchAttrib, TextMsgFilter._uKeyBoardCodePage, TextMsgFilter._fUnicodeIME, TextMsgFilter._fUsingAIMM);
			_cchCompStr = min (_cchCompStr, 255);
			szCompStr[_cchCompStr] = L'\0';
			LocalReleaseImmContext(TextMsgFilter, hIMC);		// Done with IME context.
		}

		// any new composition string?
		if(_cchCompStr)
		{
			long	cchExced = 0;
			if (TextMsgFilter._pTextDoc->CheckTextLimit(_cchCompStr-cchOld, &cchExced) == NOERROR &&
				cchExced > 0)
			{
				// We reach text limit, beep...
				TextMsgFilter._pTextDoc->SysBeep();

				if (_cchCompStr > cchExced)
					_cchCompStr -= cchExced;
				else
					_cchCompStr = 0;

				szCompStr[_cchCompStr] = L'\0';

				if (!_cchCompStr && TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)				
					TextMsgFilter._pTextDoc->SetCaretType(tomNormalCaret);		// Turn off Block caret mode
			}

			bstr = SysAllocString(szCompStr);
			if (!bstr)
				return E_OUTOFMEMORY;
		
			if (HAVE_RESULT_STRING())
			{
				// ignore next end composition
				_fIgnoreEndComposition = TRUE;

				// turn off undo
				TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);

				// Hold notification if needed
				if (!(TextMsgFilter._fIMEAlwaysNotify))
					TextMsgFilter._pTextDoc->SetNotificationMode(tomFalse);

				// Get the new format that may have changed by apps (e.g. Outlook)
				_pTextFont->Release();

				ITextFont	*pCurrentFont = NULL;
				TextMsgFilter._pTextSel->GetFont(&pCurrentFont);

				Assert(pCurrentFont != NULL);

				pCurrentFont->GetDuplicate(&_pTextFont);		// duplicate the base format for later use
				pCurrentFont->Release();
				Assert(_pTextFont != NULL);
				CIme::CheckKeyboardFontMatching (_ichStart, TextMsgFilter, _pTextFont);
			}			
		}
		
		if (cchOld || _cchCompStr)
		{
			bool	fFreezeDisplay = false;

			// Hold notification if needed
			if (!(TextMsgFilter._fIMEAlwaysNotify))
				TextMsgFilter._pTextDoc->SetNotificationMode(tomFalse);

			// We only support overtype mode in Korean IME
			if (!cchOld && TextMsgFilter._uKeyBoardCodePage == CP_KOREAN && 
				TextMsgFilter._fOvertypeMode && !_fSkipFirstOvertype)
			{				
				long		cCurrentChar;	
				HRESULT		hResult;

				// Create a range using the next character
				hResult	= TextMsgFilter._pTextDoc->Range(_ichStart, _ichStart+1, &pTextRange);
				Assert (pTextRange != NULL);

				// Check if it is par character. If so, we don't want to 
				// delete it.
				hResult	= pTextRange->GetChar(&cCurrentChar);
				if (hResult == NOERROR)
				{
					if (cCurrentChar != (long)'\r' && cCurrentChar != (long)'\n')
					{			
						TextMsgFilter._pTextDoc->Undo(tomResume, NULL);		// Turn on undo
						pTextRange->SetText(NULL);							// Delete the character
						TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);	// Turn off undo
					}
					else
					{
						// Unselect the par character
						hResult	= pTextRange->SetRange(_ichStart, _ichStart);
					}
				}
			}	
			else
			{
				// Create a range using the preivous composition text and delete the text
				TextMsgFilter._pTextDoc->Range(_ichStart, _ichStart+cchOld, &pTextRange);
				Assert (pTextRange != NULL);
				if (cchOld)
				{
					if (cpCursor)
					{
						TextMsgFilter._pTextDoc->Freeze(&lCount);	// Turn off display
						fFreezeDisplay = true;
					}
					pTextRange->SetText(NULL);
				}
			}
			
			_fSkipFirstOvertype = FALSE;
			
			if (cpCursor && !fFreezeDisplay)
				TextMsgFilter._pTextDoc->Freeze(&lCount);			// Turn off display
			
			// Make sure the composition string is formatted with the base font
			ITextFont *pFETextFont;
			HRESULT		hResult;

			hResult = _pTextFont->GetDuplicate(&pFETextFont);
			Assert(pFETextFont != NULL);

			if (!(hResult != NOERROR || pFETextFont == NULL))
			{
				if (TextMsgFilter._fHangulToHanja)
					// Hangul to Hanja mode, setup font for selection to 
					// handle the Hanja character the come in after the end composition
					// message
					TextMsgFilter._pTextSel->SetFont(pFETextFont);
				else
					pTextRange->SetFont(pFETextFont);				
			}

			pTextRange->SetText(bstr);								// Replace with the new text			
			if (pFETextFont)
				pFETextFont->Release();

			// update how many composition characters have been added
			pTextRange->GetEnd(&cpMax); 
			_cchCompStr = cpMax - _ichStart;
			
			if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)
			{
				// no formatting for Korean
				POINT		ptBottomPos;

				if (cpCursor)
					TextMsgFilter._pTextDoc->Unfreeze(&lCount);			// Turn on display
			
				if (pTextRange->GetPoint( tomEnd+TA_BOTTOM+TA_RIGHT,
					&(ptBottomPos.x), &(ptBottomPos.y) ) != NOERROR)
					pTextRange->ScrollIntoView(tomEnd);
				
				// Setup Block caret mode
				TextMsgFilter._pTextDoc->SetCaretType(_cchCompStr ? tomKoreanBlockCaret : tomNormalCaret);
				
			}
			else if (_cchCompStr && _cchCompStr <= cchAttrib)
			{				
				for ( i = 0; i < _cchCompStr; )			// Parse the attributes...
				{										//  to apply styles.					
					ITextFont *pFETextFont;
					HRESULT		hResult;

					hResult = _pTextFont->GetDuplicate(&pFETextFont);
					Assert(pFETextFont != NULL);

					if (hResult != NOERROR || pFETextFont == NULL)
						break;
					
					// Rsest the clone font so we will only apply effects returned
					// from SetCompositionStyle
					pFETextFont->Reset(tomUndefined);

					startAttrib = attrib[i];			// Get attrib's run length.
					for ( j = i+1; j < _cchCompStr; j++ )			
					{
						if ( startAttrib != attrib[j] )	// Same run until diff.
							break; 
					}

					SetCompositionStyle(TextMsgFilter, startAttrib, pFETextFont);

					// Apply FE clause's style
					pTextRange->SetRange(_ichStart+i, _ichStart+j);
					pTextRange->SetFont(pFETextFont);
					pFETextFont->Release();

					i = j;
				}
			}

			pTextRange->Release();
		}
		else if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)
			TextMsgFilter._pTextDoc->Update(tomTrue);		// Force an Update

		// setup caret pos
		if ( !(TextMsgFilter._uKeyBoardCodePage == CP_KOREAN))
		{
			if ( cpCursor > 0 )
			{
				cpCursor = min(cpCursor, _cchCompStr) + _ichStart;
				TextMsgFilter._pTextSel->SetRange(cpCursor, cpCursor);
			}
			else if ( cpCursor == 0 )
			{
				POINT		ptTopPos;
				HRESULT		hResult;

				// make sure the beginning is in view
				hResult	= TextMsgFilter._pTextDoc->Range(_ichStart, _ichStart+1, &pTextRange);
				Assert (pTextRange != NULL);
				
				if (hResult == NO_ERROR)
				{
					if (pTextRange->GetPoint( tomStart+TA_TOP+TA_LEFT,
						&(ptTopPos.x), &(ptTopPos.y) ) != NOERROR)
						pTextRange->ScrollIntoView(tomStart);
					pTextRange->Release();
				}
			}

			if (cpCursor)
				TextMsgFilter._pTextDoc->Unfreeze(&lCount);			// Turn on display
		}

		if (bstr)	
			SysFreeString(bstr);	
		
		// setup composition window for Chinese in-caret IME
		if (TextMsgFilter._uKeyBoardCodePage == CP_CHINESE_TRAD || 
			TextMsgFilter._uKeyBoardCodePage == CP_CHINESE_SIM)
			IMENotify ( IMN_OPENCANDIDATE, 0x01, TextMsgFilter, TRUE );
	}

	return S_OK;									// No DefWindowProc
}													//  processing.

/*
 *	void CIme_Lev3::SetCompositionStyle (CTextMsgFilter &TextMsgFilter, CCharFormat &CF)
 *
 *	@mfunc
 *		Set up a composition clause's character formmatting.
 *
 *	@comm
 *		If we loaded Office's IMEShare.dll, then we ask it what the formatting
 *		should be, otherwise we use our own, hardwired default formatting.
 *
 *	@devnote
 *		Note the use of pointers to functions when dealing with IMEShare funcs.
 *		This is because we dynamically load the IMEShare.dll.
 *
 */
void CIme_Lev3::SetCompositionStyle (
	CTextMsgFilter &TextMsgFilter,
	UINT attribute,
	ITextFont *pTextFont)
{

	const IMESTYLE	*pIMEStyle;
	UINT			ulID;
	COLORREF		crText = UINTIMEBOGUS;
	COLORREF		crBackground = UINTIMEBOGUS;
	COLORREF		crUl;

	if (TextMsgFilter._fRE10Mode)
	{
		if (attribute > ATTR_TARGET_NOTCONVERTED)
			attribute = ATTR_CONVERTED;

		// IME input for 1.0 mode, need to use IME Color
		if (TextMsgFilter._crComp[attribute].dwEffects & CFE_BOLD)
			pTextFont->SetBold(tomTrue);
		
		if(TextMsgFilter._crComp[attribute].dwEffects & CFE_ITALIC)
			pTextFont->SetItalic(tomTrue);

		if(TextMsgFilter._crComp[attribute].dwEffects & CFE_STRIKEOUT)
			pTextFont->SetStrikeThrough(tomTrue);
					
		if(TextMsgFilter._crComp[attribute].dwEffects & CFE_UNDERLINE)
			pTextFont->SetUnderline(tomSingle);

		pTextFont->SetForeColor(TextMsgFilter._crComp[attribute].crText);
				
		pTextFont->SetBackColor(TextMsgFilter._crComp[attribute].crBackground);			
	}
	else if (W32->HaveIMEShare())
	{
		CIMEShare *pIMEShare;
		if (W32->getIMEShareObject(&pIMEShare))
		{
			// IMEShare 98 interface
			if (pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareFBold))
				pTextFont->SetBold(tomTrue);
			
			if(pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareFItalic))
				pTextFont->SetItalic(tomTrue);

			if(pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareFUl))
			{
				ulID = pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareUKul);
				if(UINTIMEBOGUS != ulID)
				{
					long	lUnderlineCrIdx = 0;

					// get color for underline
					
					crUl = GetIMEShareColor(pIMEShare, attribute, IdstyIMEShareSubUl);
					
					if(UINTIMEBOGUS != crUl)
					{
						// NOTE:- attribute is 0 based and index for EffectColor is 1 based,
						// so, need to add 1 to attribute

						HRESULT hResult = TextMsgFilter._pTextDoc->SetEffectColor(attribute+1, crUl);
						
						// setup the high nibble for color index
						if (hResult == NOERROR)
							lUnderlineCrIdx = (attribute+1) << 4;
					}

					pTextFont->SetUnderline(IMEShareToTomUL(ulID) + lUnderlineCrIdx);					
				}
			}

			crText = GetIMEShareColor(pIMEShare, attribute, IdstyIMEShareSubText);
		
			crBackground = GetIMEShareColor(pIMEShare, attribute, IdstyIMEShareSubBack);

			
			// ignore case where text color is same as background color
			if (crText != crBackground)
			{
				if(UINTIMEBOGUS != crText)
					pTextFont->SetForeColor(crText);
				
				if(UINTIMEBOGUS != crBackground)
					pTextFont->SetBackColor(crBackground);		
			}
		}
		else
		{
			// IMEShare 96 interface
			pIMEStyle = PIMEStyleFromAttr(attribute);
			if(NULL == pIMEStyle)
				goto defaultStyle;		

			if(FBoldIMEStyle(pIMEStyle))
				pTextFont->SetBold(tomTrue);

			if(FItalicIMEStyle(pIMEStyle))
				pTextFont->SetItalic(tomTrue);

			if(FUlIMEStyle(pIMEStyle))
			{			
				ulID = IdUlIMEStyle (pIMEStyle);
				if(UINTIMEBOGUS != ulID)
					pTextFont->SetUnderline(IMEShareToTomUL(ulID));
			}

			crText = RGBFromIMEColorStyle(PColorStyleTextFromIMEStyle(pIMEStyle));
			if(UINTIMEBOGUS != crText)
				pTextFont->SetForeColor(crText);
			
			crBackground = RGBFromIMEColorStyle(PColorStyleBackFromIMEStyle(pIMEStyle));
			if(UINTIMEBOGUS != crBackground)
				pTextFont->SetBackColor(crBackground);
		}
	}
	else // default styles when no IMEShare.dll exist.
	{
defaultStyle:
		switch(attribute)
		{										// Apply underline style.
			case ATTR_INPUT:
			case ATTR_CONVERTED:
				pTextFont->SetUnderline(tomDotted);
				break;

			case ATTR_TARGET_NOTCONVERTED:
				pTextFont->SetUnderline(tomSingle);
				break;

			case ATTR_TARGET_CONVERTED:			// Target *is* selection.			
			{
				pTextFont->SetForeColor(::GetSysColor(COLOR_HIGHLIGHTTEXT));
				pTextFont->SetBackColor(::GetSysColor(COLOR_HIGHLIGHT));
			}
			break;
		}
	}
}
/*
 *	COLORREF CIme_Lev3::GetIMEShareColor (CIMEShare *pIMEShare, DWORD dwAttribute, DWORD dwProperty)
 *
 *	@mfunc
 *		Get the IME share color for the given dwAttribute and property
 *
 *
 *	@rdesc
 *		COLORREF of the color
 *
 */
COLORREF CIme_Lev3::GetIMEShareColor(
	CIMEShare *pIMEShare,
	DWORD dwAttribute,
	DWORD dwProperty)
{	
	if (pIMEShare->DwGetIMEStyle(dwAttribute,IdstyIMEShareFSpecCol | dwProperty))
	{
		if (pIMEShare->DwGetIMEStyle(dwAttribute,IdstyIMEShareFSpecColText | dwProperty))
			return (COLORREF) _crTextColor;
		else
			return (COLORREF) _crBkColor;
	}
	else
		return (COLORREF) (pIMEShare->DwGetIMEStyle(dwAttribute, 
				IdstyIMEShareRGBCol | dwProperty));
}

/*
 *	HRESULT CIme_Lev3::IMENotify(const WPARAM wparam, const LPARAM lparam,
 *					CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 3 WM_IME_NOTIFY messages.
 *
 *	@comm
 *		Currently we are only interested in knowing when to update
 *		the n window's position.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev3::IMENotify(
	const WPARAM wparam,			// @parm associated with message.
	const LPARAM lparam,			// @parm associated with message.
	CTextMsgFilter &TextMsgFilter,	// @parm the containing message filter.
	BOOL fCCompWindow)				// @parm Level3 Chinese Composition window
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::IMENotify");

	if(IMN_OPENCANDIDATE == wparam || IMN_CLOSECANDIDATE == wparam )
	{
		Assert (0 != lparam);

		INT				index;							// Candidate window index.
		CANDIDATEFORM	cdCandForm;
		POINT			ptCaret;
		HIMC			hIMC = LocalGetImmContext(TextMsgFilter);	// Get host's IME context.

		if(hIMC)
		{
			for (index = 0; index < 32; index++)	// Convert bitID to INDEX
			{										//  because API
				if((1 << index) & lparam)
					break;
			}
			Assert(((1 << index) & lparam) == lparam);	// Only 1 set?
			Assert(index < 32);

			if(IMN_OPENCANDIDATE == wparam && !(TextMsgFilter._uKeyBoardCodePage == CP_KOREAN))	// Set candidate to caret.
			{
				HRESULT	hResult;
				POINT	ptCurrentBottomPos;
				GetCaretPos(&ptCaret);			// Start at caret.

				ptCaret.x = max(0, ptCaret.x);
				ptCaret.y = max(0, ptCaret.y);
					
				cdCandForm.dwStyle = CFS_CANDIDATEPOS;
				
				if ( !fCCompWindow )			// Not positioning the Chinese composition
				{								//	Window.
					hResult = TextMsgFilter._pTextSel->GetPoint( tomStart+tomClientCoord+TA_BOTTOM+TA_LEFT,
							&(ptCurrentBottomPos.x), &(ptCurrentBottomPos.y) );

					if (hResult != NOERROR)
					{
						RECT	rcArea;

						// GetPoint fails, use application rect in screen coordinates
						hResult = TextMsgFilter._pTextDoc->GetClientRect(tomIncludeInset+tomClientCoord,
									&(rcArea.left), &(rcArea.top),
									&(rcArea.right), &(rcArea.bottom));
						ptCurrentBottomPos.y = rcArea.bottom;
					}

					if (hResult == NOERROR)
					{
						if (TextMsgFilter._uKeyBoardCodePage == CP_JAPAN)
						{
							// Change style to CFS_EXCLUDE, this is to
							// prevent the candidate window from covering
							// the current selection.
							cdCandForm.dwStyle = CFS_EXCLUDE;
							cdCandForm.rcArea.left = ptCaret.x;					

							// FUTURE: for verticle text, need to adjust
							// the rcArea to include the character width.
							cdCandForm.rcArea.right = 
								cdCandForm.rcArea.left + 2;
							cdCandForm.rcArea.top = ptCaret.y;
							ptCaret.y = ptCurrentBottomPos.y + 4;
							cdCandForm.rcArea.bottom = ptCaret.y;
						}
						else
							ptCaret.y = ptCurrentBottomPos.y + 4;
					}
				}

				// Most IMEs will have only 1, #0, candidate window. However, some IMEs
				//  may want to have a window organized alphabetically, by stroke, and
				//  by radical.
				cdCandForm.dwIndex = index;				
				cdCandForm.ptCurrentPos = ptCaret;
				ImmSetCandidateWindow(hIMC, &cdCandForm, TextMsgFilter._fUsingAIMM);
			}
			else									// Reset back to CFS_DEFAULT.
			{
				if(ImmGetCandidateWindow(hIMC, index, &cdCandForm, TextMsgFilter._fUsingAIMM)
						&& CFS_DEFAULT != cdCandForm.dwStyle)
				{
					cdCandForm.dwStyle = CFS_DEFAULT;
					ImmSetCandidateWindow(hIMC, &cdCandForm, TextMsgFilter._fUsingAIMM);
				}				
			}

			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.
			
			if (TextMsgFilter._fHangulToHanja == TRUE  &&
				IMN_CLOSECANDIDATE == wparam &&					 
				OnWinNTFE())
			{
				// By pass NT4.0 Kor Bug where we didn't get a EndComposition message
				// when user toggle the VK_HANJA key to terminate the conversion.
				TerminateIMEComposition(TextMsgFilter, CIme::TERMINATE_NORMAL);
			}

			if (IMN_CLOSECANDIDATE == wparam && CP_JAPAN == TextMsgFilter._uKeyBoardCodePage)
				_fUpdateWindow = TRUE;			
		}
	}	

	return S_FALSE;									// Allow DefWindowProc
}													//  processing.

/*
 *
 *	CIme_Lev3::IMEMouseOperation (CTextMsgFilter &TextMsgFilter, UINT msg)
 *
 *	@mfunc	if current IME support Mouse operation, need to pass
 *		mouse events to IME for processing
 *
 *	@rdesc
 *		BOOL-TRUE if IME handled the mouse events
 *
 */
BOOL CIme_Lev3::IMEMouseOperation(
	CTextMsgFilter &TextMsgFilter, 			// @parm the containing message filter.
	UINT		msg)						// @parm message id
	
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::IMEMouseOperation");
	
	BOOL	bRetCode = FALSE;
	BOOL	fButtonPressed = FALSE;
	WORD	wButtons = 0;
	POINT	ptCursor;
	WPARAM	wParamIME;

	HWND	hHostWnd = TextMsgFilter._hwnd;
	long	hWnd;

	if (!hHostWnd)									// Windowless mode...
	{		
		if (TextMsgFilter._pTextDoc->GetWindow(&hWnd) != S_OK || !hWnd)
			return FALSE;

		hHostWnd = (HWND)(DWORD_PTR)hWnd;
	}

	if (IMESupportMouse(TextMsgFilter))
	{
		switch (msg)
		{
			case WM_LBUTTONDOWN:
			case WM_RBUTTONDOWN:
			case WM_MBUTTONDOWN:
				fButtonPressed = TRUE;
				//fall through.
			case WM_SETCURSOR:
			case WM_MOUSEMOVE:
			case WM_LBUTTONUP:
			case WM_LBUTTONDBLCLK:
			case WM_RBUTTONUP:
			case WM_RBUTTONDBLCLK:
			case WM_MBUTTONUP:
			case WM_MBUTTONDBLCLK:
				if (GetKeyState(VK_LBUTTON) & 0x80)
					wButtons |= IMEMOUSE_LDOWN;
				if (GetKeyState(VK_MBUTTON) & 0x80)
					wButtons |= IMEMOUSE_MDOWN;
				if (GetKeyState(VK_RBUTTON) & 0x80)
					wButtons |= IMEMOUSE_RDOWN;
				break;

			default:
				return FALSE;
		}
	
		// change in button since last message?
		if ((wButtons != LOBYTE(LOWORD(_wParamBefore))) && GetCapture() == hHostWnd)
		{
			fButtonPressed = FALSE;
			wButtons = 0;
			ReleaseCapture();
		}
		
		if (GetCursorPos(&ptCursor))
		{
			ITextRange *pTextRange;
			HRESULT		hResult;
			long		ichCursor;

			// get cp at current Cursor position
			hResult = TextMsgFilter._pTextDoc->RangeFromPoint(ptCursor.x, ptCursor.y,
				&pTextRange);

			if (hResult != NOERROR)			
				return FALSE;

			hResult = pTextRange->GetStart(&ichCursor);
			pTextRange->Release();
			if (hResult != NOERROR)
				return FALSE;
			
			// click within composition text?
			if (_ichStart <= ichCursor && ichCursor <= _ichStart + _cchCompStr)
			{
				wParamIME = MAKEWPARAM(wButtons, ichCursor - _ichStart);
				fButtonPressed &= (_wParamBefore & 0xff) == 0;

				if (_wParamBefore != wParamIME || msg == WM_MOUSEMOVE && !fButtonPressed)
				{
					HIMC hIMC = LocalGetImmContext(TextMsgFilter);

					_wParamBefore = wParamIME;
					if (hIMC)
					{
						bRetCode = SendMessage(_hwndIME, MSIMEMouseMsg, _wParamBefore, hIMC);
						LocalReleaseImmContext(TextMsgFilter, hIMC);
					}
				}
				else
					// no change from last time, no need to send message to IME
					bRetCode = TRUE;

				if (bRetCode && fButtonPressed && GetCapture() != hHostWnd)
					SetCapture(hHostWnd);
			}
			else if (GetCapture() == hHostWnd)		//We don't want to determine while dragging...
				return TRUE;
		}
	}

	return bRetCode;
}

/*
 *
 *	CIme_Lev3::IMESupportMouse (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc	check if current IME supports Mouse events.  This should be
 *			a feature for IME Level 3.
 * 
 *	@comm	_sIMESupportMouse is a flag with the following values:
 *				== 0	if we haven't checked IME mouse support
 *				== -1	if we have checked and IME doesn't support mouse events
 *				== 1	if we have checked and IME supports mouse events and we have
 *						retrieved the IME hWnd
 */
BOOL CIme_Lev3::IMESupportMouse(
	CTextMsgFilter &TextMsgFilter) 			// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::IMESupportMouse");
	HIMC	hIMC;									// Host's IME context.
	HWND	hHostWnd;
	long	hWnd;

	if (!MSIMEMouseMsg || _sIMESuportMouse == -1)
		return FALSE;								// No mouse operation support

	if (_sIMESuportMouse == 1)
		return TRUE;								// IME supports mouse operation

	hHostWnd = TextMsgFilter._hwnd;
	
	if (!hHostWnd)									// Windowless mode...
	{		
		if (TextMsgFilter._pTextDoc->GetWindow(&hWnd) != S_OK || !hWnd)
			return FALSE;
		
		hHostWnd = (HWND)(DWORD_PTR)hWnd;
	}

	// Check if this IME supports mouse operation
	hIMC = LocalGetImmContext(TextMsgFilter);		// Get host's IME context.

	_sIMESuportMouse = -1;							// Init. to no support
	if(hIMC)
	{
		_hwndIME = ImmGetDefaultIMEWnd(hHostWnd, TextMsgFilter._fUsingAIMM);
		LocalReleaseImmContext(TextMsgFilter, hIMC);

		// SendMessage returns TRUE if IME supports mouse operation
		if (_hwndIME && SendMessage(_hwndIME, MSIMEMouseMsg, (WPARAM)IMEMOUSE_VERSION, hIMC) )
			_sIMESuportMouse = 1;
	}

	return (_sIMESuportMouse == 1);
}

/*
 *	BOOL IMEHangeulToHanja (&TextMsgFilter)
 *	
 *	@func
 *		Initiates an IME composition string edit to convert Korean Hanguel to Hanja.
 *	@comm
 *		Called from the message loop to handle VK_KANJI_KEY.
 *
 *	@devnote
 *		We decide if we need to do a conversion by checking:
 *		- the Fonot is a Korean font,
 *		- the character is a valid SBC or DBC,
 *		- ImmEscape accepts the character and bring up a candidate window
 *
 *	@rdesc
 *		BOOL - FALSE for no conversion. TRUE if OK.
 */
BOOL IMEHangeulToHanja (
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEHangeulToHanja");

	if(!TextMsgFilter.IsIMEComposition())
	{
		if(TextMsgFilter._pTextSel->CanEdit(NULL) == NOERROR)
		{
			WCHAR		szCurrentChar;
			long		cCurrentChar;	
			HRESULT		hResult;
			HKL			hKL = GetKeyboardLayout(0x0FFFFFFFF);
			HIMC		hIMC;	

			if (!hKL)
				goto Exit;
			
			hIMC = LocalGetImmContext(TextMsgFilter);
			if (!hIMC)
				goto Exit;

			// Collapse to cpMin
			hResult	= TextMsgFilter._pTextSel->Collapse(tomStart);

			// get the current character
			hResult	= TextMsgFilter._pTextSel->GetChar(&cCurrentChar);

			if (hResult != NOERROR)
				goto Exit;

			szCurrentChar = (WCHAR)cCurrentChar;
			
			// Check if the IME has a conversion for this Hangeul character.					
			if (ImmEscape(hKL, hIMC, IME_ESC_HANJA_MODE, (LPVOID)&szCurrentChar, TextMsgFilter._fUsingAIMM) != FALSE)
			{
				ITextRange *pTextRange;
				POINT		ptMiddlePos;
				LONG		cpCurrent;

				hResult = TextMsgFilter._pTextSel->GetStart(&cpCurrent);
				if (hResult == S_OK)
				{
					hResult = TextMsgFilter._pTextDoc->Range(cpCurrent, cpCurrent+1, &pTextRange);
					if (hResult == S_OK && pTextRange)
					{
						// Check if the character is in view
						if (pTextRange->GetPoint( tomEnd+TA_BASELINE+TA_LEFT,
							&(ptMiddlePos.x), &(ptMiddlePos.y) ) != NOERROR)
							pTextRange->ScrollIntoView(tomEnd);
						pTextRange->Release();
					}
				}

				TextMsgFilter._fHangulToHanja = TRUE;

				TextMsgFilter._ime = new CIme_HangeulToHanja(TextMsgFilter);

				if(TextMsgFilter.IsIMEComposition())
				{
					// start IME composition for the conversion
					LocalReleaseImmContext(TextMsgFilter, hIMC);
					return TextMsgFilter._ime->StartComposition(TextMsgFilter);
				}
				else
					TextMsgFilter._fHangulToHanja = FALSE;				
			}

			LocalReleaseImmContext(TextMsgFilter, hIMC);
		}
	}

Exit:
	return S_FALSE;
}

/*
 *	CIme_HangeulToHanja::CIme_HangeulToHanja()
 *
 *	@mfunc
 *		CIme_HangeulToHanja Constructor.
 *
 *
 */
 CIme_HangeulToHanja::CIme_HangeulToHanja(CTextMsgFilter &TextMsgFilter)	:
	CIme_Lev3(TextMsgFilter)
{
}

/*
 *	HRESULT CIme_HangeulToHanja::StartComposition(CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Begin CIme_HangeulToHanja composition string processing.		
 *
 *	@comm
 *		Call Level3::StartComposition.  Then setup the Korean block
 *		caret for the Hanguel character.
 *
 *	@rdesc
 *		Need to adjust _ichStart and _cchCompStr to make the Hanguel character
 *		"become" a composition character.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_HangeulToHanja::StartComposition(
	CTextMsgFilter &TextMsgFilter )				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_HangeulToHanja::StartComposition");
	HRESULT				hr;

	hr = CIme_Lev3::StartComposition(TextMsgFilter);
	
	// initialize to 1 so Composition string will get rid of the selected Hangeul
	_cchCompStr		= 1;

	// turn on undo
	TextMsgFilter._pTextDoc->Undo(tomResume, NULL);

	// Setup Block caret mode
	TextMsgFilter._pTextDoc->SetCaretType(tomKoreanBlockCaret);

	return hr;
}

/*
 *	HRESULT CIme_HangeulToHanja::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle CIme_HangeulToHanja WM_IME_COMPOSITION messages.
 *
 *	@comm
 *		call CIme_Lev3::CompositionString to get rid of the selected Hanguel character,
 *		then setup the format for the next Composition message.
 *
 *	@devnote
 *		When the next Composition message comes in and that we are no longer in IME,
 *		the new character will use the format as set here.
 */
HRESULT CIme_HangeulToHanja::CompositionString(
	const LPARAM lparam,		// @parm associated with message
	CTextMsgFilter &TextMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_HangeulToHanja::CompositionString");

	CIme_Lev3::CompositionString(lparam, TextMsgFilter);

	return S_OK;
}
/*
 *	HRESULT CIme_Protected::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle CIme_Protected WM_IME_COMPOSITION messages.
 *
 *	@comm
 *		Just throw away the result string since we are
 *	in read-only or protected mode
 *
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 *
 */
HRESULT CIme_Protected::CompositionString (
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Protected::CompositionString");

	if(CLEANUP_COMPOSITION_STRING() || HAVE_RESULT_STRING()) // If result string..
	{
		LONG	cch = 0;
		HIMC	hIMC = LocalGetImmContext(TextMsgFilter);		// Get host's IME context.
		WCHAR	szCompStr[256];

		if(hIMC)									// Get result string.
		{
			cch = GetCompositionStringInfo(hIMC, GCS_RESULTSTR, 
							szCompStr, sizeof(szCompStr)/sizeof(szCompStr[0]),
							NULL, 0, NULL, NULL, TextMsgFilter._uKeyBoardCodePage, FALSE, TextMsgFilter._fUsingAIMM);
			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.
		}
		return NOERROR;								// Don't want WM_IME_CHARs.
	}

	// Terminate composition to force a end composition message
	TerminateIMEComposition(TextMsgFilter, CIme::TERMINATE_FORCECANCEL);
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\measure.cpp ===
/*
 *	@doc
 *
 *	@module - MEASURE.CPP	  |
 *	
 *		CMeasurer class
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini, Murray Sargent, Rick Sailor
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_measure.h"
#include "_font.h"
#include "_disp.h"
#include "_edit.h"
#include "_frunptr.h"
#include "_objmgr.h"
#include "_coleobj.h"

ASSERTDATA

// Note we set this maximum length as appropriate for Win95 since Win95 GDI can 
// only handle 16 bit values. We don't special case this so that both NT and
// Win95 will behave the same way. 
// Note that the following obscure constant was empirically determined on Win95.
const LONG lMaximumWidth = (3 * SHRT_MAX) / 4;

void CMeasurer::Init(const CDisplay *pdp)
{
	CTxtEdit *	ped = GetPed();

	_pdp = pdp;
	_pddReference = pdp;
	_pccs = NULL;
	_pPF = NULL;
	_chPassword = ped->TxGetPasswordChar();
	_wNumber = 0;
	_fRenderer = FALSE;
	_fGlyphing = _fFallback = _fTarget = FALSE;
	_fAdjustFELineHt = !fUseUIFont() && pdp->IsMultiLine();

	if(pdp->GetWordWrap())
	{
		const CDevDesc *pddTarget = pdp->GetTargetDev();
		if(pddTarget)
			_pddReference = pddTarget;
	}

	_dypInch = pdp->GetDypInch();
	_dxpInch = pdp->GetDxpInch();
	_dtPres = GetDeviceCaps(_pdp->_hdc, TECHNOLOGY);

	if (pdp->IsMain())
	{
		_dypInch = MulDiv(_dypInch, pdp->GetZoomNumerator(), pdp->GetZoomDenominator());
		_dxpInch = MulDiv(_dxpInch, pdp->GetZoomNumerator(), pdp->GetZoomDenominator());
	}
	if (pdp->SameDevice(_pddReference))
	{
		_dyrInch = _dypInch;
		_dxrInch = _dxpInch;
		_dtRef = _dtPres;
	}
	else
	{
		_dyrInch = _pddReference->GetDypInch();
		_dxrInch = _pddReference->GetDxpInch();
		_dtRef = GetDeviceCaps(_pddReference->_hdc, TECHNOLOGY);
	}
}

CMeasurer::CMeasurer (const CDisplay* const pdp) : CRchTxtPtr (pdp->GetPed())	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::CMeasurer");
	Init(pdp);
}

CMeasurer::CMeasurer (const CDisplay* const pdp, const CRchTxtPtr &tp) : CRchTxtPtr (tp)	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::CMeasurer");
	Init(pdp);
}

CMeasurer::~CMeasurer()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::~CMeasurer");

	if(_pccs)
		_pccs->Release();
}

/*
 *	CMeasurer::SetGlyphing(fGlyphing)
 *
 *	@mfunc
 *	A state flag inside the measurer to record whether or not you
 *  are in the process of doing glyphing. If we are in a situation
 *	where the _pddReference is a printer device, then we need to
 *	throw away the _pccs.
 */
void CMeasurer::SetGlyphing(
	BOOL fGlyphing)		//@parm Currently doing glyphing
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::SetGlyphing");
	Assert(fGlyphing == TRUE || fGlyphing == FALSE);

	if (fGlyphing != _fGlyphing)
	{
		if (_dtRef == DT_RASPRINTER)
		{
			if (_pccs)
				_pccs->Release();
			_pccs = NULL;
		}
		_fGlyphing = fGlyphing;
	}
}

/*
 *	CMeasurer::SetUseTargetDevice(fUseTargetDevice)
 *
 *	@mfunc
 *		Sets whether you want to use the target device or not
 *		for getting metrics
 *		FUTURE (keithcu) Make this a parameter
 */
void CMeasurer::SetUseTargetDevice(
	BOOL fUseTargetDevice)		//@parm Use target device metrics?
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::SetUseTargetDevice");
	Assert(fUseTargetDevice == TRUE || fUseTargetDevice == FALSE);

	if (fUseTargetDevice != _fTarget)
	{
		if (_dypInch != _dyrInch && _dxpInch != _dxrInch)
		{
			if (_pccs)
				_pccs->Release();
			_pccs = NULL;
		}
		_fTarget = fUseTargetDevice;
	}
}


/*
 *	CMeasurer::NewLine (fFirstInPara)
 *
 *	@mfunc
 *		Initialize this measurer at the start of a new line
 */
void CMeasurer::NewLine(
	BOOL fFirstInPara)		//@parm Flag for setting up _bFlags
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::NewLine");

	_li.Init();							// Zero all members
	if(fFirstInPara)
		_li._bFlags = fliFirstInPara;	// Need to know if first in para
}

/*
 *	CMeasurer::NewLine(&li)
 *
 *	@mfunc
 *		Initialize this measurer at the start of a given line
 */
void CMeasurer::NewLine(
	const CLine &li)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::NewLine");

	_li				= li;
	_li._cch		= 0;
	_li._cchWhite	= 0;
	_li._xWidth		= 0;

	// Can't calculate xLeft till we get an HDC
	_li._xLeft	= 0;
	_wNumber	= _li._bNumber;
}

/*
 *	CMeasurer::MaxWidth()
 *
 *	@mfunc
 *		Get maximum width for line
 *
 *	@rdesc
 *		Maximum width for a line
 */
LONG CMeasurer::MaxWidth()
{
	LONG xWidth = lMaximumWidth;

	if(_pdp->GetWordWrap())
	{
		// Only main display has a caret 
		LONG xCaret = (_pdp->IsMain() && !GetPed()->TxGetReadOnly()) 
			? dxCaret : 0;

		// Calculate display width
		LONG xDispWidth = _pdp->GetMaxPixelWidth();

		if(!_pdp->SameDevice(_pddReference) && _fTarget)
		{
			// xWidthMax is calculated to the size of the screen DC. If
			// there is a target device with different characteristics
			// we need to convert the width to the target device's width
			xDispWidth = _pddReference->ConvertXToDev(xDispWidth, _pdp);
		}
		xWidth = xDispWidth - MeasureRightIndent() - _li._xLeft - xCaret;
	}
	return (xWidth > 0) ? xWidth : 0;
}

/*
 *	CMeasurer::MeasureText (cch)
 *
 *	@mfunc
 *		Measure a stretch of text from current running position.
 *
 *	@rdesc
 *		width of text (in device units), < 0 if failed
 */
LONG CMeasurer::MeasureText(
	LONG cch)		//@parm Number of characters to measure
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureText");

	if(Measure(0x7fffffff, cch, 0) == MRET_FAILED)
		return -1;

	return min(_li._xWidth, MaxWidth());
}

/*
 *	CMeasurer::MeasureLine (cchMax, xWidthMax, uiFlags, pliTarget)
 *
 *	@mfunc
 *		Measure a line of text from current cp and determine line break.
 *		On return *this contains line metrics for _pddReference device.
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 */
BOOL CMeasurer::MeasureLine(
	LONG cchMax, 		//@parm Max chars to process (-1 if no limit)
	LONG xWidthMax,		//@parm max width to process (-1 uses CDisplay width)
	UINT uiFlags,  		//@parm Flags controlling the process (see Measure())
	CLine *pliTarget)	//@parm Returns target-device line metrics (optional)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureLine");

	// This state must be preserved across the two possible line width
	// calculations so we save it here.
	BYTE bNumberSave = _li._bNumber;

	const CDevDesc *pddTarget = NULL;

	if(_pdp->GetWordWrap())
	{
		// Target devices are only interesting if word wrap is on because the 
		// only really interesting thing a target device can tell us is where
		// the word breaks will occur.
		pddTarget = _pdp->GetTargetDev();
		if(pddTarget)
			SetUseTargetDevice(TRUE);
	}

	// Compute line break
	LONG lRet = Measure(xWidthMax, cchMax, uiFlags);

	// Stop here if failed
	if(lRet == MRET_FAILED)
		return FALSE;

	// Return target metrics if requested
	if(pliTarget)
		*pliTarget = _li;

	if(pddTarget)
	{
		// We just use this flag as an easy way to get the recomputation to occur.
		lRet = MRET_NOWIDTH;
	}

	SetUseTargetDevice(FALSE);

	// Recompute metrics on rendering device
	if(lRet == MRET_NOWIDTH)
	{
		long cch = _li._cch;
		Advance(-cch);				// move back to BOL
		NewLine(uiFlags & MEASURE_FIRSTINPARA);

		// Restore the line number 
		_li._bNumber = bNumberSave;
	
		lRet = Measure(0x7fffffff, cch, uiFlags);
		if(lRet)
		{
			Assert(lRet != MRET_NOWIDTH);
			return FALSE;
		}
	}
	
	// Now that we know the line width, compute line shift due
	// to alignment, and add it to the left position 
	_li._xLeft += MeasureLineShift();
	
	return TRUE;
}

/*
 *	CMeasurer::RecalcLineHeight ()
 *
 *	@mfunc
 *		Reset height of line we are measuring if new run of text is taller
 *		than current maximum in line.
 */
void CMeasurer::RecalcLineHeight(
	CCcs *pccs, const CCharFormat * const pCF)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::RecalcLineHeight");

	// Compute line height
	LONG yOffset, yAdjust;
	pccs->GetOffset(pCF, _fTarget ? _dyrInch : _dypInch, &yOffset, &yAdjust);

	LONG yHeight = pccs->_yHeight;
	LONG yDescent = pccs->_yDescent;

	SHORT	yFEAdjust = pccs->AdjustFEHeight(fAdjustFELineHt());
	
	if (yFEAdjust)
	{
		yHeight += (yFEAdjust << 1);
		yDescent += yFEAdjust;
	}

	LONG yAscent = yHeight - yDescent;

	LONG yAboveBase = max(yAscent,  yAscent + yOffset);
	LONG yBelowBase = max(yDescent, yDescent - yOffset);

	_li._yHeight  = (SHORT)(max(yAboveBase, _li._yHeight - _li._yDescent) +
					   max(yBelowBase, _li._yDescent));
	_li._yDescent = (SHORT)max(yBelowBase, _li._yDescent);
}

/*
 *	CMeasurer::Measure (xWidthMax, cchMax, uiFlags)
 *
 *	@mfunc
 *		Measure given amount of text, start at current running position
 *		and storing # chars measured in _cch. 
 *		Can optionally determine line break based on a xWidthMax and 
 *		break out at that point.
 *
 *	@rdesc
 *		0 success
 *		MRET_FAILED	 if failed 
 *		MRET_NOWIDTH if second pass is needed to compute correct width
 *
 *	@devnote
 *		The uiFlags parameter has the following meanings:
 *			MEASURE_FIRSTINPARA		this is first line of paragraph
 *			MEASURE_BREAKATWORD		break out on a word break
 *			MEASURE_BREAKATWIDTH	break closest possible to xWidthMax
 *
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
LONG CMeasurer::Measure(
	LONG xWidthMax,			//@parm Max width of line (-1 uses CDisplay width)
	LONG cchMax,			//@parm Max chars to process (-1 if no limit)
	UINT uiFlags)			//@parm Flags controlling the process (see above)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::Measure");

	LONG		cch;				// cchChunk count down
	LONG		cchChunk;			// cch of cst-format contiguous run
	LONG		cchNonWhite;		// cch of last nonwhite char in line
	LONG		cchText = GetTextLength();
	unsigned	ch;					// Temporary char
	BOOL		fFirstInPara = uiFlags & MEASURE_FIRSTINPARA;
	BOOL        fLastChObj = FALSE;
	LONG		lRet = 0;
	const WCHAR*pch;
	CTxtEdit *	ped = GetPed();
	COleObject *pobj;
	LONG		xCaret = dxCaret;
	LONG		xAdd = 0;			// Character width
	LONG		xSoftHyphen = 0;	// Most recent soft hyphen width
	LONG		xWidthNonWhite;		// xWidth for last nonwhite char in line
	LONG		xWidthMaxOverhang;	// Max xWidth with current run's overhang
									//  taken into consideration.
	// This variable is used to keep track of whether there is a height change
	// so that we know whether we need to recalc the line in certain line break cases.
	BOOL		fHeightChange = FALSE;

	const INT	MAX_SAVED_WIDTHS = 31;	// power of 2 - 1
	INT			i, index, iSavedWidths = 0;
	struct {
		SHORT	width;
		SHORT	xLineOverhang;
		SHORT	yHeight;
		SHORT	yDescent;
	} savedWidths[MAX_SAVED_WIDTHS+1];

	_pPF = GetPF();							// Be sure current CParaFormat
											//  ptr is up to date
	BOOL fInTable	= _pPF->InTable();

	// If line spacing or space before/after, measure from beginning of line
	if (_li._cch && (_pPF->_bLineSpacingRule || _pPF->_dySpaceBefore ||
		_pPF->_dySpaceAfter || fInTable))					
	{										
		 Advance(-_li._cch);
		 NewLine(fFirstInPara);
	}

	// Init fliFirstInPara flag for new line
	if(fFirstInPara)
	{
		_li._bFlags |= fliFirstInPara;

		if(IsInOutlineView() && IsHeadingStyle(_pPF->_sStyle))
			_li._yHeight = (short)max(_li._yHeight, BITMAP_HEIGHT_HEADING + 1);
	}

	AssertSz(!_pPF->IsListNumbered() && !_wNumber ||
			 (uiFlags & MEASURE_BREAKBEFOREWIDTH) || !_pdp->IsMultiLine() ||
			 _wNumber > 20 || _wNumber == (i = GetParaNumber()),
		"CMeasurer::Measure: incorrect list number");
	_li._xLeft = MeasureLeftIndent();		// Set left indent

	// Compute width to break out at
	if(xWidthMax < 0)
	{					
		xWidthMax = MaxWidth();				// MaxWidth includes caret size
		xCaret = 0;
	}
	else
	{							  
		// (AndreiB) xWidthMax that's coming down to us is always calculated
		// with respect to the screen DC. The only scenario it comes into play
		// however is in TxGetNaturalSize, which may output a slightly
		// different result because of that.
		if(!_pdp->SameDevice(_pddReference) && _fTarget)
		{
			// xWidthMax is calculated to the size of the screen DC. If
			// there is a target device with different characteristics
			// we need to convert the width to the target device's width
			xWidthMax = _pddReference->ConvertXToDev(xWidthMax, _pdp);
		}
	}

	// For overhang support, we test against this adjusted widthMax.
	xWidthMaxOverhang = xWidthMax;

	// Are we ignoring the offset of the characters for the measure?
	if(!(uiFlags & MEASURE_IGNOREOFFSET))
	{
		// No - then take it from the max
		xWidthMaxOverhang -= (_li._xLineOverhang + xCaret);
	}

	// Compute max count of characters to process
	cch = cchText - GetCp();
	if(cchMax < 0 || cchMax > cch)
		cchMax = cch;

	cchNonWhite		= _li._cch;						// Default nonwhite parms
	xWidthNonWhite	= _li._xWidth;

	for( ; cchMax > 0;							// Measure up to cchMax
		cchMax -= cchChunk, Advance(cchChunk))	//  chars
	{
		pch = GetPch(cch);
		cch = min(cch, cchMax);					// Compute constant-format
		cchChunk = GetCchLeftRunCF();
		cch = min(cch, cchChunk);				// Counter for next while
		cchChunk = cch;							// Save chunk size

		const CCharFormat *pCF = GetCF();
		DWORD dwEffects = pCF->_dwEffects;

		if(dwEffects & CFE_HIDDEN)				// Ignore hidden text
		{
			_li._cch += cchChunk;
			continue;
		}

		if(!Check_pccs())						// Be sure _pccs is current
			return MRET_FAILED;

		xWidthMaxOverhang = xWidthMax;			// Overhang reduces max.

		// Are we ignoring offset of characters for the measure?
		if(!(uiFlags & MEASURE_IGNOREOFFSET))
		{
			// No - then take it from the max
			xWidthMaxOverhang -= (_pccs->_xOverhang + xCaret);
		}

		// Adjust line height for new format run

		if(cch > 0 && *pch && (IsRich() || ped->HasObjects()))
		{
			// Note: the EOP only contributes to the height calculation for the
			// line if there are no non-white space characters on the line or 
			// the paragraph is a bullet paragraph. The bullet paragraph 
			// contribution to the line height is done in AdjustLineHeight.

			// REVIEW (Victork) 
			// Another, similar topic is height of spaces.
			// They doesn't (normally) influence line height in LS, 
			// they do in CMeasurer::Measure code. 
			// Proposed ways to solve it:
			//		- have fSpacesOnly flag in run
			//		- move current (line height) logic down after next character-scanning loop


			if(!cchNonWhite || *pch != CR && *pch != LF)
			{
				// Determine if the current run is the tallest text on this
				// line and if so, increase the height of the line.
				LONG yHeightOld = _li._yHeight;
				RecalcLineHeight(_pccs, pCF);

				// Test for a change in line height. This only happens when
				// this is not the first character in the line and (surprise)
				// the height changes.
				if (yHeightOld && yHeightOld != _li._yHeight)
					fHeightChange = TRUE;
			}
		}

		while(cch > 0)
		{											// Process next char
			xAdd = 0;								// Default zero width
			ch = *pch;
			if(_chPassword && !IN_RANGE(LF, ch, CR))
				ch = _chPassword;

#ifdef UNICODE_SURROGATES
			if (IN_RANGE(0xD800, ch, 0xDFFF) && cch > 1 &&
				IN_RANGE(0xDC00, *(pch+1), 0xDFFF))	// Unicode extended char
			{
				// Convert to multiplane char (nibble 4 may be nonzero).
				// _pccs->Include(ch, xAdd) will project it down into plane 0
				// since it truncates to 16-bits. The currently selected font
				// should be correct for the plane given by (nibble 4) + 1.
				ch = WCHAR((ch << 10) | (*pch & 0x3FF));
				_li._bFlags |= fliHasSurrogates;	// Warn renderer
			}
			else									// AllCaps not supported
#endif												//  for surrogates

			if(dwEffects & CFE_ALLCAPS)
				ch = (WCHAR)CharUpper((WCHAR *)(DWORD_PTR)ch);	// See SDK to understand
													//  weird casts here
			if(ch == WCH_EMBEDDING)
			{
				_li._bFlags |= fliHasOle;
				pobj = ped->GetObjectMgr()->GetObjectFromCp
								(GetCp() + cchChunk - cch);
				if(pobj)
				{
					LONG yAscent, yDescent;
					pobj->MeasureObj(_fTarget ? _dyrInch : _dypInch, 
									 _fTarget ? _dxrInch : _dxpInch,
									 xAdd, yAscent, yDescent, _li._yDescent);

					// Only update height for line if the object is going
					// to be on this line.
					if(!_li._cch || _li._xWidth + xAdd <= xWidthMaxOverhang)
					{
						if (yAscent > _li._yHeight - _li._yDescent)
							_li._yHeight = yAscent + _li._yDescent;
					}
				}
				if(_li._xWidth + xAdd > xWidthMaxOverhang)
					fLastChObj = TRUE;
			}
			// The following if succeeds if ch isn't a CELL, BS, TAB, LF,
			// VT, FF, or CR
			else if(!IN_RANGE(CELL, ch, CR))		// Not TAB or EOP
			{
				// Get char width if not Unicode low surrogate	
				if (
#ifdef UNICODE_SURROGATES
					!IN_RANGE(0xDC00, ch, 0xDFFF) &&
#endif
					!IN_RANGE(0x300, ch, 0x36F) &&
					!_pccs->Include(ch, xAdd))
				{
					AssertSz(FALSE, "CMeasurer::Measure char not in font");
					return MRET_FAILED;
				}
				if(ch == SOFTHYPHEN)
				{
					_li._bFlags |= fliHasTabs;		// Setup RenderChunk()

					// get the width of hyphen instead
					if (!_pccs->Include('-', xAdd))
					{
						AssertSz(FALSE, "CMeasurer::Measure char not in font");
						return MRET_FAILED;
					}
					
					if(_li._xWidth + xAdd < xWidthMaxOverhang || !_li._cch)
					{
						xSoftHyphen = xAdd;			// Save soft hyphen width
						xAdd = 0;					// Use 0 unless at EOL
					}
				}
				else if (ch == EURO)
					_li._bFlags |= fliHasSpecialChars;
			}
			else if(ch == TAB || ch == CELL)		
			{
				_li._bFlags |= fliHasTabs;
				xAdd = MeasureTab(ch);
			}
			else if(ch == FF && ped->Get10Mode())	// RichEdit 1.0 treats
				_pccs->Include(ch, xAdd);			//  FFs as normal chars

			else									// Done with line
				goto eop;							// Go process EOP chars

			index = iSavedWidths++ & MAX_SAVED_WIDTHS;
			savedWidths[index].width		 = (SHORT)xAdd;
			savedWidths[index].xLineOverhang = _li._xLineOverhang;
			savedWidths[index].yHeight		 = _li._yHeight;
			savedWidths[index].yDescent		 = _li._yDescent;
			_li._xWidth += xAdd;

			if(_li._xWidth > xWidthMaxOverhang &&
				(uiFlags & MEASURE_BREAKBEFOREWIDTH || _li._cch > 0))
				goto overflow;

			_li._cch++;
			pch++;
			cch--;
			if(ch != TEXT(' ') /*&& ch != TAB*/)	// If not whitespace char,
			{
				cchNonWhite		= _li._cch;			//  update nonwhitespace
				xWidthNonWhite	= _li._xWidth;		//  count and width
			}
		}											// while(cch > 0)
	}												// for(;cchMax > 0;...)
	goto eol;										// All text exhausted 


// End Of Paragraph	char encountered (CR, LF, VT, or FF, but mostly CR)
eop:
	Advance(cchChunk - cch);				// Position tp at EOP
	cch = AdvanceCRLF();					// Bypass possibly multibyte EOP
	_li._cchEOP = (BYTE)cch;				// Store EOP cch
	_li._cch   += cch;						// Increment line count
	if(ch == CR || ped->fUseCRLF() && ch == LF)
		_li._bFlags |= fliHasEOP;
	
	AssertSz(ped->fUseCRLF() || cch == 1,
		"CMeasurer::Measure: EOP isn't a single char");
	AssertSz(_pdp->IsMultiLine() || GetCp() == cchText,
		"CMeasurer::Measure: EOP in single-line control");

eol:										// End of current line
	if(uiFlags & MEASURE_BREAKATWORD)		// Compute count of whitespace
	{										//  chars at EOL
		_li._cchWhite = (SHORT)(_li._cch - cchNonWhite);
		_li._xWidth = xWidthNonWhite;
	}
	goto done;

overflow:									// Went past max width for line
	_li._xWidth -= xAdd;
	--iSavedWidths;
	_li._xLineOverhang = savedWidths[iSavedWidths & MAX_SAVED_WIDTHS].xLineOverhang;
	Advance(cchChunk - cch);				// Position *this at overflow
											//  position
	if(uiFlags & MEASURE_BREAKATWORD)		// If required, adjust break on
	{										//  word boundary
		// We should not have the EOP flag set here.  The case to watch out
		// for is when we reuse a line that used to have an EOP.  It is the
		// responsibility of the measurer to clear this flag as appropriate.
	
		Assert(_li._cchEOP == 0);
		_li._cchEOP = 0;						// Just in case

		if(ch == TAB || ch == CELL)
		{
			// If the last character measured is a tab,	leave it on the
			// next line to allow tabbing off the end of line as in Word
			goto done;
		}

		LONG cpStop = GetCp();					// Remember current cp

		cch = -FindWordBreak(WB_LEFTBREAK, _li._cch+1);

		if(cch == 0 && fLastChObj)				// If preceding char is an
			goto done;							//  object,	put current char
												//  on next line
		Assert(cch >= 0);
		if(cch + 1 < _li._cch)					// Break char not at BOL
		{
			ch = _rpTX.GetPrevChar();
			if (ch == TAB || ch == CELL)		// If break char is a TAB,
			{									//  put it on the next line
				cch++;							//  as in Word
				Advance(-1);					
			}
			else if(ch == SOFTHYPHEN)
				_li._xWidth += xSoftHyphen;
			_li._cch -= cch;
		}
		else if(cch == _li._cch && cch > 1 &&
			_rpTX.GetChar() == ' ')				// Blanks all the way back to
		{										//  BOL. Bypass first blank
			Advance(1);
			cch--;
			_li._cch = 1;
		}
		else									// Advance forward to end of
			SetCp(cpStop);						//  measurement

		Assert(_li._cch > 0);

		// Now search at start of word to figure how many white chars at EOL
		if(GetCp() < cchText)
		{
			pch = GetPch(cch);
			cch = 0;
			if(ped->TxWordBreakProc((WCHAR *)pch, 0, sizeof(WCHAR), WB_ISDELIMITER, GetCp()))
			{
				cch = FindWordBreak(WB_RIGHT);
				Assert(cch >= 0);
			}

			_li._cchWhite = (SHORT)cch;
			_li._cch += cch;

			ch = GetChar();
			if(IsASCIIEOP(ch))					// skip *only* 1 EOP -jOn
			{
				if(ch == CR)
					_li._bFlags |= fliHasEOP;
				_li._cchEOP = (BYTE)AdvanceCRLF();
				_li._cch += _li._cchEOP;
				goto done;
			}
		}

		i = cpStop - GetCp();
		if(i)
		{
			if(i > 0)
				i += _li._cchWhite;
			if(i > 0 && i < iSavedWidths && i < MAX_SAVED_WIDTHS)
			{
				while (i-- > 0)
				{
					iSavedWidths = (iSavedWidths - 1) & MAX_SAVED_WIDTHS;
					_li._xWidth -= savedWidths[iSavedWidths].width;
				}
				iSavedWidths = (iSavedWidths - 1) & MAX_SAVED_WIDTHS;
				_li._xLineOverhang = savedWidths[iSavedWidths].xLineOverhang;
				_li._yHeight	   = savedWidths[iSavedWidths].yHeight;
				_li._yDescent	   = savedWidths[iSavedWidths].yDescent;
			}
			else
			{
				// Need to recompute width from scratch.
				_li._xWidth = -1;
				lRet = MRET_NOWIDTH;
			}
		}
		else
		{
			// i == 0 means that we are breaking on the first letter in a word.
			// Therefore, we want to set the width to the total non-white space
			// calculated so far because that does not include the size of the
			// character that caused the break nor any of the white space 
			// preceeding the character that caused the break.
			if(!fHeightChange)
				_li._xWidth = xWidthNonWhite;
			else
			{
				// Need to recompute from scratch so that we can get the 
				// correct height for the control
				_li._xWidth = -1;
				lRet = MRET_NOWIDTH;
			}
		}
	}

done:
	_xAddLast = xAdd;
	if(!_li._yHeight)						// If no height yet, use
		CheckLineHeight();					//  default height

	AdjustLineHeight();
	return lRet;
}

/*
 *	CMeasurer::GetCcsFontFallback
 *
 *	@mfunc
 *		Create the fallback font cache for given CF
 */
CCcs* CMeasurer::GetCcsFontFallback (const CCharFormat *pCF)
{
	CCharFormat	CF = *pCF;
	CCcs*		pccs = NULL;
	SHORT		iDefHeight;

	bool	fr = W32->GetPreferredFontInfo(GetCodePage(CF._bCharSet), 
									GetPed()->fUseUIFont() ? true : false, CF._iFont, 
									(BYTE&)iDefHeight, CF._bPitchAndFamily);
	if (fr)
		pccs = GetCcs(&CF);		// create fallback font cache entry

	return pccs;
}

/*
 * 	CMeasurer::ApplyFontCache (fFallback)
 *
 *	@mfunc
 *		Apply a new font cache on the fly (leave backing store intact)
 */
CCcs* CMeasurer::ApplyFontCache (
	BOOL	fFallback)
{
	if (_fFallback ^ fFallback)
	{
		CCcs*	pccs = fFallback ? GetCcsFontFallback(GetCF()) : GetCcs(GetCF());
		
		if (pccs)
		{
			if (_pccs)
				_pccs->Release();
			_pccs = pccs;
	
			_fFallback = fFallback;
		}
	}
	return _pccs;
}

/*
 *	CMeasurer::GetCcs
 *
 *	@mfunc
 *		Wrapper around font cache's GetCCcs function
 *	We use a NULL DC unless the device is a printer.
 */
CCcs* CMeasurer::GetCcs(const CCharFormat *pCF)
{
	HDC hdc = NULL;

	if (_fTarget)
	{
		if (_pddReference->_hdc && _dtRef == DT_RASPRINTER)
			hdc = _pddReference->_hdc;
	}
	else if (_pdp->_hdc && _dtPres == DT_RASPRINTER)
		hdc = _pdp->_hdc;

	return fc().GetCcs(pCF, _fTarget ? _dyrInch : _dypInch, hdc, 
					   _fGlyphing && _dtRef == DT_RASPRINTER);
}

/*
 *	CMeasurer::CheckLineHeight()
 *
 *	@mfunc
 *		If no height yet, use default height
 */
void CMeasurer::CheckLineHeight()
{
	CCcs *pccs = GetCcs(GetPed()->GetCharFormat(-1));
	_li._yHeight  = pccs->_yHeight;
	_li._yDescent = pccs->_yDescent;

	SHORT	yFEAdjust = pccs->AdjustFEHeight(fAdjustFELineHt());

	if (yFEAdjust)
	{
		_li._yHeight += (yFEAdjust << 1);
		_li._yDescent += yFEAdjust;
	}
	pccs->Release();
}

/*
 *	CMeasurer::Check_pccs()
 *
 *	@mfunc
 *		Check if new character format run or whether we don't yet have a font
 *
 *	@rdesc
 *		Current CCcs *
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
CCcs *CMeasurer::Check_pccs(
	BOOL fBullet)
{
	if(fBullet)
	{
		if(_pccs)							// Release old Format cache
			_pccs->Release();

		_pccs = GetCcsBullet(NULL);
		_iFormat = -10;						// Be sure to reset font next time
		return _pccs;
	}

	const CCharFormat *pCF = GetCF();

	if(FormatIsChanged())
	{
		// New CF run or format for this line not yet initialized
		ResetCachediFormat();
		if(_pccs)							// Release old Format cache
			_pccs->Release();
			
		_pccs = GetCcs(pCF);
		_fFallback = 0;

		if(!_pccs)
		{
			//FUTURE (keithcu) If this fails, just dig up the first pccs you can find
			AssertSz(FALSE, "CMeasurer::Measure could not get _pccs");
			return NULL;
		}
	}

	// NOTE: Drawing with a dotted pen on the screen and in a
	// compatible bitmap does not seem to match on some hardware.
	// If at some future point we do a better job of drawing the
	// dotted underline, this statement block can be removed.
	if(CFU_UNDERLINEDOTTED == pCF->_bUnderlineType)
	{
		// We draw all dotted underline lines off screen to get
		// a consistent display of the dotted line.
		_li._bFlags |= fliUseOffScreenDC;
	}

	_li._xLineOverhang = _pccs->_xOverhang;
	return _pccs;
}

/*
 *	CMeasurer::AdjustLineHeight()
 *
 *	@mfunc
 *		Adjust for space before/after and line spacing rules.
 *		No effect for plain text.
 *
 *	@future
 *		Base multiple line height calculations on largest font height rather
 *		than on line height (_yHeight), since the latter may be unduly large
 *		due to embedded objects.  Word does this correctly.
 */
void CMeasurer::AdjustLineHeight()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::AdjustLineHeight");

	if(!IsRich() || IsInOutlineView())			// Plain text and outline mode
		return;									//  don't use special line
												//  spacings
	const CParaFormat * pPF = _pPF;
	DWORD	dwRule	  = pPF->_bLineSpacingRule;
	LONG	dyAfter	  = 0;						// Default no space after
	LONG	dyBefore  = 0;						// Default no space before
	LONG	dySpacing = pPF->_dyLineSpacing;
	LONG	yHeight	  = LYtoDY(dySpacing);
	LONG	yAscent = _li._yHeight - _li._yDescent;

	if(_li._bFlags & fliFirstInPara)
		dyBefore = LYtoDY(pPF->_dySpaceBefore);	// Space before paragraph

	AssertSz(dyBefore >= 0, "CMeasurer::AdjustLineHeight - bogus value for dyBefore");

	if(yHeight < 0)								// Negative heights mean use
		_li._yHeight = (SHORT)(-yHeight);		//  the magnitude exactly

	else if(dwRule)								// Line spacing rule is active
	{
		switch (dwRule)
		{
		case tomLineSpace1pt5:
			dyAfter = _li._yHeight >> 1;		// Half-line space after
			break;								//  (per line)
	
		case tomLineSpaceDouble:
			dyAfter = _li._yHeight;				// Full-line space after
			break;								//  (per line)
	
		case tomLineSpaceAtLeast:
			if(_li._yHeight >= yHeight)
				break;
												// Fall thru to space exactly
		case tomLineSpaceExactly:
			_li._yHeight = (SHORT)max(yHeight, 1);
			break;
	
		case tomLineSpaceMultiple:				// Multiple-line space after
			// Prevent dyAfter from being negative because dySpacing is small - a-rsail
			if (dySpacing < 20)
				dySpacing = 20;

			dyAfter = (_li._yHeight*dySpacing)/20 // (20 units per line)
						- _li._yHeight;
		}
	}

	if(_li._bFlags & fliHasEOP)	
		dyAfter += LYtoDY(pPF->_dySpaceAfter);	// Space after paragraph end
												// Add in space before/after

	if (dyAfter < 0)
	{
		// Overflow - since we forced dySpacing to 20 above, the
		// only reason for a negative is overflow. In case of overflow,
		// we simply force the value to the max and then fix the
		// other resulting overflows.
		dyAfter = LONG_MAX;
	}

	AssertSz((dyBefore >= 0), "CMeasurer::AdjustLineHeight - invalid before");

	_li._yHeight  = (SHORT)(_li._yHeight + dyBefore + dyAfter);	

	if (_li._yHeight < 0)
	{
		// Overflow!
		// The reason for the -2 is then we don't have to worry about
		// overflow in the table check.
		_li._yHeight = SHRT_MAX - 2;
	}

	_li._yDescent = (SHORT)(_li._yDescent + dyAfter);

	if (_li._yDescent < 0)
	{
		// Overflow in descent
		AssertSz(_li._yHeight == SHRT_MAX - 2, "Descent overflowed when height didn't");

		// Allow old ascent
		_li._yDescent = SHRT_MAX - 2 - yAscent;

		AssertSz(_li._yDescent >= 0, "descent adjustment < 0");		
	}

	if(_pPF->InTable())
	{
		_li._yHeight++;
		if(!_li._fNextInTable)
		{
			_li._yHeight++;
			_li._yDescent++;
		}
	}

	AssertSz((_li._yHeight >= 0) && (_li._yDescent >= 0),
		"CMeasurer::AdjustLineHeight - invalid line heights");
}

/*
 *	CMeasurer::MeasureLeftIndent()
 *
 *	@mfunc
 *		Compute and return left indent of line in device units
 *
 *	@rdesc
 *		Left indent of line in device units
 *
 *	@comm
 *		Plain text is sensitive to StartIndent and RightIndent settings,
 *		but usually these are zero for plain text. 
 */
LONG CMeasurer::MeasureLeftIndent()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureLeftIndent");

	AssertSz(_pPF != NULL, "CMeasurer::MeasureLeftIndent _pPF not set!");

	LONG xLeft = _pPF->_dxStartIndent;				// Use logical units
													//  up to return
	if(IsRich())
	{
		LONG dxOffset = _pPF->_dxOffset;
		BOOL fFirstInPara = _li._bFlags & fliFirstInPara;

		if(IsInOutlineView())
		{
			xLeft = lDefaultTab/2 * (_pPF->_bOutlineLevel + 1);
			if(!fFirstInPara)
				dxOffset = 0;
		}
		if(fFirstInPara)
		{
			if(_pPF->_wNumbering && !_pPF->IsNumberSuppressed())// Add offset to text
			{											//  on first line	 
				LONG dx = DXtoLX(MeasureBullet());	// Use max of bullet
				dx = max(dx, _pPF->_wNumberingTab);		//  width, numbering tab,
				dxOffset = max(dxOffset, dx);			//  and para offset
			}
			else if(_pPF->InTable())					// For tables, need to
				xLeft += dxOffset;						//  add in trgaph twice
														//  since dxStartIndent
			else										//  subtracts one
				dxOffset = 0;
		}
		xLeft += dxOffset;								
	}
	// FUTURE: tables extending to the left of the left margin will be clipped
	// accordingly on the left. We could move the table to the right, but
	// then we need to move tabs to the right as well (include out parm with
	// amount of negative left indent.  Ideally we may want to enable a horiz
	// scroll bar able to shift to the left of the left margin for this case
	// as in Word.
	if(!_pPF->InTable() && xLeft <= 0)
		return 0;
	return LXtoDX(xLeft);
}

/*
 *	CMeasurer::HitTest(x)
 *
 *	@mfunc
 *		Return HITTEST for displacement x in this line. Can't be specific
 *		about text area (_xLeft to _xLeft + _xWidth), since need to measure
 *		to get appropriate cp (done elsewhere)
 *
 *	@rdesc
 *		HITTEST for a displacement x in this line
 */
HITTEST CMeasurer::HitTest(
	LONG x)			//@parm Displacement to test hit
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::HitTest");

	UpdatePF();
	LONG u = UFromX(x);

	if(u < 0)
		return HT_LeftOfText;

	if(u > _li._xLeft + _li._xWidth)
		return HT_RightOfText;

	if(u >= _li._xLeft)							// Caller can refine this
		return HT_Text;							//  with CLine::CchFromXpos()

	if(IsRich() && (_li._bFlags & fliFirstInPara))
	{
		_pPF = GetPF();
	
		LONG dx;
	
		if(_pPF->_wNumbering)
		{
			// Doesn't handle case where Bullet is wider than following dx
			dx = LXtoDX(max(_pPF->_dxOffset, _pPF->_wNumberingTab));
			if(u >= _li._xLeft - dx)
				return HT_BulletArea;
		}
		if(IsInOutlineView())
		{
			dx = LXtoDX(lDefaultTab/2 * _pPF->_bOutlineLevel);
			if(u >= dx && u < dx + (_pPF->_bOutlineLevel & 1
				? LXtoDX(lDefaultTab/2) : _pdp->Zoom(BITMAP_WIDTH_HEADING)))
			{
				return HT_OutlineSymbol;
			}
		}
	}
	return HT_LeftOfText;
}

/*
 *	CMeasurer::MeasureRightIndent()
 *
 *	@mfunc
 *		Compute and return right indent of line in device units
 *
 *	@rdesc
 *		right indent of line in device units
 *
 *	@comm
 *		Plain text is sensitive to StartIndent and RightIndent settings,
 *		but usually these are zero for plain text. 
 */
LONG CMeasurer::MeasureRightIndent()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureRightIndent");

	return LXtoDX(max(_pPF->_dxRightIndent, 0));
}

/*
 *	CMeasurer::MeasureTab()
 *
 *	@mfunc
 *		Computes and returns the width from the current position to the
 *		next tab stop (in device units).
 */
LONG CMeasurer::MeasureTab(unsigned ch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureTab");

	LONG			xCur = _li._xWidth + MeasureLeftIndent();
	const CParaFormat *	pPF = _pPF;
 	LONG			cTab = pPF->_bTabCount;
	LONG			dxDefaultTab = lDefaultTab;
	LONG			dxIndent = LXtoDX(pPF->_dxStartIndent + pPF->_dxOffset);
	LONG			dxOffset = pPF->_dxOffset;
	LONG			dxOutline = 0;
	BOOL			fInTable = pPF->InTable();
	LONG			h = 0;
	LONG			xT;
	LONG			xTab;

	AssertSz(cTab >= 0 || cTab <= MAX_TAB_STOPS,
		"CMeasurer::MeasureTab: illegal tab count");

	if(fInTable)
	{
		h = LXtoDX(dxOffset);
		dxOffset = 0;
	}

	if(IsInOutlineView())
		dxOutline = lDefaultTab/2 * (pPF->_bOutlineLevel + 1);

	if(cTab && (!fInTable || ch == CELL))		// Use default TAB for TAB in
	{											//  table
		const LONG *pl = pPF->GetTabs();
		for(xTab = 0; cTab--; pl++)				// Try explicit tab stops 1st
		{
			xT = GetTabPos(*pl) + dxOutline;	// (2 most significant nibbles
			xT = LXtoDX(xT);					//  are for type/style)

			if(xT > MaxWidth())					// Ignore tabs wider than display
				break;

			if(xT + h > xCur)					// Allow text in table cell to
			{									//  move into cell gap (h > 0)									
				if(dxOffset > 0 && xT < dxIndent)// Explicit tab in a hanging
					return xT - xCur;			//  indent takes precedence
				xTab = xT;
				break;
			}
		}
		if(dxOffset > 0 && xCur < dxIndent)		// If no tab before hanging
			return dxIndent - xCur;				//  indent, tab to indent

		if(xTab)								// Else use tab position
		{
			if(fInTable)
			{
				xTab += h;
				if(cTab)						// Don't include cell gap in
					xTab += h;					//  last cell
				if(IsInOutlineView() && cTab < pPF->_bTabCount)
					xTab += h;
			}
			return xTab - xCur;
		}
	}

	dxDefaultTab = GetTabPos(GetPed()->GetDefaultTab());
	AssertSz(dxDefaultTab > 0, "CMeasurer::MeasureTab: Default tab is bad");

	dxDefaultTab = LXtoDX(dxDefaultTab);
	dxDefaultTab = max(dxDefaultTab, 1);		// Don't ever divide by 0
	return dxDefaultTab - xCur%dxDefaultTab;	// Round up to nearest
}

/*
 *	CMeasurer::MeasureLineShift ()
 *
 *	@mfunc
 *		Computes and returns the line x shift due to alignment
 *
 *	@comm
 *		Plain text is sensitive to StartIndent and RightIndent settings,
 *		but usually these are zero for plain text. 
 */
LONG CMeasurer::MeasureLineShift()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureLineShift");

	WORD wAlignment = _pPF->_bAlignment;
	LONG xShift;

	if (IsInOutlineView() ||
		(wAlignment != PFA_RIGHT && wAlignment != PFA_CENTER))
	{
		return 0;
	}

	// Normal view with center or flush-right para. Move right accordingly

	xShift = _pdp->GetMaxPixelWidth() - _li._xLeft - MeasureRightIndent() - 
							dxCaret - _li._xLineOverhang - _li._xWidth;

	xShift = max(xShift, 0);			// Don't allow alignment to go < 0
										// Can happen with a target device
	if(wAlignment == PFA_CENTER)
		xShift /= 2;

	return xShift;
}

/*
 *	CMeasurer::MeasureBullet()
 *
 *	@mfunc
 *		Computes bullet/numbering dimensions
 *
 *	@rdesc
 *		return bullet/numbering string width
 */
LONG CMeasurer::MeasureBullet()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureBullet");

	CCharFormat CF;
	CCcs *pccs = GetCcsBullet(&CF);
	LONG xWidth = 0;

	if(pccs)
	{										
		WCHAR szBullet[CCHMAXNUMTOSTR];
		GetBullet(szBullet, pccs, &xWidth);
		RecalcLineHeight(pccs, &CF);
		pccs->Release();
	}
	return xWidth;
}

/*
 *	CMeasurer::GetBullet(pch, pccs, pxWidth)
 *
 *	@mfunc
 *		Computes bullet/numbering string, string length, and width
 *
 *	@rdesc
 *		return bullet/numbering string length
 */
LONG CMeasurer::GetBullet(
	WCHAR *pch,			//@parm Bullet string to receive bullet text
	CCcs  *pccs,		//@parm CCcs to use
	LONG  *pxWidth)		//@parm Out parm for bullet width
{
	Assert(pccs && pch);

	LONG cch = _pPF->NumToStr(pch, _li._bNumber);
	LONG dx;
	LONG i;
	LONG xWidth = 0;

	pch[cch++] = ' ';					// Ensure a little extra space
	for(i = cch; i--; xWidth += dx)
	{
		if(!pccs->Include(*pch++, dx))
		{
			TRACEERRSZSC("CMeasurer::GetBullet(): Error filling CCcs", E_FAIL);
		}
	}
	xWidth += pccs->_xUnderhang + pccs->_xOverhang;
	if(pxWidth)
		*pxWidth = xWidth;

	return cch;
}

/*
 *	CMeasurer::GetCcsBullet(pCFRet)
 *
 *	@mfunc
 *		Get CCcs for numbering/bullet font. If bullet is suppressed because
 *		this isn't the beginning of a paragraph (e.g., previous character is
 *		VT or if GetCcs() fails, it returns NULL.
 *
 *	@rdesc
 *		ptr to bullet CCcs, or NULL (GetCcs() failed or not start of para)
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
CCcs * CMeasurer::GetCcsBullet(
	CCharFormat *pCFRet)	//@parm option character format to return
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::GetCcsBullet");

	if(!(_li._bFlags & fliFirstInPara))
		return NULL;					// Number/bullet suppressed

	CCharFormat			CF;
	CCcs *			    pccs;
	const CCharFormat *	pCF;
	CCharFormat *		pCFUsed = pCFRet ? pCFRet : &CF;

	// Bullet CF is given by that for EOP in bullet's paragraph.

	CTxtPtr		  tp(_rpTX);
	CFormatRunPtr rpCF(_rpCF);
	rpCF.AdvanceCp(tp.FindEOP(tomForward));
	rpCF.AdjustBackward();
	pCF = GetPed()->GetCharFormat(rpCF.GetFormat());

	// Construct bullet (or numbering) CCharFormat
	*pCFUsed = *pCF;
	if(_pPF->_wNumbering == PFN_BULLET)			// Traditional bullet uses
	{											//  Symbol font bullet, but...
		pCFUsed->_bCharSet		  = SYMBOL_CHARSET,
		pCFUsed->_bPitchAndFamily = FF_DONTCARE;
		pCFUsed->_iFont			  = IFONT_SYMBOL;
	}

	// Since we always cook up bullet character format, no need to cache it
	pccs = GetCcs(pCFUsed);

#if DEBUG
	if(!pccs)
	{
		TRACEERRSZSC("CMeasurer::GetCcsBullet(): no CCcs", E_FAIL);
	}
#endif // DEBUG

	return pccs;
}

/*
 *	CMeasurer::SetNumber(wNumber)
 *
 *	@mfunc
 *		Store number if numbered paragraph
 */
void CMeasurer::SetNumber(
	WORD wNumber)
{
	_pPF = GetPF();
	if(!_pPF->IsListNumbered())
		wNumber = 0;

	else if (!wNumber)
		wNumber = 1;

	_wNumber = wNumber;
}

/*
 *	CMeasurer::DXtoLX(x), LXtoDX(x), LYtoDY(y)
 *
 *	@mfunc
 *		Functions that convert from file to pixel coordinates
 *
 *	@rdesc
 *		Scaled coordinate
 */
LONG CMeasurer::DXtoLX(LONG x)
{
	return MulDiv(x, LX_PER_INCH, _fTarget ? _dxrInch : _dxpInch);
}

LONG CMeasurer::LXtoDX(LONG x)
{
	return MulDiv(x, _fTarget ? _dxrInch : _dxpInch, LX_PER_INCH);
}

LONG CMeasurer::LYtoDY(LONG y)
{
	return MulDiv(y, _fTarget ? _dyrInch : _dypInch, LX_PER_INCH);
}

LONG CMeasurer::XFromU(LONG u)
{
#ifdef LINESERVICES
	if (_pPF->IsRtlPara())
	{
		LONG xCaret = _pdp->IsMain() ? dxCaret : 0, xWidth;

		if (_pdp->GetMaxWidth())
			xWidth = LXtoDX(_pdp->GetMaxWidth());
		else
			xWidth = max(0, _pdp->GetMaxPixelWidth());

		if(!_pdp->GetWordWrap())
		{
			xWidth = max(xWidth, _pdp->GetViewWidth());
			xWidth = max(xWidth, _pdp->GetWidth());
		}

		xWidth -= xCaret;

		POINT ptStart = {xWidth, 0};
		POINTUV pointuv = {u, 0};
		POINT	pt;

		LsPointXYFromPointUV(&ptStart, lstflowWS, &pointuv, &pt);
		return pt.x;
	}
	else
#endif
		return u;
}

LONG CMeasurer::UFromX(LONG x)
{
#ifdef LINESERVICES
	if (_pPF->IsRtlPara())
		return XFromU(x);
	else
#endif
		return x;
}

/*
 *	CMeasurer::GetPols(pme)
 *
 *	@mfunc
 *		Get ptr to LineServices object. If LineServices not enabled,
 *		return NULL.  If pme is nonNULL, use it as COls::_pme.
 *
 *	@rdesc
 *		POLS
 */
#ifdef LINESERVICES
extern BOOL g_fNoLS;

COls *CMeasurer::GetPols(
	CMeasurer **ppme)
{
	CTxtEdit *ped = GetPed();

	if(ppme)								// Default no previous measurer
		*ppme = NULL;

	if(g_fNoLS || !ped->fUseLineServices())			// Not using LineServices
		return NULL;

	if(!g_pols)								// Starting up LS:
		g_pols = new COls();				//  create new COls

	if(g_pols)								// Have the COls
	{
		if(ppme)
			*ppme = g_pols->_pme;			// Return current g_pols->_pme

		if(g_pols->Init(this) != NOERROR)	// Switch to new one
		{
			delete g_pols;
			g_pols = NULL;
		}
		UpdatePF();
	}
	return g_pols;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\m_undo.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	M_UNDO.C	|
 *
 *	Purpose:
 *		Implementation of the global mutli-undo stack
 *
 * 	Author:
 *		alexgo  3/25/95
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_m_undo.h"
#include "_edit.h"
#include "_disp.h"
#include "_urlsup.h"
#include "_antievt.h"

ASSERTDATA

//
// PUBLIC METHODS
//

/*
 *	CUndoStack::CUndoStack (ped, rdwLim, flags)
 *
 *	@mfunc	Constructor
 */
CUndoStack::CUndoStack(
	CTxtEdit *ped,		//@parm	CTxtEdit parent
	DWORD & rdwLim,		//@parm Initial limit
	USFlags	flags)		//@parm Flags for this undo stack
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::CUndoStack");

	_ped = ped;

	_prgActions = NULL;
	_index = 0;
	_dwLim = 0;

	// We should be creating an undo stack if there's nothing to put in it!
	Assert(rdwLim);
	SetUndoLimit(rdwLim);

	if(flags & US_REDO)
		_fRedo = TRUE;
}

/*
 *	CUndoStack::~CUndoStack()
 *
 *	@mfunc Destructor
 *
 *	@comm
 *		deletes any remaining anti-events.  The anti event dispenser
 *		should *not* clean up because of this!!
 */
CUndoStack::~CUndoStack()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::~CUndoStack");

	// Clear out any remaining antievents
	ClearAll();

	delete _prgActions;
}

/*
 *	CUndoStack::Destroy ()
 *
 *	@mfunc
 *		deletes this instance
 */
void CUndoStack::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::Destroy");

	delete this;
}

/*
 * 	CUndoStack::SetUndoLimit (dwLim)
 *
 *	@mfunc
 *		allows the undo stack to be enlarged or reduced
 *
 *	@rdesc
 *		the size to which the stack is actually set.
 *
 *	@comm
 *		the algorithm we use is the following:	 <nl>
 *			try to allocate space for the requested size.
 *			if there's not enough memory then we try to recover
 *			with the largest block possible.
 *
 *			if the requested size is bigger than the default,
 *			and the current size is less than the default, go 
 *			ahead and try to allocate the default.
 *
 *			if that fails then just stick with the existing stack
 */
DWORD CUndoStack::SetUndoLimit(
	DWORD dwLim)			//@parm	New undo limit.  May not be zero
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::SetUndoLimit");

	UndoAction *prgnew = NULL;

	// if the undo limit is zero, we should get rid of the entire
	// undo stack instead.

	Assert(dwLim);

	if(_fSingleLevelMode)
	{
		// if fSingleLevelMode is on, we can't be the redo stack
		Assert(_fRedo == FALSE);

		if(dwLim != 1)
		{
			TRACEERRORSZ("Trying to grow/shrink the undo buffer while in"
				"single level mode");
			
			dwLim = 1;
		}
	}

	prgnew = new UndoAction[dwLim];
	if(prgnew)
		TransferToNewBuffer(prgnew, dwLim);

	else if(dwLim > DEFAULT_UNDO_SIZE && _dwLim < DEFAULT_UNDO_SIZE)
	{
		// We are trying to grow past the default but failed.  So
		// try to allocate the default
		prgnew = new UndoAction[DEFAULT_UNDO_SIZE];

		if(prgnew)
			TransferToNewBuffer(prgnew, DEFAULT_UNDO_SIZE);
	}
	
	// In either success or failure, _dwLim will be set correctly.	
	return _dwLim;
}

/*
 *	CUndoStack::GetUndoLimit() 
 *
 *	@mfunc
 *		gets the current limit size
 *
 *	@rdesc	
 *		the current undo limit
 */
DWORD CUndoStack::GetUndoLimit()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetUndoLimit");

	return _dwLim;
}

/*
 *	CUndoStack::PushAntiEvent (idName, pae)
 *
 *	@mfunc
 *		adds an undoable event to the event stack
 *
 *	@rdesc	HRESULT
 *
 *	@comm
 *	Algorithm:
 *
 *		if merging is set, then we to merge the given anti-event
 *		list *into* the current list (assuming it's a typing
 *		undo action).
 */
HRESULT CUndoStack::PushAntiEvent(
	UNDONAMEID idName,		//@parm	Name for this AE collection
	IAntiEvent *pae)		//@parm AE collection
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::PushAntiEvent");

	// _index should be at next available position
	if(!_fMerge)
	{
		// clear out any existing event	
		if(_prgActions[_index].pae != NULL)
		{
			DestroyAEList(_prgActions[_index].pae);
			_prgActions[_index].pae = NULL;
		}

		if(_fRedo)
			_ped->GetCallMgr()->SetNewRedo();
		else
			_ped->GetCallMgr()->SetNewUndo();
	}

	if(_fMerge)
	{
		IAntiEvent *paetemp = pae, *paeNext;
		DWORD i = GetPrev();

		// If these asserts fail, then somebody did not call 
		// StopGroupTyping
		Assert(_prgActions[i].id == idName);
		Assert(idName == UID_TYPING);

		// Put existing anti-event chain onto *end* of current one
		while((paeNext = paetemp->GetNext()) != NULL)
			paetemp = paeNext;

		paetemp->SetNext(_prgActions[i].pae);
		_index = i;
	}
	else if(_fGroupTyping)
	{
		// In this case, we are *starting* a group typing session.
		// Any subsequent push'es of anti events should be merged
		_fMerge = TRUE;
	}

	_prgActions[_index].pae = pae;
	_prgActions[_index].id = idName;
	
	Next();
	return NOERROR;
}

/*
 *	CUndoStack::PopAndExecuteAntiEvent(void *pAE)
 *
 *	@mfunc
 *		Undo!  Takes the most recent anti-event and executes it
 *
 *	@rdesc	HRESULT from invoking the anti-events (AEs)
 */
HRESULT CUndoStack::PopAndExecuteAntiEvent(
	void *pAE)		//@parm if non-NULL, undo up to this point.
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::PopAndExecuteAntiEvent");

	HRESULT hresult = NOERROR;
	IAntiEvent *pae, *paeDoTo;
	DWORD i, j;
	CCallMgr *pcallmgr = _ped->GetCallMgr();

	// we need to check to see if there are any non-empty undo builders
	// higher on the stack.  In this case, we have been re-entered
	if(pcallmgr->IsReEntered())
	{
		IUndoBuilder *publdr;

		// there are two cases to handle: we are invoking redo or we
		// are invoking undo.  If we are invoking undo and there are 
		// existing undo actions in the undo builder, then simply commit
		// those actions and undo them.  We can assert in this case
		// that the redo stack is empty.
		//
		// In the second case if we are invoking redo while there are
		// undo actions in progress, simply cancel the call.  When the
		// undo actions are added, they will clear the redo stack.
		// 
		// We never need to check for a redo builder as that _only_
		// gets created in this routine and it's use is carefully guarded.


		publdr = (CGenUndoBuilder *)pcallmgr->GetComponent(COMP_UNDOBUILDER);

		
		// Commit the anti-events to this undo stack, so that we will simply
		// undo them first.
		if(publdr)
		{			
			TRACEWARNSZ("Undo/Redo Invoked with uncommitted anti-events");
			TRACEWARNSZ("		Recovering....");

			if(_fRedo)
			{
				// if we are the redo stack, simply fail the redo call
				return NOERROR;
			}
			else
			{
				// just commit the anti-events and the routine below
				// will take of the rest.
				publdr->Done();
			}
		}
	}

	// If we are in single level mode, check to see if our current buffer is
	// empty.  If so, simply delegate to the redo stack if it exists.  We only
	// support this mode for dwDoToCookies being NULL.  Note that we can't call
	// CanUndo here as it will consider the redo stack as well

	if(_fSingleLevelMode && !_prgActions[GetPrev()].pae)
	{
		Assert(_fRedo == FALSE);
		Assert(pAE == 0);

		if(_ped->GetRedoMgr())
			return _ped->GetRedoMgr()->PopAndExecuteAntiEvent(0);

		// Nothing to redo && nothing to do here; don't bother continuing	
		return NOERROR;
	}

	// this next bit of logic is tricky.  What is says is create
	// an undo builder for the stack *opposite* of the current one
	// (namely, undo actions go on the redo stack and vice versa).
	// Also, if we are the redo stack, then we don't want to flush
	// the redo stack as anti-events are added to the undo stack.

	CGenUndoBuilder undobldr(_ped, 
					(!_fRedo ? UB_REDO : UB_DONTFLUSHREDO) | UB_AUTOCOMMIT);
					
	// obviously, we can't be grouping typing if we're undoing!
	StopGroupTyping();

	// _index by default points to the next available slot
	// so we need to back up to the previous one.
	Prev();

	// Do some verification on the cookie--make sure it's one of ours
	paeDoTo = (IAntiEvent *)pAE;
	if(paeDoTo)
	{
		for(i = 0, j = _index; i < _dwLim; i++)
		{
			if(IsCookieInList(_prgActions[j].pae, (IAntiEvent *)paeDoTo))
			{
				paeDoTo = _prgActions[j].pae;
				break;
			}
			// Go backwards through ring buffer; typically
			// paeDoTo will be "close" to the top
			
			if(!j)
				j = _dwLim - 1;
			else
				j--;
		}
		
		if(i == _dwLim)
		{
			TRACEERRORSZ("Invalid Cookie passed into Undo; cookie ignored");
			hresult = E_INVALIDARG;
			paeDoTo = NULL;
		}
	}
	else
	{
		paeDoTo = _prgActions[_index].pae;
	}

	undobldr.SetNameID(_prgActions[_index].id);

	while(paeDoTo)
	{
		CUndoStackGuard guard(_ped);

		pae = _prgActions[_index].pae;
		Assert(pae);

		// Fixup our state _before_ calling Undo, so 
		// that we can handle being re-entered.
		_prgActions[_index].pae = NULL;

		hresult = guard.SafeUndo(pae, &undobldr);

		DestroyAEList(pae);

		if(pae == paeDoTo || guard.WasReEntered())
			paeDoTo = NULL;
		Prev();
	}

	// Put _index at the next unused slot
	Next();
	return hresult;
}

/* 
 *	CUndoStack::GetNameIDFromTopAE(dwAECookie)
 *
 *	@mfunc
 *		retrieves the name of the most recent undo-able operation
 *
 *	@rdesc	the name ID of the most recent collection of anti-events
 */
UNDONAMEID CUndoStack::GetNameIDFromAE(
	void *pAE)		//@parm Anti-event whose name is desired;
					//		0 for the top
{
	IAntiEvent *pae = (IAntiEvent *)pAE;
	DWORD	i, j = GetPrev();	// _index by default points to next 
								// available slot

	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetNameIDFromTopAE");

	if(pae == NULL)
		pae = _prgActions[j].pae;

	if(_fSingleLevelMode && !pae)
	{
		// if fSingleLevelMode is on, we can't be the redo stack
		Assert(_fRedo == FALSE);

		// if pae is NULL, our answer may be on the redo stack.  Note that
		// we if somebody tries to pass in a cookie while in SingleLevelMode,
		// they won't be able to get actions off the redo stack.
		if(_ped->GetRedoMgr())
			return _ped->GetRedoMgr()->GetNameIDFromAE(0);
	}		

	for(i = 0; i < _dwLim; i++)
	{
		if(_prgActions[j].pae == pae)
			return _prgActions[j].id;

		if(j == 0)
			j = _dwLim - 1;
		else
			j--;
	}
	return UID_UNKNOWN;
}

/*
 *	CUndoStack::GetMergeAntiEvent ()
 *
 *	@mfunc	If we are in merge typing mode, then return the topmost
 *			anti-event
 *
 *	@rdesc	NULL or the current AntiEvent if in merge mode
 */
IAntiEvent *CUndoStack::GetMergeAntiEvent()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetMergeAntiEvent");

	if(_fMerge)
	{
		DWORD i = GetPrev();			// _index by default points to
										//  next available slot
		Assert(_prgActions[i].pae);		// Can't be in merge anti event mode
										// if no anti-event to merge with!!
		return _prgActions[i].pae;
	}
	return NULL;
}

/*
 *	CUndoStack::GetTopAECookie()
 *
 *	@mfunc	Returns a cookie to the topmost anti-event.
 *
 *	@rdesc	A cookie value.  Note that this cookie is just the anti-event
 *			pointer, but clients shouldn't really know that.
 */		
void* CUndoStack::GetTopAECookie()
{
 	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetTopAECookie");

	DWORD i = GetPrev();

	return _prgActions[i].pae;
}

/*
 *	CUndoStack::ClearAll ()
 *
 *	@mfunc
 *		removes any anti-events that are currently in the undo stack
 */
void CUndoStack::ClearAll()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::ClearAll");

 	for(DWORD i = 0; i < _dwLim; i++)
	{
		if(_prgActions[i].pae)
		{
			DestroyAEList(_prgActions[i].pae);
			_prgActions[i].pae = NULL;
		}
	}

	// Just in case we've been grouping typing; clear the state.
	StopGroupTyping();
}

/*
 *	CUndoStack::CanUndo()
 *
 *	@mfunc
 *		indicates whether or not can undo operation can be performed
 *		(in other words, are there any anti-events in our buffer)
 *
 *	@rdesc
 *		TRUE	-- anti-events exist 	<nl>
 *		FALSE 	-- no anti-events		<nl>
 */
BOOL CUndoStack::CanUndo()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::CanUndo");

	DWORD i = GetPrev();		// _index by default points to 
								//  next available slot
	if(_prgActions[i].pae)
		return TRUE;

	if(_fSingleLevelMode)
	{
		// If fSingleLevelMode is on, we can't be the redo stack
		Assert(_fRedo == FALSE);

		// If we are in single level mode, we are the undo stack.
		// Check to see if the redo stack can do something here.
		if(_ped->GetRedoMgr())
			return _ped->GetRedoMgr()->CanUndo();
	}
	return FALSE;
}

/*
 *	CUndoStack::StartGroupTyping ()
 *
 *	@mfunc
 *		TOGGLES the group typing flag on.  If fGroupTyping is set, then
 *		all *typing* events will be merged together
 *
 *	@comm
 *	Algorithm:
 *
 *		There are three interesting states:	<nl>
 *			-no group merge; every action just gets pushed onto the stack <nl>
 *			-group merge started; the first action is pushed onto the stack<nl>
 *			-group merge in progress; every action (as long as it's "typing")
 *			is merged into the prior state	<nl>
 *
 *		See the state diagram in the implemenation doc for more details
 */
void CUndoStack::StartGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::StartGroupTyping");

	if(_fGroupTyping)
		_fMerge = TRUE;
	else
	{
		Assert(_fMerge == FALSE);
		_fGroupTyping = TRUE;
	}
}

/*
 *	CUndoStack::StopGroupTyping	()
 *
 *	@mfunc
 *		TOGGLES the group typing flag off.  If fGroupTyping is not set,
 *		then no merging of typing anti-events will be done
 */
void CUndoStack::StopGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::StopGroupTyping");

	_fGroupTyping = FALSE;
	_fMerge = FALSE;
}

/*
 *	CUndoStack::EnableSingleLevelMode()
 *
 *	@mfunc	Turns on single level undo mode; in this mode, we behave just like
 *			RichEdit 1.0 w.r.t. to Undo.
 *
 *	@rdesc
 *			HRESULT
 *
 *	@comm	This special mode means that undo is 1 level deep and everything 
 *			is accessed via UNDO messages.  Thus, instead of redo to undo an 
 *			undo action, you simply use another undo message. 
 *
 *	@devnote	This call is _ONLY_ allowed for the UndoStack; the redo 
 *			stack simply tags along.  Note that caller is responsible for
 *			ensuring that we are in an empty state.
 */
HRESULT CUndoStack::EnableSingleLevelMode()
{
	Assert(_ped->GetRedoMgr() == NULL || 
		_ped->GetRedoMgr()->CanUndo() == FALSE);
	Assert(CanUndo() == FALSE);
	Assert(_fRedo == FALSE);

	_fSingleLevelMode = TRUE;

	// For single level undo mode, it is very important to get
	// just 1 entry in the undo stack.  If we can't do that,
	// then we better just fail.
	if(SetUndoLimit(1) != 1)
	{
		_fSingleLevelMode = FALSE;
		return E_OUTOFMEMORY;
	}

	if(_ped->GetRedoMgr())
	{
		// doesn't matter if the redo manager fails to reset
		_ped->GetRedoMgr()->SetUndoLimit(1);
	}

	return NOERROR;
}

/*
 *	CUndoStack::DisableSingleLevelMode()
 *
 *	@mfunc	This turns off the 1.0 undo compatibility mode and restores us to 
 *			the RichEdit 2.0 default undo state
 */
void CUndoStack::DisableSingleLevelMode()
{
	Assert(_ped->GetRedoMgr() == NULL || 
		_ped->GetRedoMgr()->CanUndo() == FALSE);
	Assert(CanUndo() == FALSE);
	Assert(_fRedo == FALSE);

	_fSingleLevelMode = FALSE;

	// we don't care about failures here; multi-level undo mode
	// can handle any sized undo stack
	SetUndoLimit(DEFAULT_UNDO_SIZE);

	if(_ped->GetRedoMgr())
	{
		// doesn't matter if the redo manager can't grow back in
		// size; it just means that we won't have full redo capability.
		_ped->GetRedoMgr()->SetUndoLimit(DEFAULT_UNDO_SIZE);
	}
}

//
// PRIVATE METHODS
//

/*
 *	CUndoStack::Next()
 *
 *	@mfunc
 *		sets _index to the next available slot
 */
void CUndoStack::Next()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::Next");

	_index++;
	
	if(_index == _dwLim)
		_index = 0;
}

/*
 *	CUndoStack::Prev()
 *
 *	@mfunc
 *		sets _index to the previous slot
 */
void CUndoStack::Prev()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::Prev");

	_index = GetPrev();
}

/*
 *	CUndoStack::GetPrev()
 *
 *	@mfunc
 *		figures out what the index to the previous slot
 *		*should* be (but does not set it)
 *
 *	@rdesc	the index of what the previous slot would be
 */
DWORD CUndoStack::GetPrev()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetPrev");

	DWORD i = _index;

	if(i == 0)
		i = _dwLim - 1;
	else
		i--;

	return i;
}

/*
 *	CUndoStack::IsCookieInList (pae, paeCookie)
 *
 *	@mfunc	
 *		determines whether or not the given DoTo cookie is in
 *		the list of anti-events.
 *
 *	@rdesc	TRUE/FALSE
 */
BOOL CUndoStack::IsCookieInList(
	IAntiEvent *pae,		//@parm	List to check
	IAntiEvent *paeCookie)	//@parm Cookie to check
{
	while(pae)
	{
		if(pae == paeCookie)
			return TRUE;

		pae = pae->GetNext();
	}
	return FALSE;
}

/*
 *	CUndoStack::TransferToNewBuffer
 *
 *	@mfunc	
 *		transfers existing anti-events to the given buffer and
 *		swaps this undo stack to use the new buffer
 *
 *	@comm	The algorithm is very straightforward; go backwards in
 *			the ring buffer copying antievents over until either there
 *			are no more anti-events or the new buffer is full.  Discard
 *			any remaining anti-events.
 */
void CUndoStack::TransferToNewBuffer(UndoAction *prgnew, DWORD dwLimNew)
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::TransferToNewBuffer");

	DWORD 	iOld = 0, 
			iNew = 0,
			iCopyStart = 0;

	// First clear new buffer.
	FillMemory(prgnew, 0, dwLimNew * sizeof(UndoAction));

	// If there is nothing to copy, don't bother
	if(!_prgActions || !_prgActions[GetPrev()].pae)
		goto SetState;

	// This is a bit counter-intuitive, but since the stack is really
	// a ring buffer, go *forwards* until you hit a non-NULL slot.
	// This will be the _end_ of the existing antievents.
	//
	// However, we need to make sure that if dwLimNew is 
	// _smaller_ than _dwLim we only copy the final dwLimNew
	// anti-events.  We'll set iCopyStart to indicate when
	// we can start copying stuff.

	if(dwLimNew < _dwLim)
		iCopyStart = _dwLim - dwLimNew;

	for(; iOld < _dwLim; iOld++, Next())
	{
		if(!_prgActions[_index].pae)
			continue;

		if(iOld >= iCopyStart)
		{
			Assert(iNew < dwLimNew);
			// copy anti-events over 
			prgnew[iNew] = _prgActions[_index];
			iNew++;
		}
		else
		{
			// otherwise, get rid of them
			DestroyAEList(_prgActions[_index].pae);
			_prgActions[_index].pae = NULL;
		}
	}

SetState:
	
	//we start at index iNew
	_index = (iNew == dwLimNew) ? 0 : iNew;
	Assert(iNew <= dwLimNew);

	_dwLim = dwLimNew;
	
	if(_prgActions)
		delete _prgActions;

	_prgActions = prgnew;
}	

//
//	CGenUndoBuilder implementation
//

//
//	Public methods
//

/*
 *	CGenUndoBuilder::CGenUndoBuilder (ped, flags, ppubldr
 *
 *	@mfunc	Constructor
 *
 *	@comm
 *		This is a *PUBLIC* constructor
 */
CGenUndoBuilder::CGenUndoBuilder(
	CTxtEdit *		ped,		//@parm	Edit context
	DWORD			flags,		//@parm flags (usually UB_AUTOCOMMIT)
	IUndoBuilder **	ppubldr)	//@parm Ptr to undobldr interface
{
	// set everthing to NULL because instances can go on the stack
	_publdrPrev = NULL;
	// _pundo  is set below
	_idName = UID_UNKNOWN;
	_pfirstae = NULL;
	_fAutoCommit = FALSE;
	_fStartGroupTyping = FALSE;
	_fRedo = FALSE;
	_fDontFlushRedo = FALSE;
	_fInactive = FALSE;

	CompName	name = COMP_UNDOBUILDER;

	_ped 			= ped;

	if(flags & UB_AUTOCOMMIT)
		_fAutoCommit = TRUE;

	if(flags & UB_REDO)
	{
		_fRedo = TRUE;
		name = COMP_REDOBUILDER;
		_pundo = ped->GetRedoMgr();
	}
	else
		_pundo = ped->GetUndoMgr();

	// If undo is on, set *ppubldr to be this undo builder; else NULL
	// TODO: do we need to link in inactive undo builders?
	if(ppubldr)
	{
		if(!ped->_fUseUndo)				// Undo is disabled or suspended
		{								// Still have undobldrs since stack
			*ppubldr = NULL;			//  alloc is efficient. Flag this
			_fInactive = TRUE;			//  one as inactive
			return;
		}
		*ppubldr = this;
	}

	if(flags & UB_DONTFLUSHREDO)
		_fDontFlushRedo = TRUE;

	// Now link ourselves to any undobuilders that are higher up on
	// the stack.  Note that is is legal for multiple undo builders
	// to live within the same call context.

	_publdrPrev = (CGenUndoBuilder *)_ped->GetCallMgr()->GetComponent(name);

	// If we are in the middle of an undo, then we'll have two undo stacks
	// active, the undo stack and the redo stack.  Don't like the two
	// together.
	if(_fDontFlushRedo)
		_publdrPrev = NULL;

	_ped->GetCallMgr()->RegisterComponent((IReEntrantComponent *)this,
							name);
}

/*
 *	CGenUndoBuilder::~CGenUndoBuilder()
 *
 *	@mfunc	Destructor
 *
 *	@comm
 *		This is a *PUBLIC* destructor
 *
 *	Algorithm:
 *		If this builder hasn't been committed to an undo stack
 *		via ::Done, then we must be sure to free up any resources
 *		(antievents) we may be hanging onto
 */
CGenUndoBuilder::~CGenUndoBuilder()
{
	if(!_fInactive)
		_ped->GetCallMgr()->RevokeComponent((IReEntrantComponent *)this);

	if(_fAutoCommit)
	{
		Done();
		return;
	}

	// Free resources
	if(_pfirstae)
		DestroyAEList(_pfirstae);
}

/*
 *	CGenUndoBuilder::SetNameID (idName)
 *
 *	@mfunc
 *		Allows a name to be assigned to this anti-event collection.
 *		The ID should be an index that can be used to retrieve a
 *		language specific string (like "Paste").  This string is
 *		typically composed into undo menu items (i.e. "Undo Paste").
 */

void CGenUndoBuilder::SetNameID(
	UNDONAMEID idName)			//@parm	the name ID for this undo operation
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::SetNameID");

	// Don't delegate to the higher undobuilder, even if it exists. The
	// original name should win in re-entrancy cases.
	_idName = idName;
}

/*
 *	CGenUndoBuilder::AddAntiEvent (pae)
 *
 *	@mfunc
 *		Adds an anti-event to the end of the list
 *
 *	@rdesc 	NOERROR
 */
HRESULT CGenUndoBuilder::AddAntiEvent(
	IAntiEvent *pae)		//@parm	anti-event to add
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::AddAntiEvent");

	if(_publdrPrev)
		return _publdrPrev->AddAntiEvent(pae);

	pae->SetNext(_pfirstae);
	_pfirstae = pae;

	return NOERROR;
}

/*
 *	CGenUndoBuilder::GetTopAntiEvent
 *
 *	@mfunc	Gets the top anti-event for this context.
 *
 *	@comm	The current context can be either the current
 *			operation *or* to a previous operation if we are in
 *			merge typing mode.
 *
 *	@rdesc	top anti-event
 */
IAntiEvent *CGenUndoBuilder::GetTopAntiEvent()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::GetTopAntiEvent");

	if(_publdrPrev)
	{
		Assert(_pfirstae == NULL);
		return _publdrPrev->GetTopAntiEvent();
	}

	if(!_pfirstae && _pundo)
		return _pundo->GetMergeAntiEvent();

	return _pfirstae;
}

/*
 *	CGenUndoBuilder::Done ()
 *
 *	@mfunc
 *		puts the combined anti-events (if any) into the undo stack
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CGenUndoBuilder::Done()
{
	HRESULT		hr = NOERROR;
	DWORD		dwLim = DEFAULT_UNDO_SIZE;
	IUndoMgr *	predo;
	IAntiEvent *paetemp;

	if(_publdrPrev)
	{
		Assert(_pfirstae == NULL);
		return NOERROR;
	}

	if(_ped->GetDetectURL())
		_ped->GetDetectURL()->ScanAndUpdate(_pundo ? this : NULL);

	// If nothing changed, discard any selection anti-events
	// or other no-op actions.
	if(!_ped->GetCallMgr()->GetChangeEvent())
	{
		Discard();
		return NOERROR;
	}

	if(_pfirstae)
	{
		if(!_pundo)
		{
			// yikes!  There is no undo stack; better create one.

			// if we are a redo guy, we should create a redo
			// stack the size of the undo stack

			if(_fRedo)
			{
				Assert(_ped->GetUndoMgr());

				dwLim = _ped->GetUndoMgr()->GetUndoLimit();
			}

			_pundo = _ped->CreateUndoMgr(dwLim,	_fRedo ? US_REDO : US_UNDO);

			// FUTURE:  A NULL ptr returned from CreateUndoMgr means either
			// 	we are out of memory, or the undo limit is set to 0.  For the
			// 	latter case, we have collected AE's to push onto a non-existent
			// 	undo stack.  It may be more efficient to not generate
			// 	the AE's at all when the undo limit is 0.

			if(!_pundo)
				goto CleanUp;
		}

		// We may need to flush the redo stack if we are adding
		// more anti-events to the undo stack *AND* we haven't been
		// told not to flush the redo stack.  The only time we won't
		// flush the redo stack is if it's the redo stack itself
		// adding anti-events to undo.

		if(!_fRedo)
		{
			// If our destination is the undo stack, then check
			// to see if we should flush
			if(!_fDontFlushRedo)
			{
				predo = _ped->GetRedoMgr();
				if(predo)
					predo->ClearAll();
			}
		}
#ifdef DEBUG
		else
		{
			Assert(!_fDontFlushRedo);
		}

#endif // DEBUG

		// If we should enter into the group typing state, inform
		// the undo manager.  Note that we only do this *iff* 
		// there is actually some anti-event to put in the undo
		// manager.  This makes the undo manager easier to implement
		if(_fStartGroupTyping)
			_pundo->StartGroupTyping();
		
		hr = _pundo->PushAntiEvent(_idName, _pfirstae);

		// The change event flag should be set if we're adding
		// undo items!   If this test is true, it probably means
		// the somebody earlier in the call stack sent change
		// notifiations (either via SendAllNotifications or
		// the CAutonotify class) _before_ this undo context
		// was committed _or_ it means that we were re-entered
		// in some way that was not handled properly.
		//
		// Needless to say, this is not an ideal state.

CleanUp:
		Assert(_ped->GetCallMgr()->GetChangeEvent());

		paetemp = _pfirstae;
		_pfirstae = NULL;
		
		CommitAEList(paetemp, _ped);

		if(!_pundo || hr != NOERROR)
		{
			// Either we failed to add the AE's to the undo stack
			// or the undo limit is 0 in which case there won't be
			// an undo stack to push the AE's onto.
			DestroyAEList(paetemp);
		}
	}
	return hr;
}

/*
 *	CGenUndoBuilder::Discard ()
 *
 *	@mfunc
 *		Gets rid of any anti-events that we may be hanging onto without
 *		executing or committing them.  Typically used for recovering
 *		from certain failure or re-entrancy scenarios.  Note that
 *		an _entire_ anti-event chain will be removed in this fashion.
 */
void CGenUndoBuilder::Discard()
{
	if(_pfirstae)
	{
		DestroyAEList(_pfirstae);
		_pfirstae = NULL;
	}
	else if(_publdrPrev)
		_publdrPrev->Discard();
}

/*
 *	CGenUndoBuilder::StartGroupTyping ()
 *
 *	@mfunc
 *		hangs onto the the fact that group typing should start.
 *		We'll forward the the state transition to the undo manager
 *		only if an anti-event is actually added to the undo manager.
 *
 *	@devnote
 *		group typing is disabled for redo stacks.
 */
void CGenUndoBuilder::StartGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::StartGroupTyping");

	_fStartGroupTyping = TRUE;
}

/*
 *	CGenUndoBuilder::StopGroupTyping ()
 *
 *	@mfunc
 *		forwards a stop grouped typing to the undo manager
 */

void CGenUndoBuilder::StopGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::StopGroupTyping");

	if(_pundo)
		_pundo->StopGroupTyping();
}

//
//	CUndoStackGuard IMPLEMENTATION
//

/*
 *	CUndoStackGuard::CUndoStackGuard(ped)
 *
 *	@mfunc	Constructor.  Registers this object with the call manager
 */
CUndoStackGuard::CUndoStackGuard(
	CTxtEdit *ped)			//@parm the edit context
{
	_ped = ped;
	_fReEntered = FALSE;
	_hr = NOERROR;
	ped->GetCallMgr()->RegisterComponent(this, COMP_UNDOGUARD);
}

/*
 *	CUndoStackGuard::~CUndoStackGuard()
 *
 *	@mfunc	Destructor.  Revokes the registration of this object
 *			with the call manager
 */
CUndoStackGuard::~CUndoStackGuard()
{
	_ped->GetCallMgr()->RevokeComponent(this);
}

/*
 *	CUndoStackGuard::SafeUndo
 *
 *	@mfunc	Loops through the given list of anti-events, invoking
 *			undo on each.  
 *
 *	@rdesc	HRESULT, from the undo actions
 *
 *	@devnote	This routine is coded so that OnEnterContext can pick up
 *			and continue the undo operation should we become re-entered
 */
HRESULT CUndoStackGuard::SafeUndo(
	IAntiEvent *pae,		//@parm the start of the anti-event list
	IUndoBuilder *publdr)	//@parm the undo builder to use
{
	_publdr = publdr;

	while(pae)
	{
		_paeNext = pae->GetNext();
		HRESULT hr = pae->Undo(_ped, publdr);

		// save the first returned error.
		if(hr != NOERROR && _hr == NOERROR)
			_hr = hr;

		pae = (IAntiEvent *)_paeNext;
	}

	return _hr;
}

/*
 *	CUndoStackGuard::OnEnterContext
 *
 *	@mfunc	Handle re-entrancy during undo operations.
 *
 *	@devnote If this method is called, it's pretty serious.  In general,
 *			we shoud never be re-entered while processing undo stuff.
 *			However, to ensure that, block the incoming call and process
 *			the remaining actions.
 */
void CUndoStackGuard::OnEnterContext()
{
	TRACEWARNSZ("ReEntered while processing undo.  Blocking call and");
	TRACEWARNSZ("	attempting to recover.");

	_fReEntered = TRUE;
	SafeUndo((IAntiEvent *)_paeNext, _publdr);
}	

//
//	PUBLIC helper functions
//

/*
 *	@func	DestroyAEList | Destroys a list of anti-events
 */
void DestroyAEList(
	IAntiEvent *pae)	//@parm the anti-event from which to start
{
	IAntiEvent *pnext;

	while(pae)
	{
		pnext = pae->GetNext();
		pae->Destroy();
		pae = pnext;
	}
}

/*
 *	@func CommitAEList | Calls OnCommit to the given list of anti-events
 */
void CommitAEList(
	IAntiEvent *pae,	//@parm the anti-event from which to start
	CTxtEdit *ped)		//@parm the edit context
{
	IAntiEvent *pnext;

	while(pae)
	{
		pnext = pae->GetNext();
		pae->OnCommit(ped);
		pae = pnext;
	}
}

/*
 *	@func	HandleSelectionAEInfo | Tries to merge the given info with 
 *			the existing undo context; if that fails, then it allocates 
 *			a new selection anti-event to handle the info
 */
HRESULT HandleSelectionAEInfo(
	CTxtEdit *ped,			//@parm the edit context
	IUndoBuilder *publdr,	//@parm the undo context
	LONG cp,				//@parm the cp to use for the sel ae
	LONG cch,				//@parm the signed selection extension
	LONG cpNext,			//@parm the cp to use for the AE of the AE
	LONG cchNext,			//@parm the cch to use for the AE of the AE
	SELAE flags)			//@parm controls how to intepret the info
{
	IAntiEvent *pae;

	Assert(publdr);

	pae = publdr->GetTopAntiEvent();

	// First see if we can merge the selection info into any existing
	// anti-events.  Note that the selection anti-event may be anywhere
	// in the list, so go through them all
	if(pae)
	{
		SelRange sr;

		sr.cp		= cp;
		sr.cch		= cch;
		sr.cpNext	= cpNext;
		sr.cchNext	= cchNext;
		sr.flags	= flags;

		while(pae)
		{
			if(pae->MergeData(MD_SELECTIONRANGE, (void *)&sr) == NOERROR)
				break;
			pae = pae->GetNext();
		}
	
		if(pae)
			return NOERROR;
	}

	// Oops; can't do a merge.  Go ahead and create a new anti-event.

	Assert(!pae);

	pae = gAEDispenser.CreateSelectionAE(ped, cp, cch, cpNext, cchNext);

	if(pae)
	{
		publdr->AddAntiEvent(pae);
		return NOERROR;
	}

	return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\makefile.inc ===
$(O)\w32sys.obj : w32sys.cpp
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\w32sys.cpp
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\notmgr.cpp ===
/*
 *	NOTMGR.C
 *
 *	Purpose:
 *		Notification Manager implemenation
 *
 *	Author:
 *		AlexGo	6/5/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_notmgr.h"

ASSERTDATA

/*
 *	CNotifyMgr::CNotifyMgr ()
 */
CNotifyMgr::CNotifyMgr()
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::CNotifyMgr");

	_pitnlist = NULL;
}

/*
 *	CNotifyMgr::~CNotifyMgr ()
 *
 */
CNotifyMgr::~CNotifyMgr()
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::~CNotifyMgr");

	ITxNotify *plist;

	for( plist = _pitnlist; plist != NULL; plist = plist->_pnext )
	{
		plist->Zombie();
	}

	TRACEERRSZSC("CNotifyMgr::~CNotifyMgr(): zombie(s) exist", _pitnlist != 0);
}

/*
 *	CNotifyMgr::Add (pITN)
 *
 *	@mfunc
 *		Adds a notification sink to the list
 *
 *	Algorithm:
 *		puts the entry at the *front* of the notification list, so
 *		that high frequency entries (like ranges and text pointers
 *		existing on the stack) can be added and removed efficiently
 */
void CNotifyMgr::Add(
	ITxNotify *pITN )
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::Add");

		pITN->_pnext = _pitnlist;
		_pitnlist = pITN;
}

/*
 *	CNotifyMgr::Remove (pITN)
 *
 *	@mfunc
 *		removes a notification sink from the list
 */
void CNotifyMgr::Remove(
	ITxNotify *pITN )
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::Remove");

	ITxNotify *plist = _pitnlist;
	ITxNotify **ppprev = &_pitnlist;

	while(plist)
	{
		if( plist == pITN )
		{
			*ppprev = plist->_pnext;
			break;
		}
		ppprev = &(plist->_pnext);
		plist = plist->_pnext;
	}
}

/*
 *	CNotifyMgr::NotifyPreReplaceRange (pITNignore, cp, cchDel, cchNew)
 *
 *	@mfunc
 *		send an OnReplaceRange notification to all sinks (except pITNignore)
 */
void CNotifyMgr::NotifyPreReplaceRange(
	ITxNotify *	pITNignore,	//@parm Notification sink to ignore
	LONG		cp, 		//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,		//@parm Count of chars after cp that are deleted
	LONG		cchNew,		//@parm Count of chars inserted after cp
	LONG		cpFormatMin,//@parm cpMin  for a formatting change
	LONG		cpFormatMax)//@parm cpMost for a formatting change
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::NotifyPreReplaceRange");

	ITxNotify *plist;

	for( plist = _pitnlist; plist != NULL; plist = plist->_pnext )
	{
		if( plist != pITNignore )
		{
			plist->OnPreReplaceRange( cp, cchDel, cchNew, cpFormatMin, 
				cpFormatMax );
		}
	}
}

/*
 *	CNotifyMgr::NotifyPostReplaceRange (pITNignore, cp, cchDel, cchNew)
 *
 *	@mfunc
 *		send an OnReplaceRange notification to all sinks (except pITNignore)
 *
 *	@comm
 *		pITNignore typically is the TxtPtr/etc that is actually making the
 *		ReplaceRange modification
 */
void CNotifyMgr::NotifyPostReplaceRange(
	ITxNotify *	pITNignore,	//@parm Notification sink to ignore
	LONG		cp, 		//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,		//@parm Count of chars after cp that are deleted
	LONG		cchNew,		//@parm Count of chars inserted after cp
	LONG		cpFormatMin,//@parm cpMin  for a formatting change
	LONG		cpFormatMax)//@parm cpMost for a formatting change
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::NotifyPostReplaceRange");

	ITxNotify *plist;

	for( plist = _pitnlist; plist != NULL; plist = plist->_pnext )
	{
		if( plist != pITNignore )
		{
			plist->OnPostReplaceRange( cp, cchDel, cchNew, cpFormatMin,
				cpFormatMax );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\magellan.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module magellan.cpp -- Handle magellan mouse. |
 *	
 *		For REC 2, Magellan mouse can roll scroll and mButtonDown drag scroll.
 *
 *	Owner: <nl>
 *		Jon Matousek - 1996
 *
 *	Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 */								 

#include "_common.h"

#if !defined(NOMAGELLAN)

#include "_edit.h"
#include "_disp.h"
#include "_magelln.h"

ASSERTDATA

/*
 *	CMagellan::MagellanStartMButtonScroll
 *
 *	@mfunc
 *		Called when we get an mButtonDown message. Initiates tracking
 *		of the mouse which in turn will scroll at various speeds based
 *		on how far the user moves the mouse from the mDownPt.
 *
 *	@rdesc
 *		TRUE if the caller should capture the mouse.
 *
 */
BOOL CMagellan::MagellanStartMButtonScroll( CTxtEdit &ed, POINT mDownPt )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::MagellanStartMButtonScroll");

	RECT	rc;
	BOOL	fCapture = FALSE;
	CDisplay *pdp;

	pdp = ed._pdp;
	if ( pdp)
	{
		pdp->GetViewRect(rc);						// skip scroll bars, etc.
		if ( PtInRect(&rc, mDownPt) && !_fMButtonScroll )
		{
			fCapture				= TRUE;
			_ID_currMDownBMP		= 0;
			_fMButtonScroll			= TRUE;			// Now tracking...
			_zMouseScrollStartPt	= mDownPt;
			_fLastScrollWasRoll		= FALSE;		// Differentiate type.

			CheckInstallMagellanTrackTimer ( ed );	// Fire up timer...
		}
	}
	return fCapture;
}

/*
 *	CMagellan::MagellanEndMButtonScroll
 *
 *	@mfunc
 *		Finished tracking mButtonDown magellan scroll, finish up state.
 *
 */
VOID CMagellan::MagellanEndMButtonScroll( CTxtEdit &ed )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::MagellanEndMButtonScroll");

	CDisplay *pdp;


	_fMButtonScroll = FALSE;
	CheckRemoveMagellanUpdaterTimer ( ed );			// Remove timer...

	pdp = ed._pdp;
	if ( pdp )
	{
		pdp->FinishSmoothVScroll();			// So smooth scroll stops.
		InvertMagellanDownBMP(pdp, FALSE, NULL);	// Turn it off.
	}

	if ( _MagellanMDownBMP )						// Release bitmap.
	{
		DeleteObject( _MagellanMDownBMP );
		_MagellanMDownBMP = NULL;
		_ID_currMDownBMP = 0;
	}
}

/*
 *	CMagellan::MagellanRollScroll
 *
 *	@mfunc
 *		Handle the Magellan WM_MOUSEROLLER message. This routine has global, internal
 *		state that allows the number of lines scrolled to increase if the user continues
 *		to roll the wheel in rapid succession.
 *
 */
VOID CMagellan::MagellanRollScroll ( CDisplay *pdp, int direction, WORD cLines, 
			int speedNum, int speedDenom, BOOL fAdditive )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::MagellanRollScroll");

	static DWORD	lastFastRollTime;
	static int		lastDirection;
	static INT		cFastRolls;
	DWORD			tickCount = GetTickCount();

	if ( !_fMButtonScroll && pdp )
	{
														// start/continue fast
		if ( tickCount - lastFastRollTime <	FAST_ROLL_SCROLL_TRANSITION_TICKS			
			|| ((lastDirection ^ (direction < 0 ? -1 : 1)) == 0	// or, same sign
					&& _fLastScrollWasRoll				// and in slow.
					&& pdp->IsSmoothVScolling() ))
		{
			cFastRolls++;
			if ( cFastRolls > FASTER_ROLL2_COUNT )		// make faster.
				cLines <<= 1;
			else if ( cFastRolls > FASTER_ROLL1_COUNT )	// make fast
				cLines += 1;
			speedNum = cLines;							// Cancel smooth
														// effect.
			lastFastRollTime = tickCount;
		}
		else
		{
			cFastRolls = 0;
		}												// Do the scroll.
		pdp->SmoothVScroll( direction, cLines, speedNum, speedDenom, TRUE);

		_fLastScrollWasRoll = TRUE;
		lastDirection = (direction < 0) ? -1 : 1;
	}
}

/*
 *	CMagellan::CheckInstallMagellanTrackTimer
 *
 *	@mfunc
 *		Install a timing task that will allow TrackUpdateMagellanMButtonDown
 *		To be periodically called.
 *
 *	@devnote
 *		The CTxtEdit class handles all WM_TIMER dispatches, so there's glue there
 *		to call our magellan routine.
 *
 */
VOID CMagellan::CheckInstallMagellanTrackTimer ( CTxtEdit &ed )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::CheckInstallMagellanTrackTimer");

	ed.TxSetTimer(RETID_MAGELLANTRACK, cmsecScrollInterval);
}

/*
 *	CMagellan::CheckRemoveMagellanUpdaterTimer
 *
 *	@mfunc
 *		Remove the timing task that dispatches to TrackUpdateMagellanMButtonDown.
 *
 */
VOID CMagellan::CheckRemoveMagellanUpdaterTimer ( CTxtEdit &ed )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::CheckRemoveMagellanUpdaterTimer");

	ed.TxKillTimer(RETID_MAGELLANTRACK);
}

/*
 *	CMagellan::TrackUpdateMagellanMButtonDown
 *
 *	@mfunc
 *		After mButtonDown capture, a periodic WM_TIMER calls this from OnTxTimer(). The cursor
 *		is tracked to determine direction, speed, and in dead zone (not moving).
 *		Movement is dispacted to CDisplay. The cursor is set to the appropriate
 *		direction cusor, and the mButtonDown point BMP is drawn.
 */
VOID CMagellan::TrackUpdateMagellanMButtonDown ( CTxtEdit &ed, POINT mousePt )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::TrackUpdateMagellanMButtonDown");

	RECT	deadZone, rcClient;
	WORD	wide, tall, xInset, yInset;
	POINT	pt, center;

	LONG	xDiff, yDiff, inflate, target;

	SHORT	IDC_mScrollCursor, IDC_mDeadScrollCursor;

	BOOL	fDoHScroll, fDoVScroll;
	BOOL	fFastScroll = FALSE;

	CDisplay *pdp;

	pdp = ed._pdp;

	Assert ( _fMButtonScroll );
	Assert ( pdp );
													// Calc dead zone rect.
	deadZone.top = deadZone.bottom = _zMouseScrollStartPt.y;
	deadZone.left = deadZone.right = _zMouseScrollStartPt.x;
	inflate = pdp->LYtoDY(DEAD_ZONE_TWIPS);
	InflateRect(&deadZone, inflate, inflate);

	
	//
	//	Calculate direction to scroll and what cusor to display. 
	//
	//	By numbering a compass like the following, we can easily calc the index into
	//	the scrollCursors array to get the proper cursor:
	//
	//							North = 1
	//					NW = 7				NE = 4
	//				West = 6					East = 3
	//					SW = 8				SE = 5
	//							South = 2
	//
	IDC_mScrollCursor = 0;
	IDC_mDeadScrollCursor = 0;
	fDoVScroll = FALSE;
	fDoHScroll = FALSE;
	if ( pdp->IsVScrollEnabled() )					// Can scroll vertically?
	{
		IDC_mDeadScrollCursor = 1;
		if ( mousePt.y < deadZone.top || mousePt.y > deadZone.bottom )
		{
			fDoVScroll = TRUE;
			IDC_mScrollCursor = ( mousePt.y < _zMouseScrollStartPt.y )	? 1 : 2;
		}
	}

	// FUTURE (alexgo): allow magellan scrolling even for single line
	// controls with no scrollbar.  For now, however, that change is too
	// risky, so we look explicity for a scrollbar.
	if( pdp->IsHScrollEnabled() && ed.TxGetScrollBars() & WS_HSCROLL )	// Can scroll horizontally?
	{
		IDC_mDeadScrollCursor |= 2;
		if ( mousePt.x < deadZone.left || mousePt.x > deadZone.right )
		{
			fDoHScroll = TRUE;
			IDC_mScrollCursor += ( mousePt.x < _zMouseScrollStartPt.x ) ? 6 : 3;
		}
	}

	SHORT scrollCursors[] = {						// Cursor for various
		0,											//  directions.

		IDC_SCROLLNORTH,
		IDC_SCROLLSOUTH,
		IDC_SCROLLEAST,
		IDC_SCROLLNE,
		IDC_SCROLLSE,
		IDC_SCROLLWEST,
		IDC_SCROLLNW,
		IDC_SCROLLSW
	};
	IDC_mScrollCursor = scrollCursors[IDC_mScrollCursor];

	SHORT mDownBMPs[] = {							// mButtonDown origin BMPs.
		0,

		IDB_1DVSCROL,
		IDB_1DHSCROL,
		IDB_2DSCROL
	};

													// BMAP-mButtonDown for UI
	if ( mDownBMPs[IDC_mDeadScrollCursor] != _ID_currMDownBMP )
	{
		if ( _MagellanMDownBMP )					// Undraw old BMP.
		{
			InvertMagellanDownBMP( pdp, FALSE, NULL );

			DeleteObject ( _MagellanMDownBMP );
			_MagellanMDownBMP = NULL;
		}
													// Draw new BMP.
		_ID_currMDownBMP = mDownBMPs[IDC_mDeadScrollCursor];
		_MagellanMDownBMP = LoadBitmap ( hinstRE, MAKEINTRESOURCE ( _ID_currMDownBMP ) );
		InvertMagellanDownBMP( pdp, TRUE, NULL );
	}

													// Moved out of dead zone?
	if ( fDoVScroll || fDoHScroll )					//  time to scroll...
	{									

													// Prepare data for
													//  scrolling routines.

		ed.TxGetClientRect(&rcClient);				// Get our client rect.
		wide = rcClient.right - rcClient.left;
		tall = rcClient.bottom - rcClient.top;

													// Calc center of rcClient.
		center.x = rcClient.left + (wide >> 1);
		center.y = rcClient.top + (tall >> 1);

		xInset = (wide >> 1) - 2;					// Get inset to center
		yInset = (tall >> 1) - 2;					//  about rcClient.

													// Map origin to rcClient.
		xDiff = mousePt.x - _zMouseScrollStartPt.x;
		yDiff = mousePt.y - _zMouseScrollStartPt.y;
		pt.x = center.x + xDiff;
		pt.y = center.y + yDiff;
													// Determine scroll speed.
		target = (tall * 2) / 5;					// target is 40% of screen
													// height.  Past that, we
													// scroll page at a time.

		yDiff = abs(yDiff);

		if ( yDiff >= target )						// Fast scroll?
		{
			fFastScroll = TRUE;
													// Stop mutually exclusive
			pdp->CheckRemoveSmoothVScroll();		//  scroll type.

													// Fast line scroll.
			if ( fDoVScroll )						// Vertically a page at a time.
			{
				pdp->VScroll( ( _zMouseScrollStartPt.y - mousePt.y < 0 ) ? SB_PAGEDOWN : SB_PAGEUP, 0 );
			}

			if ( fDoHScroll )						
			{										
				pt.y = center.y;					// Prevent y dir scrolling.
													// Do x dir scroll.
				pdp->AutoScroll( pt, xInset, 0 );
			}
		}
		else										// Smooth scroll.
		{
													// Start, or continue
													//  smooth vertical scrolling.

			// This formula is a bit magical, but here goes.  What
			// we want is the sub-linear part of an exponential function.
			// In other words, smallish distances should produce pixel
			// by pixel scrolling.  At 40% of the screen height, however,
			// we should be srolling by a page at a time (tall # of pixels).
			//
			// So the formula we use is (x^2)/tall, where x is yDiff scaled
			// to be in units of tall (i.e. 5yDiff/2).   The final 10* 
			// multiplier is to shift all the values leftward so we can
			// do this in integer arithmetic.
			LONG num = MulDiv(10*25*yDiff/4, yDiff, tall);

			if( !num )
			{
				num = 1;
			}

			if ( fDoVScroll )
			{
				pdp->SmoothVScroll ( _zMouseScrollStartPt.y - mousePt.y,
									0, num, 10*tall, FALSE );
			}
			
													// x direction scrolling?
			if ( fDoHScroll )						
			{										
				pt.y = center.y;					// Prevent y dir scrolling.
													// Do x dir scroll.
				pdp->AutoScroll( pt, xInset, 0 );
			}
		}

		// notify through the messagefilter that we scrolled
		if ((ed._dwEventMask & ENM_SCROLLEVENTS) && (fDoHScroll || fDoVScroll))
		{
			MSGFILTER msgfltr;
			ZeroMemory(&msgfltr, sizeof(MSGFILTER));
			if (fDoHScroll)
			{
				msgfltr.msg = WM_HSCROLL;
				msgfltr.wParam = fFastScroll ?
									(xDiff > 0 ? SB_PAGERIGHT: SB_PAGELEFT):
									(xDiff > 0 ? SB_LINERIGHT: SB_LINELEFT);
			}
			else
			{
				msgfltr.msg = WM_VSCROLL;
				msgfltr.wParam = fFastScroll ?
									(yDiff > 0 ? SB_PAGEDOWN: SB_PAGEUP):
									(yDiff > 0 ? SB_LINEDOWN: SB_LINEUP);
			}

			msgfltr.lParam = NULL;
			
			// we don't check the result of this call --
			// it's not a message we received and we're not going to
			// process it any further
			ed._phost->TxNotify(EN_MSGFILTER, &msgfltr);			
		}


	}
	else
	{												// No scroll in dead zone.

		SHORT noScrollCursors[] = {
			  0,
			  IDC_NOSCROLLV,
			  IDC_NOSCROLLH,
			  IDC_NOSCROLLVH
		};											// Set dead-zone cursor.
		IDC_mScrollCursor = noScrollCursors[IDC_mDeadScrollCursor];

		pdp->FinishSmoothVScroll();			// Finish up last line.
	}
													// Set magellan cursor.
	ed._phost->TxSetCursor(IDC_mScrollCursor ? 
		LoadCursor(hinstRE, MAKEINTRESOURCE(IDC_mScrollCursor)) : 
		ed._hcurArrow, FALSE);
}



/*
 *	BOOL CMagellan::InvertMagellanDownBMP
 *
 *	@mfunc
 *		Magellan mouse UI requires that the mouse down point draw
 *		and maintain a bitmap in order to help the user control scroll speed.
 *
 *	@devnote
 *		This routine is designed to be nested. It also handles WM_PAINT updates
 *		when the repaintDC is passed in. Because there is no support for multiple
 *		cursors in the operating system, all WM_PAINT and ScrollWindow redraws
 *		must temporarily turn off the BMP and then redraw it. This gives the
 *		BMAP a flicker.
 *
 *	@rdesc
 *		TRUE if the bitmap was previously drawn.
 */
BOOL CMagellan::InvertMagellanDownBMP( CDisplay *pdp, BOOL fTurnOn, HDC repaintDC )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::InvertMagellanDownBMP");

	BOOL	fOldState = _fMagellanBitMapOn;

	Assert (pdp);

	if ( fOldState != fTurnOn )
	{
		if ( _MagellanMDownBMP )
		{
			BITMAP	bm;
			HDC		hdcMem, screenDC;
			POINT	ptSize, ptOrg;

			screenDC = (repaintDC != NULL) ? repaintDC : pdp->GetDC();
			if ( screenDC )
			{
				hdcMem = CreateCompatibleDC ( screenDC );
				if ( hdcMem )
				{
					SelectObject ( hdcMem, _MagellanMDownBMP );
					SetMapMode ( hdcMem, GetMapMode (screenDC) );

					if ( GetObjectA( _MagellanMDownBMP, sizeof(BITMAP), (LPVOID) &bm) )
					{
						ptSize.x = bm.bmWidth;
						ptSize.y = bm.bmHeight;
						DPtoLP ( screenDC, &ptSize, 1 );
						ptOrg.x = 0;
						ptOrg.y = 0;
						DPtoLP( hdcMem, &ptOrg, 1 );

						BitBlt( screenDC,
							_zMouseScrollStartPt.x - (ptSize.x >> 1) - 1,
							_zMouseScrollStartPt.y - (ptSize.y >> 1) + 1,
							ptSize.x, ptSize.y,
							hdcMem, ptOrg.x, ptOrg.y, 0x00990066 /* NOTXOR */ );
							

						_fMagellanBitMapOn = !fOldState;
					}
					DeleteDC( hdcMem );
				}
				if ( repaintDC == NULL ) pdp->ReleaseDC( screenDC );
			}
		}
	}

	return fOldState;
}

////////////////////////// 	CMagellanBMPStateWrap class.

/*
 *	CMagellanBMPStateWrap:: CMagellanBMPStateWrap
 *
 *	@mfunc
 *		Handles the state of whether to redraw the Magellan BMP as well as
 *		repaints due to WM_PAINT.
 *
 *	@devnote
 *		This class is akin to smart pointer wrapper class idioms, in that
 *		no matter how a routine exits the correct state of whether the
 *		BMP is drawn will be maintined.
 */
CMagellanBMPStateWrap:: CMagellanBMPStateWrap(CTxtEdit &ed, HDC repaintDC)
	: _ed(ed), _repaintDC(repaintDC)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellanBMPStateWrap:: CMagellanBMPStateWrap");

	BOOL fRepaint;

	fRepaint = repaintDC != NULL && _ed.mouse._fMagellanBitMapOn != 0;
	_fMagellanState = fRepaint || _ed.mouse.InvertMagellanDownBMP(_ed._pdp, FALSE, NULL);
	_ed.mouse._fMagellanBitMapOn = FALSE;
}

CMagellanBMPStateWrap::~CMagellanBMPStateWrap()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellanBMPStateWrap::~CMagellanBMPStateWrap");

	_ed.mouse.InvertMagellanDownBMP(_ed._pdp, _fMagellanState, _repaintDC);
}



#endif // !defined(NOMAGELLAN)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\olsole.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	OLSOLE.CPP -- OlsOle LineServices object class
 *	
 *	Author:
 *		Murray Sargent (with lots of help from RickSa's ols code)
 *
 *	Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_font.h"
#include "_edit.h"
#include "_disp.h"
#include "_ols.h"
#include "_render.h"
extern "C" {
#include "objdim.h"
#include "pobjdim.h"
#include "plsdnode.h"
#include "dispi.h"
#include "pdispi.h"
#include "fmti.h"
#include "lsdnset.h"
#include "lsdnfin.h"
#include "brko.h"
#include "pbrko.h"
#include "locchnk.h"
#include "lsqout.h"
#include "lsqin.h"
#include "lsimeth.h"
}

#ifdef LINESERVICES

/*
 *	OlsOleCreateILSObj(pols, plsc, pclscbk, dword, ppilsobj)
 *
 *	@func
 *		Create LS Ole object handler. We don't have any need for
 *		this, so just set it to 0.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleCreateILSObj(
	POLS	 pols,		//[IN]: COls * 
	PLSC	 plsc,  	//[IN]: LineServices context
	PCLSCBK,
	DWORD,
	PILSOBJ *ppilsobj)	//[OUT]: ptr to ilsobj
{
	*ppilsobj = 0;
	return lserrNone;
}

/*
 *	OlsOleDestroyILSObj(pilsobj)
 *
 *	@func
 *		Destroy LS Ole handler object. Nothing to do, since we don't
 *		use the ILSObj.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDestroyILSObj(
	PILSOBJ pilsobj)
{
	return lserrNone;
}

/*
 *	OlsOleSetDoc(pilsobj, pclsdocinf)
 *
 *	@func
 *		Set doc info. Nothing to do for Ole objects
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleSetDoc(
	PILSOBJ, 
	PCLSDOCINF)
{
	// Ole objects don't care about this
	return lserrNone;
}

/*
 *	OlsOleCreateLNObj(pilsobj, pplnobj)
 *
 *	@func
 *		Create the line object. Nothing needed in addition to the ped,
 *		so just return the ped as the LN object.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleCreateLNObj(
	PCILSOBJ pilsobj, 
	PLNOBJ * pplnobj)
{
	*pplnobj = (PLNOBJ)g_pols->_pme->GetPed();			// Just the ped
	return lserrNone;
}

/*
 *	OlsOleDestroyLNObj(plnobj)
 *
 *	@func
 *		Destroy LN object. Nothing to do, since ped is destroyed
 *		elsewhere
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDestroyLNObj(
	PLNOBJ plnobj)
{
	return lserrNone;
}

/*
 *	OlsOleFmt(plnobj, pcfmtin, pfmres)
 *
 *	@func
 *		Compute dimensions of a particular Ole object
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleFmt(
	PLNOBJ	plnobj, 
	PCFMTIN pcfmtin, 
	FMTRES *pfmres)
{
	const LONG		cp = pcfmtin->lsfrun.plsrun->_cp; //Cannot trust LS cps
	LONG			dup = 0;
	LSERR			lserr;
	OBJDIM			objdim;
	CTxtEdit *		ped  = (CTxtEdit *)plnobj;
	COleObject *	pobj = ped->GetObjectMgr()->GetObjectFromCp(cp);
	Assert(pobj);

	ZeroMemory(&objdim, sizeof(objdim));

	pobj->MeasureObj(g_pols->_pme->GetDyrInch(), g_pols->_pme->GetDxrInch(),
					 objdim.dur, objdim.heightsRef.dvAscent,
					 objdim.heightsRef.dvDescent, pcfmtin->lstxmRef.dvDescent);
	
	pobj->MeasureObj(g_pols->_pme->GetDypInch(), g_pols->_pme->GetDxpInch(),
					 dup, objdim.heightsPres.dvAscent,
					 objdim.heightsPres.dvDescent, pcfmtin->lstxmPres.dvDescent);

	pobj->_plsdnTop = pcfmtin->plsdnTop;

	lserr = g_plsc->dnFinishRegular(1, pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, (PDOBJ)pobj, &objdim);
	if(lserrNone == lserr) 
	{
		lserr = g_plsc->dnSetRigidDup(pcfmtin->plsdnTop, dup);
		if(lserrNone == lserr) 
		{
			*pfmres = fmtrCompletedRun;

			if (pcfmtin->lsfgi.urPen + objdim.dur > pcfmtin->lsfgi.urColumnMax 
				&& !pcfmtin->lsfgi.fFirstOnLine)
			{
				*pfmres = fmtrExceededMargin;
			}
		}
	}
	return lserr;
}


/*
 *	OlsOleTruncateChunk(plocchnk, posichnk)
 *
 *	@func
 *		Truncate chunk plocchnk at the point posichnk
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleTruncateChunk(
	PCLOCCHNK plocchnk,		// (IN): locchnk to truncate
	PPOSICHNK posichnk)		// (OUT): truncation point
{
	LSERR			lserr;
	OBJDIM			objdim;
	PLSCHNK 		plschnk = plocchnk->plschnk;
	COleObject *	pobj;
	long			ur	 = plocchnk->lsfgi.urPen;
	long			urColumnMax = plocchnk->lsfgi.urColumnMax;

	for(DWORD i = 0; ur <= urColumnMax; i++)
	{
		AssertSz(i < plocchnk->clschnk,	"OlsOleTruncateChunk: exceeded group of chunks");

		pobj = (COleObject *)plschnk[i].pdobj;
		Assert(pobj);

		lserr = g_plsc->dnQueryObjDimRange(pobj->_plsdnTop, pobj->_plsdnTop, &objdim);
		if(lserr != lserrNone)
			return lserr;

		ur += objdim.dur;
	}
	posichnk->ichnk = i - 1;
	posichnk->dcp	= 1;
	return lserrNone;
}
/*
 *	OlsOleFindPrevBreakChunk(plocchnk, pposichnk, brkcond, pbrkout)
 *
 *	@func
 *		Find previous break in chunk
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleFindPrevBreakChunk(
	PCLOCCHNK	plocchnk, 
	PCPOSICHNK	pposichnk, 
	BRKCOND		brkcond,	//(IN): recommendation about break after chunk
	PBRKOUT		pbrkout)
{
	ZeroMemory(pbrkout, sizeof(*pbrkout));

	if (pposichnk->ichnk == ichnkOutside && (brkcond == brkcondPlease || brkcond == brkcondCan))
		{
		pbrkout->fSuccessful = fTrue;
		pbrkout->posichnk.ichnk = plocchnk->clschnk - 1;
		pbrkout->posichnk.dcp = plocchnk->plschnk[plocchnk->clschnk - 1].dcp;
		COleObject *pobj = (COleObject *)plocchnk->plschnk[plocchnk->clschnk - 1].pdobj;
		Assert(pobj);

		g_plsc->dnQueryObjDimRange(pobj->_plsdnTop, pobj->_plsdnTop, &pbrkout->objdim);
	}
	else
		pbrkout->brkcond = brkcondPlease;

	return lserrNone;
}


/*
 *	OlsOleForceBreakChunk(plocchnk, pposichnk, pbrkout)
 *
 *	@func
 *		Called when forced to break a line.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleForceBreakChunk(
	PCLOCCHNK	plocchnk, 
	PCPOSICHNK	pposichnk, 
	PBRKOUT		pbrkout)
{
	ZeroMemory(pbrkout, sizeof(*pbrkout));
	pbrkout->fSuccessful = fTrue;

	if (plocchnk->lsfgi.fFirstOnLine && pposichnk->ichnk == 0 || pposichnk->ichnk == ichnkOutside)
		{
		pbrkout->posichnk.dcp = 1;
		COleObject *pobj = (COleObject *)plocchnk->plschnk[0].pdobj;
		Assert(pobj);

		g_plsc->dnQueryObjDimRange(pobj->_plsdnTop, pobj->_plsdnTop, &pbrkout->objdim);
		}
	else
		{
		pbrkout->posichnk.ichnk = pposichnk->ichnk;
		pbrkout->posichnk.dcp = 0;
		}

	return lserrNone;
}

/*
 *	OlsOleSetBreak(pdobj, brkkind, nBreakRecord, rgBreakRecord, nActualBreakRecord)
 *
 *	@func
 *		Set break
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleSetBreak(
	 PDOBJ pdobj,				// (IN): dobj which is broken
	 BRKKIND  brkkind,			// (IN): Previous/Next/Force/Imposed was chosen
	 DWORD	nBreakRecord,		// (IN): size of array
	 BREAKREC* rgBreakRecord,	// (OUT): array of break records
	 DWORD* nActualBreakRecord)	// (OUT): actual number of used elements in array
{
	return lserrNone;
}

LSERR WINAPI OlsOleGetSpecialEffectsInside(
	PDOBJ pdobj,			// (IN): dobj
	UINT *pEffectsFlags)	// (OUT): Special effects for this object
{
	*pEffectsFlags = 0;
	return lserrNone;
}

LSERR WINAPI OlsOleCalcPresentation(
	PDOBJ,					// (IN): dobj
	long,					// (IN): dup of dobj
	LSKJUST,				// (IN): LSKJUST
	BOOL fLastVisibleOnLine)// (IN): this object is last visible object on line
{
	return lserrNone;
}

/*
 *	OlsOleQueryPointPcp(pdobj, ppointuvQuery, plsqin, plsqout)
 *
 *	@func
 *		Query Ole object PointFromCp.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleQueryPointPcp(
	PDOBJ	  pdobj,			//(IN): dobj to query
	PCPOINTUV ppointuvQuery,	//(IN): query point (uQuery,vQuery)
    PCLSQIN	  plsqin,			//(IN): query input
    PLSQOUT	  plsqout)			//(OUT): query output
{
	ZeroMemory(plsqout, sizeof(LSQOUT));

	plsqout->heightsPresObj = plsqin->heightsPresRun;
	plsqout->dupObj = plsqin->dupRun;
	return lserrNone;
}
	
/*
 *	OlsOleQueryCpPpoint(pdobj, dcp, plsqin, plsqout)
 *
 *	@func
 *		Query Ole object CpFromPoint.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleQueryCpPpoint(
	PDOBJ	pdobj,		//(IN): dobj to query
	LSDCP	dcp,		//(IN):  dcp for query
    PCLSQIN	plsqin,		//(IN): query input
    PLSQOUT	plsqout)	//(OUT): query output
{
	ZeroMemory(plsqout, sizeof(LSQOUT));

	plsqout->heightsPresObj = plsqin->heightsPresRun;
	plsqout->dupObj = plsqin->dupRun;
	return lserrNone;
}

/*
 *	OlsOleDisplay(pdobj, pcdispin)
 *
 *	@func
 *		Display object
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDisplay(
	PDOBJ	 pdobj,			//(IN): dobj to query
	PCDISPIN pcdispin)		//(IN): display info
{
	POINT pt, ptCur;
	COleObject *pobj = (COleObject *)pdobj;
	Assert(pobj);

	CRenderer  *pre = g_pols->GetRenderer();
	const CDisplay *pdp = pre->GetPdp();
	
	ptCur = pre->GetCurPoint();
	pt.x = pcdispin->ptPen.x;
	pt.y = ptCur.y;

	if (pcdispin->lstflow == lstflowWS)
		pt.x -= pcdispin->dup - 1;

	pre->SetCurPoint(pt);
	pre->SetClipLeftRight(pcdispin->dup);
	RECT rc = pre->GetClipRect();

	pre->SetSelected(pcdispin->plsrun->IsSelected());

	pre->Check_pccs();
	pre->SetFontAndColor(pcdispin->plsrun->_pCF);

	// Draw it!
	HDC hdc = pre->GetDC();
	pobj->DrawObj(pdp, pre->GetDypInch(), pre->GetDxpInch(), hdc, pdp->IsMetafile(), &pt, &rc, pcdispin->ptPen.y - pt.y, pre->GetLine()._yDescent);

	return lserrNone;
}

/*
 *	OlsOleDistroyDObj(pdobj)
 *
 *	@func
 *		Destroy object: nothing to do since object is destroyed elsewhere
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDestroyDObj(
	PDOBJ pdobj)
{
	return lserrNone;
}


extern const LSIMETHODS vlsimethodsOle =
{
	OlsOleCreateILSObj,
	OlsOleDestroyILSObj,
    OlsOleSetDoc,
    OlsOleCreateLNObj,
    OlsOleDestroyLNObj,
	OlsOleFmt,
	0,//OlsOleFmtResume
	0,//OlsOleGetModWidthPrecedingChar
	0,//OlsOleGetModWidthFollowingChar
    OlsOleTruncateChunk,
    OlsOleFindPrevBreakChunk,
    0,//OlsOleFindNextBreakChunk
    OlsOleForceBreakChunk,
    OlsOleSetBreak,
	OlsOleGetSpecialEffectsInside,
	0,//OlsOleFExpandWithPrecedingChar
	0,//OlsOleFExpandWithFollowingChar
	OlsOleCalcPresentation,
	OlsOleQueryPointPcp,
	OlsOleQueryCpPpoint,
	0,//pfnEnum
    OlsOleDisplay,
    OlsOleDestroyDObj
};
#endif		// LINESERVICES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\osdc.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	OSDC.CPP -- Off Screen DC class |
 *
 *		This contains method used to implement the off screen
 *		DC class
 *	
 *	Owner:<nl>
 *		Rick Sailor
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */
#include	"_common.h"
#include	"_osdc.h"

ASSERTDATA

/*
 *	COffScreenDC::Init(hdc, xWidth, yHeight, crBackground)
 *
 *	@mfunc	
 *		Initialize off screen DC with compatible bitmap
 *
 *	@rdesc
 *		HDC created
 */
HDC	COffScreenDC::Init(
	HDC		 hdc,			//@parm DC to be compatible with
	LONG	 xWidth,		//@parm Width of compatible bitmap
	LONG	 yHeight,		//@parm Height of compatible bitmap
	COLORREF crBackground)	//@parm Default background for bitmap
{
	HDC hdcRet	= NULL;					// HDC to return to caller
	_hbmpOld	= NULL;					// Assume failure
	_hbmp		= NULL;
	_hpalOld	= NULL;

	// Create memory DC
	_hdc = CreateCompatibleDC(hdc);
	if(_hdc)
	{
		// Create bitmap based on size of client rectangle
		_hbmp = CreateCompatibleBitmap(hdc, xWidth, yHeight);
		if(_hbmp)
		{
			// Select bitmap into hdc
			_hbmpOld = (HBITMAP)SelectObject(_hdc, _hbmp);
			if(_hbmpOld && SetBkColor(_hdc, crBackground) != CLR_INVALID)
				hdcRet = _hdc;
		}
	}
	if(!hdcRet)
		FreeData();

	return hdcRet;
}

/*
 *	COffScreenDC::SelectPalette(hpal)
 *
 *	@mfunc	
 *		Set a new palette into the hdc
 */
void COffScreenDC::SelectPalette(
	HPALETTE hpal)			//@parm Handle to palette to set
{
#ifndef PEGASUS
	if(hpal)
	{
		_hpalOld = ::SelectPalette(_hdc, hpal, TRUE);
		RealizePalette(_hdc);
	}
#endif
}

/*
 *	COffScreenDC::FreeData()
 *
 *	@mfunc	
 *		Free resources associated with bitmap
 */
void COffScreenDC::FreeData()
{
	if(_hdc)
	{
#ifndef PEGASUS
		if(_hpalOld)
			::SelectPalette(_hdc, _hpalOld, TRUE);
#endif
		if(_hbmpOld)
			SelectObject(_hdc, _hbmpOld);

		if(_hbmp)
			DeleteObject(_hbmp);

		DeleteDC(_hdc);
	}
}

/*
 *	COffScreenDC::Realloc(xWidth, yHeight)
 *
 *	@mfunc	
 *		Reallocate bitmap
 *
 *	@rdesc
 *		TRUE - succeeded 
 *		FALSE - failed
 */
BOOL COffScreenDC::Realloc(
	LONG xWidth,			//@parm Width of new bitmap
	LONG yHeight)			//@parm Height of new bitmap
{
	// Create bitmap based on size of client rectangle
	HBITMAP hbmpNew = CreateCompatibleBitmap(_hdc, xWidth, yHeight);

	if(!hbmpNew)
	{
		AssertSz(FALSE,
			"COffScreenDC::Realloc CreateCompatibleBitmap failed"); 
		return FALSE;
	}

	// Select out old bitmap
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	HBITMAP hbmpDebug = (HBITMAP) 
#endif // DEBUG

	SelectObject(_hdc, hbmpNew);

	AssertSz(hbmpDebug == _hbmp, 
		"COffScreenDC::Realloc different bitmap"); 

	// Delete old bitmap
	DeleteObject(_hbmp);

	AssertSz(hbmpDebug == _hbmp, 
		"COffScreenDC::Realloc Delete old bitmap failed"); 

	// Put in new bitmap
	_hbmp = hbmpNew;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\propchg.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	PROPCHG.CPP	-- Property Change Notification Routines |
 *	
 *	Original Author: <nl>
 *		Rick Sailor
 *
 *	History: <nl>
 *		9/5/95  ricksa  Created and documented
 *
 *	Documentation is generated straight from the code.  The following
 *	date/time stamp indicates the version of code from which the
 *	the documentation was generated.
 *
 *	Copyright (c) 1995-1997 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "_edit.h"
#include "_dispprt.h"
#include "_dispml.h"
#include "_dispsl.h"
#include "_select.h"
#include "_text.h"
#include "_runptr.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_urlsup.h"

ASSERTDATA

CTxtEdit::FNPPROPCHG CTxtEdit::_fnpPropChg[MAX_PROPERTY_BITS];

/* 
 *	CTxtEdit::UpdateAccelerator()
 *
 *	@mfunc
 *		Get accelerator cp from host
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote:
 *		The point of this is to leave the accelerator offset unchanged
 *		in the face of an error from the host.
 */
HRESULT CTxtEdit::UpdateAccelerator()
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::UpdateAccelerator");
	LONG	cpAccel;
	HRESULT hr = _phost->TxGetAcceleratorPos(&cpAccel);

	if(SUCCEEDED(hr))
	{
		// It worked so reset our value
		AssertSz(cpAccel < 32768,
			"CTxtEdit::UpdateAccelerator: cp too large");
		_cpAccelerator = cpAccel;
	}
	return hr;
}

/* 
 *	CTxtEdit::HandleRichToPlainConversion()
 *
 *	@mfunc
 *		Convert a rich text object to a plain text object
 */
void CTxtEdit::HandleRichToPlainConversion()
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::HandleRichToPlainConversion");

	// Notify every interested party that they should dump their formatting
	_nm.NotifyPreReplaceRange(NULL, CONVERT_TO_PLAIN, 0, 0, 0, 0);

	// Set _fRich to false so we can delete the final CRLF.
	_fRich = 0;
	_fSelChangeCharFormat = 0;

//	if(_pdetecturl)
//	{
//		delete _pdetecturl;
//		_pdetecturl = NULL;
//	}

	// Tell document to dump its format runs
	_story.DeleteFormatRuns();

	// Clear out the ending CRLF
	CRchTxtPtr rtp(this, 0);
	rtp.ReplaceRange(GetTextLength(), 0, NULL, NULL, -1);

}

/* 
 *	CTxtEdit::OnRichEditChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that rich-text property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT CTxtEdit::OnRichEditChange(
	BOOL fPropertyFlag)		//@parm New state of richedit flag
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnRichEditChange");

	// Calculate length of empty document. Remember that multiline rich text
	// controls always have and end of paragraph marker.
	LONG cchEmptyDoc = cchCR;
	CFreezeDisplay	fd(_pdp);	// defer screen update until we finish the change.

	if(!_fRich)
		cchEmptyDoc = 0;
	else if(_f10Mode)
		cchEmptyDoc = cchCRLF;

	// This can only be changed if there is no text and nothing to undo.
	// It makes no sense to change when there is already text. This is
	// particularly true of going from rich to plain. Further, what would
	// you do with the undo state?
	if(GetTextLength() == cchEmptyDoc && (!_pundo || !_pundo->CanUndo()))
	{
#ifdef DEBUG
		// Make sure that document is in a sensible state.
		if(_fRich)
		{
			CTxtPtr	tp(this, 0);
			WCHAR	szBuf[cchCRLF];

			tp.GetText(cchCRLF, &szBuf[0]);
			AssertSz(szBuf[0] == CR && (!_f10Mode || szBuf[1] == LF),
				"CTxtEdit::OnRichEditChange: invalid document terminator");
		}
#endif // DEBUG

		if(_fRich && !fPropertyFlag)
		{
			// Going from rich text to plain text. Need to dump
			// format runs.
			HandleRichToPlainConversion();
			_fAutoFontSizeAdjust = TRUE;
		}
		else if (!_fRich && fPropertyFlag)
		{
			// Going from plain text to rich text. Need to add the 
			// appropriate EOP at the end of the document.
			SetRichDocEndEOP(0);
			_fAutoFontSizeAdjust = FALSE;
		}
		_fRich = fPropertyFlag;		
		return S_OK;
	}
	return E_FAIL;						// Flag was not updated
}

/* 
 *	CTxtEdit::OnTxMultiLineChange (fMultiline)
 *
 *	@mfunc
 *		Notify text services that the display changed.
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnTxMultiLineChange(
	BOOL fMultiLine)
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnTxMultiLineChange");

	BOOL fHadSelection = (_psel != NULL);
	CDisplay * pSavedDisplay;
	BOOL fOldShowSelection = FALSE;

	// Remember the old value for show selection
	if (fHadSelection)
		fOldShowSelection = _psel->GetShowSelection();

	// Save the current display away and null it out

	pSavedDisplay = _pdp;
	_pdp = NULL;

	// Attempt to create the new display
	if (fMultiLine)
		_pdp = new CDisplayML(this);
	else
		_pdp = new CDisplaySL(this);
	Assert(_pdp);

	if(!_pdp)
	{
		Assert(pSavedDisplay);
		_pdp = pSavedDisplay;
		return E_OUTOFMEMORY;
	}

	// Attempt to init the new display

	if(pSavedDisplay)
		_pdp->InitFromDisplay(pSavedDisplay);

	if(!_pdp->Init())
	{
		delete _pdp;
		Assert(pSavedDisplay);
		_pdp = pSavedDisplay;
		return E_FAIL;
	}

	// Ok to now kill the old display
	delete pSavedDisplay;

	// Is there are selection?
	if(_psel)
	{
		// Need to tell it there is a new display to talk to.
		_psel->SetDisplay(_pdp);
	}

	// Is this a switch to Single Line? If this is we need to
	// make sure we truncate the text to the first EOP. We wait 
	// till this point to do this check to make sure that everything 
	// is in sync before doing something which potentially affects
	// the display and the selection.
	if(!fMultiLine)
	{
		// Set up for finding an EOP
		CTxtPtr tp(this, 0);

		tp.FindEOP(tomForward);

		// Is there any EOP and text beyond?
		if (tp.GetCp() < GetAdjustedTextLength())
		{
			// FindEOP places the text after the EOP if there
			// is one. Since we want to delete the EOP as well
			// we need to back up to the EOP. 
			tp.BackupCpCRLF();

			// Sync up the cp's of all the ranges before deleting
			// the text.
			CRchTxtPtr rtp(this, tp.GetCp());

			// Truncate from the EOP to the end of the document
			rtp.ReplaceRange(GetAdjustedTextLength() - tp.GetCp(), 0, NULL, NULL, -1);
		}
	}
	_pdp->UpdateView();
	if(fHadSelection && _fFocus && fOldShowSelection)
		_psel->ShowSelection(TRUE);

	return S_OK;
}

/* 
 *	CTxtEdit::OnTxReadOnlyChange (fReadOnly)
 *
 *	@mfunc
 *		Notify text services that read-only property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnTxReadOnlyChange(
	BOOL fReadOnly)		//@parm TRUE = read only, FALSE = not read only
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnTxReadOnlyChange");

	if (fReadOnly)
		_ldte.ReleaseDropTarget();

	_fReadOnly = fReadOnly;					// Cache bit
	return S_OK;
}
		

/* 
 *	CTxtEdit::OnShowAccelerator (fPropertyFlag)
 *
 *	@mfunc
 *		Update accelerator based on change
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnShowAccelerator(
	BOOL fPropertyFlag)		//@parm TRUE = show accelerator		
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnShowAccelerator");

	// Get the new accelerator character
	HRESULT hr = UpdateAccelerator();

	// Update the view - we update even in the face of an error return.
	// The point is that errors will be rare (non-existent?) and the update
	// will work even in the face of the error so why bother conditionalizing
	// the execution.
	NeedViewUpdate(TRUE);

	return hr;
}

/* 
 *	CTxtEdit::OnUsePassword (fPropertyFlag)
 *
 *	@mfunc
 *		Update use-password property
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnUsePassword(
	BOOL fPropertyFlag)		//@parm TRUE = use password character
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnUsePassword");

	Assert((DWORD)fPropertyFlag <= 1);			// Be sure it's C boolean

	_fUsePassword = fPropertyFlag;
	_pdp->UpdateView();					// State changed so update view
	
	return S_OK;
}

/* 
 *	CTxtEdit::OnTxHideSelectionChange (fHideSelection)
 *
 *	@mfunc
 *		Notify text services that hide-selection property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnTxHideSelectionChange(
	BOOL fHideSelection)		//@parm TRUE = hide selection
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnTxHideSelectionChange");

	// update internal flag if selection is to be hidden
	_fHideSelection = fHideSelection;

	if (!_fFocus)
		OnHideSelectionChange(fHideSelection);
		
	return S_OK;
}

/* 
 *	CTxtEdit::OnHideSelectionChange (fHideSelection)
 *
 *	@mfunc
 *		Performs the actual hide selection.  Helper to OnTxHideSelectionChange
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnHideSelectionChange(
	BOOL fHideSelection)		//@parm TRUE = hide selection
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnHideSelectionChange");

	_fHideSelection = fHideSelection;
	
	CTxtSelection * psel = GetSel();
		 
	if(psel)
	{
		psel->ShowSelection(!fHideSelection);

		// In the case where we don't have focus we don't want to allow the user to display the caret but it's okay
		// to hide the caret.
		if (_fFocus || fHideSelection)
			psel->ShowCaret(!fHideSelection);
	}

	if(!_fInPlaceActive)
	{
		TxInvalidateRect(NULL, FALSE);		// Since _fInPlaceActive = FALSE,
		TxUpdateWindow();					//  this only tells user.exe to
	}										//  send a WM_PAINT message
	return S_OK;
}


/* 
 *	CTxtEdit::OnSaveSelection (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that save-selection property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnSaveSelection(
	BOOL fPropertyFlag)		//@parm TRUE = save selection when inactive
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnSaveSelection");

	return S_OK;
}	

/* 
 *	CTxtEdit::OnAutoWordSel (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that auto-word-selection property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnAutoWordSel(
	BOOL fPropertyFlag)		//@parm TRUE = auto word selection on
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnAutoWordSel");

	// We call back to the host when we need to know, so we don't bother doing
	// anything in response to this notification.

	return S_OK;
}

/* 
 *	CTxtEdit::OnTxVerticalChange (fVertical)
 *
 *	@mfunc
 *		Notify text services that vertical property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnTxVerticalChange(
	BOOL fVertical)			//@parm TRUE - text vertically oriented.
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnTxVerticalChange");

	// We pretend like something actually happened.

	GetCallMgr()->SetChangeEvent(CN_GENERIC);
	return S_OK;
}

/* 
 *	CTxtEdit::OnClientRectChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that client rectangle changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnClientRectChange(
	BOOL fPropertyFlag)		//@parm Ignored for this property	
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnClientRectChange");

	// It is unclear whether we need to actually do anything for this 
	// notification. Logically, the change of this property is followed
	// closely by some kind of operation which will cause the display
	// cache to be updated anyway. The old code is left here as an 
	// example of what might be done if it turns out we need to do
	// anything. For now, we will simply return S_OK to this notification.
#if 0
	if (_fInPlaceActive)
	{
		RECT rc;

		if(_phost->TxGetClientRect(&rc) == NOERROR)
			_pdp->OnClientRectChange(rc);

		return S_OK;
	}

	return NeedViewUpdate(fPropertyFlag);
#endif // 0

	// With a client rect change we do need to update the caret when
	// we get redrawn even if the basic information did not change. 
	_pdp->SetUpdateCaret();

	return S_OK;
}

/* 
 *	CTxtEdit::OnCharFormatChange (fPropertyFlag)
 *
 *	@mfunc
 *		Update default CCharFormat
 *
 *	@rdesc
 *		S_OK - update successfully processed.
 */
HRESULT CTxtEdit::OnCharFormatChange(
	BOOL fPropertyFlag)		//@parm Not used
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnCharFormatChange");

	CCharFormat CF;
	DWORD		dwMask;

	HRESULT hr = TxGetDefaultCharFormat(&CF, dwMask);
	if(hr == NOERROR)
	{
		DWORD dwMask2 = CFM2_CHARFORMAT;
		WPARAM wparam = SCF_ALL;

		if(!GetAdjustedTextLength())
		{
			dwMask2 = CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK;
			wparam = 0;
		}

		// OnSetCharFormat handles updating the view.
		hr = OnSetCharFormat(wparam, &CF, NULL, dwMask, dwMask2) ? NOERROR : E_FAIL;
	}
	return hr;
}

/* 
 *	CTxtEdit::OnParaFormatChange (fPropertyFlag)
 *
 *	@mfunc
 *		Update default CParaFormat
 *
 *	@rdesc
 *		S_OK - update successfully processed
 *
 *	@devnote
 *		Because Forms^3 doesn't set cbSize correctly, we limit this API 
 *		to PARAFORMAT (until they fix it).
 */
HRESULT CTxtEdit::OnParaFormatChange(
	BOOL fPropertyFlag)		//@parm Not used
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnParaFormatChange");

	CParaFormat PF;

	HRESULT hr = TxGetDefaultParaFormat(&PF);
	if(hr == NOERROR)
	{
		// OnSetParaFormat handles updating the view.
		hr = OnSetParaFormat(SPF_SETDEFAULT, &PF, NULL, PFM_ALL2)
				? NOERROR : E_FAIL;
	}
#ifdef TABS
	GetTabsCache()->Release(PF._iTabs);
#endif
	return hr;
}

/* 
 *	CTxtEdit::NeedViewUpdate (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that view of data changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::NeedViewUpdate(
	BOOL fPropertyFlag)
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::NeedViewUpdate");

	_pdp->UpdateView();
	return S_OK;
}

/* 
 *	CTxtEdit::OnTxBackStyleChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that background style changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnTxBackStyleChange(
	BOOL fPropertyFlag)	//@parm Ignored for this property 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnTxBackStyleChange");

	_fTransparent = (TxGetBackStyle() == TXTBACK_TRANSPARENT);
	TxInvalidateRect(NULL, FALSE);
	return S_OK;
}

/* 
 *	CTxtEdit::OnAllowBeep (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that beep property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnAllowBeep(
	BOOL fPropertyFlag)	//@parm New state of property 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnAllowBeep");

	_fAllowBeep = fPropertyFlag;
	return S_OK;
}

/* 
 *	CTxtEdit::OnMaxLengthChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that max-length property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnMaxLengthChange(
	BOOL fPropertyFlag)	//@parm New state of property 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnMaxLengthChange");

	// Query host for max text length
	DWORD length = CP_INFINITE;
	_phost->TxGetMaxLength(&length);
	_cchTextMost = length;

	return S_OK;
}

/* 
 *	CTxtEdit::OnWordWrapChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that word-wrap property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnWordWrapChange(
	BOOL fPropertyFlag)	//@parm TRUE = do word wrap
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnWordWrapChange");

	_pdp->SetWordWrap(fPropertyFlag);

	// Update was successful so we need the screen updated at some point
	_pdp->UpdateView();
	return S_OK;
}

/* 
 *	CTxtEdit::OnDisableDrag (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that disable drag property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnDisableDrag(
	BOOL fPropertyFlag)	//@parm New state of property 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnDisableDrag");

	_fDisableDrag = fPropertyFlag;
	return S_OK;
}

/* 
 *	CTxtEdit::OnScrollChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services scroll property change
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnScrollChange(
	BOOL fPropertyFlag)	//@parm New state of property 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnScrollChange");

	// Tell the display that scroll bars for sure need to be updated
	_pdp->SetViewChanged();

	// Tell the display to update itself.
	_pdp->UpdateView();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\objmgr.cpp ===
/*
 *  @doc    INTERNAL
 *
 *  @module objmgr.cpp.  Object manager implementation | manages a
 *          collection of OLE embedded objects 
 *
 *  Author: alexgo 11/5/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_objmgr.h"
#include "_edit.h"
#include "_disp.h"
#include "_select.h"

ASSERTDATA

//
//	PUBLIC methods
//

/*
 *	CObjectMgr::GetObjectCount
 *
 *	@mfunc	returns the number of embedded objects currently in
 *			the document.
 *
 *	@rdesc	LONG, the count
 */
LONG CObjectMgr::GetObjectCount()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetObjectCount");

	return _objarray.Count();
}

/*
 *	CObjectMgr::GetLinkCount()
 *
 *	@mfunc	returns the number of embedded objects which are links
 *
 *	@rdesc	LONG, the count
 */
LONG CObjectMgr::GetLinkCount()
{
	LONG count = 0;
	COleObject *pobj;
	LONG i;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetLinkCount");
		
	for(i = 0; i < _objarray.Count(); i++)
	{
		pobj = *_objarray.Elem(i);
		if(pobj && pobj->IsLink())
			count++;
	}
	return count;
}

/*
 *	CObjectMgr::GetObjectFromCp()
 *
 *	@mfunc	fetches an object corresponding to the given cp
 *
 *	@rdesc	the object @ a cp; NULL if nothing found
 *
 *	@comm	the algorithm is a modified binary search.  Since the
 *			"typical" access pattern will be to linearly access the
 *			objects, we used the cached index to guess first.  If
 *			that doesn't work, we resort to a binary search.
 */
COleObject *CObjectMgr::GetObjectFromCp(
	LONG cp)		//@parm the cp for the object
{
	COleObject *pobj = NULL;
	LONG i = 0;
	
	// No tracing on this method as it's too noisy.
		
	if(_objarray.Count() > 0)
	{
		if(_lastindex < _objarray.Count())
		{
			pobj = *_objarray.Elem(_lastindex);
			if(pobj && pobj->GetCp() == cp)
				return pobj;
		}
		
		// The quick lookup failed; try a binary search.
		i = FindIndexForCp(cp);

		// Because of the insert at end case, i may be equal 
		// to the count of objects().
		pobj = NULL;
		if(i < _objarray.Count())
			pobj = *_objarray.Elem(i);
	}

	// FindIndex will return a matching or _near_ index.
	// In this case, we only want a matching index
	if(pobj)
	{
		if(pobj->GetCp() != cp)
			pobj = NULL;
		else
		{
			// Set the cached index to be the next one,
			// so that somebody walking through objects in
			// cp order will always get immediate hits.
			_lastindex = i + 1;
		}
	}
	
#ifdef DEBUG
	// Make sure the binary search found the right thing

	for( i = 0 ; i < _objarray.Count();  i++ )
	{
		COleObject *pobj2 = *_objarray.Elem(i);
		if( pobj2 )
		{
			if(*_objarray.Elem(i) == pobj)
			{
				Assert((*_objarray.Elem(i))->GetCp() == cp);
			}
			else
				Assert((*_objarray.Elem(i))->GetCp() != cp);
		}
	}
#endif //DEBUG

	return pobj;
}

/*
 *	CObjectMgr::CountObjects (cObjects, cp)
 *
 *	@mfunc	Count char counts upto <p cObjects> objects away The direction of
 *			counting is determined by the sign of <p cObjects>. 
 *
 *	@rdesc	Return the signed cch counted and set <p cObjects> to count of
 *			objects actually counted.  If <p cobject> <gt> 0 and cp is at
 *			the last object, no change is made and 0 is returned.
 *
 *	@devnote This is called from TOM, which uses LONGs for cp's (because VB
 *			can't use unsigned quantities)
 */
LONG CObjectMgr::CountObjects (
	LONG&	cObjects,		//@parm Count of objects to get cch for
	LONG	cp)				//@parm cp to start counting from
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::CountObjects");

	LONG		iStart, iEnd;
	LONG		iMaxEnd = (LONG)_objarray.Count() - 1;

	if(!cObjects || !_objarray.Count())
	{
		cObjects = 0;
		return 0;
	}

	iStart = (LONG)FindIndexForCp(cp);

	// if we are looking past either end, return 0

	if (iStart > iMaxEnd && cObjects > 0 ||
		iStart == 0 && cObjects < 0 )
	{
		cObjects = 0;
		return 0;
	}

	// If the index that we found is on an object and
	// we are looking forward, it should be skipped.

	if( iStart < (LONG)_objarray.Count() && 
		(LONG)(*_objarray.Elem(iStart))->GetCp() == cp &&
		cObjects > 0)
	{
		iStart++;
	}

	if(cObjects < 0)
	{
		if(-cObjects > iStart)	// Going past the beginning
		{
			iEnd = 0;
			cObjects = -iStart;
		}
		else
			iEnd = iStart + cObjects;
	}
	else
	{
		if(cObjects > iMaxEnd - iStart) //Going past the end
		{
			iEnd = iMaxEnd;
			cObjects = iMaxEnd - iStart + 1;
		}
		else
			iEnd = iStart + cObjects - 1;
	}

	Assert(iEnd >= 0 && iEnd < (LONG)_objarray.Count() );

	return (*_objarray.Elem(iEnd))->GetCp() - cp;
}

/*
 *	CObjectMgr::CountObjectsInRange (cpMin, cpMost)
 *
 *	@mfunc	Count the number of objects in the given range.
 *
 *	@rdesc	Return the number of objects.
 */
LONG CObjectMgr::CountObjectsInRange (
	LONG	cpMin,	//@parm Beginning of range
	LONG	cpMost)	//@parm End of range
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::CountObjectsInRange");

	//Get the indexes for the objects at or after cpMin and cpMost
	//respectively.

	return FindIndexForCp(cpMost) - FindIndexForCp(cpMin);
}

/*
 *	CObjectMgr::GetFirstObjectInRange (cpMin, cpMost)
 *
 *	@mfunc	Get the first object in the given range. 
 *
 *	@rdesc	Pointer to first object in range, or NULL if none.
 */
COleObject * CObjectMgr::GetFirstObjectInRange (
	LONG	cpMin,	//@parm Beginning of range
	LONG	cpMost)	//@parm End of range
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetFirstObjectInRange");

	if (cpMin == cpMost)
		// degenerate range no object selected
		return NULL;

	LONG	iLast = (LONG)_objarray.Count() - 1;	// Index for next object
	LONG	iObj = FindIndexForCp(cpMin);			//  at or after cpMin

	//Make sure this is an existing object.
	if(iObj <= iLast)
	{
		//Make sure it is within the range
		COleObject * pObj = *_objarray.Elem(iObj);

		if(pObj && pObj->GetCp() <= cpMost)
			return pObj;
	}
	return NULL;
}

/*
 *	CObjectMgr::GetObjectFromIndex(index)
 *
 *	@mfunc	retrieves the object at the indicated index
 *
 *	@rdesc	a pointer to the object, if found, NULL otherwise
 */
COleObject *CObjectMgr::GetObjectFromIndex(
	LONG index)		//@parm	Index to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetObjectFromIndex");

	if( index < _objarray.Count() )
		return *_objarray.Elem(index);

	return NULL;
}

/*
 *	CObjectMgr::InsertObject(cp, preobj, publdr)
 *
 *	@mfunc	inserts an object at the indicated index.  It is the
 *			caller's responsibility to handle inserting any data
 *			(such as WCH_EMBEDDING) into the text stream.
 *
 *	@rdesc	HRESULT
 */
HRESULT CObjectMgr::InsertObject(
	LONG		  cp,		//@parm cp to use
	REOBJECT *	  preobj,	//@parm Object to insert
	IUndoBuilder *publdr)	//@parm Undo context
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::InsertObject");

	HRESULT		hr;
	COleObject *pobj = (COleObject *)(preobj->polesite);

	// Let the client know what we're up to
	if (_precall)
	{
		hr = _precall->QueryInsertObject(&preobj->clsid, preobj->pstg,
			REO_CP_SELECTION);

		if( hr != NOERROR )
			return hr;
	}

	// Set some stuff up first; since we may make outgoing calls, don't
	// change our internal state yet.
	hr = pobj->InitFromREOBJECT(cp, preobj);
	if( hr != NOERROR )
		return hr;

	return RestoreObject(pobj);
}

/*
 *	CObjectMgr::RestoreObject(pobj)
 *
 *	@mfunc	[re-]inserts the given object into the list of objects
 *			in the backing store
 *
 *	@rdesc	HRESULT
 */
HRESULT CObjectMgr::RestoreObject(
	COleObject *pobj)		//@parm Object to insert
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::RestoreObject");

	COleObject **ppobj = _objarray.Insert(FindIndexForCp(pobj->GetCp()), 1);

	if( ppobj == NULL )
		return E_OUTOFMEMORY;

	*ppobj = pobj;
	pobj->AddRef();

	return NOERROR;
}

/*
 *	CObjectMgr::SetRECallback(precall)
 *
 *	@mfunc	sets the callback interface
 *
 *	@rdesc	void
 */
void CObjectMgr::SetRECallback(
	IRichEditOleCallback *precall) //@parm Callback interface pointer
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::SetRECallback");

	if( _precall )
        SafeReleaseAndNULL((IUnknown**)&_precall);

	_precall = precall;

	if( _precall )
		_precall->AddRef();
}

/*
 *	CObjectMgr::SetHostNames(pszApp, pszDoc)
 *
 *	@mfunc	set host names for this edit instance
 *
 *	@rdesc	NOERROR or E_OUTOFMEMORY
 */
HRESULT CObjectMgr::SetHostNames(
	LPWSTR	pszApp,	//@parm app name
	LPWSTR  pszDoc)	//@parm doc name
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::SetHostNames");
	HRESULT hr = NOERROR;

	if( _pszApp )
	{
		delete _pszApp;
		_pszApp = NULL;
	}
	if( _pszDoc )
	{
		delete _pszDoc;
		_pszDoc = NULL;
	}
	if( pszApp )
	{
		_pszApp = new WCHAR[wcslen(pszApp) + 1];
		if( _pszApp )
			wcscpy(_pszApp, pszApp);
		else
			hr = E_OUTOFMEMORY;
	}
	if( pszDoc )
	{
		_pszDoc = new WCHAR[wcslen(pszDoc) + 1];
		if( _pszDoc )
			wcscpy(_pszDoc, pszDoc);
		else
			hr = E_OUTOFMEMORY;
	}
	return hr;
}

/*
 *	CObjectMgr::CObjectMgr
 *
 *	@mfunc constructor
 */
CObjectMgr::CObjectMgr()
{
	_pobjselect = NULL;
	_pobjactive = NULL;
}

/*
 *	CObjectMgr::~CObjectMgr
 *
 *	@mfunc	destructor
 */
CObjectMgr::~CObjectMgr()
{
	LONG i, count;
	COleObject *pobj;

 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::~CObjectMgr");

	count = _objarray.Count();

	for( i = 0; i < count; i++ )
	{
		pobj = *_objarray.Elem(i);
		// We NULL stuff here to try to protect ourselves
		// better in re-entrancy cases.
		*_objarray.Elem(i) = NULL;
		if( pobj )
		{
			pobj->Close(OLECLOSE_NOSAVE);
  			pobj->MakeZombie();
    		SafeReleaseAndNULL((IUnknown**)&pobj);
		}
	}

	if( _precall )
        SafeReleaseAndNULL((IUnknown**)&_precall);
		
	if( _pszApp )
		delete _pszApp;

	if( _pszDoc )
		delete _pszDoc;
}

/*
 *	CObjectMgr::ReplaceRange (cp, cchDel, publdr)
 *
 *	@mfunc	handles the deletion of objects from a given range.  This
 *			method _must_ be called before any floating range notifications
 *			are sent.
 *
 *	@rdesc	void
 */
void CObjectMgr::ReplaceRange(
	LONG cp,				//@parm cp starting the deletion
	LONG cchDel,			//@parm Count of characters deleted
	IUndoBuilder *publdr)	//@parm Undo builder for this actions
{
	LONG	i;
	LONG	iDel = -1, 
			cDel = 0;	// index at which to delete && number of objects
						// to delete.
	COleObject *pobj;

	// nothing deleted, don't bother doing anything.
	if( !cchDel )
		return;

	// Basically, we loop through all of the objects within the
	// range of deleted text and ask them to delete themselves.
	// We remember the range of objects deleted (the starting index
	// and # of objects deleted) so that we can remove them from
	// the array all at once.

	i = FindIndexForCp(cp);

	while( i < _objarray.Count() )
	{
		pobj = *_objarray.Elem(i);
		if( pobj && pobj->GetCp() >= cp)
		{
			if( pobj->GetCp() < (cp + cchDel) )
			{
				if( _pobjactive == pobj )
				{
					// Deactivate the object just to be on the safe side.
					_pobjactive->DeActivateObj();
					_pobjactive = NULL;
				}

				if(iDel == -1)
					iDel = i;

				cDel++;
				if (_precall)
				{
					IOleObject *poo;
					if (pobj->GetIUnknown()->QueryInterface(IID_IOleObject,
						(void **)&poo) == NOERROR)
					{
						_precall->DeleteObject(poo);
						poo->Release();
					}
				}

				// if the object was selected, then it obviously
				// can't be anymore!
				if( _pobjselect == pobj )
				{
					_pobjselect = NULL;
				}

				pobj->Delete(publdr);
				*_objarray.Elem(i) = NULL;
				pobj->Release();
			}
			else
				break;
		}
		i++;
	}
	if(cDel)
		_objarray.Remove(iDel, cDel);
	return;
}

/*
 *	CObjectMgr::ScrollObjects(dx, dy, prcScroll)
 *
 *	@mfunc	informs all objects that scrolling has occured so they can
 *			update if necessary
 *
 *	@rdesc	void
 */
void CObjectMgr::ScrollObjects(
	LONG dx,			//@parm change in the x direction
	LONG dy,			//@parm change in the y direction
	LPCRECT prcScroll)	//@parm rect that is being scrolled
{
	LONG count = _objarray.Count();
	for(LONG i = 0; i < count; i++ )
	{
		COleObject *pobj = *_objarray.Elem(i);
		if(pobj)
			pobj->ScrollObject(dx, dy, prcScroll);
	}
} 	

//
//	PRIVATE methods
//

/*
 *	CObjectMgr::FindIndexForCp(cp)
 *
 *	@mfunc	does a binary search to find the index at which an object
 *			at the given cp exists or should be inserted.
 *
 *	@rdesc	LONG, an index
 */
LONG CObjectMgr::FindIndexForCp(
	LONG cp)
{
	LONG l, r;
	COleObject *pobj = NULL;
	LONG i = 0;
		
	l = 0; 
	r = _objarray.Count() - 1;
	
	while( r >= l )
	{
		i = (l + r)/2;
		pobj = *_objarray.Elem(i);
		if( !pobj )
		{
			TRACEWARNSZ("null entry in object table.  Recovering...");
			for( i = 0 ; i < _objarray.Count() -1; i++ )
			{
				pobj = *_objarray.Elem(i);
				if( pobj && pobj->GetCp() >= cp )
					return i;
			}
			return i;
		}
		if( pobj->GetCp() == cp )
			return i;

		else if( pobj->GetCp() < cp )
			l = i + 1;

		else
			r = i - 1;
	}

	// Yikes! nothing was found.  Fixup i so that
	// it points to the correct index for insertion.

	Assert(pobj || (!pobj && i == 0));

	if(pobj)
	{
		Assert(pobj->GetCp() != cp);
		if( pobj->GetCp() < cp )
			i++;
	}
	return i;
}
						
/*
 *	CObjectMgr::HandleDoubleClick(ped, &pt, flags)
 *	
 *	@mfunc		Handles a double click message, potentially activating
 *				an object.
 *
 *	@rdesc		BOOL-- TRUE if double click-processing is completely
 *				finished.
 */
BOOL CObjectMgr::HandleDoubleClick(
	CTxtEdit *ped,	//@parm edit context
	const POINT &pt,//@parm point of click (WM_LBUTTONDBLCLK wparam)
	DWORD flags)	//@parm flags (lparam)
{
	LONG cp;
	COleObject *pobj;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, 
						"CObjectMgr::HandleDoubleClick");

	ped->_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, NULL, NULL, &cp);
	pobj = GetObjectFromCp(cp);

	if (!pobj)
		return FALSE;

	if (_pobjactive != pobj)
	{
		//Deactivate currently active object if any.
		if (_pobjactive)
			_pobjactive->DeActivateObj();

		return pobj->ActivateObj(WM_LBUTTONDBLCLK, flags, MAKELONG(pt.x, pt.y));
	}
	return TRUE;
}

/*
 *	CObjectMgr::HandleClick(ped, &pt)
 *	
 *	@mfunc
 *		The position of the caret is changing.  We need to
 *		Deactivate the active object, if any.  If the change is
 *		because of a mouse click and there is an object at this
 *		cp, we set a new individually selected object. Otherwise
 *		we set the individually selected object to NULL.
 *
 *	@rdesc	returns TRUE if this method set the selection.  Otherwise,
 *		returns FALSE;
 */
ClickStatus CObjectMgr::HandleClick(
	CTxtEdit *ped,	//@parm the edit context
	const POINT &pt)//@parm the point of the mouse click 
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::HandleClick");

	COleObject *	pobjnew;//, * pobjold;
	CTxtSelection * psel;
	LONG			cp;
	LONG			cpMin, cpMost;
	
	if( _pobjactive )
	{
		_pobjactive->DeActivateObj();
		return CLICK_OBJDEACTIVATED;
	}

	ped->_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, NULL, NULL, &cp);
	pobjnew = GetObjectFromCp(cp);

	//If we clicked on an object, set the selection to this object.
	//CTxtSelection::UpdateSelection will be called as a result of this
	//and will determine the highlighting.
	if( pobjnew )
	{
		cp = pobjnew->GetCp();
		psel = ped->GetSel();
		if (psel->GetRange(cpMin, cpMost) > 1 &&
			cpMin <= (LONG) cp &&
			(LONG) cp <= cpMost)
		{
			// There is more than one character in the selection
			// And the object is part of the selection.
			// Do not change the selection
			return CLICK_SHOULDDRAG;
		}
		
		// don't reset the selection if the object is already selected
		if( pobjnew != _pobjselect )
		{
			// Freeze the Display while we handle this click
			CFreezeDisplay fd(ped->_pdp);

			psel->SetSelection(cp, cp+1);
			if (GetSingleSelect())
			{
				// Note thate the call to SetSelection may have set selected object to NULL !!!!
				// This can happen in some strange scenarios where our state is out of whack
				AssertSz(GetSingleSelect() == pobjnew, "Object NOT Selected!!");
				return CLICK_OBJSELECTED;
			}
			return CLICK_IGNORED;
		}
		return CLICK_OBJSELECTED;
	}
	return CLICK_IGNORED;
}

/*
 *	CObjectMgr::HandleSingleSelect(ped, cp, fHiLite)
 *	
 *	@mfunc
 *		When an object is selected and it is the only thing selected, we do
 *		not highlight it by inverting it.  We Draw a frame and handles around
 *		it.  This function is called either because an object has been
 *		selected and it is the only thing selected, or because we need to
 *		check for an object that used to be in this state but may no longer be.
 */
void CObjectMgr::HandleSingleSelect(
	CTxtEdit *ped,		//@parm edit context
	LONG	  cp,		//@parm cp of object
	BOOL	  fHiLite)	//@parm is this a call for hding the selection
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::HandleSingleSelect");

	COleObject* pobjnew = GetObjectFromCp(cp);

	//This should only be called when we know we have a singley selected
	//object.  However, there are boundary cases (such as inserting an object)
	//where WCH_EMBEDDING is the backing store yet no object exists.  These
	//cases are OK; thus, we check for NULL on pobjnew.
	
	if(pobjnew)
	{
		//The object is the same as the currently selected object (if any)
		//we are deselecting it.  This works like a toggle unless state is messed up.
		//If the object is different, we are replacing the current selected
		//object (if any).
		if(!fHiLite && _pobjselect)
		{
			// This covers _pobjselct == pobjnew  Normal case
			//  and _pobjselect != pobjnew  Degenerate case.
			_pobjselect->SetREOSELECTED(FALSE);
			_pobjselect = NULL;

			//Remove frame/handles from currently selected object.
			ped->_pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, cp, cp + 1);
		}
		else if(fHiLite && pobjnew != _pobjselect)
		{
			// Only do this if we are setting a new selection.
			_pobjselect = pobjnew;
			_pobjselect->SetREOSELECTED(TRUE);

			//Draw frame/handles on newly selected object.
			ped->_pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, cp, cp + 1);
		}
		else
		{
			// We want to hilite the selection but the object is already selected.
			// Or we want to undo hilite on the selection but the selected object is NULL.
			// Do nothing.
		}
	}
}


/*
 *	CObjectMgr::ActivateObjectsAs (rclsid, rclsidAs)
 *
 *	@mfunc	Handles a request by the user to activate all objects of a particular
 *		class as objects of another class.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT CObjectMgr::ActivateObjectsAs(
	REFCLSID rclsid,
	REFCLSID rclsidAs)
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CObjectMgr::ActivateObjectsAs");

	COleObject * pobj;
	HRESULT hr, hrLatest;

	// Tell the system to treat all rclsid objects as rclsidAs
	hr = CoTreatAsClass(rclsid, rclsidAs);
	if( hr != NOERROR )
		return hr;

	LONG cobj = GetObjectCount();

	// Go through objects, letting them decide if
	// they have anything to do for this.
	for (LONG iobj = 0; iobj < cobj; iobj++)
	{
		pobj = GetObjectFromIndex(iobj);
		hrLatest = pobj->ActivateAs(rclsid, rclsidAs);
		// Make hr the latest hresult unless we have previously had an error.
		if(hr == NOERROR)
			hr = hrLatest;
	}
	return hr;
}

#ifdef DEBUG
void CObjectMgr::DbgDump(void)
{
	Tracef(TRCSEVNONE, "Object Manager %d objects", _objarray.Count());

	for(LONG i = 0 ; i < _objarray.Count();  i++)
	{
		COleObject *pobj = *_objarray.Elem(i);
		if(pobj)
			pobj->DbgDump(i);
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\object.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	object.cpp	IRichEditOle implementation |
 *
 *	Author: alexgo 8/15/95
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_objmgr.h"
#include "_coleobj.h"
#include "_rtext.h"
#include "_select.h"
#include "_m_undo.h"


// 	IUnknown is implemented elsewhere

/*
 *	CTxtEdit::GetClientSite
 *
 *	@mfunc	returns the client site 
 */
STDMETHODIMP CTxtEdit::GetClientSite(
	LPOLECLIENTSITE FAR * lplpolesite)		//@parm where to return 
											//the client site
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetClientSite");

	if(!lplpolesite)
		return E_INVALIDARG;

	COleObject *pobj = new COleObject(this);
	// should start with a ref count of 1.
	if(pobj)
	{
		*lplpolesite = (IOleClientSite *)pobj;
		return NOERROR;
	}
	*lplpolesite = NULL;
	return E_OUTOFMEMORY;
}

/* 
 *	CTxtEdit::GetObjectCount
 *
 *	@mfunc	return the number of objects in this edit instance
 */
STDMETHODIMP_(LONG) CTxtEdit::GetObjectCount()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetObjectCount");
	
	return _pobjmgr ? _pobjmgr->GetObjectCount() : 0;
}

/*
 *	CTxtEdit::GetLinkCount
 *
 *	@mfunc	return the number of likns in this edit instance
 */
STDMETHODIMP_(LONG) CTxtEdit::GetLinkCount()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetLinkCount");

	CObjectMgr *pobjmgr = GetObjectMgr();
	return pobjmgr ? pobjmgr->GetLinkCount() : 0;
}

/*
 *	CTxtEdit::GetObject(iob, preobj, dwFlags)
 *
 *	@mfunc	returns an object structure for the indicated object
 */
STDMETHODIMP CTxtEdit::GetObject(
	LONG iob, 					//@parm index of the object
	REOBJECT * preobj,			//@parm where to put object info
	DWORD dwFlags)				//@parm flags
{
	COleObject *pobj = NULL;
	CCallMgr callmgr(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetObject");
	if(!preobj || preobj->cbStruct != sizeof(REOBJECT))
		return E_INVALIDARG;

	CObjectMgr *pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;

	// There are three cases of intestest; get the object at
	// an index, at a given cp, or at the selection.

	if(iob == REO_IOB_USE_CP || iob == REO_IOB_SELECTION)
	{
		if((Get10Mode() && preobj->cp == REO_CP_SELECTION) || iob == REO_IOB_SELECTION)
		{
			// Use selection cp
			CTxtSelection *psel = GetSel();
			if(psel)
				pobj = pobjmgr->GetObjectFromCp(psel->GetCpMin());
		}
		else
			pobj = pobjmgr->GetObjectFromCp(Get10Mode() ? GetCpFromAcp(preobj->cp): preobj->cp);
	}
	else if (iob >= 0)
		pobj = pobjmgr->GetObjectFromIndex(iob);

	if(pobj)
	{
		HRESULT hResult = pobj->GetObjectData(preobj, dwFlags);

		if (Get10Mode())
			preobj->cp = GetAcpFromCp(preobj->cp);

		return hResult;
	}

	// This return code is a bit of stretch, but basially 
	return E_INVALIDARG;
}

/*
 *	CTxtEdit::InsertObject
 *
 *	@mfunc	inserts a new object
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtEdit::InsertObject(
	REOBJECT * preobj)		//@parm object info
{
	CCallMgr		callmgr(this);
	WCHAR 			ch = WCH_EMBEDDING;
	CRchTxtPtr		rtp(this, 0);
	IUndoBuilder *	publdr;
	CGenUndoBuilder undobldr(this, UB_AUTOCOMMIT, &publdr);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::InsertObject");

	// Do some boundary case checking

	if(!preobj)
		return E_INVALIDARG;

	CTxtSelection *psel = GetSel();
	if(!psel)
		return E_OUTOFMEMORY;

	// If the insertion of this character would cause
	// us to exceed the text limit, fail
	if((DWORD)(GetAdjustedTextLength() + 1) > TxGetMaxLength())
	{
		// If we're not replacing a selection (or the
		// selection is degenerate, then we will have  exceeded
		// our limit
		if(preobj->cp != REO_CP_SELECTION || psel->GetCch() == 0)
		{
			GetCallMgr()->SetMaxText();
			return E_OUTOFMEMORY;
		}
	}
	
	CObjectMgr *pobjmgr = GetObjectMgr();
	if(pobjmgr)
	{
		LONG cch = 0;
		LONG cp;
		LONG cpFormat;

		undobldr.StopGroupTyping();

		if(preobj->cp == REO_CP_SELECTION)
		{
			LONG cpMost;
			psel->AdjustEndEOP(NEWCHARS);
			cch = psel->GetRange(cp, cpMost);

			// Get cp of active end of selection from which we
			// will obtain CF for object.
			cpFormat = psel->GetCp();
			if(publdr)
			{
				HandleSelectionAEInfo(this, publdr, cpFormat, cch, 
						cp + 1, 0, SELAE_FORCEREPLACE);
			}
		}
		else
			cpFormat = cp = Get10Mode() ? GetCpFromAcp(preobj->cp): preobj->cp;
		
		// Get format for ReplaceRange:  for cp semantics, use format
		// at the cp; for selection semantics, use the format at the active
		// end of the selection.
		CTxtRange rgFormat(this, cpFormat, 0);
		LONG	  iFormat = rgFormat.Get_iCF();
		ReleaseFormats(iFormat, -1);

		rtp.SetCp(cp);

		if (rtp.ReplaceRange(cch, 1, &ch, publdr, iFormat) != 1)
		{
			return E_FAIL;
		}
		
		HRESULT		hr = pobjmgr->InsertObject(cp, preobj, publdr);
		COleObject *pobj = (COleObject *)(preobj->polesite);

		pobj->EnableGuardPosRect();
		CNotifyMgr *pnm = GetNotifyMgr();		// Get notification mgr
		if(pnm)									// Notify interested parties
			pnm->NotifyPostReplaceRange(NULL, CP_INFINITE, 0, 0, cp, cp + 1);

		pobj->DisableGuardPosRect();

		// Don't want object selected
		psel->SetSelection(cp + 1, cp + 1);

		TxUpdateWindow();
		return hr;
	}
	return E_OUTOFMEMORY;		
}

/*
 *	CTxtEdit::ConvertObject(iob, rclsidNew, lpstrUserTypeNew)
 *
 *	@mfunc	Converts the specified object to the specified class.  Does reload
 *		the object but does NOT force an update (caller must do this).
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ConvertObject(
	LONG iob, 					//@parm index of the object
	REFCLSID rclsidNew,			//@parm the destination clsid
	LPCSTR lpstrUserTypeNew)	//@parm the new user type name
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ConvertObject");
	CCallMgr callmgr(this);

	// If iob was invalid return
	COleObject * pobj = ObjectFromIOB(iob);
	if(!pobj)
		return E_INVALIDARG;

	//Delegate to the object.
	return pobj->Convert(rclsidNew, lpstrUserTypeNew);
}

/*
 *	CTxtEdit::ActivateAs(rclsid, rclsidAs)
 *
 *	@mfunc	Handles a request by the user to activate all objects of a
 *		particular class as objects of another class.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ActivateAs(
	REFCLSID rclsid, 			//@parm clsid which we're going to change
	REFCLSID rclsidAs)			//@parm clsid to activate as
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ActivateAs");
	CCallMgr callmgr(this);

	CObjectMgr * pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;

	return pobjmgr->ActivateObjectsAs(rclsid, rclsidAs);
}

/* 
 *	CTxtEdit::SetHostNames(lpstrContainerApp, lpstrContainerDoc)
 *
 *	@mfunc	Sets the host names for this instance
 */
STDMETHODIMP CTxtEdit::SetHostNames(
	LPCSTR lpstrContainerApp, 	//@parm App name
	LPCSTR lpstrContainerDoc)	//@parm	Container Object (doc) name
{
	CCallMgr callmgr(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SetHostNames");
	
 	WCHAR *pwsContainerApp = W32->ConvertToWideChar(lpstrContainerApp);
	WCHAR *pwsContainerDoc = W32->ConvertToWideChar(lpstrContainerDoc);

	CObjectMgr *pobjmgr = GetObjectMgr();
	if(pobjmgr && pwsContainerApp && pwsContainerDoc)
	{
		HRESULT hr = pobjmgr->SetHostNames(pwsContainerApp, pwsContainerDoc);
		delete pwsContainerApp;
		delete pwsContainerDoc;
		return hr;
	}
	return E_OUTOFMEMORY;
}

/*
 *	CTxtEdit::SetLinkAvailable(iob, fAvailable)
 *
 *	@mfunc
 *		Allows client to tell us whether the link is available or not.
 */
STDMETHODIMP CTxtEdit::SetLinkAvailable(
	LONG iob, 					//@parm index of the object
	BOOL fAvailable)			//@parm if TRUE, make object linkable
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SetLinkAvailable");

	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	return pobj->SetLinkAvailable(fAvailable);
}

/*
 *	CTxtEdit::SetDvaspect(iob, dvaspect)
 *
 *	@mfunc	Allows client to tell us which aspect to use and force us
 *		to recompute positioning and redraw.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::SetDvaspect(
	LONG iob, 					//@parm index of the object
	DWORD dvaspect)				//@parm	the aspect to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SetDvaspect");
	CCallMgr callmgr(this);
	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	pobj->SetDvaspect(dvaspect);
	return NOERROR;
}

/*
 *	CTxtEdit::HandsOffStorage(iob)
 *
 *	@mfunc	see IPersistStorage::HandsOffStorage
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::HandsOffStorage(
	LONG iob)					//@parm index of the object
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::HandsOffStorage");
	CCallMgr callmgr(this);

	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	pobj->HandsOffStorage();
	return NOERROR;
}

/*
 *	CTxtEdit::SaveCompleted(iob, lpstg)
 *
 *	@mfunc	see IPersistStorage::SaveCompleted
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::SaveCompleted(
	LONG iob, 					//@parm index of the object
	LPSTORAGE lpstg)			//@parm new storage
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SaveCompleted");
	CCallMgr callmgr(this);

	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	pobj->SaveCompleted(lpstg);
	return NOERROR;
}

/*
 *	CTxtEdit::InPlaceDeactivate()
 *
 *	@mfunc	Deactivate 
 */
STDMETHODIMP CTxtEdit::InPlaceDeactivate()
{
	COleObject *pobj;
	HRESULT hr = NOERROR;
	CCallMgr callmgr(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::InPlaceDeactivate");
	
	CObjectMgr *pobjmgr = GetObjectMgr();
	if(pobjmgr)
	{
		pobj = pobjmgr->GetInPlaceActiveObject();
		if(pobj)
			hr = pobj->DeActivateObj();
	}

	return hr;
}

/*
 *	CTxtEdit::ContextSensitiveHelp(fEnterMode)
 *
 *	@mfunc enter/leave ContextSensitiveHelp mode
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ContextSensitiveHelp(
	BOOL fEnterMode)			//@parm enter/exit mode
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ContextSensitiveHelp");

	HRESULT hr = NOERROR;
	CCallMgr callmgr(this);

	CObjectMgr * pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;

	// If the mode changes
	if(pobjmgr->GetHelpMode() != fEnterMode)
	{
		pobjmgr->SetHelpMode(fEnterMode);
		COleObject * pobj = pobjmgr->GetInPlaceActiveObject();
		if(pobj)
		{
			IOleWindow *pow;
			hr = pobj->GetIUnknown()->QueryInterface(IID_IOleWindow,
				(void **)&pow);
			if(hr == NOERROR)
			{
				hr = pow->ContextSensitiveHelp(fEnterMode);
				pow->Release();
			}
		}
	}
	return hr;
}

/*
 *	CTxtEdit::GetClipboardData(lpchrg, reco, lplpdataobj)
 *
 *	@mfunc	return an data transfer object for the indicated
 *	range
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::GetClipboardData(
	CHARRANGE *lpchrg, 			//@parm the range of text to use
	DWORD reco,					//@parm operation the data is for
	LPDATAOBJECT *lplpdataobj)	//@parm where to put the data object
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetClipboardData");

	CCallMgr callmgr(this);
	HRESULT hr;
	LONG cpMin, cpMost;
	CLightDTEngine * pldte = GetDTE();

	//Make sure cpMin and cpMost are within the current text limits.
	//Interpret neg. value for cpMin as the beginning of the text,
	//and neg. value for cpMax as the end of the text.  If a char range
	//is not given use the current selection.
	if(lpchrg)
	{
		LONG cchText = GetTextLength();
		cpMin = min(cchText, max(0, lpchrg->cpMin));
		cpMost = lpchrg->cpMost;
		if(lpchrg->cpMost < 0 || lpchrg->cpMost > cchText)
			cpMost = cchText;
	}
	else
	{
		CTxtSelection * psel = GetSel();
		psel->GetRange(cpMin, cpMost);
	}

	//Make sure this is a valid range.
	if(cpMin >= cpMost)
	{
		*lplpdataobj = NULL;
		return cpMin == cpMost
					? NOERROR
					: ResultFromScode(E_INVALIDARG);
	}

	CTxtRange rg(this, cpMin, cpMin-cpMost);

	//We don't use reco for anything.
	hr = pldte->RangeToDataObject(&rg, SF_RTF, lplpdataobj);

#ifdef DEBUG
	if(hr != NOERROR)
		TRACEERRSZSC("GetClipboardData", E_OUTOFMEMORY);
#endif

	return hr;
}

/*
 *	CTxtEdit::ImportDataObject(lpdataobj, cf, hMetaPict)
 *
 *	@mfunc	morally equivalent to paste, but with a data object
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ImportDataObject(
	LPDATAOBJECT lpdataobj,		//@parm Data object to use
	CLIPFORMAT	 cf, 			//@parm Clibpoard format to use
	HGLOBAL		 hMetaPict)		//@parm Metafile to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ImportDataObject");

	CCallMgr		callmgr(this);
	IUndoBuilder *	publdr;
	REPASTESPECIAL	rps = {DVASPECT_CONTENT, NULL};
	CGenUndoBuilder undobldr(this, UB_AUTOCOMMIT, &publdr);

	if(hMetaPict)
	{
		rps.dwAspect = DVASPECT_ICON;
		rps.dwParam = (DWORD_PTR) hMetaPict;
	}

	return PasteDataObjectToRange(lpdataobj, GetSel(), cf,
								  &rps, publdr, PDOR_NOQUERY);
}

/*
 *	CTxtEdit::ObjectFromIOB(iob)
 *
 *	@mfunc	Gets an object based on an IOB type index.
 *
 *	@rdesc:
 *		pointer to COleObject or NULL if none.
 */
COleObject * CTxtEdit::ObjectFromIOB(
	LONG iob)
{
	CObjectMgr * pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return NULL;

	COleObject * pobj = NULL;

	// Figure out the index of the selection
	if (iob == REO_IOB_SELECTION)
	{
		CTxtSelection * psel = GetSel();

		pobj = pobjmgr->GetFirstObjectInRange(psel->GetCpMin(),
			psel->GetCpMost());
	}
	else
	{
		// Make sure the IOB is in range
		if(0 <= iob && iob < GetObjectCount())
			pobj = pobjmgr->GetObjectFromIndex(iob);
	}
	return pobj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\ols.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	OLS.CPP -- COls LineServices object class
 *	
 *	Authors:
 *		Murray Sargent: initial coding up to nonLS RichEdit functionality
 *			(with lots of help from RickSa's ols code)
 *		Keith Curtis and Worachai Chaoweeraprasit: complex script support,
 *			etc.
 *
 *	@todo
 *		1) Fix table selection
 *		2) What are we to do with RTL tables? Word has a very different model
 *		3) What we should give for LSCHP.dcpMaxContext
 *
 *	Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_font.h"
#include "_render.h"
#include "_osdc.h"
#include "_dfreeze.h"
#include "_tomfmt.h"
#include "_ols.h"
#include "_clasfyc.h"
#include "_uspi.h"
#include "_txtbrk.h"
#include "lskysr.h"

#ifdef LINESERVICES

ASSERTDATA

// Guess at the number of characters on the line
const int cchLineHint = 66;

#define OBJID_OLE			0
#define OBJID_REVERSE		1
#define	OBJID_COUNT			2

const WCHAR wchObjectEnd = 0x9F;
const WCHAR rgchObjectEnd[]	= {wchObjectEnd};

#define	MAX_OBJ_DEPTH		3

extern const LSCBK lscbk;

// Kinsoku break pair information
extern const INT g_cKinsokuCategories;

CLineServices *g_plsc = NULL;		// LineServices Context
COls*		   g_pols = NULL;		// COls ptr

const LSBRK rglsbrkDefault[] =
{
	0,0,	// Always prohibited
	0,1,	// OK across blanks
	1,1		// Always allowed
};

// prototypes
void 	EmitBrace(COls* pols, PLSCHP pchp, BOOL* pfHid, DWORD* pcch, PLSRUN* pprun, LPCWSTR* plpwch, int id, LPCWSTR str);
void	DupShapeState(PLSRUN prun, LONG cch);


// public inline functions
//

// Emitting fake brace to LS
inline void EmitBrace(
	COls*		pols,
	PLSCHP		pchp,
	BOOL*		pfHid,
	DWORD*		pcch,
	PLSRUN*		pprun,
	LPCWSTR*	plpwch,
	int			id,
	LPCWSTR		str)
{
	ZeroMemory(pchp, sizeof(*pchp));								
	pchp->idObj = (WORD)id;												
	*pfHid 		= 0;												
	*pcch 		= 1;												
	*pprun 		= pols->GetPlsrun(0, pols->_pme->GetCF(), FALSE);
	*plpwch		= str;												
}

// Duplicate shaping state to each runs in the chain
// note: this macro used only by GetGlyph and GetGlyphPosition
inline void DupShapeState(
	PLSRUN		prun,
	LONG		cch)
{
	PLSRUN	pnext = prun->_pNext;										
	LONG	cpEnd = prun->_cp + cch;									
	while (pnext && pnext->_cp < cpEnd)
	{
		CopyMemory(&pnext->_a, &prun->_a, sizeof(SCRIPT_ANALYSIS));
		pnext->SetFallback(prun->IsFallback());
		prun = pnext;
		pnext = prun->_pNext;
	}																
	Assert(!pnext && prun->_cp < cpEnd);
}




LONG COls::GetCpLsFromCpRe(
	LONG cpRe)
{
	if (_rgcp.Count() == 0)
		return cpRe;

	LONG *pcp = _rgcp.Elem(0);

	for(LONG cpLs = cpRe; cpLs >= *pcp; pcp++)
		 cpLs++;

	return cpLs;
}

LONG COls::GetCpReFromCpLs(
	LONG cpLs
	)
{
	if (_rgcp.Count() == 0)
		return cpLs;

	LONG *pcp = _rgcp.Elem(0);

	for(int dcp = 0; cpLs > *pcp; pcp++)
		dcp--;

	return cpLs + dcp;
}

#ifdef DEBUG
//#define DEBUG_BRACE
#endif
// return TRUE if braces added
BOOL COls::AddBraceCp(long cpLs)
{
	if (_rgcp.Count() == 0)
	{
		long *pcp = _rgcp.Insert(0, 1);
		*pcp = tomForward;
	}

	long *pcp = _rgcp.Elem(0);
	long iel = 0;

	while (cpLs > pcp[iel])
		iel++;

	if (cpLs < pcp[iel])
	{
		pcp = _rgcp.Insert(iel, 1);
		*pcp = cpLs;
		return TRUE;
	}
	return FALSE;
}

// return number of braces before cp
//
LONG COls::BracesBeforeCp(LONG cpLs)
{
	LONG 	iel, cbr = 0;
	LONG*	pcp;

	if (!cpLs || (iel = _rgcp.Count()) < 2)
		return 0;

	iel -= 2;		// exclude the last tomForward one and make a count an index
	cpLs--;			// start with the cp preceding given cp

	pcp = _rgcp.Elem(0);

	while (iel > -1 && pcp[iel] > cpLs)		// search the first one
		iel--;

	while (iel > -1 && pcp[iel] == cpLs)	// continue counting
	{
		iel--;
		cpLs--;
		cbr++;
	}
	return cbr;
}

/*
 * 	SetRun(plsrun)
 *
 *	@func
 *		Do whatever is needed to initialize the measurer (pme) to the lsrun
 *		givin by plsrun and return whether the run is for autonumbering.
 *
 *	@rdesc
 *		TRUE if plsrun refers to an autonumbering run
 */
BOOL COls::SetRun(PLSRUN plsrun)
{
	LONG cp = plsrun->_cp;
	_pme->SetCp(cp & 0x7FFFFFFF);
	return plsrun->IsBullet();
}

/*
 * 	IsSelected()
 *
 *	@mfunc
 *	return whether or not the run should be drawn as selected.
 *
 */
CLsrun::IsSelected(void)
{
	if (!_fSelected)
		return FALSE;
	CRenderer *pre = g_pols->GetRenderer();
	Assert(pre->IsRenderer());
	return pre->_fRenderSelection ? TRUE : FALSE;
}

/*
 * 	CreatePlsrun (void)
 *
 *	@func
 *	Creates a PLSRUN. Is a little tricky because we allocate them in
 *	chunks.
 *
 *	@rdesc
 */
const int cplsrunAlloc = 8;
PLSRUN COls::CreatePlsrun()
{
	CLsrunChunk *plsrunChunk = 0;
	
	//First, find a chunk to use
	int cchunk = _rglsrunChunk.Count();
	for (int ichunk = 0; cchunk && ichunk < cchunk; ichunk++)
	{
		plsrunChunk = _rglsrunChunk.Elem(ichunk);
		if (plsrunChunk->_cel < cplsrunAlloc)
			break;
	}	

	if (!cchunk || ichunk == cchunk || plsrunChunk->_cel == cplsrunAlloc)
	{
		CLsrun *rglsrun = new CLsrun[cplsrunAlloc];
		if (rglsrun)
		{
			plsrunChunk = _rglsrunChunk.Add(1, 0);
			if (!plsrunChunk)
			{
				delete[] rglsrun;
				return 0;
			}
			plsrunChunk->_prglsrun = rglsrun;
		}
		else
			return 0;
	}
	return &plsrunChunk->_prglsrun[plsrunChunk->_cel++];
}

/*
 * 	GetPlsrun(cp, pCF, fAutoNumber)
 *
 *	@func
 *		Return plsrun for info in run. The structure contains the starting cp
 * 		of the run and the script analysis if Uniscribe is activated. The
 *		analysis information is needed by subsequent callbacks - GetGlyphs and
 *		GetGlyphPositions to be passed to Uniscribe in order to shape and
 *		position glyphs correctly for complex scripts.
 *
 *	@rdesc
 *		plsrun corresponding to info in arguments
 */
PLSRUN COls::GetPlsrun(
	LONG 		cp,
	const CCharFormat *pCF,
	BOOL 		fAutoNumber)
{
	if(fAutoNumber)
		cp |= CP_BULLET;

	CLsrun *plsrun = CreatePlsrun();

	if (plsrun)
	{
		ZeroMemory(plsrun, sizeof(CLsrun));

		plsrun->_pCF = pCF;
		plsrun->_cp = fAutoNumber ? _cp | CP_BULLET : cp;

		LONG 	cpSelMin, cpSelMost;
		_pme->GetPed()->GetSelRangeForRender(&cpSelMin, &cpSelMost);

		plsrun->SetSelected(!plsrun->IsBullet() && cp >= cpSelMin && cp < cpSelMost);

		if (pCF->_wScript && !_pme->GetPasswordChar())
		{
			CUniscribe*	pusp = _pme->Getusp();
			Assert(pusp);
			const SCRIPT_PROPERTIES* psp = pusp->GeteProp(pCF->_wScript);

			plsrun->_a.eScript = (pCF->_wScript < SCRIPT_MAX_COUNT) ? pCF->_wScript : 0;
			plsrun->_a.fRTL  = !psp->fNumeric && (IsBiDiCharSet(pCF->_bCharSet) || IsBiDiCharSet(psp->bCharSet));
			plsrun->_a.fLogicalOrder = TRUE;
		}
	}
	return plsrun;
}

/*
 *	COls::~COls()
 *
 *	@mfunc
 *		Destructor
 */
COls::~COls()
{
	for (int ichunk = 0, cchunk = _rglsrunChunk.Count(); ichunk < cchunk; ichunk++)
		delete []_rglsrunChunk.Elem(ichunk)->_prglsrun;
	DestroyLine(NULL);
	if (g_plsc)
		LsDestroyContext(g_plsc);
}


/*
 *	COls::Init(pme)
 *
 *	@mfunc
 *		Initialize this LineServices object
 *
 *	@rdesc
 *		HRESULT = (success) ? NOERROR : E_FAIL
 */
HRESULT COls::Init(
	CMeasurer *pme)
{
	_pme = pme;

	if(g_plsc)
		return NOERROR;

	// Build LS context to create
	LSCONTEXTINFO lsctxinf;

	// Setup object handlers
	LSIMETHODS vlsctxinf[OBJID_COUNT];
	vlsctxinf[OBJID_OLE] = vlsimethodsOle;
	if(LsGetReverseLsimethods(&vlsctxinf[OBJID_REVERSE]) != lserrNone)
		return E_FAIL;

	lsctxinf.cInstalledHandlers = OBJID_COUNT;
    lsctxinf.pInstalledHandlers = &vlsctxinf[0];

	// Set default and all other characters to 0xFFFF
    memset(&lsctxinf.lstxtcfg, 0xFF, sizeof(lsctxinf.lstxtcfg));

	lsctxinf.fDontReleaseRuns = TRUE;
	lsctxinf.lstxtcfg.cEstimatedCharsPerLine = cchLineHint;

	// Set the characters we handle
	lsctxinf.lstxtcfg.wchNull			= 0;
	lsctxinf.lstxtcfg.wchSpace			= ' ';
	lsctxinf.lstxtcfg.wchHyphen			= '-';
	lsctxinf.lstxtcfg.wchTab			= '\t';
	lsctxinf.lstxtcfg.wchEndLineInPara	= '\v';
	lsctxinf.lstxtcfg.wchEndPara1		= '\r';
	lsctxinf.lstxtcfg.wchEndPara2		= '\n';

	lsctxinf.lstxtcfg.wchVisiAltEndPara	=
	lsctxinf.lstxtcfg.wchVisiEndPara	=
	lsctxinf.lstxtcfg.wchVisiEndLineInPara = ' ';
	
	lsctxinf.lstxtcfg.wchNonReqHyphen = SOFTHYPHEN;

	// Auto number escape character
	lsctxinf.lstxtcfg.wchEscAnmRun = wchObjectEnd;

    lsctxinf.pols = this;
    lsctxinf.lscbk = lscbk;

	if(LsCreateContext(&lsctxinf, &g_plsc) != lserrNone)
		return E_FAIL;

	//REVIEW (keithcu) Quill seems to have a more mature kinsoku
	//table. For example, we don't allow breaking across space between
	//a word and the ending punctuation. French people want this behavior.
	BYTE  rgbrkpairsKinsoku[cKinsokuCategories][cKinsokuCategories];
	BYTE *prgbrkpairsKinsoku = &rgbrkpairsKinsoku[0][0];
	for(LONG i = 0; i < cKinsokuCategories; i++)
	{
		for(LONG j = 0; j < cKinsokuCategories; j++)
		{
			LONG iBreak = 2*CanBreak(i, j);
			// If don't break, allow break across blanks unless first
			// char is open brace or second char is close brace
			if (!iBreak &&				
				GetKinsokuClass(i) != brkclsOpen &&
				GetKinsokuClass(j) != brkclsOpen)
			{
				iBreak = 1;
			}
			*prgbrkpairsKinsoku++ = iBreak;
		}
	}
	if(g_plsc->SetBreaking(ARRAY_SIZE(rglsbrkDefault), rglsbrkDefault,
					 cKinsokuCategories, &rgbrkpairsKinsoku[0][0]) != lserrNone)
	{
		return E_FAIL;
	}

	return NOERROR;
}

/*
 * 	COls::MeasureLine(xWidth, pliTarget)
 *
 *	@mfunc
 *		Wrapper for LsCreateLine
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 */
const int dxpMaxWidth = 0x000FFFFF;
BOOL COls::MeasureLine(
    LONG	xWidth,			//@parm Width of line in device units
	CLine *	pliTarget)		//@parm Returns target-device line metrics (optional)
{
	LONG	xWidthActual = xWidth;
	CMeasurer *pme = _pme;
	const CParaFormat *pPF = pme->Get_pPF();
	const CDisplay *pdp = pme->_pdp;
	
	LONG cp = pme->GetCp();
#ifdef DEBUG
	LONG cchText = pme->GetTextLength();	// For DEBUG...
	AssertSz(cp < cchText || !pme->IsRich() && cp == cchText, "COls::Measure: trying to measure past EOD");
#endif
	DestroyLine(NULL);

	_cp = cp;
	_pdp = pdp;
	_fCheckFit = FALSE;
	pme->SetUseTargetDevice(FALSE);

	LSDEVRES lsdevres;
	lsdevres.dyrInch = pme->_dyrInch;
	lsdevres.dxrInch = pme->_dxrInch;
	lsdevres.dypInch = pme->_dypInch;
	lsdevres.dxpInch = pme->_dxpInch;

	g_plsc->SetDoc(TRUE, lsdevres.dyrInch == lsdevres.dypInch &&
					lsdevres.dxrInch == lsdevres.dxpInch, &lsdevres);

	if(xWidth == -1)
	{
		if (pdp->GetMaxWidth())
			xWidth = xWidthActual = pme->LXtoDX(pdp->GetMaxWidth());
		else
			xWidth = xWidthActual = max(0, pdp->GetMaxPixelWidth() - dxCaret);
	}

	if(!pdp->GetWordWrap())
	{
		xWidth = dxpMaxWidth;
		BOOL fNearJust = pPF->_bAlignment == PFA_LEFT && !pPF->IsRtlPara() ||
					     pPF->_bAlignment == PFA_RIGHT && pPF->IsRtlPara();
		if (!fNearJust)
			_fCheckFit = TRUE;
	}


	DWORD cBreakRecOut;
	LSLINFO	 lslinfo;
	BREAKREC rgBreak[MAX_OBJ_DEPTH];
	_xWidth = xWidth;

	LSERR lserr = g_plsc->CreateLine(cp, pme->DXtoLX(xWidth), NULL, 0, MAX_OBJ_DEPTH, rgBreak,
						 &cBreakRecOut, &lslinfo, &_plsline);

	if (_fCheckFit)
	{
		long upJunk, upStartTrailing;
		LsQueryLineDup(_plsline, &upJunk, &upJunk, &upJunk, &upStartTrailing, &upJunk);

		if (pme->_pPF->InTable())
			{
			// We play games in case of tables, so we should change width to get proper alignment.
			//
			// LS formats from negative left indent of -_dxOffset, but we'll actually display
			// from	the +_dxOffset. We will also lie to LS (or is is truth) about position of
			// the last tab. As a result of this, LS thinks the line by _dxOffset shorter than
			// it really is.
			xWidthActual -= pme->LXtoDX(pme->_pPF->_dxOffset);
			}

		if (upStartTrailing < xWidthActual)
		{
			_xWidth = xWidth = xWidthActual;
			_fCheckFit = FALSE;
			DestroyLine(NULL);
			lserr = g_plsc->CreateLine(cp, pme->DXtoLX(xWidth), NULL, 0, MAX_OBJ_DEPTH, rgBreak,
									   &cBreakRecOut, &lslinfo, &_plsline);
		}
	}

	//Line Services doesn't put the autonumbering dimensions into the line,
	//so we have to do it ourselves.
	lslinfo.dvpAscent = max(lslinfo.dvpAscent, lslinfo.dvpAscentAutoNumber);
	lslinfo.dvpDescent = max(lslinfo.dvpDescent, lslinfo.dvpDescentAutoNumber);

	pme->SetUseTargetDevice(FALSE);

	lslinfo.cpLim = GetCpReFromCpLs(lslinfo.cpLim);

	if (lserr != lserrNone)
	{
		AssertSz(lserr == lserrOutOfMemory, "Line format failed for invalid reason");
		pme->GetPed()->GetCallMgr()->SetOutOfMemory();
		return FALSE;
	}

	//REVIEW (keithcu) Doing this hit-testing during measurement is slow--is it
	//worth it to cache this data?
	if(!pme->IsRenderer())
	{
		long upJunk, upStart, upStartTrailing, upLimLine;

		// Save some LineServices results in the measurer's CLine
		pme->_li._cch = lslinfo.cpLim - cp;
		AssertSz(pme->_li._cch > 0,	"no cps on line");

		// Query line services for line width and indent.
		LsQueryLineDup(_plsline, &upJunk, &upJunk, &upStart, &upStartTrailing, &upLimLine);
		long dupWidth = upStartTrailing - upStart;

		pme->_li._xLeft = upStart;
		pme->_li._xWidth = dupWidth;

		if(pme->IsRich())
		{
			pme->_li._yHeight  = lslinfo.dvpAscent + lslinfo.dvpDescent;
			pme->_li._yDescent = lslinfo.dvpDescent;
		}
		else
			pme->CheckLineHeight();				// Use default heights

		pme->_li._cchEOP = 0;

		pme->SetCp(lslinfo.cpLim);
		if(pme->_rpTX.IsAfterEOP())				// Line ends with an EOP
		{										// Store cch of EOP (1 or 2)
			pme->_rpTX.BackupCpCRLF(FALSE);
			UINT ch = pme->GetChar();
			if(ch == CR || pme->GetPed()->fUseCRLF() && ch == LF)
				pme->_li._bFlags |= fliHasEOP;
			pme->_li._cchEOP = pme->_rpTX.AdvanceCpCRLF(FALSE);
		}
		if (lslinfo.cpLim > pme->GetTextLength() &&
			(!pme->IsRich() || pme->IsHidden()))
		{
			Assert(lslinfo.cpLim == pme->GetTextLength() + 1);
			pme->_li._cch--;
		}
		else
			pme->AdjustLineHeight();
	}

	//Setup pliTarget if caller requests it
	//FUTURE (KeithCu) If people want target information, then the display
	//information is the same, except that OnFormatRange has a bug.
	if (pliTarget)
	{
		CLine liSave = pme->_li;
		pme->_li._yHeight = max(lslinfo.dvrAscent, lslinfo.dvrAscentAutoNumber) +
							max(lslinfo.dvrDescent, lslinfo.dvrDescentAutoNumber);
		pme->_li._yDescent = lslinfo.dvrDescent;
		pme->SetUseTargetDevice(TRUE);
		pme->AdjustLineHeight();
		pme->SetUseTargetDevice(FALSE);
		*pliTarget = pme->_li;
		pme->_li = liSave;
	}
	return TRUE;
}

/*
 * 	COls::RenderLine()
 *
 *	@mfunc
 *		Wrapper for LsDisplayLine
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 */
BOOL COls::RenderLine(
	CLine &	li)				//@parm Line to render
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "COls::RenderLine");

	LONG		cp = _pme->GetCp();
	CRenderer	*pre = GetRenderer();
	LONG		xAdj = 0, yAdj = 0;
	Assert(pre->_fRenderer);

	pre->NewLine(li);
	if(li._fCollapsed)				// Line is collapsed in Outline mode
	{
		pre->Advance(li._cch);		// Bypass line
		return TRUE;				// Let dispml continue with next line
	}
	pre->SetNumber(li._bNumber);

	CreateOrGetLine();
	if(!_plsline)
		return FALSE;

	pre->SetCp(cp);						// Back to beginning of line
	Assert(pre->_fTarget == FALSE);
	pre->Check_pccs(FALSE);
	pre->SetClipRect();

	HDC hdcSave = NULL;
	if(li._cch > 0 && pre->fUseOffScreenDC() && (li._bFlags & fliUseOffScreenDC))
	{
		// Set up an off-screen DC if we can. Note that if this fails,
		// we just use the regular DC which won't look as nice but
		// will at least display something readable.
		hdcSave = pre->SetUpOffScreenDC(xAdj, yAdj);

		// Is this a uniform text being rendered off screen?
		if(li._bFlags & fliOffScreenOnce)
		{
			// Yes - turn off special rendering since line has been rendered
			li._bFlags &= ~(fliOffScreenOnce | fliUseOffScreenDC);
		}
	}
	POINT pt = pre->GetCurPoint();			// Must follow offscreen setup
	RECT  rc = pre->GetClipRect();			//  since _ptCur, _rc change
	LONG  x = 0;
	if(pre->_pPF->InTable())
	{
		pt.x += 2*pre->LXtoDX(pre->_pPF->_dxOffset);
		x = pt.x + pre->_li._xLeft;
	}

	pre->_li._xLeft = 0;
	pre->RenderStartLine();

	pt.x += pre->XFromU(0);

	pt.y += li._yHeight - li._yDescent;		// Move to baseline	for LS
	LSERR lserr = LsDisplayLine(_plsline, &pt, pre->GetPdp()->IsMain() ? ETO_CLIPPED : 0, &rc);

	AssertSz(lserr == lserrNone, "COls::RenderLine: error in rendering line");

	pre->EndRenderLine(hdcSave, xAdj, yAdj, x);
	pre->SetCp(cp + li._cch);

	return lserr == lserrNone;
}

/*
 * 	COls::CreateOrGetLine()
 *
 *	@mfunc
 *		If _plsline is nonNull and _cp equals _pme->GetCp(), return.  Else
 *		create line with caching so that _plsline and _cp are correct for
 *		current line
 */
void COls::CreateOrGetLine()
{
	if(_plsline && _pme->GetCp() == _cp && _pme->_pdp == _pdp)
		return;

	MeasureLine(-1, NULL);		// Define new _plsline
}

/*
 * 	COls::MeasureText(cch, taMode, pdx, pdy)
 *
 *	@mfunc
 *		Gets x offset to cp given by CMeasurer _pme + cch chars along with
 *		display dimensions.
 *
 *	@rdesc
 *		xwidth measured
 */
LONG COls::MeasureText(
	LONG	 cch,			//(IN): Max cch to measure
	UINT	 taMode,		//(IN): requested coordinate
	CDispDim *pdispdim)		//(OUT): display dimensions
{
	CMeasurer *	pme = _pme;				
	LONG		cp = pme->GetCp() + cch;	// Enter with me at start of line
	POINT		pt;							// Point at cp in client coords
	BOOL		fAtLogicalRightEdge = FALSE;

	CreateOrGetLine();
	if(!_plsline)
		return 0;
	Assert(pme->_fTarget == FALSE);

	// Query point from cp
	DWORD		cActualDepth;
	LSQSUBINFO	lsqSubInfo[MAX_OBJ_DEPTH];
	LSTEXTCELL	lsTextCell;

    memset(&lsTextCell, 0, sizeof(lsTextCell));
	
	LsQueryLineCpPpoint(_plsline, GetCpLsFromCpRe(cp), MAX_OBJ_DEPTH, &lsqSubInfo[0],
									  &cActualDepth, &lsTextCell);

	pdispdim->lstflow = lsqSubInfo[cActualDepth - 1].lstflowSubline;
	pdispdim->dx = lsTextCell.dupCell;

	LSTFLOW	 lstflowLine = lsqSubInfo[0].lstflowSubline;

	POINT ptStart = {pme->XFromU(0), pme->_li._yHeight - pme->_li._yDescent};
	POINTUV ptuv = lsTextCell.pointUvStartCell;

	if(taMode & (TA_STARTOFLINE | TA_ENDOFLINE) && cActualDepth > 1)
	{
		ptuv = lsqSubInfo[0].pointUvStartRun;
		if(taMode & TA_ENDOFLINE)
			ptuv.u += lsqSubInfo[0].dupRun;
	}

	//If they ask for position inside ligature or at lim of line, give right edge of cell
	else if (cp > GetCpReFromCpLs(lsTextCell.cpStartCell))
	{
		fAtLogicalRightEdge = TRUE;
		if (lstflowLine != pdispdim->lstflow)
			ptuv.u -= lsTextCell.dupCell;
		else
			ptuv.u += lsTextCell.dupCell;
	}

	LsPointXYFromPointUV(&ptStart, lstflowLine, &ptuv, &pt);

	if(pme->_pPF->InTable())
		pt.x += 2*pme->LXtoDX(pme->_pPF->_dxOffset);

	if (pdispdim->lstflow == lstflowWS && !(taMode & (TA_LOGICAL | TA_STARTOFLINE)))
	{
		if (fAtLogicalRightEdge)
		{
			if ((taMode & TA_RIGHT) == TA_RIGHT)
				pt.x += pdispdim->dx;
			else if (taMode & TA_CENTER)
				pt.x += pdispdim->dx / 2;
			return pt.x;
		}
		else
			pt.x -= pdispdim->dx;
	}

	LONG dx = 0;

	if(taMode & TA_CENTER && !fAtLogicalRightEdge)
		dx = pdispdim->dx;
	if((taMode & TA_CENTER) == TA_CENTER)
		dx >>= 1;

	if (pdispdim->lstflow == lstflowWS && (taMode & TA_LOGICAL))
		dx = -dx;
	return max(0, pt.x + dx);
}

/*
 * 	COls::CchFromXpos(pt, &dx)
 *
 *	@mfunc
 *		Moves _pme to pt.x. Calls LsQueryLinePointPcp()
 */
void COls::CchFromXpos(
	POINT pt,			//@parm Point to find cch for in line
	CDispDim *pdispdim,	//@parm dimensions of object
	LONG	*pcpActual) //@parm CP point
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "COls::CchFromXpos");

	if(_pme->_pPF->InTable())
		pt.x -= 2*_pme->LXtoDX(_pme->_pPF->_dxOffset);

	// Make point relative to LS coordinate system - (0,0) in LS is at the
	// baseline of the line.
	POINTUV ptuv = {_pme->UFromX(pt.x), -pt.y + _pme->_li._yHeight - _pme->_li._yDescent};

	LONG cpStart = _pme->GetCp();

	CreateOrGetLine();
	if(!_plsline)
		return;
	Assert(_pme->_fTarget == FALSE);

	DWORD		cActualDepth;
	LSQSUBINFO	lsqSubInfo[MAX_OBJ_DEPTH];
	LSTEXTCELL	lsTextCell;

	memset(&lsTextCell, 0, sizeof(lsTextCell));

	LsQueryLinePointPcp(_plsline, &ptuv, MAX_OBJ_DEPTH,	&lsqSubInfo[0], &cActualDepth, &lsTextCell);

	if (cActualDepth == 0) //If we got back empty textcell, let's just query cp explicitly to get information
	{
		LsQueryLineCpPpoint(_plsline, cpStart, MAX_OBJ_DEPTH, &lsqSubInfo[0], &cActualDepth, &lsTextCell);
		Assert(cActualDepth != 0);
	}

	pdispdim->dx = lsTextCell.dupCell;
	pdispdim->lstflow = lsqSubInfo[cActualDepth - 1].lstflowSubline;

    LONG cp = *pcpActual = GetCpReFromCpLs(lsTextCell.cpStartCell);

	POINTUV ptuvCell;
	//Convert the hit-test point from u,v of line to u,v of cell
	LsPointUV2FromPointUV1(lsqSubInfo[0].lstflowSubline, &lsTextCell.pointUvStartCell, &ptuv,
		lsqSubInfo[cActualDepth - 1].lstflowSubline, &ptuvCell);

	if(ptuvCell.u > lsTextCell.dupCell/2)
		cp += lsTextCell.cpEndCell - lsTextCell.cpStartCell + 1;

	if (_pme->GetPed()->_pbrk)
	{
		// If text breaker is up, verify cluster before placing the caret
		CTxtBreaker* pbrk = _pme->GetPed()->_pbrk;
		LONG		 cpEnd = _pme->GetPed()->GetTextLength();
		while (cp < cpEnd && !pbrk->CanBreakCp(BRK_CLUSTER, cp))
			cp++;
	}

	_pme->_li._cch = cp - _cp;
	_pme->SetCp(cp);
}

/*
 * 	COls::DestroyLine(pdp)
 *
 *	@mfunc
 *		Destroys any line data structures.
 */
void COls::DestroyLine(CDisplay *pdp)
{
	CLock lock;
	if (pdp && pdp != _pdp)
		return;

	if(_plsline)
	{
		g_plsc->DestroyLine(_plsline);
		_plsline = NULL;
	}
	if (_rgcp.Count())
		_rgcp.Clear(AF_KEEPMEM);

	int cchunk = _rglsrunChunk.Count();
	for (int ichunk = 0; ichunk < cchunk; ichunk++)
		_rglsrunChunk.Elem(ichunk)->_cel = 0;
}

/*
 * 	LimitChunk(pch, &cchChunk, f10Mode)
 *
 *	@func
 *		Return object ID at *pch and shorten cchChunk to 1 if object isn't
 *		text and to the count of text chars up to a nontext object if one
 *		occurs within cchChunk and within the current paragraph.
 *
 *	@rdesc
 *		Object ID at *pch
 */
DWORD LimitChunk(const WCHAR *pch, LONG &cchChunk, BOOL f10Mode)
{
	for(LONG i = 0; i < cchChunk && *pch != CR; i++, pch++)
	{
		switch(*pch)
		{
		case WCH_EMBEDDING:
			if(i == 0)
			{
				cchChunk = 1;
				return OBJID_OLE;		// Entered at an OLE object
			}
			cchChunk = i;				// Will break before
		break;

		case EURO:
			if (i == 0)
			{
				for(; i < cchChunk && *pch == EURO; i++)
					pch++;
			}
			cchChunk = i;
		break;

		case FF:
			if(f10Mode)					// RE 1.0 treats FFs as
				continue;				//  ordinary characters

			cchChunk = i;				// Will break before
		break;
		}
	}

	return idObjTextChp;
}

/*
 * 	SetLsChp(dwObjId, pme, plsChp)
 *
 *	@func
 *		Helper function that initializes an LS chp from RE CCharFormat
 *
 *	@rdesc
 *		TRUE iff IsHidden()
 */
BOOL COls::SetLsChp(
	DWORD		dwObjId,	//(IN): Object id
	PLSRUN		plsrun,		//(IN): Current Run
	PLSCHP		plsChp)		//(OUT): LS chp
{
	ZeroMemory(plsChp, sizeof(*plsChp));
	plsChp->idObj = (WORD)dwObjId;

	//If we do FE or Latin kerning, we need to set dcpMaxContext to 2

	if (_pme->GetPed()->IsComplexScript() && plsrun->_a.eScript && !plsrun->IsBullet())
	{
		CUniscribe*		pusp = _pme->Getusp();
		Assert (pusp);
		const SCRIPT_PROPERTIES *psp = pusp->GeteProp(plsrun->_a.eScript);

		if (psp->fComplex || plsrun->_a.fRTL ||
			psp->fNumeric && W32->GetDigitSubstitutionMode() != DIGITS_NOTIMPL)
		{
			// 1. Complex script
			// 2. RTL (internal direction) run (handle mirror glyph i.e.'?')
			// 3. Numeric run and substitution mode is either Native or Context

			plsChp->fGlyphBased	= TRUE;
		}
	}

	DWORD dwEffects = plsrun->_pCF->_dwEffects;

	if(dwEffects & (CFE_UNDERLINE | CFE_LINK | CFE_REVISED))
		plsChp->fUnderline = TRUE;

	if(dwEffects & CFE_STRIKEOUT && !plsrun->IsBullet())
		plsChp->fStrike = TRUE;

	if (plsrun->_pCF->_yOffset || dwEffects & (CFE_SUPERSCRIPT | CFE_SUBSCRIPT))
	{
		_pme->SetUseTargetDevice(FALSE);
		CCcs *pccs = _pme->Check_pccs(plsrun->IsBullet());
		LONG yOffset, yAdjust;
		pccs->GetOffset(plsrun->_pCF, _pme->_dypInch, &yOffset, &yAdjust);

		plsChp->dvpPos += yOffset + yAdjust;
	}

	//If its an OLE object, but the Object doesn't exist yet, then hide it
	if (dwObjId == OBJID_OLE)
	{
		COleObject * pobj = _pme->GetPed()->GetObjectMgr()->GetObjectFromCp(_pme->GetCp());
		if (!pobj)
			return TRUE;
	}
	return dwEffects & CFE_HIDDEN;
}

/*
 *	FetchAnmRun(pols, cp, plpwchRun, pcchRun, pfHidden, plsChp, pplsrun)
 *
 *	@func
 *		 LineServices fetch bullets/numbering callback
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI COls::FetchAnmRun(
	LSCP	 cp,		//@parm [IN]: RE cp
	LPCWSTR *plpwchRun, //@parm [OUT]: Run of characters
	DWORD *	 pcchRun, 	//@parm [OUT]: Count of characters in run
	BOOL *	 pfHidden, 	//@parm [OUT]: fHidden run?
	PLSCHP	 plsChp, 	//@parm [OUT]: Char properties of run
	PLSRUN * pplsrun)	//@parm [OUT]: Abstract representation of run properties
{
	if (cp == cpFirstAnm && _pme->Get_pPF()->IsRtlPara())
	{
		ZeroMemory(plsChp, sizeof(*plsChp));
		plsChp->idObj = OBJID_REVERSE;
		*pfHidden	= 0; *pcchRun = 1;
		*pplsrun	= GetPlsrun(_pme->GetCp(), &_CFBullet, TRUE);
		*plpwchRun	= &_szAnm[0];
		return lserrNone;
	}

	*plpwchRun = &_szAnm[cp - cpFirstAnm];
	*pcchRun = _cchAnm - (cp - cpFirstAnm);	
	*pplsrun  = GetPlsrun(_pme->GetCp(), &_CFBullet, TRUE);
	SetLsChp(idObjTextChp, *pplsrun, plsChp);
	*pfHidden = FALSE;

	if (!_pme->GetNumber())
		plsChp->fUnderline = FALSE;

	return lserrNone;	
}



/*
 *	OlsFetchRun(pols, cp, plpwchRun, pcchRun, pfHidden, plsChp, pplsrun)
 *
 *	@func
 *		 LineServices fetch-run callback
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFetchRun(
	POLS	 pols,		//@parm [IN]: COls *
	LSCP	 cpLs,		//@parm [IN]: LS cp
	LPCWSTR *plpwchRun, //@parm [OUT]: Run of characters
	DWORD *	 pcchRun, 	//@parm [OUT]: Count of characters in run
	BOOL *	 pfHidden, 	//@parm [OUT]: Hidden run?
	PLSCHP	 plsChp, 	//@parm [OUT]: Char properties of run
	PLSRUN * pplsrun)	//@parm [OUT]: Abstract representation of run properties
{
	if(cpLs < 0)
		return pols->FetchAnmRun(cpLs, plpwchRun, pcchRun, pfHidden, plsChp, pplsrun);

	CMeasurer 	*pme = pols->GetMeasurer();
	CTxtEdit 	*ped = pme->GetPed();
	BOOL		fStart = FALSE;
	BOOL		fFetchBraces = ped->IsBiDi() && g_pusp && g_pusp->IsValid() &&
							!ped->_fItemizePending && ped->GetAdjustedTextLength();
	WCHAR		chPassword = pme->GetPasswordChar();
	LONG		cpAccelerator = ped->GetCpAccelerator();
	BOOL		fAccelerator = FALSE;
	BOOL		f10Mode = ped->Get10Mode();

	if (cpLs == pols->_cp)
	{
		//If we are formatting (or re-formatting) the line, cleanup
		if (pols->_rgcp.Count())
			pols->_rgcp.Clear(AF_KEEPMEM);
		pols->_cEmit = 0;
	}
	long cpRe = pols->GetCpReFromCpLs(cpLs);


	pme->SetCp(cpRe);		// start fetching at given cp


	if (fFetchBraces && pme->_rpCF.IsValid())
	{
		// consider emitting braces only at the run boundary or start of a fetched line
		//
		if (cpRe == pols->_cp || !pme->GetIchRunCF() || !pme->GetCchLeftRunCF())
		{
			SHORT	cBrClose, cBrOpen;
			BYTE	bBaseLevel = pme->IsParaRTL() ? 1 : 0;
			BYTE	bLevel, bLevelPrev;
	
			bLevelPrev = bLevel = bBaseLevel;			// assume base level
	
			if (cpRe < ped->GetTextLength())
			{
				CBiDiLevel	level;

				bLevel = pme->_rpCF.GetLevel(&level);	// got level of current run
				fStart = level._fStart;
			}
	
			if (cpRe > pols->_cp && pme->Advance(-1))
			{
				if (pme->_rpPF.SameLevel(bBaseLevel))	// preceding run may be hidden
					bLevelPrev = pme->_rpCF.GetLevel();	// got level of preceding run
				pme->Advance(1);						// resume position
			}
	
			cBrOpen = cBrClose = bLevel - bLevelPrev;
	
			if (fStart)									// start embedding at the current run
				cBrClose = bBaseLevel - bLevelPrev;		// this means we must close all braces of preceding run
	
			cBrClose = max(0, -cBrClose);

			if (cBrClose > 0 && pols->BracesBeforeCp(cpLs) < cBrClose)
			{
				// emit close braces

				if (pols->_cEmit > 0)
				{
					EmitBrace(pols, plsChp, pfHidden, pcchRun, pplsrun, plpwchRun, idObjTextChp, rgchObjectEnd);
					if (pols->AddBraceCp(cpLs))
						pols->_cEmit--;
#ifdef DEBUG_BRACE
					Tracef(TRCSEVNONE, "CLOSE(%d) cpLs %d: emitted %d", cBrClose, cpLs, pols->_cEmit);
#endif
					return lserrNone;
				}
				else
				{
					// We assert. You can click "Ignore All" with no hang.
					AssertSz(FALSE, "Prevent emitting close brace (no open counterpart)");
				}
			}
	
			if (fStart)									// start embedding at the current run
				cBrOpen = bLevel - bBaseLevel;			// we begin openning braces
	
			if (cBrOpen > 0 && pols->BracesBeforeCp(cpLs) < cBrOpen + cBrClose)
			{
				// emit open braces
	
				EmitBrace(pols, plsChp, pfHidden, pcchRun, pplsrun, plpwchRun, OBJID_REVERSE, L" ");
				if (pols->AddBraceCp(cpLs))
					pols->_cEmit++;
#ifdef DEBUG_BRACE
				Tracef(TRCSEVNONE, "OPEN(%d) cpLs %d: emitted %d", cBrOpen, cpLs, pols->_cEmit);
#endif
				return lserrNone;
			}
		}
	}

	// Done fetching braces.
	// Begin getting real data...


#ifdef DEBUG_BRACE
	Tracef(TRCSEVNONE, "cpLs %d: emitted %d", cpLs, pols->_cEmit);
#endif

	// Initialized chunk to count of characters in format run
	LONG	cchChunk = pme->GetCchLeftRunCF();
	DWORD	dwObjId	 = idObjTextChp;

	if(!pme->IsHidden())							// Run isn't hidden
	{
		LONG cch;

		*plpwchRun = pme->GetPch(cch);		// Get text in run
		cchChunk = min(cchChunk, cch);		// Maybe less than cchChunk
		if (!pme->GetPdp()->IsMetafile())
			cchChunk = min(cchChunk, cchLineHint);

		if (chPassword)
		{
			cchChunk = min(cchChunk, int(sizeof(pols->_rgchTemp) / sizeof(WCHAR)));
			memcpy(pols->_rgchTemp, *plpwchRun, cchChunk * sizeof(WCHAR));

			for (int i = 0; i < cchChunk; i++)
			{
				if (!IsASCIIEOP((*plpwchRun)[i]))
					pols->_rgchTemp[i] = chPassword;
				else
					pols->_rgchTemp[i] = (*plpwchRun)[i];
			}
			*plpwchRun = pols->_rgchTemp;
		}

		if(cpAccelerator != -1)
		{
			LONG cpCur = pme->GetCp();		// Get current cp

			// Does accelerator character fall in this chunk?
			if (cpCur < cpAccelerator &&
				cpCur + cchChunk > cpAccelerator)
			{
				// Yes. Reduce chunk to char just before accelerator
				cchChunk = cpAccelerator - cpCur;
			}
			// Is this character the accelerator?
			else if(cpCur == cpAccelerator)
			{							// Set chunk size to 1 since only
				cchChunk = 1;			//  want to output underlined char
				fAccelerator = TRUE;	// Tell downstream routines that
										//  we're handling accelerator
			}
		}
		if(pme->GetCF()->_dwEffects & CFE_ALLCAPS)
		{
			cchChunk = min(cchChunk, int(sizeof(pols->_rgchTemp) / sizeof(WCHAR)));
			memcpy(pols->_rgchTemp, *plpwchRun, cchChunk * sizeof(WCHAR));
			CharUpperBuff(pols->_rgchTemp, cchChunk);
			*plpwchRun = pols->_rgchTemp;
		}

		//Line Services handles page breaks in a weird way, so lets just convert to a CR.
		if (*plpwchRun && *(*plpwchRun) == FF && !f10Mode)
		{
			pols->_szAnm[0] = CR;
			*plpwchRun = pols->_szAnm;
			cchChunk = 1;
		}

		AssertSz(cpRe < ped->GetTextLength() || !ped->IsRich(),	"0-length run at end of control");
		AssertSz(cch || !ped->IsRich(),	"0-length run at end of control");

		// Set run size appropriately for any objects that are in run
		dwObjId = LimitChunk(*plpwchRun, cchChunk, f10Mode);

		// Get regular highlighted positions
		LONG cpSelMin, cpSelMost;
		ped->GetSelRangeForRender(&cpSelMin, &cpSelMost);

		if(cpSelMin != cpSelMost)
		{
			if(cpRe >= cpSelMin)
			{
				if(cpRe < cpSelMost)
				{
					// Current text falls inside selection
					cch = cpSelMost - cpRe;
					cchChunk = min(cchChunk, cch);
				}
			}
			else if(cpRe + cchChunk >= cpSelMin)
			{
				// cp < cpSelMin - run starts outside of selection.
				// Limit text to start of selection.
				cchChunk = cpSelMin - cpRe;
			}
		}
	}

	*pplsrun = pols->GetPlsrun(cpRe, pme->GetCF(), FALSE);
	*pfHidden = pols->SetLsChp(dwObjId, *pplsrun, plsChp);

	if (fAccelerator)
		plsChp->fUnderline = TRUE;

	if(!cchChunk)							// Happens in plain-text controls
	{										//  and if hidden text to end of story
		if (!ped->IsRich() && pols->_cEmit > 0)
		{
			EmitBrace(pols, plsChp, pfHidden, pcchRun, pplsrun, plpwchRun, idObjTextChp, rgchObjectEnd);
			TRACEWARNSZ("(plain)Auto-emit a close brace to make balance");
			if (pols->AddBraceCp(cpLs))
				pols->_cEmit--;
			return lserrNone;
		}
		cchChunk = 1;
		*plpwchRun = szCR;
		*pfHidden = FALSE;
		//Paragraph marks should not have any script state associated with them,
		//even if the pCF that point to does.
		ZeroMemory(&(*pplsrun)->_a, sizeof((*pplsrun)->_a));
	}
	*pcchRun = cchChunk;

	return lserrNone;
}

/*
 *	OlsGetAutoNumberInfo (pols, plskalAnm, pwchAdd, plschp, pplsrun,
 *						  pfWord95Model, pduaSpaceAnm, pduaWidthAnm)
 *	@func
 *		LineServices fetch autonumbering info callback. Return info needed
 *		by LS for auto numbering. Get the chp/run for last char from auto
 *		number run. Always say we are Word95 model Anm and get rest of info
 *		from paragraph properties.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetAutoNumberInfo(
	POLS	 pols,			//(IN): Client context
	LSKALIGN *plskalAnm,	//(OUT):Justification
	PLSCHP   plschpAnm,
	PLSRUN   *pplsrunAnm,
	WCHAR *	 pwchAdd,		//(OUT):char to add (Nil is treated as none)
	PLSCHP	 plsChp,		//(OUT):chp for bridge character
	PLSRUN * pplsrun,		//(OUT):Run for bridge character
	BOOL *	 pfWord95Model,	//(OUT):Type of autonumber run
	long *	 pduaSpaceAnm,	//(OUT):Relevant iff fWord95Model
	long *	 pduaWidthAnm)	//(OUT):Relevant iff fWord95Model
{
	CMeasurer *pme = pols->GetMeasurer();
	const CParaFormat *pPF = pme->Get_pPF();

	*pplsrunAnm = *pplsrun = pols->GetPlsrun(pme->GetCp(), &pols->_CFBullet, TRUE);
	pols->SetLsChp(idObjTextChp, *pplsrun, plsChp);

	if (!pme->GetNumber())
		plsChp->fUnderline = FALSE;

	*plschpAnm		= *plsChp;
	*pwchAdd		= '\t';
	*pfWord95Model	= TRUE;
	*pduaSpaceAnm	= 0;
	*pduaWidthAnm	= max(pPF->_dxOffset, pPF->_wNumberingTab);
	*plskalAnm		= (LSKALIGN)(lskalLeft + (pPF->_wNumberingStyle & 3));

	return lserrNone;
}

/*
 *	OlsGetNumericSeparators (pols, cp, plspap)
 *
 *	@func
 *		Get numeric separators needed, e.g., for decimal tabs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetNumericSeparators(
	POLS	pols,			//(IN): pols
	PLSRUN	plsrun,			//(IN): Run (cp here)
	WCHAR *	pwchDecimal,	//(OUT): Decimal separator for this run
	WCHAR *	pwchThousands)	//(OUT): Thousands separator for this run
{
	LCID	lcid = plsrun->_pCF->_lcid;
	WCHAR	ch = TEXT('.');

	// This may need to be virtualized for Win95/CE...
	::GetLocaleInfo(lcid, LOCALE_SDECIMAL, &ch, 1);
	*pwchDecimal = ch;
	ch = TEXT(',');
	::GetLocaleInfo(lcid, LOCALE_STHOUSAND, &ch, 1);
	*pwchThousands = ch;

	return lserrNone;
}

							
/*
 *	OlsFetchPap (pols, cp, plspap)
 *
 *	@func
 *		Fetch paragraph properties
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFetchPap(
	POLS	pols,		//(IN): pols
	LSCP	cpLs, 		//(IN):  an arbitrary cp value inside paragraph
	PLSPAP	plspap)		//(OUT): Paragraph properties.
{
	CMeasurer *pme = pols->GetMeasurer();
	pme->SetCp(pols->_cp);

	const CParaFormat *pPF = pme->Get_pPF();
	CTxtEdit *		   ped = pme->GetPed();

	// Default all results to 0
	ZeroMemory(plspap, sizeof(*plspap));

	//LS doesn't really care where the paragraph starts
	plspap->cpFirst = pols->_cp;

	if(plspap->cpFirst && !pme->fFirstInPara())	// Not first in para: say para
		plspap->cpFirst--;						//  starts one char earlier

	plspap->cpFirstContent = plspap->cpFirst;

	if (pPF->IsRtlPara() && !pPF->InTable())
		plspap->lstflow = lstflowWS;

	// Alignment
	plspap->lskal = (LSKALIGN) g_rgREtoTOMAlign[pPF->_bAlignment];

	if (pPF->_bAlignment == PFA_FULL_INTERWORD)
	{
		plspap->lskal = lskalLeft;
		plspap->lskj = lskjFullInterWord;
	}

	// Kind of EOP
	plspap->lskeop = ped->fUseCRLF() ? lskeopEndPara12 : lskeopEndPara1;

	if (pPF->IsRtlPara())
	{	//For Line Services, left means near and right means far.
		if (plspap->lskal == lskalLeft)
			plspap->lskal = lskalRight;
		else if (plspap->lskal == lskalRight)
			plspap->lskal = lskalLeft;
	}

	if (pols->_fCheckFit)
		plspap->lskal = lskalLeft;

	// Line breaking
	if (pPF->_bAlignment > PFA_FULL_INTERWORD || !ped->fUseSimpleLineBreak() ||
		!pme->GetPdp()->GetWordWrap())		// No word wrap
	{
		plspap->grpf |= fFmiApplyBreakingRules;
	}

	LONG dx = pPF->_dxRightIndent;

	plspap->uaRightBreak   = dx;
	plspap->uaRightJustify = dx;
	if(ped->IsInOutlineView())
	{
		plspap->uaLeft	   = lDefaultTab/2 * (pPF->_bOutlineLevel + 1);
		plspap->duaIndent  = 0;
	}
	else
	{
		plspap->uaLeft	   = pPF->_dxStartIndent + pPF->_dxOffset;
		plspap->duaIndent  = -pPF->_dxOffset;
	}

	if(!pPF->InTable() && plspap->uaLeft < 0)
		plspap->uaLeft = 0;

	// Is this a bulleted paragraph? - ignore bullets in a password
	if(pPF->_wNumbering && pme->fFirstInPara() && !pme->GetPasswordChar() &&
	   !pPF->IsNumberSuppressed())
	{
		CCcs *pccs = pme->GetCcsBullet(&pols->_CFBullet);
		if (pccs)
			pccs->Release();

		plspap->grpf |= fFmiAnm;
		WCHAR *pchAnm = pols->_szAnm;
		pols->_cchAnm = 0;

		if (pPF->IsRtlPara()) //open character
			*pchAnm++ = ' ';
		
		//FUTURE (KeithCu) we turn off Indic digits if there is any Hebrew,
		//which should be refined to do a better job with worldwide documents.
		pols->_cchAnm += pPF->NumToStr(pchAnm, pme->GetNumber(),
			(pme->GetPed()->GetCharFlags() & fHEBREW) ? 0 : fIndicDigits);
		pchAnm += pols->_cchAnm;
		
		if (pPF->IsRtlPara()) 	  //End character for reverser
		{
			*pchAnm++ = wchObjectEnd;
			pols->_cchAnm += 2;	  //alloc space for open and close
		}
		*pchAnm++ = ' ';		  //Ensure a little extra space
		*pchAnm++ = wchObjectEnd; //End character for Anm
		pols->_cchAnm += 2;
	}

	return lserrNone;
}

/*
 *	OlsFetchTabs(pols, LSCP cp, PLSTABS plstabs, BOOL *pfHangingTab,
 *				 long *pduaHangingTab, WCHAR *pwchHangingTabLeader)
 *	@func
 *		Fetch tabs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFetchTabs(
	POLS	pols,					//(IN):	(COls *)
	LSCP	cp,						//(IN): Arbitrary cp value inside para
	PLSTABS plstabs,				//(OUT): Tabs array
	BOOL *	pfHangingTab,			//(OUT): There is hanging tab
	long *	pduaHangingTab,			//(OUT): dua of hanging tab
	WCHAR *	pwchHangingTabLeader)	//(OUT): Leader of hanging tab
{
	CMeasurer *pme = pols->GetMeasurer();

	const CParaFormat *pPF = pme->Get_pPF();
	const char rgchTabLeader[] = {0, '.', '-', '_', '_', '='};

	LONG		cTabCount = pPF->_bTabCount;
	LONG		i, iActual;
	LSTBD *		prgTab	  = pols->_rgTab;
	const LONG *prgxTabs  = pPF->GetTabs();

	Assert(cTabCount <= MAX_TAB_STOPS && (prgxTabs || !cTabCount));

	plstabs->duaIncrementalTab = pme->GetPed()->GetDefaultTab();

	*pwchHangingTabLeader = 0;
	*pduaHangingTab = pPF->_dxStartIndent + pPF->_dxOffset;
	*pfHangingTab = (!(pPF->InTable()) && pPF->_dxOffset > 0);

	for(i = 0, iActual = 0; i < cTabCount; i++)
	{
		LONG tbAlign, tbLeader;
		pPF->GetTab(i, &prgTab[iActual].ua, &tbAlign, &tbLeader, prgxTabs);

		pme->SetUseTargetDevice(FALSE);
		if (pme->LXtoDX(prgTab[iActual].ua) > pols->_xWidth)
			break;

		if(pPF->InTable())
		{
			tbAlign = lsktLeft;				// Don't have alignment and
			tbLeader = 0;			 		//	leader yet
		}
		if(tbAlign <= tomAlignDecimal)		// Don't include tomAlignBar
		{
			prgTab[iActual].lskt = (lsktab) tbAlign;
			prgTab[iActual].wchTabLeader = rgchTabLeader[tbLeader];
			iActual++;
		}
	}

	plstabs->pTab = prgTab;
	plstabs->iTabUserDefMac = iActual;
	return lserrNone;
}

/*
 *	OlsCheckParaBoundaries (pols, cpOld, cpNew, pfChanged)
 *
 *	@func
 *		Determine if para formatting between para containing cpOld and
 *		that containing cpNew are incompatible and shouldn't be formatted
 *		on the same line when connected by hidden text.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCheckParaBoundaries(
	POLS	pols,		//(IN): Interface object
	LONG	cpOld,		//(IN): cp in one paragraph
	LONG	cpNew,		//(IN): cp in another paragraph
	BOOL *	pfChanged)	//(OUT): "Dangerous" change between para properties
{

	// It's easier (and safer) to allow LS decide which para properties to take.
	// Else we have to close objects (BiDi, for instance) before hidden EOP.

	*pfChanged = fFalse;			// they're always compatible

	return lserrNone;
}
		
/*
 *	OlsGetRunCharWidths (pols, plrun, deviceID, lpwchRun, cwchRun, du,
 *						 kTFlow, prgDu, pduRun, plimDu)
 *	@func
 *		Get run character widths
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunCharWidths(
	POLS	  pols,			//(IN): Interface object
	PLSRUN	  plsrun,		//(IN): Run (cp here)
	enum lsdevice deviceID, //(IN): Preview, reference, or absolute
	LPCWSTR	  lpwchRun,		//(IN): Run of characters
	DWORD	  cwchRun, 		//(IN): Count of characters in run
	long	  du, 			//(IN): Available space for characters
	LSTFLOW	  kTFlow,		//(IN): Text direction and orientation
	int *	  prgDu,		//(OUT): Widths of characters
	long *	  pduRun,		//(OUT): Sum of widths in rgDx[0] to rgDu[limDx-1]
	long *	  plimDu)		//(OUT): Number of widths fetched
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL fBullet = pols->SetRun(plsrun);
	DWORD i = 0;
	LONG  xWidth, xAdjust, duCalc = 0;
	BOOL  fGlyphRun = FALSE;
	pme->SetUseTargetDevice(deviceID == lsdevReference);
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	if (pme->GetPed()->IsComplexScript() &&
		plsrun->_a.eScript && !plsrun->IsBullet())
	{
		const SCRIPT_PROPERTIES *psp = pme->Getusp()->GeteProp(plsrun->_a.eScript);
		if (psp->fComplex)
			fGlyphRun = TRUE;
	}

	xAdjust = pme->LXtoDX(plsrun->_pCF->_sSpacing);
	for(;i < cwchRun; i++, lpwchRun++)
	{
		if (!fGlyphRun)
		{
			if (IsZerowidthCharacter(*lpwchRun))
				xWidth = 0;
			else
			{
				pccs->Include(*lpwchRun, xWidth);
				xWidth =  max(xWidth + xAdjust, 1);
			}
		}
		else
		{
			xWidth = 0;
			if (!IsDiacriticOrKashida(*lpwchRun, 0))
				xWidth = pccs->_xAveCharWidth;
		}

		duCalc += xWidth;				// Keep running total of width
		*prgDu++ = xWidth;				// Store width in output array
		if(xWidth + duCalc > du)		// Width exceeds width available
		{
			i++;						// Count this char as processed
			break;
		}
	}
	*plimDu = i;						// Store total chars processed
	*pduRun = duCalc;					// Store output total width
	return lserrNone;
}

/*
 *	OlsGetRunTextMetrics (pols, plsrun, deviceID, kTFlow, plsTxMet)
 *
 *	@func
 *		Get run text metrics
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunTextMetrics(
	POLS	  pols,			//(IN): interface object
	PLSRUN	  plsrun,		//(IN): run (cp here)
	enum lsdevice deviceID, //(IN): presentation or reference
	LSTFLOW	  kTFlow,		//(IN): text direction and orientation
	PLSTXM	  plsTxMet)		//(OUT): Text metrics
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL fBullet = pols->SetRun(plsrun);

	// Make sure right font is set for run
	pme->SetUseTargetDevice(deviceID == lsdevReference);
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	LONG yFEAdjust = pccs->AdjustFEHeight(pme->fAdjustFELineHt());

	// Cache descent to save a few indirections
	LONG yDescent = pccs->_yDescent + yFEAdjust;

	// Fill in metric structure
	plsTxMet->dvAscent			= pccs->_yHeight + (yFEAdjust << 1) - yDescent;
    plsTxMet->dvDescent			= yDescent;
    plsTxMet->dvMultiLineHeight = plsTxMet->dvAscent + yDescent;
    plsTxMet->fMonospaced		= pccs->_fFixPitchFont;

	if (plsrun->_pCF->_yOffset)
	{
		LONG yOffset, yAdjust;
		pccs->GetOffset(plsrun->_pCF, deviceID == lsdevReference ? pme->GetDyrInch() :
					    pme->GetDypInch(), &yOffset, &yAdjust);

		if (yOffset < 0)
			plsTxMet->dvDescent -= yOffset;
		else
			plsTxMet->dvAscent += yOffset;
		
	}

	return lserrNone;
}

/*
 *	OlsGetRunUnderlineInfo (pols, plsrun, pcheights, kTFlow, plsStInfo)
 *
 *	@func
 *		Get run underline info
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunUnderlineInfo(
	POLS	  pols,			//(IN): Interface object
	PLSRUN	  plsrun,		//(IN): Run (cp here)
	PCHEIGHTS pcheights,	//(IN): Height of line
	LSTFLOW	  kTFlow,		//(IN): Text direction and orientation
	PLSULINFO plsUlInfo)	//(OUT): Underline information
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL	   fBullet = pols->SetRun(plsrun);

	// Initialize output buffer
	ZeroMemory(plsUlInfo, sizeof(*plsUlInfo));
	//REVIEW KeithCu

	// Make sure right font is set for run
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	long dvpUlOffset = pccs->_dyULOffset;

	plsUlInfo->cNumberOfLines = 1;

	// Set underline type
	if (plsrun->_pCF->_dwEffects & CFE_LINK)
		plsUlInfo->kulbase = CFU_UNDERLINE;
	else if (plsrun->_pCF->_dwEffects & (CFE_UNDERLINE | CFE_REVISED))
		plsUlInfo->kulbase	= plsrun->_pCF->_bUnderlineType;
	else
	{
		Assert(pme->GetPed()->GetCpAccelerator() == plsrun->_cp);
		plsUlInfo->kulbase = CFU_UNDERLINE;
	}

	LONG yDescent = pccs->_yDescent + pccs->AdjustFEHeight(pme->fAdjustFELineHt());

	// Some fonts report invalid offset so we fix it up here
	//BUGBUG: subscripts with Line Services don't display.
	if(dvpUlOffset >= yDescent)
		dvpUlOffset = yDescent - 1;

	plsUlInfo->dvpFirstUnderlineOffset = dvpUlOffset;
	plsUlInfo->dvpFirstUnderlineSize   = pccs->_dyULWidth;

	return lserrNone;
}

/*
 *	OlsGetRunStrikethroughInfo (pols, plsrun, pcheights, kTFlow, plsStInfo)
 *
 *	@func
 *		Get run strikethrough info
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunStrikethroughInfo(
	POLS	  pols,			//(IN): interface object
	PLSRUN	  plsrun,		//(IN): run
	PCHEIGHTS pcheights,	//(IN): height of line
	LSTFLOW	  kTFlow,		//(IN): text direction and orientation
	PLSSTINFO plsStInfo)	//(OUT): Strikethrough information
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL fBullet = pols->SetRun(plsrun);

	AssertSz(plsrun->_pCF->_dwEffects & CFE_STRIKEOUT, "no strikeout");

	// Make sure right font is set for run
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	// Default number of lines
	plsStInfo->cNumberOfLines = 1;
	plsStInfo->dvpLowerStrikethroughOffset = -pccs->_dySOOffset;
	plsStInfo->dvpLowerStrikethroughSize   = pccs->_dySOWidth;

	return lserrNone;
}


/*	OlsDrawUnderline (pols, plsrun, kUlbase, pptStart, dupUL, dvpUL,
 *					  kTFlow, kDisp, prcClip)
 *	@func
 *		Draw underline
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsDrawUnderline(
	POLS		pols,		//(IN): interface object
	PLSRUN		plsrun,		//(IN): run (cp) to use for underlining
	UINT		kUlbase,	//(IN): underline kind
	const POINT *pptStart,	//(IN): starting position (top left)
	DWORD		dupUL,		//(IN): underline width
	DWORD		dvpUL,		//(IN): underline thickness
	LSTFLOW		lstflow,	//(IN): text direction and orientation
	UINT		kDisp,		//(IN): display mode - opaque, transparent
	const RECT *prcClip)	//(IN): clipping rectangle
{
	CRenderer *pre = pols->GetRenderer();
	Assert(pre->IsRenderer());

	pols->SetRun(plsrun);
	pre->Check_pccs();

	pre->SetSelected(plsrun->IsSelected());
	pre->SetFontAndColor(plsrun->_pCF);

	pre->SetupUnderline(kUlbase);
	pre->RenderUnderline(lstflow == lstflowWS ? pptStart->x - dupUL - 1:
						 pptStart->x, pptStart->y, dupUL, dvpUL);

	return lserrNone;
}

/*
 *	OlsDrawStrikethrough (pols, plsrun, kStbase, pptStart, dupSt, dvpSt,
 *						  kTFlow, kDisp, prcClip)
 *	@func
 *		Draw strikethrough
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsDrawStrikethrough(
	POLS		pols,		//(IN): Interface object
	PLSRUN		plsrun,		//(IN): run (cp) for strikethrough
	UINT		kStbase,	//(IN): strikethrough kind
	const POINT *pptStart,	//(IN): starting position (top left)
	DWORD		dupSt,		//(IN): strikethrough width
	DWORD		dvpSt,		//(IN): strikethrough thickness
	LSTFLOW		lstflow,	//(IN): text direction and orientation
	UINT		kDisp,		//(IN): display mode - opaque, transparent
	const RECT *prcClip)	//(IN): clipping rectangle
{
	CRenderer *pre = pols->GetRenderer();
	Assert(pre->IsRenderer());

	pols->SetRun(plsrun);
	pre->SetSelected(plsrun->IsSelected());

	pre->RenderStrikeOut(lstflow == lstflowWS ? pptStart->x - dupSt - 1:
						 pptStart->x, pptStart->y, dupSt, dvpSt);

	return lserrNone;
}


/*
 *	OlsFInterruptUnderline(pols, plsrunFirst, cpLastFirst, plsrunSecond,
 *						   cpStartSecond, pfInterruptUnderline)
 *	@func
 *		Says whether client wants to interrupt drawing of underline
 *		between the first and second runs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFInterruptUnderline(
	POLS   pols,				//(IN): Client context
	PLSRUN plsrunFirst,			//(IN): Run pointer for previous run
	LSCP   cpLastFirst,			//(IN): cp of last character of previous run
	PLSRUN plsrunSecond,		//(IN): Run pointer for current run
	LSCP   cpStartSecond,		//(IN): cp of first character of current run
	BOOL * pfInterruptUnderline)//(OUT): Interrupt underline between runs?
{
	CRenderer *pre = pols->GetRenderer();
	Assert(pre->IsRenderer());

	pre->SetSelected(FALSE); //Selection is handled below

	COLORREF cr = pre->GetTextColor(plsrunFirst->_pCF);

	// Interrupt underline if run text colors differ
	*pfInterruptUnderline = cr != pre->GetTextColor(plsrunSecond->_pCF) ||
							plsrunFirst->IsSelected() != plsrunSecond->IsSelected();
	return lserrNone;
}

/*
 *	OlsDrawTextRun (pols, plsrun, kStbase, pptStart, dupSt, dvpSt,
 *						  kTFlow, kDisp, prcClip)
 *	@func
 *		Draw text run
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsDrawTextRun(
	POLS		pols,			//(IN): Interface object
	PLSRUN		plsrun,			//(IN): Run (cp) to use for text
	BOOL		fStrikeoutOkay, //(IN): TRUE <==> allow strikeout
	BOOL		fUnderlineOkay, //(IN): TRUE <==> allow underlining
	const POINT *ppt, 			//(IN): Starting position
	LPCWSTR		pwchRun, 		//(IN): Run of characters
	const int *	rgDupRun, 		//(IN): Character widths
	DWORD		cwchRun, 		//(IN): Count of chars in run
	LSTFLOW		lstflow,		//(IN): Text direction and orientation
	UINT		kDisp,			//(IN): Display mode - opaque, transparent
	const POINT *pptRun,		//(IN): Starting point of run
	PCHEIGHTS	pheightsPres, 	//(IN): Presentation heights for run
	long		dupRun, 		//(IN): Presentation width for run
	long		dupUlLimRun,	//(IN): Underlining limit
	const RECT *prcClip)		//(IN): Clipping rectangle
{
	CRenderer  *pre = pols->GetRenderer();
	RECT		rc = *prcClip;
	Assert(pre->IsRenderer());

	// Set up drawing point and options
	BOOL fBullet = pols->SetRun(plsrun);
	CCcs *pccs = pre->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	// y needs to be moved from baseline to top of character
	POINT pt = {ppt->x, ppt->y - (pccs->_yHeight - pccs->_yDescent)};

	if (lstflow == lstflowWS)
		pt.x -= dupRun - 1;

	pre->SetSelected(plsrun->IsSelected());
	pre->SetFontAndColor(plsrun->_pCF);

	if(!fBullet && pre->fBackgroundColor())
	{
		kDisp = ETO_OPAQUE | ETO_CLIPPED;

		POINT ptCur = pre->GetCurPoint();
		ptCur.x = pt.x;
		pre->SetCurPoint(ptCur);
		pre->SetClipLeftRight(dupRun);
		rc = pre->GetClipRect();
	}
	else if (cwchRun == 1 && pwchRun[0] == ' ') //Don't waste time drawing a space.
		return lserrNone;						//(helps grid perf test a lot)

	pre->RenderExtTextOut(pt.x, pt.y, kDisp, &rc, pwchRun, cwchRun, rgDupRun);

	return lserrNone;
}

/*
 *	GetBreakingClasses (pols, plsrun, ch, pbrkclsBefore, pbrkclsAfter)
 *
 *	@func
 *		Line services calls this callback for each run, to obtain the
 *		breaking classes (line breaking behaviors) for each character
 *
 *	    For Quill and RichEdit, the breaking class of a character is
 *		independent of whether it occurs Before or After a break opportunity.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetBreakingClasses(
	POLS	pols,			//(IN): Interface object
	PLSRUN	plsrun,			//(IN): Run (cp) to use for text
	LSCP	cpLs,				//(IN): cp of the character
	WCHAR	ch, 			//(IN): Char to return breaking classes for
	BRKCLS *pbrkclsBefore,	//(OUT): Breaking class if ch is lead char in pair
	BRKCLS *pbrkclsAfter)	//(OUT): Breaking class if ch is trail char in pair
{
	long 		cpRe = pols->GetCpReFromCpLs(cpLs);
	CMeasurer 	*pme = pols->GetMeasurer();
	CTxtBreaker *pbrk = pme->GetPed()->_pbrk;

	// Get line breaking class and report it twice
	*pbrkclsBefore = *pbrkclsAfter = (pbrk && pbrk->CanBreakCp(BRK_WORD, cpRe)) ?
									brkclsOpen :
									GetKinsokuClass(ch);
	return lserrNone;
}

/*
 *	OlsFTruncateBefore (pols, cpCur, wchCur, durCur, cpPrev, wchPrev,
 *						durPrev, durCut, pfTruncateBefore)
 *	@func
 *		Line services support function. This should always return
 *		FALSE for best performance
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFTruncateBefore(
	POLS	pols,				// (IN): Client context
	PLSRUN  plsrunCur,			// (IN): PLSRUN of cp
	LSCP	cpCur,				// (IN): cp of truncation char
	WCHAR	wchCur,				// (IN): Truncation character
	long	durCur,				// (IN): Width of truncation char
	PLSRUN	plsrunPrev,			// (IN): PLSRUN of cpPrev
	LSCP	cpPrev,				// (IN): cp of truncation char
	WCHAR	wchPrev,			// (IN): Truncation character
	long	durPrev,			// (IN): Width of truncation character
	long	durCut,				// (IN): Width from RM until end of current char
	BOOL *	pfTruncateBefore)	// (OUT): Truncation point is before this char
{
	*pfTruncateBefore = FALSE;
	return lserrNone;
}

/*
 *	OlsCanBreakBeforeChar (pols, brkcls, pcond)
 *
 *	@func
 *		Line services calls this callback for a break candidate following an
 *		inline object, to determine whether breaks are prevented, possible or
 *		mandatory
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCanBreakBeforeChar(
	POLS	pols,		//(IN): Client context
	BRKCLS	brkcls,		//(IN): Breaking class
	BRKCOND *pcond) 	//(OUT): Corresponding break condition
{
	switch (brkcls)
	{
	default:
		*pcond = brkcondCan;
		break;

	case brkclsClose:
	case brkclsNoStartIdeo:
	case brkclsExclaInterr:
	case brkclsGlueA:
		*pcond = brkcondNever;
		break;

	case brkclsIdeographic:
	case brkclsSpaceN:
	case brkclsSlash:
		*pcond = brkcondPlease;	
		break;
	};
	return lserrNone;
}

/*
 *	OlsCanBreakAfterChar (pols, brkcls, pcond)
 *
 *	@func
 *		Line services calls this callback for a break candidate preceding an
 *		inline object, to determine whether breaks are prevented, possible or
 *		mandatory
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCanBreakAfterChar(
	POLS	pols,		//(IN): Client context
	BRKCLS	brkcls,		//(IN): Breaking class
	BRKCOND *pcond) 	//(OUT): Corresponding break condition
{
	switch (brkcls)
	{
	default:
		*pcond = brkcondCan;
		break;

	case brkclsOpen:
	case brkclsGlueA:
		*pcond = brkcondNever;
		break;

	case brkclsIdeographic:
	case brkclsSpaceN:
	case brkclsSlash:
		*pcond = brkcondPlease;	
		break;
	};
	return lserrNone;
}

/*
 *	OlsFInterruptShaping (pols, kTFlow, plsrunFirst, plsrunSecond, pfInterruptShaping)
 *
 *	@func
 *		Line services calls this callback to find out if you
 *		would like to ligate across these two runs.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFInterruptShaping(
	POLS	pols,					//(IN): Client context
	LSTFLOW	kTFlow,					//(IN): Text direction and orientation
	PLSRUN	plsrunFirst,			//(IN): Run #1
	PLSRUN	plsrunSecond,			//(IN): Run #2
	BOOL	*pfInterruptShaping)	//(OUT): Shape across these 2 runs?
{
	*pfInterruptShaping = FALSE;

	const CCharFormat* pCFFirst = plsrunFirst->_pCF;
	const CCharFormat* pCFSecond = plsrunSecond->_pCF;

	Assert (plsrunFirst->_a.eScript && plsrunSecond->_a.eScript);

	const DWORD dwMask = CFE_BOLD | CFE_ITALIC | CFM_SUBSCRIPT;

	if (pCFFirst == pCFSecond ||
		(plsrunFirst->_a.eScript == plsrunSecond->_a.eScript &&
		!((pCFFirst->_dwEffects ^ pCFSecond->_dwEffects) & dwMask) &&
		pCFFirst->_iFont == pCFSecond->_iFont &&
		pCFFirst->_yOffset == pCFSecond->_yOffset &&
		pCFFirst->_yHeight == pCFSecond->_yHeight))
	{
		// establish link
		plsrunFirst->_pNext = plsrunSecond;
		return lserrNone;
	}

	*pfInterruptShaping = TRUE;
	return lserrNone;
}


// LS calls this callback to shape the codepoint string to a glyph indices string
// for handling glyph based script such as Arabic, Hebrew and Thai.
//
LSERR OlsGetGlyphs(
	POLS 		pols,
	PLSRUN	 	plsrun,
	LPCWSTR		pwch,
	DWORD		cch,
	LSTFLOW		kTFlow,
	PGMAP		pgmap,				// OUT: array of logical cluster information
	PGINDEX*	ppgi, 				// OUT: array of output glyph indices
	PGPROP*		ppgprop, 			// OUT: array of glyph's properties
	DWORD*		pcgi)				// OUT: number of glyph generated
{
	pols->SetRun(plsrun);

	CMeasurer*		pme = pols->GetMeasurer();
	CUniscribe* 	pusp = pme->Getusp();
	Assert (pusp);

	WORD*			pwgi;
	SCRIPT_VISATTR *psva;
	int				cgi;

	pme->SetGlyphing(TRUE);

	// Glyphing doesn't care about the target device but always
	// using target device reduces creation of Cccs in general.
	pme->SetUseTargetDevice(TRUE);

	AssertSz(IN_RANGE(1, plsrun->_a.eScript, SCRIPT_MAX_COUNT - 1), "Bad script ID!");

	// Digit substitution
	pusp->SubstituteDigitShaper(plsrun, pme);

	if (!(cgi = (DWORD)pusp->ShapeString(plsrun, &plsrun->_a, pme, pwch, (int)cch, pwgi, pgmap, psva)))
	{
		const SCRIPT_ANALYSIS	saUndef = {SCRIPT_UNDEFINED,0,0,0,0,0,0,{0}};

		// Current font cant shape given string.
		// Try SCRIPT_UNDEF so it generates invalid glyphs
		if (!(cgi = (DWORD)pusp->ShapeString(plsrun, (SCRIPT_ANALYSIS*)&saUndef, pme, pwch, (int)cch, pwgi, pgmap, psva)))
		{
			// For whatever reason we still fails.
			// Abandon glyph processing.
			plsrun->_a.fNoGlyphIndex = TRUE;
			cgi = (DWORD)pusp->ShapeString(plsrun, &plsrun->_a, pme, pwch, (int)cch, pwgi, pgmap, psva);
		}
	}

	*pcgi = cgi;

	DupShapeState(plsrun, cch);

	*ppgi = (PGINDEX)pwgi;
	*ppgprop = (PGPROP)psva;
	pme->SetGlyphing(FALSE);
	return lserrNone;
}

// LS calls this callback to find out glyph positioning for complex scripts
//
LSERR OlsGetGlyphPositions(
	POLS		pols,
	PLSRUN		plsrun,
	LSDEVICE	deviceID,
	LPWSTR		pwch,
	PCGMAP		pgmap,
	DWORD		cch,
	PCGINDEX	pgi,
	PCGPROP		pgprop,
	DWORD		cgi,
	LSTFLOW		kTFlow,
	int*		pgdx,				// OUT: array of glyph advanced width
	PGOFFSET	pgduv)				// OUT: array of offset between glyphs
{
	pols->SetRun(plsrun);

	CMeasurer*		pme = pols->GetMeasurer();
	CUniscribe* 	pusp = pme->Getusp();
	Assert (pusp);
	Assert(pgduv);
	pme->SetGlyphing(TRUE);

	// zero out before passing to shaping engine
	ZeroMemory ((void*)pgduv, cgi*sizeof(GOFFSET));

	pme->SetUseTargetDevice(deviceID == lsdevReference);

	AssertSz(IN_RANGE(1, plsrun->_a.eScript, SCRIPT_MAX_COUNT - 1), "Bad script ID!");

	if (!pusp->PlaceString(plsrun, &plsrun->_a, pme, pgi, cgi, (const SCRIPT_VISATTR*)pgprop, pgdx, pgduv, NULL))
	{
		SCRIPT_ANALYSIS	saUndef = {SCRIPT_UNDEFINED,0,0,0,0,0,0,{0}};

		if (!pusp->PlaceString(plsrun, &saUndef, pme, pgi, cgi, (const SCRIPT_VISATTR*)pgprop, pgdx, pgduv, NULL))
		{
			plsrun->_a.fNoGlyphIndex = TRUE;
			pusp->PlaceString(plsrun, &plsrun->_a, pme, pgi, cgi, (const SCRIPT_VISATTR*)pgprop, pgdx, pgduv, NULL);
		}
	}

	DupShapeState(plsrun, cch);

	pme->SetGlyphing(FALSE);
	return lserrNone;
}

LSERR OlsDrawGlyphs(
	POLS			pols,
	PLSRUN			plsrun,
	BOOL			fStrikeOut,
	BOOL			fUnderline,
	PCGINDEX		pcgi,
	const int*		pgdx,			// array of glyph width
	const int*		pgdxo,			// array of original glyph width (before justification)
	PGOFFSET		pgduv,			// array of glyph offset
	PGPROP			pgprop,			// array of glyph's properties
	PCEXPTYPE		pgxtype,		// array of expansion type
	DWORD			cgi,
	LSTFLOW			kTFlow,
	UINT			kDisp,
	const POINT*	pptRun,
	PCHEIGHTS		pHeight,
	long			dupRun,
	long			dupLimUnderline,
	const RECT*		prectClip)
{
	BOOL			fBullet = pols->SetRun(plsrun);
	CRenderer*		pre = pols->GetRenderer();
	CUniscribe* 	pusp = pre->Getusp();
	Assert(pusp && pre->IsRenderer());
	pre->SetGlyphing(TRUE);

	RECT			rc = *prectClip;
	CCcs* 			pccs = pre->Check_pccs(fBullet);

	if (!pccs)
		return lserrOutOfMemory;

	// Apply fallback font if we need to
	if (!fBullet)
		pccs = pre->ApplyFontCache(plsrun->IsFallback());

	pre->SetSelected(plsrun->IsSelected());
	pre->SetFontAndColor(plsrun->_pCF);

	// y needs to be moved from baseline to top of character
	POINT 			pt = {pptRun->x, pptRun->y - (pccs->_yHeight - pccs->_yDescent)};

	if (kTFlow == lstflowWS)
		pt.x -= dupRun - 1;	
	
	if(!fBullet && pre->fBackgroundColor())
	{
		kDisp = ETO_OPAQUE | ETO_CLIPPED;

		POINT ptCur = pre->GetCurPoint();
		ptCur.x = pt.x;
		pre->SetCurPoint(ptCur);
		pre->SetClipLeftRight(dupRun);
		rc = pre->GetClipRect();
	}

	if (rc.left == rc.right)
		goto Exit;

	if (pre->GetPdp()->IsMetafile() && !IsEnhancedMetafileDC(pre->GetDC()))
	{
		// -WMF metafile handling-
		//
		//     If the rendering device is WMF metafile. We metafile the codepoint array
		// instead of glyph indices. This requires that the target OS must know how to
		// playback complex script text (shaping, Bidi algorithm, etc.).
		//     Metafiling glyph indices only works for EMF since the WMF's META_EXTTEXTOUT
		// record stores the input string as an array of byte but a glyph index is 16-bit
		// word element.
		//     WMF also must NOT be used to record ExtTextOutW call otherwise the Unicode
		// string will be converted to mutlibyte text using system codepage. Anything
		// outside the codepage then becomes '?'.
		//     We have the workaround for such case in REExtTextOut to make sure we only
		// metafile ExtTextOutA to WMF. (wchao)
		//
	
		LONG			cch;
		const WCHAR*	pwch = pre->GetPch(cch);
		PINT			piDx;
	
		cch = min(cch, pre->GetCchLeftRunCF());
		cch = min(cch, pre->GetLine()._cch - plsrun->_cp + pols->_cp);

		// make sure that we record ETO with proper reading order.
		kDisp |= plsrun->_a.fRTL ? ETO_RTLREADING : 0;

		if (pusp->PlaceMetafileString(plsrun, pre, pwch, (int)cch, &piDx))
		{
			pre->RenderExtTextOut(pt.x, pt.y, kDisp, &rc, pwch, cch, piDx);
			goto Exit;
		}

		TRACEERRORSZ("Recording metafile failed!");

		// Fall through... with unexpected error

		// Else, metafile glyph indices for EMF...
	}

	//This is duplicated from RenderExtTextOut but the params are different so simplest solution
	//was to copy code.
	if(pre->_fDisabled)
	{
		if(pre->_crForeDisabled != pre->_crShadowDisabled)
		{
			// The shadow should be offset by a hairline point, namely
			// 3/4 of a point.  Calculate how big this is in device units,
			// but make sure it is at least 1 pixel.
			DWORD offset = MulDiv(3, pre->_dypInch, 4*72);
			offset = max(offset, 1);

			// Draw shadow
			pre->SetTextColor(pre->_crShadowDisabled);
					
			ScriptTextOut(pre->GetDC(), &pccs->_sc, pt.x + offset, pt.y + offset, kDisp, &rc, &plsrun->_a,
				NULL, 0, pcgi, (int)cgi, pgdx, NULL, pgduv);

			// Now set drawing mode to transparent
			kDisp &= ~ETO_OPAQUE;
		}
		pre->SetTextColor(pre->_crForeDisabled);
	}

	ScriptTextOut(pre->GetDC(), &pccs->_sc, pt.x, pt.y, kDisp, &rc, &plsrun->_a,
				NULL, 0, pcgi, (int)cgi, pgdx, NULL, pgduv);

Exit:
	if (!fBullet)
		pre->ApplyFontCache(0);		// reset font fallback if any

	pre->SetGlyphing(FALSE);
	return lserrNone;
}


/*
 *	OlsResetRunContents (pols, brkcls, pcond)
 *
 *	@func
 *		Line Services calls this routine when a ligature
 *		extends across run boundaries.
 *
 *		We don't have to do anything special here if we are
 *		careful about how we use our PLSRUNs.
 *	@rdesc
 *		LSERR
 */
 LSERR WINAPI OlsResetRunContents(
 	POLS 	pols,		//(IN): Client context
 	PLSRUN 	plsrun,		//(IN): Run being combined
 	LSCP 	cpFirstOld, //(IN): cp of the first run being combined
 	LSDCP 	dcpOld,		//(IN):	dcp of the first run being combined
 	LSCP 	cpFirstNew, //(IN): new cp of the run
 	LSDCP 	dcpNew)		//(IN): new dcp of the run
{
	return lserrNone;
}

/*
 *	OlsCheckForDigit (pols, cp, plspap)
 *
 *	@func
 *		Get numeric separators needed, e.g., for decimal tabs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCheckForDigit(
	POLS	pols,		//(IN): pols
	PLSRUN	plsrun,		//(IN): Run (cp here)
	WCHAR	wch,		//(IN): Character to check
	BOOL *	pfIsDigit)	//(OUT): This character is digit
{
	WORD	wType;

	// We could get the run LCID to use for the first parm in the following
	// call, but the digit property should be independent of LCID.
	W32->GetStringTypeEx(0, CT_CTYPE1, &wch, 1, &wType);
	*pfIsDigit = (wType & C1_DIGIT) != 0;

	return lserrNone;
}

/*
 *	OlsGetBreakThroughTab(pols, uaRightMargin, uaTabPos, puaRightMarginNew)
 *
 *	@func
 *		Just follow word95 behavior.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetBreakThroughTab(
	POLS	pols,				//(IN): client context
	long	uaRightMargin,		//(IN): right margin for breaking
	long	uaTabPos,			//(IN): breakthrough tab position
	long *	puaRightMarginNew)	//(OUT): new right margin
{
	*puaRightMarginNew = 20 * 1440;
	return lserrNone;
}

/*
 *	OlsFGetLastLineJustification(pols, lskj, endr, pfJustifyLastLine)
 *
 *	@func
 *		Just say no to justify last line.	
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFGetLastLineJustification(
	POLS	pols,				//(IN): client context
	LSKJUST lskj,				//(IN): kind of justification
	LSKALIGN lskal,				//(IN): kind of alignment
	ENDRES	endr,				//(IN): result of formatting
	BOOL	*pfJustifyLastLine,	//(OUT): should last line be fully justified
	LSKALIGN *plskalLine)		//(OUT): kind of alignment for this line
{
	*pfJustifyLastLine = FALSE;
	*plskalLine = lskal;
	return lserrNone;
}

/*
 *	OlsGetHyphenInfo(pols, plsrun, pkysr, pwchYsr)
 *
 *	@func
 *		We don't support fancy YSR types, tell LS so.	
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetHyphenInfo(
	POLS	pols,				//(IN): client context
	PLSRUN	plsrun,				//(IN)
	DWORD*	pkysr,				//(OUT): Ysr type - see "lskysr.h"
	WCHAR*	pwchYsr)			//(OUT): Character code of YSR
{
	*pkysr = kysrNil;
	*pwchYsr = 0;	
	return lserrNone;
}

/*
 *	OlsReleaseRun (pols, plsrun)
 *
 *	@func
 *		We do nothing because the run is in an array and is
 *		released automatically.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsReleaseRun(
	POLS	pols,	//(IN): interface object
	PLSRUN	plsrun)	//(IN): run (cp) to use for underlining
{
	return lserrNone;
}

/*
 * 	OlsNewPtr(pols, cBytes)
 *
 *	@func
 *		Memory allocator.
 */
void* WINAPI OlsNewPtr(
	POLS	pols,		//@parm Not used
	DWORD	cBytes)		//@parm Count of bytes to alloc
{
	return PvAlloc(cBytes, 0);
}

/*
 * 	OlsDisposePtr(pols, pv)
 *
 *	@func
 *		Memory deallocator.
 */
void WINAPI OlsDisposePtr(
	POLS	pols,		//@parm Not used
	void *	pv)			//@parm [in]: ptr to free
{
	FreePv(pv);
}

/*
 * 	OlsDisposePtr(pols, pv, cBytes)
 *
 *	@func
 *		Memory reallocator.
 */
void* WINAPI OlsReallocPtr(
	POLS	pols,		//@parm Not used
	void *	pv, 		//@parm [in/out]: ptr to realloc
	DWORD	cBytes)		//@parm Count of bytes to realloc
{
	return PvReAlloc(pv, cBytes);
}
const REVERSEINIT reverseinit =
{
	REVERSE_VERSION,
	wchObjectEnd
};

LSERR WINAPI OlsGetObjectHandlerInfo(POLS pols, DWORD idObj, void* pObjectInfo)
{
	switch (idObj)
	{
	case OBJID_REVERSE:
		memcpy(pObjectInfo, (void *)&reverseinit, sizeof(REVERSEINIT));
		break;
	default:
		AssertSz(0, "Undefined Object handler. Add missing case.");
	}
	return lserrNone;
}

#ifdef DEBUG
/* Debugging APIs */
void WINAPI OlsAssertFailed(
	char *sz,
	char *szFile,
	int	  iLine)
{
	AssertSzFn(sz, szFile, iLine);
}
#endif


extern const LSCBK lscbk =
{
	OlsNewPtr,					// pfnNewPtr
	OlsDisposePtr,				// pfnDisposePtr
	OlsReallocPtr,				// pfnReallocPtr
	OlsFetchRun,				// pfnFetchRun
	OlsGetAutoNumberInfo,		// pfnGetAutoNumberInfo
	OlsGetNumericSeparators,	// pfnGetNumericSeparators
	OlsCheckForDigit,			// pfnCheckForDigit
	OlsFetchPap,				// pfnFetchPap
	OlsFetchTabs,				// pfnFetchTabs
	OlsGetBreakThroughTab,		// pfnGetBreakThroughTab
	OlsFGetLastLineJustification,// pfnFGetLastLineJustification
	OlsCheckParaBoundaries,		// pfnCheckParaBoundaries
	OlsGetRunCharWidths,		// pfnGetRunCharWidths
	0,							// pfnCheckRunKernability
	0,							// pfnGetRunCharKerning
	OlsGetRunTextMetrics,		// pfnGetRunTextMetrics
	OlsGetRunUnderlineInfo,		// pfnGetRunUnderlineInfo
	OlsGetRunStrikethroughInfo,	// pfnGetRunStrikethroughInfo
	0,							// pfnGetBorderInfo
	OlsReleaseRun,				// pfnReleaseRun
	0,							// pfnHyphenate
	OlsGetHyphenInfo,			// pfnGetHyphenInfo
	OlsDrawUnderline,			// pfnDrawUnderline
	OlsDrawStrikethrough,		// pfnDrawStrikethrough
	0,							// pfnDrawBorder
	0,							// pfnDrawUnderlineAsText //REVIEW (keithcu) Need to implement this??
	OlsFInterruptUnderline,		// pfnFInterruptUnderline
	0,							// pfnFInterruptShade
	0,							// pfnFInterruptBorder
	0,							// pfnShadeRectangle
	OlsDrawTextRun,				// pfnDrawTextRun
	0,							// pfnDrawSplatLine
	OlsFInterruptShaping,		// pfnFInterruptShaping
	OlsGetGlyphs,				// pfnGetGlyphs
	OlsGetGlyphPositions,		// pfnGetGlyphPositions
	OlsResetRunContents,		// pfnResetRunContents
	OlsDrawGlyphs,				// pfnDrawGlyphs
	0,							// pfnGetGlyphExpansionInfo
	0,							// pfnGetGlyphExpansionInkInfo
	0,							// pfnGetEms
	0,							// pfnPunctStartLine
	0,							// pfnModWidthOnRun
	0,							// pfnModWidthSpace
	0,							// pfnCompOnRun
	0,							// pfnCompWidthSpace
	0,							// pfnExpOnRun
	0,							// pfnExpWidthSpace
	0,							// pfnGetModWidthClasses
	OlsGetBreakingClasses,		// pfnGetBreakingClasses
	OlsFTruncateBefore,			// pfnFTruncateBefore
	OlsCanBreakBeforeChar,		// pfnCanBreakBeforeChar
	OlsCanBreakAfterChar,		// pfnCanBreakAfterChar
	0,							// pfnFHangingPunct
	0,							// pfnGetSnapGrid
	0,							// pfnDrawEffects
	0,							// pfnFCancelHangingPunct
	0,							// pfnModifyCompAtLastChar
	0,							// pfnEnumText
	0,							// pfnEnumTab
	0,							// pfnEnumPen
	OlsGetObjectHandlerInfo,	// pfnGetObjectHandlerInfo
#ifdef DEBUG
	OlsAssertFailed				// pfnAssertFailed
#else
	0							// pfnAssertFailed
#endif
};

#endif // LINESERVICES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\range.cpp ===
/*
 *  @doc INTERNAL
 *
 *  @module RANGE.C - Implement the CTxtRange Class |
 *
 *      This module implements the internal CTxtRange methods.  See range2.c
 *      for the ITextRange methods
 *
 *  Authors: <nl>
 *      Original RichEdit code: David R. Fulmer <nl>
 *      Christian Fortini <nl>
 *      Murray Sargent <nl>
 *
 *  Revisions: <nl>
 *      AlexGo: update to runptr text ptr; floating ranges, multilevel undo
 *
 *  Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_range.h"
#include "_edit.h"
#include "_text.h"
#include "_rtext.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_disp.h"
#include "_uspi.h"
#include "_rtfconv.h"
#include "_txtbrk.h"
#include "_font.h"

#ifdef LINESERVICES
#include "_ols.h"
#endif

ASSERTDATA

TCHAR   szEmbedding[] = {WCH_EMBEDDING, 0};

// ===========================  Invariant stuff  ======================================================

#define DEBUG_CLASSNAME CTxtRange
#include "_invar.h"

#ifdef DEBUG
BOOL
CTxtRange::Invariant( void ) const
{
    LONG cpMin, cpMost;
    GetRange(cpMin, cpMost);

    Assert ( cpMin >= 0 );
    Assert ( cpMin <= cpMost );
    Assert ( cpMost <= GetTextLength() );
    Assert ( cpMin != cpMost || cpMost <= GetAdjustedTextLength());

    static LONG numTests = 0;
    numTests++;             // how many times we've been called.

    // make sure the selections are in range.

    return CRchTxtPtr::Invariant();
}
#endif

void CTxtRange::RangeValidateCp(LONG cp, LONG cch)
{
    LONG cchText = GetAdjustedTextLength();
    LONG cpOther = cp - cch;            // Calculate cpOther with entry cp

    _wFlags = FALSE;                    // This range isn't a selection
    _iFormat = -1;                      // Set up the default format, which
                                        //  doesn't get AddRefFormat'd
    ValidateCp(cpOther);                // Validate requested other end
    cp = GetCp();                       // Validated cp
    if(cp == cpOther && cp > cchText)   // IP cannot follow undeletable
        cp = cpOther = SetCp(cchText);  //  EOP at end of story

    _cch = cp - cpOther;                // Store valid length
}

CTxtRange::CTxtRange(CTxtEdit *ped, LONG cp, LONG cch) :
    CRchTxtPtr(ped, cp)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CTxtRange");

    RangeValidateCp(cp, cch);
    Update_iFormat(-1);                 // Choose _iFormat

    CNotifyMgr *pnm = ped->GetNotifyMgr();

    if(pnm)
        pnm->Add( (ITxNotify *)this );
}

CTxtRange::CTxtRange(CRchTxtPtr& rtp, LONG cch) :
    CRchTxtPtr(rtp)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CTxtRange");

    RangeValidateCp(GetCp(), cch);
    Update_iFormat(-1);                 // Choose _iFormat

    CNotifyMgr *pnm = GetPed()->GetNotifyMgr();

    if(pnm)
        pnm->Add( (ITxNotify *)this );
}

CTxtRange::CTxtRange(const CTxtRange &rg) :
    CRchTxtPtr((CRchTxtPtr)rg)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CTxtRange");

    _cch = rg._cch;
    _wFlags = FALSE;                // This range isn't a selection
    _iFormat = -1;                  // Set up the default format, which
                                    //  doesn't get AddRefFormat'd
    Set_iCF(rg._iFormat);

    CNotifyMgr *pnm = GetPed()->GetNotifyMgr();

    if(pnm)
        pnm->Add((ITxNotify *)this);
}

CTxtRange::~CTxtRange()
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::~CTxtRange");

    if(!IsZombie())
    {
        CNotifyMgr *pnm = GetPed()->GetNotifyMgr();
        if(pnm )
            pnm->Remove((ITxNotify *)this);
    }
    ReleaseFormats(_iFormat, -1);
}

CRchTxtPtr& CTxtRange::operator =(const CRchTxtPtr &rtp)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::operator =");

    _TEST_INVARIANT_ON(rtp)

    LONG cpSave = GetCp();          // Save entry _cp for CheckChange()

    CRchTxtPtr::operator =(rtp);
    CheckChange(cpSave);
    return *this;
}

CTxtRange& CTxtRange::operator =(const CTxtRange &rg)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::operator =");

    _TEST_INVARIANT_ON( rg );

    LONG cchSave = _cch;            // Save entry _cp, _cch for change check
    LONG cpSave  = GetCp();

    CRchTxtPtr::operator =(rg);
    _cch = rg._cch;                 // Can't use CheckChange(), since don't
                                    //  use _fExtend
    Update_iFormat(-1);
    _TEST_INVARIANT_

    if( _fSel && (cpSave != GetCp() || cchSave != _cch) )
        GetPed()->GetCallMgr()->SetSelectionChanged();

    return *this;
}

/*
 *  CTxtRange::OnPreReplaceRange (cp, cchDel, cchNew, cpFormatMin,
 *                                  cpFormatMax)
 *
 *  @mfunc
 *      called when the backing store changes
 *
 *  @devnote
 *      1) if this range is before the changes, do nothing
 *
 *      2) if the changes are before this range, simply
 *      add the delta change to GetCp()
 *
 *      3) if the changes overlap one end of the range, collapse
 *      that end to the edge of the modifications
 *
 *      4) if the changes are completely internal to the range,
 *      adjust _cch and/or GetCp() to reflect the new size.  Note
 *      that two overlapping insertion points will be viewed as
 *      a 'completely internal' change.
 *
 *      5) if the changes overlap *both* ends of the range, collapse
 *      the range to cp
 *
 *      Note that there is an ambiguous cp case; namely the changes
 *      occur *exactly* at a boundary.  In this case, the type of
 *      range matters.  If a range is normal, then the changes
 *      are assumed to fall within the range.  If the range is
 *      is protected (either in reality or via DragDrop), then
 *      the changes are assumed to be *outside* of the range.
 */
void CTxtRange::OnPreReplaceRange (
    LONG cp,                    //@parm cp at start of change
    LONG cchDel,                //@parm Count of chars deleted
    LONG cchNew,                //@parm Count of chars inserted
    LONG cpFormatMin,           //@parm the min cp of a format change
    LONG cpFormatMax)           //@parm the max cp of a format change
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::OnPreReplaceRange");

    if(CONVERT_TO_PLAIN == cp)
    {
        // We need to dump our formatting because it is gone
        _rpCF.SetToNull();
        _rpPF.SetToNull();

        if(_fSel)
            GetPed()->_fUpdateSelection = TRUE;

        Update_iFormat(-1);
        return;
    }
}

/*
 *  CTxtRange::OnPostReplaceRange (cp, cchDel, cchNew, cpFormatMin,
 *                                  cpFormatMax)
 *
 *  @mfunc
 *      called when the backing store changes
 *
 *  @devnote
 *      1) if this range is before the changes, do nothing
 *
 *      2) if the changes are before this range, simply
 *      add the delta change to GetCp()
 *
 *      3) if the changes overlap one end of the range, collapse
 *      that end to the edge of the modifications
 *
 *      4) if the changes are completely internal to the range,
 *      adjust _cch and/or GetCp() to reflect the new size.  Note
 *      that two overlapping insertion points will be viewed as
 *      a 'completely internal' change.
 *
 *      5) if the changes overlap *both* ends of the range, collapse
 *      the range to cp
 *
 *      Note that there is an ambiguous cp case; namely the changes
 *      occur *exactly* at a boundary.  In this case, the type of
 *      range matters.  If a range is normal, then the changes
 *      are assumed to fall within the range.  If the range is
 *      is protected (either in reality or via DragDrop), then
 *      the changes are assumed to be *outside* of the range.
 */
void CTxtRange::OnPostReplaceRange (
    LONG cp,                    //@parm cp at start of change
    LONG cchDel,                //@parm Count of chars deleted
    LONG cchNew,                //@parm Count of chars inserted
    LONG cpFormatMin,           //@parm Min cp of format change
    LONG cpFormatMax)           //@parm Max cp of format change
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::OnPostReplaceRange");

    // NB!! We can't do invariant testing here, because we could
    // be severely out of date!

    LONG cchtemp;
    LONG cpMin, cpMost;
    LONG cchAdjTextLen;
    LONG delta = cchNew - cchDel;

    Assert (CONVERT_TO_PLAIN != cp);
    GetRange(cpMin, cpMost);

    // This range is before the changes. Note: an insertion pt at cp
    // shouldn't be changed
    if( cp >= cpMost )
    {
        // Double check to see if we need to fix up our format
        // run pointers.  If so, all we need to do is rebind
        // our inherited rich text pointer

        if(cpFormatMin <= cpMost || cpFormatMin == CP_INFINITE)
            InitRunPtrs();

        else
        {
            // It's possible that the format runs changed anyway,
            // e.g., they became allocated, deallocated, or otherwise
            // changed.  Normally, BindToCp takes care of this
            // situation, but we don't want to pay that cost all
            // the time.
            //
            // Note that starting up the rich text subsystem will
            // generate a notification with cpFormatMin == CP_INFINITE
            //
            // So here, call CheckFormatRuns.  This makes sure that
            // the runs are in sync with what CTxtStory has
            // (doing an InitRunPtrs() _only_ if absolutely necessary).
            CheckFormatRuns();
        }
        return;
    }


    // Anywhere in the following that we want to increment the current cp by a
    // delta, we are counting on the following invariant.
    Assert(GetCp() >= 0);

    // Changes are entirely before this range.  Specifically,
    // that's determined by looking at the incoming cp *plus* the number
    // of characters deleted
    if(cp + cchDel < cpMin || _fDragProtection && cp + cchDel <= cpMin)
    {
        cchtemp = _cch;
        BindToCp(GetCp() + delta);
        _cch = cchtemp;
    }
    // The changes are internal to the range or start within the
    // range and go beyond.
    else if( cp >= cpMin && cp <= cpMost )
    {
        // Nobody should be modifying a drag-protected range.  Unfortunately,
        // Ren re-enters us with a SetText call during drag drop, so we need
        // to handle this case 'gracefully'.
        if( _fDragProtection )
        {
            TRACEWARNSZ("REENTERED during a DRAG DROP!! Trying to recover!");
        }

        if( cp + cchDel <= cpMost )
        {
            // Changes are purely internal, so
            // be sure to preserve the active end.  Basically, if
            // GetCp() *is* cpMin, then we only need to update _cch.
            // Otherwise, GetCp() needs to be moved as well
            if( _cch >= 0 )
            {
                Assert(GetCp() == cpMost);
                cchtemp = _cch;
                BindToCp(GetCp() + delta);
                _cch = cchtemp + delta;
            }
            else
            {
                BindToCp(GetCp());
                _cch -= delta;
            }

            // Special case: the range is left with only the final EOP
            // selected. This means all the characters in the range were
            // deleted so we want to move the range back to an insertion
            // point at the end of the text.
            cchAdjTextLen = GetAdjustedTextLength();

            if(GetCpMin() >= cchAdjTextLen && !GetPed()->IsStreaming())
            {
                // Reduce the range to an insertion point
                _cch = 0;
                _fExtend = FALSE;

                // Set the cp to the end of the document.
                SetCp(cchAdjTextLen);
            }
        }
        else
        {
            // Changes extended beyond cpMost.  In this case,
            // we want to truncate cpMost to the *beginning* of
            // the changes (i.e. cp)

            if( _cch > 0 )
            {
                BindToCp(cp);
                _cch = cp - cpMin;
            }
            else
            {
                BindToCp(cpMin);
                _cch = cpMin - cp;
            }
        }
    }
    else if( cp + cchDel >= cpMost )
    {
        // Nobody should be modifying a drag-protected range.  Unfortunately,
        // Ren re-enters us with a SetText call during drag drop, so we need
        // to handle this case 'gracefully'.
        if( _fDragProtection )
        {
            TRACEWARNSZ("REENTERED during a DRAG DROP!! Trying to recover!");
        }

        // Entire range was deleted, so collapse to an insertion point at cp
        BindToCp(cp);
        _cch = 0;
    }
    else
    {
        // Nobody should be modifying a drag-protected range.  Unfortunately,
        // Ren re-enters us with a SetText call during drag drop, so we need
        // to handle this case 'gracefully'.
        if( _fDragProtection )
        {
            TRACEWARNSZ("REENTERED during a DRAG DROP!! Trying to recover!");
        }

        // The change crossed over just cpMin.  In this case move cpMin
        // forward to the unchanged part
        LONG cchdiff = (cp + cchDel) - cpMin;

        Assert( cp + cchDel < cpMost );
        Assert( cp + cchDel >= cpMin );
        Assert( cp < cpMin );

        cchtemp = _cch;
        if( _cch > 0 )
        {
            BindToCp(GetCp() + delta);
            _cch = cchtemp - cchdiff;
        }
        else
        {
            BindToCp(cp + cchNew);
            _cch = cchtemp + cchdiff;
        }
    }

    if( _fSel )
    {
        GetPed()->_fUpdateSelection = TRUE;
        GetPed()->GetCallMgr()->SetSelectionChanged();
    }

    Update_iFormat(-1);                 // Make sure _iFormat is up to date

    _TEST_INVARIANT_
}

/*
 *  CTxtRange::Zombie ()
 *
 *  @mfunc
 *      Turn this range into a zombie (_cp = _cch = 0, NULL ped, ptrs to
 *      backing store arrays.  CTxtRange methods like GetRange(),
 *      GetCpMost(), GetCpMin(), and GetTextLength() all work in zombie mode,
 *      returning zero values.
 */
void CTxtRange::Zombie()
{
    CRchTxtPtr::Zombie();
    _cch = 0;
}

/*
 *  CTxtRange::CheckChange(cpSave, cchSave)
 *
 *  @mfunc
 *      Set _cch according to _fExtend and set selection-changed flag if
 *      this range is a CTxtSelection and the new _cp or _cch differ from
 *      cp and cch, respectively.
 *
 *  @devnote
 *      We can count on GetCp() and cpSave both being <= GetTextLength(),
 *      but we can't leave GetCp() equal to GetTextLength() unless _cch ends
 *      up > 0.
 */
LONG CTxtRange::CheckChange(
    LONG cpSave)        //@parm Original _cp for this range
{
    LONG cchAdj = GetAdjustedTextLength();
    LONG cchSave = _cch;

    if(_fExtend)                                // Wants to be nondegenerate
    {                                           //  and maybe it is
        LONG cp = GetCp();

        _cch = cp - (cpSave - cchSave);
        CheckIfSelHasEOP(cpSave, cchSave);
    }
    else
    {
        _cch = 0;                               // Insertion point
        _fSelHasEOP = FALSE;                    // Selection doesn't contain
        _fSelHasCell = FALSE;                   //  any char, let alone a CR
    }                                           //  or table cell

    if(!_cch && GetCp() > cchAdj)               // If still IP and active end
        CRchTxtPtr::SetCp(cchAdj);              //  follows nondeletable EOP,
                                                //  backspace over that EOP
    LONG cch = GetCp() - cpSave;
    _fMoveBack = cch < 0;

    if(cch || cchSave != _cch)
    {
        Update_iFormat(-1);
        if(_fSel)
            GetPed()->GetCallMgr()->SetSelectionChanged();

        _TEST_INVARIANT_
    }

    return cch;
}

/*
 *  CTxtRange::CheckIfSelHasEOP(cpSave, cchSave)
 *
 *  @mfunc
 *      Maintains _fSelHasEOP = TRUE iff selection contains one or more EOPs.
 *      When cpSave = -1, calculates _fSelHasEOP unconditionally and cchSave
 *      is ignored (it's only used for conditional execution). Else _fSelHasEOP
 *      is only calculated for cases that may change it, i.e., it's assumed
 *      be up to date before the change.
 *
 *  @rdesc
 *      TRUE iff _fSel and _cch
 *
 *  @devnote
 *      Call after updating range _cch
 */
BOOL CTxtRange::CheckIfSelHasEOP(
    LONG cpSave,    //@parm Previous active end cp or -1
    LONG cchSave)   //@parm Previous signed length if cpSave != -1
{
    // _fSelHasEOP only maintained for the selection
    if(!_fSel)
        return FALSE;

    if(!_cch)
    {
        _fSelHasEOP  = FALSE;           // Selection doesn't contain
        _fSelHasCell = FALSE;           //  any char, let alone CR
        return FALSE;
    }

    LONG cpMin, cpMost;
    GetRange(cpMin, cpMost);

    if(cpSave != -1)                    // Selection may have changed
    {                                   // Set up to bypass text scan if
        LONG cpMinPrev, cpMostPrev;     //  selection grew and _fSelHasEOP
                                        //  is already TRUE or got smaller
        cpMinPrev = cpMostPrev = cpSave;//  and _fSelHasEOP is FALSE.

        if(cchSave > 0)                 // Calculate previous cpMin
            cpMinPrev  -= cchSave;      //  and cpMost
        else
            cpMostPrev -= cchSave;

        // Note: _fSelHasCell shouldn't change while in a table, since
        // Update() should always expand to a cell once _fSelHasCell has
        // been deteted.
        if (!_fSelHasEOP && cpMin >= cpMinPrev && cpMost <= cpMostPrev ||
             _fSelHasEOP && cpMin <= cpMinPrev && cpMost >= cpMostPrev)
        {
            return TRUE;                // _fSelHasEOP can't change
        }
    }

    LONG    FEOP_Results;
    CTxtPtr tp(_rpTX);                  // Scan range for an EOP

    tp.SetCp(cpMin);
    tp.FindEOP(cpMost - cpMin, &FEOP_Results);
    _fSelHasCell = (FEOP_Results & FEOP_CELL) != 0;
    _fSelHasEOP  = (FEOP_Results & FEOP_EOP)  != 0;
    return TRUE;
}

/*
 *  CTxtRange::GetRange(&cpMin, &cpMost)
 *
 *  @mfunc
 *      set cpMin  = this range cpMin
 *      set cpMost = this range cpMost
 *      return cpMost - cpMin, i.e. abs(_cch)
 *
 *  @rdesc
 *      abs(_cch)
 */
LONG CTxtRange::GetRange (
    LONG& cpMin,                //@parm Pass-by-ref cpMin
    LONG& cpMost) const         //@parm Pass-by-ref cpMost
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetRange");

    LONG cch = _cch;

    if(cch >= 0)
    {
        cpMost  = GetCp();
        cpMin   = cpMost - cch;
    }
    else
    {
        cch     = -cch;
        cpMin   = GetCp();
        cpMost  = cpMin + cch;
    }
    return cch;
}

/*
 *  CTxtRange::GetCpMin()
 *
 *  @mfunc
 *      return this range's cpMin
 *
 *  @rdesc
 *      cpMin
 *
 *  @devnote
 *      If you need cpMost and/or cpMost - cpMin, GetRange() is faster
 */
LONG CTxtRange::GetCpMin() const
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetCpMin");

    LONG cp = GetCp();
    return _cch <= 0 ? cp : cp - _cch;
}

/*
 *  CTxtRange::GetCpMost()
 *
 *  @mfunc
 *      return this range's cpMost
 *
 *  @rdesc
 *      cpMost
 *
 *  @devnote
 *      If you need cpMin and/or cpMost - cpMin, GetRange() is faster
 */
LONG CTxtRange::GetCpMost() const
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetCpMost");

    LONG cp = GetCp();
    return _cch >= 0 ? cp : cp - _cch;
}

/*
 *  CTxtRange::Update(fScrollIntoView)
 *
 *  @mfunc
 *      Virtual stub routine overruled by CTxtSelection::Update() when this
 *      text range is a text selection.  The purpose is to update the screen
 *      display of the caret or selection to correspond to changed cp's.
 *
 *  @rdesc
 *      TRUE
 */
BOOL CTxtRange::Update (
    BOOL fScrollIntoView)       //@parm TRUE if should scroll caret into view
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Update");

    return TRUE;                // Simple range has no selection colors or
}                               //  caret, so just return TRUE

/*
 * CTxtRange::SetCp(cp)
 *
 *  @mfunc
 *      Set active end of this range to cp. Leave other end where it is or
 *      collapse range depending on _fExtend (see CheckChange()).
 *
 *  @rdesc
 *      cp at new active end (may differ from cp, since cp may be invalid).
 */
LONG CTxtRange::SetCp(
    LONG cp)            //@parm new cp for active end of this range
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtRange::SetCp");

    LONG cpSave = GetCp();

    CRchTxtPtr::SetCp(cp);
    CheckChange(cpSave);                    // NB: this changes _cp if after
    return GetCp();                         //  final CR and _cch = 0
}

/*
 *  CTxtRange::Set (cp, cch)
 *
 *  @mfunc
 *      Set this range's active-end cp and signed cch
 */
BOOL CTxtRange::Set (
    LONG cp,                    //@parm Desired active end cp
    LONG cch)                   //@parm Desired signed count of chars
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Set");

    BOOL bRet    = FALSE;
    LONG cchSave = _cch;            // Save entry _cp, _cch for change check
    LONG cchText = GetAdjustedTextLength();
    LONG cpSave  = GetCp();
    LONG cpOther = cp - cch;        // Desired "other" end

    ValidateCp(cp);                         // Be absolutely sure to validate
    ValidateCp(cpOther);                    //  both ends

    if(cp == cpOther && cp > cchText)       // IP cannot follow undeletable
        cp = cpOther = cchText;             //  EOP at end of story

    CRchTxtPtr::Advance(cp - GetCp());
    AssertSz(cp == GetCp(),
        "CTxtRange::Set: inconsistent cp");

    if(GetPed()->fUseCRLF())
    {
        cch = _rpTX.AdjustCpCRLF();
        if(cch)
        {
            _rpCF.AdvanceCp(cch);           // Keep all 3 runptrs in sync
            _rpPF.AdvanceCp(cch);
            cp = GetCp();
        }
        if(cpOther != cp)
        {
            CTxtPtr tp(_rpTX);
            tp.AdvanceCp(cpOther - cp);
            cpOther += tp.AdjustCpCRLF();
        }
    }

    _cch = cp - cpOther;                    // Validated _cch value
    CheckIfSelHasEOP(cpSave, cchSave);      // Maintain _fSelHasEOP in
                                            //  outline mode
    _fMoveBack = GetCp() < cpSave;

    if(cpSave != GetCp() || cchSave != _cch)
    {
        if(_fSel)
            GetPed()->GetCallMgr()->SetSelectionChanged();

        Update_iFormat(-1);
        bRet = TRUE;
    }

    _TEST_INVARIANT_
    return bRet;
}

/*
 *  CTxtRange::Advance(cch)
 *
 *  @mfunc
 *      Advance active end of range by cch.
 *      Other end stays put iff _fExtend
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CTxtRange::Advance (
    LONG cch)               //@parm Signed char count to move active end
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Advance");

    LONG cpSave = GetCp();          // Save entry _cp for CheckChange()

    CRchTxtPtr::Advance(cch);
    return CheckChange(cpSave);
}

/*
 *  CTxtRange::AdvanceCRLF()
 *
 *  @mfunc
 *      Advance active end of range one char, treating CRLF as a single char.
 *      Other end stays put iff _fExtend is nonzero.
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CTxtRange::AdvanceCRLF()
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::AdvanceCRLF");

    LONG cpSave = GetCp();          // Save entry _cp for CheckChange()

    CRchTxtPtr::AdvanceCRLF();
    return CheckChange(cpSave);
}

/*
 *  CTxtRange::SnapToCluster(INT iDirection)
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CTxtRange::SnapToCluster(INT iDirection)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::SnapToCluster");

    LONG cpSave = GetCp();          // Save entry _cp for CheckChange()

    CRchTxtPtr::SnapToCluster(iDirection);
    return CheckChange(cpSave);
}

/*
 *  CTxtRange::BackupCRLF()
 *
 *  @mfunc
 *      Backup active end of range one char, treating CRLF as a single char.
 *      Other end stays put iff _fExtend
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CTxtRange::BackupCRLF(
    BOOL fDiacriticCheck)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::BackupCRLF");

    LONG cpSave = GetCp();          // Save entry _cp for CheckChange()

    CRchTxtPtr::BackupCRLF(fDiacriticCheck);
    return CheckChange(cpSave);
}

/*
 *  CTxtRange::FindWordBreak(action)
 *
 *  @mfunc
 *      Move active end as determined by plain-text FindWordBreak().
 *      Other end stays put iff _fExtend
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CTxtRange::FindWordBreak (
    INT action)         //@parm action defined by CTxtPtr::FindWordBreak()
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtPtr::FindWordBreak");

    LONG cpSave = GetCp();          // Save entry _cp for CheckChange()

    CRchTxtPtr::FindWordBreak(action);
    return CheckChange(cpSave);
}

/*
 *  CTxtRange::FlipRange()
 *
 *  @mfunc
 *      Flip active and non active ends
 */
void CTxtRange::FlipRange()
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FlipRange");

    _TEST_INVARIANT_

    CRchTxtPtr::Advance(-_cch);
    _cch = -_cch;
}

/*
 *  CTxtRange::HexToUnicode(publdr)
 *
 *  @mfunc
 *      Convert hex number ending at cpMost to a Unicode character and
 *      replace the hex number by that character. Take into account
 *      Unicode surrogates for hex values from 0x10000 up to 0x10FFFF.
 *
 *  @rdesc
 *      HRESULT S_OK if conversion successful and hex number replaced by
 *      corresponding Unicode character
 */
HRESULT CTxtRange::HexToUnicode (
    IUndoBuilder *publdr)       //@parm UndoBuilder to receive antievents
{
    LONG ch;
    LONG cpMin, cpMost;
    LONG cch = GetRange(cpMin, cpMost);
    LONG i;
    LONG lch = 0;

    if(cch)
    {
        if(cpMost > GetAdjustedTextLength() || cch > 6)
            return S_FALSE;
        Collapser(tomEnd);
    }
    else
        cch = 6;

    SetExtend(TRUE);
    for(i = 0; cch--; i += 4)
    {
        ch = GetPrevChar();
        if(ch == '+')                       // Check for U+xxxx notation
        {                                   // If it's there, set up to
            Advance(-1);                    //  delete the U+ (or u+)
            Advance((GetPrevChar() | 0x20) == 'u' ? -1 : 1);
            break;                          // Else leave the +
        }
        if(ch > 'f' || !IsXDigit(ch))
            break;
        Advance(-1);
        ch |= 0x20;
        ch -= (ch >= 'a') ? 'a' - 10 : '0';
        lch += (ch << i);
    }
    if(!lch || lch > 0x10FFFF)
        return S_FALSE;

    WCHAR str[2] = {(WCHAR)lch};
    cch = 1;
    if(lch > 0xFFFF)
    {
        lch -= 0x10000;
        str[0] = 0xD800 + (lch >> 10);
        str[1] = 0xDC00 + (lch & 0x3FF);
        cch = 2;
    }
    if(publdr)
        publdr->StopGroupTyping();

    _rpCF.AdjustBackward();                 // Use format of run preceding
    Set_iCF(_rpCF.GetFormat());             //  hex number
    _fUseiFormat = TRUE;
    _rpCF.AdjustForward();

    CleanseAndReplaceRange(cch, str, FALSE, publdr, NULL);
    return S_OK;
}

/*
 *  CTxtRange::UnicodeToHex(publdr)
 *
 *  @mfunc
 *      Convert Unicode character(s) preceeding cpMin to a hex number and
 *      select it. Translate Unicode surrogates into corresponding for hex
 *      values from 0x10000 up to 0x10FFFF.
 *
 *  @rdesc
 *      HRESULT S_OK if conversion successful and Unicode character(s) is
 *      replaced by corresponding hex number.
 */
HRESULT CTxtRange::UnicodeToHex (
    IUndoBuilder *publdr)       //@parm UndoBuilder to receive antievents
{
    if(_cch)                            // If there's a selection,
    {                                   //  convert 1st char in sel
        Collapser(tomStart);
        Advance(IN_RANGE(0xD800, CRchTxtPtr::GetChar(), 0xDBFF) ? 2 : 1);
    }
    LONG cp = GetCp();
    if(!cp)                             // No character to convert
        return S_FALSE;

    _cch = 1;                           // Select previous char
    LONG n = GetPrevChar();             // Get it

    _fExtend = TRUE;
    if(publdr)
        publdr->StopGroupTyping();

    if(IN_RANGE(0xDC00, n, 0xDFFF))     // Unicode surrogate trail word
    {
        if(cp <= 1)                     // No lead word
            return S_FALSE;
        Advance(-2);
        LONG ch = CRchTxtPtr::GetChar();
        Assert(IN_RANGE(0xD800, ch, 0xDBFF));
        n = (n & 0x3FF) + ((ch & 0x3FF) << 10) + 0x10000;
        _cch = -2;
    }

    // Convert ch to str
    LONG    cch = 0;
    LONG    quot, rem;                  // ldiv results
    WCHAR   str[6];
    WCHAR * pch = &str[0];

    for(LONG d = 1; d < n; d <<= 4)     // d = smallest power of 16 > n
        ;
    if(n && d > n)
        d >>= 4;

    while(d)
    {
        quot = n / d;                   // Avoid an ldiv
        rem = n % d;
        n = quot + '0';
        if(n > '9')
            n += 'A' - '9' - 1;
        *pch++ = (WCHAR)n;              // Store digit
        cch++;
        n = rem;                        // Setup remainder
        d >>= 4;
    }

    CleanseAndReplaceRange(cch, str, FALSE, publdr, NULL);
    _cch = cch;                         // Select number

    if(_fSel)
        Update(FALSE);

    return S_OK;
}

/*
 *  CTxtRange::IsInputSequenceValid(pch, cchIns, fOver, pfBaseChar)
 *
 *  @mfunc
 *      Verify the sequence of incoming text. Return FALSE if invalid
 *      combination is found. The criteria is to allow any combinations
 *      that are displayable on screen (the simplest approach used by system
 *      edit control).
 *
 *  @rdesc
 *      Return FALSE if invalid combination is found; else TRUE.
 *
 *      FUTURE: We may consider to support bad sequence filter or text streaming. The code
 *      below is easy enough to be extended to do so.
 */
BOOL CTxtRange::IsInputSequenceValid(
    WCHAR*  pwch,           // Inserting string
    LONG    cchIns,         // Character count
    BOOL    fOverType,      // Insert or Overwrite mode
    BOOL*   pfBaseChar)     // Is pwch[0] a cluster start (base char)?
{
    CTxtEdit*       ped = GetPed();
    CTxtPtr         tp(_rpTX);
    HKL             hkl = GetKeyboardLayout(0);
    BOOL            fr = TRUE;

    if (ped->fUsePassword() || ped->_fNoInputSequenceChk)
        return TRUE;        // no check when editing password

    if (PRIMARYLANGID(hkl) == LANG_VIETNAMESE)
    {
        // No concern about overtyping or cluster since we look backward only
        // 1 char and dont care characters following the insertion point.
        if(_cch > 0)
            tp.AdvanceCp(-_cch);
        fr = IsVietCdmSequenceValid(tp.GetPrevChar(), *pwch);
    }
    else if (PRIMARYLANGID(hkl) == LANG_THAI ||
        W32->IsIndicLcid(LOWORD(hkl)))
    {
        // Do complex things for Thai and Indic

        WCHAR           rgwchText[32];
        WCHAR*          pwchText = rgwchText;
        CUniscribe*     pusp = ped->Getusp();
        CTxtBreaker*    pbrk = ped->_pbrk;
        LONG            found = 0;
        LONG            cp, cpSave, cpLimMin, cpLimMax;
        LONG            cchDel = 0, cchText, ich;
        LONG            cpEnd = ped->GetAdjustedTextLength();

        if (_cch > 0)
            tp.AdvanceCp(-_cch);

        cp = cpSave = cpLimMin = cpLimMax = tp.GetCp();

        if (_cch)
        {
            cchDel = abs(_cch);
        }
        else if (fOverType && !tp.IsAtEOP() && cp != cpEnd)
        {
            // Delete up to the next cluster in overtype mode
            cchDel++;
            if (pbrk)
                while (cp + cchDel < cpEnd && !pbrk->CanBreakCp(BRK_CLUSTER, cp + cchDel))
                    cchDel++;
        }
        cpLimMax += cchDel;

        // Figure the min/max boundaries
        if (pbrk)
        {
            // Min boundary
            cpLimMin += tp.FindEOP(tomBackward, &found);
            if (!(found & FEOP_EOP))
                cpLimMin = 0;

            while (--cp > cpLimMin && !pbrk->CanBreakCp(BRK_CLUSTER, cp));
            cpLimMin = max(cp, cpLimMin);       // more precise boundary

            // Max boundary
            cp = cpLimMax;
            tp.SetCp(cpLimMax);
            cpLimMax += tp.FindEOP(tomForward, &found);
            if (!(found & FEOP_EOP))
                cpLimMax = ped->GetTextLength();

            while (cp < cpLimMax && !pbrk->CanBreakCp(BRK_CLUSTER, cp++));
            cpLimMax = min(cp, cpLimMax);       // more precise boundary
        }
        else
        {
            // No cluster info we statically bound to -1/+1 from selection range
            cpLimMin--;
            cpLimMin = max(0, cpLimMin);

            cpLimMax += cchDel + 1;
            cpLimMax = min(cpLimMax, ped->GetTextLength());
        }

        cp = cpSave + cchDel;
        cchText = cpSave - cpLimMin + cchIns + cpLimMax - cp;

        tp.SetCp(cpLimMin);

        if (cchText > 32)
            pwchText = new WCHAR[cchText];

        if (pwchText)
        {
            // prepare text
            cchText = tp.GetText (cpSave - cpLimMin, pwchText);
            tp.AdvanceCp (cchText + cchDel);
            ich = cchText;
            wcsncpy (&pwchText[cchText], pwch, cchIns);
            cchText += cchIns;
            cchText += tp.GetText (cpLimMax - cpSave - cchDel, &pwchText[cchText]);
            Assert (cchText == cpLimMax - cpLimMin - cchDel + cchIns);


            if (pusp)
            {
                SCRIPT_STRING_ANALYSIS  ssa;
                HRESULT                 hr;
                BOOL                    fDecided = FALSE;

                hr = ScriptStringAnalyse(NULL, pwchText, cchText, GLYPH_COUNT(cchText), -1,
                                    SSA_BREAK, -1, NULL, NULL, NULL, NULL, NULL, &ssa);
                if (S_OK == hr)
                {
                    if (fOverType)
                    {
                        const SCRIPT_LOGATTR* psla = ScriptString_pLogAttr(ssa);
                        BOOL    fBaseChar = !psla || psla[ich].fCharStop;

                        if (!fBaseChar)
                        {
                            // In overtype mode, if the inserted char is not a cluster start.
                            // We act like insert mode. Recursive call with fOvertype = FALSE.
                            fr = IsInputSequenceValid(pwch, cchIns, 0, NULL);
                            fDecided = TRUE;
                        }

                        if (pfBaseChar)
                            *pfBaseChar = fBaseChar;
                    }
                    if (!fDecided && S_FALSE == ScriptStringValidate(ssa))
                        fr = FALSE;

                    ScriptStringFree(&ssa);
                }
            }

            if (pwchText != rgwchText)
                delete[] pwchText;
        }
    }
    return fr;
}

/*
 *  CTxtRange::CleanseAndReplaceRange(cch, *pch, fTestLimit, publdr,
 *                                    pchD, pcchMove, dwFlags)
 *  @mfunc
 *      Cleanse the string pch (replace CRLFs by CRs, etc.) and substitute
 *      the resulting string for the text in this range using the CCharFormat
 *      _iFormat and updating other text runs as needed. For single-line
 *      controls, truncate on the first EOP and substitute the truncated
 *      string.  Also truncate if string would overflow the max text length.
 *
 *  @rdesc
 *      Count of new characters added
 */
LONG CTxtRange::CleanseAndReplaceRange (
    LONG            cchS,       //@parm Length of replacement (Source) text
    const WCHAR *   pchS,       //@parm Replacement (Source) text
    BOOL            fTestLimit, //@parm Whether to do limit test
    IUndoBuilder *  publdr,     //@parm UndoBuilder to receive antievents
    WCHAR *         pchD,       //@parm Destination string (multiline only)
    LONG*           pcchMove,   //@parm Count of chars moved in 1st replace
    DWORD           dwFlags)    //@parm ReplaceRange's flags
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CleanseAndReplaceRange");

    CTxtEdit *     ped = GetPed();
    BYTE           bDefaultCharset = ped->GetCharFormat(-1)->_bCharSet;
    LONG           cchM = 0;
    LONG           cchMove = 0;
    LONG           cchNew = 0;              // Collects total cch inserted
    LONG           cch;                     // Collects cch for cur charset
    DWORD          ch, ch1;
    LONG           cpFirst = GetCpMin();
    DWORD          dw;
    DWORD          dwCharFlags = 0;
    DWORD          dwCharMask = GetCharSetMask();
    DWORD          dwCurrentFontUsed = 0;
	BOOL		   f10Mode = ped->Get10Mode();
    BOOL           fCallerDestination = pchD != 0;  // Save if pchD enters as 0
    BOOL           fDefFontHasASCII = FALSE;
    CFreezeDisplay fd(ped->_pdp);
    BOOL           fMultiLine   = ped->_pdp->IsMultiLine();
    BOOL           fFEBaseFont  = IsFECharSet(bDefaultCharset);
    BOOL           fInTable     = FALSE;
    bool           fUIFont      = fUseUIFont();
    BOOL           fUseCRLF     = ped->fUseCRLF();
    BOOL           fDefFontSymbol = dwCharMask == fSYMBOL;
    const WCHAR *  pch = pchS;
    CTempWcharBuf  twcb;                    // Buffer needed for multiline if
                                            //  pchD = 0
    CCharFormat     CFCurrent;              // Current CF used during IME in progress
    const   DWORD   fALPHA = 0x01;
    BOOL            fDeleteChar = !ped->IsRich() && _cch;

    if (ped->_fIMEInProgress)
    {
        // Initialize data to handle alpha/ASCII dual font mode
        // during IME composition
        dwCurrentFontUsed = fFE;
        CFCurrent = *ped->GetCharFormat(GetiFormat());
    }

    // Check if default font supports full ASCII and Symbol
    if (fUIFont)
    {
        DWORD   dwMaskDefFont = GetCharSetMask(TRUE);
        fDefFontHasASCII = (dwMaskDefFont & fASCII) == fASCII;
        fDefFontSymbol = dwMaskDefFont == fSYMBOL;
    }

    if(!pchS)
        cchS = 0;
    else if(fMultiLine)
    {
        if(cchS < 0)                        // Calculate length for
            cchS = wcslen(pchS);            //  target buffer
        if(cchS && !pchD)
        {
            pchD = twcb.GetBuf(cchS);
            if(!pchD)                       // Couldn't allocate buffer:
                return 0;                   //  give up with no update
        }
        pch = pchD;
        if(_cch <= 0)
            fInTable = GetPF()->InTable();
        else
        {
            CFormatRunPtr rpPF(_rpPF);
            rpPF.AdvanceCp(-_cch);
            fInTable = (ped->GetParaFormat(rpPF.GetFormat())->InTable());
        }
    }
    else if(cchS < 0)                       // Calculate string length
        cchS = tomForward;                  //  while looking for EOP

    for(cch = 0; cchS; cchS--, pchS++, cch++)
    {
        ch = *pchS;
        if(!ch && (!fMultiLine || !fCallerDestination))
            break;

        if(IN_RANGE(CELL, ch, CR))          // Handle CR and LF combos
        {
            if(!fMultiLine && ch >= LF)     // Truncate at 1st EOP to be
                break;                      //  compatible with user.exe SLE
                                            //  and for consistent behavior
            if(ch == CR && !f10Mode)
            {
                if(cchS > 1)
                {
                    ch1 = *(pchS + 1);
                    if(cchS > 2 && ch1 == CR && *(pchS+2) == LF)
                    {
                        if(fUseCRLF)
                        {
                            *pchD++ = ch;
                            *pchD++ = ch1;
                            ch = LF;
                            cch += 2;
                        }
                        else
                        {
                            // Translate CRCRLF to CR or to ' '
                            ch = ped->fXltCRCRLFtoCR() ? CR : ' ';
                        }
                        pchS += 2;          // Bypass two chars
                        cchS -= 2;
                    }
                    else if(ch1 == LF)
                    {
                        if(fUseCRLF && !fInTable)// Copy over whole CRLF
                        {
                            *pchD++ = ch;   // Here we copy CR
                            ch = ch1;       // Setup to copy LF
                            cch++;
                        }
                        pchS++;
                        cchS--;
                    }
                }
                if(fInTable && ch == CR)    // Our simple tables can't contain
                    ch = ' ';               //  CRs or CELLs
            }
            else if(!fUseCRLF && ch == LF)  // Treat lone LFs as EOPs, i.e.,
                ch = CR;                    //  be nice to Unix text files

            else if(ch == CELL && fInTable)
                ch = ' ';
        }
        else if((ch | 1) == PS)             // Translate Unicode para/line
        {                                   //  separators into CR/VT
            if(!fMultiLine)
                break;
            ch = (ch == PS) ? CR : VT;
        }

        dw = fSYMBOL;
        if(!fDefFontSymbol)
            dw = GetCharFlags(ch, bDefaultCharset);     // Check for complex scripts,
        dwCharFlags |= dw;                              // FE, and charset changes
        dw &= ~0xFF;                                    // Exclude non-fontbind flags
        if(ped->IsAutoFont() && !fDefFontSymbol)
        {
            BOOL fReplacedText = FALSE;

            if (fDeleteChar)
            {
                fDeleteChar = FALSE;
                ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE, NULL, RR_ITMZ_NONE);
                Set_iCF(-1);
                dwCharMask = GetCharSetMask(TRUE);
            }

            if (!ped->_fIMEInProgress)
            {
                // Simp. Chinese uses some of the Latin2 symbols
                if (dw == fLATIN2 || IN_RANGE(0x0250, ch, 0x02FF)
                    || IN_RANGE(0xFE50, ch, 0xFE6F))
                {
                    WCHAR   wch = ch;
                    if (VerifyFEString(CP_CHINESE_SIM, &wch, 1, TRUE) == CP_CHINESE_SIM ||
                        VerifyFEString(CP_CHINESE_TRAD, &wch, 1, TRUE) == CP_CHINESE_TRAD)
                        dw = fCHINESE;
                }

                if (fUIFont && dw == fHILATIN1 && fFEBaseFont)
                {
                    // Use Ansi font for HiAnsi
                    if (dwCurrentFontUsed != fHILATIN1)
                    {
                        fReplacedText = TRUE;
                        cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
                            dw, &cchM, cpFirst, IGNORE_CURRENT_FONT, RR_ITMZ_NONE); // Replace text up to previous char
                    }
                    dwCurrentFontUsed = fHILATIN1;
                }
                else if (fUIFont && fDefFontHasASCII &&
                    (dw & fASCII || IN_RANGE(0x2018, ch, 0x201D)))
                {
                    if (dwCurrentFontUsed != fASCII)
                    {
                        cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
                            0, &cchM, cpFirst, IGNORE_CURRENT_FONT, RR_ITMZ_NONE);  // Replace text up to previous char

                        // Use the -1 font charset/face/size so the current font effect
                        // will still be used.
                        CCharFormat CFDefault = *ped->GetCharFormat(-1);
                        SetCharFormat(&CFDefault, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
                                 CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);

                        fReplacedText = TRUE;
                    }
                    dwCurrentFontUsed = fASCII;
                }
                else if (dw && !(dw & dwCharMask)   // No match: need charset change
                     || dwCurrentFontUsed)          //  or change in classification
                {
                    fReplacedText = TRUE;
                    dwCurrentFontUsed = 0;
                    if(dw & (fCHINESE | fBIG5) & ~255)  // If Han char, check next few
                    {                                   //  chars for a Hangul or Kana
                        Assert(cchS);
                        const WCHAR *pchT = pchS+1;
                        LONG i = min(10, cchS - 1);

                        while(i-- && *pchT)
                            dw |= GetCharFlags(*pchT++, bDefaultCharset);

                        i = CalcTextLenNotInRange();
                        if(cchS < 6 && i)           // Get flags around range
                        {
                            CTxtPtr tp(_rpTX);
                            i = min(i, 6);
                            if(!_cch)               // For insertion point, backup
                                tp.AdvanceCp(-i/2); //  half way
                            else if(_cch < 0)       // Active end at cpMin, backup
                                tp.AdvanceCp(-i);   //  whole way
                            for(; i--; tp.AdvanceCp(1))
                                dw |= GetCharFlags(tp.GetChar(), bDefaultCharset);
                        }
                        dw &= (fKANA | fHANGUL | fCHINESE | fBIG5);
                    }
                    else if(dw & (fHILATIN1 | fLATIN2) && dwCharMask & fLATIN)
                    {
                        LONG i = dwCharMask & fLATIN;
                        dw = W32->GetCharFlags125x(ch) & fLATIN;
                        if(!(dw & i))
                            for(i = 0x100; i < 0x20000 && !(dw & i); i <<= 1)
                                ;
                        dw &= i;
                    }

                    cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
                        dw, &cchM, cpFirst, MATCH_FONT_SIG, RR_ITMZ_NONE);  // Replace text up to previous char
                }
            }
            else
            {
                // IME in progress, only need to check ASCII cases
                BOOL    fHandled = FALSE;

                if (ch <= 0x7F)
                {
                    if (fUIFont)
                    {
                        // Use default font
                        if (dwCurrentFontUsed != fASCII)
                        {
                            cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
                                0, &cchM, cpFirst, IGNORE_CURRENT_FONT, RR_ITMZ_NONE);  // Replace text up to previous char

                            // Use the -1 font charset/face/size so the current font effect
                            // will still be used.
                            CCharFormat CFDefault = *ped->GetCharFormat(-1);
                            SetCharFormat(&CFDefault, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
                                     CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);

                            fReplacedText = TRUE;
                        }
                        dwCurrentFontUsed = fASCII;
                        fHandled = TRUE;
                    }
                    else if (ped->_fDualFont && IsAlpha(ch))
                    {
                        // Use English Font
                        if (dwCurrentFontUsed != fALPHA)
                        {

                            cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
                                dw, &cchM, cpFirst, IGNORE_CURRENT_FONT, RR_ITMZ_NONE); // Replace text up to previous char
                            fReplacedText = TRUE;
                        }
                        dwCurrentFontUsed = fALPHA;
                        fHandled = TRUE;
                    }
                }

                // Use current FE font
                if (!fHandled)
                {
                    if (dwCurrentFontUsed != fFE)
                    {
                        cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
                            0, &cchM, cpFirst, IGNORE_CURRENT_FONT, RR_ITMZ_NONE);  // Replace text up to previous char
                        SetCharFormat(&CFCurrent, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
                            CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
                        fReplacedText = TRUE;
                    }
                    dwCurrentFontUsed = fFE;
                }
            }

            if (fReplacedText)
            {
                dwCharMask = (dw & fSYMBOL) ? fSYMBOL : GetCharSetMask();
                if(cchM)
                    cchMove = cchM;         // Can only happen on 1st replace
                pch = fMultiLine ? pchD : pchS;
                cch = 0;
            }
        }
        if(fMultiLine)                      // In multiline controls, collect
        {                                   //  possibly translated chars
            if(dw & fSYMBOL)                // Convert 0xF000 thru 0xF0FF to
                ch &= 0xFF;                 //  SYMBOL_CHARSET with 0x00 thru
            *pchD++ = ch;                   //  0xFF. FUTURE: make work for
        }                                   //  single line too...
    }
    ped->OrCharFlags(dwCharFlags, publdr);

    cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr, 0, &cchM, cpFirst,
                                    IGNORE_CURRENT_FONT, RR_ITMZ_NONE);
    if(cchM)
        cchMove = cchM;                     // Can only happen on 1st replace

    if (pcchMove)
        *pcchMove = cchMove;

    if (ped->IsComplexScript())
    {
        if (dwFlags & RR_ITMZ_NONE || ped->IsStreaming())
            ped->_fItemizePending = TRUE;
        else
            ItemizeReplaceRange(cchNew, cchMove, publdr, dwFlags & RR_ITMZ_UNICODEBIDI);
    }
    return cchNew;
}

/*
 *  CTxtRange::CheckLimitReplaceRange(cchNew, *pch, fTestLimit, publdr,
 *                                    dwFlags, pcchMove, prp, iMatchCurrent, dwFlags)
 *  @mfunc
 *      Replace the text in this range by pch using CCharFormat _iFormat
 *      and updating other text runs as needed.
 *
 *  @rdesc
 *      Count of new characters added
 *
 *  @devnote
 *      moves this text pointer to end of replaced text and
 *      may move text block and formatting arrays
 */
LONG CTxtRange::CheckLimitReplaceRange (
    LONG            cch,            //@parm Length of replacement text
    TCHAR const *   pch,            //@parm Replacement text
    BOOL            fTestLimit,     //@parm Whether to do limit test
    IUndoBuilder *  publdr,         //@parm UndoBuilder to receive antievents
    DWORD           dwCharFlags,    //@parm CharFlags following pch
    LONG *          pcchMove,       //@parm Count of chars moved in 1st replace
    LONG            cpFirst,        //@parm Starting cp for font binding
    int             iMatchCurrent,  //@parm Font matching method
    DWORD           dwFlags)        //@parm ReplaceRange's flags
{
    CTxtEdit *ped = GetPed();

    if(cch || _cch)
    {
        if(fTestLimit)
        {
            LONG    cchLen = CalcTextLenNotInRange();
            DWORD   cchMax = ped->TxGetMaxLength();
            if((DWORD)(cch + cchLen) > cchMax)  // New plus old count exceeds
            {                                   //  max allowed, so truncate
                cch = cchMax - cchLen;          //  down to what fits
                cch = max(cch, 0);              // Keep it positive
                ped->GetCallMgr()->SetMaxText(); // Report exceeded
            }
        }

        if (cch && ped->IsAutoFont() && !ped->_fIMEInProgress)
        {
            LONG iFormatTemp;
            if (fUseUIFont() && GetAdjustedTextLength() != _cch)
            {
                // Delete the old string first so _iFormat is defined
                ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE, pcchMove, dwFlags);
                iFormatTemp = _iFormat;
            }
            else
                iFormatTemp = GetiFormat();

            BYTE bCharSetCurrent = ped->GetCharFormat(iFormatTemp)->_bCharSet;

            if (IsFECharSet(bCharSetCurrent))
            {
                // Check if current font can handle this string.
                INT     cpgCurrent = GetCodePage(bCharSetCurrent);
                INT     cpgNew = VerifyFEString(cpgCurrent, pch, cch, FALSE);

                if (cpgCurrent != cpgNew)
                {
                    // Setup the new CodePage to handle this string
                    CCharFormat CF;
                    CCFRunPtr   rp(_rpCF, ped);
                    rp.AdvanceCp(cpFirst - GetCp());

                    CF._bCharSet = GetCharSet(cpgNew);

                    if(rp.GetPreferredFontInfo(cpgNew, CF._bCharSet, CF._iFont, CF._yHeight,
                            CF._bPitchAndFamily, _iFormat, iMatchCurrent))
                    {
                        SetCharFormat(&CF, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
                             CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
                    }
                }
            }
        }
        cch = ReplaceRange(cch, pch, publdr, SELRR_REMEMBERRANGE, pcchMove, dwFlags);
    }

    if(dwCharFlags)
    {
        CCharFormat CF;
        CCFRunPtr   rp(_rpCF, ped);
        rp.AdvanceCp(cpFirst - GetCp());

        // If following string contains Hangul or Kana, use Korean or Japanese
        // font signatures, respectively. Else use incoming dwCharFlags
        dwCharFlags &= ~255;
        if(dwCharFlags & fHANGUL)
            dwCharFlags = fHANGUL;
        else if(dwCharFlags & fKANA)
            dwCharFlags = fKANA;
        else if(dwCharFlags & fBIG5)
            dwCharFlags = fBIG5;
        else
            Assert(!(dwCharFlags & fCHINESE) || dwCharFlags == (fCHINESE & ~255));

        LONG i = W32->ScriptIndexFromFontSig(dwCharFlags >> 8);

        CF._bCharSet = GetCharSet(i, NULL);

        if(rp.GetPreferredFontInfo(i, CF._bCharSet, CF._iFont, CF._yHeight,
                CF._bPitchAndFamily, (_cch ? -1 : _iFormat), iMatchCurrent))
        {
            SetCharFormat(&CF, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
                 CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
        }
    }
    return cch;
}

/*
 *  CTxtRange::ReplaceRange(cchNew, *pch, publdr. selaemode, pcchMove)
 *
 *  @mfunc
 *      Replace the text in this range by pch using CCharFormat _iFormat
 *      and updating other text runs as needed.
 *
 *  @rdesc
 *      Count of new characters added
 *
 *  @devnote
 *      moves this text pointer to end of replaced text and
 *      may move text block and formatting arrays
 */
LONG CTxtRange::ReplaceRange (
    LONG            cchNew,     //@parm Length of replacement text
    TCHAR const *   pch,        //@parm Replacement text
    IUndoBuilder *  publdr,     //@parm UndoBuilder to receive antievents
    SELRR           selaemode,  //@parm Controls how selection antievents are to be generated.
    LONG*           pcchMove,   //@parm number of chars moved after replace
    DWORD           dwFlags)    //@parm Special flags
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::ReplaceRange");

    LONG lRet;
    LONG iFormat = _iFormat;
    BOOL fReleaseFormat = FALSE;
    ICharFormatCache * pcf = GetCharFormatCache();

    _TEST_INVARIANT_

    if(!(cchNew | _cch))                    // Nothing to add or delete,
    {                                       //  so we're done
        if(pcchMove)
            *pcchMove = 0;
        return 0;
    }

    if(publdr && selaemode != SELRR_IGNORE)
    {
        Assert(selaemode == SELRR_REMEMBERRANGE);
        HandleSelectionAEInfo(GetPed(), publdr, GetCp(), _cch,
                GetCpMin() + cchNew, 0, SELAE_MERGE);
    }

    if(_cch > 0)
        FlipRange();

    // If we are replacing a non-degenerate selection, then the Word95
    // UI specifies that we should use the rightmost formatting at cpMin.
    if(_cch < 0 && _rpCF.IsValid() && !_fDualFontMode && !_fUseiFormat)
    {
        _rpCF.AdjustForward();
        iFormat = _rpCF.GetFormat();

        // This is a bit icky, but the idea is to stabilize the
        // reference count on iFormat.  When we get it above, it's
        // not addref'ed, so if we happen to delete the text in the
        // range and the range is the only one with that format,
        // then the format will go away.
        pcf->AddRef(iFormat);
        fReleaseFormat = TRUE;
    }
    _fUseiFormat = FALSE;

    LONG cchForReplace = -_cch;
    _cch = 0;
    lRet = CRchTxtPtr::ReplaceRange(cchForReplace, cchNew, pch, publdr,
                iFormat, pcchMove, dwFlags);
    if(lRet)
        _fMoveBack = FALSE;

    Update_iFormat(fReleaseFormat ? iFormat : -1);

    if(fReleaseFormat)
    {
        Assert(pcf);
        pcf->Release(iFormat);
    }

    return lRet;
}

/*
 *  CTxtRange::Delete(publdr. selaemode)
 *
 *  @mfunc
 *      Delete text in this range.
 */
void CTxtRange::Delete (
    IUndoBuilder *  publdr,     //@parm UndoBuilder to receive antievents
    SELRR           selaemode)  //@parm Controls generation of selection antievents
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Delete");

    if(!_cch)
        return;                         // Nothing to delete

    if(!GetPed()->IsBiDi())
    {
        ReplaceRange(0, NULL, publdr, selaemode, NULL);
        return;
    }

    CFreezeDisplay fd(GetPed()->_pdp);

    ReplaceRange(0, NULL, publdr, selaemode);
}

/*
 *  CTxtRange::GetCharFormat(pCF, flags)
 *
 *  @mfunc
 *      Set *pCF = CCharFormat for this range. If cbSize = sizeof(CHARFORMAT)
 *      only transfer CHARFORMAT data.
 *
 *  @rdesc
 *      Mask of unchanged properties over range (for CHARFORMAT::dwMask)
 *
 *  @devnote
 *      NINCH means No Input No CHange (a Microsoft Word term). Here used for
 *      properties that change during the range of cch characters.  NINCHed
 *      properties in a Word-Font dialog have grayed boxes. They are indicated
 *      by zero values in their respective dwMask bit positions. Note that
 *      a blank at the end of the range does not participate in the NINCH
 *      test, i.e., it can have a different CCharFormat without zeroing the
 *      corresponding dwMask bits.  This is done to be compatible with Word
 *      (see also CTxtSelection::SetCharFormat when _fWordSelMode is TRUE).
 */
DWORD CTxtRange::GetCharFormat (
    CCharFormat *pCF,       //@parm CCharFormat to fill with results
    DWORD flags) const      //@parm flags
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetCharFormat");
    _TEST_INVARIANT_

    CTxtEdit * const ped = GetPed();

    if(!_cch || !_rpCF.IsValid())                   // IP or invalid CF
    {                                               //  run ptr: use CF at
        *pCF = *ped->GetCharFormat(_iFormat);       //  this text ptr
        return CFM_ALL2;
    }

    LONG          cpMin, cpMost;                    // Nondegenerate range:
    LONG          cch = GetRange(cpMin, cpMost);    //  need to scan
    LONG          cchChunk;                         // cch in CF run
    DWORD         dwMask = CFM_ALL2;                // Initially all prop def'd
    LONG          iDirection;                       // Direction of scan
    CFormatRunPtr rp(_rpCF);                        // Nondegenerate range

    /*
     * The code below reads character formatting the way Word does it,
     * that is, by not including the formatting of the last character in the
     * range if that character is a blank.
     *
     * See also the corresponding code in CTxtSelection::SetCharFormat().
     */

    if(cch > 1 && _fSel && (flags & SCF_USEUIRULES))// If more than one char,
    {                                               //  don't include trailing
        CTxtPtr tp(ped, cpMost - 1);                //  blank in NINCH test
        if(tp.GetChar() == ' ')
        {                                           // Have trailing blank:
            cch--;                                  //  one less char to check
            if(_cch > 0)                            // Will scan backward, so
                rp.AdvanceCp(-1);                   //  backup before blank
        }
    }

    if(_cch < 0)                                    // Setup direction and
    {                                               //  initial cchChunk
        iDirection = 1;                             // Scan forward
        rp.AdjustForward();
        cchChunk = rp.GetCchLeft();                 // Chunk size for _rpCF
    }
    else
    {
        iDirection = -1;                            // Scan backward
        rp.AdjustBackward();                        // If at BOR, go to
        cchChunk = rp.GetIch();                     //  previous EOR
    }

    *pCF = *ped->GetCharFormat(rp.GetFormat());     // Initialize *pCF to
                                                    //  starting format
    while(cchChunk < cch)                           // NINCH properties that
    {                                               //  change over the range
        cch -= cchChunk;                            //  given by cch
        if(!rp.ChgRun(iDirection))                  // No more runs
            break;                                  //  (cch too big)
        cchChunk = rp.GetRun(0)->_cch;

        const CCharFormat *pCFTemp = ped->GetCharFormat(rp.GetFormat());

        dwMask &= ~pCFTemp->Delta(pCF,              // NINCH properties that
                        flags & CFM2_CHARFORMAT);   //  changed, i.e., reset
    }                                               //  corresponding bits
    return dwMask;
}

/*
 *  CTxtRange::SetCharFormat(pCF, flags, publdr, dwMask, dwMask2)
 *
 *  @mfunc
 *      apply CCharFormat *pCF to this range.  If range is an insertion point,
 *      and (flags & SCF_WORD) != 0, then apply CCharFormat to word surrounding
 *      this insertion point
 *
 *  @rdesc
 *      HRESULT = (successfully set whole range) ? NOERROR : S_FALSE
 *
 *  @devnote
 *      SetParaFormat() is similar, but simpler, since it doesn't have to
 *      special case insertion-point ranges or worry about bullet character
 *      formatting, which is given by EOP formatting.
 */
HRESULT CTxtRange::SetCharFormat (
    const CCharFormat *pCF, //@parm CCharFormat to fill with results
    DWORD         flags,    //@parm SCF_WORD OR SCF_IGNORESELAE
    IUndoBuilder *publdr,   //@parm Undo builder to use
    DWORD         dwMask,   //@parm CHARFORMAT2 mask
    DWORD         dwMask2)  //@parm Second mask
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::SetCharFormat");

    LONG                cch = -_cch;            // Defaults for _cch <= 0
    LONG                cchBack = 0;            // cch to back up for formatting
    LONG                cchFormat;              // cch for formatting
    CCharFormat         CF;                     // Temporary CF
    LONG                cp;
    LONG                cpMin, cpMost;
    LONG                cpStart = 0;
    LONG                cpWordMin, cpWordMost;
    BOOL                fApplyToEOP = FALSE;
    BOOL                fProtected = FALSE;
    HRESULT             hr = NOERROR;
    LONG                iCF;
    CTxtEdit * const    ped = GetPed();         //  defined and not style
    ICharFormatCache *  pf = GetCharFormatCache();
    CFreezeDisplay      fd(ped->_pdp);

    _TEST_INVARIANT_

    if(!Check_rpCF())                           // Not rich
        return NOERROR;

    if(_cch > 0)                                // Active end at range end
    {
        cchBack = -_cch;                        // Setup to back up to
        cch = _cch;                             //  start of format area
    }
    else if(_cch < 0)
        _rpCF.AdjustForward();

    else if(!cch && (flags & (SCF_WORD | SCF_USEUIRULES)))
    {
        BOOL fCheckEOP = TRUE;
        if(flags & SCF_WORD)
        {
            FindWord(&cpWordMin, &cpWordMost, FW_EXACT);

            // If nearest word is within this range, calculate cchback and cch
            // so that we can apply the given format to the word
            if(cpWordMin < GetCp() && GetCp() < cpWordMost)
            {
                // RichEdit 1.0 made 1 final check: ensure word's format
                // is constant w.r.t. the format passed in
                CTxtRange rg(*this);

                rg.Set(cpWordMin, cpWordMin - cpWordMost);
                fProtected = rg.WriteAccessDenied();
                if(!fProtected && (rg.GetCharFormat(&CF) & dwMask) == dwMask)
                {
                    cchBack = cpWordMin - GetCp();
                    cch = cpWordMost - cpWordMin;
                }
                fCheckEOP = FALSE;
            }
        }
        if(fCheckEOP && _rpTX.IsAtEOP() && !GetPF()->_wNumbering)
        {
            CTxtPtr tp(_rpTX);
            cch = tp.AdvanceCpCRLF();
            _rpCF.AdjustForward();              // Go onto format EOP
            fApplyToEOP = TRUE;

            // Apply the characterset and face to EOP because EOP can be in any charset
            dwMask2 |= CFM2_NOCHARSETCHECK;
        }
    }
    cchFormat = cch;

    BOOL fApplyStyle = pCF->fSetStyle(dwMask, dwMask2);

    if(!cch)                                    // Set degenerate-range (IP)
    {                                           //  CF
LApplytoIP:
        DWORD dwMsk = dwMask;
        dwMask2 |= CFM2_NOCHARSETCHECK;
        CF = *ped->GetCharFormat(_iFormat);     // Copy current CF at IP to CF
        if ((CF._dwEffects & CFE_LINK) &&       // Don't allow our URL
            ped->GetDetectURL())                //  formatting to be changed
        {
            dwMsk &= ~CFM_LINK;
        }
        if(fApplyStyle)
            CF.ApplyDefaultStyle(pCF->_sStyle);
        hr = CF.Apply(pCF, dwMsk, dwMask2);     // Apply *pCF
        if(hr != NOERROR)                       // Cache result if new
            return hr;
        hr = pf->Cache(&CF, &iCF);              // In any case, get iCF
        if(hr != NOERROR)                       //  (which AddRef's it)
            return hr;

#ifdef LINESERVICES
        if (g_pols)
            g_pols->DestroyLine(NULL);
#endif

        pf->Release(_iFormat);
        _iFormat = iCF;
        if(fProtected)                          // Signal to beep if UI
            hr = S_FALSE;
    }
    else                                        // Set nondegenerate-range CF
    {                                           // Get start of affected area
        CNotifyMgr *pnm = NULL;

        if (!(flags & SCF_IGNORENOTIFY))
        {
            pnm = ped->GetNotifyMgr();              // Get the notification mgr
            if(pnm)
            {
                cpStart = GetCp() + cchBack;        // Bulletting may move
                                                    //  affected area back if
                if(GetPF()->_wNumbering)            //  formatting hits EOP that
                {                                   //  affects bullet at BOP
                    FindParagraph(&cpMin, &cpMost);

                    if(cpMost <= GetCpMost())
                        cpStart = cpMin;
                }
                pnm->NotifyPreReplaceRange(this,    // Notify interested parties of
                    CP_INFINITE, 0, 0, cpStart,     // the impending update
                        cpStart + cchFormat);
            }
        }

        _rpCF.AdvanceCp(cchBack);               // Back up to formatting start
        CFormatRunPtr rp(_rpCF);                // Clone _rpCF to walk range

        cp = GetCp() + cchBack;
        if(publdr)
        {
            LONG    cchBackup = 0, cchAdvance = 0;
            if (ped->IsBiDi())
            {
                CRchTxtPtr  rtp(*this);
                rtp._rpCF.AdvanceCp(-cchBack);  // restore previous _rpCF
                rtp.Advance(cchBack);
                cchBackup = rtp.ExpandRangeFormatting(cch, 0, cchAdvance);
                Assert(cchBackup >= 0);
            }
            rp.AdvanceCp(-cchBackup);

            IAntiEvent *pae = gAEDispenser.CreateReplaceFormattingAE(
                                ped, rp, cch + cchBackup + cchAdvance, pf, CharFormat);

            rp.AdvanceCp(cchBackup);
            if(pae)
                publdr->AddAntiEvent(pae);
        }

        // Following Word, we translate runs for 8-bit charsets to/from
        // SYMBOL_CHARSET
        LONG    cchRun;
        LONG    cchTrans;
        UINT    CodePage = 0;
        DWORD   dwFontSig = 0;
        DWORD   dwMaskSave  = dwMask;
        DWORD   dwMask2Save = dwMask2;
        LONG    cchSkip     = 0;
        BOOL    fSymbolCharSet = IsSymbolOrOEM(pCF->_bCharSet);
        BOOL    fBiDiCharSet = IsBiDiCharSet(pCF->_bCharSet);
        BOOL    fFECharSet = IsFECharSet(pCF->_bCharSet);
        BOOL    fFontCheck = (dwMask2 & CFM2_MATCHFONT);
        BOOL    fInRange;
        CTxtPtr tp(_rpTX);

        if(fFontCheck && !fSymbolCharSet)
        {
            GetFontSignatureFromFace(pCF->_iFont, &dwFontSig);
            if(!dwFontSig)
                dwFontSig = GetFontSig(pCF->_bCharSet);
        }

        if (ped->_fIMEInProgress && !(dwMask2 & CFM2_SCRIPT))
            dwMask2 |= CFM2_NOCHARSETCHECK;     // Don't check charset or it will display garbage

        while(cch > 0 && rp.IsValid())
        {
            CF = *ped->GetCharFormat(rp.GetFormat());// Copy rp CF to temp CF
            if(fApplyStyle)
                CF.ApplyDefaultStyle(pCF->_sStyle);
            cchRun = cch;

            if (CF._dwEffects & CFE_RUNISDBCS)
            {
                // Don't allow charset/face name change for DBCS run
                // causing these are garbage characters
                dwMask &= ~(CFM_CHARSET | CFM_FACE);
            }
            else if(fFontCheck)                     // Only apply font if it
            {                                   //  supports run's charset
                cchRun = rp.GetCchLeft();       // Translate up to end of
                cchRun = min(cch, cchRun);      //  current CF run
                dwMask &= ~CFM_CHARSET;         // Default no charset change

                if(cchSkip)
                {                               // Skip cchSkip chars (were
                    cchRun = cchSkip;           //  not translatable with
                    cchSkip = 0;                //  CodePage)
                }
                else if(fSymbolCharSet ^ IsSymbolOrOEM(CF._bCharSet))
                {                               // SYMBOL to/from nonSYMBOL
                    CodePage = GetCodePage(fSymbolCharSet ? CF._bCharSet : pCF->_bCharSet);
                    if(!Is8BitCodePage(CodePage))
                        goto DoASCII;

                    dwMask |= CFM_CHARSET;      // Need to change charset
                    if(fSymbolCharSet)
                        CF._wCodePageSave = CodePage;
                    else if(Is8BitCodePage(CF._wCodePageSave))
                    {
                        CodePage = CF._wCodePageSave;
                        CF._bCharSet = GetCharSet(CodePage);
                        dwMask &= ~CFM_CHARSET; // Already changed
                    }

                    tp.SetCp(cp);               // Point tp at start of run
                    cchTrans = tp.TranslateRange(cchRun, CodePage, fSymbolCharSet,
                                                 publdr /*, cchSkip */);
                    if(cchTrans < cchRun)       // Ran into char not in
                    {                           //  CodePage, so set up to
                        cchSkip = 1;            //  skip the char
                        cchRun = cchTrans;      // FUTURE: use cchSkip out
                        if(!cchRun)             //  parm from TranslateRange
                            continue;           //  instead of skipping 1 char
                    }                           //  at a time
                }
                else if(!fSymbolCharSet)
                {
DoASCII:            tp.SetCp(cp);               // Point tp at start of run
                    fInRange = tp.GetChar() < 0x80;

                    if (!fBiDiCharSet && !IsBiDiCharSet(CF._bCharSet) &&
                        fInRange &&
                        ((dwFontSig & fASCII >> 8) == fASCII >> 8 || fFECharSet || fSymbolCharSet))
                    {
                        // ASCII text and new font supports ASCII

                        // -FUTURE-
                        // We exlude BiDi here. We cannot allow applying BiDi charset to non-BiDi run or vice versa.
                        // This because we use charset for BiDi reordering. In the future we should
                        // evolve to something more elegant than charset.

                        if (!(GetFontSig(CF._bCharSet) & ~(fASCII >> 8) & dwFontSig))

                            // New font doesnt support underlying charset,
                            // apply new charset to ASCII

                            dwMask |= CFM_CHARSET;
                    }
                    else if (!(GetFontSig(CF._bCharSet) & ~(fASCII >> 8) & dwFontSig))

                        // New font doesnt support underlying charset,
                        // suppress both new charset and facename

                        dwMask &= ~CFM_FACE;

                    cchRun -= tp.MoveWhile(cchRun, 0, 0x7F, fInRange);
                }
            }
            hr = CF.Apply(pCF, dwMask, dwMask2);// Apply *pCF
            if(hr != NOERROR)
                return hr;
            dwMask = dwMaskSave;                // Restore mask in case
            dwMask2 = dwMask2Save;              //  changed above
            hr = pf->Cache(&CF, &iCF);          // Cache result if new, In any
            if(hr != NOERROR)                   //  cause, use format index iCF
                break;

#ifdef LINESERVICES
            if (g_pols)
                g_pols->DestroyLine(NULL);
#endif

            cchRun = rp.SetFormat(iCF, cchRun, pf);// Set format for this run
                                                // Proper levels will be generated later by BiDi FSM.

            pf->Release(iCF);                   // Release count from Cache above
                                                // rp.SetFormat AddRef's as needed
            if(cchRun == CP_INFINITE)
            {
                ped->GetCallMgr()->SetOutOfMemory();
                break;
            }
            cp += cchRun;
            cch -= cchRun;
        }
        _rpCF.AdjustBackward();                 // Expand scope for merging
        rp.AdjustForward();                     //  runs

        rp.MergeRuns(_rpCF._iRun, pf);          // Merge adjacent runs that
                                                //  have the same format
        if(cchBack)                             // Move _rpCF back to where it
            _rpCF.AdvanceCp(-cchBack);          //  was
        else                                    // Active end at range start:
            _rpCF.AdjustForward();              //  don't leave at EOR

        if(pnm)
        {
            pnm->NotifyPostReplaceRange(this,   // Notify interested parties
                CP_INFINITE, 0, 0, cpStart,     // of the change.
                    cpStart + cchFormat - cch);
        }

        if(publdr && !(flags & SCF_IGNORESELAE))
        {
            HandleSelectionAEInfo(ped, publdr, GetCp(), _cch, GetCp(), _cch,
                    SELAE_FORCEREPLACE);
        }

        if(!_cch)                               // In case IP with ApplyToWord
        {
            if(fApplyToEOP)                     // Formatting EOP only
                goto LApplytoIP;

            Update_iFormat(-1);
        }
        if (ped->IsRich())
            ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);
    }
    if(_fSel && ped->IsRich() && !ped->_f10Mode /*bug fix #5211*/)
        ped->GetCallMgr()->SetSelectionChanged();

    AssertSz(GetCp() == (cp = _rpCF.CalculateCp()),
        "RTR::SetCharFormat(): incorrect format-run ptr");

    if (!(dwMask2 & (CFM2_SCRIPT | CFM2_HOLDITEMIZE)) && cchFormat && hr == NOERROR && !cch)
    {
        // A non-degenerate range not coming from ItemizeRuns

        // It's faster to make a copy pointer since we dont need to worry about fExtend.
        CRchTxtPtr  rtp(*this);

        rtp.Advance(cchBack + cchFormat);
        rtp.ItemizeReplaceRange(cchFormat, 0, publdr);

        return hr;
    }

    return (hr == NOERROR && cch) ? S_FALSE : hr;
}

/*
 *  CTxtRange::GetParaFormat(pPF)
 *
 *  @mfunc
 *      return CParaFormat for this text range. If no PF runs are allocated,
 *      then return default CParaFormat
 *
 *  @rdesc
 *      Mask of defined properties: 1 bit means corresponding property is
 *      defined and constant throughout range.  0 bit means it isn't constant
 *      throughout range.  Note that PARAFORMAT has fewer relevant bits
 *      (PFM_ALL vs PFM_ALL2)
 */
DWORD CTxtRange::GetParaFormat (
    CParaFormat *pPF,           //@parm ptr to CParaFormat to be filled
    DWORD        flags) const   //  be filled with possibly NINCH'd values
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetParaFormat");

    CTxtEdit * const ped = GetPed();

    _TEST_INVARIANT_

    DWORD dwMask = flags & PFM_PARAFORMAT           // Default presence of
                 ? PFM_ALL : PFM_ALL2;              //  all properties

    CFormatRunPtr rp(_rpPF);
    LONG          cch = -_cch;

    if(cch < 0)                                     // At end of range:
    {                                               //  go to start of range
        rp.AdvanceCp(cch);
        cch = -cch;                                 // Count with cch > 0
    }

    *pPF = *ped->GetParaFormat(rp.GetFormat());     // Initialize *pPF to
                                                    //  starting paraformat
    if(!cch || !rp.IsValid())                       // No cch or invalid PF
        return dwMask;                              //  run ptr: use PF at
                                                    //  this text ptr
    LONG cchChunk = rp.GetCchLeft();                // Chunk size for rp
    while(cchChunk < cch)                           // NINCH properties that
    {                                               //  change over the range
        cch -= cchChunk;                            //  given by cch
        if(!rp.NextRun())                           // Go to next run                                                   // No more runs
            break;                                  //  (cch too big)
        cchChunk = rp.GetCchLeft();
        dwMask &= ~ped->GetParaFormat(rp.GetFormat())// NINCH properties that
            ->Delta(pPF, flags & PFM_PARAFORMAT);   //  changed, i.e., reset
    }                                               //  corresponding bits
    return dwMask;
}

/*
 *  CTxtRange::SetParaFormat(pPF, publdr, dwMask)
 *
 *  @mfunc
 *      apply CParaFormat *pPF to this range.
 *
 *  @rdesc
 *      if successfully set whole range, return NOERROR, otherwise
 *      return error code or S_FALSE.
 */
HRESULT CTxtRange::SetParaFormat (
    const CParaFormat* pPF,     //@parm CParaFormat to apply to this range
    IUndoBuilder *publdr,       //@parm Undo context for this operation
    DWORD         dwMask)       //@parm Mask to use
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::SetParaFormat");

    LONG                cch;                // Length of text to format
    LONG                cchBack;            // cch to back up for formatting
    LONG                cp;
    LONG                cpMin, cpMost;      // Limits of text to format
    LONG                delta;
    HRESULT             hr = NOERROR;
    LONG                iPF = 0;            // Lndex to a CParaFormat
    CTxtEdit * const    ped = GetPed();
    CParaFormat         PF;                 // Temporary CParaFormat
    IParaFormatCache *  pf = GetParaFormatCache();// Format cache ptr for Cache,
                                            //  AddRefFormat, ReleaseFormat
    CBiDiLevel*         pLevel;
    CBiDiLevel          lvRTL = {1, 0};
    CBiDiLevel          lvLTR = {0, 0};
    CFreezeDisplay      fd(ped->_pdp);

    _TEST_INVARIANT_

    if(!Check_rpPF())
        return E_FAIL;

    FindParagraph(&cpMin, &cpMost);             // Get limits of text to
    cch = cpMost - cpMin;                       //  format, namely closest

    CNotifyMgr *pnm = ped->GetNotifyMgr();
    if(pnm)
    {
        pnm->NotifyPreReplaceRange(this,        // Notify interested parties of
            CP_INFINITE, 0, 0, cpMin, cpMost);  // the impending update
    }

    cchBack = cpMin - GetCp();

    _rpPF.AdvanceCp(cchBack);                   // Back up to formatting start
    CFormatRunPtr rp(_rpPF);                    // Clone _rpPF to walk range

    if(publdr)
    {
        IAntiEvent *pae = gAEDispenser.CreateReplaceFormattingAE(ped,
                            rp, cch, pf, ParaFormat);
        if(pae)
            publdr->AddAntiEvent(pae);
    }

    const CParaFormat*  pPFCurrent;         // PF at current runptr
    BOOL    fLevelChanged = FALSE;
    BOOL    fFullyDefined = FALSE;          // Default input PF not fully defined

    if (ped->HandleStyle(&PF, pPF, dwMask) == NOERROR &&
        pf->Cache(&PF, &iPF) == NOERROR)
    {
        fFullyDefined = TRUE;
    }

    do
    {
        WORD    wEffectsCurrent;
        pPFCurrent = ped->GetParaFormat(rp.GetFormat());// Get current PF
        wEffectsCurrent = pPFCurrent->_wEffects;// Save current effect so we don't
                                                //  need to use pPFCurrent because it may
                                                //  become invalid after a PF.Apply.
        if(!fFullyDefined)                      // If pPF doesn't specify
        {                                       //  full PF, fill in undefined
            PF = *pPFCurrent;
            hr = PF.Apply(pPF, dwMask);         // Apply *pPF
            if(hr != NOERROR)                   //  (Probably E_INVALIDARG)
                break;                          // Cache result if new; in any
            hr = pf->Cache(&PF, &iPF);          //  case, get format index iPF
            if(hr != NOERROR)                   // Can't necessarily return
                break;                          //  error, since may need
        }

        if (!fLevelChanged)
            fLevelChanged = (wEffectsCurrent ^ PF._wEffects) & PFE_RTLPARA;

        pLevel = PF.IsRtlPara() ? &lvRTL : &lvLTR;

        delta = rp.SetFormat(iPF, cch, pf, pLevel); // Set format for this run
        if(!fFullyDefined)                      // Release count from Cache above
            pf->Release(iPF);                   // rp.SetFormat AddRefs as needed

        if(delta == CP_INFINITE)
        {
            ped->GetCallMgr()->SetOutOfMemory();
            break;
        }
        cch -= delta;
    } while (cch > 0) ;
    if(fFullyDefined)
        pf->Release(iPF);                       // Release count from Cache above

    _rpPF.AdjustBackward();                     // If at BOR, go to prev EOR
    rp.MergeRuns(_rpPF._iRun, pf);              // Merge any adjacent runs
                                                //  that have the same format
    if(cchBack)                                 // Move _rpPF back to where it
        _rpPF.AdvanceCp(-cchBack);              //  was
    else                                        // Active end at range start:
        _rpPF.AdjustForward();                  //  don't leave at EOR

    if(pnm)
    {
        pnm->NotifyPostReplaceRange(this,       // Notify interested parties of
            CP_INFINITE, 0, 0, cpMin,   cpMost);    //  the update
    }

    if(publdr)
    {
        // Paraformatting works a bit differently, it just remembers the
        // current selection. Cast selection to range to avoid including
        // _select.h; we only need range methods.
        CTxtRange *psel = (CTxtRange *)GetPed()->GetSel();
        if(psel)
        {
            cp  = psel->GetCp();
            HandleSelectionAEInfo(ped, publdr, cp, psel->GetCch(),
                                  cp, psel->GetCch(), SELAE_FORCEREPLACE);
        }
    }

    ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);

    AssertSz(GetCp() == (cp = _rpPF.CalculateCp()),
        "RTR::SetParaFormat(): incorrect format-run ptr");


    if (fLevelChanged && cpMost > cpMin)
    {
        ped->OrCharFlags(fBIDI, publdr);

        // make sure the CF is valid
        Check_rpCF();

        CTxtRange   rg(*this);

        if (publdr)
        {
            // create anti-events to keep BiDi level of paragraphs in need
            //
            ICharFormatCache*   pcfc = GetCharFormatCache();
            CFormatRunPtr       rp(_rpCF);

            rp.AdvanceCp(cpMin - _rpTX.GetCp());

            IAntiEvent *pae = gAEDispenser.CreateReplaceFormattingAE (
                                ped, rp, cpMost - cpMin, pcfc, CharFormat);
            if (pae)
                publdr->AddAntiEvent(pae);
        }
        rg.Set(cpMost, cpMost - cpMin);
        rg.ItemizeRuns (publdr);
    }

    return (hr == NOERROR && cch) ? S_FALSE : hr;
}

/*
 *  CTxtRange::SetParaStyle(pPF, publdr, dwMask)
 *
 *  @mfunc
 *      apply CParaFormat *pPF using the style pPF->sStyle to this range.
 *
 *  @rdesc
 *      if successfully set whole range, return NOERROR, otherwise
 *      return error code or S_FALSE.
 *
 *  @comm
 *      If pPF->dwMask & PFM_STYLE is nonzero, this range is expanded to
 *      complete paragraphs.  If it's zero, this call just passes control
 *      to CTxtRange::SetParaStyle().
 */
 HRESULT CTxtRange::SetParaStyle (
    const CParaFormat* pPF,     //@parm CParaFormat to apply to this range
    IUndoBuilder *publdr,       //@parm Undo context for this operation
    DWORD         dwMask)       //@parm Mask to use
{
    LONG    cchSave = _cch;         // Save range cp and cch in case
    LONG    cpSave  = GetCp();      //  para expand needed
    HRESULT hr;

    if(publdr)
        publdr->StopGroupTyping();

    if(pPF->fSetStyle(dwMask))
    {
        CCharFormat CF;             // Need to apply associated CF

        LONG cpMin, cpMost;
        Expander(tomParagraph, TRUE, NULL, &cpMin, &cpMost);

        CF._sStyle = pPF->_sStyle;
        hr = SetCharFormat(&CF, 0, publdr, CFM_STYLE, 0);
        if(hr != NOERROR)
            return hr;
    }
    hr = SetParaFormat(pPF, publdr, dwMask);
    Set(cpSave, cchSave);           // Restore this range in case expanded
    return hr;
}

/*
 *  CTxtRange::Update_iFormat(iFmtDefault)
 *
 *  @mfunc
 *      update _iFormat to CCharFormat at current active end
 *
 *  @devnote
 *      _iFormat is only used when the range is degenerate
 *
 *      The Word 95 UI specifies that the *previous* format should
 *      be used if we're in at an ambiguous cp (i.e. where a formatting
 *      change occurs) _unless_ the previous character is an EOP
 *      marker _or_ if the previous character is protected.
 */
void CTxtRange::Update_iFormat (
    LONG iFmtDefault)       //@parm Format index to use if _rpCF isn't valid
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Update_iFormat");

    DWORD   dwEffects;
    LONG    ifmt, iFormatForward;
    const CCharFormat *pCF, *pCFForward;

    if(_cch)
        return;

    _fSelHasEOP  = FALSE;                       // Empty ranges don't contain
    _fSelHasCell = FALSE;                       //  anything, incl EOPs/cells

    if(_fDontUpdateFmt)                         // _iFormat is only used
        return;                                 //  for degenerate ranges

    if(_rpCF.IsValid() && iFmtDefault == -1)
    {
        // Get forward info before possibly adjusting backward
        _rpCF.AdjustForward();
        ifmt = iFormatForward = _rpCF.GetFormat();
        pCF  = pCFForward = GetPed()->GetCharFormat(ifmt);
        dwEffects = pCF->_dwEffects;

        if(!_rpTX.IsAfterEOP())
        {
            _rpCF.AdjustBackward();                 // Adjust backward
            ifmt = _rpCF.GetFormat();
            pCF = GetPed()->GetCharFormat(ifmt);
            dwEffects = pCF->_dwEffects;
        }

        if (!(GetPed()->_fIMEInProgress))       // Dont change fomrat during IME
        {
            if(!_rpTX.GetCp() && (pCF->_dwEffects & CFE_RUNISDBCS))
            {
                // If at beginning of document, and text is protected, just use
                // default format.
                ifmt = iFmtDefault;
            }
            else if(dwEffects & (CFE_PROTECTED | CFE_LINK | CFE_HIDDEN | CFE_RUNISDBCS))
            {
                // If range is protected or a hyperlink, pick forward format
                ifmt = iFormatForward;
            }
            else if(ifmt != iFormatForward && _fMoveBack &&
                IsRTLCharSet(pCF->_bCharSet) != IsRTLCharSet(pCFForward->_bCharSet))
            {
                ifmt = iFormatForward;
            }
        }
        iFmtDefault = ifmt;
    }

    // Don't allow _iFormat to include CFE_LINK or CFE_HIDDEN attributes
    // unless they're the default
    if(iFmtDefault != -1)
    {
        pCF = GetPed()->GetCharFormat(iFmtDefault);
        if(pCF->_dwEffects & (CFE_LINK | CFE_HIDDEN))
        {
            CCharFormat CF = *pCF;
            CF._dwEffects &= ~(CFE_LINK | CFE_HIDDEN);

            // This range must be an insertion point!
            Assert(_cch == 0);
            SetCharFormat(&CF, FALSE, NULL, CFM_ALL2, 0);
            return;
        }
    }
    Set_iCF(iFmtDefault);
}

/*
 *  CTxtRange::GetCharSetMask(fUseDocFormat)
 *
 *  @mfunc
 *      Get this range's charset mask corresponding to _iFormat.
 *      If fUseDocFormat is TRUE, then use -1 instead of _iFormat.
 *
 *  @rdesc
 *      charset mask for range or default document
 */
DWORD CTxtRange::GetCharSetMask(
    BOOL fUseDocFormat)
{
    LONG iFormat = fUseDocFormat ? -1 : GetiFormat();
    DWORD dwMask = GetFontSig((GetPed()->GetCharFormat(iFormat))->_bCharSet) << 8;

    if(dwMask & fSYMBOL)
        return dwMask;

    // For now, Indic fonts match only ASCII digits
    dwMask |= fBELOWX40;
    if (dwMask < fDEVANAGARI)
        dwMask |= fASCII;                               // fASCIIUPR+fBELOWX40

    if ((dwMask & (fKANA | fHANGUL | fCHINESE | fBIG5))
        && W32->IsFESystem() )                          // For FE systems
            dwMask |= fOTHER;                           //  match fOTHER

    else if(dwMask & fLATIN)
        dwMask |= fCOMBINING;

    return dwMask;
}

/*
 *  CTxtRange::GetiFormat()
 *
 *  @mfunc
 *      Return (!_cch || _fUseiFormat) ? _iFormat : iFormat at cpMin
 *
 *  @rdesc
 *      iFormat at cpMin if nondegenerate and !_fUseiFormat; else _iFormat
 *
 *  @devnote
 *      This routine doesn't AddRef iFormat, so it shouldn't be used if
 *      it needs to be valid after character formatting has changed, e.g.,
 *      by ReplaceRange or SetCharFormat or SetParaStyle
 */
LONG CTxtRange::GetiFormat() const
{
    if(!_cch || _fUseiFormat)
        return _iFormat;

    if(_cch > 0)
    {
        CFormatRunPtr rp(_rpCF);
        rp.AdvanceCp(-_cch);
        return rp.GetFormat();
    }
    return _rpCF.GetFormat();
}

/*
 *  CTxtRange::Get_iCF()
 *
 *  @mfunc
 *      Get this range's _iFormat (AddRef'ing, of course)
 *
 *  @devnote
 *      Get_iCF() is used by the RTF reader
 */
LONG CTxtRange::Get_iCF ()
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Get_iCF");

    GetCharFormatCache()->AddRef(_iFormat);
    return _iFormat;
}

/*
 *  CTxtRange::Set_iCF(iFormat)
 *
 *  @mfunc
 *      Set range's _iFormat to iFormat, AddRefing and Releasing as required.
 *
 *  @rdesc
 *      TRUE if _iFormat changed
 */
BOOL CTxtRange::Set_iCF (
    LONG iFormat)               //@parm Index of char format to use
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Set_iCF");

    if(iFormat == _iFormat)
        return FALSE;

    ICharFormatCache *pCFC = GetCharFormatCache();

    pCFC->AddRef(iFormat);
    pCFC->Release(_iFormat);            // Note: _iFormat = -1 doesn't
    _iFormat = iFormat;                 //  get AddRef'd or Release'd

    AssertSz(GetCF(), "CTxtRange::Set_iCF: illegal format");
    return TRUE;
}

/*
 *  CTxtRange::Get_iPF()
 *
 *  @mfunc
 *      Get paragraph format at active end
 *
 *  @devnote
 *      Get_iPF() is used by the RTF reader on encountering a start group
 */
LONG CTxtRange::Get_iPF ()
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Get_iPF");

    LONG iPF = _rpPF.GetFormat();

    GetParaFormatCache()->AddRef(iPF);
    return iPF;
}

/*
 *  CTxtRange::BiDiLevelFromFSM(pFSM)
 *
 *  @mfunc
 *      Run BiDi FSM to generate proper embedding level for runs
 *
 *  @rdesc
 *      HRESULT
 */
HRESULT CTxtRange::BiDiLevelFromFSM (
    const CBiDiFSM* pFSM)       // in: ptr to FSM
{
    AssertSz(pFSM && _rpCF.IsValid(), "Not enough information to run BiDi FSM");

    LONG                cpMin, cpMost, cp, cchLeft;
    LONG                ich, cRunsStart, cRuns = 0;
    HRESULT             hr = S_OK;

    GetRange(cpMin, cpMost);

    AssertSz (cpMost - cpMin > 0, "FSM: Invalid range");

    CRchTxtPtr          rtp(*this);

    rtp.Advance(cpMin - rtp.GetCp());               // initiate position to cpMin
    CFormatRunPtr   rpPF(rtp._rpPF);                // pointer to current paragraph

    cchLeft = cpMost - cpMin;
    cp = cpMin;

    while (cchLeft > 0 && SUCCEEDED(hr))
    {
        // accumulate runs within the same paragraph level
        cRuns = GetRunsPF(&rtp, &rpPF, cchLeft);
        cRunsStart = 0;                             // assume no start run

        ich = rtp.Advance(-rtp.GetIchRunCF());      // locate preceding run
        rtp._rpCF.AdjustBackward();                 // adjusting format backward
        rtp._rpPF.AdjustBackward();                 // adjusting format backward

        if(rtp._rpPF.SameLevel(&rpPF))
        {
            // start at the beginning of preceding run
            if (rtp.Advance(-rtp.GetCchRunCF()))
                cRunsStart++;
        }
        else
        {
            // preceding run is not at the same paragraph level, resume position
            rtp.Advance(-ich);
        }

        rtp._rpCF.AdjustForward();                  // make sure we have forward run pointers
        rtp._rpPF.AdjustForward();

        // Run FSM for the number of runs in multiple paragraphs with the same level
        hr = pFSM->RunFSM(&rtp, cRuns, cRunsStart, rtp.IsParaRTL() ? 1 : 0);

        cp = cpMost - cchLeft;
        rtp.Advance(cp - rtp.GetCp());              // Advance to next paragraph(s)
        rpPF = rtp._rpPF;                           // paragraph format at cp
    }

    AssertSz (cp == cpMost , "Running BiDi FSM partially done!");

    _rpCF = rtp._rpCF;                              // We may have splitted CF runs

    return hr;
}

/*
 *  CTxtRange::GetRunsPF(prtp, prpPF, cchLeft)
 *
 *  @mfunc
 *      Get the number of CF runs within the same paragraph's base level.
 *  Its scope could cover multiple paragraphs. As long as they are in the
 *  same level, we can run them through the FSM in one go.
 *
 */
LONG CTxtRange::GetRunsPF(
    CRchTxtPtr*         prtp,       // in: RichText ptr to the first run in range
    CFormatRunPtr*      prpPF,      // in: Pointer to current paragraph run
    LONG&               cchLeft)    // in/out: number of char left
{
    Assert (prtp && prtp->_rpPF.SameLevel(prpPF) && cchLeft > 0);

    LONG                cRuns = 0;
    LONG                cchRun, cchText = cchLeft;
    ICharFormatCache*   pf = GetCharFormatCache();


    // check if the first CF run is PF bound
    //

    prtp->_rpPF.AdjustBackward();

    if (prtp->GetIchRunCF() > 0 && !prtp->_rpPF.SameLevel(prpPF))
        prtp->_rpCF.SplitFormat(pf);                    // PF breaks inside a CF run, split the run

    prtp->_rpPF.AdjustForward();                        // make sure we are all forward.
    prtp->_rpCF.AdjustForward();


    while (cchText > 0)
    {
        cchRun = min(prtp->GetCchLeftRunPF(), prtp->GetCchLeftRunCF());
        cchRun = min(cchText, cchRun);                  // find out the nearest hop
        cchText -= cchRun;

        prtp->Advance(cchRun);                          // to the next hop

        if (!prtp->_rpPF.SameLevel(prpPF))
        {                                               // this is a para with different level
            prtp->_rpCF.SplitFormat(pf);                // split that CF run
            cRuns++;                                    // count the splitted
            break;                                      // and we're done
        }

        if (!cchText ||                                 // this is the last hop -or-
            !prtp->GetIchRunCF() ||                     // we're at the start or the end of a CF run
            !prtp->GetCchLeftRunCF())
        {
            cRuns++;                                    // count this hop
        }
    }

    prtp->Advance(cchText - cchLeft);                   // resume position
    cchLeft = cchText;                                  // update number of char left

    return cRuns;
}


/*
 *  CTxtRange::SpanSubstringDir (pusp, prtp, cchString, puInitLevel, pfNumericFound)
 *
 *  @mfunc
 *      Span the run of text bound by or contains only block separators
 *      and share the same charset directionality.
 *
 *  @rdesc
 *      number of span'ed text characters
 *
 */
LONG CTxtRange::SpanSubstring(
    CUniscribe*     pusp,           // in: Uniscribe interface
    CFormatRunPtr*  prp,            // in: Format run pointer
    WCHAR*          pwchString,     // in: Input string
    LONG            cchString,      // in: String character count
    WORD&           uSubStrLevel,   // in/out: BiDi substring initial level
    DWORD           dwInFlags,      // in: Input flags
	CCharFlags*		pCharflags,		// out:Output charflags
    WORD&           wBiDiLangId)    // out:The primary language of a BiDi run
{
    Assert (pusp && cchString > 0 && prp && prp->IsValid());

    LONG                cch, cchLeft;

    cch = cchLeft = cchString;

    wBiDiLangId = LANG_NEUTRAL;     // assume unknown

    if (dwInFlags & SUBSTR_INSPANCHARSET)
    {
        // span runs with same charset's direction

        CTxtEdit*           ped = GetPed();
        CFormatRunPtr       rp(*prp);
        const CCharFormat*  pCF;
        BOOL                fNext;
        BYTE                bCharSet1, bCharSet2;

        rp.AdjustForward();

        pCF = ped->GetCharFormat(rp.GetFormat());

        bCharSet1 = bCharSet2 = pCF->_bCharSet;

        while (!(bCharSet1 ^ bCharSet2))
        {
            cch = min(rp.GetCchLeft(), cchLeft);
            cchLeft -= cch;

            if (!(fNext = rp.NextRun()) || !cchLeft)
                break;

            bCharSet1 = bCharSet2;

            pCF = ped->GetCharFormat(rp.GetFormat());
            bCharSet2 = pCF->_bCharSet;
        }
        uSubStrLevel = IsBiDiCharSet(bCharSet1) ? 1 : 0;

        if (uSubStrLevel & 1)
            wBiDiLangId = bCharSet1 == ARABIC_CHARSET ? LANG_ARABIC : LANG_HEBREW;

        cchString -= cchLeft;
        cch = cchString;

        dwInFlags |= SUBSTR_INSPANBLOCK;
    }

    if (dwInFlags & SUBSTR_INSPANBLOCK)
    {
        // scan the whole substring to collect information about it

        DWORD   dwBS = IsEOP(*pwchString) ? 1 : 0;
		BYTE	bCharMask;

        cch = 0;

		if (pCharflags)
			pCharflags->_bFirstStrong = pCharflags->_bContaining = 0;

        while (cch < cchString && !((IsEOP(pwchString[cch]) ? 1 : 0) ^ dwBS))
        {
			if (!dwBS && pCharflags)
			{
				bCharMask = 0;
	
				switch (MECharClass(pwchString[cch]))
				{
					case CC_ARABIC:
					case CC_HEBREW:
					case CC_RTL:
							bCharMask = SUBSTR_OUTCCRTL;
							break;
					case CC_LTR:
							bCharMask = SUBSTR_OUTCCLTR;
					default:
							break;
				}
	
				if (bCharMask)
				{
					if (!pCharflags->_bFirstStrong)
						pCharflags->_bFirstStrong |= bCharMask;
	
					pCharflags->_bContaining |= bCharMask;
				}
			}
            cch++;
        }
    }

    return cch;
}

/*
 *  CTxtRange::ItemizeRuns(publdr, fUnicodeBidi, iCtxBaseLevel)
 *
 *  @mfunc
 *      Break text range into smaller run(s) containing
 *
 *      1. Script ID for complex script shaping
 *      2. Charset for run internal direction
 *      3. BiDi embedding level
 *
 *  @rdesc
 *      TRUE iff one or more items found.
 *      The range's active end will be at cpMost upon return.
 *
 *  @devnote
 *      This routine could handle mixed paragraph runs
 */
BOOL CTxtRange::ItemizeRuns(
    IUndoBuilder	*publdr,        //@parm Undo context for this operation
    BOOL			fUnicodeBiDi,   //@parm TRUE: Caller needs Bidi algorithm
    BOOL			fUseCtxLevel)	//@parm Itemize using context based level (only valid if fUnicodeBiDi is true)
{
    LONG            cchString;
    int             cItems = 0;
    LONG            cpMin, cpMost;
    CTxtEdit*       ped = GetPed();
    CFreezeDisplay  fd(ped->_pdp);      // Freeze display
    int             i;
    BYTE            pbBufIn[MAX_CLIENT_BUF];
    PUSP_CLIENT     pc = NULL;
    const CBiDiFSM* pFSM;
    SCRIPT_ITEM*    psi;
    CUniscribe*     pusp;
    CTxtPtr         tp(_rpTX);
    LONG            cp, cch, cchSave;
    HRESULT         hr = E_FAIL;
    CCharFormat     CF;
    BOOL            fWhiteChunk;                            // Chunk contains only whitespaces
    WCHAR*          pwchString;
    WORD            uSubStrLevel;                           // Substring initial level
    WORD            uParaLevel;                             // Paragraph initial level
    CNotifyMgr*     pnm = NULL;                             // Notification manager
    BOOL            fRunUnicodeBiDi;
    BOOL            fStreaming = ped->IsStreaming();
    BOOL            fChangeCharSet = FALSE;
	CCharFlags		charflags = {0};
    WORD            wBiDiLangId;
#ifdef DEBUG
    LONG            cchText = tp.GetTextLength();
#endif

    // Get range and setup text ptr to the start
    //
    cch = cchString = GetRange(cpMin, cpMost);

    if (!cch)
        return FALSE;

    tp.SetCp(cpMin);

    // prepare Uniscribe
    pusp = ped->Getusp();
    if (!pusp)
        goto Exit;

    // allocate temp buffer for itemization
    pusp->CreateClientStruc(pbBufIn, MAX_CLIENT_BUF, &pc, cchString, cli_Itemize);
    if (!pc)
        goto Exit;

    Assert (tp.GetCp() == cpMin);


    if(pnm = ped->GetNotifyMgr())
        pnm->NotifyPreReplaceRange(this, CP_INFINITE, 0, 0, cpMin, cpMost);


    cp = cpMin;         // Set cp starting point at cpMin
    Set(cp, 0);         // equals to Collapser(tomStart)
    SetExtend(TRUE);

    Check_rpCF();       // Make sure _rpCF is valid
    Check_rpPF();       // _rpPF too


    // Always run UnicodeBidi for plain text control
    // (2.1 backward compatible)
    //
    if (!ped->IsRich())
    {
        fUnicodeBiDi = TRUE;
		fUseCtxLevel = FALSE;
    }

    uSubStrLevel = uParaLevel = IsParaRTL() ? 1 : 0;    // initialize substring level

    pwchString = pc->si->pwchString;
    tp.GetTextForUsp(cchString, pwchString, ped->_fNeutralOverride);

    while ( cchString > 0 &&
            ((cch = SpanSubstring(pusp, &_rpCF, pwchString, cchString, uSubStrLevel,
                    fUnicodeBiDi ? SUBSTR_INSPANBLOCK : SUBSTR_INSPANCHARSET,
					(fStreaming || fUseCtxLevel) ? &charflags : NULL,
                    wBiDiLangId)) > 0) )
    {
        cchSave = cch;
        fWhiteChunk = FALSE;

        if (uSubStrLevel ^ uParaLevel)
        {
            // Handle Bidi spaces when substring level counters paragraph base direction.

            // Spanning leading spaces
            cch = 0;
            while (cch < cchSave && pwchString[cch] == 0x20)
                cch++;

            if (cch)
                fWhiteChunk = TRUE;
            else
            {
                // Trimming out trailing whitespaces (including CR)
                cch = cchSave;
                while (cch > 0 && IsWhiteSpace(pwchString[cch-1]))
                    cch--;
                if (!cch)
                    cch = cchSave;
            }
            Assert(cch > 0);
        }

        // Itemize with Unicode Bidi algorithm when
        //   a. Plain text mode
        //   b. Caller wants (fUnicodeBidi != 0)
        //   c. Substring is RTL.
        //
        fRunUnicodeBiDi = fUnicodeBiDi || uSubStrLevel;
        fChangeCharSet = fUnicodeBiDi;

        if (!fUnicodeBiDi && uSubStrLevel == 1 && fStreaming)
        {
            // During RTF streaming if the RTL run contains strong LTR,
            // we resolve them using the paragraph base level
            if (charflags._bContaining & SUBSTR_OUTCCLTR)
                uSubStrLevel = uParaLevel;

            fChangeCharSet = TRUE;
        }


        // Caller wants context based level.
        // We want to itemize incoming plain text (into richtext doc) with the base level
        // of the first strong character found in each substrings (wchao - 7/15/99)
        //
		if (fUnicodeBiDi && fUseCtxLevel && charflags._bFirstStrong)
			uSubStrLevel = (WORD)(charflags._bFirstStrong & SUBSTR_OUTCCRTL ? 1 : 0);


        if (fWhiteChunk || pusp->ItemizeString (pc, uSubStrLevel, &cItems, pwchString, cch,
                                                fRunUnicodeBiDi, wBiDiLangId) > 0)
        {
            const SCRIPT_PROPERTIES*    psp;
            DWORD                       dwMask1;
            BYTE                        bCharSetDefault = ped->GetCharFormat(-1)->_bCharSet;

            psi = pc->si->psi;

            if (fWhiteChunk)
            {
                cItems = 1;
                psi[0].a.eScript = SCRIPT_WHITE;
                psi[0].iCharPos = 0;
                psi[1].iCharPos = cch;
            }

            Assert(cItems > 0);

            // process items
            //
            for (i=0; i < cItems; i++)
            {
                cp += psi[i+1].iCharPos - psi[i].iCharPos;
                AssertNr (cp <= cchText);
                SetCp(min(cp, cpMost));

                dwMask1 = 0;

                // Associate the script properties
                psp = pusp->GeteProp(psi[i].a.eScript);
                Assert (psp);

                if (!psp->fComplex && !psp->fNumeric &&
                    !psi[i].a.fRTL && psi[i].a.eScript < SCRIPT_MAX_COUNT)
                {
                    // Note: Value 0 here is a valid script ID (SCRIPT_UNDEFINED),
                    // guaranteed by Uniscribe to be available all the time
                    // so we're safe using it as our simplified script ID.
                    //
                    psi[i].a.eScript = 0;
                    psp = pusp->GeteProp(0);
                }

                CF._wScript = psi[i].a.eScript;

                // Stamp appropriate charset
                //
                if (pusp->GetComplexCharSet(psp, bCharSetDefault, CF._bCharSet))
                {
                    // Complex script that has distinctive charset
                    dwMask1 |= CFM_CHARSET;
                }
                else if (fChangeCharSet)
                {
                    // We run UnicodeBidi to analyse the whole thing so
                    // we need to figure out the proper charset to use as well.
                    //

                    // Note that we dont want to apply charset in general, say things
                    // like FarEast or GREEK_CHARSET should remain unchanged by
                    // this effect. But doing charset check is tough since we deal
                    // with text in range basis, so we simply call to update it here
                    // and let CCharFormat::Apply do the charset test in down level.

                    CF._bCharSet = psp->bCharSet;   // assume what Uniscribe has given us

                    if (psi[i].a.fRTL || psi[i].a.fLayoutRTL)
                    {
                        // those of strong RTL and RTL digits need RTL charset
                        CF._bCharSet = pusp->GetRtlCharSet(ped);
                    }

                    Assert(CF._bCharSet != DEFAULT_CHARSET);
                    dwMask1 |= CFM_CHARSET;
                }

                // no publdr for this call so no antievent for itemized CF
                SetCharFormat(&CF, SCF_IGNORENOTIFY, NULL, dwMask1, CFM2_SCRIPT);
                Set(cp, 0);
            }
        }
        else
        {
            // Itemization fails.

            cp += cch;
            SetCp(min(cp, cpMost));

            // reset script id to 0
            CF._wScript = 0;
            SetCharFormat(&CF, SCF_IGNORENOTIFY, NULL, 0, CFM2_SCRIPT);
            Set(cp, 0);
        }
        pwchString = &pc->si->pwchString[cp - cpMin];   // point to next substring
        cchString -= cch;
        uParaLevel = IsParaRTL() ? 1 : 0;               // paragraph level might have changed
    }

    Assert (cpMost == cp);

    // restore original range
    Set(cpMost, cpMost - cpMin);

    // retrieve ptr to Bidi FSM
    pFSM = pusp->GetFSM();

    if (pFSM)
        hr = BiDiLevelFromFSM (pFSM);

    AssertSz(SUCCEEDED(hr), "Unable to run or running BiDi FSM fails! We are in deep trouble,");


    if (pc && pbBufIn != (BYTE*)pc)
        FreePv(pc);

    // update flags
    ped->_fItemizePending = FALSE;


    // Notify backing store change to all notification sinks
    if(pnm)
        pnm->NotifyPostReplaceRange(this, CP_INFINITE, 0, 0, cpMin, cpMost);


Exit:
    return cItems > 0;
}

/*
 *  CTxtRange::IsProtected(iDirection)
 *
 *  @mfunc
 *      Return TRUE if any part of this range is protected (HACK:  or
 *      if any part of the range contains DBCS text stored in our Unicode
 *      backing store).  If degenerate,
 *      use CCharFormat from run specified by iDirection, that is, use run
 *      valid up to, at, or starting at this GetCp() for iDirection less, =,
 *      or greater than 0, respectively.
 *
 *  @rdesc
 *      TRUE iff any part of this range is protected (HACK:  or if any part
 *      of the range contains DBCS text stored in our Unicode backing store
 *      For this to work correctly, GetCharFormat() needs to return dwMask2
 *      as well).
 */
BOOL CTxtRange::IsProtected (
    LONG iDirection)    //@parm Controls which run to check if range is IP
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::IsProtected");

    CCharFormat CF;
    LONG        iFormat = -1;                   // Default default CF

    _TEST_INVARIANT_

    if(_rpCF.IsValid())                         // Active rich-text runs
    {
        if(_cch)                                // Range is nondegenerate
        {
            DWORD dwMask = GetCharFormat(&CF);
            if(CF._dwEffects & CFE_RUNISDBCS)
                return PROTECTED_YES;

            if (!(dwMask & CFM_PROTECTED) ||
                (CF._dwEffects & CFE_PROTECTED))
            {
                return PROTECTED_ASK;
            }
            return PROTECTED_NO;
        }
        iFormat = _iFormat;                     // Degenerate range: default
        if(iDirection != 0)                     //  this range's iFormat
        {                                       // Specific run direction
            CFormatRunPtr rpCF(_rpCF);

            if(iDirection < 0)                  // If at run ambiguous pos,
                rpCF.AdjustBackward();          //  use previous run
            else
                rpCF.AdjustForward();

            iFormat = rpCF.GetFormat();         // Get run format
        }
    }

    const CCharFormat *pCF = GetPed()->GetCharFormat(iFormat);

    if(pCF->_dwEffects & CFE_RUNISDBCS)
        return PROTECTED_YES;

    if(pCF->_dwEffects & CFE_PROTECTED)
        return PROTECTED_ASK;

    return PROTECTED_NO;
}

/*
 *  CTxtRange::AdjustEndEOP (NewChars)
 *
 *  @mfunc
 *      If this range is a selection and ends with an EOP and consists of
 *      more than just this EOP and fAdd is TRUE, or this EOP is the final
 *      EOP (at the story end), or this selection doesn't begin at the start
 *      of a paragraph, then move cpMost just before the end EOP. This
 *      function is used by UI methods that delete the selected text, such
 *      as PutChar(), Delete(), cut/paste, drag/drop.
 *
 *  @rdesc
 *      TRUE iff range end has been adjusted
 *
 *  @devnote
 *      This method leaves the active end at the selection cpMin.  It is a
 *      CTxtRange method to handle the selection when it mascarades as a
 *      range for Cut/Paste.
 */
BOOL CTxtRange::AdjustEndEOP (
    EOPADJUST NewChars)         //@parm NEWCHARS if chars will be added
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtRange::AdjustEndEOP");

    LONG cpMin, cpMost;
    LONG cch = GetRange(cpMin, cpMost);
    LONG cchSave = _cch;
    BOOL fRet = FALSE;

    if(cch && (cch < GetTextLength() || NewChars == NEWCHARS))
    {
        LONG    cchEOP = GetPed()->fUseCRLF() ? 2 : 1;
        CTxtPtr tp(_rpTX);

        if(_cch > 0)                            // Ensure active end is cpMin
            FlipRange();                        // (ReplaceRange() needs to
        else                                    //  do this anyhow)
            tp.AdvanceCp(-_cch);                // Ensure tp is at cpMost

        if(tp.IsAfterEOP())                     // Don't delete EOP at sel
        {                                       //  end if EOP isn't end of
            CPFRunPtr rp(*this);                //  table row and if there're
            rp.AdvanceCp(-_cch);                //  chars to add, or cpMin
            rp.AdjustBackward();                //  isn't at BOP and more than
                                                //  EOP is selected
            if(!rp.InTable() &&
               (NewChars == NEWCHARS ||
                cpMin && !_rpTX.IsAfterEOP() && cch > cchEOP))
            {
                _cch -= tp.BackupCpCRLF();      // Shorten range before EOP
                                                // Note: the -= _adds_ to a
                Update_iFormat(-1);             //  negative _cch to make
                fRet = TRUE;                    //  it less negative
            }
        }
        if((_cch ^ cchSave) < 0 && _fSel)       // Keep active end the same
            FlipRange();                        //  for selection undo
    }
    return fRet;
}

/*
 *  CTxtRange::DeleteTerminatingEOP (publdr)
 *
 *  @mfunc
 *      If this range is an insertion point that follows an EOP, select
 *      and delete that EOP
 */
void CTxtRange::DeleteTerminatingEOP(
    IUndoBuilder *publdr)
{
    Assert(!_cch);
    if(_rpTX.IsAfterEOP())
    {
        SetExtend(TRUE);
        BackupCRLF();
        ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE);
    }
}

/*
 *  CTxtRange::CheckTextLength(cch)
 *
 *  @mfunc
 *      Check to see if can add cch characters. If not, notify parent
 *
 *  @rdesc
 *      TRUE if OK to add cch chars
 */
BOOL CTxtRange::CheckTextLength (
    LONG cch,
    LONG *pcch)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CheckTextLength");

    _TEST_INVARIANT_

    DWORD cchNew = (DWORD)(CalcTextLenNotInRange() + cch);

    if(cchNew > GetPed()->TxGetMaxLength())
    {
        if (pcch)
            *pcch = cchNew - GetPed()->TxGetMaxLength();
        else
            GetPed()->GetCallMgr()->SetMaxText();

        return FALSE;
    }
    return TRUE;
}

/*
 *  CTxtRange::FindObject(pcpMin, pcpMost)
 *
 *  @mfunc
 *      Set *pcpMin  = closest embedded object cpMin <lt>= range cpMin
 *      Set *pcpMost = closest embedded object cpMost <gt>= range cpMost
 *
 *  @rdesc
 *      TRUE iff object found
 *
 *  @comm
 *      An embedded object cpMin points at the first character of an embedded
 *      object. For RichEdit, this is the WCH_EMBEDDING character.  An
 *      embedded object cpMost follows the last character of an embedded
 *      object.  For RichEdit, this immediately follows the WCH_EMBEDDING
 *      character.
 */
BOOL CTxtRange::FindObject(
    LONG *pcpMin,       //@parm Out parm to receive object's cpMin;  NULL OK
    LONG *pcpMost) const//@parm Out parm to receive object's cpMost; NULL OK
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindObject");

    if(!GetObjectCount())                   // No objects: can't move, so
        return FALSE;                       //  return FALSE

    BOOL    bRet = FALSE;                   // Default no object
    LONG    cpMin, cpMost;
    CTxtPtr tp(_rpTX);

    GetRange(cpMin, cpMost);
    if(pcpMin)
    {
        tp.SetCp(cpMin);
        if(tp.GetChar() != WCH_EMBEDDING)
        {
            cpMin = tp.FindExact(tomBackward, szEmbedding);
            if(cpMin >= 0)
            {
                bRet = TRUE;
                *pcpMin = cpMin;
            }
        }
    }
    if(pcpMost)
    {
        tp.SetCp(cpMost);
        if (tp.PrevChar() != WCH_EMBEDDING &&
            tp.FindExact(tomForward, szEmbedding) >= 0)
        {
            bRet = TRUE;
            *pcpMost = tp.GetCp();
        }
    }
    return bRet;
}

/*
 *  CTxtRange::FindCell(pcpMin, pcpMost)
 *
 *  @mfunc
 *      Set *pcpMin  = closest cell cpMin  <lt>= range cpMin (see comment)
 *      Set *pcpMost = closest cell cpMost <gt>= range cpMost
 *
 *  @comment
 *      This function does nothing if the range isn't completely in a table.
 */
void CTxtRange::FindCell (
    LONG *pcpMin,           //@parm Out parm for bounding-cell cpMin
    LONG *pcpMost) const    //@parm Out parm for bounding-cell cpMost
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindCell");

    WCHAR       ch;
    LONG        cpMin, cpMost;
    CRchTxtPtr  rtp(*this);

    _TEST_INVARIANT_

    GetRange(cpMin, cpMost);

    if(pcpMin)
    {
        if(_cch > 0)
            rtp.Advance(-_cch);

        rtp._rpPF.AdjustBackward();
        if(rtp.InTable())
        {
            while(rtp.GetCp())
            {
                rtp.BackupCRLF();
                ch = rtp.GetChar();
                if(IsASCIIEOP(ch) || ch == CELL)
                {
                    rtp.AdvanceCRLF();
                    break;
                }
                Assert(rtp.InTable());
            }
        }
        *pcpMin = rtp.GetCp();
    }

    if(pcpMost)
    {
        rtp.SetCp(cpMost);
        if(rtp.InTable())
        {
            rtp.BackupCRLF();
            do
            {
                ch = rtp.GetChar();
                rtp.AdvanceCRLF();
                Assert(rtp.InTable());
            } while(ch && !IsASCIIEOP(ch) && ch != CELL);
        }
        *pcpMost = rtp.GetCp();
    }
}

/*
 *  CTxtRange::FindParagraph(pcpMin, pcpMost)
 *
 *  @mfunc
 *      Set *pcpMin  = closest paragraph cpMin  <lt>= range cpMin (see comment)
 *      Set *pcpMost = closest paragraph cpMost <gt>= range cpMost
 *
 *  @devnote
 *      If this range's cpMost follows an EOP, use it for bounding-paragraph
 *      cpMost unless 1) the range is an insertion point, and 2) pcpMin and
 *      pcpMost are both nonzero, in which case use the next EOP.  Both out
 *      parameters are nonzero if FindParagraph() is used to expand to full
 *      paragraphs (else StartOf or EndOf is all that's requested).  This
 *      behavior is consistent with the selection/IP UI.  Note that FindEOP
 *      treats the beginning/end of document (BOD/EOD) as a BOP/EOP,
 *      respectively, but IsAfterEOP() does not.
 */
void CTxtRange::FindParagraph (
    LONG *pcpMin,           //@parm Out parm for bounding-paragraph cpMin
    LONG *pcpMost) const    //@parm Out parm for bounding-paragraph cpMost
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindParagraph");

    LONG    cpMin, cpMost;
    CTxtPtr tp(_rpTX);

    _TEST_INVARIANT_

    GetRange(cpMin, cpMost);
    if(pcpMin)
    {
        tp.SetCp(cpMin);                    // tp points at this range's cpMin
        if(!tp.IsAfterEOP())                // Unless tp directly follows an
            tp.FindEOP(tomBackward);        //  EOP, search backward for EOP
        *pcpMin = cpMin = tp.GetCp();
    }

    if(pcpMost)
    {
        tp.SetCp(cpMost);                   // If range cpMost doesn't follow
        if (!tp.IsAfterEOP() ||             //  an EOP or else if expanding
            (!cpMost || pcpMin) &&
             cpMin == cpMost)               //  IP at paragraph beginning,
        {
            tp.FindEOP(tomForward);         //  search for next EOP
        }
        *pcpMost = tp.GetCp();
    }
}

/*
 *  CTxtRange::FindSentence(pcpMin, pcpMost)
 *
 *  @mfunc
 *      Set *pcpMin  = closest sentence cpMin  <lt>= range cpMin
 *      Set *pcpMost = closest sentence cpMost <gt>= range cpMost
 *
 *  @devnote
 *      If this range's cpMost follows a sentence end, use it for bounding-
 *      sentence cpMost unless the range is an insertion point, in which case
 *      use the next sentence end.  The routine takes care of aligning on
 *      sentence beginnings in the case of range ends that fall on whitespace
 *      in between sentences.
 */
void CTxtRange::FindSentence (
    LONG *pcpMin,           //@parm Out parm for bounding-sentence cpMin
    LONG *pcpMost) const    //@parm Out parm for bounding-sentence cpMost
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindSentence");

    LONG    cpMin, cpMost;
    CTxtPtr tp(_rpTX);

    _TEST_INVARIANT_

    GetRange(cpMin, cpMost);
    if(pcpMin)                              // Find sentence beginning
    {
        tp.SetCp(cpMin);                    // tp points at this range's cpMin
        if(!tp.IsAtBOSentence())            // If not at beginning of sentence
            tp.FindBOSentence(tomBackward); //  search backward for one
        *pcpMin = cpMin = tp.GetCp();
    }

    if(pcpMost)                             // Find sentence end
    {                                       // Point tp at this range's cpLim
        tp.SetCp(cpMost);                   // If cpMost isn't at sentence
        if (!tp.IsAtBOSentence() ||         //  beginning or if at story
            (!cpMost || pcpMin) &&          //  beginning or expanding
             cpMin == cpMost)               //  IP at sentence beginning,
        {                                   //  find next sentence beginning
            if(!tp.FindBOSentence(tomForward))
                tp.SetCp(GetTextLength());  // End of story counts as
        }                                   //  sentence end too
        *pcpMost = tp.GetCp();
    }
}

/*
 *  CTxtRange::FindVisibleRange(pcpMin, pcpMost)
 *
 *  @mfunc
 *      Set *pcpMin  = _pdp->_cpFirstVisible
 *      Set *pcpMost = _pdp->_cpLastVisible
 *
 *  @rdesc
 *      TRUE iff calculated cp's differ from this range's cp's
 *
 *  @devnote
 *      CDisplay::GetFirstVisible() and GetCliVisible() return the first cp
 *      on the first visible line and the last cp on the last visible line.
 *      These won't be visible if they are scrolled off the screen.
 *      FUTURE: A more general algorithm would CpFromPoint (0,0) and
 *      (right, bottom).
 */
BOOL CTxtRange::FindVisibleRange (
    LONG *pcpMin,           //@parm Out parm for cpFirstVisible
    LONG *pcpMost) const    //@parm Out parm for cpLastVisible
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindVisibleRange");

    _TEST_INVARIANT_

    CDisplay *  pdp = GetPed()->_pdp;

    if(!pdp)
        return FALSE;

    if(pcpMin)
        *pcpMin = pdp->GetFirstVisibleCp();

    pdp->GetCliVisible(pcpMost);

    return TRUE;
}

/*
 *  CTxtRange::FindWord(pcpMin, pcpMost, type)
 *
 *  @mfunc
 *      Set *pcpMin  = closest word cpMin  <lt>= range cpMin
 *      Set *pcpMost = closest word cpMost <gt>= range cpMost
 *
 *  @comm
 *      There are two interesting cases for finding a word.  The first,
 *      (FW_EXACT) finds the exact word, with no extraneous characters.
 *      This is useful for situations like applying formatting to a
 *      word.  The second case, FW_INCLUDE_TRAILING_WHITESPACE does the
 *      obvious thing, namely includes the whitespace up to the next word.
 *      This is useful for the selection double-click semantics and TOM.
 */
void CTxtRange::FindWord(
    LONG *pcpMin,           //@parm Out parm to receive word's cpMin; NULL OK
    LONG *pcpMost,          //@parm Out parm to receive word's cpMost; NULL OK
    FINDWORD_TYPE type) const //@parm Type of word to find
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindWord");

    LONG    cch, cch1;
    LONG    cpMin, cpMost;
    CTxtPtr tp(_rpTX);

    _TEST_INVARIANT_

    Assert(type == FW_EXACT || type == FW_INCLUDE_TRAILING_WHITESPACE );

    GetRange(cpMin, cpMost);
    if(pcpMin)
    {
        tp.SetCp(cpMin);
        if(!tp.IsAtBOWord())                            // cpMin not at BOW:
            cpMin += tp.FindWordBreak(WB_MOVEWORDLEFT); //  go there

        *pcpMin = cpMin;

        Assert(cpMin >= 0 && cpMin <= GetTextLength());
    }

    if(pcpMost)
    {
        tp.SetCp(cpMost);
        if (!tp.IsAtBOWord() ||                         // If not at word strt
            (!cpMost || pcpMin) && cpMin == cpMost)     //  or there but need
        {                                               //  to expand IP,
            cch = tp.FindWordBreak(WB_MOVEWORDRIGHT);   //  move to next word

            if(cch && type == FW_EXACT)                 // If moved and want
            {                                           //  word proper, move
                cch1 = tp.FindWordBreak(WB_LEFTBREAK);  //  back to end of
                if(cch + cch1 > 0)                      //  preceding word
                    cch += cch1;                        // Only do so if were
            }                                           //  not already at end
            cpMost += cch;
        }
        *pcpMost = cpMost;

        Assert(cpMost >= 0 && cpMost <= GetTextLength());
        Assert(cpMin <= cpMost);
    }
}

/*
 *  CTxtRange::FindAttributes(pcpMin, pcpMost, dwMask)
 *
 *  @mfunc
 *      Set *pcpMin  = closest attribute-combo cpMin  <lt>= range cpMin
 *      Set *pcpMost = closest attribute-combo cpMost <gt>= range cpMost
 *      The attribute combo is given by Unit and is any OR combination of
 *      TOM attributes, e.g., tomBold, tomItalic, or things like
 *      tomBold | tomItalic.  The combo is found if any of the attributes
 *      is present.
 *
 *  @devnote
 *      Plan to add other logical combinations: tomAND, tomExact
 */
void CTxtRange::FindAttributes (
    LONG *pcpMin,           //@parm Out parm for bounding-sentence cpMin
    LONG *pcpMost,          //@parm Out parm for bounding-sentence cpMost
    LONG Unit) const        //@parm TOM attribute mask
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindAttributes");
    LONG        cch;
    LONG        cpMin, cpMost;
    DWORD       dwMask = Unit & ~0x80000000;    // Kill sign bit
    CCFRunPtr   rp(*this);

    Assert(Unit < 0);
    GetRange(cpMin, cpMost);

    if(!rp.IsValid())                       // No CF runs instantiated
    {
        if(rp.IsMask(dwMask))               // Applies to default CF
        {
            if(pcpMin)
                *pcpMin = 0;
            if(pcpMost)
                *pcpMost = GetTextLength();
        }
        return;
    }

    // Start at cpMin
    if(_cch > 0)
        rp.AdvanceCp(-_cch);

    // Go backward until we don't match dwMask
    if(pcpMin)
    {
        rp.AdjustBackward();
        while(rp.IsMask(dwMask) && rp.GetIch())
        {
            cpMin -= rp.GetIch();
            rp.AdvanceCp(-rp.GetIch());
            rp.AdjustBackward();
        }
        *pcpMin = cpMin;
    }

    // Now go forward from cpMost until we don't match dwMask
    if(pcpMost)
    {
        rp.AdvanceCp(cpMost - cpMin);
        rp.AdjustForward();                 // In case cpMin = cpMost
        cch = rp.GetCchLeft();
        while(rp.IsMask(dwMask) && cch)
        {
            cpMost += cch;
            rp.AdvanceCp(cch);
            cch = rp.GetCchLeft();
        }
        *pcpMost = cpMost;
    }
}

/*
 *  CTxtRange::CalcTextLenNotInRange()
 *
 *  @mfunc
 *      Helper function that calculates the total length of text
 *      excluding the current range.
 *
 *  @comm
 *      Used for limit testing. The problem being solved is that
 *      the range can contain the final EOP which is not included
 *      in the adjusted text length.
 */
LONG CTxtRange::CalcTextLenNotInRange()
{
    LONG    cchAdjLen = GetPed()->GetAdjustedTextLength();
    LONG    cchLen = cchAdjLen - abs(_cch);
    LONG    cpMost = GetCpMost();

    if (cpMost > cchAdjLen)
    {
        // Selection extends beyond adjusted length. Put amount back in the
        // selection as it has become too small by the difference.
        cchLen += cpMost - cchAdjLen;
    }
    return cchLen;
}

////////////////////////// Outline Support //////////////////////////////////

/*
 *  CTxtRange::Promote(lparam, publdr)
 *
 *  @mfunc
 *      Promote selected text according to:
 *
 *      LOWORD(lparam) == 0 ==> promote to body-text
 *      LOWORD(lparam) != 0 ==> promote/demote current selection by
 *                              LOWORD(lparam) levels
 *  @rdesc
 *      TRUE iff promotion occurred
 *
 *  @devnote
 *      Changes this range
 */
HRESULT CTxtRange::Promote (
    LPARAM        lparam,   //@parm 0 to body, < 0 demote, > 0 promote
    IUndoBuilder *publdr)   //@parm undo builder to receive antievents
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtRange::Promote");

    if(abs(lparam) >= NHSTYLES)
        return E_INVALIDARG;

    if(publdr)
        publdr->StopGroupTyping();

    if(_cch > 0)                            // Point at cpMin
        FlipRange();

    LONG        cchText = GetTextLength();
    LONG        cpEnd = GetCpMost();
    LONG        cpMin, cpMost;
    BOOL        fHeading = TRUE;            // Default heading in range
    HRESULT     hr;
    LONG        Level;
    LONG        nHeading = NHSTYLES;        // Setup to find any heading
    CParaFormat PF;
    const CParaFormat *pPF;
    CPFRunPtr   rp(*this);
    LONG        cch = rp.FindHeading(abs(_cch), nHeading);
    WORD        wEffects;

    if(!lparam)                             // Demote to subtext
    {
        if(cch)                             // Already in subtext so don't
            return S_FALSE;                 //  need to demote

        CTxtPtr tp(_rpTX);

        if(!tp.IsAfterEOP())
            cch = tp.FindEOP(tomBackward);
        nHeading = 1;
        if(tp.GetCp())                      // Get previous level and convert
        {                                   //  to heading to set up
            rp.AdvanceCp(cch);              //  following Level code
            rp.AdjustBackward();
            nHeading = rp.GetOutlineLevel()/2 + 1;
        }
    }
    else if(cch == tomBackward)             // No heading in range
    {                                       // Set up to promote to
        nHeading = rp.GetOutlineLevel()/2   //  heading
                 + (lparam > 0 ? 2 : 1);
        fHeading = FALSE;                   // Signal no heading in range
    }
    else if(cch)                            // Range starts in subtext
    {
        SetExtend(TRUE);
        Advance(cch);                       // Bypass initial nonheading
    }

    Level = 2*(nHeading - 1);               // Heading level
    PF._bOutlineLevel = (BYTE)(Level | 1);  // Corresponding subtext level

    if (!Level && lparam > 0 ||             // Can't promote Heading 1
        nHeading == NHSTYLES && lparam < 0) //  or demote Heading 9
    {
        return S_FALSE;
    }
    do
    {
        _cch = 0;
        Level -= long(2*lparam);            // Promote Level
        pPF = GetPF();
        wEffects = pPF->_wEffects;
        if(pPF->_bOutlineLevel & 1)         // Handle contiguous text in
        {                                   //  one fell swoop
            cch = fHeading ? _rpPF.GetCchLeft() : cpEnd - GetCp();
            if(cch > 0)
            {
                SetExtend(TRUE);
                Advance(cch);
            }
        }
        Expander(tomParagraph, TRUE, NULL, &cpMin, &cpMost);

        if((unsigned)Level < 2*NHSTYLES)
        {                                   // Promoted Level is valid
            DWORD dwMask = PFM_OUTLINELEVEL;// Default setting subtext level
            if(!(Level & 1) && lparam)      // Promoting or demoting heading
            {                               // Preserve collapse status
                PF._wEffects = Level ? wEffects : 0; // H1 is aways expanded
                PF._sStyle = (SHORT)(-Level/2 + STYLE_HEADING_1);
                PF._bOutlineLevel = (BYTE)(Level | 1);// Set up subtext
                dwMask = PFM_STYLE + PFM_COLLAPSED;
            }
            else if(!lparam)                // Changing heading to subtext
            {                               //  or uncollapsing subtext
                PF._wEffects = 0;           // Turn off collapsed
                PF._sStyle = STYLE_NORMAL;
                dwMask = PFM_STYLE + PFM_OUTLINELEVEL + PFM_COLLAPSED;
            }
            hr = SetParaStyle(&PF, publdr, dwMask);
            if(hr != NOERROR)
                return hr;
        }
        if(GetCp() >= cchText)              // Have handled last PF run
            break;
        Assert(_cch > 0);                   // Para/run should be selected
        pPF = GetPF();                      // Points at next para
        Level = pPF->_bOutlineLevel;
    }                                       // Iterate until past range &
    while((Level & 1) || fHeading &&        // any subtext that follows
          (GetCp() < cpEnd || pPF->_wEffects & PFE_COLLAPSED));

    return NOERROR;
}

/*
 *  CTxtRange::ExpandOutline(Level, fWholeDocument)
 *
 *  @mfunc
 *      Expand outline according to Level and fWholeDocument. Wraps
 *      OutlineExpander() helper function and updates selection/view
 *
 *  @rdesc
 *      NOERROR if success
 */
HRESULT CTxtRange::ExpandOutline(
    LONG Level,             //@parm If < 0, collapse; else expand, etc.
    BOOL fWholeDocument)    //@parm If TRUE, whole document
{
    if (!IsInOutlineView())
        return NOERROR;

    HRESULT hres = OutlineExpander(Level, fWholeDocument);
    if(hres != NOERROR)
        return hres;

    GetPed()->TxNotify(EN_PARAGRAPHEXPANDED, NULL);
    return GetPed()->UpdateOutline();
}

/*
 *  CTxtRange::OutlineExpander(Level, fWholeDocument)
 *
 *  @mfunc
 *      Expand/collapse outline for this range according to Level
 *      and fWholeDocument.  If fWholeDocument is TRUE, then
 *      1 <= Level <= NHSTYLES collapses all headings with numbers
 *      greater than Level and collapses all nonheadings. Level = -1
 *      expands all.
 *
 *      fWholeDocument = FALSE expands/collapses (Level > 0 or < 0)
 *      paragraphs depending on whether an EOP and heading are included
 *      in the range.  If Level = 0, toggle heading's collapsed status.
 *
 *  @rdesc
 *      (change made) ? NOERROR : S_FALSE
 */
HRESULT CTxtRange::OutlineExpander(
    LONG Level,             //@parm If < 0, collapse; else expand, etc.
    BOOL fWholeDocument)    //@parm If TRUE, whole document
{
    CParaFormat PF;

    if(fWholeDocument)                          // Apply to whole document
    {
        if (IN_RANGE(1, Level, NHSTYLES) ||     // Collapse to heading
            Level == -1)                        // -1 means all
        {
            Set(0, tomBackward);                // Select whole document
            PF._sStyle = (SHORT)(STYLE_COMMAND + (BYTE)Level);
            SetParaFormat(&PF, NULL, PFM_STYLE);// No undo
            return NOERROR;
        }
        return S_FALSE;                         // Nothing happened (illegal
    }                                           //  arg)

    // Expand/Collapse for Level positive/negative, respectively

    LONG cpMin, cpMost;                         // Get range cp's
    LONG cchMax = GetRange(cpMin, cpMost);
    if(_cch > 0)                                // Ensure cpMin is active
        FlipRange();                            //  for upcoming rp and tp

    LONG      nHeading = NHSTYLES;              // Setup to find any heading
    LONG      nHeading1;
    CTxtEdit *ped = GetPed();
    CPFRunPtr rp(*this);
    LONG      cch = rp.FindHeading(cchMax, nHeading);

    if(cch == tomBackward)                      // No heading found within range
        return S_FALSE;                         // Do nothing

    Assert(cch <= cchMax && (Level || !cch));   // cch is count up to heading
    CTxtPtr tp(_rpTX);
    cpMin += cch;                               // Bypass any nonheading text
    tp.AdvanceCp(cch);                          //  at start of range

    // If toggle collapse or if range contains an EOP,
    // collapse/expand all subordinates
    cch = tp.FindEOP(tomForward);               // Find next para
    if(!cch)
        return NOERROR;

    if(!Level || cch < -_cch)                   // Level = 0 or EOP in range
    {
        if(!Level)                              // Toggle collapse status
        {
            LONG cchLeft = rp.GetCchLeft();
            if (cch < cchLeft || !rp.NextRun() ||
                nHeading == STYLE_HEADING_1 - rp.GetStyle() + 1)
            {
                return NOERROR;                 // Next para has same heading
            }
            Assert(cch == cchLeft);
            Level = rp.IsCollapsed();
            rp.AdvanceCp(-cchLeft);
        }
        PF._wEffects = Level > 0 ? 0 : PFE_COLLAPSED;
        while(cpMin < cpMost)
        {                                       // We're at a heading
            tp.SetCp(cpMin);
            cch = tp.FindEOP(-_cch);
            cpMin += cch;                       // Bypass it
            if(!rp.AdvanceCp(cch))              // Point at next para
                break;                          // No more, we're done
            nHeading1 = nHeading;               // Setup to find heading <= nHeading
            cch = rp.FindHeading(tomForward, nHeading1);
            if(cch == tomBackward)              // No more higher headings
                cch = GetTextLength() - cpMin;  // Format to end of text
            Set(cpMin, -cch);                   // Collapse/expand up to here
            SetParaFormat(&PF, NULL, PFM_COLLAPSED);
            cpMin += cch;                       // Move past formatted area
            nHeading = nHeading1;               // Update nHeading to possibly
        }                                       //  lower heading #
        return NOERROR;
    }

    // Range contains no EOP: expand/collapse deepest level.
    // If collapsing, collapse all nonheading text too. Expand
    // nonheading text only if all subordinate levels are expanded.
    BOOL    fCollapsed;
    LONG    nHeadStart, nHeadDeepNC, nHeadDeep;
    LONG    nNonHead = -1;                      // No nonHeading found yet
    const CParaFormat *pPF;

    cpMin = tp.GetCp();                         // Point at start of
    cpMost = cpMin;                             //  next para
    pPF = ped->GetParaFormat(_rpPF.GetFormat());
    nHeading = pPF->_bOutlineLevel;

    Assert(!(nHeading & 1) &&                   // Must start with a heading
        !(pPF->_wEffects & PFE_COLLAPSED));     //  that isn't collapsed

    nHeadStart = nHeading/2 + 1;                // Convert outline level to
    nHeadDeep = nHeadDeepNC = nHeadStart;       //  heading number

    while(cch)                                  // Determine deepest heading
    {                                           //  and deepest collapsed
        rp.AdvanceCp(cch);                      //  heading
        pPF = ped->GetParaFormat(rp.GetFormat());
        fCollapsed = pPF->_wEffects & PFE_COLLAPSED;
        nHeading = pPF->_bOutlineLevel;
        if(nHeading & 1)                        // Text found
        {                                       // Set nNonHead > 0 if
            nNonHead = fCollapsed;              //  collapsed; else 0
            cch = rp.GetCchLeft();              // Zip to end of contiguous
            tp.AdvanceCp(cch);                  //  text paras
        }
        else                                    // It's a heading
        {
            nHeading = nHeading/2 + 1;          // Convert to heading number
            if(nHeading <= nHeadStart)          // If same or shallower as
                break;                          //  start heading we're done

            // Update deepest and deepest nonCollapsed heading #'s
            nHeadDeep = max(nHeadDeep, nHeading);
            if(!fCollapsed)
                nHeadDeepNC = max(nHeadDeepNC, nHeading);
            cch = tp.FindEOP(tomForward);       // Go to next paragraph
        }
        cpMost = tp.GetCp();                    // Include up to it
    }

    PF._sStyle = (SHORT)(STYLE_COMMAND + nHeadDeepNC);
    if(Level > 0)                               // Expand
    {
        if(nHeadDeepNC < nHeadDeep)             // At least one collapsed
            PF._sStyle++;                       //  heading: expand shallowest
        else                                    // All heads expanded: do others
            PF._sStyle = (unsigned short) (STYLE_COMMAND + 0xFF);
    }                                           // In any case, expand nonheading
    else if(nNonHead)                           // Collapse. If text collapsed
    {                                           //  or missing, do headings
        if(nHeadDeepNC == nHeadStart)
            return S_FALSE;                     // Everything already collapsed
        PF._sStyle--;                           // Collapse to next shallower
    }                                           //  heading

    Set(cpMin, cpMin - cpMost);                 // Select range to change
    SetParaFormat(&PF, NULL, PFM_STYLE);        // No undo
    return NOERROR;
}

/*
 *  CTxtRange::CheckOutlineLevel(publdr)
 *
 *  @mfunc
 *      If the paragraph style at this range isn't a heading, make
 *      sure its outline level is compatible with the preceeding one
 */
void CTxtRange::CheckOutlineLevel(
    IUndoBuilder *publdr)       //@parm Undo context for this operation
{
    LONG      LevelBackward, LevelForward;
    CPFRunPtr rp(*this);

    Assert(!_cch);

    rp.AdjustBackward();
    LevelBackward = rp.GetOutlineLevel() | 1;   // Nonheading level corresponding
                                                //  to previous PF run
    rp.AdjustForward();
    LevelForward = rp.GetOutlineLevel();

    if (!(LevelForward & 1) ||                  // Any heading can follow
        LevelForward == LevelBackward)          //  any style. Also if
    {                                           //  forward level is correct,
        return;                                 //  return
    }

    LONG        cch;                            // One or more nonheadings
    LONG        lHeading = NHSTYLES;            //  with incorrect outline
    CParaFormat PF;                             //  levels follow

    PF._bOutlineLevel = (BYTE)LevelBackward;        //  level

    cch = rp.FindHeading(tomForward, lHeading); // Find next heading
    if(cch == tomBackward)
        cch = tomForward;

    Set(GetCp(), -cch);                         // Select all nonheading text
    SetParaFormat(&PF, publdr, PFM_OUTLINELEVEL);// Change its outline level
    Set(GetCp(), 0);                            // Restore range to IP
}

#if defined(DEBUG)
/*
 *  CTxtRange::::DebugFont (void)
 *
 *  @mfunc
 *      Dump out the character and Font info for current selection.
 */
void CTxtRange::DebugFont (void)
{
    LONG            ch;
    LONG            cpMin, cpMost;
    LONG            cch = GetRange(cpMin, cpMost);
    LONG            i;
    char            szTempBuf[64];
    CTxtEdit        *ped = GetPed();
    const           WCHAR *wszFontname;
    const           CCharFormat *CF;                // Temporary CF
    const           WCHAR *GetFontName(LONG iFont);

    char            szTempPath[MAX_PATH] = "\0";
    DWORD           cchLength;
    HANDLE          hfileDump;
    DWORD           cbWritten;

    SideAssert(cchLength = GetTempPathA(MAX_PATH, szTempPath));

    // append trailing backslash if neccessary
    if(szTempPath[cchLength - 1] != '\\')
    {
        szTempPath[cchLength] = '\\';
        szTempPath[cchLength + 1] = 0;
    }

    strcat(szTempPath, "DumpFontInfo.txt");

    SideAssert(hfileDump = CreateFileA(szTempPath,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL));

    if(_cch > 0)                            // start from cpMin
        FlipRange();

    CFormatRunPtr rp(_rpCF);

    for (i=0; i <= cch; i++)
    {
        LONG    iFormat;

        if (GetChar(&ch) != NOERROR)
            break;

        if (ch <= 0x07f)
            sprintf(szTempBuf, "Char= '%c'\r\n", (char)ch);
        else
            sprintf(szTempBuf, "Char= 0x%x\r\n", ch);
        OutputDebugStringA(szTempBuf);
        if (hfileDump)
            WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);

        iFormat = rp.GetFormat();
        CF = ped->GetCharFormat(iFormat);
        Assert(CF);

        sprintf(szTempBuf, "Font iFormat= %d, Charset= %d, Size= %d\r\nName= ",
            iFormat, CF->_bCharSet, CF->_yHeight);
        OutputDebugStringA(szTempBuf);
        if (hfileDump)
            WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);

        wszFontname = GetFontName(CF->_iFont);
        if (wszFontname)
        {
            if (*wszFontname <= 0x07f)
            {
                szTempBuf[0] = '\'';
                WCTMB(CP_ACP, 0,
                        wszFontname, -1, &szTempBuf[1], sizeof(szTempBuf)-1,
                        NULL, NULL, NULL);
                strcat(szTempBuf,"\'");
                OutputDebugStringA(szTempBuf);
                if (hfileDump)
                    WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);
            }
            else
            {
                for (; *wszFontname; wszFontname++)
                {
                    sprintf(szTempBuf, "0x%x,", *wszFontname);
                    OutputDebugStringA(szTempBuf);
                    if (hfileDump)
                        WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);
                }
            }
        }

        OutputDebugStringA("\r\n");
        if (hfileDump)
            WriteFile(hfileDump, "\r\n", 2, &cbWritten, NULL);

        Advance(1);
        rp.AdvanceCp(1);
    }

    // Now dump the doc font info
    CF = ped->GetCharFormat(-1);
    Assert(CF);

    sprintf(szTempBuf, "Default Font iFormat= -1, Charset= %d, Size= %d\r\nName= ",
        CF->_bCharSet, CF->_yHeight);
    OutputDebugStringA(szTempBuf);
    if (hfileDump)
        WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);

    wszFontname = GetFontName(CF->_iFont);
    if (wszFontname)
    {
        if (*wszFontname <= 0x07f)
        {
            szTempBuf[0] = '\'';
            WCTMB(CP_ACP, 0,
                    wszFontname, -1, &szTempBuf[1], sizeof(szTempBuf),
                    NULL, NULL, NULL);
            strcat(szTempBuf,"\'");
            OutputDebugStringA(szTempBuf);
            if (hfileDump)
                WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);
        }
        else
        {
            for (; *wszFontname; wszFontname++)
            {
                sprintf(szTempBuf, "0x%x,", *wszFontname);
                OutputDebugStringA(szTempBuf);
                if (hfileDump)
                    W