 13);
                this.MaximizeBox = false;
                this.ControlBox = false;
                this.MinimizeBox = false;
                this.ClientSize = new Size(256, 122);
                this.CancelButton = button1;
                this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;

                this.Controls.Add(label1);
                this.Controls.Add(button1);

            }
            private void button1_Click(object sender, System.EventArgs e) {
                button1.Enabled = false;
                label1.Text = SR.GetString(SR.PrintControllerWithStatusDialog_Canceling);
                backgroundThread.canceled = true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\printing\pagesetupdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="PageSetupDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Printing;
    using System.Runtime.InteropServices;
    using System.Security;
    
    /// <include file='doc\PageSetupDialog.uex' path='docs/doc[@for="PageSetupDialog"]/*' />
    /// <devdoc>
    ///    <para> Represents
    ///       a dialog box that allows users to manipulate page settings, including margins and paper orientation.</para>
    /// </devdoc>
    [DefaultProperty("Document")]
    // The only event this dialog has is HelpRequested, which isn't very useful
    public sealed class PageSetupDialog : CommonDialog {
        // If PrintDocument != null, pageSettings == printDocument.PageSettings
        private PrintDocument printDocument = null;
        private PageSettings pageSettings = null;
        private PrinterSettings printerSettings = null;

        private bool allowMargins;
        private bool allowOrientation;
        private bool allowPaper;
        private bool allowPrinter;
        private Margins minMargins;
        private bool showHelp;
        private bool showNetwork;
        
        /// <include file='doc\PageSetupDialog.uex' path='docs/doc[@for="PageSetupDialog.PageSetupDialog"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.PageSetupDialog'/> class.</para>
        /// </devdoc>
        public PageSetupDialog() {
            Reset();
        }

        /// <include file='doc\PageSetupDialog.uex' path='docs/doc[@for="PageSetupDialog.AllowMargins"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the margins section of the dialog box is enabled.
        ///       
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.PSDallowMarginsDescr)
        ]
        public bool AllowMargins {
            get { 
                return allowMargins;
            }
            set { 
                allowMargins = value;
            }
        }

        /// <include file='doc\PageSetupDialog.uex' path='docs/doc[@for="PageSetupDialog.AllowOrientation"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets a value indicating whether the orientation section of the dialog box (landscape vs. portrait)
        ///       is enabled.
        ///       </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.PSDallowOrientationDescr)
        ]
        public bool AllowOrientation {
            get { return allowOrientation;}
            set { allowOrientation = value;}
        }

        /// <include file='doc\PageSetupDialog.uex' path='docs/doc[@for="PageSetupDialog.AllowPaper"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the paper section of the dialog box (paper size and paper source)
        ///       is enabled.
        ///       
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.PSDallowPaperDescr)
        ]
        public bool AllowPaper {
            get { return allowPaper;}
            set { allowPaper = value;}
        }

        /// <include file='doc\PageSetupDialog.uex' path='docs/doc[@for="PageSetupDialog.AllowPrinter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the Printer button is enabled.
        ///       
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.PSDallowPrinterDescr)
        ]
        public bool AllowPrinter {
            get { return allowPrinter;}
            set { allowPrinter = value;}
        }

        /// <include file='doc\PageSetupDialog.uex' path='docs/doc[@for="PageSetupDialog.Document"]/*' />
        /// <devdoc>
        /// <para>Gets or sets a value indicating the <see cref='System.Drawing.Printing.PrintDocument'/> 
        /// to get page settings from.
        /// </para>
        /// </devdoc>
        [
        DefaultValue(null),
        SRDescription(SR.PDdocumentDescr)
        ]
        public PrintDocument Document {
            get { return printDocument;}
            set { 
                printDocument = value;
                if (printDocument != null) {
                    pageSettings = printDocument.DefaultPageSettings;
                    printerSettings = printDocument.PrinterSettings;
                }
            }
        }

        /// <include file='doc\PageSetupDialog.uex' path='docs/doc[@for="PageSetupDialog.MinMargins"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating the minimum margins the
        ///       user is allowed to select, in hundredths of an inch.
        ///       
        ///    </para>
        /// </devdoc>
        [
        SRDescription(SR.PSDminMarginsDescr)
        ]
        public Margins MinMargins {
            get { return minMargins;}
            set { 
                if (value == null)
                    value = new Margins(0, 0, 0, 0);
                minMargins = value;
            }
        }

        /// <include file='doc\PageSetupDialog.uex' path='docs/doc[@for="PageSetupDialog.PageSettings"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets
        ///       a value indicating
        ///       the page settings modified by the dialog box.
        ///       
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(null),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.PSDpageSettingsDescr)
        ]
        public PageSettings PageSettings {
            get { return pageSettings;}
            set {
                pageSettings = value;
                printDocument = null;
            }
        }

        /// <include file='doc\PageSetupDialog.uex' path='docs/doc[@for="PageSetupDialog.PrinterSettings"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the printer
        ///       settings the dialog box will modify if the user clicks the Printer button.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(null),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.PSDprinterSettingsDescr)
        ]
        public PrinterSettings PrinterSettings {
            get { return printerSettings;}
            set {
                printerSettings = value;
                printDocument = null;
            }
        }

        /// <include file='doc\PageSetupDialog.uex' path='docs/doc[@for="PageSetupDialog.ShowHelp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the Help button is visible.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.PSDshowHelpDescr)
        ]
        public bool ShowHelp {
            get { return showHelp;}
            set { showHelp = value;}
        }

        /// <include file='doc\PageSetupDialog.uex' path='docs/doc[@for="PageSetupDialog.ShowNetwork"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the Network button is visible.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.PSDshowNetworkDescr)
        ]
        public bool ShowNetwork {
            get { return showNetwork;}
            set { showNetwork = value;}
        }

        private int GetFlags() {
            int flags = 0;
            flags |= NativeMethods.PSD_ENABLEPAGESETUPHOOK;

            if (!allowMargins) flags |= NativeMethods.PSD_DISABLEMARGINS;
            if (!allowOrientation) flags |= NativeMethods.PSD_DISABLEORIENTATION;
            if (!allowPaper) flags |= NativeMethods.PSD_DISABLEPAPER;
            if (!allowPrinter || printerSettings == null) flags |= NativeMethods.PSD_DISABLEPRINTER;

            if (showHelp) flags |= NativeMethods.PSD_SHOWHELP;
            if (!showNetwork) flags |= NativeMethods.PSD_NONETWORKBUTTON;
            if (minMargins != null) flags |= NativeMethods.PSD_MINMARGINS;
            if (pageSettings.Margins != null) flags |= NativeMethods.PSD_MARGINS;

            // CONSIDER: metric versus English
            return flags;
        }

        /// <include file='doc\PageSetupDialog.uex' path='docs/doc[@for="PageSetupDialog.Reset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resets all options to their default values.
        ///    </para>
        /// </devdoc>
        public override void Reset() {
            allowMargins = true;
            allowOrientation = true;
            allowPaper = true;
            allowPrinter = true;
            MinMargins = null; // turns into Margin with all zeros
            pageSettings = null;
            printDocument = null;
            printerSettings = null;
            showHelp = false;
            showNetwork = true;
        }

        /// <include file='doc\PageSetupDialog.uex' path='docs/doc[@for="PageSetupDialog.ShouldSerializeMinMargins"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Windows.Forms.PageSetupDialog.MinMargins'/>
        ///       property should be
        ///       persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeMinMargins() {
            return minMargins.Left != 0
            || minMargins.Right != 0
            || minMargins.Top != 0
            || minMargins.Bottom != 0;
        }

        private static void UpdateSettings(NativeMethods.PAGESETUPDLG data, PageSettings pageSettings,
                                           PrinterSettings printerSettings) {
            pageSettings.SetHdevmode(data.hDevMode);
            if (printerSettings != null) {
                printerSettings.SetHdevmode(data.hDevMode);
                printerSettings.SetHdevnames(data.hDevNames);
            }

            Margins newMargins = new Margins();
            newMargins.Left = data.marginLeft;
            newMargins.Top = data.marginTop;
            newMargins.Right = data.marginRight;
            newMargins.Bottom = data.marginBottom;

            PrinterUnit fromUnit = ((data.Flags & NativeMethods.PSD_INHUNDREDTHSOFMILLIMETERS) != 0)
                                   ? PrinterUnit.HundredthsOfAMillimeter
                                   : PrinterUnit.ThousandthsOfAnInch;
            
            pageSettings.Margins = PrinterUnitConvert.Convert(newMargins, fromUnit, PrinterUnit.Display);
        }


        /// <include file='doc\PageSetupDialog.uex' path='docs/doc[@for="PageSetupDialog.RunDialog"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override bool RunDialog(IntPtr hwndOwner) {
            IntSecurity.SafePrinting.Demand();

            NativeMethods.WndProc hookProcPtr = new NativeMethods.WndProc(this.HookProc);
            if (pageSettings == null)
                throw new ArgumentException(SR.GetString(SR.PSDcantShowWithoutPage));

            NativeMethods.PAGESETUPDLG data = new NativeMethods.PAGESETUPDLG();
            data.lStructSize = Marshal.SizeOf(data);
            data.Flags = GetFlags();
            data.hwndOwner = hwndOwner;
            data.lpfnPageSetupHook = hookProcPtr;
            
            if (MinMargins != null) {
                PrinterUnit toUnit = PrinterUnit.ThousandthsOfAnInch;
                Margins margins = PrinterUnitConvert.Convert(MinMargins, PrinterUnit.Display, toUnit);
                data.minMarginLeft = margins.Left;
                data.minMarginTop = margins.Top;
                data.minMarginRight = margins.Right;
                data.minMarginBottom = margins.Bottom;
            }

            if (pageSettings.Margins != null) {
                PrinterUnit toUnit = PrinterUnit.ThousandthsOfAnInch;
                Margins margins = PrinterUnitConvert.Convert(pageSettings.Margins, PrinterUnit.Display, toUnit);
                data.marginLeft = margins.Left;
                data.marginTop = margins.Top;
                data.marginRight = margins.Right;
                data.marginBottom = margins.Bottom;
            }

            // Ensure that the margins are >= minMargins.
            // This is a requirement of the PAGESETUPDLG structure.
            //
            data.marginLeft = Math.Max(data.marginLeft, data.minMarginLeft);
            data.marginTop = Math.Max(data.marginTop, data.minMarginTop);
            data.marginRight = Math.Max(data.marginRight, data.minMarginRight);
            data.marginBottom = Math.Max(data.marginBottom, data.minMarginBottom);           

            PrinterSettings printer = (printerSettings == null) ? pageSettings.PrinterSettings : printerSettings;

            IntSecurity.AllPrinting.Assert();

            try {
                data.hDevMode = printer.GetHdevmode(pageSettings);
                data.hDevNames = printer.GetHdevnames();
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }

            try {
                bool status = UnsafeNativeMethods.PageSetupDlg(data);
                if (!status) {
                    // Debug.WriteLine(Windows.CommonDialogErrorToString(Windows.CommDlgExtendedError()));
                    return false;
                }

                UpdateSettings(data, pageSettings, printerSettings); // yes, printerSettings, not printer
                return true;
            }
            finally {
                UnsafeNativeMethods.GlobalFree(new HandleRef(data, data.hDevMode));
                UnsafeNativeMethods.GlobalFree(new HandleRef(data, data.hDevNames));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\printing\printdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrintDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Printing;
    using System.Runtime.InteropServices;
    using System.Security;

    /// <include file='doc\PrintDialog.uex' path='docs/doc[@for="PrintDialog"]/*' />
    /// <devdoc>
    ///    <para> Allows users to select a printer and choose which
    ///       portions of the document to print.</para>
    /// </devdoc>
    [DefaultProperty("Document")]
    // The only event this dialog has is HelpRequested, which isn't very useful
    public sealed class PrintDialog : CommonDialog {
        private const int printRangeMask = (int) (PrintRange.AllPages | PrintRange.SomePages 
                                                  | PrintRange.Selection /* | PrintRange.CurrentPage */);

        // If PrintDocument != null, settings == printDocument.PrinterSettings
        private PrinterSettings settings = null;
        private PrintDocument printDocument = null;

        // Implementing "current page" would require switching to PrintDlgEx, which is windows 2000 and later only
        // private bool allowCurrentPage;

        private bool allowPages;
        private bool allowPrintToFile;
        private bool allowSelection;
        private bool printToFile;
        private bool showHelp;
        private bool showNetwork;

        /// <include file='doc\PrintDialog.uex' path='docs/doc[@for="PrintDialog.PrintDialog"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.PrintDialog'/> class.</para>
        /// </devdoc>
        public PrintDialog() {
            Reset();
        }

        /*
        /// <summary>
        ///    <para>
        ///       Gets or sets a value indicating whether the Current Page option button is enabled.
        ///       
        ///    </para>
        /// </summary>
        /// <value>
        ///    <para>
        ///    <see langword='true '/> if the Current Page option button is enabled; otherwise, 
        ///    <see langword='false'/>. 
        ///       The default is <see langword='false'/>.
        ///       
        ///    </para>
        /// </value>
        /// <keyword term=''/>
        [
        DefaultValue(false),
        SRDescription(SR.PDallowCurrentPageDescr)
        ]
        public bool AllowCurrentPage {
            get { return allowCurrentPage;}
            set { allowCurrentPage = value;}
        }
        */

        /// <include file='doc\PrintDialog.uex' path='docs/doc[@for="PrintDialog.AllowSomePages"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the Pages option button is enabled.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.PDallowPagesDescr)
        ]
        public bool AllowSomePages {
            get { return allowPages;}
            set { allowPages = value;}
        }

        /// <include file='doc\PrintDialog.uex' path='docs/doc[@for="PrintDialog.AllowPrintToFile"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the Print to file check box is enabled.</para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.PDallowPrintToFileDescr)
        ]
        public bool AllowPrintToFile {
            get { return allowPrintToFile;}
            set { allowPrintToFile = value;}
        }

        /// <include file='doc\PrintDialog.uex' path='docs/doc[@for="PrintDialog.AllowSelection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the From... To... Page option button is enabled.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.PDallowSelectionDescr)
        ]
        public bool AllowSelection {
            get { return allowSelection;}
            set { allowSelection = value;}
        }

        /// <include file='doc\PrintDialog.uex' path='docs/doc[@for="PrintDialog.Document"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating the <see cref='System.Drawing.Printing.PrintDocument'/> used to obtain <see cref='System.Drawing.Printing.PrinterSettings'/>.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(null),
        SRDescription(SR.PDdocumentDescr)
        ]
        public PrintDocument Document {
            get { return printDocument;}
            set { 
                printDocument = value;
                if (printDocument == null)
                    settings = new PrinterSettings();
                else
                    settings = printDocument.PrinterSettings;
            }
        }

        private PageSettings PageSettings {
            get {
                if (Document == null)
                    return null;
                else
                    return Document.DefaultPageSettings;
            }
        }

        /// <include file='doc\PrintDialog.uex' path='docs/doc[@for="PrintDialog.PrinterSettings"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the <see cref='System.Drawing.Printing.PrinterSettings'/> the
        ///       dialog box will be modifying.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(null),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.PDprinterSettingsDescr)
        ]
        public PrinterSettings PrinterSettings {
            get { return settings;}
            set {
                settings = value;
                printDocument = null;

                if (settings == null)
                    settings = new PrinterSettings();
            }
        }

        /// <include file='doc\PrintDialog.uex' path='docs/doc[@for="PrintDialog.PrintToFile"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the Print to file check box is checked.</para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.PDprintToFileDescr)
        ]
        public bool PrintToFile {
            get { return printToFile;}
            set { printToFile = value;}
        }

        /// <include file='doc\PrintDialog.uex' path='docs/doc[@for="PrintDialog.ShowHelp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the Help button is displayed.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.PDshowHelpDescr)
        ]
        public bool ShowHelp {
            get { return showHelp;}
            set { showHelp = value;}
        }

        /// <include file='doc\PrintDialog.uex' path='docs/doc[@for="PrintDialog.ShowNetwork"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the Network button is displayed.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.PDshowNetworkDescr)
        ]
        public bool ShowNetwork {
            get { return showNetwork;}
            set { showNetwork = value;}
        }

        private int GetFlags() {
            int flags = 0;
            flags |= NativeMethods.PD_ENABLEPRINTHOOK;

            // if (!allowCurrentPage) flags |= NativeMethods.PD_NOCURRENTPAGE;
            if (!allowPages) flags |= NativeMethods.PD_NOPAGENUMS;
            if (!allowPrintToFile) flags |= NativeMethods.PD_DISABLEPRINTTOFILE;
            if (!allowSelection) flags |= NativeMethods.PD_NOSELECTION;

            flags |= (int) settings.PrintRange;

            if (printToFile) flags |= NativeMethods.PD_PRINTTOFILE;
            if (showHelp) flags |= NativeMethods.PD_SHOWHELP;
            if (!showNetwork) flags |= NativeMethods.PD_NONETWORKBUTTON;
            if (settings.Collate) flags |= NativeMethods.PD_COLLATE;
            return flags;
        }

        /// <include file='doc\PrintDialog.uex' path='docs/doc[@for="PrintDialog.Reset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resets all options, the last selected printer, and the page
        ///       settings to their default values.
        ///    </para>
        /// </devdoc>
        public override void Reset() {
            // allowCurrentPage = false;
            allowPages = false;
            allowPrintToFile = true;
            allowSelection = false;
            printDocument = null;
            printToFile = false;
            settings = null;
            showHelp = false;
            showNetwork = true;
        }

        // Create a PRINTDLG with a few useful defaults.
        internal static NativeMethods.PRINTDLG CreatePRINTDLG() {
            NativeMethods.PRINTDLG data = new NativeMethods.PRINTDLG();
            data.lStructSize = 66;
            data.hwndOwner = IntPtr.Zero;
            data.hDevMode = IntPtr.Zero;
            data.hDevNames = IntPtr.Zero;
            data.Flags = 0;
            data.hwndOwner = IntPtr.Zero;
            data.hDC = IntPtr.Zero;
            data.nFromPage = 1;
            data.nToPage = 1;
            data.nMinPage = 0;
            data.nMaxPage = 9999;
            data.nCopies = 1;
            data.hInstance = IntPtr.Zero;
            data.lCustData = IntPtr.Zero;
            data.lpfnPrintHook = null;
            data.lpfnSetupHook = null;
            data.lpPrintTemplateName = null;
            data.lpSetupTemplateName = null;
            data.hPrintTemplate = IntPtr.Zero;
            data.hSetupTemplate = IntPtr.Zero;
            return data;
        }

        // Take information from print dialog and put in PrinterSettings
        private static void UpdatePrinterSettings(NativeMethods.PRINTDLG data, PrinterSettings settings, PageSettings pageSettings) {
            // Mode
            settings.SetHdevmode(data.hDevMode);
            settings.SetHdevnames(data.hDevNames);

            if (pageSettings != null)
                pageSettings.SetHdevmode(data.hDevMode);

            // PrintDlg
            int flags = data.Flags;
            
            //Check for Copies == 1 since we might get the Right number of Copies from hdevMode.dmCopies...
            //this is Native PrintDialogs BUG... 
            if (settings.Copies == 1)
                settings.Copies = data.nCopies;

            settings.PrintRange = (PrintRange) (flags & printRangeMask);
        }

        /// <include file='doc\PrintDialog.uex' path='docs/doc[@for="PrintDialog.RunDialog"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override bool RunDialog(IntPtr hwndOwner) {
            IntSecurity.SafePrinting.Demand();

            NativeMethods.WndProc hookProcPtr = new NativeMethods.WndProc(this.HookProc);
            if (settings == null)
                throw new ArgumentException(SR.GetString(SR.PDcantShowWithoutPrinter));

            NativeMethods.PRINTDLG data = CreatePRINTDLG();
            data.Flags = GetFlags();
            data.nCopies = (short) settings.Copies;
            data.hwndOwner = hwndOwner;
            data.lpfnPrintHook = hookProcPtr;

            IntSecurity.AllPrinting.Assert();

            try {
                if (PageSettings == null)
                    data.hDevMode = settings.GetHdevmode();
                else
                    data.hDevMode = settings.GetHdevmode(PageSettings);

                data.hDevNames = settings.GetHdevnames();
            }
            catch (InvalidPrinterException) {
                data.hDevMode = IntPtr.Zero;
                data.hDevNames = IntPtr.Zero;
                // Leave those fields null; Windows will fill them in
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }

            try {
                // Windows doesn't like it if page numbers are invalid
                if (AllowSomePages) {
                    if (settings.FromPage < settings.MinimumPage
                        || settings.FromPage > settings.MaximumPage)
                        throw new ArgumentException(SR.GetString(SR.PDpageOutOfRange, "FromPage"));
                    if (settings.ToPage < settings.MinimumPage
                        || settings.ToPage > settings.MaximumPage)
                        throw new ArgumentException(SR.GetString(SR.PDpageOutOfRange, "ToPage"));
                    if (settings.ToPage < settings.FromPage)
                        throw new ArgumentException(SR.GetString(SR.PDpageOutOfRange, "FromPage"));

                    data.nFromPage = (short) settings.FromPage;
                    data.nToPage = (short) settings.ToPage;
                    data.nMinPage = (short) settings.MinimumPage;
                    data.nMaxPage = (short) settings.MaximumPage;
                }

                if (!UnsafeNativeMethods.PrintDlg(data))
                    return false;

                UpdatePrinterSettings(data, settings, PageSettings);
                PrintToFile = ((data.Flags & NativeMethods.PD_PRINTTOFILE) != 0);
                settings.PrintToFile = PrintToFile;

                if (AllowSomePages) {
                    settings.FromPage = data.nFromPage;
                    settings.ToPage = data.nToPage;
                }

                return true;
            }
            finally {
                UnsafeNativeMethods.GlobalFree(new HandleRef(data, data.hDevMode));
                UnsafeNativeMethods.GlobalFree(new HandleRef(data, data.hDevNames));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\design\componenteditorform.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentEditorForm.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Security.Permissions;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Reflection;
    using System.ComponentModel.Design;
    using System.Windows.Forms.ComponentModel;
    using Microsoft.Win32;
    using Message = System.Windows.Forms.Message;

    /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm"]/*' />
    /// <devdoc>
    /// <para>Provides a user interface for <see cref='System.Windows.Forms.Design.WindowsFormsComponentEditor'/>.</para>
    /// </devdoc>
    [ToolboxItem(false)]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class ComponentEditorForm : Form {
        private IComponent component;
        private Type[] pageTypes;
        private ComponentEditorPageSite[] pageSites;
        private Size maxSize = System.Drawing.Size.Empty;
        private int initialActivePage;
        private int activePage;
        private bool dirty;
        private bool firstActivate;

        private Panel pageHost = new Panel();
        private PageSelector selector;
        private ImageList selectorImageList;
        private Button okButton;
        private Button cancelButton;
        private Button applyButton;
        private Button helpButton;

        private const int BUTTON_WIDTH = 70;
        private const int BUTTON_HEIGHT = 23;
        private const int BUTTON_PAD = 6;
        private const int MIN_SELECTOR_WIDTH = 90;
        private const int SELECTOR_PADDING = 10;
        private const int STRIP_HEIGHT = 4;

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.ComponentEditorForm"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.Design.ComponentEditorForm'/> class.
        ///    </para>
        /// </devdoc>
        public ComponentEditorForm(object component, Type[] pageTypes) : base() {
        
            if (!(component is IComponent)) {
               throw new ArgumentException("component");
            }
            this.component = (IComponent)component;
            this.pageTypes = pageTypes;
            dirty = false;
            firstActivate = true;
            activePage = -1;
            initialActivePage = 0;

            FormBorderStyle = FormBorderStyle.FixedDialog;
            MinimizeBox = false;
            MaximizeBox = false;
            ShowInTaskbar = false;
            Icon = null;
            StartPosition = FormStartPosition.CenterParent;

            OnNewObjects();
            OnConfigureUI();
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.ApplyChanges"]/*' />
        /// <devdoc>
        ///     Applies any changes in the set of ComponentPageControl to the actual component.
        /// </devdoc>
        /// <internalonly/>
        internal virtual void ApplyChanges(bool lastApply) {
            if (dirty) {
                IComponentChangeService changeService = null;

                if (component.Site != null) {
                    changeService = (IComponentChangeService)component.Site.GetService(typeof(IComponentChangeService));
                    if (changeService != null) {
                        try {
                            changeService.OnComponentChanging(component, null);
                        }
                        catch (CheckoutException e) {
                            if (e == CheckoutException.Canceled) {
                                return;
                            }
                            throw e;
                        }
                    }
                }

                for (int n = 0; n < pageSites.Length; n++) {
                    if (pageSites[n].Dirty) {
                        pageSites[n].GetPageControl().ApplyChanges();
                        pageSites[n].Dirty = false;
                    }
                }

                if (changeService != null) {
                    changeService.OnComponentChanged(component, null, null, null);
                }

                applyButton.Enabled = false;
                cancelButton.Text = SR.GetString(SR.CloseCaption);
                dirty = false;

                if (lastApply == false) {
                    for (int n = 0; n < pageSites.Length; n++) {
                        pageSites[n].GetPageControl().OnApplyComplete();
                    }
                }
            }
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.OnButtonClick"]/*' />
        /// <devdoc>
        ///     Handles ok/cancel/apply/help button click events
        /// </devdoc>
        /// <internalonly/>
        private void OnButtonClick(object sender, EventArgs e) {
            if (sender == okButton) {
                ApplyChanges(true);
                DialogResult = DialogResult.OK;
            }
            else if (sender == cancelButton) {
                DialogResult = DialogResult.Cancel;
            }
            else if (sender == applyButton) {
                ApplyChanges(false);
            }
            else if (sender == helpButton) {
                ShowPageHelp();
            }
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.OnConfigureUI"]/*' />
        /// <devdoc>
        ///     Lays out the UI of the form.
        /// </devdoc>
        /// <internalonly/>
        private void OnConfigureUI() {
            Font uiFont = Control.DefaultFont;
            if (component.Site != null) {
                IUIService uiService = (IUIService)component.Site.GetService(typeof(IUIService));
                if (uiService != null) {
                    uiFont = (Font)uiService.Styles["DialogFont"];
                }
            }

            this.Font = uiFont;

            okButton = new Button();
            cancelButton = new Button();
            applyButton = new Button();
            helpButton = new Button();

            selectorImageList = new ImageList();
            selectorImageList.ImageSize = new Size(16, 16);
            selector = new PageSelector();

            selector.ImageList = selectorImageList;
            selector.AfterSelect += new TreeViewEventHandler(this.OnSelChangeSelector);

            Label grayStrip = new Label();
            grayStrip.BackColor = SystemColors.ControlDark;

            int selectorWidth = MIN_SELECTOR_WIDTH;

            if (pageSites != null) {
                // Add the nodes corresponding to the pages
                for (int n = 0; n < pageSites.Length; n++) {
                    ComponentEditorPage page = pageSites[n].GetPageControl();

                    string title = page.Title;
                    Graphics graphics = CreateGraphicsInternal();
                    int titleWidth = (int) graphics.MeasureString(title, Font).Width;
                    graphics.Dispose();
                    selectorImageList.Images.Add(page.Icon.ToBitmap());

                    selector.Nodes.Add(new TreeNode(title, n, n));
                    if (titleWidth > selectorWidth)
                        selectorWidth = titleWidth;
                }
            }
            selectorWidth += SELECTOR_PADDING;

            string caption = String.Empty;
            ISite site = component.Site;
            if (site != null) {
                caption = site.Name + " ";
            }
            caption += SR.GetString(SR.ComponentEditorFormProperties);
            this.Text = caption;


            Rectangle pageHostBounds = new Rectangle(2 * BUTTON_PAD + selectorWidth, 2 * BUTTON_PAD + STRIP_HEIGHT,
                                                     maxSize.Width, maxSize.Height);
            pageHost.Bounds = pageHostBounds;
            grayStrip.Bounds = new Rectangle(pageHostBounds.X, BUTTON_PAD,
                                             pageHostBounds.Width, STRIP_HEIGHT);

            if (pageSites != null) {
                Rectangle pageBounds = new Rectangle(0, 0, pageHostBounds.Width, pageHostBounds.Height);
                for (int n = 0; n < pageSites.Length; n++) {
                    ComponentEditorPage page = pageSites[n].GetPageControl();
                    page.GetControl().Bounds = pageBounds;
                }
            }

            int xFrame = SystemInformation.FixedFrameBorderSize.Width;
            Rectangle bounds = pageHostBounds;
            Size size = new Size(bounds.Width + 3 * (BUTTON_PAD + xFrame) + selectorWidth,
                                   bounds.Height + STRIP_HEIGHT + 4 * BUTTON_PAD + BUTTON_HEIGHT +
                                   2 * xFrame + SystemInformation.CaptionHeight);
            this.Size = size;

            selector.Bounds = new Rectangle(BUTTON_PAD, BUTTON_PAD,
                                            selectorWidth, bounds.Height + STRIP_HEIGHT + 2 * BUTTON_PAD + BUTTON_HEIGHT);

            bounds.X = bounds.Width + bounds.X - BUTTON_WIDTH;
            bounds.Y = bounds.Height + bounds.Y + BUTTON_PAD;
            bounds.Width = BUTTON_WIDTH;
            bounds.Height = BUTTON_HEIGHT;

            helpButton.Bounds = bounds;
            helpButton.Text = SR.GetString(SR.HelpCaption);
            helpButton.Click += new EventHandler(this.OnButtonClick);
            helpButton.Enabled = false;
            helpButton.FlatStyle = FlatStyle.System;

            bounds.X -= (BUTTON_WIDTH + BUTTON_PAD);
            applyButton.Bounds = bounds;
            applyButton.Text = SR.GetString(SR.ApplyCaption);
            applyButton.Click += new EventHandler(this.OnButtonClick);
            applyButton.Enabled = false;
            applyButton.FlatStyle = FlatStyle.System;

            bounds.X -= (BUTTON_WIDTH + BUTTON_PAD);
            cancelButton.Bounds = bounds;
            cancelButton.Text = SR.GetString(SR.CancelCaption);
            cancelButton.Click += new EventHandler(this.OnButtonClick);
            cancelButton.FlatStyle = FlatStyle.System;
            this.CancelButton = cancelButton;

            bounds.X -= (BUTTON_WIDTH + BUTTON_PAD);
            okButton.Bounds = bounds;
            okButton.Text = SR.GetString(SR.OKCaption);
            okButton.Click += new EventHandler(this.OnButtonClick);
            okButton.FlatStyle = FlatStyle.System;
            this.AcceptButton = okButton;

            this.Controls.Clear();                     
            this.Controls.AddRange(new Control[] {
                selector,
                grayStrip,
                pageHost,
                okButton,
                cancelButton,
                applyButton,
                helpButton
            });

            AutoScaleBaseSize = new Size(5, 14);
            ApplyAutoScaling();
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.OnActivated"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnActivated(EventArgs e) {
            base.OnActivated(e);

            if (firstActivate) {
                firstActivate = false;
                
                selector.SelectedNode = selector.Nodes[initialActivePage];
                pageSites[initialActivePage].Active = true;
                activePage = initialActivePage;

                helpButton.Enabled = pageSites[activePage].GetPageControl().SupportsHelp();
            }
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.OnHelpRequested"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnHelpRequested(HelpEventArgs e) {
            base.OnHelpRequested(e);
            ShowPageHelp();
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.OnNewObjects"]/*' />
        /// <devdoc>
        ///     Called to initialize this form with the new component.
        /// </devdoc>
        /// <internalonly/>
        private void OnNewObjects() {
            pageSites = null;
            maxSize = new Size(3 * (BUTTON_WIDTH + BUTTON_PAD), 24 * pageTypes.Length);

            pageSites = new ComponentEditorPageSite[pageTypes.Length];

            // create sites for them
            //
            for (int n = 0; n < pageTypes.Length; n++) {
                pageSites[n] = new ComponentEditorPageSite(pageHost, pageTypes[n], component, this);
                ComponentEditorPage page = pageSites[n].GetPageControl();

                Size pageSize = page.Size;
                if (pageSize.Width > maxSize.Width)
                    maxSize.Width = pageSize.Width;
                if (pageSize.Height > maxSize.Height)
                    maxSize.Height = pageSize.Height;
            }

            // and set them all to an ideal size
            //
            for (int n = 0; n < pageSites.Length; n++) {
                pageSites[n].GetPageControl().Size = maxSize;
            }
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.OnSelChangeSelector"]/*' />
        /// <devdoc>
        ///     Handles switching between pages.
        /// </devdoc>
        /// <internalonly/>
        protected virtual void OnSelChangeSelector(object source, TreeViewEventArgs e) {
            if (firstActivate == true) {
                // treeview seems to fire a change event when it is first setup before
                // the form is activated
                return;
            }
                
            int newPage = selector.SelectedNode.Index;
            Debug.Assert((newPage >= 0) && (newPage < pageSites.Length),
                         "Invalid page selected");

            if (newPage == activePage)
                return;

            if (activePage != -1) {
                if (pageSites[activePage].AutoCommit)
                    ApplyChanges(false);
                pageSites[activePage].Active = false;
            }

            activePage = newPage;
            pageSites[activePage].Active = true;
            helpButton.Enabled = pageSites[activePage].GetPageControl().SupportsHelp();
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.PreProcessMessage"]/*' />
        /// <devdoc>
        ///    <para>Provides a method to override in order to pre-process input messages before 
        ///       they are dispatched.</para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public override bool PreProcessMessage(ref Message msg) {
            if (null != pageSites && pageSites[activePage].GetPageControl().IsPageMessage(ref msg))
                return true;

            return base.PreProcessMessage(ref msg);
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.SetDirty"]/*' />
        /// <devdoc>
        ///     Sets the controls of the form to dirty.  This enables the "apply"
        ///     button.
        /// </devdoc>
        internal virtual void SetDirty() {
            dirty = true;
            applyButton.Enabled = true;
            cancelButton.Text = SR.GetString(SR.CancelCaption);
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.ShowForm"]/*' />
        /// <devdoc>
        ///    <para>Shows the form. The form will have no owner window.</para>
        /// </devdoc>
        public virtual DialogResult ShowForm() {
            return ShowForm(null, 0);
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.ShowForm1"]/*' />
        /// <devdoc>
        ///    <para> Shows the form and the specified page. The form will have no owner window.</para>
        /// </devdoc>
        public virtual DialogResult ShowForm(int page) {
            return ShowForm(null, page);
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.ShowForm2"]/*' />
        /// <devdoc>
        ///    <para>Shows the form with the specified owner.</para>
        /// </devdoc>
        public virtual DialogResult ShowForm(IWin32Window owner) {
            return ShowForm(owner, 0);
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.ShowForm3"]/*' />
        /// <devdoc>
        ///    <para>Shows the form and the specified page with the specified owner.</para>
        /// </devdoc>
        public virtual DialogResult ShowForm(IWin32Window owner, int page) {
            initialActivePage = page;
            ShowDialog(owner);
            return DialogResult;
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.ShowPageHelp"]/*' />
        /// <devdoc>
        ///     Shows help for the active page.
        /// </devdoc>
        /// <internalonly/>
        private void ShowPageHelp() {
            Debug.Assert(activePage != -1);

            if (pageSites[activePage].GetPageControl().SupportsHelp()) {
                pageSites[activePage].GetPageControl().ShowHelp();
            }
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.ComponentEditorPageSite"]/*' />
        /// <devdoc>
        ///     Implements a standard version of ComponentEditorPageSite for use within a
        ///     ComponentEditorForm.
        /// </devdoc>
        /// <internalonly/>
        private sealed class ComponentEditorPageSite : IComponentEditorPageSite {
            internal IComponent component;
            internal ComponentEditorPage pageControl;
            internal Control parent;
            internal bool isActive;
            internal bool isDirty;
            private ComponentEditorForm form;

            /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.ComponentEditorPageSite.ComponentEditorPageSite"]/*' />
            /// <devdoc>
            ///     Creates the page site.
            /// </devdoc>
            /// <internalonly/>
            internal ComponentEditorPageSite(Control parent, Type pageClass, IComponent component, ComponentEditorForm form) {
                this.component = component;
                this.parent = parent;
                this.isActive = false;
                this.isDirty = false;

                if (form == null)
                    throw new ArgumentNullException("form");

                this.form = form;

                try {
                    pageControl = (ComponentEditorPage)Activator.CreateInstance(pageClass);
                }
                catch (TargetInvocationException e) {
                    Debug.Fail(e.ToString());
                    throw new TargetInvocationException(SR.GetString(SR.ExceptionCreatingCompEditorControl, e.ToString()), e.InnerException);
                }

                pageControl.SetSite(this);
                pageControl.SetComponent(component);
            }

            /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.ComponentEditorPageSite.Active"]/*' />
            /// <devdoc>
            ///     Called by the ComponentEditorForm to activate / deactivate the page.
            /// </devdoc>
            /// <internalonly/>
            internal bool Active {
                get {
                     return isActive;
                }
                set {
                    if (value) {
                        // make sure the page has been created
                        pageControl.CreateControl();

                        // activate it and give it focus
                        pageControl.Activate();
                    }
                    else {
                        pageControl.Deactivate();
                    }
                    isActive = value;
                }
            }

            internal bool AutoCommit {
                get {
                    return pageControl.CommitOnDeactivate;
                }
            }

            internal bool Dirty {
                get {
                    return isDirty;
                }
                set {
                    isDirty = value;
                }
            }

            /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.ComponentEditorPageSite.GetControl"]/*' />
            /// <devdoc>
            ///     Called by a page to return a parenting control for itself.
            /// </devdoc>
            /// <internalonly/>
            public Control GetControl() {
                return parent;
            }

            /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.ComponentEditorPageSite.GetPageControl"]/*' />
            /// <devdoc>
            ///     Called by the ComponentEditorForm to get the actual page.
            /// </devdoc>
            /// <internalonly/>
            internal ComponentEditorPage GetPageControl() {
                return pageControl;
            }

            /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.ComponentEditorPageSite.SetDirty"]/*' />
            /// <devdoc>
            ///     Called by a page to mark it's contents as dirty.
            /// </devdoc>
            /// <internalonly/>
            public void SetDirty() {
                if (isActive)
                    Dirty = true;
                    form.SetDirty();
            }
        }

        /// <include file='doc\ComponentEditorForm.uex' path='docs/doc[@for="ComponentEditorForm.PageSelector"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        // CONSIDER: nikhilko, 9/99: This should be moved into a shared location
        //    Its a duplication of what exists in the StyleBuilder.
        internal sealed class PageSelector : TreeView {
            private const int PADDING_VERT = 3;
            private const int PADDING_HORZ = 4;

            private const int SIZE_ICON_X = 16;
            private const int SIZE_ICON_Y = 16;

            private const int STATE_NORMAL = 0;
            private const int STATE_SELECTED = 1;
            private const int STATE_HOT = 2;

            private IntPtr hbrushDither;


            public PageSelector() {
                this.HotTracking = true;
                this.HideSelection = false;
                this.BackColor = SystemColors.Control;
                this.Indent = 0;
                this.LabelEdit = false;
                this.Scrollable = false;
                this.ShowLines = false;
                this.ShowPlusMinus = false;
                this.ShowRootLines = false;
                this.BorderStyle = BorderStyle.None;
                this.Indent = 0;
                this.FullRowSelect = true;
            }


            protected override CreateParams CreateParams {
                [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
                get {
                    CreateParams cp = base.CreateParams;

                    cp.ExStyle |= NativeMethods.WS_EX_STATICEDGE;
                    return cp;
                }
            }

            private void CreateDitherBrush() {
                Debug.Assert(hbrushDither == IntPtr.Zero, "Brush should not be recreated.");

                short[] patternBits = new short[] {
                    unchecked((short)0xAAAA), unchecked((short)0x5555), unchecked((short)0xAAAA), unchecked((short)0x5555),
                    unchecked((short)0xAAAA), unchecked((short)0x5555), unchecked((short)0xAAAA), unchecked((short)0x5555)
                };

                IntPtr hbitmapTemp = SafeNativeMethods.CreateBitmap(8, 8, 1, 1, patternBits);
                Debug.Assert(hbitmapTemp != IntPtr.Zero,
                             "could not create dither bitmap. Page selector UI will not be correct");

                if (hbitmapTemp != IntPtr.Zero) {
                    hbrushDither = SafeNativeMethods.CreatePatternBrush(new HandleRef(null, hbitmapTemp));

                    Debug.Assert(hbrushDither != IntPtr.Zero,
                                 "Unable to created dithered brush. Page selector UI will not be correct");

                    SafeNativeMethods.DeleteObject(new HandleRef(null, hbitmapTemp));
                }
            }

            private void DrawTreeItem(string itemText, int imageIndex, IntPtr dc, NativeMethods.RECT rc,
                                        int state, int backColor, int textColor) {
                NativeMethods.SIZE size = new NativeMethods.SIZE();
                NativeMethods.RECT rc2 = new NativeMethods.RECT();
                ImageList imagelist = this.ImageList;
                IntPtr hfontOld = IntPtr.Zero;

                // Select the font of the dialog, so we don't get the underlined font
                // when the item is being tracked
                if ((state & STATE_HOT) != 0)
                    hfontOld = SafeNativeMethods.SelectObject(new HandleRef(null, dc), new HandleRef(Parent, ((Control)Parent).FontHandle));

                // Fill the background
                if (((state & STATE_SELECTED) != 0) && (hbrushDither != IntPtr.Zero)) {
                    FillRectDither(dc, rc);
                    SafeNativeMethods.SetBkMode(new HandleRef(null, dc), NativeMethods.TRANSPARENT);
                }
                else {
                    SafeNativeMethods.SetBkColor(new HandleRef(null, dc), backColor);
                    SafeNativeMethods.ExtTextOut(new HandleRef(null, dc), 0, 0, NativeMethods.ETO_CLIPPED | NativeMethods.ETO_OPAQUE, ref rc, null, 0, null);
                }

                // Get the height of the font
                SafeNativeMethods.GetTextExtentPoint32(new HandleRef(null, dc), itemText, itemText.Length, size);

                // Draw the caption
                rc2.left = rc.left + SIZE_ICON_X + 2 * PADDING_HORZ;
                rc2.top = rc.top + (((rc.bottom - rc.top) - size.cy) >> 1);
                rc2.bottom = rc2.top + size.cy;
                rc2.right = rc.right;
                SafeNativeMethods.SetTextColor(new HandleRef(null, dc), textColor);
                SafeNativeMethods.DrawText(new HandleRef(null, dc), itemText, itemText.Length, ref rc2,
                                 NativeMethods.DT_LEFT | NativeMethods.DT_VCENTER | NativeMethods.DT_END_ELLIPSIS | NativeMethods.DT_NOPREFIX);

                SafeNativeMethods.ImageList_Draw(new HandleRef(imagelist, imagelist.Handle), imageIndex, new HandleRef(null, dc),
                                       PADDING_HORZ, rc.top + (((rc.bottom - rc.top) - SIZE_ICON_Y) >> 1),
                                       NativeMethods.ILD_TRANSPARENT);

                // Draw the hot-tracking border if needed
                if ((state & STATE_HOT) != 0) {
                    int savedColor;

                    // top left
                    savedColor = SafeNativeMethods.SetBkColor(new HandleRef(null, dc), ColorTranslator.ToWin32(SystemColors.ControlLightLight));
                    rc2.left = rc.left;
                    rc2.top = rc.top;
                    rc2.bottom = rc.top + 1;
                    rc2.right = rc.right;
                    SafeNativeMethods.ExtTextOut(new HandleRef(null, dc), 0, 0, NativeMethods.ETO_OPAQUE, ref rc2, null, 0, null);
                    rc2.bottom = rc.bottom;
                    rc2.right = rc.left + 1;
                    SafeNativeMethods.ExtTextOut(new HandleRef(null, dc), 0, 0, NativeMethods.ETO_OPAQUE, ref rc2, null, 0, null);

                    // bottom right
                    SafeNativeMethods.SetBkColor(new HandleRef(null, dc), ColorTranslator.ToWin32(SystemColors.ControlDark));
                    rc2.left = rc.left;
                    rc2.right = rc.right;
                    rc2.top = rc.bottom - 1;
                    rc2.bottom = rc.bottom;
                    SafeNativeMethods.ExtTextOut(new HandleRef(null, dc), 0, 0, NativeMethods.ETO_OPAQUE, ref rc2, null, 0, null);
                    rc2.left = rc.right - 1;
                    rc2.top = rc.top;
                    SafeNativeMethods.ExtTextOut(new HandleRef(null, dc), 0, 0, NativeMethods.ETO_OPAQUE, ref rc2, null, 0, null);

                    SafeNativeMethods.SetBkColor(new HandleRef(null, dc), savedColor);
                }

                if (hfontOld != IntPtr.Zero)
                    SafeNativeMethods.SelectObject(new HandleRef(null, dc), new HandleRef(null, hfontOld));
            }

            protected override void OnHandleCreated(EventArgs e) {
                base.OnHandleCreated(e);

                int itemHeight;

                itemHeight = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TVM_GETITEMHEIGHT, 0, 0);
                itemHeight += 2 * PADDING_VERT;
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TVM_SETITEMHEIGHT, itemHeight, 0);

                if (hbrushDither == IntPtr.Zero) {
                    CreateDitherBrush();
                }
            }

            private void OnCustomDraw(ref Message m) {
                NativeMethods.NMTVCUSTOMDRAW nmtvcd = (NativeMethods.NMTVCUSTOMDRAW)m.GetLParam(typeof(NativeMethods.NMTVCUSTOMDRAW));

                switch (nmtvcd.nmcd.dwDrawStage) {
                    case NativeMethods.CDDS_PREPAINT:
                        m.Result = (IntPtr)(NativeMethods.CDRF_NOTIFYITEMDRAW | NativeMethods.CDRF_NOTIFYPOSTPAINT);
                        break;
                    case NativeMethods.CDDS_ITEMPREPAINT:
                        {
                            TreeNode itemNode = TreeNode.FromHandle(this, (IntPtr)nmtvcd.nmcd.dwItemSpec);
                            int state = STATE_NORMAL;
                            int itemState = nmtvcd.nmcd.uItemState;

                            if (((itemState & NativeMethods.CDIS_HOT) != 0) ||
                                ((itemState & NativeMethods.CDIS_FOCUS) != 0))
                                state |= STATE_HOT;
                            if ((itemState & NativeMethods.CDIS_SELECTED) != 0)
                                state |= STATE_SELECTED;

                            DrawTreeItem(itemNode.Text, itemNode.ImageIndex,
                                         nmtvcd.nmcd.hdc, nmtvcd.nmcd.rc,
                                         state, ColorTranslator.ToWin32(SystemColors.Control), ColorTranslator.ToWin32(SystemColors.ControlText));
                            m.Result = (IntPtr)NativeMethods.CDRF_SKIPDEFAULT;
                        }
                        break;
                    case NativeMethods.CDDS_POSTPAINT:
                        m.Result = (IntPtr)NativeMethods.CDRF_SKIPDEFAULT;
                        break;
                    default:
                        m.Result = (IntPtr)NativeMethods.CDRF_DODEFAULT;
                        break;
                }
            }

            protected override void OnHandleDestroyed(EventArgs e) {
                base.OnHandleDestroyed(e);

                if (!RecreatingHandle && (hbrushDither != IntPtr.Zero)) {
                    SafeNativeMethods.DeleteObject(new HandleRef(this, hbrushDither));
                    hbrushDither = IntPtr.Zero;
                }
            }

            private void FillRectDither(IntPtr dc, NativeMethods.RECT rc) {
                IntPtr hbrushOld = SafeNativeMethods.SelectObject(new HandleRef(null, dc), new HandleRef(this, hbrushDither));

                if (hbrushOld != IntPtr.Zero) {
                    int oldTextColor, oldBackColor;

                    oldTextColor = SafeNativeMethods.SetTextColor(new HandleRef(null, dc), ColorTranslator.ToWin32(SystemColors.ControlLightLight));
                    oldBackColor = SafeNativeMethods.SetBkColor(new HandleRef(null, dc), ColorTranslator.ToWin32(SystemColors.Control));

                    SafeNativeMethods.PatBlt(new HandleRef(null, dc), rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, NativeMethods.PATCOPY);
                    SafeNativeMethods.SetTextColor(new HandleRef(null, dc), oldTextColor);
                    SafeNativeMethods.SetBkColor(new HandleRef(null, dc), oldBackColor);
                }
            }

            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            protected override void WndProc(ref Message m) {
                if (m.Msg == NativeMethods.WM_REFLECT + NativeMethods.WM_NOTIFY) {
                    NativeMethods.NMHDR nmh = (NativeMethods.NMHDR)m.GetLParam(typeof(NativeMethods.NMHDR));
                    if (nmh.code == NativeMethods.NM_CUSTOMDRAW) {
                        OnCustomDraw(ref m);
                        return;
                    }
                }

                base.WndProc(ref m);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\printing\printpreviewdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrintPreviewDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Drawing.Design;
    using Microsoft.Win32;
    using System.Drawing.Printing;
    using System.Windows.Forms.Design;

    /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog"]/*' />
    /// <devdoc>
    ///    <para> Represents a
    ///       dialog box form that contains a <see cref='System.Windows.Forms.PrintPreviewControl'/>.</para>
    /// </devdoc>
    [
    Designer("System.ComponentModel.Design.ComponentDesigner, " + AssemblyRef.SystemDesign),
    DesignTimeVisible(true),
    DefaultProperty("Document"),
    ToolboxItem(true)
    ]
    public class PrintPreviewDialog : Form {
        PrintPreviewControl previewControl;

        NumericUpDown pageCounter;
        Label pageLabel;
        ToolBarButton singlePage;
        Button closeButton;
        MenuItem zoomMenu0;
        MenuItem zoomMenu1;
        MenuItem zoomMenu2;
        MenuItem zoomMenu3;
        MenuItem zoomMenu4;
        MenuItem zoomMenu5;
        MenuItem zoomMenu6;
        MenuItem zoomMenu7;
        MenuItem zoomMenu8;
        ToolBarButton printButton;
        ToolBarButton twoPages;
        ToolBarButton threePages;
        ToolBarButton fourPages;
        ToolBarButton sixPages;
        ToolBarButton zoomButton;
        ToolBarButton separator1;
        ToolBarButton separator2;
        ToolBar toolBar1;
        ImageList imageList;
        ContextMenu menu = new ContextMenu();
        
        static readonly Size DefaultMinimumSize = new Size(375, 250);

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.PrintPreviewDialog"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.PrintPreviewDialog'/> class.</para>
        /// </devdoc>
        public PrintPreviewDialog() {
            base.AutoScaleBaseSize = new Size(5, 13);

            InitForm();

            Bitmap bitmaps = new Bitmap(typeof(PrintPreviewDialog), "PrintPreviewStrip.bmp");
            bitmaps.MakeTransparent();
            imageList.Images.AddStrip(bitmaps);
            
            MinimumSize = DefaultMinimumSize;
        }

        //subhag addition
        //-------------------------------------------------------------------------------------------------------------
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.AcceptButton"]/*' />
        /// <devdoc>
        /// <para>Indicates the <see cref='System.Windows.Forms.Button'/> control on the form that is clicked when
        ///    the user presses the ENTER key.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public IButtonControl AcceptButton {
            get {
                return base.AcceptButton;
            }
            set {
                base.AcceptButton = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.AutoScale"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the form will adjust its size
        ///       to fit the height of the font used on the form and scale
        ///       its controls.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool AutoScale {
            get {
                return base.AutoScale;
            }
            set {
                base.AutoScale = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.AutoScroll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the form implements
        ///       autoscrolling.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override bool AutoScroll {
            get { 
                return base.AutoScroll;
            }
            set {
                base.AutoScroll = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.BackColor"]/*' />
        /// <devdoc>
        ///     The background color of this control. This is an ambient property and
        ///     will always return a non-null value.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color BackColor {
            get {
                return base.BackColor;
            }
            set {
                base.BackColor = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.BackColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackColorChanged {
            add {
                base.BackColorChanged += value;
            }
            remove {
                base.BackColorChanged -= value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.CancelButton"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       or
        ///       sets the button control that will be clicked when the
        ///       user presses the ESC key.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public IButtonControl CancelButton {
            get {
                return base.CancelButton;
            }
            set {
                base.CancelButton = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.ControlBox"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether a control box is displayed in the
        ///       caption bar of the form.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool ControlBox {
            get {
                return base.ControlBox;
            }
            set {
                base.ControlBox = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.FormBorderStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the border style of the form.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public FormBorderStyle FormBorderStyle {
            get {
                return base.FormBorderStyle;
            }
            set {
                base.FormBorderStyle = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.HelpButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether a
        ///       help button should be displayed in the caption box of the form.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool HelpButton {
            get {
                return base.HelpButton;
            }
            set {
                base.HelpButton = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.Icon"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the icon for the form.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public Icon Icon {
            get {
                return base.Icon;
            }
            set {
                base.Icon = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.IsMdiContainer"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the form is a container for multiple document interface
        ///       (MDI) child forms.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool IsMdiContainer {
            get {
                return base.IsMdiContainer;
            }
            set {
                base.IsMdiContainer = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.KeyPreview"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value
        ///       indicating whether the form will receive key events
        ///       before the event is passed to the control that has focus.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool KeyPreview {
            get {
                return base.KeyPreview;
            }
            set {
                base.KeyPreview = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.MaximumSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or Sets the maximum size the dialog can be resized to.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public Size MaximumSize {
            get {
                return base.MaximumSize;
            }
            set {
                base.MaximumSize = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.MaximumSizeChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler MaximumSizeChanged {
            add {
                base.MaximumSizeChanged += value;
            }
            remove {
                base.MaximumSizeChanged -= value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.MaximizeBox"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the maximize button is
        ///       displayed in the caption bar of the form.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool MaximizeBox {
            get {
                return base.MaximizeBox;
            }
            set {
                base.MaximizeBox = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.Menu"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the <see cref='System.Windows.Forms.MainMenu'/>
        ///       that is displayed in the form.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public MainMenu Menu {
            get {
                return base.Menu;
            }
            set {
                base.Menu = value;
            }
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.MinimumSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the minimum size the form can be resized to.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public Size MinimumSize {
            get {
                return base.MinimumSize;
            }
            set {
                base.MinimumSize = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.MinimumSizeChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler MinimumSizeChanged {
            add {
                base.MinimumSizeChanged += value;
            }
            remove {
                base.MinimumSizeChanged -= value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.Size"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the size of the form.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public Size Size {
            get {
                return base.Size;
            }
            set {
                base.Size = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.SizeChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler SizeChanged {
            add {
                base.SizeChanged += value;
            }
            remove {
                base.SizeChanged -= value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.StartPosition"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the
        ///       starting position of the form at run time.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public FormStartPosition StartPosition {
            get {
                return base.StartPosition;
            }
            set {
                base.StartPosition = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.TopMost"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the form should be displayed as the top-most
        ///       form of your application.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool TopMost {
            get {
                return base.TopMost;
            }
            set {
                base.TopMost = value;
            }
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.TransparencyKey"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the color that will represent transparent areas of the form.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public Color TransparencyKey {
            get {
                return base.TransparencyKey;
            }
            set {
                base.TransparencyKey = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.WindowState"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the form's window state.
        ///       </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public FormWindowState WindowState {
            get {
                return base.WindowState;
            }
            set {
                base.WindowState = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.AccessibleRole"]/*' />
        /// <devdoc>
        ///      The accessible role of the control
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public AccessibleRole AccessibleRole {
            get {
                return base.AccessibleRole;
            }
            set {
                base.AccessibleRole = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.AccessibleDescription"]/*' />
        /// <devdoc>
        ///      The accessible description of the control
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public string AccessibleDescription {
             get {
                return base.AccessibleDescription;
            }
            set {
                base.AccessibleDescription = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.AccessibleName"]/*' />
        /// <devdoc>
        ///      The accessible name of the control
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public string AccessibleName {
             get {
                return base.AccessibleName;
            }
            set {
                base.AccessibleName = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.CausesValidation"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates whether entering the control causes validation on the controls requiring validation.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool CausesValidation {
             get {
                return base.CausesValidation;
            }
            set {
                base.CausesValidation = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.CausesValidationChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler CausesValidationChanged {
            add {
                base.CausesValidationChanged += value;
            }
            remove {
                base.CausesValidationChanged -= value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.DataBindings"]/*' />
        /// <devdoc>
        ///     Retrieves the bindings for this control.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public ControlBindingsCollection DataBindings {
            get {
                return base.DataBindings;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.Enabled"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the control is currently enabled.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool Enabled {
            get {
                return base.Enabled;
            }
            set {
                base.Enabled = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.EnabledChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler EnabledChanged {
            add {
                base.EnabledChanged += value;
            }
            remove {
                base.EnabledChanged -= value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.Location"]/*' />
        /// <devdoc>
        ///     The location of this control.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public Point Location {
            get {
                return base.Location;
            }
            set {
                base.Location = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.LocationChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler LocationChanged {
            add {
                base.LocationChanged += value;
            }
            remove {
                base.LocationChanged -= value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.Tag"]/*' />
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public object Tag {
            get {
                return base.Tag;
            }
            set {
                base.Tag = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.AllowDrop"]/*' />
        /// <devdoc>
        ///     The AllowDrop property. If AllowDrop is set to true then
        ///     this control will allow drag and drop operations and events to be used.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override bool AllowDrop {
            get {
                return base.AllowDrop;
            }
            set {
                base.AllowDrop = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.Cursor"]/*' />
        /// <devdoc>
        ///     Retrieves the cursor that will be displayed when the mouse is over this
        ///     control.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Cursor Cursor {
            get {
                return base.Cursor;
            }
            set {
                base.Cursor = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.CursorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler CursorChanged {
            add {
                base.CursorChanged += value;
            }
            remove {
                base.CursorChanged -= value;
            }
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.BackgroundImage"]/*' />
        /// <devdoc>
        ///     The background image of the control.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.ImeMode"]/*' />
        /// <devdoc>
        ///     Specifies a value that determines the IME (Input Method Editor) status of the 
        ///     object when that object is selected.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public ImeMode ImeMode {
            get {
                return base.ImeMode;
            }
            set {
                base.ImeMode = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.ImeModeChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler ImeModeChanged {
            add {
                base.ImeModeChanged += value;
            }
            remove {
                base.ImeModeChanged -= value;
            }
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.AutoScrollMargin"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the size of the auto-scroll
        ///       margin.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public Size AutoScrollMargin {
            get {
                return base.AutoScrollMargin;
            }
            set {
                base.AutoScrollMargin = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.AutoScrollMinSize"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the mimimum size of the auto-scroll.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public Size AutoScrollMinSize {
            get {
                return base.AutoScrollMinSize;
            }
            set {
                base.AutoScrollMinSize = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.Anchor"]/*' />
        /// <devdoc>
        ///     The current value of the anchor property. The anchor property
        ///     determines which edges of the control are anchored to the container's
        ///     edges.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override AnchorStyles Anchor {
            get {
                return base.Anchor;
            }
            set {
                base.Anchor = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.Visible"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the control is visible.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool Visible {
            get {
                return base.Visible;
            }
            set {
                base.Visible = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.VisibleChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler VisibleChanged {
            add {
                base.VisibleChanged += value;
            }
            remove {
                base.VisibleChanged -= value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.ForeColor"]/*' />
        /// <devdoc>
        ///     The foreground color of the control.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color ForeColor {
            get {
                return base.ForeColor;
            }
            set {
                base.ForeColor = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.ForeColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler ForeColorChanged {
            add {
                base.ForeColorChanged += value;
            }
            remove {
                base.ForeColorChanged -= value;
            }
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.RightToLeft"]/*' />
        /// <devdoc>
        ///     This is used for international applications where the language
        ///     is written from RightToLeft. When this property is true,
        ///     control placement and text will be from right to left.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override RightToLeft RightToLeft {
            get {
                return base.RightToLeft;
            }
            set {
                base.RightToLeft = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.RightToLeftChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler RightToLeftChanged {
            add {
                base.RightToLeftChanged += value;
            }
            remove {
                base.RightToLeftChanged -= value;
            }
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.TabStop"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the user can give the focus to this control using the TAB 
        ///       key. This property is read-only.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool TabStop {
            get {
                return base.TabStop;
            }
            set {
                base.TabStop = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.TabStopChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TabStopChanged {
            add {
                base.TabStopChanged += value;
            }
            remove {
                base.TabStopChanged -= value;
            }
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.Text"]/*' />
        /// <devdoc>
        ///     The current text associated with this control.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.Dock"]/*' />
        /// <devdoc>
        ///     The dock property. The dock property controls to which edge
        ///     of the container this control is docked to. For example, when docked to
        ///     the top of the container, the control will be displayed flush at the
        ///     top of the container, extending the length of the container.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override DockStyle Dock {
            get {
                return base.Dock;
            }
            set {
                base.Dock = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.DockChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler DockChanged {
            add {
                base.DockChanged += value;
            }
            remove {
                base.DockChanged -= value;
            }
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.Font"]/*' />
        /// <devdoc>
        ///     Retrieves the current font for this control. This will be the font used
        ///     by default for painting and text in the control.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Font Font {
            get {
                return base.Font;
            }
            set {
                base.Font = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.FontChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler FontChanged {
            add {
                base.FontChanged += value;
            }
            remove {
                base.FontChanged -= value;
            }
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.ContextMenu"]/*' />
        /// <devdoc>
        ///     The contextMenu associated with this control. The contextMenu
        ///     will be shown when the user right clicks the mouse on the control.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override ContextMenu ContextMenu {
            get {
                return base.ContextMenu;
            }
            set {
                base.ContextMenu = value;
            }
        }
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.ContextMenuChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler ContextMenuChanged {
            add {
                base.ContextMenuChanged += value;
            }
            remove {
                base.ContextMenuChanged -= value;
            }
        }

        // DockPadding is not relevant to UpDownBase
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.DockPadding"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public DockPaddingEdges DockPadding {
            get {
                return base.DockPadding;
            }
        }
        //-------------------------------------------------------------------------------------------------------------
        //end addition
        
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.UseAntiAlias"]/*' />
        [
        SRCategory(SR.CatBehavior), 
        DefaultValue(false),
        SRDescription(SR.PrintPreviewAntiAliasDescr)
        ]
        public bool UseAntiAlias {
            get {
                return PrintPreviewControl.UseAntiAlias;
            }
            set {
                PrintPreviewControl.UseAntiAlias = value;
            }
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.AutoScaleBaseSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PrintPreviewDialog does not support AutoScaleBaseSize.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Size AutoScaleBaseSize {
            get {
                return base.AutoScaleBaseSize;
            }

            set {
                // No-op
            }
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.Document"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the document to preview.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(null),
        SRDescription(SR.PrintPreviewDocumentDescr)
        ]
        public PrintDocument Document {
            get { 
                return previewControl.Document;
            }
            set {
                previewControl.Document = value;
            }
        }
        
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.MinimizeBox"]/*' />
        [Browsable(false), DefaultValue(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new bool MinimizeBox {
            get {
                return base.MinimizeBox;
            }
            set {
                base.MinimizeBox = value;
            }
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.PrintPreviewControl"]/*' />
        /// <devdoc>
        /// <para>Gets or sets a value indicating the <see cref='System.Windows.Forms.PrintPreviewControl'/> 
        /// contained in this form.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        SRDescription(SR.PrintPreviewPrintPreviewControlDescr),
        Browsable(false),
        EditorBrowsable(EditorBrowsableState.Never)
        ]
        public PrintPreviewControl PrintPreviewControl {
            get { return previewControl;}
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.Opacity"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Opacity does not apply to PrintPreviewDialogs.
        ///    </para>
        /// </devdoc>
        [Browsable(false),EditorBrowsable(EditorBrowsableState.Advanced)]
        public new double Opacity {
            get {
                return base.Opacity;
            }
            set {
                base.Opacity = value;
            }
        }
        
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.ShowInTaskbar"]/*' />
        [Browsable(false), DefaultValue(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new bool ShowInTaskbar {
            get {
                return base.ShowInTaskbar;
            }
            set {
                base.ShowInTaskbar = value;
            }
        }
        
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.SizeGripStyle"]/*' />
        [Browsable(false), DefaultValue(SizeGripStyle.Hide), EditorBrowsable(EditorBrowsableState.Never)]
        public new SizeGripStyle SizeGripStyle {
            get {
                return base.SizeGripStyle;
            }
            set {
                base.SizeGripStyle = value;
            }
        }

        void InitForm() {
            this.singlePage = new ToolBarButton();
            this.zoomButton = new ToolBarButton();
            this.closeButton = new Button();
            this.separator1 = new ToolBarButton();
            this.separator2 = new ToolBarButton();
            this.pageLabel = new Label();
            this.pageCounter = new NumericUpDown();
            this.toolBar1 = new ToolBar();
            this.previewControl = new PrintPreviewControl();
            this.printButton = new ToolBarButton();
            this.twoPages = new ToolBarButton();
            this.threePages = new ToolBarButton();
            this.fourPages = new ToolBarButton();
            this.sixPages = new ToolBarButton();
            this.imageList = new ImageList();

            singlePage.ToolTipText = SR.GetString(SR.PrintPreviewDialog_OnePage);
            singlePage.ImageIndex = 2;

            toolBar1.ImageList = imageList;
            toolBar1.Dock = System.Windows.Forms.DockStyle.Top;
            toolBar1.Appearance = System.Windows.Forms.ToolBarAppearance.Flat;

            separator1.Style = ToolBarButtonStyle.Separator;
            separator2.Style = ToolBarButtonStyle.Separator;

            zoomMenu0 = new MenuItem(SR.GetString(SR.PrintPreviewDialog_ZoomAuto), new EventHandler(ZoomAuto));
            zoomMenu1 = new MenuItem(SR.GetString(SR.PrintPreviewDialog_Zoom500), new EventHandler(Zoom500));
            zoomMenu2 = new MenuItem(SR.GetString(SR.PrintPreviewDialog_Zoom200), new EventHandler(Zoom250));
            zoomMenu3 = new MenuItem(SR.GetString(SR.PrintPreviewDialog_Zoom150), new EventHandler(Zoom150));
            zoomMenu4 = new MenuItem(SR.GetString(SR.PrintPreviewDialog_Zoom100), new EventHandler(Zoom100));
            zoomMenu5 = new MenuItem(SR.GetString(SR.PrintPreviewDialog_Zoom75), new EventHandler(Zoom75));
            zoomMenu6 = new MenuItem(SR.GetString(SR.PrintPreviewDialog_Zoom50), new EventHandler(Zoom50));
            zoomMenu7 = new MenuItem(SR.GetString(SR.PrintPreviewDialog_Zoom25), new EventHandler(Zoom25));
            zoomMenu8 = new MenuItem(SR.GetString(SR.PrintPreviewDialog_Zoom10), new EventHandler(Zoom10));
            zoomMenu0.Checked = true;
            menu.MenuItems.AddRange(new MenuItem[] { zoomMenu0, zoomMenu1, zoomMenu2, zoomMenu3, zoomMenu4, zoomMenu5, zoomMenu6, zoomMenu7, zoomMenu8});

            zoomButton.ToolTipText = SR.GetString(SR.PrintPreviewDialog_Zoom);
            zoomButton.ImageIndex = 1;
            zoomButton.Style = ToolBarButtonStyle.DropDownButton;
            zoomButton.DropDownMenu = menu;

            this.Text = SR.GetString(SR.PrintPreviewDialog_PrintPreview);
            this.ClientSize = new Size(400, 300);
            this.MinimizeBox = false;
            this.ShowInTaskbar = false;
            this.SizeGripStyle = SizeGripStyle.Hide;

            closeButton.Location = new System.Drawing.Point(196, 2);
            closeButton.Size = new System.Drawing.Size(50, 20);
            closeButton.TabIndex = 2;
            closeButton.FlatStyle = FlatStyle.Popup;
            closeButton.Text = SR.GetString(SR.PrintPreviewDialog_Close);
            closeButton.Click += new System.EventHandler(closeButton_Click);

            pageLabel.Text = SR.GetString(SR.PrintPreviewDialog_Page);
            pageLabel.TabStop = false;
            pageLabel.Location = new System.Drawing.Point(510, 4);
            pageLabel.Size = new System.Drawing.Size(50, 24);
            pageLabel.TextAlign = ContentAlignment.MiddleLeft;
            pageLabel.Dock = System.Windows.Forms.DockStyle.Right;

            pageCounter.TabIndex = 1;
            pageCounter.Text = "1";
            pageCounter.TextAlign = HorizontalAlignment.Right;
            pageCounter.DecimalPlaces = 0;
            pageCounter.Minimum = new Decimal(0d);
            pageCounter.Maximum = new Decimal(1000d);
            pageCounter.ValueChanged += new EventHandler(UpdownMove);
            pageCounter.Size = new System.Drawing.Size(64, 20);
            pageCounter.Dock = System.Windows.Forms.DockStyle.Right;
            pageCounter.Location = new System.Drawing.Point(568, 0);

            toolBar1.TabIndex = 3;
            toolBar1.Size = new Size(792, 43);
            toolBar1.ShowToolTips = true;
            toolBar1.DropDownArrows = true;
            toolBar1.Buttons.AddRange(new ToolBarButton[] {printButton, zoomButton, separator1, singlePage, twoPages, threePages, fourPages, sixPages, separator2});
            toolBar1.ButtonClick += new ToolBarButtonClickEventHandler(ToolBarClick);

            previewControl.TabIndex = 1;
            previewControl.Size = new Size(792, 610);
            previewControl.Location = new Point(0, 43);
            previewControl.Dock = DockStyle.Fill;
            previewControl.StartPageChanged += new EventHandler(previewControl_StartPageChanged);

            printButton.ToolTipText = SR.GetString(SR.PrintPreviewDialog_Print);
            printButton.ImageIndex = 0;

            twoPages.ToolTipText = SR.GetString(SR.PrintPreviewDialog_TwoPages);
            twoPages.ImageIndex = 3;

            threePages.ToolTipText = SR.GetString(SR.PrintPreviewDialog_ThreePages);
            threePages.ImageIndex = 4;

            fourPages.ToolTipText = SR.GetString(SR.PrintPreviewDialog_FourPages);
            fourPages.ImageIndex = 5;

            sixPages.ToolTipText = SR.GetString(SR.PrintPreviewDialog_SixPages);
            sixPages.ImageIndex = 6;

            this.Controls.Add(previewControl);
            this.Controls.Add(toolBar1);
            toolBar1.Controls.Add(pageLabel);
            toolBar1.Controls.Add(pageCounter);
            toolBar1.Controls.Add(closeButton);
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.OnClosing"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Forces the preview to be regenerated every time the dialog comes up
        ///    </para>
        /// </devdoc>
        protected override void OnClosing(CancelEventArgs e) {
            base.OnClosing(e);
            previewControl.InvalidatePreview();
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.CreateHandle"]/*' />
        /// <devdoc>
        ///    <para>Creates the handle for the PrintPreviewDialog. If a
        ///       subclass overrides this function,
        ///       it must call the base implementation.</para>
        /// </devdoc>
        protected override void CreateHandle() {
            // We want to check printer settings before we push the modal message loop,
            // so the user has a chance to catch the exception instead of letting go to
            // the windows forms exception dialog.
            if (Document != null && !Document.PrinterSettings.IsValid)
                throw new InvalidPrinterException(Document.PrinterSettings);
            
            base.CreateHandle();
        }

        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.ShouldSerializeAutoScaleBaseSize"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       AutoScaleBaseSize should never be persisted for PrintPreviewDialogs.
        ///    </para>
        /// </devdoc>
        internal override bool ShouldSerializeAutoScaleBaseSize() {
            // This method is called when the dialog is "contained" on another form.
            // We should use our own base size, not the base size of our container.
            return false;
        }
        
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.ShouldSerializeMinimumSize"]/*' />
        internal bool ShouldSerializeMinimumSize() {
            return !MinimumSize.Equals(DefaultMinimumSize);
        }
        
        /// <include file='doc\PrintPreviewDialog.uex' path='docs/doc[@for="PrintPreviewDialog.ShouldSerializeText"]/*' />
        internal override bool ShouldSerializeText() {
            return !Text.Equals(SR.GetString(SR.PrintPreviewDialog_PrintPreview));
        }

        void closeButton_Click(object sender, System.EventArgs e) {
            this.Close();
        }

        void previewControl_StartPageChanged(object sender, EventArgs e) {
            pageCounter.Value = previewControl.StartPage + 1;
        }

        void CheckZoomMenu(MenuItem toChecked) {
            foreach (MenuItem item in menu.MenuItems) {
                item.Checked = toChecked == item;
            }
        }

        void ZoomAuto(object sender, EventArgs eventargs) {
            CheckZoomMenu(zoomMenu0);
            previewControl.AutoZoom = true;
        }

        void Zoom500(object sender, EventArgs eventargs) {
            CheckZoomMenu(zoomMenu1);
            previewControl.Zoom = 5.00;
        }

        void Zoom250(object sender, EventArgs eventargs) {
            CheckZoomMenu(zoomMenu2);
            previewControl.Zoom = 2.50;
        }

        void Zoom150(object sender, EventArgs eventargs) {
            CheckZoomMenu(zoomMenu3);
            previewControl.Zoom = 1.50;
        }

        void Zoom100(object sender, EventArgs eventargs) {
            CheckZoomMenu(zoomMenu4);
            previewControl.Zoom = 1.00;
        }

        void Zoom75(object sender, EventArgs eventargs) {
            CheckZoomMenu(zoomMenu5);
            previewControl.Zoom = .75;
        }

        void Zoom50(object sender, EventArgs eventargs) {
            CheckZoomMenu(zoomMenu6);
            previewControl.Zoom = .50;
        }

        void Zoom25(object sender, EventArgs eventargs) {
            CheckZoomMenu(zoomMenu7);
            previewControl.Zoom = .25;
        }

        void Zoom10(object sender, EventArgs eventargs) {
            CheckZoomMenu(zoomMenu8);
            previewControl.Zoom = .10;
        }

        void ToolBarClick(object source, ToolBarButtonClickEventArgs eventargs) {
            if (eventargs.Button == printButton) {
                if (previewControl.Document != null)
                    previewControl.Document.Print();
            }
            else if (eventargs.Button == zoomButton) {
                ZoomAuto(null, EventArgs.Empty);
            }
            else if (eventargs.Button == singlePage) {
                previewControl.Rows = 1;
                previewControl.Columns = 1;
            }
            else if (eventargs.Button == twoPages) {
                previewControl.Rows = 1;
                previewControl.Columns = 2;
            }
            else if (eventargs.Button == threePages) {
                previewControl.Rows = 1;
                previewControl.Columns = 3;
            }
            else if (eventargs.Button == fourPages) {
                previewControl.Rows = 2;
                previewControl.Columns = 2;
            }
            else if (eventargs.Button == sixPages) {
                previewControl.Rows = 2;
                previewControl.Columns = 3;
            }
            else {
                Debug.Fail("Unhandled toolbar click");
            }
        }

        void UpdownMove(object sender, EventArgs eventargs) {
            // -1 because users like to count from one, and programmers from 0
            previewControl.StartPage = ((int) pageCounter.Value) - 1;

            // And previewControl_PropertyChanged will change it again,
            // ensuring it stays within legal bounds.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\printing\printpreviewcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrintPreviewControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Diagnostics;
    using System;
    using System.Security.Permissions;
    using System.Drawing;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Drawing.Printing;
    using CodeAccessPermission = System.Security.CodeAccessPermission;

    /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The raw "preview" part of print previewing, without any dialogs or buttons.
    ///       Most PrintPreviewControl's are found on PrintPreviewDialog's,
    ///       but they don't have to be.
    ///    </para>
    /// </devdoc>
    [DefaultProperty("Document")]
    public class PrintPreviewControl : Control {
        Size virtualSize = new Size(1,1);
        Point position = new Point(0,0);
        Point lastOffset;
        bool antiAlias;

        private const int SCROLL_PAGE = 100;
        private const int SCROLL_LINE = 5;

        private const int border = 10; // spacing per page, in mm

        private PrintDocument document;
        private PreviewPageInfo[] pageInfo; // null if needs refreshing
        private int startPage = 0;  // 0-based
        private int rows = 1;
        private int columns = 1;
        private bool autoZoom = true;

        // The following are all computed by ComputeLayout
        private bool layoutOk = false;
        private Size imageSize = System.Drawing.Size.Empty; // 100ths of inch, not pixels
        private Point screendpi = Point.Empty;
        private double zoom = 0.3;
        bool pageInfoCalcPending = false;
        bool exceptionPrinting = false;

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.PrintPreviewControl"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.PrintPreviewControl'/> class.
        ///    </para>
        /// </devdoc>
        public PrintPreviewControl() {
            ResetBackColor();
            ResetForeColor();
            Size = new Size(100, 100);
            SetStyle(ControlStyles.ResizeRedraw, false);
            SetStyle(ControlStyles.Opaque, true);
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.UseAntiAlias"]/*' />
        [
        SRCategory(SR.CatBehavior), 
        DefaultValue(false),
        SRDescription(SR.PrintPreviewAntiAliasDescr)
        ]
        public bool UseAntiAlias {
            get {
                return antiAlias;
            }
            set {
                antiAlias = value;
            }
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.AutoZoom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value If true (the default), resizing the control or changing the number of pages shown
        ///       will automatically adjust Zoom to make everything visible.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.PrintPreviewAutoZoomDescr)
        ]
        public bool AutoZoom {
            get { return autoZoom;}
            set {
                autoZoom = value;
                InvalidateLayout();
            }
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.Document"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating the document to preview.
        ///       
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(null),
        SRDescription(SR.PrintPreviewDocumentDescr)
        ]
        public PrintDocument Document {
            get { return document;}
            set {
                document = value;
                InvalidatePreview();
            }
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.Columns"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the number of pages
        ///       displayed horizontally across the screen.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(1),
        SRCategory(SR.CatLayout),
        SRDescription(SR.PrintPreviewColumnsDescr)
        ]
        public int Columns {
            get { return columns;}
            set {
                columns = value;
                InvalidateLayout();
            }
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.CreateParams"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets the CreateParams used to create the window.
        ///       If a subclass overrides this function, it must call the base implementation.
        ///       
        ///    </para>
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.Style |= NativeMethods.WS_HSCROLL;
                cp.Style |= NativeMethods.WS_VSCROLL;
                return cp;
            }
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.Position"]/*' />
        /// <devdoc>
        ///     The virtual coordinate of the upper left visible pixel.
        /// </devdoc>

        [
        SRCategory(SR.CatLayout),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlWithScrollbarsPositionDescr)
        ]
        private Point Position {
            get { return position;}
            set {
                SetPositionNoInvalidate(value);
            }
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.Rows"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the number of pages
        ///       displayed vertically down the screen.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(1),
        SRDescription(SR.PrintPreviewRowsDescr),
        SRCategory(SR.CatBehavior)
        ]
        public int Rows {
            get { return rows;}
            set {
                rows = value;
                InvalidateLayout();
            }
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.Text"]/*' />
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Never), 
        Bindable(false), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]                
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }
        
        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.StartPage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the page number of the upper left page.
        ///       
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(0),
        SRDescription(SR.PrintPreviewStartPageDescr),
        SRCategory(SR.CatBehavior)
        ]
        public int StartPage {
            get { 
                int value = startPage;
                if (pageInfo != null) {
                    value = Math.Min(value, pageInfo.Length - (rows * columns));
                }
                value = Math.Max(value, 0);

                return value;
            }
            set {
                int oldValue = StartPage;
                startPage = value;

                if (oldValue != startPage) {
                    InvalidateLayout();
                    OnStartPageChanged(EventArgs.Empty);
                }
            }
        }

        private static readonly object EVENT_STARTPAGECHANGED = new object();

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.StartPageChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.RadioButtonOnStartPageChangedDescr)]
        public event EventHandler StartPageChanged {
            add {
                Events.AddHandler(EVENT_STARTPAGECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_STARTPAGECHANGED, value);
            }
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.VirtualSize"]/*' />
        /// <devdoc>
        ///     How big the control would be if the screen was infinitely large.
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Never),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlWithScrollbarsVirtualSizeDescr)
        ]
        private Size VirtualSize {
            get { return virtualSize;}
            set {
                SetVirtualSizeNoInvalidate(value);
                Invalidate();
            }
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.Zoom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating how large the pages will appear.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        SRDescription(SR.PrintPreviewZoomDescr)
        ]
        public double Zoom {
            get { return zoom;}
            set {
                if (value <= 0)
                    throw new ArgumentException(SR.GetString(SR.PrintPreviewControlZoomNegative));
                autoZoom = false;
                zoom = value;
                InvalidateLayout();
            }
        }

        private int AdjustScroll(Message m, int pos, int maxPos) {
            switch (NativeMethods.Util.LOWORD(m.WParam)) {
                case NativeMethods.SB_THUMBPOSITION:
                case NativeMethods.SB_THUMBTRACK:
                    pos = NativeMethods.Util.HIWORD(m.WParam);
                    break;
                case NativeMethods.SB_LINEUP:
                    if (pos > SCROLL_LINE) {
                        pos-=SCROLL_LINE;
                    }
                    else {
                        pos = 0;
                    }
                    break;
                case NativeMethods.SB_LINEDOWN:
                    if (pos < maxPos-SCROLL_LINE) {
                        pos+=SCROLL_LINE;
                    }
                    else {
                        pos = maxPos;
                    }
                    break;
                case NativeMethods.SB_PAGEUP:
                    if (pos > SCROLL_PAGE) {
                        pos-=SCROLL_PAGE;
                    }
                    else {
                        pos = 0;
                    }
                    break;
                case NativeMethods.SB_PAGEDOWN:
                    if (pos < maxPos-SCROLL_PAGE) {
                        pos+=SCROLL_PAGE;
                    }
                    else {
                        pos = maxPos;
                    }
                    break;
            }
            return pos;
        }


        // This function computes everything in terms of physical size (millimeters), not pixels
        // CONSIDER: In multi-page mode, assumes all pages are same size
        private void ComputeLayout() {
            Debug.Assert(pageInfo != null, "Must call ComputePreview first");
            layoutOk = true;
            if (pageInfo.Length == 0) {
                ClientSize = Size;
                return;
            }

            Graphics tempGraphics = CreateGraphicsInternal();
            IntPtr dc = tempGraphics.GetHdc();
            screendpi = new Point(UnsafeNativeMethods.GetDeviceCaps(new HandleRef(tempGraphics, dc), NativeMethods.LOGPIXELSX),
                                  UnsafeNativeMethods.GetDeviceCaps(new HandleRef(tempGraphics, dc), NativeMethods.LOGPIXELSY));
            tempGraphics.ReleaseHdcInternal(dc);
            tempGraphics.Dispose();

            Size pageSize = pageInfo[StartPage].PhysicalSize;
            Size controlPhysicalSize = new Size(PixelsToPhysical(new Point(Size), screendpi));

            if (autoZoom) {
                double zoomX = ((double) controlPhysicalSize.Width - border*(columns + 1)) / (columns*pageSize.Width);
                double zoomY = ((double) controlPhysicalSize.Height - border*(rows + 1)) / (rows*pageSize.Height);
                zoom = Math.Min(zoomX, zoomY);
            }

            imageSize = new Size((int) (zoom*pageSize.Width), (int) (zoom*pageSize.Height));
            int virtualX = (imageSize.Width * columns) + border * (columns +1);
            int virtualY = (imageSize.Height * rows) + border * (rows +1);
            SetVirtualSizeNoInvalidate(new Size(PhysicalToPixels(new Point(virtualX, virtualY), screendpi)));
        }

        // "Prints" the document to memory
        private void ComputePreview() {
            int oldStart = StartPage;

            if (document == null)
                pageInfo = new PreviewPageInfo[0];
            else {
                IntSecurity.SafePrinting.Demand(); 

                PrintController oldController = document.PrintController;
                PreviewPrintController previewController = new PreviewPrintController();
                previewController.UseAntiAlias = UseAntiAlias;
                document.PrintController = new PrintControllerWithStatusDialog(previewController, 
                                                                               SR.GetString(SR.PrintControllerWithStatusDialog_DialogTitlePreview));

                // Want to make sure we've reverted any security asserts before we call Print -- that calls into user code
                document.Print();
                pageInfo = previewController.GetPreviewPageInfo();
                Debug.Assert(pageInfo != null, "ReviewPrintController did not give us preview info");

                document.PrintController = oldController;
            }

            if (oldStart != StartPage) {
                OnStartPageChanged(EventArgs.Empty);
            }
        }

        // Recomputes the sizes and positions of pages without forcing a new "preview print"
        private void InvalidateLayout() {
            layoutOk = false;        
            Invalidate();
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.InvalidatePreview"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Refreshes the preview of the document.
        ///    </para>
        /// </devdoc>
        public void InvalidatePreview() {
            pageInfo = null;
            InvalidateLayout();
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.OnResize"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Invalidate the layout, if necessary.
        ///    </para>
        /// </devdoc>
        protected override void OnResize(EventArgs eventargs) {
            if (autoZoom) {
                InvalidateLayout();
            }
            else {
                Point imagePixels = PhysicalToPixels(new Point(imageSize), screendpi);
                Point virtualPixels = new Point(VirtualSize);

                // center pages on screen if small enough
                Point offset = new Point(Math.Max(0, (Size.Width - virtualPixels.X) / 2),
                                         Math.Max(0, (Size.Height - virtualPixels.Y) / 2));
                offset.X -= Position.X;
                offset.Y -= Position.Y;

                if (lastOffset.X != offset.X || lastOffset.Y != offset.Y) {
                    Invalidate();
                }
            }
            base.OnResize(eventargs);
        }

        void CalculatePageInfo() {
            if (pageInfoCalcPending) {
                return;
            }

            pageInfoCalcPending = true;
            try {
                if (pageInfo == null) {
                    try {
                        ComputePreview();
                    }
                    catch (Exception e) {
                        exceptionPrinting = true;
                        throw e;
                    }
                    finally {
                        Invalidate();
                    }
                }
            }
            finally {
                pageInfoCalcPending = false;
            }
        }
            

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.OnPaint"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Paints the control.
        ///    </para>
        /// </devdoc>
        protected override void OnPaint(PaintEventArgs pevent) {
            Brush backBrush = new SolidBrush(BackColor);

            try {
                if (pageInfo == null || pageInfo.Length == 0) {
                    pevent.Graphics.FillRectangle(backBrush, ClientRectangle);

                    if (pageInfo != null || exceptionPrinting) {
                        // Calculate formats
                        StringFormat format = new StringFormat();
                        format.Alignment = ControlPaint.TranslateAlignment(ContentAlignment.MiddleCenter);
                        format.LineAlignment = ControlPaint.TranslateLineAlignment(ContentAlignment.MiddleCenter);

                        // Do actual drawing
                        SolidBrush brush = new SolidBrush(ForeColor);
                        try {
                            if (exceptionPrinting) {
                                pevent.Graphics.DrawString(SR.GetString(SR.PrintPreviewExceptionPrinting), Font, brush, ClientRectangle, format);
                            }
                            else {
                                pevent.Graphics.DrawString(SR.GetString(SR.PrintPreviewNoPages), Font, brush, ClientRectangle, format);
                            }
                        }
                        finally {
                            brush.Dispose();
                            format.Dispose();
                        }
                    }
                    else {
                        BeginInvoke(new MethodInvoker(CalculatePageInfo));
                    }
                }
                else {
                    if (!layoutOk)
                        ComputeLayout();

                    Point imagePixels = PhysicalToPixels(new Point(imageSize), screendpi);
                    Point virtualPixels = new Point(VirtualSize);

                    // center pages on screen if small enough
                    Point offset = new Point(Math.Max(0, (Size.Width - virtualPixels.X) / 2),
                                             Math.Max(0, (Size.Height - virtualPixels.Y) / 2));
                    offset.X -= Position.X;
                    offset.Y -= Position.Y;
                    lastOffset = offset;

                    int borderPixelsX = PhysicalToPixels(border, screendpi.X);
                    int borderPixelsY = PhysicalToPixels(border, screendpi.Y);

                    Region originalClip = pevent.Graphics.Clip;
                    Rectangle[] pageRenderArea = new Rectangle[rows * columns];

                    try {
                        for (int row = 0; row < rows; row++) {
                            for (int column = 0; column < columns; column++) {
                                int imageIndex = StartPage + column + row*columns;
                                if (imageIndex < pageInfo.Length) {
                                    int x = offset.X + borderPixelsX * (column + 1) + imagePixels.X * column;
                                    int y = offset.Y + borderPixelsY * (row + 1) + imagePixels.Y * row;

                                    pageRenderArea[imageIndex - StartPage] = new Rectangle(x, y, imagePixels.X, imagePixels.Y);
                                    pevent.Graphics.ExcludeClip(pageRenderArea[imageIndex - StartPage]);
                                }
                            }
                        }

                        pevent.Graphics.FillRectangle(backBrush, ClientRectangle);
                    }
                    finally {
                        pevent.Graphics.Clip = originalClip;
                    }

                    for (int i=0; i<pageRenderArea.Length; i++) {
                        if (i + StartPage < pageInfo.Length) {
                            Rectangle box = pageRenderArea[i];
                            pevent.Graphics.DrawRectangle(Pens.Black, box);
                            box.Inflate(-1, -1);
                            pevent.Graphics.FillRectangle(new SolidBrush(ForeColor), box);
                            if (pageInfo[i + StartPage].Image != null) {
                                pevent.Graphics.DrawImage(pageInfo[i + StartPage].Image, box);
                            }
                            box.Width --;
                            box.Height--;
                            pevent.Graphics.DrawRectangle(Pens.Black, box);
                        }
                    }
                }
            }
            finally {
                backBrush.Dispose();
            }

            base.OnPaint(pevent); // raise paint event
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.OnStartPageChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnStartPageChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_STARTPAGECHANGED] as EventHandler;
            if (eh != null) {
                eh(this, e);
            }
        }

        private static int PhysicalToPixels(int physicalSize, int dpi) {
            return(int) (physicalSize * dpi / 100.0);
        }

        private static Point PhysicalToPixels(Point physical, Point dpi) {
            return new Point(PhysicalToPixels(physical.X, dpi.X),
                             PhysicalToPixels(physical.Y, dpi.Y));
        }

        private static Size PhysicalToPixels(Size physicalSize, Point dpi) {
            return new Size(PhysicalToPixels(physicalSize.Width, dpi.X),
                            PhysicalToPixels(physicalSize.Height, dpi.Y));
        }

        private static int PixelsToPhysical(int pixels, int dpi) {
            return(int) (pixels * 100.0 / dpi);
        }

        private static Point PixelsToPhysical(Point pixels, Point dpi) {
            return new Point(PixelsToPhysical(pixels.X, dpi.X),
                             PixelsToPhysical(pixels.Y, dpi.Y));
        }

        private static Size PixelsToPhysical(Size pixels, Point dpi) {
            return new Size(PixelsToPhysical(pixels.Width, dpi.X),
                            PixelsToPhysical(pixels.Height, dpi.Y));
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.ResetBackColor"]/*' />
        /// <devdoc>
        ///     Resets the back color to the defaults for the PrintPreviewControl.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override void ResetBackColor() {
            BackColor = SystemColors.AppWorkspace;
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.ResetForeColor"]/*' />
        /// <devdoc>
        ///     Resets the back color to the defaults for the PrintPreviewControl.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override void ResetForeColor() {
            ForeColor = Color.White;
        }

        /// <devdoc>
        ///     WM_HSCROLL handler
        /// </devdoc>
        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.WmHScroll"]/*' />
        /// <internalonly/>

        private void WmHScroll(ref Message m) {

            // The lparam is handle of the sending scrollbar, or NULL when
            // the scrollbar sending the message is the "form" scrollbar...
            //
            if (m.LParam != IntPtr.Zero) {
                base.WndProc(ref m);
                return;
            }

            Point locPos = position;
            int pos = locPos.X;
            int maxPos = Math.Max(Width, virtualSize.Width /*- Width*/);

            locPos.X = AdjustScroll(m, pos, maxPos);
            Position = locPos;
        }

        private void SetPositionNoInvalidate(Point value) {
            Point current = position;

            position = value;
            position.X = Math.Min(position.X, virtualSize.Width - Width);
            position.Y = Math.Min(position.Y, virtualSize.Height - Height);
            if (position.X < 0) position.X = 0;
            if (position.Y < 0) position.Y = 0;

            Rectangle rect = ClientRectangle;
            NativeMethods.RECT scroll = NativeMethods.RECT.FromXYWH(rect.X, rect.Y, rect.Width, rect.Height);
            SafeNativeMethods.ScrollWindow(new HandleRef(this, Handle),
                                 current.X - position.X,
                                 current.Y - position.Y,
                                 ref scroll,
                                 ref scroll);

            UnsafeNativeMethods.SetScrollPos(new HandleRef(this, Handle), NativeMethods.SB_HORZ, position.X, true);
            UnsafeNativeMethods.SetScrollPos(new HandleRef(this, Handle), NativeMethods.SB_VERT, position.Y, true);
        }

        internal void SetVirtualSizeNoInvalidate(Size value) {
            virtualSize = value;
            SetPositionNoInvalidate(position); // Make sure it's within range

            NativeMethods.SCROLLINFO info = new NativeMethods.SCROLLINFO();
            info.fMask = NativeMethods.SIF_RANGE | NativeMethods.SIF_PAGE;
            info.nMin = 0;
            info.nMax = Math.Max(Height, virtualSize.Height) - 1;
            info.nPage = Height;
            UnsafeNativeMethods.SetScrollInfo(new HandleRef(this, Handle), NativeMethods.SB_VERT, info, true);

            info.fMask = NativeMethods.SIF_RANGE | NativeMethods.SIF_PAGE;
            info.nMin = 0;
            info.nMax = Math.Max(Width, virtualSize.Width) - 1;
            info.nPage = Width;
            UnsafeNativeMethods.SetScrollInfo(new HandleRef(this, Handle), NativeMethods.SB_HORZ, info, true);
        }

        /// <devdoc>
        ///     WM_VSCROLL handler
        /// </devdoc>
        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.WmVScroll"]/*' />
        /// <internalonly/>

        private void WmVScroll(ref Message m) {

            // The lparam is handle of the sending scrollbar, or NULL when
            // the scrollbar sending the message is the "form" scrollbar...
            //
            if (m.LParam != IntPtr.Zero) {
                base.WndProc(ref m);
                return;
            }

            Point locPos = Position;
            int pos = locPos.Y;
            int maxPos = Math.Max(Height, virtualSize.Height/* - Height*/);

            locPos.Y = AdjustScroll(m, pos, maxPos);
            Position = locPos;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.WmKeyChar"]/*' />
        /// <devdoc>
        ///     Handles the WM_KEYDOWN message.
        /// </devdoc>
        /// <internalonly/>
        //added to handle keyboard events(71009)subhag
        //
        private void WmKeyDown(ref Message msg) {

            Keys keyData = (Keys)((int)msg.WParam | (int)ModifierKeys);

            switch (keyData & Keys.KeyCode) {
                case Keys.PageUp:
                    StartPage--;
                    break;
                case Keys.PageDown:
                    StartPage++;
                    break;
                case Keys.Home:
                    if ((keyData & Keys.Modifiers) == Keys.Control)      
                         StartPage=0;
                    break;
                case Keys.End:
                    if ((keyData & Keys.Modifiers) == Keys.Control)
                         StartPage=pageInfo.Length;
                    break;
            }
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.WndProc"]/*' />
        /// <internalonly/>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_VSCROLL:
                    WmVScroll(ref m);
                    break;
                case NativeMethods.WM_HSCROLL:
                    WmHScroll(ref m);
                    break;
                //added case to handle keyboard events(71009)subhag
                //
                case NativeMethods.WM_KEYDOWN:
                    WmKeyDown(ref m);
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            }
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.ShouldSerializeBackColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Windows.Forms.Control.BackColor'/> property should be
        ///       persisted.
        ///    </para>
        /// </devdoc>
        internal override bool ShouldSerializeBackColor() {
            return !BackColor.Equals(SystemColors.AppWorkspace);
        }

        /// <include file='doc\PrintPreviewControl.uex' path='docs/doc[@for="PrintPreviewControl.ShouldSerializeForeColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Windows.Forms.Control.ForeColor'/> property should be
        ///       persisted.
        ///    </para>
        /// </devdoc>
        internal override bool ShouldSerializeForeColor() {
            return !ForeColor.Equals(Color.White);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\arrayelementgridentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="ArrayElementGridEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.PropertyGridInternal {

    using System.Diagnostics;

    using System;
    using System.Collections;
    using System.Reflection;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;

    internal class ArrayElementGridEntry : GridEntry {

        protected int index;


        public ArrayElementGridEntry(GridEntry peParent, int index)
        : base(peParent) {
            this.index = index;
            this.SetFlag(FLAG_RENDER_READONLY, (peParent.Flags & FLAG_RENDER_READONLY) != 0 || peParent.ForceReadOnly);
        }

        
        public override GridItemType GridItemType {
            get {
                return GridItemType.ArrayValue;
            }
        }


        public override bool IsValueEditable {
            get{
                return ParentGridEntry.IsValueEditable;
            }
        }

        public override string PropertyLabel {
            get {
                return "[" + index.ToString() + "]";
            }
        }



        public override Type PropertyType {
            get {
                return parentPE.PropertyType.GetElementType();
            }
        }

        public override object PropertyValue {
            get {
                object owner = GetValueOwner();
                Debug.Assert(owner is Array, "Owner is not array type!");
                return((Array)owner).GetValue(index);
            }
            set {
                object owner = GetValueOwner();
                Debug.Assert(owner is Array, "Owner is not array type!");
                ((Array)owner).SetValue(value,index);
            }
        }

        public override bool ShouldRenderReadOnly {
            get {
                return ParentGridEntry.ShouldRenderReadOnly;
            }
        }

        /*
        /// <summary>
        /// Checks if the value of the current item can be modified by the user.
        /// </summary>
        /// <returns>
        /// True if the value can be modified
        /// </returns>
        public override bool CanSetPropertyValue() {
           return this.ParentGridEntry.CanSetPropertyValue();
        }
        */

        /*
        /// <summary>
        /// Returns if it's an editable item.  An example of a readonly
        /// editable item is a collection property -- the property itself
        /// can not be modified, but it's value (e.g. it's children) can, so
        /// we don't want to draw it as readonly.
        /// </summary>
        /// <returns>
        /// True if the value associated with this property (e.g. it's children) can be modified even if it's readonly.
        /// </returns>
        public override bool CanSetReadOnlyPropertyValue() {
           return this.ParentGridEntry.CanSetReadOnlyPropertyValue();
        }*/
       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\dropdownbutton.cs ===
//------------------------------------------------------------------------------
// <copyright file="DropDownButton.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.PropertyGridInternal {

    using System.Diagnostics;
    using System;
    using System.Drawing;

    using System.ComponentModel;
    using System.Windows.Forms;
    using Microsoft.Win32;

    internal sealed class DropDownButton : Button {

        public DropDownButton() {
            SetStyle(ControlStyles.Selectable, true);
        }

        private void DDB_Draw3DBorder(System.Drawing.Graphics g, Rectangle r, bool raised) {
            if (BackColor != SystemColors.Control && SystemInformation.HighContrast) {
                if (raised) {
                    Color c = ControlPaint.LightLight(BackColor);
                    ControlPaint.DrawBorder(g, r,
                                            c, 1, ButtonBorderStyle.Outset,
                                            c, 1, ButtonBorderStyle.Outset,
                                            c, 2, ButtonBorderStyle.Inset,
                                            c, 2, ButtonBorderStyle.Inset);
                }
                else {
                    ControlPaint.DrawBorder(g, r, ControlPaint.Dark(BackColor), ButtonBorderStyle.Solid);
                }
            }
            else {
                if (raised) {
                    Color c = ControlPaint.Light(BackColor);
                    ControlPaint.DrawBorder(g, r,
                                            c, 1, ButtonBorderStyle.Solid,
                                            c, 1, ButtonBorderStyle.Solid,
                                            BackColor, 2, ButtonBorderStyle.Outset,
                                            BackColor, 2, ButtonBorderStyle.Outset);

                    Rectangle inside = r;
                    inside.Offset(1,1);
                    inside.Width -= 3;
                    inside.Height -= 3;
                    c = ControlPaint.LightLight(BackColor);
                    ControlPaint.DrawBorder(g, inside,
                                            c, 1, ButtonBorderStyle.Solid,
                                            c, 1, ButtonBorderStyle.Solid,
                                            c, 1, ButtonBorderStyle.None,
                                            c, 1, ButtonBorderStyle.None);
                }
                else {
                    ControlPaint.DrawBorder(g, r, ControlPaint.Dark(BackColor), ButtonBorderStyle.Solid);
                }
            }
        }
        
        internal override void PaintUp(PaintEventArgs pevent, CheckState state) {
            base.PaintUp(pevent, state);
            DDB_Draw3DBorder(pevent.Graphics, ClientRectangle, true);
        }


        internal override void DrawImageCore(Graphics graphics, Image image, int xLoc, int yLoc) {
             ControlPaint.DrawImageReplaceColor(graphics, image, new Rectangle(xLoc, yLoc, image.Width, image.Height), Color.Black, ForeColor);
             //ControlPaint.DrawImageColorized(graphics, image,new Rectangle(xLoc, yLoc, image.Width, image.Height) , ForeColor);
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\categorygridentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="CategoryGridEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//#define PAINT_CATEGORY_TRIANGLE
/*
 */
namespace System.Windows.Forms.PropertyGridInternal {

    using System.Diagnostics;

     using System;
     using System.Collections;
     using System.Reflection;
     
     using System.ComponentModel;
     using System.ComponentModel.Design;
     using System.Windows.Forms;
     using System.Drawing;
     using Microsoft.Win32;

     internal class CategoryGridEntry : GridEntry {

        internal string name;
        private Brush backBrush = null;
        private static Hashtable categoryStates = null;

        public CategoryGridEntry(GridEntry peParent,string name, GridEntry[] childGridEntries)
        : base(peParent) {
            this.name = name;

#if DEBUG
            for (int n = 0;n < childGridEntries.Length; n++) {
                Debug.Assert(childGridEntries[n] != null, "Null item in category subproperty list");
            }
#endif
            if (categoryStates == null) {
                categoryStates = new Hashtable();
            }

            lock (categoryStates) {
                if (!categoryStates.ContainsKey(name)) {
                    categoryStates.Add(name, true);
                }
            }

            this.IsExpandable = true;
            
            for (int i = 0; i < childGridEntries.Length; i++) {
                childGridEntries[i].ParentGridEntry = this;
            }
            
            this.ChildCollection = new GridEntryCollection(this, childGridEntries);

            lock (categoryStates) {
                this.InternalExpanded = (bool)categoryStates[name];
            }

            this.SetFlag(GridEntry.FLAG_LABEL_BOLD,true);
        }
        
          
        /// <include file='doc\CategoryGridEntry.uex' path='docs/doc[@for="CategoryGridEntry.HasValue"]/*' />
        /// <devdoc>
        /// Returns true if this GridEntry has a value field in the right hand column.
        /// </devdoc>
        internal override bool HasValue {
            get {
               return false;
            }
        }

        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (backBrush != null) {
                    backBrush.Dispose();
                    backBrush = null;
                }

                if (ChildCollection != null) {
                    ChildCollection = null;
                }
            }
            base.Dispose(disposing);
        }

        public override void DisposeChildren() {

            // categories should never dispose
            //
            return;
        }
        
        
        // we don't want this guy participating in property depth.
        public override int PropertyDepth {
            get {
                return base.PropertyDepth - 1;
            }
        }

        protected override Brush GetBackgroundBrush(Graphics g) {
            return this.GridEntryHost.GetLineBrush(g);
        }

        public override bool Expandable {
            get {
                return !GetFlagSet(FL_EXPANDABLE_FAILED);
            }
        }
        
        internal override bool InternalExpanded {
            set {
                base.InternalExpanded = value;
                lock (categoryStates) {
                    categoryStates[this.name] = value;
                }
            }
        }
        
        public override GridItemType GridItemType {
            get {
                return GridItemType.Category;
            }
        }
        public override string HelpKeyword {
            get {
               return null;
            }
        }

        public override string PropertyLabel {
            get {
                return name;
            }
        }
        
        internal override int PropertyLabelIndent {
            get {
                // we give an extra pixel for breathing room
                // we want to make sure that we return 0 for property depth here instead of
                PropertyGridView gridHost = this.GridEntryHost;
                
                // we call base.PropertyDepth here because we don't want the subratction to happen.
                return 1+gridHost.GetOutlineIconSize()+OUTLINE_ICON_PADDING + (base.PropertyDepth * gridHost.GetDefaultOutlineIndent());
            }
        }

        public override string GetPropertyTextValue(object o) {
            return "";
        }

        public override Type PropertyType {
            get {
                return typeof(void);
            }
        }

        /// <include file='doc\CategoryGridEntry.uex' path='docs/doc[@for="CategoryGridEntry.GetChildValueOwner"]/*' />
        /// <devdoc>
        /// Gets the owner of the current value.  This is usually the value of the
        /// root entry, which is the object being browsed
        /// </devdoc>
        public override object GetChildValueOwner(GridEntry childEntry) {
            return ParentGridEntry.GetChildValueOwner(childEntry);
        }

        protected override bool CreateChildren(bool diffOldChildren) {
            return true;
        }

        public override string GetTestingInfo() {
            string str = "object = (";
            str += FullLabel;
            str += "), Category = (" + this.PropertyLabel + ")";
            return str;
        }

        public override void PaintLabel(System.Drawing.Graphics g, Rectangle rect, Rectangle clipRect, bool selected, bool paintFullLabel) {

            base.PaintLabel(g, rect, clipRect, false, true);

            // now draw the focus rect
            if (selected && hasFocus) {
                bool bold = ((this.Flags & GridEntry.FLAG_LABEL_BOLD) != 0);
                Font font = GetFont(bold);
                int labelWidth = GetLabelTextWidth(this.PropertyLabel, g, font);

                int indent = PropertyLabelIndent-2;
                Rectangle focusRect = new Rectangle(indent, rect.Y, labelWidth+3, rect.Height-1);
                ControlPaint.DrawFocusRectangle(g, focusRect);
            }

            // draw the line along the top
            if (parentPE.GetChildIndex(this) > 0) {
                g.DrawLine(SystemPens.Control, rect.X-1, rect.Y-1, rect.Width+2, rect.Y - 1);
            }
        }

#if PAINT_CATEGORY_TRIANGLE
        private const double TRI_HEIGHT_RATIO = 2.5;
        private static readonly double TRI_WIDTH_RATIO = .8;
#endif

        public override void PaintOutline(System.Drawing.Graphics g, Rectangle r) {



            // draw outline pointer triangle.
            if (Expandable) {
                bool fExpanded = Expanded;
                Rectangle outline = OutlineRect;

                // make sure we're in our bounds
                outline = Rectangle.Intersect(r, outline);

                if (outline.IsEmpty) {
                    return;
                }

#if PAINT_CATEGORY_TRIANGLE

                // bump it over a pixel
                //outline.Offset(1, 0);
                //outline.Inflate(-1,-1);

                // build the triangle, an equalaterial centered around the midpoint of the rect.

                Point[] points = new Point[3];
                int borderWidth = 2;

                // width is always the length of the sides of the triangle.
                // Height = (width /2 * (Cos60)) ; Cos60 ~ .86
                int triWidth, triHeight;
                int xOffset, yOffset;

                if (!fExpanded) {
                    // draw arrow pointing right, remember height is pointing right
                    //      0
                    //      |\
                    //      | \2
                    //      | /
                    //      |/
                    //      1

                    triWidth = (int)((outline.Height * TRI_WIDTH_RATIO) - (2*borderWidth));
                    // make sure it's an odd width so our lines will match up
                    if (!(triWidth % 2 == 0)) {
                        triWidth++;
                    }

                    triHeight = (int)Math.Ceil((triWidth/2) * TRI_HEIGHT_RATIO);

                    yOffset = outline.Y + (outline.Height-triWidth)/2;
                    xOffset = outline.X + (outline.Width-triHeight)/2;

                    points[0] = new Point(xOffset, yOffset);
                    points[1] = new Point(xOffset, yOffset + triWidth);
                    points[2] = new Point(xOffset+triHeight, yOffset + (triWidth / 2));

                }
                else {
                    // draw arrow pointing down

                    //  0 -------- 1
                    //    \      /
                    //     \    /
                    //      \  /
                    //       \/
                    //       2

                    triWidth = (int)((outline.Width * TRI_WIDTH_RATIO) - (2*borderWidth));
                    // make sure it's an odd width so our lines will match up
                    if (!(triWidth % 2 == 0)) {
                        triWidth++;
                    }

                    triHeight = (int)Math.Ceil((triWidth/2) * TRI_HEIGHT_RATIO);

                    xOffset = outline.X + (outline.Width-triWidth)/2;
                    yOffset = outline.Y + (outline.Height-triHeight)/2;

                    points[0] = new Point(xOffset, yOffset);
                    points[1] = new Point(xOffset + triWidth, yOffset);
                    points[2] = new Point(xOffset + (triWidth/ 2),yOffset + triHeight);
                }

                g.FillPolygon(SystemPens.WindowText, points);
#else

            
                // draw border area box
                Brush b;
                Pen p;
                bool disposeBrush = false;
                bool disposePen = false;
                
                Color color = GridEntryHost.GetLineColor();
                b = new SolidBrush(g.GetNearestColor(color));
                disposeBrush = true;
                
                color = GridEntryHost.GetTextColor();

                p = new Pen(g.GetNearestColor(color));
                disposePen = true;
                
                g.FillRectangle(b, outline);
                g.DrawRectangle(p, outline.X, outline.Y, outline.Width - 1, outline.Height - 1);

                // draw horizontal line for +/-
                int indent = 2;
                g.DrawLine(SystemPens.WindowText, outline.X + indent,outline.Y + outline.Height / 2,
                           outline.X + outline.Width - indent - 1,outline.Y + outline.Height/2);

                // draw vertical line to make a +
                if (!fExpanded)                   
                    g.DrawLine(SystemPens.WindowText, outline.X + outline.Width/2, outline.Y + indent,
                               outline.X + outline.Width/2, outline.Y + outline.Height - indent - 1);
                               
                if (disposePen) p.Dispose();
                if (disposeBrush) b.Dispose();

#endif


            }
        }

        public override void PaintValue(object val, System.Drawing.Graphics g, Rectangle rect, Rectangle clipRect, PaintValueFlags paintFlags) {
            base.PaintValue(val, g, rect, clipRect, paintFlags & ~PaintValueFlags.DrawSelected);

            // draw the line along the top
            if (parentPE.GetChildIndex(this) > 0) {
                g.DrawLine(SystemPens.Control, rect.X-2, rect.Y-1,rect.Width+1, rect.Y-1);
            }
        }

        internal override bool NotifyChildValue(GridEntry pe, int type) {
            return parentPE.NotifyChildValue(pe, type);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\gridentrycollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="GridEntryCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.PropertyGridInternal {
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Collections;
    using System.Reflection;

    using System.Drawing.Design;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;
    using Microsoft.Win32;

    internal class GridEntryCollection : GridItemCollection {

        private GridEntry owner;
        
        public GridEntryCollection(GridEntry owner, GridEntry[] entries) : base(entries) {
            this.owner = owner;
        }
        
        public void AddRange(GridEntry[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            if (entries != null) {
                GridEntry[] newArray = new GridEntry[entries.Length + value.Length];
                entries.CopyTo(newArray, 0);
                value.CopyTo(newArray, entries.Length);
                entries = newArray;
            }
            else {
                entries = (GridEntry[])value.Clone();
            }
        }                                       
                                       
        public void Clear() {
            entries = new GridEntry[0];            
        }
        
        public void CopyTo(Array dest, int index) {
            entries.CopyTo(dest, index);
        }
        
        internal GridEntry GetEntry(int index) {
            return (GridEntry)entries[index];
        }
        
        internal void SetEntry(int index, GridItem value) {
            entries[index] = value;
        }

        internal int GetEntry(GridEntry child) {
            return Array.IndexOf(entries, child);   
        }

        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                if (owner != null && entries != null) {
                    for (int i = 0; i < entries.Length; i++) {
                        if (entries[i] != null) {
                            ((GridEntry)entries[i]).Dispose();
                            entries[i] = null;
                        }
                    }
                    entries = new GridEntry[0];
                }
            }
        }

        ~GridEntryCollection() {
            Dispose(false);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\griderrordlg.cs ===
//------------------------------------------------------------------------------
// <copyright file="GridErrorDlg.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.PropertyGridInternal {
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Globalization;
    using System;
    using System.Collections;   
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms.Design;    
    using System.ComponentModel.Design;
    using System.IO;
    using System.Drawing;
    using Microsoft.Win32;
    using Message = System.Windows.Forms.Message;
    using System.Drawing.Drawing2D;    

    /// <include file='doc\GridErrorDlg.uex' path='docs/doc[@for="GridErrorDlg"]/*' />
    /// <devdoc>
    ///     Implements a dialog that is displayed when an unhandled exception occurs in
    ///     a thread.
    /// </devdoc>
    internal class GridErrorDlg : Form {

        private PictureBox pictureBox = new PictureBox();
        private Label lblMessage = new Label();
        
        private Button continueBtn = new Button();
        private Button quitBtn = new Button();
        private Button detailsBtn = new Button();
        private Button yesBtn = new Button();
        private Button noBtn = new Button();
        private Button okBtn = new Button();
        private Button cancelBtn = new Button();
        private TextBox details = new TextBox();
        private Bitmap expandImage = null;
        private Bitmap collapseImage = null;
        
        public string Details {
            get {
                return details.Text;
            }
            set {
                this.details.Text = value;
            }
        }

        public string Message {
            get {
                return this.lblMessage.Text;
            }
            set {
                 this.lblMessage.Text = value;
            }
        }

        public GridErrorDlg() {
            expandImage = new Bitmap(typeof(ThreadExceptionDialog), "down.bmp");
            expandImage.MakeTransparent();
            collapseImage = new Bitmap(typeof(ThreadExceptionDialog), "up.bmp");
            collapseImage.MakeTransparent();
                

            InitializeComponent();

            pictureBox.Image = SystemIcons.Warning.ToBitmap();
            detailsBtn.Text = SR.GetString(SR.ExDlgShowDetails);
            
            okBtn.Text = SR.GetString(SR.ExDlgOk);
            cancelBtn.Text = SR.GetString(SR.ExDlgCancel);
            detailsBtn.Image = expandImage;
        }

                /// <include file='doc\GridErrorDlg.uex' path='docs/doc[@for="GridErrorDlg.DetailsClick"]/*' />
        /// <devdoc>
        ///     Called when the details button is clicked.
        /// </devdoc>
        private void DetailsClick(object sender, EventArgs devent) {
            int delta = details.Height + 8;
            if ( details.Visible ) delta = -delta;
            Height = Height + delta;
            details.Visible = !details.Visible;
            detailsBtn.Image = details.Visible ? collapseImage : expandImage;
        }

        private void InitializeComponent()
                {
                this.lblMessage = new System.Windows.Forms.Label();
                        this.pictureBox = new System.Windows.Forms.PictureBox();
                        this.detailsBtn = new System.Windows.Forms.Button();
                        this.okBtn = new System.Windows.Forms.Button();
                        this.cancelBtn = new System.Windows.Forms.Button();
                        this.details = new System.Windows.Forms.TextBox();
                        this.SuspendLayout();
                        // 
                        // lblMessage
                        // 
                        this.lblMessage.Anchor = ((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
                                | System.Windows.Forms.AnchorStyles.Right);
                        this.lblMessage.Location = new System.Drawing.Point(64, 24);
                        this.lblMessage.Name = "lblMessage";
                        this.lblMessage.Size = new System.Drawing.Size(190, 48);
                        this.lblMessage.TabIndex = 5;
                        this.lblMessage.Text = "";
                        // 
                        // pictureBox
                        // 
                        this.pictureBox.Name = "pictureBox";
                        this.pictureBox.Size = new System.Drawing.Size(64, 64);
                        this.pictureBox.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
                        this.pictureBox.TabIndex = 4;
                        this.pictureBox.TabStop = false;
                        // 
                        // detailsBtn
                        // 
                        this.detailsBtn.ImageAlign = System.Drawing.ContentAlignment.MiddleLeft;
                        this.detailsBtn.Location = new System.Drawing.Point(5, 80);
                        this.detailsBtn.Name = "detailsBtn";
                        this.detailsBtn.Size = new System.Drawing.Size(100, 23);
                        this.detailsBtn.TabIndex = 3;
                        this.detailsBtn.Text = "";
                        this.detailsBtn.Click += new System.EventHandler(this.DetailsClick);
                        // 
                        // okBtn
                        // 
                        this.okBtn.Anchor = (System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right);
                        this.okBtn.Location = new System.Drawing.Point(110, 80);
                        this.okBtn.Name = "okBtn";
                        this.okBtn.Size = new System.Drawing.Size(80, 23);
                        this.okBtn.TabIndex = 0;
                        this.okBtn.Text = "OK";
                        this.okBtn.Click += new System.EventHandler(this.OnButtonClick);
            this.okBtn.DialogResult = System.Windows.Forms.DialogResult.OK;
                        // 
                        // cancelBtn
                        // 
                        this.cancelBtn.Anchor = (System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right);
                        this.cancelBtn.DialogResult = System.Windows.Forms.DialogResult.Cancel;
                        this.cancelBtn.Location = new System.Drawing.Point(195, 80);
                        this.cancelBtn.Name = "cancelBtn";
                        this.cancelBtn.Size = new System.Drawing.Size(80, 23);
                        this.cancelBtn.TabIndex = 1;
                        this.cancelBtn.Text = "";
                        this.cancelBtn.Click += new System.EventHandler(this.OnButtonClick);
                        // 
                        // details
                        // 
                        this.details.Anchor = ((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
                                | System.Windows.Forms.AnchorStyles.Right);
                        this.details.BackColor = System.Drawing.SystemColors.Control;
                        this.details.BorderStyle = System.Windows.Forms.BorderStyle.None;
                        this.details.Location = new System.Drawing.Point(8, 112);
                        this.details.Multiline = true;
                        this.details.Name = "details";
                        this.details.ReadOnly = true;
                        this.details.Size = new System.Drawing.Size(242, 100);
                        this.details.TabIndex = 2;
                        this.details.TabStop = false;
                        this.details.Text = "";
                        this.details.Visible = false;
                        // 
                        // Form1
                        // 
                        this.AcceptButton = this.okBtn;
            this.StartPosition = FormStartPosition.CenterScreen;
                        this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
                        this.CancelButton = this.cancelBtn;
                        this.ClientSize = new System.Drawing.Size(286, 113);
                        this.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                                                                                                  this.cancelBtn,
                                                                                                                                                  this.okBtn,
                                                                                                                                                  this.detailsBtn,
                                                                                                                                                  this.details,
                                                                                                                                                  this.pictureBox,
                                                                                                                                                  this.lblMessage});
                        this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
                        this.MaximizeBox = false;
                        this.MinimizeBox = false;
                        this.Name = "Form1";
            this.ResumeLayout(false);

                }

        private void OnButtonClick(object s, EventArgs e) {
            DialogResult = ((Button)s).DialogResult;
            Close();
        }

        protected override void OnVisibleChanged(EventArgs e) {
            if (this.Visible) {

                // make sure the details button is sized properly
                //
                Graphics g = CreateGraphics();
                int detailsWidth = (int)g.MeasureString(detailsBtn.Text, detailsBtn.Font).Width;
                detailsWidth += detailsBtn.Image.Width;
                detailsBtn.Width = detailsWidth + 8;
                g.Dispose();

                if (details.Visible) {
                    DetailsClick(details, EventArgs.Empty);
                }
            }
            okBtn.Focus();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\gridtooltip.cs ===
//------------------------------------------------------------------------------
// <copyright file="GridToolTip.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.PropertyGridInternal {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Diagnostics;

    using System;
    using System.Collections;
    
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.IO;
    using System.Drawing;
    using Microsoft.Win32;
    using Message = System.Windows.Forms.Message;

    internal class GridToolTip : Control {

        Control[]    controls;
        string       toolTipText;
        NativeMethods.TOOLINFO_T[]   toolInfos;
        bool         dontShow;
        Point        lastMouseMove = Point.Empty;

        internal GridToolTip(Control[] controls) {
            this.controls = controls;
            SetStyle(ControlStyles.UserPaint, false);
            this.Font = controls[0].Font;
            this.toolInfos = new NativeMethods.TOOLINFO_T[controls.Length];
            
            for (int i = 0; i < controls.Length; i++) {
                  controls[i].HandleCreated += new EventHandler(this.OnControlCreateHandle);
                  controls[i].HandleDestroyed += new EventHandler(this.OnControlDestroyHandle);
                  
                  if (controls[i].IsHandleCreated) {
                     SetupToolTip(controls[i]);
                  }
            }
        }

        public string ToolTip{
            get {
               return toolTipText;
            }
            set {  
                  this.Reset();

                  this.toolTipText = value;

                  if (this.IsHandleCreated) {

                     bool visible = this.Visible;

                     if (visible){
                        this.Visible = false;
                     }

                     // here's a hack.  if we give
                     // the tooltip an empty string, it won't come back
                     // so we just force it hidden instead
                     //
                     if (value == null || value.Length == 0){
                        dontShow = true;
                        value = "";
                     }
                     else{
                        dontShow = false;
                     }
                     
                     for (int i = 0; i < controls.Length; i++) {
                        UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_UPDATETIPTEXT, 0, GetTOOLINFO(controls[i]));
                     }

                     if (visible && !dontShow){
                        this.Visible = true;
                     }
                  
               }
            }
        }


        /// <include file='doc\GridToolTip.uex' path='docs/doc[@for="GridToolTip.CreateParams"]/*' />
        /// <devdoc>
        ///     The createParams to create the window.
        /// </devdoc>
        /// <internalonly/>
        protected override  CreateParams CreateParams {
            get {
                NativeMethods.INITCOMMONCONTROLSEX icc = new NativeMethods.INITCOMMONCONTROLSEX();
                icc.dwICC = NativeMethods.ICC_TAB_CLASSES;
                SafeNativeMethods.InitCommonControlsEx(icc);
                CreateParams cp = new CreateParams();
                cp.Parent = IntPtr.Zero;
                cp.ClassName = NativeMethods.TOOLTIPS_CLASS;
                cp.Style |= NativeMethods.TTS_ALWAYSTIP;
                cp.ExStyle = 0;
                cp.Caption = this.ToolTip;
                return cp;
            }
        }

        private NativeMethods.TOOLINFO_T GetTOOLINFO(Control c) {
        
            int index = Array.IndexOf(controls, c);
            
            Debug.Assert(index != -1, "Failed to find control in tooltip array");
            
            if (toolInfos[index] == null){
               toolInfos[index] = new NativeMethods.TOOLINFO_T();
               toolInfos[index].cbSize = Marshal.SizeOf(typeof(NativeMethods.TOOLINFO_T));
               toolInfos[index].uFlags |= NativeMethods.TTF_IDISHWND | NativeMethods.TTF_TRANSPARENT | NativeMethods.TTF_SUBCLASS;
            }
            toolInfos[index].lpszText = this.toolTipText;
            toolInfos[index].hwnd = c.Handle;
            toolInfos[index].uId = c.Handle;
            return toolInfos[index];
        }

        private bool MouseMoved(Message msg){
            bool moved = true;

            Point newMove = new Point(NativeMethods.Util.LOWORD(msg.LParam), NativeMethods.Util.HIWORD(msg.LParam));

            // check if the mouse has actually moved...
            if (lastMouseMove == newMove){
                  moved = false;
            }

            lastMouseMove = newMove;
            return moved;
        }

        private void OnControlCreateHandle(object sender, EventArgs e){
            SetupToolTip((Control)sender);
        }

        private void OnControlDestroyHandle(object sender, EventArgs e){
            if (IsHandleCreated) {
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_DELTOOL, 0, GetTOOLINFO((Control)sender));
            }
        }
        
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            for (int i = 0; i < controls.Length; i++) {
                  if (controls[i].IsHandleCreated) {
                     SetupToolTip(controls[i]);
                  }
            }
        }

        private void SetupToolTip(Control c) {
            
            if (this.IsHandleCreated) {
               SafeNativeMethods.SetWindowPos(new HandleRef(this, Handle), NativeMethods.HWND_TOPMOST,
                                 0, 0, 0, 0,
                                 NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOSIZE |
                                 NativeMethods.SWP_NOACTIVATE);

               if (0 == (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_ADDTOOL, 0, GetTOOLINFO(c))) {
                     Debug.Fail("TTM_ADDTOOL failed for " + c.GetType().Name);
               }

            // Setting the max width has the added benefit of enabling multiline
            // tool tips! subhag 66503)
            //
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_SETMAXTIPWIDTH, 0, SystemInformation.MaxWindowTrackSize.Width);


            }
        }

        public void Reset(){

            // okay, this resets the tooltip state,
            // which can get screwed up when we leave the window
            // then reenter.  So we set the tooltip to null,
            // update the text, then it back to what it was, so the tooltip
            // thinks it's back in the regular state again
            //
            string oldText = this.ToolTip;
            this.toolTipText = "";
            for (int i = 0; i < controls.Length; i++) {
               if (0 == (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_UPDATETIPTEXT, 0, GetTOOLINFO(controls[i]))) {
                    //Debug.Fail("TTM_UPDATETIPTEXT failed for " + controls[i].GetType().Name);
               }
            }
            this.toolTipText = oldText;
            this.SendMessage(NativeMethods.TTM_UPDATE, 0, 0);
        }

        protected override void WndProc(ref Message msg) {
            switch (msg.Msg) {
               case NativeMethods.WM_SHOWWINDOW:
                  if ((int)msg.WParam != 0 && dontShow){
                     msg.WParam = IntPtr.Zero;
                  }
                  break;
            }
            base.WndProc(ref msg);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\doccomment.cs ===
//------------------------------------------------------------------------------
// <copyright file="DocComment.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.PropertyGridInternal {

    using System.Diagnostics;

    using System;
    using System.Windows.Forms;
    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing;
    using Microsoft.Win32;

    internal class DocComment : PropertyGrid.SnappableControl {
        
        private Label m_labelTitle;
        //private Edit m_labelDesc;
        private Label m_labelDesc;
        private string fullDesc;
        
        protected int lineHeight;
        private bool needUpdateUIWithFont = true;

        protected const int CBORDER = 3;
        protected const int CXDEF = 0;
        protected const int CYDEF = 59;
        protected const int MIN_LINES = 2;
        
        private const int StringDelta = 8;
        private readonly static string Ellipsis = " ...";

        internal Rectangle rect = Rectangle.Empty;

        internal DocComment() {
            m_labelTitle = new Label();
            m_labelTitle.UseMnemonic = false;
            m_labelDesc = new Label();
            m_labelTitle.Cursor = Cursors.Default;
            m_labelDesc.Cursor = Cursors.Default;


            Controls.Add(m_labelTitle);
            Controls.Add(m_labelDesc);

            Size = new Size(CXDEF,CYDEF);

            this.Text = "Description Pane";
            SetStyle(ControlStyles.Selectable, false);
        }

        public virtual int Lines {
            get {
                UpdateUIWithFont();
                return Height/lineHeight;
            }
            set {
                UpdateUIWithFont();
                Size = new Size(Width, 1 + value * lineHeight);
            }
        }
        
        
        // makes sure that we can display the full text or crops the text and adds 
        // an ellipsis
        //
        private string AdjustDescriptionToSize(string desc) {
            
            int thisWidth = m_labelDesc.ClientRectangle.Width;
            
            // check if we want to bother to do this...
            //
            if (!IsHandleCreated || !Visible || thisWidth == 0 || desc == null) {
                return desc;
            }
        
            Graphics g = m_labelDesc.CreateGraphicsInternal();
            
            try {
                // cache the stuff
                // we'll be reusing
                //
                Font f = m_labelDesc.Font;
                int startLen = desc.Length;
                
                int labelHeight = Math.Min(m_labelDesc.Height, this.Height - m_labelDesc.Top);
                int ellipsisWidth = (int)g.MeasureString(Ellipsis, f).Width + 1; // we add a little fudge factor here.
                int lineHeight = (int)g.MeasureString("XXX", f).Height + 1; // we add a little fudge factor here.
                
                
                labelHeight = Math.Max(labelHeight, lineHeight);
                
                SizeF strSize = g.MeasureString(desc, f, thisWidth);
                
                int nextDelta;
                int lastSpace = desc.LastIndexOf(' ');
                
                if (lastSpace != -1) {
                    nextDelta = Math.Min(StringDelta, desc.Length - lastSpace);
                }
                else {
                    nextDelta = StringDelta;
                }

                // first do a quick check to prevent us from processing very long strings.
                // so we chop the string so its ~ twice as large as can fit.
                // 
                float hRatio = strSize.Height / labelHeight;
                if (hRatio > 2) {
                    hRatio = 2f / hRatio;
                    int newLength = (int)(desc.Length * hRatio);
                    desc = desc.Substring(0, newLength);
                }
                
                // check to see if :
                // 1) the text is too tall for the label
                // 2) the text can fit in one line
                // 3) we've got enough text to lop off our delta
                //
                while ((strSize.Height > labelHeight || (strSize.Height <= lineHeight && (strSize.Width > thisWidth))) && desc.Length > nextDelta) {
                    lastSpace = desc.LastIndexOf(' ');
                
                    if (lastSpace != -1) {
                        nextDelta = Math.Min(StringDelta, desc.Length - lastSpace);
                    }
                    else {
                        nextDelta = StringDelta;
                    }
                    
                    // crop the delta and try again.
                    //
                    if (desc.Length < nextDelta) {
                        break;
                    }

                    desc = desc.Substring(0, desc.Length - nextDelta);
                    strSize = g.MeasureString(desc + Ellipsis, f, thisWidth);
                }
                
                // add the ellipsis if necessary
                if (desc.Length != startLen) {
                    desc += Ellipsis;
                }
                return desc;
            }
            finally {
                g.Dispose();
            }
        }

        public override int GetOptimalHeight(int width) {
            UpdateUIWithFont();
            // compute optimal label height as one line only.
            int height = m_labelTitle.Size.Height;

            // compute optimal text height
            Graphics g = m_labelDesc.CreateGraphicsInternal();
            Size sz = Size.Ceiling(g.MeasureString(m_labelTitle.Text, Font, width));
            g.Dispose();
            height += (sz.Height * 2) + 2;
            return Math.Max(height + 4, CYDEF);
        }

        internal virtual void LayoutWindow() {
        }

        protected override void OnFontChanged(EventArgs e) {
            needUpdateUIWithFont = true;
            PerformLayout();
            base.OnFontChanged(e);
        }

        protected override void OnLayout(LayoutEventArgs e) {
            UpdateUIWithFont();
            Size size = ClientSize;
            size.Width -= 2*CBORDER;
            size.Height -= 2*CBORDER;
            m_labelTitle.Size = new Size(size.Width,Math.Min(lineHeight, size.Height));
            m_labelDesc.Size = new Size(size.Width,Math.Max(0,size.Height-lineHeight-1));
            m_labelDesc.Text = AdjustDescriptionToSize(this.fullDesc);
            m_labelDesc.AccessibleName = this.fullDesc; // Don't crop the description for accessibility clients
            base.OnLayout(e);
        }
        
        protected override void OnResize(EventArgs e) {
            Rectangle newRect = ClientRectangle;
            if (!rect.IsEmpty && newRect.Width > rect.Width) {
                Rectangle rectInvalidate = new Rectangle(rect.Width-1,0,newRect.Width-rect.Width+1,rect.Height);
                Invalidate(rectInvalidate);
            }
            rect = newRect;
            base.OnResize(e);
        }

        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            UpdateUIWithFont();
        }

        public virtual void SetComment(string title, string desc) {
            if (m_labelDesc.Text != title) {
                m_labelTitle.Text = title;
            }
            
            if (desc != fullDesc) {
                this.fullDesc = desc;
                m_labelDesc.Text = AdjustDescriptionToSize(fullDesc);
                m_labelDesc.AccessibleName = this.fullDesc; // Don't crop the description for accessibility clients
            }
        }

        public override int SnapHeightRequest(int cyNew) {
            UpdateUIWithFont();
            int lines = Math.Max(MIN_LINES, cyNew/lineHeight);
            return 1 + lines*lineHeight;
        }

        private void UpdateUIWithFont() {
            if (IsHandleCreated && needUpdateUIWithFont) {

                // Some fonts throw because Bold is not a valid option
                // for them.  Fail gracefully.
                try {
                    m_labelTitle.Font = new Font(Font, FontStyle.Bold);
                }
                catch {
                }

                lineHeight = (int)Font.Height + 2;

                m_labelTitle.Location = new Point(CBORDER, CBORDER);
                m_labelDesc.Location = new Point(CBORDER, CBORDER + lineHeight);

                needUpdateUIWithFont = false;
                PerformLayout();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\hotcommands.cs ===
//------------------------------------------------------------------------------
// <copyright file="HotCommands.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.PropertyGridInternal {
    using System.Text;

    using System.Diagnostics;

    using System;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing;
    using Microsoft.Win32;

    internal class HotCommands : PropertyGrid.SnappableControl {

        private object component;
        private DesignerVerb[] verbs;
        private HCLinkLabel label;
        private bool allowVisible = true;
        private int optimalHeight = -1;

        internal HotCommands() {
            this.Text = "Command Pane";
        }

        public virtual bool AllowVisible {
            get {
                return allowVisible;
            }
            set {
                if (this.allowVisible != value) {
                    this.allowVisible = value;
                    if (value && WouldBeVisible)
                        this.Visible = true;
                    else
                        this.Visible = false;
                }
            }
        }

        public override Rectangle DisplayRectangle {
            get {
                Size sz = ClientSize;
                return new Rectangle(4, 4, sz.Width - 8, sz.Height - 8);
            }
        }

        private HCLinkLabel Label {
            get {
                if (label == null) {
                    label = new HCLinkLabel();
                    label.Dock = DockStyle.Fill;
                    label.LinkBehavior = LinkBehavior.AlwaysUnderline;
                    
                    // use default LinkLabel colors for regular, active, and visited
                    label.DisabledLinkColor = SystemColors.ControlDark;
                    label.LinkClicked += new LinkLabelLinkClickedEventHandler(this.LinkClicked);
                    this.Controls.Add(label);
                }
                return label;
            }
        }


        public virtual bool WouldBeVisible {
            get {
                return (component != null);
            }
        }

        public override int GetOptimalHeight(int width) {
            if (optimalHeight == -1) {
                int lineHeight = (int)(1.5 * Font.Height);
                int verbCount = 0;
                if (verbs != null) {
                    verbCount = verbs.Length;
                }
                optimalHeight = verbCount * lineHeight + 8;
            }
            return optimalHeight;
        }
        public override int SnapHeightRequest(int request) {
            return request;
        }

        private void LinkClicked(object sender, LinkLabelLinkClickedEventArgs e) {
            try {
                if (!e.Link.Enabled) {
                    return;
                }
            
                ((DesignerVerb)e.Link.LinkData).Invoke();
            }
            catch (Exception ex) {
                MessageBox.Show(this, ex.Message, SR.GetString(SR.PBRSErrorTitle), MessageBoxButtons.OK, MessageBoxIcon.Warning);
            }
        }

        private void OnCommandChanged(object sender, EventArgs e) {
            SetupLabel();
        }
        
        protected override void OnGotFocus(EventArgs e) {
            Label.FocusInternal();
            Label.Invalidate();
        } 

        protected override void OnFontChanged(EventArgs e) {
            base.OnFontChanged(e);
            optimalHeight = -1;
        }

        internal void SetColors(Color background, Color normalText, Color link, Color activeLink, Color visitedLink, Color disabledLink) {
            Label.BackColor = background;
            Label.ForeColor = normalText;
            Label.LinkColor = link;
            Label.ActiveLinkColor = activeLink;
            Label.VisitedLinkColor = visitedLink;
            Label.DisabledLinkColor = disabledLink;
        }

        public void Select(bool forward) {
            Label.FocusInternal();
            Label.Select(forward);
        }

        public virtual void SetVerbs(object component, DesignerVerb[] verbs) {
            if (this.verbs != null) {
                for (int i = 0; i < this.verbs.Length; i++){
                    this.verbs[i].CommandChanged -= new EventHandler(this.OnCommandChanged);
                }
                this.component = null;
                this.verbs = null;
            }

            if (component == null || verbs == null || verbs.Length == 0) {
                Visible = false;
            }
            else {
                this.component = component;
                this.verbs = verbs;

                for (int i = 0; i < verbs.Length; i++){
                    verbs[i].CommandChanged += new EventHandler(this.OnCommandChanged);
                }

                if (allowVisible) {
                    Visible = true;
                }
                SetupLabel();
            }

            optimalHeight = -1;
        }

        private void SetupLabel() {
            Label.Links.Clear();
            StringBuilder sb = new StringBuilder();
            Point[] links = new Point[verbs.Length];
            int charLoc = 0;

            for (int i=0; i<verbs.Length; i++) {
                if (verbs[i].Visible) {
                    if (i > 0) {
                        sb.Append(", ");
                        charLoc += 2;
                    }

                    string name = verbs[i].Text;

                    links[i] = new Point(charLoc, name.Length);
                    sb.Append(name);
                    charLoc += name.Length;
                }
            }

            Label.Text = sb.ToString();

            for (int i=0; i<verbs.Length; i++) {
                if (verbs[i].Visible) {
                    LinkLabel.Link link = Label.Links.Add(links[i].X, links[i].Y, verbs[i]);
                    if (!verbs[i].Enabled) {
                        link.Enabled = false;
                    }
                }
            }
        }

        private class HCLinkLabel : LinkLabel {
            
            public HCLinkLabel() {

            }

            protected override void OnLostFocus(EventArgs e) {
                base.OnLostFocus(e);

                // Clear the link so we stay consistant with tabbing.
                // the problem is if you tab to one of the links, then
                // click back on the grid, and tab again, the linklabel
                // thinks it should already have a link selected and will 
                // tab to the next one, so we do this as a way to clear out that
                // old selection.
                //
                string text = base.Text;
                base.Text = "";
                base.Text = text;
            }

            public void Select(bool forward) {
                base.Select(true, forward);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\multiselectrootgridentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="MultiSelectRootGridEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.PropertyGridInternal {
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Collections;
    using System.Reflection;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;
    using Microsoft.Win32;
    using System.Globalization;

    internal class MultiSelectRootGridEntry : SingleSelectRootGridEntry {

        private static PDComparer PropertyComparer = new PDComparer();

        internal MultiSelectRootGridEntry(PropertyGridView view, object obj, GridEntry parent, IServiceProvider baseProvider, IDesignerHost host, PropertyTab tab, PropertySort sortType)
        : base(view, obj,parent, baseProvider, host, tab, sortType) {
        }

        internal MultiSelectRootGridEntry(PropertyGridView view, object obj, IServiceProvider baseProvider, IDesignerHost host, PropertyTab tab, PropertySort sortType)
        : base(view,obj, baseProvider, host, tab, sortType) {
        }

        internal override bool ForceReadOnly {
            get {
                if (!forceReadOnlyChecked) {
                    bool anyRO = false;
                    foreach (object obj in (Array)objValue) {
                        ReadOnlyAttribute readOnlyAttr = (ReadOnlyAttribute)TypeDescriptor.GetAttributes(obj)[typeof(ReadOnlyAttribute)];
                        if ((readOnlyAttr != null && !readOnlyAttr.IsDefaultAttribute()) || TypeDescriptor.GetAttributes(obj).Contains(InheritanceAttribute.InheritedReadOnly)) {
                            anyRO = true;
                            break;
                        }
                    }
                    if (anyRO) {
                        flags |= FLAG_FORCE_READONLY;
                    }
                    forceReadOnlyChecked = true;
                }
                return base.ForceReadOnly;
            }
        }

        protected override bool CreateChildren() {
             return CreateChildren(false);
        }

        protected override bool CreateChildren(bool diffOldChildren) {
            try {
                object[] rgobjs = (object[])objValue;
                

                ChildCollection.Clear();

                MultiPropertyDescriptorGridEntry[] mergedProps = PropertyMerger.GetMergedProperties(rgobjs, this, this.PropertySort, CurrentTab);
                
                Debug.Assert(mergedProps != null, "MergedProps returned null!");

                if (mergedProps != null) {
                    ChildCollection.AddRange(mergedProps);
                }
                bool fExpandable = this.Children.Count > 0;
                if (!fExpandable) {
                    //Debug.WriteLine("Object " + rgobjs[0].GetType().FullName + " is not expandable because it has no children");
                    SetFlag(GridEntry.FL_EXPANDABLE_FAILED,true);
                }
                CategorizePropEntries();
                return fExpandable;
            }
            catch (Exception) {
                return false;
            }
        }

       
        internal class PropertyMerger {

             public static MultiPropertyDescriptorGridEntry[] GetMergedProperties(object[] rgobjs, GridEntry parentEntry, PropertySort sort, PropertyTab tab) {

                MultiPropertyDescriptorGridEntry[] result = null;
                try {
                    int cLength = rgobjs.Length;
                    object[] rgobjArgs = new object[1];
                    
                    if((sort & PropertySort.Alphabetical) != 0) {
                        ArrayList props = GetCommonProperties(rgobjs, true, tab, parentEntry);
                        
                        MultiPropertyDescriptorGridEntry[] entries = new MultiPropertyDescriptorGridEntry[props.Count];
                        for (int i=0; i < entries.Length; i++) {
                            entries[i] = new MultiPropertyDescriptorGridEntry(parentEntry, rgobjs, (PropertyDescriptor[])props[i], false);
                        }
    
                        result = SortParenEntries(entries);
                    }
                    else {
                        object[] sortObjs = new object[cLength - 1];
                        Array.Copy(rgobjs, 1, sortObjs, 0, cLength - 1);
    
                        ArrayList props = GetCommonProperties(sortObjs, true, tab, parentEntry);
    
                        // this'll work for just one as well
                        ArrayList firstProps = GetCommonProperties(new object[]{rgobjs[0]}, false, tab, parentEntry);
    
                        PropertyDescriptor[] firstPds = new PropertyDescriptor[firstProps.Count];
                        for (int i = 0; i < firstProps.Count; i++) {
                            firstPds[i] = ((PropertyDescriptor[])firstProps[i])[0];
                        }
                        
                        props = UnsortedMerge(firstPds, props);
                        
                        MultiPropertyDescriptorGridEntry[] entries = new MultiPropertyDescriptorGridEntry[props.Count];
                        
                        for (int i=0; i < entries.Length; i++) {
                            entries[i] = new MultiPropertyDescriptorGridEntry(parentEntry, rgobjs, (PropertyDescriptor[])props[i], false);
                        }
    
                        result = SortParenEntries(entries);
                    }
                }
                catch (Exception) {
                }
    
                return result;
    
            }

            // this returns an array list of the propertydescriptor arrays, one for each
            // component
            //
            private static ArrayList GetCommonProperties(object[] objs, bool presort, PropertyTab tab, GridEntry parentEntry) {
                PropertyDescriptorCollection[] propCollections = new PropertyDescriptorCollection[objs.Length];
    
                ArrayList finalProps = new ArrayList();
    
                Attribute[] attrs = new Attribute[parentEntry.BrowsableAttributes.Count];
                parentEntry.BrowsableAttributes.CopyTo(attrs, 0);
                
                for (int i = 0; i < objs.Length; i++) {
                    PropertyDescriptorCollection pdc = tab.GetProperties(parentEntry, objs[i], attrs);
                    if (presort) {
                        pdc = pdc.Sort(PropertyComparer);
                    }
                    propCollections[i] = pdc;
                }
                
                ArrayList mergedList = new ArrayList();
                PropertyDescriptor[] matchArray = new PropertyDescriptor[objs.Length];
    
               // 
               // Merge the property descriptors
               //
               int[] posArray = new int[propCollections.Length];
               for (int i = 0; i < propCollections[0].Count; i++) {
                   PropertyDescriptor pivotDesc = propCollections[0][i];
                   
                   bool match = pivotDesc.Attributes[typeof(MergablePropertyAttribute)].IsDefaultAttribute();
                        
                   for (int j = 1; match && j < propCollections.Length; j++) {
        
                       if (posArray[j] >= propCollections[j].Count) {
                           match = false;
                           break;
                       }
        
                       // check to see if we're on a match
                       //
                       PropertyDescriptor jProp = propCollections[j][posArray[j]];
                       if (pivotDesc.Equals(jProp)) {
                           posArray[j] += 1;
                           
                           if (!jProp.Attributes[typeof(MergablePropertyAttribute)].IsDefaultAttribute()) {
                                match = false;
                                break;
                           }
                           matchArray[j] = jProp;
                           continue;
                       }
                       
                       int jPos = posArray[j];
                       jProp = propCollections[j][jPos];
    
                       match = false;
        
                       // if we aren't on a match, check all the items until we're past
                       // where the matching item would be
                       while (PropertyComparer.Compare(jProp, pivotDesc) <= 0) {
        
                           // got a match!
                           if (pivotDesc.Equals(jProp)) {
    
                               if (!jProp.Attributes[typeof(MergablePropertyAttribute)].IsDefaultAttribute()) {
                                  match = false;
                                  jPos++;
                               }
                               else {
                                  match = true;
                                  matchArray[j] = jProp;
                                  posArray[j] = jPos + 1;
                               }
                               break;
                           }
        
                           // try again
                           jPos++;
                           if (jPos < propCollections[j].Count) {
                               jProp = propCollections[j][jPos];
                           }
                           else {
                               break;
                           }
                       }
        
                       // if we got here, there is no match, quit for this guy
                       if (!match) {
                            posArray[j] = jPos;
                            break;
                       }
                   }
        
                   // do we have a match?
                   if (match) {
                       matchArray[0] = pivotDesc;
                       mergedList.Add(matchArray.Clone());
                   }
               }
    
               return mergedList;
            }



            private static MultiPropertyDescriptorGridEntry[] SortParenEntries(MultiPropertyDescriptorGridEntry[] entries) {

                MultiPropertyDescriptorGridEntry[] newEntries = null;
                int newPos = 0;
                
                // first scan the list and move any parentesized properties to the front.
                for (int i = 0; i < entries.Length; i++) {
                    if (entries[i].ParensAroundName) {
                        if (newEntries == null) {
                            newEntries = new MultiPropertyDescriptorGridEntry[entries.Length];
                        }
                        newEntries[newPos++] = entries[i];
                        entries[i] = null;
                    }
                }
    
                // second pass, copy any that didn't have the parens.
                if (newPos > 0) {
                    for (int i = 0; i < entries.Length; i++) {
                        if (entries[i] != null) {
                            newEntries[newPos++] = entries[i];
                        }
                    } 
                    entries = newEntries;
                }
                return entries;
            }

            /// <include file='doc\MultiSelectRootGridEntry.uex' path='docs/doc[@for="MultiSelectRootGridEntry.UnsortedMerge"]/*' />
            /// <devdoc>
            /// merges an unsorted array of grid entries with a sorted array of grid entries that
            /// have already been merged.  The resulting array is the intersection of entries between the two,
            /// but in the order of baseEntries.
            /// </devdoc>
            private static ArrayList UnsortedMerge(PropertyDescriptor[] baseEntries, ArrayList sortedMergedEntries) {
                
                ArrayList mergedEntries = new ArrayList();
                PropertyDescriptor[] mergeArray = new PropertyDescriptor[((PropertyDescriptor[])sortedMergedEntries[0]).Length + 1];
                
                for (int i = 0; i < baseEntries.Length; i++) {
    
                    PropertyDescriptor basePd = baseEntries[i];
    
                    // first, do a binary search for a matching item
                    PropertyDescriptor[] mergedEntryList = null;
                    string entryName = basePd.Name + basePd.PropertyType.FullName;
    
                    int len = sortedMergedEntries.Count;
                    // perform a binary search
                    int offset = len / 2;
                    int start = 0;
                    
                    while (len > 0) {
                        PropertyDescriptor[] pdList = (PropertyDescriptor[])sortedMergedEntries[start + offset];
                        PropertyDescriptor pd = pdList[0];
                        string sortString = pd.Name + pd.PropertyType.FullName;
                        int result = String.Compare(entryName, sortString, false, CultureInfo.InvariantCulture);
                        if (result == 0) {
                            mergedEntryList = pdList;
                            break;
                        }
                        else if (result < 0) {
                            len = offset;
                        }
                        else {
                            int delta = offset + 1;
                            start += delta;
                            len -= delta;
                        }
                        offset = len / 2;
                    }
                    
                    if (mergedEntryList != null) {
                        mergeArray[0] = basePd;
                        Array.Copy(mergedEntryList, 0, mergeArray, 1,  mergedEntryList.Length);
                        mergedEntries.Add(mergeArray.Clone());
                    }
                }
                return mergedEntries;
            }

        }
        
        private class PDComparer : IComparer {
            public int Compare(object obj1, object obj2) {
                PropertyDescriptor a1 = obj1 as PropertyDescriptor;
                PropertyDescriptor a2 = obj2 as PropertyDescriptor;
            
                if (a1 == null && a2 == null) {
                    return 0;
                }
                else if (a1 == null) {
                    return -1;
                }
                else if (a2 == null) {
                    return 1;
                }

                int result = String.Compare(a1.Name, a2.Name, false, CultureInfo.InvariantCulture);

                if (result == 0) {
                    // REVIEW: (davidgut) Should this be Invariant or CurrentCulture?  This was reviewed and approved as Invariant!!!!
                    result = String.Compare(a1.PropertyType.FullName, a2.PropertyType.FullName, true, System.Globalization.CultureInfo.CurrentCulture);
                }
                return result;
            }
        }
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\irootgridentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="IRootGridEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.PropertyGridInternal {
    using System.Runtime.InteropServices;

    using System.Diagnostics;

        using System;
        using System.Collections;
        using System.Reflection;
        using System.ComponentModel;
        using System.ComponentModel.Design;
        using System.Windows.Forms;
        using System.Drawing;
        using Microsoft.Win32;

        /// <include file='doc\IRootGridEntry.uex' path='docs/doc[@for="IRootGridEntry"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public interface IRootGridEntry{
                /// <include file='doc\IRootGridEntry.uex' path='docs/doc[@for="IRootGridEntry.BrowsableAttributes"]/*' />
                /// <devdoc>
                ///    <para>[To be supplied.]</para>
                /// </devdoc>
                AttributeCollection BrowsableAttributes {
                     get;
                     set;
                }
                /// <include file='doc\IRootGridEntry.uex' path='docs/doc[@for="IRootGridEntry.ResetBrowsableAttributes"]/*' />
                /// <devdoc>
                ///    <para>[To be supplied.]</para>
                /// </devdoc>

                void ResetBrowsableAttributes();
                /// <include file='doc\IRootGridEntry.uex' path='docs/doc[@for="IRootGridEntry.ShowCategories"]/*' />
                /// <devdoc>
                ///    <para>[To be supplied.]</para>
                /// </devdoc>
                void ShowCategories(bool showCategories);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\immutablepropertydescriptorgridentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImmutablePropertyDescriptorGridEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.PropertyGridInternal {

    using System.Runtime.Serialization.Formatters;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Reflection;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;
    using System.Drawing.Design;
    using Microsoft.Win32;


    // This grid entry is used for immutable objects.  An immutable object is identified
    // through it's TypeConverter, which returns TRUE to ShouldCreateInstance.  For this case,
    // we never go through the property descriptor to change the value, but recreate each
    // time.
    //
    internal class ImmutablePropertyDescriptorGridEntry : PropertyDescriptorGridEntry {

        internal ImmutablePropertyDescriptorGridEntry(GridEntry peParent, PropertyDescriptor propInfo, bool hide)
        : base(peParent, propInfo, hide) {
        }

        protected override bool IsPropertyReadOnly {
            get {
                return ShouldRenderReadOnly;
            }
        }

        public override object PropertyValue {
            get {
                return base.PropertyValue;
            }
            set {

                // Create a new instance of the value and set it into the parent grid entry.
                //
                object owner = GetValueOwner();
                GridEntry parentEntry = ParentGridEntry;
                TypeConverter parentConverter = parentEntry.TypeConverter;

                PropertyDescriptorCollection props = parentConverter.GetProperties(parentEntry, owner);
                IDictionary values = new Hashtable(props.Count);
                object newObject = null;

                for (int i = 0; i < props.Count; i++) {
                    if (propertyInfo.Name != null && propertyInfo.Name.Equals(props[i].Name)) {
                        values[props[i].Name] = value;
                    }
                    else {
                        values[props[i].Name] = props[i].GetValue(owner);
                    }
                }

                try {
                    newObject = parentConverter.CreateInstance(parentEntry, values);
                }
                catch (Exception e) {
                    if (e.Message == null || e.Message.Length == 0) {
                        throw new TargetInvocationException(SR.GetString(SR.ExceptionCreatingObject,
                                                            parentPE.PropertyType.FullName,
                                                            e.ToString()), e);
                    }
                    else
                        throw; // rethrow the same exception
                }

                if (newObject != null) {
                    parentEntry.PropertyValue = newObject;
                }
            }
        }

        internal override bool NotifyValueGivenParent(object obj, int type) {
            return ParentGridEntry.NotifyValue(type);
        }

        public override bool ShouldRenderReadOnly {
            get {
                return ParentGridEntry.ShouldRenderReadOnly;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\multipropertydescriptorgridentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="MultiPropertyDescriptorGridEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   MultiPropertyDescriptorGridEntry.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
/*
 */
namespace System.Windows.Forms.PropertyGridInternal {
    using System.Runtime.Serialization.Formatters;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Reflection;    
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;

    internal class MultiPropertyDescriptorGridEntry : PropertyDescriptorGridEntry {


        private MergePropertyDescriptor mergedPd;
        private object[]                objs;

        public MultiPropertyDescriptorGridEntry(GridEntry peParent, object[] objectArray, PropertyDescriptor[] propInfo, bool hide) : base (peParent, hide) {
            mergedPd = new MergePropertyDescriptor(propInfo);
            this.objs = objectArray;
            base.Initialize(mergedPd);
        }

        public override IContainer Container {
            get {
                IContainer c = null;

                foreach (object o in objs) {
                    IComponent comp = o as IComponent;
                    if (comp == null) {
                        c = null;
                        break;
                    }

                    if (comp.Site != null) {
                        if (c == null) {
                            c = comp.Site.Container;
                            continue;
                        }
                        else if (c == comp.Site.Container) {
                            continue;
                        }
                    }
                    c = null;
                    break;
                }
                return c;
            }
        }

        public override bool Expandable {
            get {
                bool fExpandable = GetFlagSet(FL_EXPANDABLE);

                if (fExpandable && ChildCollection.Count > 0) {
                    return true;
                }

                if (GetFlagSet(FL_EXPANDABLE_FAILED)) {
                    return false;
                }

                try {
                    foreach (object o in mergedPd.GetValues(objs)) {
                        if (o == null) {
                            fExpandable = false;
                            break;
                        }
                    }
                }
                catch {
                    fExpandable = false;
                }

                return fExpandable;
            }
        }

        public override object PropertyValue{
            set {
                base.PropertyValue = value;

                RecreateChildren();
                if (Expanded)
                    GridEntryHost.Refresh(false);

            }
        }

        protected override bool CreateChildren() {
            return CreateChildren(false);
        }

        protected override bool CreateChildren(bool diffOldChildren) {
            try {

                if (mergedPd.PropertyType.IsValueType || (Flags & GridEntry.FLAG_IMMUTABLE) != 0) {
                    return base.CreateChildren(diffOldChildren);
                }

                ChildCollection.Clear();

                MultiPropertyDescriptorGridEntry[] mergedProps = MultiSelectRootGridEntry.PropertyMerger.GetMergedProperties(mergedPd.GetValues(objs), this, this.PropertySort, this.CurrentTab);

                Debug.Assert(mergedProps != null, "MergedProps returned null!");

                if (mergedProps != null) {
                    ChildCollection.AddRange(mergedProps);
                }
                bool fExpandable = this.Children.Count > 0;
                if (!fExpandable) {
                    SetFlag(GridEntry.FL_EXPANDABLE_FAILED,true);
                }
                return fExpandable;
            }
            catch (Exception) {
                return false;
            }
        }

        public override object GetChildValueOwner(GridEntry childEntry) {
            if (mergedPd.PropertyType.IsValueType || (Flags & GridEntry.FLAG_IMMUTABLE) != 0) {
                return base.GetChildValueOwner(childEntry);
            }
            return mergedPd.GetValues(objs);
        }

        public override IComponent[] GetComponents() {
            IComponent[] temp = new IComponent[objs.Length];
            Array.Copy(objs, 0, temp, 0, objs.Length);
            return temp;
        }

        /// <include file='doc\MultiSelectPropertyGridEntry.uex' path='docs/doc[@for="MultiSelectPropertyGridEntry.GetPropertyTextValue"]/*' />
        /// <devdoc>
        /// Returns the text value of this property.
        /// </devdoc>
        public override string GetPropertyTextValue(object value) {

            bool allEqual = true;
            try{
                if (value == null && mergedPd.GetValue(objs, out allEqual) == null) {
                    if (!allEqual) {
                        return "";
                    }
                }
            }
            catch{
                return "";
            }
            return base.GetPropertyTextValue(value);
        }

        internal override bool NotifyChildValue(GridEntry pe, int type) {
            bool success = false;

            IDesignerHost host = DesignerHost;
            DesignerTransaction trans = null;

            if (host != null) {
                trans = host.CreateTransaction();
            }
            try {
                success = base.NotifyChildValue(pe, type);
            }
            finally {
                if (trans != null) {
                    trans.Commit();
                }
            }
            return success;
        }

        protected override void NotifyParentChange(GridEntry ge) {
            // now see if we need to notify the parent(s) up the chain
            while (ge != null &&
                   ge is PropertyDescriptorGridEntry &&
                   ((PropertyDescriptorGridEntry)ge).propertyInfo.Attributes.Contains(NotifyParentPropertyAttribute.Yes)) {

                // find the next parent property with a differnet value owner
                object owner = ge.GetValueOwner();

                // find the next property descriptor with a different parent
                while (!(ge is PropertyDescriptorGridEntry) || OwnersEqual(owner, ge.GetValueOwner())) {
                    ge = ge.ParentGridEntry;
                    if (ge == null) {
                        break;
                    }
                }

                // fire the change on that owner
                if (ge != null) {
                    owner = ge.GetValueOwner();

                    IComponentChangeService changeService = ComponentChangeService;

                    if (changeService != null) {
                        Array ownerArray = owner as Array;
                        if (ownerArray != null) {
                            for (int i = 0; i < ownerArray.Length; i++) {
                                PropertyDescriptor pd = ((PropertyDescriptorGridEntry)ge).propertyInfo;;

                                if (pd is MergePropertyDescriptor) {
                                    pd = ((MergePropertyDescriptor)pd)[i];
                                }

                                if (pd != null) {
                                    changeService.OnComponentChanging(ownerArray.GetValue(i), pd);
                                    changeService.OnComponentChanged(ownerArray.GetValue(i), pd, null, null);
                                }
                            }
                        }
                        else {
                            changeService.OnComponentChanging(owner, ((PropertyDescriptorGridEntry)ge).propertyInfo);
                            changeService.OnComponentChanged(owner, ((PropertyDescriptorGridEntry)ge).propertyInfo, null, null);
                        }
                    }
                }
            }
        }

        internal override bool NotifyValueGivenParent(object obj, int type) {
            if (obj is ICustomTypeDescriptor) {
                obj = ((ICustomTypeDescriptor)obj).GetPropertyOwner(propertyInfo);
            }

            switch (type) {
                case NOTIFY_DBL_CLICK:
                case NOTIFY_RETURN:
                    Debug.Assert(propertyInfo is MergePropertyDescriptor, "Did not get a MergePropertyDescriptor!!!");
                    Debug.Assert(obj is object[], "Did not get an array of objects!!");

                    MergePropertyDescriptor mpd = propertyInfo as MergePropertyDescriptor;
                    
                    if (mpd != null) {
                        object[] objs = (object[])obj;

                        if (eventBindings == null) {
                            eventBindings = (IEventBindingService)GetService(typeof(IEventBindingService));
                        }

                        if (eventBindings != null) {
                            EventDescriptor descriptor = eventBindings.GetEvent(mpd[0]);
                            if (descriptor != null) {
                                return ViewEvent(obj, null, descriptor, true);
                            }
                        }
                    
                        return false;
                    }
                    else {
                        return base.NotifyValueGivenParent(obj, type);
                    }
            }

            return base.NotifyValueGivenParent(obj, type);
        }

        private bool OwnersEqual(object owner1, object owner2) {
            if (!(owner1 is Array)) {
                return owner1 == owner2;
            }
            else {
                Array a1 = owner1 as Array;
                Array a2 = owner2 as Array;

                if (a1 != null && a2 != null && a1.Length == a2.Length) {
                    for (int i = 0; i < a1.Length; i++) {
                        if (a1.GetValue(i) != a2.GetValue(i)) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            }
        }


        public override bool OnComponentChanging() {
            if (ComponentChangeService != null) {
                int cLength = objs.Length;
                for (int i = 0; i < cLength; i++) {
                    try {
                        ComponentChangeService.OnComponentChanging(objs[i], mergedPd[i]);
                    }
                    catch (CheckoutException co) {
                        if (co == CheckoutException.Canceled) {
                            return false;
                        }
                        throw co;
                    }
                }
            }
            return true;
        }

        public override void OnComponentChanged() {
            if (ComponentChangeService != null) {
                int cLength = objs.Length;
                for (int i = 0; i < cLength; i++) {
                    ComponentChangeService.OnComponentChanged(objs[i], mergedPd[i], null, null);
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\mergepropertydescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="MergePropertyDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.PropertyGridInternal {
    using System.Runtime.Serialization.Formatters;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Reflection;    
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;
    
    internal class MergePropertyDescriptor : PropertyDescriptor {

        private PropertyDescriptor[] descriptors;

        private enum TriState {
                Unknown,
                Yes,
                No
        }

        private TriState localizable = TriState.Unknown;
        private TriState readOnly = TriState.Unknown;
        private TriState canReset = TriState.Unknown;

        private MultiMergeCollection collection;

        
        public MergePropertyDescriptor(PropertyDescriptor[] descriptors) : base(descriptors[0].Name, null)  {
            this.descriptors = descriptors;
        }


        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, gets the type of the
        ///       component this property
        ///       is bound to.
        ///    </para>
        /// </devdoc>
        public override Type ComponentType {
                get {
                    return descriptors[0].ComponentType;
                }
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.Converter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type converter for this property.
        ///    </para>
        /// </devdoc>
        public override TypeConverter Converter {
            get {
                return descriptors[0].Converter;
            }
        }

        public override string DisplayName {
            get {
                return descriptors[0].DisplayName;
            }
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.IsLocalizable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value
        ///       indicating whether this property should be localized, as
        ///       specified in the <see cref='System.ComponentModel.LocalizableAttribute'/>.
        ///    </para>
        /// </devdoc>
        public override bool IsLocalizable {
            get {
                if (localizable == TriState.Unknown) {
                    localizable = TriState.Yes;
                    foreach (PropertyDescriptor pd in descriptors) {
                        if (!pd.IsLocalizable) {
                            localizable = TriState.No;
                            break;
                        }
                    }
                }
                return (localizable == TriState.Yes);
            }
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in
        ///       a derived class, gets a value
        ///       indicating whether this property is read-only.
        ///    </para>
        /// </devdoc>
        public override bool IsReadOnly { 
            get {
                if (readOnly == TriState.Unknown) {
                    readOnly = TriState.No;
                    foreach (PropertyDescriptor pd in descriptors) {
                        if (pd.IsReadOnly) {
                            readOnly = TriState.Yes;
                            break;
                        }
                    }
                }
                return (readOnly == TriState.Yes);
            }
        }

   
        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.PropertyType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class,
        ///       gets the type of the property.
        ///    </para>
        /// </devdoc>
        public override Type PropertyType { 
            get {
                return descriptors[0].PropertyType;
            }
        }

        public PropertyDescriptor this[int index] {
            get {
                return descriptors[index];
            }
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.CanResetValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, indicates whether
        ///       resetting the <paramref name="component "/>will change the value of the
        ///    <paramref name="component"/>.
        /// </para>
        /// </devdoc>
        public override bool CanResetValue(object component) {
            Debug.Assert(component is Array, "MergePropertyDescriptor::CanResetValue called with non-array value");
            if (canReset == TriState.Unknown) {
                 canReset = TriState.Yes;
                 Array a = (Array)component;
                 for (int i = 0; i < descriptors.Length; i++) {
                     if (!descriptors[i].CanResetValue(a.GetValue(i))) {
                         canReset = TriState.No;
                         break;
                     }
                 }
                 
             }
             return (canReset == TriState.Yes);
        }

         /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.CreateAttributeCollection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a collection of attributes using the
        ///       array of attributes that you passed to the constructor.
        ///    </para>
        /// </devdoc>
        protected override AttributeCollection CreateAttributeCollection() {
            return new MergedAttributeCollection(this);
        }


              /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.GetEditor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an editor of the specified type.
        ///    </para>
        /// </devdoc>
        public override object GetEditor(Type editorBaseType) {
            return descriptors[0].GetEditor(editorBaseType);
        }


        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.GetValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, gets the current
        ///       value
        ///       of the
        ///       property on a component.
        ///    </para>
        /// </devdoc>
        public override object GetValue(object component) {
            Debug.Assert(component is Array, "MergePropertyDescriptor::GetValue called with non-array value");
            bool temp;
            return GetValue((Array)component, out temp);
        }

        public object GetValue(Array components, out bool allEqual) {
            allEqual = true;
            object obj = descriptors[0].GetValue(components.GetValue(0));
                    
            if (obj is ICollection) {
               if (collection == null) {
                   collection = new MultiMergeCollection((ICollection)obj);
               }
               else if (collection.Locked) {
                   return collection;
               }
               else {
                   collection.SetItems((ICollection)obj);
               }
            }
            
            for (int i = 1; i < descriptors.Length; i++) {
                
                object objCur = descriptors[i].GetValue(components.GetValue(i));
                if (collection != null) {
                   if (!collection.MergeCollection((ICollection)objCur)){
                      allEqual = false;
                      return null;
                   }
                }
                else if ((obj == null && objCur == null) ||
                         (obj != null && obj.Equals(objCur))) {
                
                   continue;
                }
                else {
                    allEqual = false;
                    return null;
                }
            }
            
            if (allEqual && collection != null && collection.Count == 0) {
                return null;
            }
            
            return (collection != null ? collection : obj);
        }

        internal object[] GetValues(Array components) {
            object[] values = new object[components.Length];

            for (int i = 0; i < components.Length; i++) {
                values[i] = descriptors[i].GetValue(components.GetValue(i));
            }
            return values;
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.ResetValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, resets the
        ///       value
        ///       for this property
        ///       of the component.
        ///    </para>
        /// </devdoc>
        public override void ResetValue(object component) {

            Debug.Assert(component is Array, "MergePropertyDescriptor::ResetValue called with non-array value");
            Array a = (Array)component;
            for (int i = 0; i < descriptors.Length; i++) {
                descriptors[i].ResetValue(a.GetValue(i));
            }
        }

        private void SetCollectionValues(Array a, IList listValue) {
            
            try {
                if (collection != null) {
                   collection.Locked = true;
                }

                // now we have to copy the value into each property.
                object[] values = new object[listValue.Count];
                
                listValue.CopyTo(values, 0);
                
                for (int i = 0; i < descriptors.Length; i++) {
                    IList propList = descriptors[i].GetValue(a.GetValue(i)) as IList;
                    
                    if (propList == null) {
                       continue;
                    }
                    
                    propList.Clear();
                    foreach (object val in values) {
                        propList.Add(val);
                    }
                }
            }
            finally {
               if (collection != null) {
                  collection.Locked = false;
               }
            }

        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.SetValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, sets the value of
        ///       the component to a different value.
        ///    </para>
        /// </devdoc>
        public override void SetValue(object component, object value) {
            Debug.Assert(component is Array, "MergePropertyDescriptor::SetValue called with non-array value");
            Array a = (Array)component;
            if (value is IList && typeof(IList).IsAssignableFrom(PropertyType)) {
                SetCollectionValues(a, (IList)value);
            }
            else {
                for (int i = 0; i < descriptors.Length; i++) {
                    descriptors[i].SetValue(a.GetValue(i), value);
                }
            }
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.ShouldSerializeValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, indicates whether the
        ///       value of
        ///       this property needs to be persisted.
        ///    </para>
        /// </devdoc>
        public override bool ShouldSerializeValue(object component) {
            Debug.Assert(component is Array, "MergePropertyDescriptor::ShouldSerializeValue called with non-array value");
            Array a = (Array)component;
            for (int i = 0; i < descriptors.Length; i++) {
                if (!descriptors[i].ShouldSerializeValue(a.GetValue(i))) {
                    return false;
                }
            }
            return true;
        }

        private class MultiMergeCollection : ICollection {
        
            private object[] items;
            private bool     locked;
            
            public MultiMergeCollection(ICollection original) {
               SetItems(original);
            }
            
            /// <include file='doc\MultiSelectPropertyGridEntry.uex' path='docs/doc[@for="MultiSelectPropertyGridEntry.MultiMergeCollection.Count"]/*' />
            /// <devdoc>
            ///     Retrieves the number of items.
            /// </devdoc>
            public int Count {
                get {
                    if (items != null) {
                        return items.Length;
                    }
                    else {
                        return 0;
                    }
                }
            }
            
            
            /// <include file='doc\MultiSelectPropertyGridEntry.uex' path='docs/doc[@for="MultiSelectPropertyGridEntry.MultiMergeCollection.Locked"]/*' />
            /// <devdoc>
            ///     Prevents the contents of the collection from being re-initialized;
            /// </devdoc>
            public bool Locked {
               get {
                  return locked;
               }
               set {
                  this.locked = value;
               }
            }

            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }
            
            public void CopyTo(Array array, int index) {
               if (items == null) return;
               
               Array.Copy(items, 0, array, index, items.Length);
            }
            
            public IEnumerator GetEnumerator(){
               if (items != null) {
                  return items.GetEnumerator();
               }
               else {
                  return new object[0].GetEnumerator();
               }
            }
            
            /// <include file='doc\MultiSelectPropertyGridEntry.uex' path='docs/doc[@for="MultiSelectPropertyGridEntry.MultiMergeCollection.MergeCollection"]/*' />
            /// <devdoc>
            /// Ensures that the new collection equals the exisitng one.
            /// Otherwise, it wipes out the contents of the new collection.
            /// </devdoc>
            public bool MergeCollection(ICollection newCollection) {
                
                if (locked) {
                   return true;
                }
               
                if (items.Length != newCollection.Count) {
                     items = new object[0];
                     return false;
                }
                
                object[] newItems = new object[newCollection.Count];
                newCollection.CopyTo(newItems, 0);
                for (int i = 0;i < newItems.Length; i++) {
                     if (((newItems[i] == null) != (items[i] == null)) ||
                         (items[i] != null && !items[i].Equals(newItems[i]))){
                           items = new object[0];
                           return false;  
                         }
                         
                }
                return true;
            }
            
            public void SetItems(ICollection collection) {
                if (locked) {
                  return;
                }
                items = new object[collection.Count];
                collection.CopyTo(items, 0);
            }
            
        }

        private class MergedAttributeCollection : AttributeCollection {
            private MergePropertyDescriptor owner;

            private AttributeCollection[] attributeCollections = null;
            private IDictionary             foundAttributes = null;
            
            public MergedAttributeCollection(MergePropertyDescriptor owner) : base(null) {
                this.owner = owner;
            }

            public override Attribute this[Type attributeType] {
                get {
                    return GetCommonAttribute(attributeType);
                }
            }

            #if false
            private void FullMerge() {
                Attribute[][] collections = new Attribute[owner.descriptors.Length][];
                for (int i = 0; i < owner.descriptors.Length; i++) {
                    AttributeCollection attrCollection = owner.descriptors[i].Attributes;
                    collections[i] = new Attribute[attrCollection.Count];
                    attrCollection.CopyTo(collections[i], 0);
                    Array.Sort(collections[i], GridEntry.AttributeTypeSorter);
                }
                
                ArrayList mergedList = new ArrayList();
    
                // merge the sorted lists -- note that lists aren't fully sorted just by
                // Attribute.TypeId
                //
                int[] posArray = new int[collections.Length];
                for (int i = 0; i < collections[0].Length; i++) {
                    Attribute pivotAttr = collections[0][i];
                    bool match = true;
                    for (int j = 1; j < collections.Length; j++) {
    
                        if (posArray[j] >= collections[j].Length) {
                            match = false;
                            break;
                        }
    
                        // check to see if we're on a match
                        //
                        if (pivotAttr.Equals(collections[j][posArray[j]])) {
                            posArray[j] += 1;
                            continue;
                        }
    
                        int jPos = posArray[j];
                        Attribute jAttr = collections[j][jPos];
    
                        match = false;
    
                        // if we aren't on a match, check all the items until we're past
                        // where the matching item would be
                        while (GridEntry.AttributeTypeSorter.Compare(jAttr, pivotAttr) <= 0) {
                            
                            // got a match!
                            if (pivotAttr.Equals(jAttr)) {
                                posArray[j] = jPos + 1;
                                match = true;
                                break;
                            }
    
                            // try again
                            jPos++;
                            if (jPos < collections[j].Length) {
                                jAttr = collections[j][jPos];
                            }
                            else {
                                break;
                            }
                        }
    
                        // if we got here, there is no match, quit for this guy
                        if (!match) {
                            posArray[j] = jPos;
                            break;
                        }
                    }
    
                    // do we have a match?
                    if (match) {
                        mergedList.Add(pivotAttr);
                    }
                }
    
                // create our merged array
                Attribute[] mergedAttrs = new Attribute[mergedList.Count];
                mergedList.CopyTo(mergedAttrs, 0);
            }

            #endif

            private Attribute GetCommonAttribute(Type attributeType) {
                if (attributeCollections == null) {
                    attributeCollections = new AttributeCollection[owner.descriptors.Length];
                    for (int i = 0; i < owner.descriptors.Length; i++) {
                        attributeCollections[i] = owner.descriptors[i].Attributes;
                    }
                }

                if (attributeCollections.Length == 0) {
                    return GetDefaultAttribute(attributeType);
                }

                Attribute value;
                if (foundAttributes != null) {
                    value = foundAttributes[attributeType] as Attribute;
                    if (value != null) {
                        return value;
                    }
                }

                value = attributeCollections[0][attributeType];

                if (value == null) {
                    return null;
                }
                
                for (int i = 1; i < attributeCollections.Length; i++) {
                    Attribute newValue = attributeCollections[i][attributeType];
                    if (!value.Equals(newValue)) {
                        value = GetDefaultAttribute(attributeType);
                        break;
                    }
                }

                if (foundAttributes == null) {
                    foundAttributes = new Hashtable();
                }
                foundAttributes[attributeType] = value;
                return value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\propertiestab.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertiesTab.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.PropertyGridInternal {
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.ComponentModel.Design;
    using System.ComponentModel;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms.Design;
    using System.Collections;
    using Microsoft.Win32;

    /// <include file='doc\PropertiesTab.uex' path='docs/doc[@for="PropertiesTab"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class PropertiesTab : PropertyTab {


        /// <include file='doc\PropertiesTab.uex' path='docs/doc[@for="PropertiesTab.TabName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string TabName {
            get {
                return SR.GetString(SR.PBRSToolTipProperties);
            }
        }
        
        /// <include file='doc\PropertiesTab.uex' path='docs/doc[@for="PropertiesTab.HelpKeyword"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string HelpKeyword {
            get {
                return "vs.properties"; // do not localize.
            }
        }

        /// <include file='doc\PropertiesTab.uex' path='docs/doc[@for="PropertiesTab.GetDefaultProperty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override PropertyDescriptor GetDefaultProperty(object obj) {
               PropertyDescriptor def = base.GetDefaultProperty(obj);

               if (def == null) {
                   PropertyDescriptorCollection props = GetProperties(obj);
                   if (props != null) {
                       for (int i = 0; i < props.Count; i++) {
                            if ("Name".Equals(props[i].Name)) {
                                def = props[i];
                                break;
                            }
                       }
                   }
               }
               return def;
        }

        /// <include file='doc\PropertiesTab.uex' path='docs/doc[@for="PropertiesTab.GetProperties"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes) {
               return GetProperties(null, component, attributes);
        }
        
        /// <include file='doc\PropertiesTab.uex' path='docs/doc[@for="PropertiesTab.GetProperties1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object component, Attribute[] attributes) {
            if (attributes == null) {
                attributes = new Attribute[]{BrowsableAttribute.Yes};
            }

            if (context == null) {
                return TypeDescriptor.GetProperties(component, attributes); 
            }
            else {
                TypeConverter tc = (context.PropertyDescriptor == null ? TypeDescriptor.GetConverter(component) : context.PropertyDescriptor.Converter);
                if (tc == null || !tc.GetPropertiesSupported(context)) {
                    return TypeDescriptor.GetProperties(component, attributes);
                }
                else {
                    return tc.GetProperties(context, component, attributes);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\propertygridview.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyGridView.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.PropertyGridInternal {
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Globalization;
    using System;
    using System.Collections;   
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms.Design;    
    using System.ComponentModel.Design;
    using System.IO;
    using System.Drawing;
    using Microsoft.Win32;
    using Message = System.Windows.Forms.Message;
    using System.Drawing.Drawing2D;

    internal class PropertyGridView :
    Control,
    IWin32Window,
    IWindowsFormsEditorService,
    IServiceProvider {

        protected static readonly Point InvalidPoint = new Point(int.MinValue, int.MinValue);

#if true // RENDERMODE
        public const int RENDERMODE_LEFTDOT = 2;
        public const int RENDERMODE_BOLD = 3;
        public const int RENDERMODE_TRIANGLE = 4;

        public static int inheritRenderMode = RENDERMODE_BOLD;
#endif


        public static TraceSwitch GridViewDebugPaint = new TraceSwitch("GridViewDebugPaint", "PropertyGridView: Debug property painting");


        private PropertyGrid ownerGrid;                      // the properties window host.


#if true // RENDERMODE
        private const int LEFTDOT_SIZE = 4;
#endif
        // constants
        protected const int     EDIT_INDENT = 0;
        protected const int     OUTLINE_INDENT = 10;
        protected const int     OUTLINE_SIZE = 9;
        protected const int     PAINT_WIDTH = 20;
        protected const int     PAINT_INDENT = 26;
        protected const int     ROWLABEL = 1;
        protected const int     ROWVALUE = 2;
        protected const int     MAX_LISTBOX_HEIGHT = 200;

        protected const short    ERROR_NONE = 0;
        protected const short    ERROR_THROWN = 1;
        protected const short    ERROR_MSGBOX_UP = 2;
        internal  const short    GDIPLUS_SPACE = 2;
        internal   const int      MaxRecurseExpand = 10;

        protected static readonly Point InvalidPosition = new Point(int.MinValue, int.MinValue);


        // colors and fonts
        private Brush                               backgroundBrush = null;
        private   Font                              fontBold = null;

        // property collections
        private GridEntryCollection                 topLevelGridEntries = null;     // top level props
        private GridEntryCollection                 allGridEntries = null;  // cache of viewable props
        
        // row information
        internal   int                               totalProps = -1;        // # of viewable props
        private   int                               visibleRows = -1;         // # of visible rows
        private   int                               labelWidth = -1;
        public double                               labelRatio = 2; // ratio of whole row to label width
        
        private short                               requiredLabelPaintMargin = GDIPLUS_SPACE;

        // current selected row and tooltip.
        private   int                               selectedRow = -1;
        private GridEntry                           selectedGridEntry = null;
        private   int                               tipInfo = -1;

        // editors & controls
        private   GridViewEdit                      edit = null;
        private   Button                            btnDropDown = null;
        private   Button                            btnDialog = null;
        private   GridViewListBox                   listBox = null;
        private   DropDownHolder                    dropDownHolder = null;
        private   Rectangle                         lastClientRect = Rectangle.Empty;
        private   Control                           currentEditor = null;
        private   ScrollBar                         scrollBar = null;
        internal  GridToolTip                       toolTip = null;
        private   GridErrorDlg                      errorDlg = null;
        

        // flags
        private const short FlagNeedsRefresh            = 0x0001;
        private const short FlagIsNewSelection          = 0x0002;
        private const short FlagIsSplitterMove          = 0x0004;
        private const short FlagIsSpecialKey            = 0x0008;
        private const short FlagInPropertySet           = 0x0010;
        private const short FlagDropDownClosing         = 0x0020;
        private const short FlagDropDownCommit          = 0x0040;
        private const short FlagNeedUpdateUIBasedOnFont = 0x0080;
        private const short FlagBtnLaunchedEditor       = 0x0100;
        private const short FlagNoDefault               = 0x0200;
        

        private   short                             flags = FlagNeedsRefresh | FlagIsNewSelection | FlagNeedUpdateUIBasedOnFont;
        private   short                             errorState = ERROR_NONE;

        private   Point                             ptOurLocation = new Point(1,1);
        
        private   string                            originalTextValue = null;     // original text, in case of ESC
        private   int                               wheelDelta = 0;
        private   long                              rowSelectTime = 0;
        private   Point                             lastMouseDown = InvalidPosition;
        private   int                               lastMouseMove;
        private   GridEntry                         lastClickedEntry;
        
        private IServiceProvider                    serviceProvider;
        private IHelpService                        topHelpService;
        private IHelpService                        helpService;

        private EventHandler                        ehValueClick;
        private EventHandler                        ehLabelClick;
        private EventHandler                        ehOutlineClick;
        private EventHandler                        ehValueDblClick;
        private EventHandler                        ehLabelDblClick;
        private GridEntryRecreateChildrenEventHandler ehRecreateChildren;

        private int                                 cachedRowHeight = -1;
        IntPtr baseHfont;
        IntPtr boldHfont;

        
        public PropertyGridView(IServiceProvider serviceProvider, PropertyGrid propertyGrid)
        : base() {
              
            this.ehValueClick = new EventHandler(this.OnGridEntryValueClick);
            this.ehLabelClick = new EventHandler(this.OnGridEntryLabelClick);
            this.ehOutlineClick = new EventHandler(this.OnGridEntryOutlineClick);
            this.ehValueDblClick = new EventHandler(this.OnGridEntryValueDoubleClick);
            this.ehLabelDblClick = new EventHandler(this.OnGridEntryLabelDoubleClick);
            this.ehRecreateChildren = new GridEntryRecreateChildrenEventHandler(this.OnRecreateChildren);

            ownerGrid = propertyGrid;
            this.serviceProvider = serviceProvider;
            
            SetStyle(ControlStyles.DoubleBuffer, true);
            SetStyle(ControlStyles.ResizeRedraw, false);
            SetStyle(ControlStyles.UserMouse, true);
            

            // properties
            BackColor = SystemColors.Window;
            ForeColor = SystemColors.WindowText;
            backgroundBrush = SystemBrushes.Window;
            TabStop = true;
            
            this.Text = "PropertyGridView";

            CreateUI();
            LayoutWindow(true); 
        }
        
        public override Color BackColor {
            get {
                return base.BackColor;
            }
            set {
                this.backgroundBrush = new SolidBrush(value);
                base.BackColor = value;
            }
        }
        
        internal Brush GetBackgroundBrush(Graphics g) {
            return backgroundBrush;
        }
        
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public bool CanCopy {
            get {
                return selectedGridEntry != null && selectedGridEntry.GetPropertyTextValue() != null;
            }
        }
        
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public bool CanCut {
            get {
                return CanCopy && selectedGridEntry.IsTextEditable; 
            }
        }
        
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public bool CanPaste {
            get {
                return selectedGridEntry != null && selectedGridEntry.IsTextEditable; // return gridView.CanPaste;
            }
        }
        
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public bool CanUndo {
            get {
                if (!Edit.Visible || !Edit.Focused) {
                    return false;
                }
                return (0 != (int)Edit.SendMessage(NativeMethods.EM_CANUNDO, 0, 0));
            }
        }

        private Button DropDownButton {
            get {
                if (btnDropDown == null) {
                    #if DEBUG
                        if (ownerGrid.inGridViewCreate) {
                            throw new Exception("PERF REGRESSION - Creating item in grid view create");
                        }
                    #endif
                    
                    btnDropDown = new DropDownButton();
                    Bitmap bitmap = CreateDownArrow();
                    btnDropDown.Image = bitmap;
                    btnDropDown.BackColor = SystemColors.Control;
                    btnDropDown.ForeColor = SystemColors.ControlText;
                    btnDropDown.Click += new EventHandler(this.OnBtnClick);
                   // btnDropDown.MouseUp += new MouseEventHandler(this.OnBtnMouseUp);
                   // btnDropDown.MouseDown += new MouseEventHandler(this.OnBtnMouseDown);
                    btnDropDown.LostFocus += new EventHandler(this.OnChildLostFocus);
                    btnDropDown.TabIndex = 2;
                    CommonEditorSetup(btnDropDown);
                    btnDropDown.Size = new Size(SystemInformation.VerticalScrollBarArrowHeight, RowHeight);
                }
                return btnDropDown;
            }
        }

        private Button DialogButton {
            get {
                if (btnDialog == null) {

                    #if DEBUG
                    if (ownerGrid.inGridViewCreate) {
                        throw new Exception("PERF REGRESSION - Creating item in grid view create");
                    }
                    #endif
                    btnDialog = new DropDownButton();
                    btnDialog.BackColor = SystemColors.Control;
                    btnDialog.ForeColor = SystemColors.ControlText;
                    btnDialog.TabIndex = 3;
                    Icon icon = new Icon(typeof(PropertyGrid), "dotdotdot.ico");
                    btnDialog.Image = icon.ToBitmap();
                    icon.Dispose();
                    btnDialog.Click += new EventHandler(this.OnBtnClick);
                    //btnDialog.MouseUp += new MouseEventHandler(this.OnBtnMouseUp);
                    //btnDialog.MouseDown += new MouseEventHandler(this.OnBtnMouseDown);
                    btnDialog.KeyDown += new KeyEventHandler(this.OnBtnKeyDown);
                    btnDialog.LostFocus += new EventHandler(this.OnChildLostFocus);
                    btnDialog.Size = new Size(SystemInformation.VerticalScrollBarArrowHeight, RowHeight);
                    CommonEditorSetup(btnDialog);
                }
                return btnDialog;
            }
        }

        private GridViewEdit Edit {
            get{
                if (edit == null) {

                    #if DEBUG
                    if (ownerGrid.inGridViewCreate) {
                        throw new Exception("PERF REGRESSION - Creating item in grid view create");
                    }
                    #endif

                    edit = new GridViewEdit(this);
                    edit.BorderStyle = BorderStyle.None;
                    edit.AutoSize = false;
                    edit.TabStop = false;
                    edit.AcceptsReturn = true;
                    edit.BackColor = BackColor;
                    edit.ForeColor = ForeColor;
                    edit.KeyDown += new KeyEventHandler(this.OnEditKeyDown);
                    edit.KeyPress += new KeyPressEventHandler(this.OnEditKeyPress);
                    edit.GotFocus += new EventHandler(this.OnEditGotFocus);
                    edit.LostFocus += new EventHandler(this.OnEditLostFocus);
                    edit.MouseDown += new MouseEventHandler(this.OnEditMouseDown);
                    edit.TextChanged += new EventHandler(this.OnEditChange);
                    edit.ImeModeChanged += new EventHandler(this.OnEditImeModeChanged);
                    edit.TabIndex = 1;
                    CommonEditorSetup(edit);
                }
                return edit;
            }
        }

        private GridViewListBox DropDownListBox {
            get {
                if (listBox == null) {
                    #if DEBUG
                    if (ownerGrid.inGridViewCreate) {
                        throw new Exception("PERF REGRESSION - Creating item in grid view create");
                    }
                    #endif

                    listBox = new GridViewListBox(this);
                    listBox.DrawMode = DrawMode.OwnerDrawFixed;
                    //listBox.Click += new EventHandler(this.OnListClick);
                    listBox.MouseUp += new MouseEventHandler(this.OnListMouseUp);
                    listBox.DrawItem += new DrawItemEventHandler(this.OnListDrawItem);
                    listBox.SelectedIndexChanged += new EventHandler(this.OnListChange);
                    listBox.KeyDown += new KeyEventHandler(this.OnListKeyDown);
                    listBox.LostFocus += new EventHandler(this.OnChildLostFocus);
                    listBox.Visible = true;
                    listBox.ItemHeight = RowHeight;
                }
                return listBox;
            }
        }
        
        internal bool DrawValuesRightToLeft {
            get {
                if (edit != null && edit.IsHandleCreated) {
                    int exStyle = (int)UnsafeNativeMethods.GetWindowLong(new HandleRef(edit, edit.Handle), NativeMethods.GWL_EXSTYLE);
                    return ((exStyle & NativeMethods.WS_EX_RTLREADING) != 0);
                }
                else {
                    return false;
                }
            }
        }

        
        public bool FocusInside {
            get {
                return(this.ContainsFocus || (dropDownHolder != null && dropDownHolder.ContainsFocus));
            }
        }
        
        internal Color GrayTextColor{
            get {
                if (this.ForeColor.ToArgb() == SystemColors.WindowText.ToArgb()) {
                    return SystemColors.GrayText;
                }
                
                // compute the new color by halving the value of the old one.
                //
                int colorRGB = this.ForeColor.ToArgb();
                
                int alphaValue = (colorRGB >> 24) & 0xff;
                if (alphaValue != 0) {
                    alphaValue /= 2;
                    colorRGB &= 0xFFFFFF;
                    colorRGB |= (int)((alphaValue << 24) & 0xFF000000);
                }
                else {
                    colorRGB /= 2;
                }
                return Color.FromArgb(colorRGB);
            }
        }

        private GridErrorDlg ErrorDialog {
            get {
                if (this.errorDlg == null) {
                    errorDlg = new GridErrorDlg();
                }
                return errorDlg;
            }
        }

        private bool HasEntries {
            get{
                return topLevelGridEntries != null && topLevelGridEntries.Count > 0;
            }
        }
        
        protected int InternalLabelWidth {
            get {
                if (GetFlag(FlagNeedUpdateUIBasedOnFont)) {
                    UpdateUIBasedOnFont(true);
                }
                if (labelWidth == -1) {
                    SetConstants();
                }
                return labelWidth;
            }
        }
        
        internal int LabelPaintMargin {
            get {
                return requiredLabelPaintMargin;
            }
            set {
                requiredLabelPaintMargin = (short)Math.Max(Math.Max(value, requiredLabelPaintMargin), GDIPLUS_SPACE);
            }
        }

        protected bool NeedsCommit{
            get {
                string text;

                if (edit==null || !Edit.Visible) {
                    return false;
                }

                text = Edit.Text;

                if (((text == null || text.Length == 0) && (originalTextValue == null || originalTextValue.Length == 0)) ||
                    (text != null && originalTextValue != null && text.Equals(originalTextValue))) {
                    return false;
                }
                return true;
            }
        }

        protected int RowHeight {
            get {
                if (cachedRowHeight == -1) {
                    cachedRowHeight = (int)Font.Height + 2;
                }
                return cachedRowHeight;
            }
        }

        /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.ContextMenuDefaultLocation"]/*' />
        /// <devdoc>
        /// Returns a default location for showing the context menu.  This
        /// location is the center of the active property label in the grid, and
        /// is used useful to position the context menu when the menu is invoked
        /// via the keyboard.
        /// </devdoc>
        public Point ContextMenuDefaultLocation {
            get {
                // get the rect for the currently selected prop name, find the middle
                Rectangle rect = GetRectangle( selectedRow, ROWLABEL );
                Point pt = PointToScreen( new Point( rect.X, rect.Y ) );
                return new Point(pt.X + (rect.Width / 2), pt.Y + (rect.Height / 2));
            }
        }

        private ScrollBar ScrollBar {
            get {
                if (scrollBar == null) {
                    #if DEBUG
                    if (ownerGrid.inGridViewCreate) {
                        throw new Exception("PERF REGRESSION - Creating item in grid view create");
                    }
                    #endif
                    scrollBar = new VScrollBar();
                    scrollBar.Scroll += new ScrollEventHandler(this.OnScroll);
                    Controls.Add(scrollBar);
                }
                return scrollBar;
            }
        }
        
        internal GridEntry SelectedGridEntry {
            get {
                return selectedGridEntry;
            }
            set {
                if (allGridEntries != null) {
                    foreach (GridEntry e in allGridEntries) {
                        if (e == value) {
                            SelectGridEntry(value, true);
                            return;
                        }
                    }
                }
                
                GridEntry gr = FindEquivalentGridEntry(new GridEntryCollection(null, new GridEntry[]{value}));
                
                if (gr != null) {
                    SelectGridEntry(gr, true);
                    return;
                }
                
                throw new ArgumentException(SR.GetString(SR.PropertyGridInvalidGridEntry));
            }
        }


        public PropertyDescriptor SelectedPropertyDescriptor {
            get {
                if (selectedGridEntry != null && (selectedGridEntry is PropertyDescriptorGridEntry)) {
                    return ((PropertyDescriptorGridEntry) selectedGridEntry).PropertyDescriptor;
                }
                else {
                    return null;
                }
            }
        }

        /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.SelectedPropertyName"]/*' />
        /// <devdoc>
        /// Returns the currently selected property name.
        /// If no property or a category name is selected, "" is returned.
        /// If the category is a sub property, it is concatenated onto its
        /// parent property name with a ".".
        /// </devdoc>
        public string SelectedPropertyName {
            get {
                if (selectedGridEntry == null) {
                    return "";
                }
                GridEntry gridEntry = selectedGridEntry;
                string name = "";
                while (gridEntry != null && gridEntry.PropertyDepth >= 0) {
                    if (name.Length > 0) {
                        name = gridEntry.PropertyName + "." + name;
                    }
                    else {
                        name = gridEntry.PropertyName;
                    }
                    gridEntry = gridEntry.ParentGridEntry;
                }
                return name;
            }
            /*set{
                if (value==null){
                    return;
                }
                if (value.Equals(selectedGridEntry.PropertyLabel)){
                    return;
                }

                string curName;
                string remain = value;

                int dot = remain.IndexOf('.');
                GridEntry[] ipes = GetAllGridEntries();
                int pos = 0;

                while (dot != -1){
                    curName = remain.Substring(0, dot);
                    Debug.WriteLine("Looking for: " + curName);
                    for (int i = pos; i < ipes.Length ; i++){
                        Debug.WriteLine("Checking : " + ipes[i].PropertyLabel);
                        if (ipes[i].PropertyLabel.Equals(curName)){
                            if (ipes[i].Expandable){
                                pos = i;
                                remain = remain.Substring(dot + 1);
                                dot = remain.IndexOf('.');
                                if (dot != -1){
                                    Debug.WriteLine("Expanding: " + ipes[i].PropertyLabel);
                                    ipes[i].SetPropertyExpand(true);
                                    ipes = GetAllGridEntries();
                                    break;
                                }
                                else{
                                    SelectGridEntry(ipes[i], true);
                                    return;
                                }
                            }
                        }
                    }
                    // uh oh
                    dot = -1;
                }
                // oops, didn't find it
                SelectRow(0);
                return;

            }*/
        }

        
        /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.ServiceProvider"]/*' />
        /// <devdoc>
        /// Returns or sets the IServiceProvider the PropertyGridView will use to obtain
        /// services.  This may be null.
        /// </devdoc>
        public IServiceProvider ServiceProvider {
            get { 
               return serviceProvider;
            }
            set {
               if (value != serviceProvider) {
                    this.serviceProvider = value;
                    
                    topHelpService = null;

                    if (helpService != null && helpService is IDisposable)
                        ((IDisposable)helpService).Dispose();

                    helpService = null;
               }
            }
        }    
        
        private int TipColumn {
            get{
                return(tipInfo & unchecked((int)0xFFFF0000)) >> 16;
            }
            set{

                // clear the column
                tipInfo &= 0xFFFF;

                // set the row
                tipInfo |= ((value & 0xFFFF) << 16);
            }
        }

        private int TipRow {
            get{
                return tipInfo & 0xFFFF;
            }
            set{

                // clear the row
                tipInfo &= unchecked((int)0xFFFF0000);

                // set the row
                tipInfo |= (value & 0xFFFF);
            }
        }

        private GridToolTip ToolTip {
            get {
                if (toolTip == null) {
                    #if DEBUG
                    if (ownerGrid.inGridViewCreate) {
                        throw new Exception("PERF REGRESSION - Creating item in grid view create");
                    }
                    #endif
                    toolTip = new GridToolTip(new Control[]{this, Edit});
                    toolTip.ToolTip = "";
                    toolTip.Font = this.Font;
                }   
                return toolTip;
            }
        }

        public object Value {
            get {
                return GetGridEntryFromRow(selectedRow).PropertyValue;
            }
            set {
                CommitValue(value);
            }
        }

        internal GridEntryCollection AccessibilityGetGridEntries() {
            return GetAllGridEntries();
        }

        internal Rectangle AccessibilityGetGridEntryBounds(GridEntry gridEntry) {
            int row = GetRowFromGridEntry(gridEntry);
            if (row == -1) {
                return new Rectangle(0, 0, 0, 0);
            }
            Rectangle rect = GetRectangle(row, ROWVALUE | ROWLABEL);

            // Translate rect to screen coordinates
            //
            NativeMethods.POINT pt = new NativeMethods.POINT(rect.X, rect.Y);
            UnsafeNativeMethods.ClientToScreen(new HandleRef(this, Handle), pt);

            return new Rectangle(pt.x, pt.y, rect.Width, rect.Height);
        }
        
        internal int AccessibilityGetGridEntryChildID(GridEntry gridEntry) {
         
            GridEntryCollection ipes = GetAllGridEntries();
            
            if (ipes == null) {
                return -1;
            }
            
            // Find the grid entry and return its ID
            //
            for(int index = 0; index < ipes.Count; ++index) {
                if (ipes[index].Equals(gridEntry)) {
                    return index;
                }
            }
            
            return -1;
        }

        internal void AccessibilitySelect(GridEntry entry) {
            SelectGridEntry(entry, true);            
            FocusInternal();
        }

        private void AddGridEntryEvents(GridEntryCollection ipeArray, int startIndex, int count) {
            if (ipeArray == null) {
                return;
            }
            
            if (count == -1) {
                count = ipeArray.Count - startIndex;
            }

            for (int i= startIndex; i < (startIndex + count); i++) {
                if (ipeArray[i] != null) {
                    GridEntry ge = ipeArray.GetEntry(i);
                    ge.AddOnValueClick(ehValueClick);
                    ge.AddOnLabelClick(ehLabelClick);
                    ge.AddOnOutlineClick(ehOutlineClick);
                    ge.AddOnOutlineDoubleClick(ehOutlineClick);
                    ge.AddOnValueDoubleClick(ehValueDblClick);
                    ge.AddOnLabelDoubleClick(ehLabelDblClick);
                    ge.AddOnRecreateChildren(ehRecreateChildren);
                }
            }
        }
        
        protected virtual void AdjustOrigin(System.Drawing.Graphics g, Point newOrigin, ref Rectangle r) {
            
            Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "Adjusting paint origin to (" + newOrigin.X.ToString() + "," + newOrigin.Y.ToString() + ")");

            g.ResetTransform();
            g.TranslateTransform(newOrigin.X, newOrigin.Y);
            r.Offset(-newOrigin.X, -newOrigin.Y);
        }

        private void CancelSplitterMove() {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:CancelSplitterMove");
            if (GetFlag(FlagIsSplitterMove)) {
                SetFlag(FlagIsSplitterMove, false);
                CaptureInternal = false;
            
                if (selectedRow != -1) {
                    SelectRow(selectedRow);
                }
            }
        }

        private void ClearGridEntryEvents(GridEntryCollection ipeArray, int startIndex, int count) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:ClearGridEntryEvents");
            if (ipeArray == null) {
                return;
            }
            
            if (count == -1) {
                count = ipeArray.Count - startIndex;
            }

            for (int i = startIndex ; i < (startIndex + count); i++) {
                if (ipeArray[i] != null) {
                    GridEntry ge = ipeArray.GetEntry(i);
                    ge.RemoveOnValueClick(ehValueClick);
                    ge.RemoveOnLabelClick(ehLabelClick);
                    ge.RemoveOnOutlineClick(ehOutlineClick);
                    ge.RemoveOnOutlineDoubleClick(ehOutlineClick);
                    ge.RemoveOnValueDoubleClick(ehValueDblClick);
                    ge.RemoveOnLabelDoubleClick(ehLabelDblClick);
                    ge.RemoveOnRecreateChildren(ehRecreateChildren);
                }
            }
        }

        public void ClearProps() {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:ClearProps");


            if (!HasEntries) {
                return;
            }

            CommonEditorHide();
            topLevelGridEntries = null;
            ClearGridEntryEvents(allGridEntries, 0, -1);
            allGridEntries = null;
            selectedRow = -1;
            //selectedGridEntry = null; // we don't wanna clear this because then we can't save where we were on a Refresh()
            tipInfo = -1;
        }

        /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.CloseDropDown"]/*' />
        /// <devdoc>
        ///      Closes a previously opened drop down.  This should be called by the
        ///      drop down when the user does something that should close it.
        /// </devdoc>
        public void /* IWindowsFormsEditorService. */ CloseDropDown() {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:CloseDropDown");

            // the activation code in the DropDownHolder can cause this to recurse...

            if (GetFlag(FlagDropDownClosing)) {
                return;
            }
            try {
                SetFlag(FlagDropDownClosing, true);
                if (dropDownHolder != null && dropDownHolder.Visible) {

                    if (dropDownHolder.Component == DropDownListBox && GetFlag(FlagDropDownCommit)) {
                        OnListClick(null,  null);
                    }

                    Edit.Filter = false;
                    
                    // disable the ddh so it wont' steal the focus back
                    dropDownHolder.SetComponent(null);
                    dropDownHolder.Visible = false;
                    
                    // when we disable the dropdown holder, focus will be lost,
                    // so put it onto one of our children first.
                    if (DialogButton.Visible) {
                        DialogButton.FocusInternal();
                    }
                    else if (DropDownButton.Visible) {
                        DropDownButton.FocusInternal();
                    }
                    else if (Edit.Visible) {
                        Edit.FocusInternal();
                    }
                    else {
                        FocusInternal();
                    }
                
                    if (selectedRow != -1) {
                        SelectRow(selectedRow);
                    }
                    
                }
            }
            finally {
                SetFlag(FlagDropDownClosing, false);
            }
        }

        private void CommonEditorHide() {
                CommonEditorHide(false);
        }

        private void CommonEditorHide(bool always) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:CommonEditorHide");

            if (!always && !HasEntries) {
                return;
            }
            
            CloseDropDown();

            bool gotfocus = false;
            
            if (Edit.Focused || DialogButton.Focused || DropDownButton.Focused) {

                if (IsHandleCreated && Visible && Enabled) {

                    gotfocus = IntPtr.Zero != UnsafeNativeMethods.SetFocus(new HandleRef(this, Handle));
                }
            }
            
            try {
               // We do this becuase the Focus call above doesn't always stick, so
               // we make the Edit think that it doesn't have focus.  this prevents
               // ActiveControl code on the containercontrol from moving focus elsewhere
               // when the dropdown closes.
               Edit.DontFocus = true;
               if (Edit.Focused && !gotfocus) {
                 gotfocus = this.FocusInternal();
               }
               Edit.Visible = false;
               
               Edit.SelectionStart = 0;
               Edit.SelectionLength = 0;
               
               if (DialogButton.Focused && !gotfocus) {
                  gotfocus = this.FocusInternal();
               }
               DialogButton.Visible = false;
               
               if (DropDownButton.Focused && !gotfocus) {
                   gotfocus = this.FocusInternal();
               }
               DropDownButton.Visible = false;
               currentEditor = null;
            }
            finally {
               Edit.DontFocus = false;
            }
        }

        protected virtual void CommonEditorSetup(Control ctl) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:CommonEditorSetup");
            ctl.Visible = false;
            Controls.Add(ctl);
        }

        protected virtual void CommonEditorUse(Control ctl, Rectangle rectTarget) {

            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:CommonEditorUse");
            Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "Showing common editors");

            Debug.Assert(ctl != null, "Null control passed to CommonEditorUse");

            Rectangle rectCur = ctl.Bounds;

            // the client rect minus the border line
            Rectangle clientRect = this.ClientRectangle;

            clientRect.Inflate(-1,-1);

            try {
                rectTarget = Rectangle.Intersect(clientRect, rectTarget);
                 //if (ctl is Button)
                 //   Debug.WriteStackTrace();


                if (!rectTarget.IsEmpty) {
                    if (!rectTarget.Equals(rectCur)) {
                        ctl.SetBounds(rectTarget.X,rectTarget.Y,
                                      rectTarget.Width,rectTarget.Height);
                    }
                    ctl.Visible = true;
                }
            }
            catch (Exception) {
                rectTarget = Rectangle.Empty;
            }

            if (rectTarget.IsEmpty) {

                ctl.Visible = false;
            }

            currentEditor = ctl;

        }

        private /*protected virtual*/ int CountPropsFromOutline(GridEntryCollection rgipes) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:CountPropsFromOutLine");
            if (rgipes == null) return 0;
            int cProps = rgipes.Count;
            for (int i = 0; i < rgipes.Count; i++) {
                if (((GridEntry)rgipes[i]).InternalExpanded)
                    cProps += CountPropsFromOutline(((GridEntry)rgipes[i]).Children);
            }
            return cProps;
        }

        /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.CreateAccessibilityInstance"]/*' />
        /// <devdoc>
        ///     Constructs the new instance of the accessibility object for this control. Subclasses
        ///     should not call base.CreateAccessibilityObject.
        /// </devdoc>
        protected override AccessibleObject CreateAccessibilityInstance() {
            return new PropertyGridViewAccessibleObject(this);
        }
        
        private Bitmap CreateDownArrow() {
            Bitmap bitmap = null;

            try {
                Icon icon = new Icon(typeof(PropertyGrid), "Arrow.ico");
                bitmap = icon.ToBitmap();
                icon.Dispose();
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
                bitmap= new Bitmap(16, 16);
            }
            return bitmap;
        }

        
        protected virtual void CreateUI() {
            UpdateUIBasedOnFont(false);
        }

        protected override void Dispose(bool disposing) {
            if (disposing) {
                Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:Dispose");
                if (scrollBar != null) scrollBar.Dispose();
                if (listBox != null) listBox.Dispose();
                if (dropDownHolder != null) dropDownHolder.Dispose();
                scrollBar = null;
                listBox = null;
                dropDownHolder = null;

                ownerGrid = null;
                topLevelGridEntries = null;
                allGridEntries = null;
                serviceProvider = null;
                
                if (topHelpService != null && topHelpService is IDisposable)
                    ((IDisposable)topHelpService).Dispose();

                topHelpService = null;

                if (helpService != null && helpService is IDisposable)
                    ((IDisposable)helpService).Dispose();

                helpService = null;

                if (fontBold != null) {
                    fontBold.Dispose();
                    fontBold = null;

                }

                if (edit != null) {
                    edit.Dispose();
                    edit = null;
                }

                if (btnDropDown != null) {
                    btnDropDown.Dispose();
                    btnDropDown = null;
                }

                if (btnDialog != null) {
                    btnDialog.Dispose();
                    btnDialog = null;
                }

                if (toolTip != null) {
                    toolTip.Dispose();
                    toolTip = null;
                }
            }

            base.Dispose(disposing);
        }
        
        public void DoCopyCommand() {
            if (this.CanCopy) {    
               if (Edit.Focused) {
                    Edit.Copy();
               }
               else {
                    Clipboard.SetDataObject(selectedGridEntry.GetPropertyTextValue());           
               }
            }
        }
        
        public void DoCutCommand() {
            if (this.CanCut) {
               DoCopyCommand();
               if (Edit.Visible) {
                    Edit.Cut();
               }
            }
        }


        public void DoPasteCommand() {
            if (this.CanPaste && Edit.Visible) {
               if (Edit.Focused) {
                    Edit.Paste();
               }
               else {
                   IDataObject dataObj = Clipboard.GetDataObject();
                   if (dataObj != null) {
                      string data = (string)dataObj.GetData(typeof(string));
                      if (data != null) {
                         Edit.FocusInternal();
                         Edit.Text = data;
                         SetCommitError(ERROR_NONE, true);
                      }   
                   }
               }
            }
        }
        
        public void DoUndoCommand() {
            if (this.CanUndo && Edit.Visible) {
               Edit.SendMessage(NativeMethods.WM_UNDO, 0, 0);
            }
        }
        
        internal void DumpPropsToConsole(GridEntry entry, string prefix) { 
        
            Type propType = entry.PropertyType;
            
            if (entry.PropertyValue != null) {
               propType = entry.PropertyValue.GetType();
            }
            
            System.Console.WriteLine(prefix + entry.PropertyLabel + ", value type=" + (propType == null ? "(null)" : propType.FullName) + ", value=" + (entry.PropertyValue == null ? "(null)" : entry.PropertyValue.ToString()) + ", flags=" + entry.Flags.ToString() + ", TypeConverter=" + (entry.TypeConverter == null ? "(null)" : entry.TypeConverter.GetType().FullName) + ", UITypeEditor=" + ((entry.UITypeEditor == null ? "(null)" : entry.UITypeEditor.GetType().FullName)));
            GridEntryCollection children = entry.Children;
            
            if (children != null) {
               foreach(GridEntry g in children) {
                  DumpPropsToConsole(g, prefix + "\t");
               }
            }
        }

        private int GetIPELabelIndent(GridEntry gridEntry) {
            //return OUTLINE_INDENT*(gridEntry.PropertyDepth + 1);
            return gridEntry.PropertyLabelIndent + 1;
        }

        private int GetIPELabelLength(System.Drawing.Graphics g,GridEntry gridEntry) {
            Size size = Size.Ceiling(g.MeasureString(gridEntry.PropertyLabel, Font));
            return ptOurLocation.X + GetIPELabelIndent(gridEntry) + size.Width;
        }

        private bool IsIPELabelLong(System.Drawing.Graphics g,GridEntry gridEntry) {
            if (gridEntry == null) return false;
            int length = GetIPELabelLength(g,gridEntry);
            return(length > ptOurLocation.X + InternalLabelWidth);
        }

        protected virtual void DrawLabel(System.Drawing.Graphics g, int row, Rectangle rect, bool selected, bool fLongLabelRequest, ref Rectangle clipRect) {

            GridEntry gridEntry = GetGridEntryFromRow(row);

            if (gridEntry == null || rect.IsEmpty)
                return;

            Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "Drawing label for property " + gridEntry.PropertyLabel);
            
            Point newOrigin = new Point(rect.X, rect.Y);
            Rectangle cr = Rectangle.Intersect(rect, clipRect);
            
            if (cr.IsEmpty) {
                return;
            }
            
            AdjustOrigin(g, newOrigin, ref rect);
            cr.Offset(-newOrigin.X, -newOrigin.Y);
            
            try {
                try {
                    bool fLongLabel = false;
                    int labelEnd = 0;
                    int labelIndent = GetIPELabelIndent(gridEntry);

                    if (fLongLabelRequest) {
                        labelEnd = GetIPELabelLength(g,gridEntry);
                        fLongLabel = IsIPELabelLong(g,gridEntry);
                    }

                    gridEntry.PaintLabel(g, rect, cr, selected, fLongLabel);
                }
                catch (Exception ex) {
                    IUIService uiService = (IUIService)GetService(typeof(IUIService));
                    if (uiService != null) {
                        uiService.ShowError(ex, "An Exception has occurred while painting the label for property '" + gridEntry.PropertyLabel + "'. See below for details.");
                    }
                    else {
                        Debug.Fail(ex.ToString());
                    }
                }
            }
            finally {
                ResetOrigin(g);
            }
        }

        protected virtual void DrawValueEntry(System.Drawing.Graphics g, int row, ref Rectangle clipRect) {
            GridEntry gridEntry = GetGridEntryFromRow(row);
            if (gridEntry == null)
                return;

            Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "Drawing value for property " + gridEntry.PropertyLabel);

            Rectangle r = GetRectangle(row,ROWVALUE);
            Point newOrigin = new Point(r.X, r.Y);
            Rectangle cr = Rectangle.Intersect(clipRect, r);

            if (cr.IsEmpty) {
                return;
            }
            
            AdjustOrigin(g, newOrigin, ref r);
            cr.Offset(-newOrigin.X, -newOrigin.Y);

            try {
                try {
                    DrawValueEntry(g,r, cr,gridEntry,null, true);
                }
                catch (Exception) {
                }
            }
            finally {
                ResetOrigin(g);
            }
        }

        private /*protected virtual*/ void DrawValueEntry(System.Drawing.Graphics g, Rectangle rect, Rectangle clipRect, GridEntry gridEntry, object value, bool fetchValue) {
            DrawValue(g, rect, clipRect, gridEntry, value, false, true, fetchValue, true);
        }
        private void DrawValue(System.Drawing.Graphics g, Rectangle rect, Rectangle clipRect, GridEntry gridEntry, object value, bool drawSelected, bool checkShouldSerialize, bool fetchValue, bool paintInPlace) { 
            GridEntry.PaintValueFlags paintFlags = GridEntry.PaintValueFlags.None;

            if(drawSelected) {
                paintFlags |= GridEntry.PaintValueFlags.DrawSelected;
            }

            if (checkShouldSerialize) {
               paintFlags |= GridEntry.PaintValueFlags.CheckShouldSerialize;
            }

            if (fetchValue) {
                paintFlags |= GridEntry.PaintValueFlags.FetchValue;
            }

            if (paintInPlace) {
                paintFlags |= GridEntry.PaintValueFlags.PaintInPlace;
            }

            gridEntry.PaintValue(value, g, rect, clipRect, paintFlags);
        }
        
        private void F4Selection(bool popupModalDialog) {
            GridEntry gridEntry = GetGridEntryFromRow(selectedRow);
            if (gridEntry == null) return;

            // if we are in an errorState, just put the focus back on the Edit
            if (errorState != ERROR_NONE && Edit.Visible) {
                Edit.FocusInternal();
                return;
            }

            if (DropDownButton.Visible) {
                PopupDialog(selectedRow);
            }
            else if (DialogButton.Visible) {
                if (popupModalDialog) {
                    PopupDialog(selectedRow);
                }
                else {
                    DialogButton.FocusInternal();
                }
            }
            else if (Edit.Visible) {
                Edit.FocusInternal();
                SelectEdit(false);
            }
            return;
        }

        public void DoubleClickRow(int row, bool toggleExpand, int type) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:DoubleClickRow");
            GridEntry gridEntry = GetGridEntryFromRow(row);
            if (gridEntry == null) return;

            Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "Property " + gridEntry.PropertyLabel + " double clicked");

            if (!toggleExpand || type == ROWVALUE) {
                bool action = gridEntry.DoubleClickPropertyValue();
                if (action) {
                    SelectRow(row);
                    return;
                }
            }

            SelectGridEntry(gridEntry, true);

            if (type == ROWLABEL && toggleExpand && gridEntry.Expandable) {
                SetExpand(gridEntry,!gridEntry.InternalExpanded);
                return;
            }
            
            if (gridEntry.IsValueEditable && gridEntry.Enumerable) {
                int index = GetCurrentValueIndex(gridEntry);

                if (index != -1) {
                    object[] values = gridEntry.GetPropertyValueList();

                    if (values == null || index >= (values.Length - 1)) {
                        index = 0;
                    }
                    else {
                        index++;
                    }

                    CommitValue(values[index]);
                    SelectRow(selectedRow);
                    return;
                }
            }
        
            if (Edit.Visible) {
                Edit.FocusInternal();
                SelectEdit(false);
                return;
            }
        }

        public Font GetBaseFont() {
            return Font;
        }

        public Font GetBoldFont() {
            if (fontBold == null) {
                fontBold = new Font(this.Font, FontStyle.Bold);
            }
            return fontBold;
        }

        internal IntPtr GetBaseHfont() {
            if (baseHfont == IntPtr.Zero) {
                baseHfont = GetBaseFont().ToHfont();
            }
            return baseHfont;
        }

        internal IntPtr GetBoldHfont() {
            if (boldHfont == IntPtr.Zero) {
                boldHfont = GetBoldFont().ToHfont();
            }
            return boldHfont;
        }


        private bool GetFlag(short flag) {
            return (this.flags & flag) != 0;
        }

        public virtual Color GetLineColor() {
            return ownerGrid.LineColor;
        }

        public virtual Brush GetLineBrush(Graphics g) {
            if (ownerGrid.lineBrush == null) {
                Color clr = g.GetNearestColor(ownerGrid.LineColor);
                ownerGrid.lineBrush = new SolidBrush(clr);
            }
            return ownerGrid.lineBrush;
        }

        public virtual IntPtr GetHostHandle() {
            return Handle;
        }

        public virtual int GetLabelWidth() {
            return InternalLabelWidth;
        }

        public virtual int GetOutlineIconSize() {
            return OUTLINE_SIZE;
        }

        public virtual int GetGridEntryHeight() {
            return RowHeight;
        }

        // for qa automation
        internal int GetPropertyLocation(string propName, bool getXY, bool rowValue) {
            if (allGridEntries != null && allGridEntries.Count > 0) {
                for (int i = 0; i < allGridEntries.Count; i++) {
                    if (0 == String.Compare(propName, allGridEntries.GetEntry(i).PropertyLabel, true, CultureInfo.InvariantCulture)) {
                        if (getXY) {
                            int row = GetRowFromGridEntry(allGridEntries.GetEntry(i));

                            if (row < 0 || row >= this.visibleRows) {
                                return -1;
                            }
                            else {
                                Rectangle r = GetRectangle(row, rowValue ? ROWVALUE : ROWLABEL);
                                return(r.Y << 16 | (r.X & 0xFFFF));
                            }
                        }
                        else {
                            return i;
                        }
                    }
                }
            }
            return -1;
        }

        public new object GetService(Type classService) {
            if (classService == typeof(IWindowsFormsEditorService)) {
                return this;
            }
            if (ServiceProvider != null) {
                return serviceProvider.GetService(classService);
            }
            return null;
        }

        public virtual int GetSplitterWidth() {
            return 1;
        }

        public virtual int GetTotalWidth() {
            return GetLabelWidth() + GetSplitterWidth() + GetValueWidth();
        }

        public virtual int GetValuePaintIndent() {
            return PAINT_INDENT;
        }

        public virtual int GetValuePaintWidth() {
            return PAINT_WIDTH;
        }

        public virtual int GetValueStringIndent() {
            return EDIT_INDENT;
        }

        public virtual int GetValueWidth() {
            return(int)(InternalLabelWidth * (labelRatio - 1));
        }

        /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.DropDownControl"]/*' />
        /// <devdoc>
        ///      Displays the provided control in a drop down.  When possible, the
        ///      current dimensions of the control will be respected.  If this is not possible
        ///      for the current screen layout the control may be resized, so it should
        ///      be implemented using appropriate docking and anchoring so it will resize
        ///      nicely.  If the user performs an action that would cause the drop down
        ///      to prematurely disappear the control will be hidden.
        /// </devdoc>
        public void /* cpr IWindowsFormsEditorService. */ DropDownControl(Control ctl) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:DropDownControl");
            Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "DropDownControl(ctl = " + ctl.GetType().Name + ")");
            if (dropDownHolder == null) {
                dropDownHolder = new DropDownHolder(this);
            }

            dropDownHolder.Visible = false;
            dropDownHolder.SetComponent(ctl);
            Rectangle rect = GetRectangle(selectedRow,ROWVALUE);
            Size size = dropDownHolder.Size;
            Point loc = PointToScreen(new Point(0, 0));
            Rectangle rectScreen = Screen.FromControl(Edit).WorkingArea;
            size.Width = Math.Max(rect.Width+1,size.Width);

            // Not needed... CYMAXDDLHEIGHT used to be 200, but why limit it???
            //size.Height = Math.Min(size.Height,CYMAXDDLHEIGHT);

            loc.X = Math.Min(rectScreen.X + rectScreen.Width - size.Width,
                             Math.Max(rectScreen.X,loc.X + rect.X + rect.Width - size.Width));
            loc.Y += rect.Y;
            if (rectScreen.Y + rectScreen.Height < (size.Height + loc.Y + Edit.Height))
                loc.Y -= size.Height;
            else
                loc.Y += rect.Height + 1;

            UnsafeNativeMethods.SetWindowLong(new HandleRef(dropDownHolder, dropDownHolder.Handle), NativeMethods.GWL_HWNDPARENT, new HandleRef(this, Handle));
            dropDownHolder.SetBounds(loc.X,loc.Y,size.Width,size.Height);
            SafeNativeMethods.ShowWindow(new HandleRef(dropDownHolder, dropDownHolder.Handle), NativeMethods.SW_SHOWNA);
            Edit.Filter = true;
            dropDownHolder.Visible = true;

            dropDownHolder.FocusComponent();
            SelectEdit(false);

            dropDownHolder.DoModalLoop();
            if (selectedRow != -1) {
                FocusInternal();
                SelectRow(selectedRow);
            }
        }

        public virtual void DropDownDone() {
            CloseDropDown();
        }

        public virtual void DropDownUpdate() {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "DropDownHolder:DropDownUpdate");
            if (dropDownHolder != null && dropDownHolder.GetUsed()) {
                int row = selectedRow;
                GridEntry gridEntry = GetGridEntryFromRow(row);
                Edit.Text = gridEntry.GetPropertyTextValue();
            }
        }
        
        public bool EnsurePendingChangesCommitted() {
            this.CloseDropDown();
            return this.Commit();
        }
        
        private bool FilterEditWndProc(ref Message m) {
            // if it's the TAB key, we keep it since we'll give them focus with it.
            if (dropDownHolder != null && dropDownHolder.Visible && m.Msg == NativeMethods.WM_KEYDOWN && (int)m.WParam != (int)Keys.Tab) {
                Control ctl = dropDownHolder.Component;
                if (ctl != null) {
                    m.Result = ctl.SendMessage(m.Msg, m.WParam, m.LParam);
                    return true;
                }
            }
            return false;
        }

        private bool FilterReadOnlyEditKeyPress(char keyChar) {
            GridEntry gridEntry = GetGridEntryFromRow(selectedRow);
            if (gridEntry.Enumerable && gridEntry.IsValueEditable) {
                int index = GetCurrentValueIndex(gridEntry);

                object[] values = gridEntry.GetPropertyValueList();
                string letter = new string(new char[] {keyChar});
                for (int i = 0; i < values.Length; i++) {
                    object valueCur = values[(i + index + 1) % values.Length];
                    string text = gridEntry.GetPropertyTextValue(valueCur);
                    if (text != null && text.Length > 0 && String.Compare(text.Substring(0,1), letter, true, CultureInfo.InvariantCulture) == 0) {
                        CommitValue(valueCur);
                        if (Edit.Focused) {
                            SelectEdit(false);
                        }
                        return true;
                    }
                }

            }
            return false;
        }

        public virtual bool WillFilterKeyPress(char charPressed) {
            if (!Edit.Visible) {
                return false;
            }

            Keys modifiers = ModifierKeys;
            if ((int)(modifiers & ~Keys.Shift) != 0) {
                return false;
            }

            // try to activate the Edit.
            // we don't activate for +,-, or * on expandable items because they have special meaning
            // for the tree.
            //

            if (selectedGridEntry != null) {
                switch (charPressed) {
                    case '+':
                    case '-':
                    case '*':
                        return !selectedGridEntry.Expandable;
                    case (char)(int)Keys.Tab:
                        return false;
                }
            }

            return true;
        }

        public void FilterKeyPress(char keyChar) {

            GridEntry gridEntry = GetGridEntryFromRow(selectedRow);
            if (gridEntry == null)
                return;

            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:FilterKeyPress()");

            Edit.FilterKeyPress(keyChar);
        }

        private /*protected virtual*/ GridEntry FindEquivalentGridEntry(GridEntryCollection ipeHier) {
            if (ipeHier == null || ipeHier.Count == 0)
                return null;
            GridEntryCollection rgipes = GetAllGridEntries();

            if (rgipes == null || rgipes.Count == 0) {
                return null;
            }

            GridEntry targetEntry = null;
            int row = 0;
            int count = rgipes.Count;

            for (int i = 0; i < ipeHier.Count; i++) {

                if (ipeHier[i] == null) {
                    continue;
                }

                // if we've got one above, and it's expandable,
                // expand it
                if (targetEntry != null) {

                    // how many do we have?
                    int items = rgipes.Count;

                    // expand and get the new count
                    if (!targetEntry.InternalExpanded) {
                      SetExpand(targetEntry, true);
                      rgipes = GetAllGridEntries();
                    }
                    count = targetEntry.ChildCount;
                }

                int start = row;
                targetEntry = null;

                // now, we will only go as many as were expanded...
                for (; row < rgipes.Count && ((row - start) <= count); row++) {
                    if (ipeHier.GetEntry(i).NonParentEquals(rgipes[row])) {
                        targetEntry = rgipes.GetEntry(row);
                        row++;
                        break;
                    }
                }

                // didn't find it...
                if (targetEntry == null) {
                    break;
                }
            }

            return targetEntry;
        }

        protected virtual Point FindPosition(int x, int y) {
            if (RowHeight == -1)
                return InvalidPosition;
            Size size = this.GetOurSize();

            if (x < 0 || x > size.Width + ptOurLocation.X)
                return InvalidPosition;
            Point pt = new Point(ROWLABEL,0);
            if (x > InternalLabelWidth + ptOurLocation.X)
                pt.X = ROWVALUE;
            pt.Y = (y-ptOurLocation.Y)/(1+RowHeight);
            return pt;
        }

        public virtual void Flush() {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView::Flush()");
            if (Commit() && Edit.Focused) {
                this.FocusInternal();
            }
        }

        private GridEntryCollection GetAllGridEntries() {
            return GetAllGridEntries(false);
        }

        private GridEntryCollection GetAllGridEntries(bool fUpdateCache) {
            if (visibleRows == -1 || totalProps == -1 || !HasEntries) {
                return null;
            }

            if (allGridEntries != null && !fUpdateCache) {
                return allGridEntries;
            }

            GridEntry[] rgipes = new GridEntry[totalProps];
            try {
                GetGridEntriesFromOutline(topLevelGridEntries,0,0,rgipes);
            }
            catch (Exception ex) {
                Debug.Fail(ex.ToString());
            }
            allGridEntries = new GridEntryCollection(null, rgipes);
            AddGridEntryEvents(allGridEntries, 0, -1);
            return allGridEntries;
        }

        private int GetCurrentValueIndex(GridEntry gridEntry) {

            if (!gridEntry.Enumerable) {
                return -1;
            }

            object[] values  = gridEntry.GetPropertyValueList();
            object value     = gridEntry.PropertyValue;
            string textValue = gridEntry.TypeConverter.ConvertToString(gridEntry, value);

            if (values != null && values.Length > 0) {
                string itemTextValue;
                int stringMatch = -1;
                int equalsMatch = -1;
                for (int i = 0; i < values.Length; i++) {
                    
                    object curValue = values[i];

                    // check real values against string values.
                    itemTextValue = gridEntry.TypeConverter.ConvertToString(curValue);
                    if (value == curValue || 0 == String.Compare(textValue, itemTextValue, true, CultureInfo.InvariantCulture)) {
                        stringMatch = i;
                    }
                    // now try .equals if they are both non-null
                    if (value != null && curValue != null && curValue.Equals(value)) {
                        equalsMatch = i;
                    }

                    if (stringMatch == equalsMatch && stringMatch != -1) {
                        return stringMatch;
                    }
                }

                if (stringMatch != -1) {
                    return stringMatch;
                }

                if (equalsMatch != -1) {
                    return equalsMatch;
                }
            }
            return -1;

        }

        public virtual int GetDefaultOutlineIndent() {
            return OUTLINE_INDENT;
        }

        private IHelpService GetHelpService() {
            if (helpService == null && ServiceProvider != null) {
                topHelpService = (IHelpService)ServiceProvider.GetService(typeof(IHelpService));
                if (topHelpService != null) {
                     IHelpService localHelpService = topHelpService.CreateLocalContext(HelpContextType.ToolWindowSelection);
                     if (localHelpService != null) {
                        helpService = localHelpService;
                     }
                }
            }
            return helpService;
        }

        public virtual int GetScrollOffset() {
            //Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:GetScrollOffset");
            if (scrollBar == null) {
                return 0;
            }
            int pos = ScrollBar.Value;
            return pos;
        }

        /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.GetGridEntryHierarchy"]/*' />
        /// <devdoc>
        /// returns an array of IPE specifying the current heirarchy of ipes from the given
        /// gridEntry through its parents to the root.
        /// </devdoc>
        private GridEntryCollection GetGridEntryHierarchy(GridEntry gridEntry) {
            if (gridEntry == null) {
                return null;
            }

            int depth = gridEntry.PropertyDepth;
            if (depth > 0) {
                GridEntry[] entries = new GridEntry[depth + 1];

                while (gridEntry != null && depth >= 0) {
                    entries[depth] = gridEntry;
                    gridEntry = gridEntry.ParentGridEntry;
                    depth = gridEntry.PropertyDepth;
                }
                return new GridEntryCollection(null, entries);
            }
            return new GridEntryCollection(null, new GridEntry[]{gridEntry});
        }

        private /*protected virtual*/ GridEntry GetGridEntryFromRow(int row) {
            GridEntryCollection rgipesAll = GetAllGridEntries();
            if (rgipesAll != null) {
                int offset = row + GetScrollOffset();
                if (offset >= 0 && offset < rgipesAll.Count)
                    return rgipesAll.GetEntry(offset);
            }
            return null;
        }

        private /*protected virtual*/ int GetGridEntriesFromOutline(GridEntryCollection rgipe, int cCur,
                                                 int cTarget, GridEntry[] rgipeTarget) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:GetGridEntriesFromOutline");
            if (rgipe == null || rgipe.Count == 0)
                return cCur;

            cCur--; // want to account for each entry as we find it.

            for (int cLocal = 0; cLocal < rgipe.Count; cLocal++) {
                cCur++;
                if (cCur >= cTarget + rgipeTarget.Length)
                    break;

                GridEntry ipeCur = rgipe.GetEntry(cLocal);

                //Debug.Assert(ipeCur != null, "Null IPE at position " + cLocal.ToString());


                if (cCur >= cTarget)
                    rgipeTarget[cCur - cTarget] = ipeCur;

                if (ipeCur.InternalExpanded) {
                    GridEntryCollection subGridEntry = ipeCur.Children;
                    //Debug.Assert(subGridEntry != null && subGridEntry.Length > 0 && subGridEntry[0] != null, "Expanded property " + ipeCur.PropertyLabel + " has no children!");
                    if (subGridEntry != null && subGridEntry.Count > 0) {
                        cCur = GetGridEntriesFromOutline(subGridEntry,
                                                  cCur+1,cTarget,rgipeTarget);
                    }
                }
            }

            return cCur;
        }

        private Size GetOurSize() {
                Size size = ClientSize;
                if (size.Width == 0) {
                    Size sizeWindow = Size;
                    if (sizeWindow.Width > 10) {
                        Debug.Fail("We have a bad client width!");
                        size.Width = sizeWindow.Width;
                        size.Height = sizeWindow.Height;
                    }
                }
                if (!GetScrollbarHidden()) {
                    Size sizeScroll = ScrollBar.Size;
                    size.Width -= sizeScroll.Width;
                }
                size.Width -= 2;
                size.Height -= 2;
                return size;
        }

        public Rectangle GetRectangle(int row, int flRow) {
            Rectangle rect = new Rectangle(0,0,0,0);
            Size size = this.GetOurSize();
            
            rect.X = ptOurLocation.X;

            bool fLabel = ((flRow & ROWLABEL) != 0);
            bool fValue = ((flRow & ROWVALUE) != 0);

            if (fLabel && fValue) {
                rect.X = 1;
                rect.Width = size.Width - 1;
            }
            else if (fLabel) {
                rect.X = 1;
                rect.Width = InternalLabelWidth - 1;
            }
            else if (fValue) {
                rect.X = ptOurLocation.X + InternalLabelWidth;
                rect.Width = size.Width - InternalLabelWidth;
            }

            rect.Y = (row)*(RowHeight+1)+1+ptOurLocation.Y;
            rect.Height = RowHeight;

            return rect;
        }

        private /*protected virtual*/ int GetRowFromGridEntry(GridEntry gridEntry) {
            GridEntryCollection rgipesAll = GetAllGridEntries();
            if (gridEntry == null || rgipesAll == null)
                return -1;

            int bestMatch = -1;

            for (int i = 0; i < rgipesAll.Count; i++) {

                // try for an exact match.  semantics of equals are a bit loose here...
                //
                if (gridEntry == rgipesAll[i]) {
                    return i - GetScrollOffset();
                }
                else if (bestMatch == -1 && gridEntry.Equals(rgipesAll[i])) {
                    bestMatch = i - GetScrollOffset();
                }
            }

            if (bestMatch != -1) {
                return bestMatch;
            }

            return -1 - GetScrollOffset();
        }

        public virtual bool GetInPropertySet() {
            return GetFlag(FlagInPropertySet);
        }

        protected virtual bool GetScrollbarHidden() {
            if (scrollBar == null) {
                return true;
            }
            return !ScrollBar.Visible;
        }

        public Color GetTextColor() {
            return this.ForeColor;
        }

        private void LayoutWindow(bool invalidate) {
            Rectangle rect = ClientRectangle;
            Size sizeWindow = new Size(rect.Width,rect.Height);

            if (scrollBar != null) {
                Rectangle boundsScroll = ScrollBar.Bounds;
                boundsScroll.X = sizeWindow.Width - boundsScroll.Width - 1;
                boundsScroll.Y = 1;
                boundsScroll.Height = sizeWindow.Height - 2;
                ScrollBar.Bounds = boundsScroll;
            }

            if (invalidate) {
                Invalidate();
            }
        }

        private void InvalidateRow(int row) {
            InvalidateRows(row, row, ROWVALUE | ROWLABEL);
        }

        private void InvalidateRow(int row, int type ) {
            InvalidateRows(row, row, type);
        }

        private void InvalidateRows(int startRow, int endRow) {
            InvalidateRows(startRow, endRow, ROWVALUE | ROWLABEL);
        }

        private void InvalidateRows(int startRow, int endRow, int type) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:InvalidateRows");

            Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "Invalidating rows " + startRow.ToString() + " through " + endRow.ToString());
            Rectangle rect;

            // invalidate from the start row down
            if (endRow == -1) {
                rect = GetRectangle(startRow, type);
                rect.Height = (Size.Height - rect.Y) - 1;
                Invalidate(rect);
            }
            else {
                for (int i = startRow; i <= endRow; i++) {
                    rect = GetRectangle(i, type);
                    Invalidate(rect);
                }
            }
        }

        private void InvalidateLabels() {
            Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "Invalidating labels");
            Invalidate(new Rectangle(0, 0, InternalLabelWidth + 2 , Size.Height));
        }

        private void InvalidateValues() {
            Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "Invalidating values");
            int left = InternalLabelWidth - 2;
            Invalidate(new Rectangle(left, 0, Size.Width - left, Size.Height));
        }

        /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.IsInputKey"]/*' />
        /// <devdoc>
        ///     Overridden to handle TAB key.
        /// </devdoc>
        protected override bool IsInputKey(Keys keyData) {
            switch (keyData & Keys.KeyCode) {
                case Keys.Escape:
                case Keys.Tab:
                case Keys.F4:
                    return false;

                case Keys.Return:
                     if (Edit.Focused) {
                        return false;
                     }
                     break;
            }
            return base.IsInputKey(keyData);
        }

        private bool IsMyChild(Control c) {

            if (c == this || c == null) {
                return false;
            }

            Control cParent = c.ParentInternal;

            while (cParent != null) {
                if (cParent == this) {
                    return true;
                }
                cParent = cParent.ParentInternal;
            }
            return false;
        }

        private bool IsScrollValueValid(int newValue) {
            /*Debug.WriteLine("se.newValue = " + se.newValue.ToString());
            Debug.WriteLine("ScrollBar.Value = " + ScrollBar.Value.ToString());
            Debug.WriteLine("visibleRows = " + visibleRows.ToString());
            Debug.WriteLine("totalProps = " + totalProps.ToString());
            Debug.WriteLine("ScrollBar.Max = " + ScrollBar.Maximum.ToString());
            Debug.WriteLine("ScrollBar.LargeChange = " + ScrollBar.LargeChange.ToString());*/

            // is this move valid?
            if (newValue == ScrollBar.Value ||
                newValue < 0 ||
                newValue > ScrollBar.Maximum ||
                (newValue + (ScrollBar.LargeChange-1) >= totalProps)) {
                Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView: move not needed, returning");
                return false;
            }
            return true;
        }

        internal bool IsSiblingControl(Control c1, Control c2) {

            Control parent1 = c1.ParentInternal;
            Control parent2 = c2.ParentInternal;

            while (parent2 != null) {
                if (parent1 == parent2) {
                    return true;
                }
                parent2 = parent2.ParentInternal;
            }
            return false;
        }

        private void MoveSplitterTo(int xpos) {

            int widthPS = GetOurSize().Width;
            int startPS = ptOurLocation.X;
            int pos = Math.Max(Math.Min(xpos,widthPS-10),GetOutlineIconSize() * 2);

            int oldLabelWidth = InternalLabelWidth;

            labelRatio = ((double)widthPS / (double) (pos - startPS));

            SetConstants();

            if (selectedRow != -1) {
                // do this to move any editor we have
                SelectRow(selectedRow);
            }
            
            Rectangle r = ClientRectangle;
            
            // if we're moving to the left, just invalidate the values
            if (oldLabelWidth > InternalLabelWidth) {
                int left = InternalLabelWidth - requiredLabelPaintMargin;
                Invalidate(new Rectangle(left, 0, Size.Width - left, Size.Height));
            }
            else {
                // to the right, just invalidate from where the splitter was
                // to the right
                r.X = oldLabelWidth - requiredLabelPaintMargin;
                r.Width -= r.X;
                Invalidate(r);
            }
        }

        private void OnBtnClick(object sender, EventArgs e) {

            if (GetFlag(FlagBtnLaunchedEditor)) {
                return;
            }

            if (sender == DialogButton && !Commit()) {
                return;
            }
            SetCommitError(ERROR_NONE);

            try {
                SetFlag(FlagBtnLaunchedEditor, true);
                PopupDialog(selectedRow);
            }
            finally {
                SetFlag(FlagBtnLaunchedEditor, false);
            }
        }

        private void OnBtnKeyDown(object sender, KeyEventArgs ke) {
            OnKeyDown(sender,ke);
        }

        private void OnBtnMouseDown(object sender, MouseEventArgs e) {
            SetFlag(FlagBtnLaunchedEditor, this.dropDownHolder == null || !this.dropDownHolder.Visible);
        }

        private void OnBtnMouseUp(object sender, MouseEventArgs e) {
            if (!GetFlag(FlagBtnLaunchedEditor)) {
                return;
            }

            OnBtnClick(sender, e);
            SetFlag(FlagBtnLaunchedEditor, false);
        }

        private void OnChildLostFocus(object sender, EventArgs e) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnChildLostFocus");
            OnLostFocus(null);
        }

        protected override void OnGotFocus(EventArgs e) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnGotFocus");
            
            base.OnGotFocus(e);
            
            if (e != null && !GetInPropertySet()) {
                if (!Commit()) {
                    Edit.FocusInternal();
                    return;
                }
            }

            if (selectedGridEntry != null && GetRowFromGridEntry(selectedGridEntry) != -1) {
                selectedGridEntry.Focus = true;
                SelectGridEntry(selectedGridEntry, false);
            }
            else {
                SelectRow(0);
            }            
        }

         protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(this.OnSysColorChange);
        }

        protected override void OnHandleDestroyed(EventArgs e) {
            SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(this.OnSysColorChange);
            // We can leak this if we aren't disposed.
            //
            if (toolTip != null && !RecreatingHandle) {
                toolTip.Dispose();
                toolTip = null;
            }
            base.OnHandleDestroyed(e);
        }

        public bool OnHelp() {
            GridEntry gridEntry = GetGridEntryFromRow(selectedRow);
            if (gridEntry == null || !(Focused || Edit.Focused)) {
                return false;
            }

            string keyword = gridEntry.HelpKeyword;
            if (keyword != null && keyword.Length != 0) {
                try {
                    IHelpService hsvc = GetHelpService();
                    if (hsvc != null) {
                        hsvc.ShowHelpFromKeyword(keyword);
                    }
                }
                catch (Exception) {
                }
            }
            return true;
        }

        protected override void OnImeModeChanged(EventArgs e) {
            if (edit != null) {
                // URT  #51190
                // Keep the ImeMode of the property grid and edit box in step
                //
                edit.ImeMode = this.ImeMode;
            }
            base.OnImeModeChanged(e);
        }                                       

        private void OnListChange(object sender, EventArgs e) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnListChange");
            if (!DropDownListBox.InSetSelectedIndex()) {
                GridEntry gridEntry = GetGridEntryFromRow(selectedRow);
                Edit.Text = gridEntry.GetPropertyTextValue(DropDownListBox.SelectedItem);
                Edit.FocusInternal();
                SelectEdit(false);
            }
            SetFlag(FlagDropDownCommit, true);
        }

        private void OnListMouseUp(object sender, MouseEventArgs me) {
            OnListClick(sender, me);
        }

        private void OnListClick(object sender, EventArgs e) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnListClick");
            GridEntry gridEntry = GetGridEntryFromRow(selectedRow);
            
            if (DropDownListBox.Items.Count == 0) {
               CommonEditorHide();
               SetCommitError(ERROR_NONE);
               SelectRow(selectedRow);
               return;
            }
            else {
                object value = DropDownListBox.SelectedItem;

                // don't need the commit becuase we're committing anyway.
                //
                SetFlag(FlagDropDownCommit, false);
                if (value != null && !CommitText((string)value)) {
                    SetCommitError(ERROR_NONE);
                    SelectRow(selectedRow);
                }
            }
        }
        
        private void OnListDrawItem(object sender, DrawItemEventArgs die) {
            int index = die.Index;

            if (index < 0 || selectedGridEntry == null) {
                return;
            }

            string text = (string)DropDownListBox.Items[die.Index];

            Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "Drawing list item, value='" + text + "'");
            die.DrawBackground();
            die.DrawFocusRectangle();

            Rectangle drawBounds = die.Bounds;
            drawBounds.Y += 1;
            drawBounds.X -= 1;
            

            GridEntry gridEntry = GetGridEntryFromRow(selectedRow);
            DrawValue(die.Graphics,drawBounds, drawBounds,gridEntry, gridEntry.ConvertTextToValue(text), (int)(die.State & DrawItemState.Selected) != 0, false, false, false);
        }

        private void OnListKeyDown(object sender, KeyEventArgs ke) {
            if (ke.KeyCode == Keys.Return) {
                OnListClick(null, null);
                selectedGridEntry.OnValueReturnKey();
            }

            OnKeyDown(sender,ke);
        }

        protected override void OnLostFocus(EventArgs e) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnLostFocus");
            Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "PropertyGridView lost focus");
            
            if (e != null) {
                base.OnLostFocus(e);
            }
            if (this.FocusInside) {
                base.OnLostFocus(e);
                return;
            }
            GridEntry gridEntry = GetGridEntryFromRow(selectedRow);
            if (gridEntry != null) {
                Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "removing gridEntry focus");
                gridEntry.Focus = false;;
                CommonEditorHide();
                InvalidateRow(selectedRow);
            }
            RefreshHelpAttributes();
            base.OnLostFocus(e);
        }

        private void OnEditChange(object sender, EventArgs e) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnEditChange");
            SetCommitError(ERROR_NONE, Edit.Focused);
            
            ToolTip.ToolTip = "";
            ToolTip.Visible = false;
            
            if (!Edit.InSetText()) {
                GridEntry gridEntry = GetGridEntryFromRow(selectedRow);
                if (gridEntry != null && (gridEntry.Flags & GridEntry.FLAG_IMMEDIATELY_EDITABLE) != 0)
                    Commit();
            }
        }

        private void OnEditGotFocus(object sender, EventArgs e) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnEditGotFocus");

            if (!Edit.Visible) {
                this.FocusInternal();
                return;
            }

            switch (errorState) {
                case ERROR_MSGBOX_UP:
                    return;
                case ERROR_THROWN:
                    if (Edit.Visible) {
                        Edit.HookMouseDown = true;
                    }
                    break;
                default:
                    if (this.NeedsCommit) {
                        SetCommitError(ERROR_NONE, true);
                    }
                    break;
            }

            if (selectedGridEntry != null && GetRowFromGridEntry(selectedGridEntry) != -1) {
                Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "adding gridEntry focus");
                selectedGridEntry.Focus = true;
                InvalidateRow(selectedRow);
            }
            else {
                SelectRow(0);
            }
        }
        
        private void OnEditImeModeChanged(object sender, EventArgs e) {
            // URT  #51190
            // The property grid ImeMode tracks the ImeMode of the edit control.
            // We require this because the first character the goes into the edit control
            // is composed while the PropertyGrid still has focus - so the ImeMode
            // of the grid and the edit need to be the same or we get inconsistent IME composition.
            //
            if (this.ImeMode != edit.ImeMode) {
                this.ImeMode = edit.ImeMode;            
            }
        }
        
        private void OnEditKeyDown(object sender, KeyEventArgs ke) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnEditKeyDown");
            bool fAlt = ke.Alt;
            if (!fAlt && (ke.KeyCode == Keys.Up || ke.KeyCode == Keys.Down)) {
                GridEntry gridEntry = GetGridEntryFromRow(selectedRow);
                if (!gridEntry.Enumerable || !gridEntry.IsValueEditable) {
                    return;
                }
                object value = gridEntry.PropertyValue;
                object[] rgvalues = gridEntry.GetPropertyValueList();
                ke.Handled = true;
                if (rgvalues != null) {
                    for (int i = 0; i < rgvalues.Length; i++) {
                        object rgvalue = rgvalues[i];
                        if (value != null && rgvalue != null && value.GetType() != rgvalue.GetType() && gridEntry.TypeConverter.CanConvertTo(gridEntry, value.GetType())) {
                            rgvalue = gridEntry.TypeConverter.ConvertTo(gridEntry, CultureInfo.CurrentCulture, rgvalue, value.GetType());
                        }

                        bool equal = (value == rgvalue) || (value != null && value.Equals(rgvalue));

                        if (!equal && value is string && rgvalue != null) {
                            equal = 0 == String.Compare((string)value, rgvalue.ToString(), true, CultureInfo.CurrentCulture);
                        }
                        if (equal) {
                            object valueNew = null;
                            if (ke.KeyCode == Keys.Up) {
                                if (i == 0) return;
                                valueNew = rgvalues[i - 1];
                            }
                            else {
                                if (i == rgvalues.Length - 1) return;
                                valueNew = rgvalues[i + 1];
                            }
                            CommitValue(valueNew);
                            SelectEdit(false);
                            return;
                        }
                    }
                }
            }
            // VS7 # 13336:  handle non-expand/collapse case of left & right as up & down
            else if ((ke.KeyCode == Keys.Left || ke.KeyCode == Keys.Right) &&
                     (ke.Modifiers & ~Keys.Shift) != 0) {
                return;
            }
            OnKeyDown(sender,ke);
        }

        private void OnEditKeyPress(object sender, KeyPressEventArgs ke) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnEditKeyPress");
            GridEntry gridEntry = GetGridEntryFromRow(selectedRow);
            if (gridEntry == null)
                return;

            if (!gridEntry.IsTextEditable) {
                ke.Handled = FilterReadOnlyEditKeyPress(ke.KeyChar);
            }
        }


        private void OnEditLostFocus(object sender, EventArgs e) {

            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnEditLostFocus");

            // believe it or not, this can actually happen.
            if (Edit.Focused || (errorState == ERROR_MSGBOX_UP) || (errorState == ERROR_THROWN)|| GetInPropertySet()) {
                return;
            }

            // check to see if the focus is on the drop down or one of it's children
            // if so, return;
            if (dropDownHolder != null && dropDownHolder.Visible) {
                bool found = false;
                for (IntPtr hwnd = UnsafeNativeMethods.GetForegroundWindow();
                    hwnd != IntPtr.Zero; hwnd = UnsafeNativeMethods.GetParent(new HandleRef(null, hwnd))) {
                    if (hwnd == dropDownHolder.Handle) {
                        found = true;
                    }
                }
                if (found)
                    return;
            }
            
            if (this.FocusInside) {
               return;
            }
            
            // if the focus isn't goint to a child of the view
            if (!Commit()) {
                Edit.FocusInternal();
                return;
            }
            // change our focus state.
            OnLostFocus(null);
        }

        private void OnEditMouseDown(object sender, MouseEventArgs me) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnEditMouseDown");
            
            if (!FocusInside) {
               SelectGridEntry(selectedGridEntry, false);
            }
            
            if (me.Clicks % 2 == 0) {
                DoubleClickRow(selectedRow,false, ROWVALUE);
                Edit.SelectAll();
            }
            
            if (rowSelectTime == 0) {
                return;
            }
            
            // check if the click happened within the double click time since the row was selected.
            // this allows the edits to be selected with two clicks instead of 3 (select row, double click).
            //
            long timeStamp = DateTime.Now.Ticks;
            int delta = (int)((timeStamp - rowSelectTime) / 10000); // make it milleseconds
            
            if (delta < SystemInformation.DoubleClickTime) {
                DoubleClickRow(selectedRow,false, ROWVALUE);
                
                Edit.SendMessage(NativeMethods.WM_LBUTTONUP, 0, (int)(me.Y << 16 | (me.X & 0xFFFF)));
                Edit.SelectAll();
                rowSelectTime = 0;
            }
        }
      
        private bool OnF4(Control sender) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnF4");
            if (ModifierKeys != 0) {
                return false;
            }
            if (sender == this || sender == this.ownerGrid)
                F4Selection(true);
            else
                UnfocusSelection();
            return true;
        }

        private bool OnEscape(Control sender) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnEscape");
            if ((ModifierKeys & (Keys.Alt | Keys.Control)) != 0) {
                return false;
            }

            SetFlag(FlagDropDownCommit, false);

            if (sender == Edit && Edit.Focused) {
            
                // if we aren't in an error state, just quit
                if (errorState == ERROR_NONE) {
                   Edit.Text = originalTextValue;
                   FocusInternal();
                   return true;
                }
            
                if (this.NeedsCommit) {
                    bool success = false;
                    Edit.Text = originalTextValue;
                    bool needReset = true;

                    if (selectedGridEntry != null) {
                                    
                        string curTextValue = selectedGridEntry.GetPropertyTextValue();
                        needReset = originalTextValue != curTextValue;
                    }
        
                    if (needReset) {
                        try {
                            success = CommitText(originalTextValue);
                        }
                        catch (Exception) {
                        }
                    }
                    else {
                        success = true;
                    }

                    // this would be an odd thing to happen, but...
                    if (!success) {
                        Edit.FocusInternal();
                        SelectEdit(false);
                        return true;
                    }
                }

                SetCommitError(ERROR_NONE);
                FocusInternal();
                return true;
            }
            else if (sender != this) {
                CloseDropDown();
                FocusInternal();
            }
            return false;
        }

        protected override void OnKeyDown(KeyEventArgs ke) {
            OnKeyDown(this,ke);
        }

        private void OnKeyDown(object sender, KeyEventArgs ke) {

            GridEntry gridEntry = GetGridEntryFromRow(selectedRow);
            if (gridEntry == null) return;

            ke.Handled = true;
            bool fControl = ke.Control;
            bool fShift = ke.Shift;
            bool fBoth = fControl && fShift;
            bool fAlt = ke.Alt;
            Keys keyCode = ke.KeyCode;
            bool fallingThorugh = false;

            // SBurke, we have to do this here because if we are
            // hosted in a non-windows forms dialog, we never get a chance to
            // peek at the messages, we just get called,
            // so we have to do this here...
            //
            if (keyCode == Keys.Tab) {
                if (ProcessDialogKey(ke.KeyData)) {
                    ke.Handled = true;
                    return;
                }
            }

            // Alt-Arrow support... sigh...
            if (keyCode == Keys.Down && fAlt && DropDownButton.Visible) {
                F4Selection(false);
                return;
            }

            if (keyCode == Keys.Up && fAlt && DropDownButton.Visible && (dropDownHolder != null) && dropDownHolder.Visible) {
                UnfocusSelection();
                return;
            }

            if (ToolTip.Visible) {
                ToolTip.ToolTip = "";
            }


            if (fBoth || sender == this || sender == this.ownerGrid) {
                switch (keyCode) {
                    case Keys.Up:
                    case Keys.Down:
                        int pos = (keyCode == Keys.Up ? selectedRow - 1 : selectedRow + 1);
                        SelectGridEntry(GetGridEntryFromRow(pos),true);
                        SetFlag(FlagNoDefault, false);
                        return;
                    case Keys.Left:
                        if (fControl) {
                            // move the splitter 3 pixels to the left
                            MoveSplitterTo(InternalLabelWidth - 3);
                            return;
                        }
                        if (gridEntry.InternalExpanded)
                            SetExpand(gridEntry,false);
                        else {
                            // VS7 # 13336:  handle non-expand/collapse case of left & right as up & down
                            SelectGridEntry( GetGridEntryFromRow( selectedRow - 1 ), true );
                        }
                        return;
                    case Keys.Right:
                        if (fControl) {
                            // move the splitter 3 pixels to the right
                            MoveSplitterTo(InternalLabelWidth + 3);
                            return;
                        }
                        if (gridEntry.Expandable) {
                            if (gridEntry.InternalExpanded) {
                                GridEntryCollection rgipes2 = gridEntry.Children;
                                SelectGridEntry(rgipes2.GetEntry(0),true);
                            }
                            else
                                SetExpand(gridEntry,true);
                        }
                        else {
                            // VS7 # 13336:  handle non-expand/collapse case of left & right as up & down
                            SelectGridEntry( GetGridEntryFromRow( selectedRow + 1 ), true );
                        }
                        return;
                    case Keys.Return:
                        if (gridEntry.Expandable) {
                            SetExpand(gridEntry,!gridEntry.InternalExpanded);
                        }
                        else {
                           gridEntry.OnValueReturnKey();
                        }
                        
                        return;
                    case Keys.Home:
                    case Keys.End:
                        GridEntryCollection rgipes = GetAllGridEntries();
                        int pos2 = (keyCode == Keys.Home ? 0 : rgipes.Count-1);
                        SelectGridEntry(rgipes.GetEntry(pos2),true);
                        return;
                    case Keys.Add:
                    case Keys.Oemplus:
                    case Keys.OemMinus:
                    case Keys.Subtract:
                        SetFlag(FlagIsSpecialKey, true);
                        bool expand = (keyCode == Keys.Add || keyCode == Keys.Oemplus);
                        SetExpand(gridEntry,expand);
                        Invalidate();
                        ke.Handled = true;
                        return;

                
                case Keys.D8:
                        if (fShift) {
                            goto case Keys.Multiply;
                        }
                        break;
                case Keys.Multiply:
                        SetFlag(FlagIsSpecialKey, true);
                        RecursivelyExpand(gridEntry,true, true, MaxRecurseExpand);
                        ke.Handled = false;
                        return;

                    
                    
                    case Keys.Prior:  //PAGE_UP:
                    case Keys.Next: //PAGE_DOWN
                        
                        bool next = (keyCode == Keys.Next);
                        //int rowGoal = next ? visibleRows - 1 : 0;
                        int offset = next ? visibleRows - 1 : 1 - visibleRows;

                        int row = selectedRow;

                        if (fControl && !fShift) {
                            return;
                        }
                        if (selectedRow != -1) { // actual paging.

                            int start = GetScrollOffset();
                            SetScrollOffset(start + offset);
                            SetConstants();
                            if (GetScrollOffset() != (start + offset)) {
                                // we didn't make a full page
                                if (next) {
                                    row = visibleRows - 1;
                                }
                                else {
                                    row = 0;
                                }
                            }
                        }

                        SelectRow(row);
                        Refresh();
                        return;   
                    
                    // Copy/paste support...    
                    
                    case Keys.Insert:
                        if (fShift && !fControl && !fAlt) {
                           fallingThorugh = true;
                           goto case Keys.V;
                        }
                        goto case Keys.C;
                    case Keys.C:
                        // copy text in current property
                        if (fControl && !fAlt && !fShift) {
                           DoCopyCommand();
                           return;
                        }
                        break;
                    case Keys.Delete:
                        // cut text in current property
                        if (fShift && !fControl && !fAlt) {
                           fallingThorugh = true;
                           goto case Keys.X;
                        }
                        break;
                    case Keys.X:
                        // cut text in current property
                        if (fallingThorugh || (fControl && !fAlt && !fShift)) {
                           Clipboard.SetDataObject(gridEntry.GetPropertyTextValue());
                           CommitText("");
                           return;
                        }
                        break;
                    case Keys.V:
                        // paste the text
                        if (fallingThorugh || (fControl && !fAlt && !fShift)) {
                           DoPasteCommand();
                        }
                        break;
                    case Keys.A:
                        if (fControl && !fAlt && !fShift && Edit.Visible) {
                           Edit.FocusInternal();
                           Edit.SelectAll();       
                        }
                        break;
                }
            }

            if (gridEntry != null && ke.KeyData == (Keys.C | Keys.Alt | Keys.Shift | Keys.Control)) {
                Clipboard.SetDataObject(gridEntry.GetTestingInfo());
                return;
            }

            /* SBurke, VS30371 -- Due to conflicts with other VS commands,
               we are removing this functionality.

               // Ctrl + Shift + 'X' selects the property that starts with 'X'
               if (fBoth) {
                   // now get the array to work with.
                   GridEntry[] rgipes = GetAllGridEntries();
                   int cLength = rgipes.Length;

                   // now get our char.
                   string strCh = (new string(new char[] {(char)ke.KeyCode})).ToLower(CultureInfo.InvariantCulture);

                   int cCur = -1;
                   if (gridEntry != null)
                       for (int i = 0; i < cLength; i++) {
                           if (rgipes[i] == gridEntry) {
                               cCur = i;
                               break;
                           }
                       }

                   cCur += 1; // this indicated where we start...
                   // find next label that starts with this letter.
                   for (int i = 0; i < cLength; i++) {
                       GridEntry ipeCur = rgipes[(i + cCur) % cLength];
                       if (ipeCur.PropertyLabel.ToLower(CultureInfo.InvariantCulture).StartsWith(strCh)) {
                           if (gridEntry != ipeCur) {
                               SelectGridEntry(ipeCur,true);
                               return;
                           }
                           break;
                       }
                   }
               }
            */
            
            ke.Handled = false;
            return;
        }

        protected override void OnKeyPress(KeyPressEventArgs ke) {

            bool fControl = false; //ke.getControl();
            bool fShift = false; //ke.getShift();
            bool fBoth = fControl && fShift;
            if (!fBoth && WillFilterKeyPress(ke.KeyChar))
                // find next property with letter typed.
                FilterKeyPress(ke.KeyChar);
            SetFlag(FlagIsSpecialKey, false);
        }

        protected override void OnMouseDown(MouseEventArgs me) {
            // check for a splitter
            if (me.Button == MouseButtons.Left && SplitterInside(me.X,me.Y) && totalProps != 0) {
                if (!Commit()) {
                    return;
                }
                
                if (me.Clicks == 2) {
                     MoveSplitterTo(this.Width / 2);
                     return;
                }
                
                UnfocusSelection();
                SetFlag(FlagIsSplitterMove, true);
                tipInfo = -1;
                CaptureInternal = true;
                return;
            }

            // are ew on a propentry?
            Point pos = FindPosition(me.X,me.Y);

            if (pos == InvalidPosition) {
                return;
            }

            // Notify that prop entry of the click...but normalize
            // it's coords first...we really  just need the x, y
            GridEntry gridEntry = GetGridEntryFromRow(pos.Y);

            if (gridEntry != null) {
                // get the origin of this pe
                Rectangle r = GetRectangle(pos.Y, ROWLABEL);
                
                lastMouseDown = new Point(me.X, me.Y);

                // offset the mouse points
                // notify the prop entry
                if (me.Button == MouseButtons.Left) {
                    gridEntry.OnMouseClick(me.X - r.X, me.Y - r.Y, me.Clicks, me.Button);
                }
                else {
                    SelectGridEntry(gridEntry, false);
                }
                lastMouseDown = InvalidPosition;
                gridEntry.Focus = true;
                SetFlag(FlagNoDefault, false);
            }
        }

        // this will make tool tip go away.
        protected override void OnMouseLeave(EventArgs e) {
            if (!GetFlag(FlagIsSplitterMove))
                Cursor = Cursors.Default; // Cursor = null;;

            base.OnMouseLeave(e);
        }

        protected override void OnMouseMove(MouseEventArgs me) {
            int rowMoveCur;
            Point pt = Point.Empty;
            bool onLabel = false;

            if (me == null) {
                rowMoveCur = -1;
                pt = InvalidPosition;
            }
            else {
                pt = FindPosition(me.X,me.Y);
                if (pt == InvalidPosition || (pt.X != ROWLABEL && pt.X != ROWVALUE)) {
                    rowMoveCur = -1;
                    ToolTip.ToolTip = "";
                }
                else {
                    rowMoveCur = pt.Y;
                    onLabel = pt.X == ROWLABEL;
                }

            }

            if (pt == InvalidPosition || me == null) {
                return;
            }

            if (GetFlag(FlagIsSplitterMove)) {
                MoveSplitterTo(me.X);
            }
            
            if ((rowMoveCur != this.TipRow || pt.X != this.TipColumn)  && !GetFlag(FlagIsSplitterMove)) {
                GridEntry gridItem = GetGridEntryFromRow(rowMoveCur);
                string tip = "";
                tipInfo = -1;

                if (gridItem != null) {
                    Rectangle itemRect = GetRectangle(pt.Y, pt.X);
                    if (onLabel && gridItem.GetLabelToolTipLocation(me.X - itemRect.X, me.Y - itemRect.Y) != InvalidPoint) {
                        tip = gridItem.LabelToolTipText;
                        this.TipRow = rowMoveCur;
                        this.TipColumn = pt.X;
                    }
                    else if (!onLabel && gridItem.ValueToolTipLocation != InvalidPoint && !Edit.Focused) {
                        if (!this.NeedsCommit) {
                           tip = gridItem.GetPropertyTextValue();
                        }
                        this.TipRow = rowMoveCur;
                        this.TipColumn = pt.X;
                    }
                }

                // vs  75848 -- don't show the tips if a
                // dropdown is showing
                if ((dropDownHolder == null || dropDownHolder.Component == null) || rowMoveCur == selectedRow) {
                    ToolTip.ToolTip = tip;
                }
            }

            if (totalProps != 0 && (SplitterInside(me.X,me.Y) || GetFlag(FlagIsSplitterMove))) {
                Cursor = Cursors.VSplit;
            }
            else {
                Cursor = Cursors.Default; // Cursor = null;;
            }
            base.OnMouseMove(me);
        }

        protected override void OnMouseUp(MouseEventArgs me) {
            CancelSplitterMove();
        }


        protected override void OnMouseWheel(MouseEventArgs me) {
        
            // Should this only work if the Edit has focus?  anyway
            // we use the mouse wheel to change the values in the dropdown if it's
            // an enumerable value.
            //
            if (selectedGridEntry != null && selectedGridEntry.Enumerable && Edit.Focused && selectedGridEntry.IsValueEditable){
                  int index = GetCurrentValueIndex(selectedGridEntry);
                  if (index != -1) {
                     int delta = me.Delta > 0 ? -1 : 1;
                     object[] values = selectedGridEntry.GetPropertyValueList();

                    if (delta > 0 && index >= (values.Length - 1)) {
                        index = 0;
                    }
                    else if (delta < 0 && index == 0) {
                        index = values.Length - 1;
                    }
                    else {
                        index += delta;
                    }

                    CommitValue(values[index]);
                    SelectGridEntry(selectedGridEntry, true);
                    Edit.FocusInternal();
                    return;
                 }
            }

            int initial = GetScrollOffset();
            wheelDelta += me.Delta;
            float movePerc = (float)wheelDelta / (float)NativeMethods.WHEEL_DELTA;
            
            // SystemInformation.MouseWheelScrollLines doesn't work under terminal server, so we use 1 instead
            int move = (int)((float)SystemInformation.MouseWheelScrollLines * movePerc);
            if (move != 0) {
                   if (ToolTip.Visible) {
                       ToolTip.ToolTip = "";
                   }
                   wheelDelta = 0;
                   GridEntry ipeCur = selectedGridEntry;
   
                   // adjust the offset if it's outside the max values
                   int newOffset = Math.Max(0,initial - move);
                   newOffset = Math.Min(newOffset, totalProps - visibleRows +1);
   
                   if (!IsScrollValueValid(newOffset) || !Commit()) {
                       return;
                   }
                   
                   bool showEdit = Edit.Visible;
                   bool showBtnDropDown = DropDownButton.Visible;
                   bool showBtnEdit     = DialogButton.Visible;
                 
                   Edit.Visible = false;
                   DialogButton.Visible = false;
                   DropDownButton.Visible = false;
                   
                   SetScrollOffset(newOffset);
                   if (ipeCur != null) {
                       int curRow = GetRowFromGridEntry(ipeCur);
                       if (curRow >=0 && curRow < visibleRows) {
                           Edit.Visible = showEdit;
                           DialogButton.Visible = showBtnEdit;
                           DropDownButton.Visible = showBtnDropDown;
                           SelectGridEntry(ipeCur, true);
                       }
                       else {
                           CommonEditorHide();
                       }
                   }
                   else {
                       CommonEditorHide();
                   }
                   Invalidate();
            }
        }

        protected override void OnMove(EventArgs e) {
            CloseDropDown();
        }
        
        protected override void OnPaintBackground(PaintEventArgs pe) {
        }

        protected override void OnPaint(PaintEventArgs pe) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnPaint");
            Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "On paint called.  Rect=" + pe.ClipRectangle.ToString());
            Graphics g = pe.Graphics;

            int yPos = 0;
            int startRow = 0;
            int endRow = visibleRows - 1;
            
            Rectangle clipRect = pe.ClipRectangle;
            
            // give ourselves a little breathing room to account for lines, etc., as well
            // as the entries themselves.
            //
            clipRect.Inflate(0,2);

            try {
                Size sizeWindow = this.Size;

                // figure out what rows we're painting
                Point posStart = FindPosition(clipRect.X, clipRect.Y);
                Point posEnd = FindPosition(clipRect.X, clipRect.Y + clipRect.Height);
                if (posStart != InvalidPosition) {
                    startRow = Math.Max(0,posStart.Y);
                }

                if (posEnd != InvalidPosition) {
                    endRow   = posEnd.Y;
                }

                int cPropsVisible = Math.Min(totalProps - GetScrollOffset(),1+visibleRows);
                
#if DEBUG
                GridEntry debugIPEStart = GetGridEntryFromRow(startRow);
                GridEntry debugIPEEnd   = GetGridEntryFromRow(endRow);
                string startName = debugIPEStart == null ? null : debugIPEStart.PropertyLabel;
                if (startName == null) {
                    startName = "(null)";
                }
                string endName = debugIPEEnd == null ? null : debugIPEEnd.PropertyLabel;
                if (endName == null) {
                    endName = "(null)";
                }
#endif

                SetFlag(FlagNeedsRefresh, false);

                //SetConstants();

                Size size = this.GetOurSize();
                Point loc = this.ptOurLocation;

                if (GetGridEntryFromRow(cPropsVisible-1) == null) {
                    cPropsVisible--;
                }


                // if we actually have some properties, then start drawing the grid
                //
                if (totalProps > 0) {
                
                    // draw splitter
                    cPropsVisible = Math.Min(cPropsVisible, endRow+1);

                    Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "Drawing splitter");
                    Pen splitterPen = new Pen(ownerGrid.LineColor, GetSplitterWidth());
                    splitterPen.DashStyle = DashStyle.Solid;
                    g.DrawLine(splitterPen, labelWidth,loc.Y,labelWidth, (cPropsVisible)*(RowHeight+1)+loc.Y);
                    splitterPen.Dispose();

                    // draw lines.
                    Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "Drawing lines");
                    Pen linePen = new Pen(g.GetNearestColor(ownerGrid.LineColor));
                    
                    int cHeightCurRow = 0;
                    int cLineEnd = loc.X + size.Width;
                    int cLineStart = loc.X;

                    // draw values.
                    int totalWidth = GetTotalWidth() + 1;
                    //g.TextColor = ownerGrid.TextColor;

                    // draw labels. set clip rect.
                    for (int i = startRow; i < cPropsVisible; i++) {
                        try {

                            // draw the line
                            cHeightCurRow = (i)*(RowHeight+1) + loc.Y;
                            g.DrawLine(linePen, cLineStart,cHeightCurRow,cLineEnd,cHeightCurRow);

                            // draw the value
                            DrawValueEntry(g,i, ref clipRect);

                            // draw the label
                            Rectangle rect = GetRectangle(i,ROWLABEL);
                            yPos = rect.Y + rect.Height;
                            DrawLabel(g,i, rect, (i==selectedRow),false, ref clipRect);
                            if (i == selectedRow) {
                                Edit.Invalidate();
                            }

                        }
                        catch (Exception) {
                            Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "Exception thrown during painting property " + GetGridEntryFromRow(i).PropertyLabel);
                        }
                    }

                    // draw the bottom line
                    cHeightCurRow = (cPropsVisible)*(RowHeight+1) + loc.Y;
                    g.DrawLine(linePen, cLineStart,cHeightCurRow,cLineEnd,cHeightCurRow);
                    
                    linePen.Dispose();
                }

                // fill anything left with window
                if (yPos < Size.Height) {
                    yPos++;
                    Rectangle clearRect = new Rectangle(1, yPos, Size.Width - 2, Size.Height - yPos - 1);
                    Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "Filling remaining area rect=" + clearRect.ToString());
                    
                    g.FillRectangle(backgroundBrush, clearRect);
                }

                g.DrawRectangle(SystemPens.ControlDark, 0,0,sizeWindow.Width - 1, sizeWindow.Height - 1);
                
                fontBold = null;
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
                // Do nothing.
            }
            finally {
                ClearCachedFontInfo();
            }
        }

        private void OnGridEntryLabelDoubleClick(object s, EventArgs e) {
            GridEntry gridEntry = (GridEntry)s;

            // if we've changed since the click (probably because we moved a row into view), bail
            //
            if (gridEntry != lastClickedEntry) {
                return;
            }
            int row = GetRowFromGridEntry(gridEntry);
            DoubleClickRow(row, gridEntry.Expandable, ROWLABEL);
        }

        private void OnGridEntryValueDoubleClick(object s, EventArgs e) {

            GridEntry gridEntry = (GridEntry)s;
            // if we've changed since the click (probably because we moved a row into view), bail
            //
            if (gridEntry != lastClickedEntry) {
                return;
            } 
            int row = GetRowFromGridEntry(gridEntry);
            DoubleClickRow(row, gridEntry.Expandable, ROWVALUE);
        }

        private void OnGridEntryLabelClick(object s, EventArgs e) {
            this.lastClickedEntry = (GridEntry)s;
            SelectGridEntry(lastClickedEntry, true);
        }

        private void OnGridEntryOutlineClick(object s, EventArgs e) {
            GridEntry gridEntry = (GridEntry)s;
            Debug.Assert(gridEntry.Expandable, "non-expandable IPE firing outline click");

            Cursor oldCursor = Cursor;
            if (!ShouldSerializeCursor()) {
                oldCursor = null;
            }
            Cursor = Cursors.WaitCursor;

            try {
                SetExpand(gridEntry, !gridEntry.InternalExpanded);
                SelectGridEntry(gridEntry, false);
            }
            finally {
                Cursor = oldCursor;
            }
        }

        private void OnGridEntryValueClick(object s, EventArgs e) {
        
            this.lastClickedEntry = (GridEntry)s;
            bool setSelectTime = s != selectedGridEntry;
            SelectGridEntry(lastClickedEntry, true);
            Edit.FocusInternal();
            
            if (lastMouseDown != InvalidPosition) {
            
               // clear the row select time so we don't interpret this as a double click.
               //
               rowSelectTime = 0;    
               
               Point editPoint = PointToScreen(lastMouseDown);
               editPoint = Edit.PointToClientInternal(editPoint);
               Edit.SendMessage(NativeMethods.WM_LBUTTONDOWN, 0, (int)(editPoint.Y << 16 | (editPoint.X & 0xFFFF))); 
               Edit.SendMessage(NativeMethods.WM_LBUTTONUP, 0, (int)(editPoint.Y << 16 | (editPoint.X & 0xFFFF))); 
            }
            
            if (setSelectTime) {
               rowSelectTime = DateTime.Now.Ticks;
            }
            else {
                rowSelectTime = 0;
            }
        }

        private void ClearCachedFontInfo() {
            if (baseHfont != IntPtr.Zero) {
                SafeNativeMethods.ExternalDeleteObject(new HandleRef(this, baseHfont));
                baseHfont = IntPtr.Zero;
            }
            if (boldHfont != IntPtr.Zero) {
                SafeNativeMethods.ExternalDeleteObject(new HandleRef(this, boldHfont));
                boldHfont = IntPtr.Zero;
            }
        }

        protected override void OnFontChanged(EventArgs e) {
        
            ClearCachedFontInfo();
            cachedRowHeight = -1;

            if (this.Disposing || this.ParentInternal == null || this.ParentInternal.Disposing) {
                return;
            }
         
            fontBold = null;    // URT  #45662 - fontBold is cached based on Font                        
                        
            ToolTip.Font = this.Font;
            SetFlag(FlagNeedUpdateUIBasedOnFont, true);
            UpdateUIBasedOnFont(true);
            base.OnFontChanged(e);

            if (selectedGridEntry != null) {
                SelectGridEntry(selectedGridEntry, true);
            }
        }

        protected override void OnVisibleChanged(EventArgs e) {
            if (this.Disposing || this.ParentInternal == null || this.ParentInternal.Disposing) {
                return;
            }
         
            if (this.Visible && this.ParentInternal != null) {
                 SetConstants();
                 if (selectedGridEntry != null) {
                       SelectGridEntry(selectedGridEntry, true);
                 }
                 if (toolTip != null) {
                     ToolTip.Font = this.Font;
                 }
                 
            }

            base.OnVisibleChanged(e);
        }
        
        // a GridEntry recreated its children
        protected virtual void OnRecreateChildren(object s, GridEntryRecreateChildrenEventArgs e) {
            GridEntry parent = (GridEntry) s;

            if (parent.Expanded) {
                                          
                GridEntry[] entries = new GridEntry[allGridEntries.Count];
                allGridEntries.CopyTo(entries, 0);
                
                // find the index of the gridEntry that fired the event in our main list.
                int parentIndex = -1;
                for (int i = 0; i < entries.Length; i++) {
                    if (entries[i] == parent) {
                        parentIndex = i;
                        break;
                    }
                }
                
                Debug.Assert(parentIndex != -1, "parent GridEntry not found in allGridEntries");
                
                // clear our existing handlers
                ClearGridEntryEvents(allGridEntries, parentIndex + 1, e.OldChildCount);
                
                // resize the array if it's changed
                if (e.OldChildCount != e.NewChildCount) {
                    int newArraySize = entries.Length + (e.NewChildCount - e.OldChildCount);
                    GridEntry[] newEntries = new GridEntry[newArraySize];
                    
                    // copy the existing entries up to the parent
                    Array.Copy(entries, 0, newEntries, 0, parentIndex + 1);
                    
                    // copy the entries after the spot we'll be putting the new ones
                    Array.Copy(entries, parentIndex + e.OldChildCount+1, newEntries, parentIndex + e.NewChildCount+1, entries.Length - (parentIndex + e.OldChildCount + 1));
                    
                    entries = newEntries;
                }
                
                // from that point, replace the children with tne new children.
                GridEntryCollection children = parent.Children;
                int childCount = children.Count;
                
                Debug.Assert(childCount == e.NewChildCount, "parent reports " + childCount + " new children, event reports " + e.NewChildCount);
                
                // replace the changed items
                for (int i = 0; i < childCount; i++) {
                    entries[parentIndex + i + 1] = children.GetEntry(i);
                }
                
                // reset the array, rehook the handlers.
                allGridEntries.Clear();
                allGridEntries.AddRange(entries);
                AddGridEntryEvents(allGridEntries, parentIndex + 1, childCount);            
                
            }

            if (e.OldChildCount != e.NewChildCount) {
                totalProps = CountPropsFromOutline(topLevelGridEntries);
                SetConstants();
            }
            Invalidate();
        }
        
        protected override void OnResize(EventArgs e) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnResize");

            Rectangle newRect = ClientRectangle;
            int       yDelta = lastClientRect == Rectangle.Empty  ? 0 : newRect.Height - lastClientRect.Height;
            bool   lastRow = (selectedRow+1) == visibleRows;

            // if we are hiding or showing the scroll bar, update the selected row
            // or if we are changing widths
            //
            bool sbVisible = ScrollBar.Visible;

            if (!lastClientRect.IsEmpty && newRect.Width > lastClientRect.Width) {
                Rectangle rectInvalidate = new Rectangle(lastClientRect.Width-1,0,newRect.Width-lastClientRect.Width+1,lastClientRect.Height);
                Invalidate(rectInvalidate);
            }

            if (!lastClientRect.IsEmpty && yDelta > 0) {
                Rectangle rectInvalidate = new Rectangle(0,lastClientRect.Height-1,lastClientRect.Width,newRect.Height-lastClientRect.Height+1);
                Invalidate(rectInvalidate);
            }

            int scroll = GetScrollOffset();
            SetScrollOffset(0);
            SetConstants();
            SetScrollOffset(scroll);
            

            CommonEditorHide();

            LayoutWindow(false);
            // vs  69679
            bool selectionVisible = (selectedGridEntry != null && selectedRow >=0  && selectedRow <= visibleRows);
            SelectGridEntry(selectedGridEntry, selectionVisible);
            lastClientRect = newRect;
        }

        private void OnScroll(object sender, ScrollEventArgs se) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:OnScroll(" + ScrollBar.Value.ToString() + " -> " + se.NewValue.ToString() +")");

			if (!IsScrollValueValid(se.NewValue) || !Commit()) {
                // cancel the move
                se.NewValue = ScrollBar.Value;
                return;
            }

			int oldRow = -1;
            GridEntry oldGridEntry = selectedGridEntry;
            if (selectedGridEntry != null) {
                oldRow = GetRowFromGridEntry(oldGridEntry);
                Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "OnScroll: SelectedGridEntry=" + oldGridEntry.PropertyLabel);
            }

            ScrollBar.Value = se.NewValue;
            if (oldGridEntry != null) {
                // we need to zero out the selected row so we don't try to commit again...since selectedRow is now bogus.
                selectedRow = -1;
                SelectGridEntry(oldGridEntry, (ScrollBar.Value == totalProps ? true : false));
                int newRow = GetRowFromGridEntry(oldGridEntry);
                if (oldRow != newRow) {
                    Invalidate(); 
                }
            }
            else {
                Invalidate();
            }
        }

        private void OnSysColorChange(object sender, UserPreferenceChangedEventArgs e) {
            if (e.Category == UserPreferenceCategory.Color || e.Category == UserPreferenceCategory.Accessibility) {
                SetFlag(FlagNeedUpdateUIBasedOnFont, true);
            }
        }
        
        public virtual void PopupDialog(int row) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:PopupDialog");
            GridEntry gridEntry = GetGridEntryFromRow(row);
            if (gridEntry != null) {
                if (dropDownHolder != null && dropDownHolder.GetUsed()) {
                    CloseDropDown();
                    return;
                }

                bool fBtnDropDown = gridEntry.NeedsDropDownButton;
                bool fEnum = gridEntry.Enumerable;
                bool fBtnDialog = gridEntry.NeedsCustomEditorButton;
                if (fEnum && !fBtnDropDown) {
                    DropDownListBox.Items.Clear();
                    object value = gridEntry.PropertyValue;
                    object[] rgItems = gridEntry.GetPropertyValueList();
                    int maxWidth = 0;

                    // The listbox draws with GDI, not GDI+.  So, we
                    // use a normal DC here.
                    //
                    IntPtr hdc = UnsafeNativeMethods.GetDC(new HandleRef(DropDownListBox, DropDownListBox.Handle));
                    IntPtr hFont = Font.ToHfont();
                    NativeMethods.TEXTMETRIC tm = new NativeMethods.TEXTMETRIC();
                    int iSel = -1;
                    try {
                        hFont = SafeNativeMethods.SelectObject(new HandleRef(DropDownListBox, hdc), new HandleRef(Font, hFont));
                        
                        iSel = GetCurrentValueIndex(gridEntry);
                        if (rgItems != null && rgItems.Length > 0) {
                            string s;
                            NativeMethods.SIZE textSize = new NativeMethods.SIZE();
                            
                            for (int i = 0; i < rgItems.Length; i++) {
                                s = gridEntry.GetPropertyTextValue(rgItems[i]);
                                DropDownListBox.Items.Add(s);        
                                SafeNativeMethods.GetTextExtentPoint32(new HandleRef(DropDownListBox, hdc), s, s.Length, textSize);
                                maxWidth = Math.Max((int) textSize.cx, maxWidth);
                            }
                        }
                        SafeNativeMethods.GetTextMetrics(new HandleRef(DropDownListBox, hdc), tm);
                        
                        // border + padding + scrollbar
                        maxWidth += 2 + tm.tmMaxCharWidth + SystemInformation.VerticalScrollBarWidth;
                        
                        hFont = SafeNativeMethods.SelectObject(new HandleRef(DropDownListBox, hdc), new HandleRef(Font, hFont));
                    }
                    finally {
                        SafeNativeMethods.DeleteObject(new HandleRef(Font, hFont));
                        UnsafeNativeMethods.ReleaseDC(new HandleRef(DropDownListBox, DropDownListBox.Handle), new HandleRef(DropDownListBox, hdc));
                    }
                    
                    // CHRISAN, 4/25/1998 - must check for -1 and not call the set...
                    if (iSel != -1) {
                        DropDownListBox.SelectedIndex = iSel;
                    }
                    SetFlag(FlagDropDownCommit, false);
                    DropDownListBox.Height = Math.Max(tm.tmHeight + 2, Math.Min(MAX_LISTBOX_HEIGHT, DropDownListBox.PreferredHeight));
                    DropDownListBox.Width = Math.Max(maxWidth, GetRectangle(row,ROWVALUE).Width);
                    DropDownControl(DropDownListBox);
                }
                else if (fBtnDialog || fBtnDropDown) {
                     try {
                        SetFlag(FlagInPropertySet, true);
                        Edit.DisableMouseHook = true;
                        gridEntry.EditPropertyValue(this);
                     }
                     finally {
                        SetFlag(FlagInPropertySet, false);
                        Edit.DisableMouseHook = false;
                     }
                     Refresh();
                     
                     // as/urt  31468 -- we can't do this because
                     // some dialogs are non-modal, and
                     // this will pull focus from them.
                     // See ASURT 31468.
                     //
                     //if (fBtnDialog) {
                     //      this.Focus();
                     //}
                     
                     if (FocusInside) {
                        SelectGridEntry(gridEntry, false);
                     }
                }
            }
        }
        
        internal static void PositionTooltip(Control parent, GridToolTip ToolTip, Rectangle itemRect) {
            ToolTip.Visible = false;
            
            NativeMethods.RECT rect = NativeMethods.RECT.FromXYWH(itemRect.X, itemRect.Y, itemRect.Width, itemRect.Height);

            ToolTip.SendMessage(NativeMethods.TTM_ADJUSTRECT, 1, ref rect);

            // now offset it back to screen coords
            Point locPoint = parent.PointToScreen(new Point(rect.left, rect.top));
            
            ToolTip.Location = locPoint;   // set the position once so it updates it's size with it's real width.
            
            int overHang =  (ToolTip.Location.X + ToolTip.Size.Width) - SystemInformation.VirtualScreen.Width;
            if (overHang > 0) {
                locPoint.X -= overHang;
                ToolTip.Location = locPoint;
            }

            // tell the control we've repositioned it.
            ToolTip.Visible = true;  
        }
        
        

        protected override bool ProcessDialogKey(Keys keyData) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:ProcessDialogKey");
            if (HasEntries) {
                Keys keyCode = keyData & Keys.KeyCode;
                switch (keyCode) {
                    case Keys.F4:
                        if (FocusInside) {
                            return OnF4(this);
                        }
                        break;

                    case Keys.Tab:
                        bool forward = (keyData & Keys.Shift) == 0;

                        Control focusedControl = Control.FromHandleInternal(UnsafeNativeMethods.GetFocus());

                        if (focusedControl == null || !IsMyChild(focusedControl)) {
                            if (forward) {
                                TabSelection();
                                focusedControl = Control.FromHandleInternal(UnsafeNativeMethods.GetFocus());
                                // make sure the value actually took the focus
                                if (IsMyChild(focusedControl)) {
                                    return true;
                                }
                                else {
                                    return base.ProcessDialogKey(keyData);
                                }

                            }
                            else {
                                break;
                            }
                        }
                        else {
                            // one of our editors has focus

                            if (Edit.Focused) {
                                if (forward) {
                                    if (DropDownButton.Visible) {
                                        DropDownButton.FocusInternal();
                                        return true;
                                    }
                                    else if (DialogButton.Visible) {
                                        DialogButton.FocusInternal();
                                        return true;
                                    }
                                    // fall through
                                }
                                else {
                                    SelectGridEntry(GetGridEntryFromRow(selectedRow), false);
                                    return true;
                                }
                            }
                            else if (DialogButton.Focused || DropDownButton.Focused) {
                                if (!forward && Edit.Visible) {
                                    Edit.FocusInternal();
                                    return true;
                                }
                                // fall through
                            }
                        }
                        break;  
                    case Keys.Up:
                    case Keys.Down:
                    case Keys.Left:
                    case Keys.Right:
                        return false;
                    case Keys.Return:
                        if (DialogButton.Focused || DropDownButton.Focused) {
                           OnBtnClick((DialogButton.Focused ? DialogButton : DropDownButton), new EventArgs());
                           return true;
                        }
                        else if (selectedGridEntry != null && selectedGridEntry.Expandable) {
                           SetExpand(selectedGridEntry, !selectedGridEntry.InternalExpanded);
                           return true;
                        }
                        break;
                }
            }
            return base.ProcessDialogKey(keyData);
        }

        protected virtual void RecalculateProps() {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:RecalculateProps");
            int props = CountPropsFromOutline(topLevelGridEntries);
            if (totalProps != props) {
                totalProps = props;
                ClearGridEntryEvents(allGridEntries, 0, -1);
                allGridEntries = null;
            }
        }

        internal /*public virtual*/ void RecursivelyExpand(GridEntry gridEntry, bool fInit, bool expand, int maxExpands) {

            if (expand && --maxExpands < 0) {
                return;
            }

            SetExpand(gridEntry, expand);

            GridEntryCollection rgipes = gridEntry.Children;
            if (rgipes != null)
                for (int i = 0; i < rgipes.Count; i++)
                    RecursivelyExpand(rgipes.GetEntry(i),false, expand, maxExpands);

            if (fInit) {
                GridEntry ipeSelect = selectedGridEntry;
                Refresh();
                SelectGridEntry(ipeSelect,false);
                Invalidate();
            }

        }

        public override void Refresh() {
            Refresh(false, -1, -1);
            // make sure we got everything
            Invalidate();
        }

        public void Refresh(bool fullRefresh) {
            Refresh(fullRefresh, -1, -1);
        }

        
        GridPositionData positionData;
    
        private void Refresh(bool fullRefresh, int rowStart, int rowEnd) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:Refresh");
            Debug.WriteLineIf(GridViewDebugPaint.TraceVerbose,  "Refresh called for rows " + rowStart.ToString() + " through " + rowEnd.ToString());
            SetFlag(FlagNeedsRefresh, true);
            GridEntry gridEntry = null;

            bool pageInGridEntry = true;
            
            if (rowStart == -1) {
                rowStart = 0;
            }
            
            if (fullRefresh || this.ownerGrid.HavePropEntriesChanged()) {
                if (HasEntries && !GetInPropertySet() && !Commit()) {
                    OnEscape(this);
                }
                
                int oldLength = totalProps;
                object oldObject = topLevelGridEntries == null || topLevelGridEntries.Count == 0 ? null : ((GridEntry)topLevelGridEntries[0]).GetValueOwner();
                
                // walk up to the main IPE and refresh it.
                if (fullRefresh) {
                    this.ownerGrid.RefreshProperties(true);
                }
                
                if (oldLength > 0 && !GetFlag(FlagNoDefault)) {
                     positionData = new GridPositionData(this);
                     CommonEditorHide(true);
                }
                
                selectedGridEntry = null;
                SetFlag(FlagIsNewSelection, true);
                topLevelGridEntries = this.ownerGrid.GetPropEntries();
                
                
                ClearGridEntryEvents(allGridEntries, 0, -1);
                allGridEntries = null;
                RecalculateProps();
                
                int newLength = totalProps;
                if (newLength > 0) {
                   if (newLength < oldLength) {
                       SetScrollbarLength();
                       SetScrollOffset(0);
                   }
                   
                   SetConstants();

                   if (positionData != null) {
                       gridEntry = positionData.Restore(this);

                       // Upon restoring the grid entry position, we don't
                       // want to page it in
                       //
                       object newObject = topLevelGridEntries == null || topLevelGridEntries.Count == 0 ? null : ((GridEntry)topLevelGridEntries[0]).GetValueOwner();
                       pageInGridEntry = (gridEntry == null) || oldLength != newLength || newObject != oldObject;
                   }
                   
                   if (gridEntry == null) {
                       gridEntry = this.ownerGrid.GetDefaultGridEntry();
                       SetFlag(FlagNoDefault, gridEntry == null && totalProps > 0);
                   }

                   InvalidateRows(rowStart, rowEnd);
                   if (gridEntry == null) {
                       selectedRow = 0;
                       selectedGridEntry = GetGridEntryFromRow(selectedRow);
                   }
                   positionData = null;
               }
               else if (oldLength == 0) {
                  return;
               }
               else {
                   SetConstants();
               }
            }

            if (!HasEntries) {
                CommonEditorHide(selectedRow != -1);
                this.ownerGrid.SetStatusBox(null, null);
                SetScrollOffset(0);
                selectedRow = -1;
                Invalidate();
                return;
            }
            // in case we added or removed properties
            
            ownerGrid.ClearValueCaches();

            InvalidateRows(rowStart, rowEnd);

            if (gridEntry != null) {
                SelectGridEntry(gridEntry, pageInGridEntry);
            }
        }

        public virtual void Reset() {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:Reset");
            GridEntry gridEntry = GetGridEntryFromRow(selectedRow);
            if (gridEntry == null) return;

            gridEntry.ResetPropertyValue();
            SelectRow(selectedRow);
        }

        protected virtual void ResetOrigin(System.Drawing.Graphics g) {
            g.ResetTransform();
        }
        
        internal void RestoreHierarchyState(ArrayList expandedItems) {
            if (expandedItems == null) {
               return;
            }
            
            foreach(GridEntryCollection gec in expandedItems) {
               FindEquivalentGridEntry(gec);
            }
        }

        public virtual DialogResult RunDialog(Form dialog) {
            return ShowDialog(dialog);
        }
        
        internal ArrayList SaveHierarchyState(GridEntryCollection entries) {
            return SaveHierarchyState(entries, null);
        }
        
        private ArrayList SaveHierarchyState(GridEntryCollection entries, ArrayList expandedItems) {
            if (entries == null) {
               return new ArrayList();
            }
            
            if (expandedItems == null) {
               expandedItems = new ArrayList();
            }
        
            for (int i = 0; i < entries.Count; i++) {
               if (((GridEntry)entries[i]).InternalExpanded) {
                  GridEntry entry = entries.GetEntry(i);
                  expandedItems.Add(GetGridEntryHierarchy(entry.Children.GetEntry(0)));
                  SaveHierarchyState(entry.Children, expandedItems);
               }
            }
            
            return expandedItems;
        }

        private void SelectEdit(bool caretAtEnd) {
            if (edit != null) {
                Edit.SelectAll();
            }
        }

        // select functions... selectGridEntry and selectRow will select a Row
        // and install the appropriate editors.
        //
        internal /*protected virtual*/ void SelectGridEntry(GridEntry gridEntry, bool fPageIn) {

            if (gridEntry == null) return;
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:SelectGridEntry(" + gridEntry.PropertyLabel + ")");

            int row = GetRowFromGridEntry(gridEntry);
            if (row + GetScrollOffset() < 0) {
                // throw exception? return false?
                return;
            }

            int maxRows = (int)Math.Ceiling(((double)GetOurSize().Height)/(1+RowHeight));

            if ((row >= 0 && row < (maxRows-1)) || !fPageIn) {
                // great. just select it.
                if (row != -1) {
                    SelectRow(row);
                }
                return;
            }

            // clear the selected row since it's no longer a valid number
            selectedRow = -1;

            // oh well. we have to page it in.
            int cOffset = GetScrollOffset();
            if (row < 0) {
                SetScrollOffset(row + cOffset);
                Invalidate();
                SelectRow(0);
            }
            else {
                // try to put it one row up from the bottom
                int newOffset = row + cOffset - (maxRows - 2);

                if (newOffset >= ScrollBar.Minimum && newOffset < ScrollBar.Maximum) {
                    SetScrollOffset(newOffset);
                }
                Invalidate();
                SelectGridEntry(gridEntry, false);
            }
            return;
        }

        private void SelectRow(int row) {

            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:SelectRow(" + row.ToString() + ")");

            if (!GetFlag(FlagIsNewSelection)) {
                if (this.FocusInside) {
                    // If we're in an error state, we want to bail out of this.
                    if (errorState != ERROR_NONE || (row != selectedRow && !Commit())) {
                        return;
                    }
                }
                else {
                    FocusInternal();
                }
            }

            GridEntry gridEntry = GetGridEntryFromRow(row);

            // Update our reset command.
            //
            if (row != selectedRow) {
                UpdateResetCommand(gridEntry);
            }

            if (GetFlag(FlagIsNewSelection) && GetGridEntryFromRow(selectedRow) == null) {
                CommonEditorHide();
            }

            UpdateHelpAttributes(selectedGridEntry, gridEntry);

            // tell the old selection it's not focused any more
            if (selectedGridEntry != null) {
                selectedGridEntry.Focus = false;
            }

            // selection not visible.
            if (row < 0 || row >= visibleRows) {
                CommonEditorHide();
                selectedRow = row;
                selectedGridEntry = gridEntry;
                Refresh();
                return;
            }

            // leave current selection.
            if (gridEntry == null)
                return;

            bool newRow = false;
            int oldSel = selectedRow;
            if (selectedRow != row || !gridEntry.Equals(selectedGridEntry)) {
                CommonEditorHide();
                newRow = true;
            }
            
            if (!newRow)
                CloseDropDown();

            Rectangle rect = GetRectangle(row,ROWVALUE);
            string s = gridEntry.GetPropertyTextValue();

            // what components are we using?
            bool fBtnDropDown = gridEntry.NeedsDropDownButton | gridEntry.Enumerable;
            bool fBtnDialog = gridEntry.NeedsCustomEditorButton;
            bool fEdit = gridEntry.IsTextEditable;
            bool fPaint = gridEntry.IsCustomPaint;

            rect.X += 1;
            rect.Width -= 1;

            // we want to allow builders on read-only properties
            if ((fBtnDialog || fBtnDropDown) && !gridEntry.ShouldRenderReadOnly) {
                Control btn = fBtnDropDown ? (Control)DropDownButton : (Control)DialogButton;
                Size sizeBtn = new Size(SystemInformation.VerticalScrollBarArrowHeight, RowHeight);
                Rectangle rectTarget = new Rectangle(rect.X+rect.Width-sizeBtn.Width,
                                                      rect.Y-1,
                                                      sizeBtn.Width,rect.Height+2);
                CommonEditorUse(btn,rectTarget);
                sizeBtn = btn.Size;
                rect.Width -= (sizeBtn.Width + 1);
                btn.Invalidate();
            }

            // if we're painting the value, size the rect between the button and the painted value
            if (fPaint) {
                rect.X += PAINT_INDENT + 1;
                rect.Width -= PAINT_INDENT;
            }
            else {
                rect.X += EDIT_INDENT + 1; // +1 to compensate for where GDI+ draws it's string relative to the rect.
                rect.Width -= EDIT_INDENT + 1;
            }
           
            if ((GetFlag(FlagIsNewSelection) || !Edit.Focused) && (s != null && !s.Equals(Edit.Text))) {
                Edit.Text = s;
                originalTextValue = s;
                Edit.SelectionStart = 0;
                Edit.SelectionLength = 0;
            }


#if true // RENDERMODE
            switch (inheritRenderMode) {
                case RENDERMODE_BOLD:
                    if (gridEntry.ShouldSerializePropertyValue()) {
                        Edit.Font = GetBoldFont();
                    }
                    else {
                        Edit.Font = Font;
                    }
                    break;
                case RENDERMODE_LEFTDOT:
                    if (gridEntry.ShouldSerializePropertyValue()) {
                        rect.X += (LEFTDOT_SIZE * 2);
                        rect.Width -= (LEFTDOT_SIZE * 2);
                    }
                    // nothing
                    break;
                case RENDERMODE_TRIANGLE:
                    // nothing
                    break;
            }
#endif

            if (GetFlag(FlagIsSplitterMove) || !gridEntry.HasValue || !FocusInside) {
                Edit.Visible = false;
            }
            else {
                rect.Offset(1,1);
                rect.Height -= 1;
                CommonEditorUse(Edit,rect);
                bool drawReadOnly = gridEntry.ShouldRenderReadOnly;
                Edit.ForeColor = drawReadOnly ? this.GrayTextColor : this.ForeColor;
                Edit.BackColor = this.BackColor;
                Edit.ReadOnly = drawReadOnly || !gridEntry.IsTextEditable;
            }

            GridEntry oldSelectedGridEntry = selectedGridEntry;
            selectedRow = row;
            selectedGridEntry = gridEntry;
            this.ownerGrid.SetStatusBox(gridEntry.PropertyLabel,gridEntry.PropertyDescription);

            // tell the new focused item that it now has focus
            if (selectedGridEntry != null) {
                selectedGridEntry.Focus = this.FocusInside;
            }

            if (!GetFlag(FlagIsNewSelection)) {
                FocusInternal();
            }
            
            // CONSIDER: -1 is overloaded -- to us, it means "no selection", but to InvalidateRow,
            // it means "invalidate everything".  Should we ever pass InvalidateRow a -1?
            InvalidateRow(oldSel);

            InvalidateRow(row);
            if (FocusInside)
            {
                SetFlag(FlagIsNewSelection, false);
            }
            
            try {
                if (selectedGridEntry != oldSelectedGridEntry) {
                    this.ownerGrid.OnSelectedGridItemChanged(oldSelectedGridEntry, selectedGridEntry);
                }               
            }
            catch {
            }
        }

        public virtual void SetConstants() {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:SetConstants");
            Size size = this.GetOurSize();
            
            visibleRows = (int)Math.Ceiling(((double)size.Height)/(1+RowHeight));
            
            size = this.GetOurSize();
            
            if (size.Width >= 0) {
                labelRatio = Math.Max(Math.Min(labelRatio, 9), 1.1);
                labelWidth = ptOurLocation.X + (int) ((double)size.Width / labelRatio);
            }
            
            int oldWidth = labelWidth;

            
            bool adjustWidth = SetScrollbarLength();
            GridEntryCollection rgipesAll = GetAllGridEntries();
            if (rgipesAll != null) {
                int scroll = GetScrollOffset();
                if ((scroll + visibleRows) >= rgipesAll.Count) {
                    visibleRows = rgipesAll.Count - scroll;
                }
            }
            
            
            if (adjustWidth && size.Width >= 0) {
                labelRatio = ((double) GetOurSize().Width / (double) (oldWidth - ptOurLocation.X));
                //labelWidth = loc.X + (int) ((double)size.Width / labelRatio);
            }

            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "\tsize       :" + size.ToString());
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "\tlocation   :" + ptOurLocation.ToString());
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "\tvisibleRows:" + (visibleRows).ToString());
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "\tlabelWidth :" + (labelWidth).ToString());
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "\tlabelRatio :" + (labelRatio).ToString());
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "\trowHeight  :" + (RowHeight).ToString());
#if DEBUG
            if (rgipesAll == null) {
                Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "\tIPE Count  :(null)");
            }
            else {
                Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "\tIPE Count  :" + (rgipesAll.Count).ToString());
            }
#endif
        }

        private void SetCommitError(short error) {
            SetCommitError(error, error == ERROR_THROWN);
        }

        private void SetCommitError(short error, bool capture) {
        #if DEBUG
            if (CompModSwitches.DebugGridView.TraceVerbose) {
                string err = "UNKNOWN!";
                switch (error) {
                    case ERROR_NONE:
                        err = "ERROR_NONE";
                        break;
                    case ERROR_THROWN:
                        err = "ERROR_THROWN";
                        break;
                    case ERROR_MSGBOX_UP:
                        err = "ERROR_MSGBOX_UP";
                        break;
                }
                Debug.WriteLine( "PropertyGridView:SetCommitError(error=" + err + ", capture=" + capture.ToString() + ")");
            }
        #endif
            errorState = error;
            if (error != ERROR_NONE) {
                CancelSplitterMove();
            }
            
            Edit.HookMouseDown = capture;
            
        }

        internal /*public virtual*/ void SetExpand(GridEntry gridEntry, bool value) {
            if (gridEntry.Expandable) {

                int row = GetRowFromGridEntry(gridEntry);
                int countFromEnd = visibleRows - row;
                int curRow = selectedRow;

                // if the currently selected row is below us, we need to commit now
                // or the offsets will be wrong
                if (selectedRow != -1 && row < selectedRow && Edit.Visible) {
                    // this will cause the commit
                    FocusInternal();

                }

                int offset = GetScrollOffset();
                int items = totalProps;

                gridEntry.InternalExpanded = value;
                RecalculateProps();
                GridEntry ipeSelect = selectedGridEntry;
                if (!value) {
                    for (GridEntry ipeCur = ipeSelect; ipeCur != null; ipeCur = ipeCur.ParentGridEntry) {
                        if (ipeCur.Equals(gridEntry)) {
                            ipeSelect = gridEntry;
                        }
                    }
                }
                row = GetRowFromGridEntry(gridEntry);

                SetConstants();

                int newItems = totalProps - items;

                if (value && newItems > 0 && newItems < visibleRows && (row + (newItems)) >= visibleRows && newItems < curRow) {
                    // scroll to show the newly opened items.
                    SetScrollOffset((totalProps - items) + offset);
                }

                Invalidate();

                SelectGridEntry(ipeSelect,false);

                int scroll = GetScrollOffset();
                SetScrollOffset(0);
                SetConstants();
                SetScrollOffset(scroll);
            }
        }

        private void SetFlag(short flag, bool value) {
            if (value) {
                flags |= flag;
            }
            else {
                flags &= (short)~flag;
            }
        }

        public virtual void SetScrollOffset(int cOffset) {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:SetScrollOffset(" + cOffset.ToString() + ")");
            int posNew = Math.Max(0, Math.Min(totalProps - visibleRows + 1, cOffset));
            int posOld = ScrollBar.Value;
            if (posNew != posOld && IsScrollValueValid(posNew) && visibleRows > 0) {
                ScrollBar.Value = posNew;
                Invalidate(); 
                selectedRow = GetRowFromGridEntry(selectedGridEntry);
            }
        }

        // C#r
        internal virtual bool _Commit() {
            return Commit();
        }

        private bool Commit() {

            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:Commit()");

            if (errorState == ERROR_MSGBOX_UP) {
                Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:Commit() returning false because an error has been thrown or we are in a property set");
                return false;
            }

            if (!this.NeedsCommit) {
                SetCommitError(ERROR_NONE);
                Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:Commit() returning true because no change has been made");
                return true;
            }

            if (GetInPropertySet()) {
                return false;
            }

            GridEntry ipeCur = GetGridEntryFromRow(selectedRow);
            if (ipeCur == null) {
                return true;
            }
            bool success = false;
            try {
                success = CommitText(Edit.Text);
            }
            finally { 
    
                if (!success) {
                    Edit.FocusInternal();
                    SelectEdit(false);
                }
                else {
                    SetCommitError(ERROR_NONE);   
                }
            }
            return success;
        }

        private bool CommitValue(object value) {

            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:CommitValue(" + (value==null ? "null" :value.ToString()) + ")");

            GridEntry ipeCur = selectedGridEntry;

            if (selectedGridEntry == null && selectedRow != -1) {
                ipeCur = GetGridEntryFromRow(selectedRow);
            }

            if (ipeCur == null) {
                Debug.Fail("Committing with no selected row!");
                return true;
            }

            int propCount = ipeCur.ChildCount;
            bool capture = Edit.HookMouseDown;
            object originalValue = null;

            try {
                originalValue = ipeCur.PropertyValue;
            }
            catch {
                // if the getter is failing, we still want to let
                // the set happen.
            }

            try {
                try {
                    SetFlag(FlagInPropertySet, true);

                    //if this propentry is enumerable, then once a value is selected from the editor,
                    //we'll want to close the drop down (like true/false).  Otherwise, if we're
                    //working with Anchor for ex., then we should be able to select different values
                    //from the editor, without having it close every time.
                    if (ipeCur != null &&
                        ipeCur.Enumerable) {
                           CloseDropDown();
                    }

                    try {
                        Edit.DisableMouseHook = true;
                        ipeCur.PropertyValue = value;
                    }
                    finally {
                        Edit.DisableMouseHook = false;
                        Edit.HookMouseDown = capture;
                    }
                }
                catch (Exception ex) {
                    SetCommitError(ERROR_THROWN);
                    ShowInvalidMessage(ipeCur.PropertyLabel, value, ex);
                    return false;
                }
            }
            finally {
                SetFlag(FlagInPropertySet, false);
            }

            SetCommitError(ERROR_NONE);

            string text = ipeCur.GetPropertyTextValue();
            if (!String.Equals(text, Edit.Text)) {
                Edit.Text = text;
                Edit.SelectionStart = 0;
                Edit.SelectionLength = 0;
            }
            originalTextValue = text;

            // Update our reset command.
            //
            UpdateResetCommand(ipeCur);

            if (ipeCur.ChildCount != propCount) {
                ClearGridEntryEvents(allGridEntries, 0, -1);
                allGridEntries = null;
                SelectGridEntry(ipeCur, true);
            }

            this.ownerGrid.OnPropertyValueSet(ipeCur, originalValue);

            return true;
        }

        private bool CommitText(string text) {

            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:CommitValue(" + (text==null ? "null" :text.ToString()) + ")");

            object value = null;

            GridEntry ipeCur = selectedGridEntry;

            if (selectedGridEntry == null && selectedRow != -1) {
                ipeCur = GetGridEntryFromRow(selectedRow);
            }

            if (ipeCur == null) {
                Debug.Fail("Committing with no selected row!");
                return true;
            }

            try {
                value = ipeCur.ConvertTextToValue(text);
            }
            catch (Exception ex) {
                SetCommitError(ERROR_THROWN);
                ShowInvalidMessage(ipeCur.PropertyLabel, text, ex);
                return false;
            }

            SetCommitError(ERROR_NONE);

            return CommitValue(value);
        }
        
        internal void ReverseFocus() {
            if (selectedGridEntry == null) {
               FocusInternal();
            }
            else {
               SelectGridEntry(selectedGridEntry, true);
               
               if (DialogButton.Visible) {
                  DialogButton.FocusInternal();
               }
               else if (DropDownButton.Visible) {
                  DropDownButton.FocusInternal();
               }
               else if (Edit.Visible) {
                  Edit.SelectAll();
                  Edit.FocusInternal();
               }
            }
        }

        private bool SetScrollbarLength() {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:SetScrollBarLength");
            bool sbChange = false;
            if (totalProps != -1) {
                if (totalProps < visibleRows) {
                    SetScrollOffset(0);
                }
                else if (GetScrollOffset() > totalProps) {
                    SetScrollOffset((totalProps+1) - visibleRows);
                }

                bool fHidden = !ScrollBar.Visible;
                if (visibleRows > 0) {
                    ScrollBar.LargeChange = visibleRows-1;
                }
                ScrollBar.Maximum = Math.Max(0,totalProps - 1);
                if (fHidden != (totalProps < visibleRows)) {
                    sbChange = true;
                    ScrollBar.Visible = fHidden;
                    Size size = GetOurSize();
                    if (labelWidth != -1 && size.Width > 0) {
                        if (labelWidth > ptOurLocation.X + size.Width) {
                            labelWidth = ptOurLocation.X + (int) ((double)size.Width / labelRatio);
                        }
                        else {
                            labelRatio = ((double) GetOurSize().Width / (double) (labelWidth - ptOurLocation.X));
                        }
                    }
                    Invalidate();
                }
            }
            return sbChange;
        }

        /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.ShowDialog"]/*' />
        /// <devdoc>
        ///      Shows the given dialog, and returns its dialog result.  You should always
        ///      use this method rather than showing the dialog directly, as this will
        ///      properly position the dialog and provide it a dialog owner.
        /// </devdoc>
        public DialogResult /* IWindowsFormsEditorService. */ ShowDialog(Form dialog) {
            // try to shift down if sitting right on top of existing owner.
            if (dialog.StartPosition == FormStartPosition.CenterScreen) {
                Control topControl = this;
                if (topControl != null) {
                    while (topControl.ParentInternal != null) {
                        topControl = topControl.ParentInternal;
                    }
                    if (topControl.Size.Equals(dialog.Size)) {
                        dialog.StartPosition = FormStartPosition.Manual;
                        Point location = topControl.Location;
                        // CONSIDER what constant to get here?
                        location.Offset(25, 25);
                        dialog.Location = location;
                    }
                }
            }

            IntPtr priorFocus = UnsafeNativeMethods.GetFocus();

            IUIService service = (IUIService)GetService(typeof(IUIService));
            DialogResult result;
            if (service != null) {
                result = service.ShowDialog(dialog);
            }
            else {
                result = dialog.ShowDialog(this);
            }

            if (priorFocus != IntPtr.Zero) {
                UnsafeNativeMethods.SetFocus(new HandleRef(null, priorFocus));
            }

            return result;
        }

        private void ShowInvalidMessage(string propName, object value, Exception ex) {

            if (value == null) {
                value = "(null)";
            }

            if (propName == null) {
                propName = "(unknown)";
            }

            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:ShowInvalidMessage(prop=" + propName + ")");
            // we have to uninstall our hook so the user can push the button!
            bool hooked = Edit.HookMouseDown;
            Edit.DisableMouseHook = true;
            SetCommitError(ERROR_MSGBOX_UP, false);

            // These things are just plain useless.
            //
            if (ex is System.Reflection.TargetInvocationException) {
                ex = ex.InnerException;
            }

            // Try to find an exception message to display
            //
            string exMessage = ex.Message;

            bool revert = false;

            while (exMessage == null || exMessage.Length == 0) {
                ex = ex.InnerException;
                if (ex == null) {
                    break;
                }
                exMessage = ex.Message;
            }
            
            IUIService uiSvc = (IUIService)GetService(typeof(IUIService));

            ErrorDialog.Message = SR.GetString(SR.PBRSErrorInvalidPropertyValue);
            ErrorDialog.Text = SR.GetString(SR.PBRSErrorTitle);
            ErrorDialog.Details = exMessage;
            

            if (uiSvc != null) {
                revert = (DialogResult.Cancel == uiSvc.ShowDialog(ErrorDialog));
            }
            else {
                revert = (DialogResult.Cancel == this.ShowDialog(ErrorDialog));
            }
            
            Edit.DisableMouseHook = false;

            if (hooked) {
                SelectGridEntry(selectedGridEntry, true);
            }
            SetCommitError(ERROR_THROWN, hooked);

            if (revert) {
                OnEscape(Edit);
            }
        }

        private bool SplitterInside(int x, int y) {
            return(Math.Abs(x - InternalLabelWidth) < 4);
        }

        private void TabSelection() {
            GridEntry gridEntry = GetGridEntryFromRow(selectedRow);
            if (gridEntry == null)
                return;

            if (Edit.Visible) {
                Edit.FocusInternal();
                SelectEdit(false);
            }
            else if (dropDownHolder != null && dropDownHolder.Visible) {
                dropDownHolder.FocusComponent();
                return;
            }
            else if (currentEditor != null) {
                currentEditor.FocusInternal();
            }

            return;
        }
        
        internal void RefreshHelpAttributes() {
            UpdateHelpAttributes(selectedGridEntry, null);
        }


        private void UpdateHelpAttributes(GridEntry oldEntry, GridEntry newEntry) {
            // Update the help context with the current property
            //
            IHelpService hsvc = GetHelpService();
            if (hsvc == null || oldEntry == newEntry) {
                return;
            }

            GridEntry temp = oldEntry;
            if (oldEntry != null && !oldEntry.Disposed) {
                
    
                while (temp != null) {
                    hsvc.RemoveContextAttribute("Keyword", temp.HelpKeyword);
                    temp = temp.ParentGridEntry;
                }
            }

            if (newEntry != null) {
                temp = newEntry;
            
                UpdateHelpAttributes(hsvc, temp, true);
            }
        }
        
        private void UpdateHelpAttributes(IHelpService helpSvc, GridEntry entry, bool addAsF1) {
            if (entry == null) {
               return;
            }
            
            UpdateHelpAttributes(helpSvc, entry.ParentGridEntry, false);
            string helpKeyword = entry.HelpKeyword;
            if (helpKeyword != null) {
               helpSvc.AddContextAttribute("Keyword", helpKeyword, addAsF1 ? HelpKeywordType.F1Keyword : HelpKeywordType.GeneralKeyword);
            }
        }


        private void UpdateUIBasedOnFont(bool layoutRequired) {
            if (IsHandleCreated && GetFlag(FlagNeedUpdateUIBasedOnFont)) {
                try {
                    if (listBox != null) {
                        DropDownListBox.ItemHeight = RowHeight + 2;
                    }
                    if (btnDropDown != null) {
                        btnDropDown.Size = new Size(SystemInformation.VerticalScrollBarArrowHeight, RowHeight);
                        if (btnDialog != null) {
                            DialogButton.Size = DropDownButton.Size;
                        }
                    }
                    
                    if (layoutRequired) {
                        LayoutWindow(true);
                    }
                }
                finally {
                    SetFlag(FlagNeedUpdateUIBasedOnFont, false);
                }
            }
        }

        private bool UnfocusSelection() {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:UnfocusSelection()");
            GridEntry gridEntry = GetGridEntryFromRow(selectedRow);
            if (gridEntry == null)
                return true;

            bool commit = Commit();
            
            if (commit && this.FocusInside) {
                FocusInternal();
            }
            return commit;
        }

        private void UpdateResetCommand(GridEntry gridEntry) {
            IMenuCommandService mcs = (IMenuCommandService)GetService(typeof(IMenuCommandService));
            if (mcs != null) {
                MenuCommand reset = mcs.FindCommand(PropertyGridCommands.Reset);
                if (reset != null) {
                    reset.Enabled = gridEntry == null ? false : gridEntry.CanResetPropertyValue();
                }
            }
        }


        public void ValueChanged() {
            Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "PropertyGridView:ValueChanged");

            // We do a lot of work to fire OnComponentChanged ourselves. If the consume of
            // IValueAccess calls ValueChanged then we need to ensure that OnComponentChanged
            // gets fired. To do this we first have to get the Site of the selected component
            // so that we can GetService and get at the IDesignerHost and IComponentChanged.
            //
            // As a fall back, we will just call commit value if we can't find everything
            // we need.
            //

            bool didCommit = false;

            IDesignerHost host = null;
            IComponentChangeService changeSvc = null;

            GridEntry gridEntry = selectedGridEntry;
            while (gridEntry.ParentGridEntry != null) {
                gridEntry = gridEntry.ParentGridEntry;
            }

            if (gridEntry != null) {
                object[] values = null;
                object single = gridEntry.PropertyValue;
                if (single is Array) {
                    Array arr = (Array)single;
                    values = new object[arr.Length];
                    for (int i=0; i<values.Length; i++) {
                        values[i] = arr.GetValue(i);
                    }
                }
                else {
                    values = new object[] {single};
                }


                for (int i=0; i<values.Length; i++) {
                    if (values[i] is IComponent) {
                        host = (IDesignerHost)((IComponent)values[i]).Site.GetService(typeof(IDesignerHost));
                        changeSvc = (IComponentChangeService)((IComponent)values[i]).Site.GetService(typeof(IComponentChangeService));
                        break;
                    }
                }

                if (host != null && changeSvc != null) {
                    DesignerTransaction trans = host.CreateTransaction();
                    try {
                        CommitValue(Value);
                        didCommit = true;

                        for (int i=0; i<values.Length; i++) {
                            changeSvc.OnComponentChanged(values[i], null, null, null);
                        }
                    }
                    finally {
                        trans.Commit();
                    }
                }

            }

            if (!didCommit) {
                CommitValue(Value);
            }
        }

        // a mini version of process dialog key
        // for responding to WM_GETDLGCODE
        internal bool WantsTab(bool forward) {
            if (forward) {
                if (this.Focused) {
                    // we want a tab if the grid has focus and
                    // we have a button or an Edit
                    if (DropDownButton.Visible ||
                        DialogButton.Visible ||
                        Edit.Visible) {
                        return true;
                    }
                }
                else if (Edit.Focused && (DropDownButton.Visible || DialogButton.Visible)) {
                    // if the Edit has focus, and we have a button, we want the tab as well
                    return true;
                }
                return ownerGrid.WantsTab(forward);
            }
            else {
                if (Edit.Focused || DropDownButton.Focused || DialogButton.Focused) {
                    return true;
                }
                return ownerGrid.WantsTab(forward);
            }
        }
        
        private unsafe bool WmNotify(ref Message m) {
            if (m.LParam != IntPtr.Zero) {
                NativeMethods.NMHDR* nmhdr = (NativeMethods.NMHDR*)m.LParam;
            
                if (nmhdr->hwndFrom == ToolTip.Handle) {
                    switch (nmhdr->code) {
                        case NativeMethods.TTN_POP:
                            break;
                        case NativeMethods.TTN_SHOW:
                            // we want to move the tooltip over where our text would be
                            Point mouseLoc = Cursor.Position;
    
                            // convert to window coords
                            mouseLoc = this.PointToClientInternal(mouseLoc);
    
                            // figure out where we are and apply the offset
                            mouseLoc = FindPosition(mouseLoc.X, mouseLoc.Y);
    
                            if (mouseLoc == InvalidPosition) {
                                break;
                            }
    
                            GridEntry curEntry = GetGridEntryFromRow(mouseLoc.Y);
    
                            if (curEntry == null) {
                                break;
                            }
    
                            // get the proper rectangle
                            Rectangle itemRect = GetRectangle(mouseLoc.Y, mouseLoc.X);
                            Point     tipPt    = Point.Empty;
    
                            // and if we need a tooltip, move the tooltip control to that point.
                            if (mouseLoc.X == ROWLABEL) {
                                tipPt = curEntry.GetLabelToolTipLocation(mouseLoc.X - itemRect.X, mouseLoc.Y - itemRect.Y);
                            }
                            else if (mouseLoc.X == ROWVALUE) {
                                tipPt = curEntry.ValueToolTipLocation;
                            }
                            else {
                                break;
                            }
    
                            if (tipPt != InvalidPoint) {
                                itemRect.Offset(tipPt);
                                PositionTooltip(this, ToolTip, itemRect);
                                m.Result = (IntPtr)1;
                                return true;
                            }
    
                            break;
                    }
                }
            }
            return false;
        }
        
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                
                case NativeMethods.WM_SYSCOLORCHANGE:
                    Invalidate();
                    break;

                    // SBurke -- if we get focus in the error
                    // state, make sure we push it back to the
                    // Edit or bad bad things can happen with
                    // our state...
                    //
                case NativeMethods.WM_SETFOCUS:
                    if (!GetInPropertySet() && Edit.Visible && (errorState != ERROR_NONE || !Commit())) {
                        base.WndProc(ref m);
                        Edit.FocusInternal();
                        return;
                    }
                    break;
                    
                case NativeMethods.WM_IME_STARTCOMPOSITION:
                    Edit.FocusInternal();
                    Edit.Clear();
                    UnsafeNativeMethods.PostMessage(new HandleRef(Edit, Edit.Handle), NativeMethods.WM_IME_STARTCOMPOSITION, 0, 0); 
                    return;
                    
                case NativeMethods.WM_IME_COMPOSITION:
                    Edit.FocusInternal();
                    UnsafeNativeMethods.PostMessage(new HandleRef(Edit, Edit.Handle), NativeMethods.WM_IME_COMPOSITION, m.WParam, m.LParam);
                    return;
                    
            case NativeMethods.WM_GETDLGCODE:

                    int flags = NativeMethods.DLGC_WANTCHARS |  NativeMethods.DLGC_WANTARROWS;
                    

                    if (selectedGridEntry != null) {
                        if ((ModifierKeys & Keys.Shift) == 0) {
                            // if we're going backwards, we don't want the tab.
                            // otherwise, we only want it if we have an edit...
                            //
                            if (edit.Visible) {
                                flags |= NativeMethods.DLGC_WANTTAB;
                            }
                        }
                    }
                    m.Result = (IntPtr)(flags);
                    return;
                    
                case NativeMethods.WM_MOUSEMOVE: 
                    
                    // check if it's the same position, of so eat the message
                    if ((int)m.LParam == lastMouseMove) {
                        return;
                    }
                    lastMouseMove = (int)m.LParam;
                    break;

                case NativeMethods.WM_NOTIFY:
                    if (WmNotify(ref m))
                        return;
                    break;
                case AutomationMessages.PGM_GETSELECTEDROW:
                    m.Result = (IntPtr)GetRowFromGridEntry(selectedGridEntry);
                    return;
                case AutomationMessages.PGM_GETVISIBLEROWCOUNT:
                    m.Result = (IntPtr)Math.Min(visibleRows, totalProps);
                    return;
            }

            base.WndProc(ref m);
        }

        private class DropDownHolder : Form, IMouseHookClient {

            internal Control currentControl = null;
            internal const int BORDER = 1;
            internal PropertyGridView gridView;
            private  MouseHooker mouseHooker;
            
            internal DropDownHolder(PropertyGridView psheet)
            : base() {
               this.ShowInTaskbar = false;
               this.ControlBox = false;
               this.MinimizeBox = false;
               this.MaximizeBox = false;
               this.Text = "";
               this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
               mouseHooker = new MouseHooker(this, this, psheet);
               Visible = false;
               gridView = psheet;
               Font = psheet.Font;
               this.BackColor = gridView.BackColor;
            }

            protected override CreateParams CreateParams {
                get {
                    CreateParams cp = base.CreateParams;
                    cp.ExStyle |= NativeMethods.WS_EX_TOOLWINDOW;
                    cp.Style |= NativeMethods.WS_POPUP | NativeMethods.WS_BORDER;
                    if (gridView != null) {
                        cp.Parent = gridView.ParentInternal.Handle;
                    }
                    return cp;
                }
            }
            
             public bool DisableMouseHook {
                get {
                    return mouseHooker.DisableMouseHook;
                }
                set {
                    mouseHooker.DisableMouseHook = value;
                }
            }

            public virtual bool HookMouseDown{
                get{
                    return mouseHooker.HookMouseDown;
                }
                set{
                    mouseHooker.HookMouseDown = value;
                }
            }
            
            
            protected override void DestroyHandle() {
                  mouseHooker.HookMouseDown = false;
                  base.DestroyHandle();
            }
            
            public void DoModalLoop() {
               
                  // Push a modal loop.  This kind of stinks, but I think it is a
                  // better user model than returning from DropDownControl immediately.
                  //  
                  while (this.Visible) { 
                      Application.DoEvents();
                      UnsafeNativeMethods.MsgWaitForMultipleObjects(1, 0, true, 250, NativeMethods.QS_ALLINPUT);
                  }
            }
            
            public virtual Control Component {
                get {
                    return currentControl;
                }
            }

            public virtual bool GetUsed() {
                return(currentControl != null);
            }
            
            protected override void OnMouseDown(MouseEventArgs me) {
               if (me.Button == MouseButtons.Left) {
                  gridView.CloseDropDown();
               }
               base.OnMouseDown(me);
            }

            protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
                if (currentControl != null) {
                    currentControl.SetBounds(0, 0, width - 2 * BORDER, height - 2 * BORDER);
                    width = currentControl.Width;
                    height = currentControl.Height;
                    if (height == 0 && currentControl is ListBox) {
                        height = ((ListBox)currentControl).ItemHeight;
                        currentControl.Height = height;
                    }
                    width += 2 * BORDER;
                    height += 2 * BORDER;
                }
                base.SetBoundsCore(x, y, width, height, specified);
            }

            public virtual void FocusComponent() {
                Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "DropDownHolder:FocusComponent()");
                if (currentControl != null && Visible) {
                    currentControl.FocusInternal();
                }
            }
            
            public bool OnClickHooked() {
                  gridView.CloseDropDown();
                  return false;
            }
            
            private void OnCurrentControlResize(object o, EventArgs e) {
                if (currentControl != null) {
                    int oldWidth = this.Width;
                    this.Size = new Size(2 * BORDER + currentControl.Width, 2 * BORDER + currentControl.Height);
                    this.Left -= (this.Width - oldWidth);
                }
            }
          
            protected override bool ProcessDialogKey(Keys keyData) {
                if ((keyData & (Keys.Shift | Keys.Control | Keys.Alt)) == 0) {
                    switch (keyData & Keys.KeyCode) {
                        case Keys.Escape:
                            gridView.OnEscape(this);
                            return true;
                        case Keys.F4:
                            gridView.F4Selection(true);
                            return true;
                        case Keys.Return:
                            // make sure the return gets forwarded to the control that
                            // is being displayed
                            if (gridView.UnfocusSelection()) {
                              gridView.SelectedGridEntry.OnValueReturnKey();
                            }
                            return true;
                    }
                }

                return base.ProcessDialogKey(keyData);
            }

            public virtual void SetComponent(Control ctl) {

                if (currentControl != null) {
                    Controls.Remove(currentControl);
                    currentControl = null;
                }
                if (ctl != null) {
                    Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "DropDownHolder:SetComponent(" + (ctl.GetType().Name) + ")");
                    Controls.Add(ctl);
                    Size = new Size(2 * BORDER + ctl.Width, 2 * BORDER + ctl.Height);
                    ctl.Location = new Point(0, 0);
                    ctl.Visible = true;
                    currentControl = ctl;
                    currentControl.Resize += new EventHandler(this.OnCurrentControlResize);
                }
                Enabled = currentControl != null;
            }

            protected override void WndProc(ref Message m) {

                if (m.Msg == NativeMethods.WM_ACTIVATE) {
                    SetState(STATE_MODAL, true);
                    Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "DropDownHolder:WM_ACTIVATE()");
                    Control activatedControl = Control.FromHandleInternal(m.LParam);
                    if (Visible && NativeMethods.Util.LOWORD(m.WParam) == NativeMethods.WA_INACTIVE && (activatedControl == null || !this.Contains(activatedControl))) {
                        gridView.CloseDropDown();
                        return;
                    }
                    
                    // prevent the IMsoComponentManager active code from getting fired.
                    //Active = ((int)m.WParam & 0x0000FFFF) != NativeMethods.WA_INACTIVE;
                    //return;
                }
                else if (m.Msg == NativeMethods.WM_CLOSE) {
                    // don't let an ALT-F4 get you down
                    //
                    if (Visible) {
                        gridView.CloseDropDown();
                    }
                    return;
                }

                base.WndProc(ref m);
            }
        }

        private class GridViewListBox : ListBox {

            internal bool fInSetSelectedIndex = false;
            
            public GridViewListBox(PropertyGridView gridView) {
                base.IntegralHeight = false;
            }

            protected override CreateParams CreateParams {
                get {
                    CreateParams cp = base.CreateParams;
                    cp.Style &= ~NativeMethods.WS_BORDER;
                    cp.ExStyle &= ~NativeMethods.WS_EX_CLIENTEDGE;
                    return cp;
                }
            }

            public virtual bool InSetSelectedIndex() {
                return fInSetSelectedIndex;
            }

            protected override void OnSelectedIndexChanged(EventArgs e) {
                fInSetSelectedIndex = true;
                base.OnSelectedIndexChanged(e);
                fInSetSelectedIndex = false;
            }

        }

        private class GridViewEdit : TextBox , IMouseHookClient {

            internal bool fInSetText = false;
            internal bool filter = false;
            internal PropertyGridView psheet = null;
            private  bool dontFocusMe = false;
            private int   lastMove;
            
            private MouseHooker mouseHooker;
            
            // We do this becuase the Focus call above doesn't always stick, so
            // we make the Edit think that it doesn't have focus.  this prevents
            // ActiveControl code on the containercontrol from moving focus elsewhere
            // when the dropdown closes.
            public bool DontFocus {
               set {
                  dontFocusMe = value;
               }
            }
                        
            public virtual bool Filter {
                get { return filter;}

                set {
                    this.filter = value;
                }
            }
            
            public override bool Focused {
                get {
                    if (dontFocusMe) {
                        return false;
                    }
                    return base.Focused;
                }
            }


            public override string Text {
                get {
                    return base.Text;
                }
                set {
                    fInSetText = true;
                    base.Text = value;
                    fInSetText = false;
                }
            }
            
            public bool DisableMouseHook {
                get {
                    return mouseHooker.DisableMouseHook;
                }
                set {
                    mouseHooker.DisableMouseHook = value;
                }
            }


            public virtual bool HookMouseDown{
                get{
                    return mouseHooker.HookMouseDown;
                }
                set{
                    mouseHooker.HookMouseDown = value;
                    if (value) {
                        this.FocusInternal();
                    }
                }
            }


            public GridViewEdit(PropertyGridView psheet) {
                this.psheet = psheet;
                mouseHooker = new MouseHooker(this, this, psheet);
            }
        
            protected override void DestroyHandle() {
                  mouseHooker.HookMouseDown = false;
                  base.DestroyHandle();
            }

            protected override void Dispose(bool disposing) {
                if (disposing) {
                    mouseHooker.Dispose();
                }
                base.Dispose(disposing);
            }

            public void FilterKeyPress(char keyChar) {
            
                if (IsInputChar(keyChar)) {
                    this.FocusInternal();
                    this.SelectAll();
                    UnsafeNativeMethods.PostMessage(new HandleRef(this, Handle), NativeMethods.WM_CHAR, (IntPtr)keyChar, IntPtr.Zero);
                }
            }
    
    

            /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.GridViewEdit.IsInputKey"]/*' />
            /// <devdoc>
            ///     Overridden to handle TAB key.
            /// </devdoc>
            protected override bool IsInputKey(Keys keyData) {
                switch (keyData & Keys.KeyCode) {
                    case Keys.Escape:
                    case Keys.Tab:
                    case Keys.F4:
                    case Keys.F1:
                    case Keys.Return:
                        return false;
                }
                if (psheet.NeedsCommit) {
                    return false;
                }
                return base.IsInputKey(keyData);
            }

            /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.GridViewEdit.IsInputChar"]/*' />
            /// <devdoc>
            ///     Overridden to handle TAB key.
            /// </devdoc>
            protected override bool IsInputChar(char keyChar) {
                switch ((Keys)(int)keyChar) {
                    case Keys.Tab:
                    case Keys.Return:
                        return false;
                }
                return base.IsInputChar(keyChar);
            }

            /*protected override void OnLostFocus(EventArgs e){
                base.OnLostFocus(e);
                Debug.Assert(!this.HookMouseDown || !this.Focused, "Bad mojo! Hook active after focus was lost");
            }*/

            protected override void OnKeyDown(KeyEventArgs ke) {

                // this is because on a dialog we may
                // not get a chance to pre-process
                //
                if (ProcessDialogKey(ke.KeyData)) {
                    ke.Handled = true;
                    return;
                }

                base.OnKeyDown(ke);
            }

            protected override void OnKeyPress(KeyPressEventArgs ke) {
                if (!IsInputChar(ke.KeyChar)) {
                    ke.Handled = true;
                    return;
                }
                base.OnKeyPress(ke);
            }
            
            
            public bool OnClickHooked() {
                 // can we commit this value?
                 // eat the value if we failed to commit.
                 return !psheet._Commit();
            }
            
            protected override void OnMouseEnter(EventArgs e) {
               base.OnMouseEnter(e);
               
               
               if (!this.Focused) {
                  Graphics g = CreateGraphics();
                  if (ClientRectangle.Width <= psheet.SelectedGridEntry.GetValueTextWidth(this.Text, g, this.Font)) {
                        psheet.ToolTip.ToolTip = this.Text;
                  }
                  g.Dispose();
               }
               
            }
            
            protected override bool ProcessCmdKey(ref Message msg, Keys keyData) {
            
                 // make sure we allow the Edit to handle ctrl-z
                 switch (keyData & Keys.KeyCode) {
                     case Keys.Z:
                     case Keys.C:
                     case Keys.X:
                     case Keys.V:
                        if(
                           ((keyData & Keys.Control) != 0) && 
                           ((keyData & Keys.Shift) == 0) &&
                           ((keyData & Keys.Alt) == 0)) {
                           return false;
                        }
                        break;
                        
                     case Keys.A:
                        if(
                           ((keyData & Keys.Control) != 0) && 
                           ((keyData & Keys.Shift) == 0) &&
                           ((keyData & Keys.Alt) == 0)) {
                           SelectAll();
                           return true;
                        }
                        
                        break;
                        
                     case Keys.Insert:
                         if (((keyData & Keys.Alt) == 0)) {
                             if (((keyData & Keys.Control) != 0) ^ ((keyData & Keys.Shift) == 0)) {
                                 return false;
                             }
                         }
                         break;
                         
                     case Keys.Delete:
                         if(
                           ((keyData & Keys.Control) == 0) && 
                           ((keyData & Keys.Shift) != 0) &&
                           ((keyData & Keys.Alt) == 0)) {
                           return false;
                         }
                         else if(
                               ((keyData & Keys.Control) == 0) && 
                               ((keyData & Keys.Shift) == 0) &&
                               ((keyData & Keys.Alt) == 0)
                                 )
                         {
                             // if this is just the delete key and we're on a non-text editable property that is resettable,
                             // reset it now.
                             //
                             if (psheet.SelectedGridEntry != null && !psheet.SelectedGridEntry.Enumerable && !psheet.SelectedGridEntry.IsTextEditable && psheet.SelectedGridEntry.CanResetPropertyValue()) {
                                 object oldValue = psheet.SelectedGridEntry.PropertyValue;
                                 psheet.SelectedGridEntry.ResetPropertyValue();
                                 psheet.UnfocusSelection();
                                 psheet.ownerGrid.OnPropertyValueSet(psheet.SelectedGridEntry, oldValue);
                             }
                         }
                         break;
                 }
                 return base.ProcessCmdKey(ref msg, keyData);
            }


            /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.GridViewEdit.ProcessDialogKey"]/*' />
            /// <devdoc>
            ///      Overrides Control.ProcessDialogKey to handle the Escape and Return
            ///      keys.
            /// </devdoc>
            /// <internalonly/>
            protected override bool ProcessDialogKey(Keys keyData) {

                // We don't do anything with modified keys here.
                //
                if ((keyData & (Keys.Shift | Keys.Control | Keys.Alt)) == 0) {
                    switch (keyData & Keys.KeyCode) {
                        case Keys.Return: 
                            bool fwdReturn = !psheet.NeedsCommit;
                            if (psheet.UnfocusSelection() && fwdReturn) {
                              psheet.SelectedGridEntry.OnValueReturnKey();
                            }
                            return true;
                        case Keys.Escape:
                            psheet.OnEscape(this);
                            return true;
                        case Keys.F4:
                            psheet.F4Selection(true);
                            return true;
                    }
                }
                
                // for the tab key, we want to commit before we allow it to be processed.
                if ((keyData & Keys.KeyCode) == Keys.Tab && ((keyData & (Keys.Control | Keys.Alt)) == 0)) {
                    return !psheet._Commit();
                }

                return base.ProcessDialogKey(keyData);
            }

            protected override void SetVisibleCore(bool value) {
                Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "DropDownHolder:Visible(" + (value.ToString()) + ")");
                // make sure we dont' have the mouse captured if
                // we're going invisible
                if (value == false && this.HookMouseDown) {
                    mouseHooker.HookMouseDown = false;
                }
                base.SetVisibleCore(value);
            }

            
            // a mini version of process dialog key
            // for responding to WM_GETDLGCODE
            internal bool WantsTab(bool forward) {
                return psheet.WantsTab(forward);
            }
      
            private unsafe bool WmNotify(ref Message m) {
                
                if (m.LParam != IntPtr.Zero) {
                   NativeMethods.NMHDR* nmhdr = (NativeMethods.NMHDR*)m.LParam;
                   
                   if (nmhdr->hwndFrom == psheet.ToolTip.Handle) {
                       switch (nmhdr->code) {
                          case NativeMethods.TTN_SHOW:
                             PropertyGridView.PositionTooltip(this, psheet.ToolTip, ClientRectangle);
                             m.Result = (IntPtr)1;
                             return true;
                          default:
                             psheet.WndProc(ref m);
                             break;
                       }         
                   }
                }
                return false;
            }
            
            protected override void WndProc(ref Message m) {

                if (filter) {
                    if (psheet.FilterEditWndProc(ref m)) {
                        return;
                    }
                }

                switch (m.Msg) {
                    case NativeMethods.WM_STYLECHANGED:
                        if (((int)m.WParam & NativeMethods.GWL_EXSTYLE) != 0) {
                            psheet.Invalidate();
                        }
                        break;
                    case NativeMethods.WM_MOUSEMOVE:
                        if ((int)m.LParam == lastMove) {
                            return;
                        }
                        lastMove = (int)m.LParam;
                        break;
                    case NativeMethods.WM_DESTROY:
                        mouseHooker.HookMouseDown = false;
                        break;
                    case NativeMethods.WM_SHOWWINDOW:
                        if (IntPtr.Zero == m.WParam) {
                            mouseHooker.HookMouseDown = false;
                        }
                        break;
                    case NativeMethods.WM_PASTE:
                        /*if (!this.ReadOnly) {
                            IDataObject dataObject = Clipboard.GetDataObject();
                            Debug.Assert(dataObject != null, "Failed to get dataObject from clipboard");
                            if (dataObject != null) {
                                object data = dataObject.GetData(typeof(string));
                                if (data != null) {
                                    string clipboardText = data.ToString();
                                    SelectedText = clipboardText;
                                    m.result = 1;
                                    return;
                                }
                            }
                        }*/
                        if (this.ReadOnly) {
                           return;
                        }
                        break;
                                                            
                    case NativeMethods.WM_GETDLGCODE:

                        m.Result = (IntPtr)((long)m.Result | NativeMethods.DLGC_WANTARROWS | NativeMethods.DLGC_WANTCHARS);
                        if (psheet.NeedsCommit || this.WantsTab((ModifierKeys & Keys.Shift) == 0)) {
                            m.Result = (IntPtr)((long)m.Result | NativeMethods.DLGC_WANTALLKEYS | NativeMethods.DLGC_WANTTAB);
                        }
                        return;
                        
                    case NativeMethods.WM_NOTIFY:
                        if (WmNotify(ref m))
                            return;
                        break;                                                              
                }
                base.WndProc(ref m);
            }

            public virtual bool InSetText() {
                return fInSetText;
            }

          
        }
        
        internal interface IMouseHookClient {
        
            // return true if the click is handled, false
            // to pass it on
            bool OnClickHooked();        
        }                                             
        
        internal class MouseHooker {
            private PropertyGridView gridView;
            private Control          control;
            private IMouseHookClient client;
            
            internal int        thisProcessID = 0;
            private GCHandle    mouseHookRoot;
            private IntPtr      mouseHookHandle = IntPtr.Zero;
            private bool        hookDisable = false;
            
            private bool processing;      
            
            public MouseHooker(Control control, IMouseHookClient client, PropertyGridView gridView) {
               this.control = control;
               this.gridView = gridView;
               this.client = client;
            }       
            
            
            public bool DisableMouseHook {
                get {
                    return hookDisable;
                }
                set {
                    hookDisable = value;
                    if (value) {
                        UnhookMouse();
                    }
                }
            }


            public virtual bool HookMouseDown{
                get{
                    return mouseHookHandle != IntPtr.Zero;
                }
                set{
                    if (value && !hookDisable) {
                        HookMouse();
                    }
                    else {
                        UnhookMouse();
                    }
                }
            }

            
            public void Dispose() {
               UnhookMouse();
            }  
                    

            /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.MouseHooker.HookMouse"]/*' />
            /// <devdoc>
            ///     Sets up the needed windows hooks to catch messages.
            /// </devdoc>
            /// <internalonly/>
            private void HookMouse() {
                lock(this) {
                    if (mouseHookHandle != IntPtr.Zero) {
                        return;
                    }
                    
                    if (thisProcessID == 0) {
                        SafeNativeMethods.GetWindowThreadProcessId(new HandleRef(control, control.Handle), out thisProcessID);
                    }
                  
                    
                    NativeMethods.HookProc hook = new NativeMethods.HookProc(new MouseHookObject(this).Callback);
                    mouseHookRoot = GCHandle.Alloc(hook);

                    mouseHookHandle = UnsafeNativeMethods.SetWindowsHookEx(NativeMethods.WH_MOUSE,
                                                               hook,
                                                               NativeMethods.NullHandleRef,
                                                               SafeNativeMethods.GetCurrentThreadId());
                    Debug.Assert(mouseHookHandle != IntPtr.Zero, "Failed to install mouse hook");
                    Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "DropDownHolder:HookMouse()");
                }
            }
            
            /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.MouseHooker.MouseHookProc"]/*' />
            /// <devdoc>
            ///     HookProc used for catch mouse messages.
            /// </devdoc>
            /// <internalonly/>
            private IntPtr MouseHookProc(int nCode, IntPtr wparam, IntPtr lparam) {
                if (nCode == NativeMethods.HC_ACTION) {
                    NativeMethods.MOUSEHOOKSTRUCT mhs = (NativeMethods.MOUSEHOOKSTRUCT)UnsafeNativeMethods.PtrToStructure(lparam, typeof(NativeMethods.MOUSEHOOKSTRUCT));
                    if (mhs != null) {
                        switch ((int)wparam) {
                            case NativeMethods.WM_LBUTTONDOWN:
                            case NativeMethods.WM_MBUTTONDOWN:
                            case NativeMethods.WM_RBUTTONDOWN:
                            case NativeMethods.WM_NCLBUTTONDOWN:
                            case NativeMethods.WM_NCMBUTTONDOWN:
                            case NativeMethods.WM_NCRBUTTONDOWN:
                            case NativeMethods.WM_MOUSEACTIVATE:
                                if (ProcessMouseDown(mhs.hWnd, mhs.pt_x, mhs.pt_y)) {
                                    return (IntPtr)1;
                                }
                                break;
                        }

                    }
                }

                return UnsafeNativeMethods.CallNextHookEx(new HandleRef(this, mouseHookHandle), nCode, wparam, lparam);
            }
            
            /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.MouseHooker.UnhookMouse"]/*' />
            /// <devdoc>
            ///     Removes the windowshook that was installed.
            /// </devdoc>
            /// <internalonly/>
            private void UnhookMouse() {
                lock(this) {
                    if (mouseHookHandle != IntPtr.Zero) {
                        UnsafeNativeMethods.UnhookWindowsHookEx(new HandleRef(this, mouseHookHandle));
                        mouseHookRoot.Free();
                        mouseHookHandle = IntPtr.Zero;
                        Debug.WriteLineIf(CompModSwitches.DebugGridView.TraceVerbose,  "DropDownHolder:UnhookMouse()");
                    }
                }
            }
             /*
            * Here is where we force validation on any clicks outside the
            */
            private bool ProcessMouseDown(IntPtr hWnd, int x, int y) {
            
               
               // com+ 12678
               // if we put up the "invalid" message box, it appears this 
               // method is getting called re-entrantly when it shouldn't be.
               // this prevents us from recursing.
               //
               if (processing) {
                  return false;
               }
               
                IntPtr hWndAtPoint = hWnd;
                IntPtr handle = control.Handle;
                Control ctrlAtPoint = Control.FromHandleInternal(hWndAtPoint);

                // if it's us or one of our children, just process as normal
                //
                if (hWndAtPoint != handle && !control.Contains(ctrlAtPoint)) {
                    Debug.Assert(thisProcessID != 0, "Didn't get our process id!");

                    // make sure the window is in our process
                    int pid;
                    SafeNativeMethods.GetWindowThreadProcessId(new HandleRef(null, hWndAtPoint), out pid);

                    // if this isn't our process, unhook the mouse.
                    if (pid != thisProcessID) {
                        this.HookMouseDown = false;
                        return false;
                    }

                    bool needCommit = false;   

                    // if this a sibling control (e.g. the drop down or buttons), just forward the message and skip the commit
                    needCommit = ctrlAtPoint == null ?  true : !gridView.IsSiblingControl(control, ctrlAtPoint);
                    
                    try {
                       processing = true;
                       
                       if (needCommit && client.OnClickHooked()) {
                              return true;
                          }
                       }
                    finally {
                       processing = false;
                    }

                    // cancel our hook at this point
                    HookMouseDown = false;
                    //gridView.UnfocusSelection();
                }
                return false;
            }
            
              /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.MouseHooker.MouseHookObject"]/*' />
              /// <devdoc>
            ///     Forwards messageHook calls to ToolTip.messageHookProc
            /// </devdoc>
            /// <internalonly/>
            private class MouseHookObject {
                internal WeakReference reference;

                public MouseHookObject(MouseHooker parent) {
                    this.reference = new WeakReference(parent, false);
                }

                public virtual IntPtr Callback(int nCode, IntPtr wparam, IntPtr lparam) {
                    IntPtr ret = IntPtr.Zero;
                    try {
                        MouseHooker control = (MouseHooker)reference.Target;
                        if (control != null) {
                            ret = control.MouseHookProc(nCode, wparam, lparam);
                        }
                    }
                    catch (Exception) {
                        // ignore
                    }
                    return ret;
                }
            }
        }

        /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.PropertyGridViewAccessibleObject"]/*' />
        /// <devdoc>
        ///     The accessible object class for a PropertyGridView. The child accessible objects
        ///     are accessible objects corresponding to the property grid entries.        
        /// </devdoc>
        [System.Runtime.InteropServices.ComVisible(true)]        
        internal class PropertyGridViewAccessibleObject : ControlAccessibleObject {

            /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.PropertyGridViewAccessibleObject.PropertyGridViewAccessibleObject"]/*' />
            /// <devdoc>
            ///     Construct a PropertyGridViewAccessibleObject
            /// </devdoc>
            public PropertyGridViewAccessibleObject(PropertyGridView owner) : base(owner) {
            }
            
            public override string Name {
                get {
                    string name = Owner.AccessibleName;
                    if (name != null) {
                        return name;
                    }
                    else {
                        return SR.GetString(SR.PropertyGridDefaultAccessibleName);
                    }
                }
            }
            
            public override AccessibleRole Role {
                get {
                    AccessibleRole role = Owner.AccessibleRole;
                    if (role != AccessibleRole.Default) {
                        return role;
                    }
                    else {
                        return AccessibleRole.Table;
                    }
                }
            }                                                         

            public AccessibleObject Next(GridEntry current) {
                int row = ((PropertyGridView)Owner).GetRowFromGridEntry(current);
                GridEntry nextEntry = ((PropertyGridView)Owner).GetGridEntryFromRow(++row);
                if (nextEntry != null) {
                    return nextEntry.AccessibilityObject;
                }
                return null;
            }

            public AccessibleObject Previous(GridEntry current) {
                int row = ((PropertyGridView)Owner).GetRowFromGridEntry(current);
                GridEntry prevEntry = ((PropertyGridView)Owner).GetGridEntryFromRow(--row);
                if (prevEntry != null) {
                    return prevEntry.AccessibilityObject;
                }
                return null;
            }

            /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.PropertyGridViewAccessibleObject.GetChild"]/*' />
            /// <devdoc>
            ///      Get the accessible child at the given index.
            ///      The accessible children of a PropertyGridView are accessible objects
            ///      corresponding to the property grid entries.
            /// </devdoc>
            public override AccessibleObject GetChild(int index) {

                GridEntryCollection properties = ((PropertyGridView)Owner).AccessibilityGetGridEntries();
                if (properties != null && index >= 0 && index < properties.Count) {
                    return properties.GetEntry(index).AccessibilityObject;
                }
                else {
                    return null;
                }
            }

            /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.PropertyGridViewAccessibleObject.GetChildCount"]/*' />
            /// <devdoc>
            ///      Get the number of accessible children.
            ///      The accessible children of a PropertyGridView are accessible objects
            ///      corresponding to the property grid entries.
            /// </devdoc>
            public override int GetChildCount() {
                GridEntryCollection properties = ((PropertyGridView)Owner).AccessibilityGetGridEntries();

                if (properties != null) {
                    return properties.Count;
                }
                else {
                    return 0;
                }
            }

            /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.PropertyGridViewAccessibleObject.GetFocused"]/*' />
            /// <devdoc>
            ///      Get the accessible object for the currently focused grid entry.
            /// </devdoc>
            public override AccessibleObject GetFocused() {
            
                GridEntry gridEntry = ((PropertyGridView)Owner).SelectedGridEntry;
                if (gridEntry != null && gridEntry.Focus) {
                    return gridEntry.AccessibilityObject;
                }
                return null;
            }

            /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.PropertyGridViewAccessibleObject.GetSelected"]/*' />
            /// <devdoc>
            ///      Get the accessible object for the currently selected grid entry.
            /// </devdoc>
            public override AccessibleObject GetSelected() {
                GridEntry gridEntry = ((PropertyGridView)Owner).SelectedGridEntry;
                if (gridEntry != null) {
                    return gridEntry.AccessibilityObject;
                }
                return null;
            }



            /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.PropertyGridViewAccessibleObject.HitTest"]/*' />
            /// <devdoc>
            ///      Get the accessible child at the given screen location.
            ///      The accessible children of a PropertyGridView are accessible objects
            ///      corresponding to the property grid entries.
            /// </devdoc>
            public override AccessibleObject HitTest(int x, int y) {

                // Convert to client coordinates
                //
                NativeMethods.POINT pt = new NativeMethods.POINT(x, y);
                UnsafeNativeMethods.ScreenToClient(new HandleRef(Owner, Owner.Handle), pt);

                // Find the grid entry at the given client coordinates
                //
                Point pos = ((PropertyGridView)Owner).FindPosition(pt.x, pt.y);
                if (pos != PropertyGridView.InvalidPosition) {
                    GridEntry gridEntry = ((PropertyGridView)Owner).GetGridEntryFromRow(pos.Y);
                    if (gridEntry != null) {

                        // Return the accessible object for this grid entry
                        //
                        return gridEntry.AccessibilityObject;
                    }
                }

                // No grid entry at this point
                //
                return null;
            }

            /// <include file='doc\PropertyGridView.uex' path='docs/doc[@for="PropertyGridView.PropertyGridViewAccessibleObject.Navigate"]/*' />
            /// <devdoc>
            ///      Navigate to another object.
            /// </devdoc>
            public override AccessibleObject Navigate(AccessibleNavigation navdir) {

                if (GetChildCount() > 0) {
                    // We're only handling FirstChild and LastChild here
                    switch(navdir) {
                        case AccessibleNavigation.FirstChild:
                            return GetChild(0);
                        case AccessibleNavigation.LastChild:
                            return GetChild(GetChildCount() - 1);
                    }
                }
                return null;    // Perform default behavior
            }
        }

        private class GridPositionData {

            ArrayList expandedState;
            GridEntryCollection selectedItemTree;
            int       itemRow;
            int       itemCount;

            public GridPositionData(PropertyGridView gridView) {
                selectedItemTree = gridView.GetGridEntryHierarchy(gridView.selectedGridEntry);
                expandedState = gridView.SaveHierarchyState(gridView.topLevelGridEntries);
                itemRow = gridView.selectedRow;
                itemCount = gridView.totalProps;
            }

            public GridEntry Restore(PropertyGridView gridView) {
                    gridView.RestoreHierarchyState(expandedState);
                    GridEntry entry = gridView.FindEquivalentGridEntry(selectedItemTree);

                    if (entry != null) {
                        gridView.SelectGridEntry(entry, true);
                        
                        int delta = gridView.selectedRow - itemRow;
                        if (delta != 0 && gridView.ScrollBar.Visible) {
                            if (itemRow < gridView.visibleRows) {
                                delta += gridView.GetScrollOffset();
                                
                                if (delta < 0) {
                                    delta = 0;
                                }
                                else if (delta > gridView.ScrollBar.Maximum) {
                                    delta = gridView.ScrollBar.Maximum - 1;
                                }
                                gridView.SetScrollOffset(delta);
                            }
                            
                        }
                    }
                    return entry;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\propertydescriptorgridentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyDescriptorGridEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.PropertyGridInternal {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Reflection;    
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;
    using System.Drawing.Design;
    using Microsoft.Win32;
    using System.Globalization;


    internal class PropertyDescriptorGridEntry : GridEntry {
        internal PropertyDescriptor       propertyInfo;

        private TypeConverter exceptionConverter = null;
        private UITypeEditor  exceptionEditor = null;
        private bool          isSerializeContentsProp = false;
        private byte          parensAroundName   = ParensAroundNameUnknown;
        private IPropertyValueUIService pvSvc;
        protected IEventBindingService    eventBindings = null;
        private bool           pvSvcChecked;
        private PropertyValueUIItem[]   pvUIItems = null;
        private Rectangle          []   uiItemRects;
        private bool          readOnlyVerified = false;
        private bool          forceRenderReadOnly = false;
        private string        helpKeyword;
        // private string         toolTipText = null;
        private bool          activeXHide = false;


        private const int  IMAGE_SIZE = 8;
        private const byte ParensAroundNameUnknown = (byte)0xFF;
        private const byte ParensAroundNameNo = (byte)0;
        private const byte ParensAroundNameYes = (byte)1;

        internal PropertyDescriptorGridEntry(GridEntry peParent, bool hide) : base(peParent){
            this.activeXHide = hide;
        }

        internal PropertyDescriptorGridEntry(GridEntry peParent, PropertyDescriptor propInfo, bool hide)
        : base(peParent) {

            this.activeXHide = hide;
            Initialize(propInfo);
        }
        
        
        /// <include file='doc\PropertyDescriptorGridEntry.uex' path='docs/doc[@for="PropertyDescriptorGridEntry.AllowMerge"]/*' />
        /// <devdoc>
        /// specify that this grid entry should be allowed to be merged for.
        /// multi-select.
        /// </devdoc>
        public override bool AllowMerge {
            get {
               MergablePropertyAttribute mpa = (MergablePropertyAttribute)propertyInfo.Attributes[typeof(MergablePropertyAttribute)];
               return mpa == null || mpa.IsDefaultAttribute();
            }
        }
         
        /// <include file='doc\PropertyDescriptorGridEntry.uex' path='docs/doc[@for="PropertyDescriptorGridEntry.HelpKeyword"]/*' />
        /// <devdoc>
        ///     Retrieves the keyword that the VS help dynamic help window will
        ///     use when this IPE is selected.
        /// </devdoc>
        public override string HelpKeyword {
            get {
                if (this.helpKeyword == null) {

                    object owner = GetValueOwner();
                   
                   if (this is ImmutablePropertyDescriptorGridEntry) {
                      helpKeyword = this.PropertyName;
                      
                      GridEntry ge = this;
                      
                      while (ge.ParentGridEntry != null) {
                           
                           ge = ge.ParentGridEntry;

                           // for value classes, the equality will never work, so
                           // just try the type equality
                           if (ge.PropertyValue == owner || (owner.GetType().IsValueType && owner.GetType() == ge.PropertyValue.GetType()))  {
                               helpKeyword = ge.PropertyName + "." + helpKeyword;
                               break;
                           }
                      }
                   }
                   else {

                        string typeName = "";

                        Type componentType = propertyInfo.ComponentType;

                        if (componentType.IsCOMObject) {
                            typeName = TypeDescriptor.GetClassName(owner);
                        }
                        else {

                            // make sure this property is declared on a class that 
                            // is related to the component we're looking at.
                            // if it's not, it could be a shadow property so we need
                            // to try to find the real property.
                            //
                            Type ownerType = owner.GetType();
                            if (!componentType.IsPublic || !componentType.IsAssignableFrom(ownerType)) {
                                PropertyDescriptor componentProperty = TypeDescriptor.GetProperties(ownerType)[this.PropertyName];
                                if (componentProperty != null) {
                                    componentType = componentProperty.ComponentType;
                                }
                                else {
                                    componentType = null;
                                }
                            }

                            if (componentType == null) {
                                typeName = TypeDescriptor.GetClassName(owner);
                            }
                            else {
                                typeName = componentType.FullName;
                            }
                            
                        }

                        helpKeyword = typeName + "." + propertyInfo.Name;
                   }
                }
                return this.helpKeyword;
            }
        }
        
        internal override string HelpKeywordInternal{
            get {
               return this.PropertyLabel;
            }
        }

        internal override bool Enumerable {
            get {
                return base.Enumerable && !IsPropertyReadOnly;
            }
        }


        protected virtual bool IsPropertyReadOnly {
            get {
                return propertyInfo.IsReadOnly;
            }
        }

        public override bool IsValueEditable {
            get {
                return this.exceptionConverter == null && !IsPropertyReadOnly && base.IsValueEditable;
            }
        }

        public override bool NeedsDropDownButton{
            get {
                return base.NeedsDropDownButton && !IsPropertyReadOnly;
            }
        }

        internal bool ParensAroundName {
            get {
                if (ParensAroundNameUnknown == this.parensAroundName) {
                    if (((ParenthesizePropertyNameAttribute)propertyInfo.Attributes[typeof(ParenthesizePropertyNameAttribute)]).NeedParenthesis) {
                        this.parensAroundName = ParensAroundNameYes;
                    }
                    else {
                        this.parensAroundName = ParensAroundNameNo;
                    }
                }
                return (this.parensAroundName == ParensAroundNameYes);
            }
        }

 
        public override string PropertyCategory {
            get {
                string category = propertyInfo.Category;
                if (category == null || category.Length == 0) {
                    category = base.PropertyCategory;
                }
                return category;
            }
        }
        
        /// <include file='doc\PropertyDescriptorGridEntry.uex' path='docs/doc[@for="PropertyDescriptorGridEntry.PropertyDescriptor"]/*' />
        /// <devdoc>
        ///      Retrieves the PropertyDescriptor that is surfacing the given object/
        /// </devdoc>
        public override PropertyDescriptor PropertyDescriptor {
            get {
                return propertyInfo;
            }
        }


        public override string PropertyDescription {
            get {
                return propertyInfo.Description;
            }
        }

        public override string PropertyLabel {
            get {
                string label = propertyInfo.DisplayName;
                if (ParensAroundName) {
                    label = "(" + label + ")";
                }
                return label;
            }
        }

        /// <include file='doc\PropertyDescriptorGridEntry.uex' path='docs/doc[@for="PropertyDescriptorGridEntry.PropertyName"]/*' />
        /// <devdoc>
        /// Returns non-localized name of this property.
        /// </devdoc>
        public override string PropertyName {
            get {
                if (propertyInfo != null) {
                    return propertyInfo.Name;
                }
                return null;
            }
        }



        public override Type PropertyType {
            get {
                return propertyInfo.PropertyType;
            }
        }


        /// <include file='doc\PropertyDescriptorGridEntry.uex' path='docs/doc[@for="PropertyDescriptorGridEntry.PropertyValue"]/*' />
        /// <devdoc>
        /// Gets or sets the value for the property that is represented
        /// by this GridEntry.
        /// </devdoc>
        public override object PropertyValue{
            get {
                
                try {
                    object objRet = GetPropertyValueCore(GetValueOwner());

                    if (this.exceptionConverter != null) {
                        // undo the exception converter
                        this.Flags = 0;
                        this.exceptionConverter = null;
                        this.exceptionEditor = null;
                    }

                    return objRet;
                }
                catch (Exception e) {
                    
                    if (this.exceptionConverter == null) {
                        // clear the flags
                        this.Flags = 0;
                        this.exceptionConverter = new ExceptionConverter();
                        this.exceptionEditor = new ExceptionEditor();
                    }
                    return e;
                }
            }
            set {
                SetPropertyValue(GetValueOwner(), value);
            }
        }

        private IPropertyValueUIService PropertyValueUIService {
            get {
                if (!pvSvcChecked && this.pvSvc == null) {
                    this.pvSvc = (IPropertyValueUIService)GetService(typeof(IPropertyValueUIService));
                    pvSvcChecked = true;
                }
                return this.pvSvc;
            }
        }

        public override bool ShouldRenderReadOnly {
            get {
               if (base.ForceReadOnly || forceRenderReadOnly) {
                  return true;
               }
            
               // if read only editable is set, make sure it's valid
               //
               if (propertyInfo.IsReadOnly && !readOnlyVerified && GetFlagSet(GridEntry.FLAG_READONLY_EDITABLE)) {
                   Type propType = this.PropertyType;
                   
                   if (propType != null && (propType.IsArray || propType.IsValueType || propType.IsPrimitive)) {
                        SetFlag(FLAG_READONLY_EDITABLE,false);
                        SetFlag(FLAG_RENDER_READONLY, true);
                        forceRenderReadOnly = true;
                   }
               }
               readOnlyVerified = true;
            
               if (base.ShouldRenderReadOnly){
                   if (!this.isSerializeContentsProp && !base.NeedsCustomEditorButton) {
                        return true;
                   }
               }
               return false;
            }
        }

        /// <include file='doc\PropertyDescriptorGridEntry.uex' path='docs/doc[@for="PropertyDescriptorGridEntry.TypeConverter"]/*' />
        /// <devdoc>
        /// Returns the type converter for this entry.
        /// </devdoc>
        internal override TypeConverter TypeConverter {
            get {
                if (exceptionConverter != null) {
                    return exceptionConverter;
                }

                if (converter == null) {
                    converter = propertyInfo.Converter;
                }
                return base.TypeConverter;
            }
        }

        /// <include file='doc\PropertyDescriptorGridEntry.uex' path='docs/doc[@for="PropertyDescriptorGridEntry.UITypeEditor"]/*' />
        /// <devdoc>
        /// Returns the type editor for this entry.  This may return null if there
        /// is no type editor.
        /// </devdoc>
        internal override UITypeEditor UITypeEditor {
            get {
                if (exceptionEditor != null) {
                    return exceptionEditor;
                }

                if (editor == null) {
                    editor = (UITypeEditor)propertyInfo.GetEditor(typeof(System.Drawing.Design.UITypeEditor));
                }

                return base.UITypeEditor;
            }
        }
        
        
        /// <include file='doc\PropertyDescriptorGridEntry.uex' path='docs/doc[@for="PropertyDescriptorGridEntry.EditPropertyValue"]/*' />
        /// <devdoc>
        /// Invokes the type editor for editing this item.
        /// </devdoc>
        internal override void EditPropertyValue(PropertyGridView iva) {            
            base.EditPropertyValue(iva);
            
            if (!IsValueEditable) {
               RefreshPropertiesAttribute refreshAttr = (RefreshPropertiesAttribute)propertyInfo.Attributes[typeof(RefreshPropertiesAttribute)];
               if ((refreshAttr != null && !refreshAttr.RefreshProperties.Equals(RefreshProperties.None))) {
                     this.GridEntryHost.Refresh(refreshAttr != null && refreshAttr.Equals(RefreshPropertiesAttribute.All));
               }
            }
        }


        /*internal override Point GetLabelToolTipLocation(int mouseX, int mouseY){
            if (pvUIItems != null) {
                for (int i = 0; i < pvUIItems.Length; i++) {
                    if (uiItemRects[i].Contains(mouseX, GridEntryHost.GetGridEntryHeight() / 2)) {
                        this.toolTipText = pvUIItems[i].ToolTip;
                        return new Point(mouseX, mouseY);
                    }
                }
            }
            this.toolTipText = null;
            return base.GetLabelToolTipLocation(mouseX, mouseY);
        } */

        protected object GetPropertyValueCore(object target) {
            if (propertyInfo == null) {
                return null;
            }

            if (target is ICustomTypeDescriptor) {
                target = ((ICustomTypeDescriptor)target).GetPropertyOwner(propertyInfo);
            }
            try {
                return propertyInfo.GetValue(target);
            }
            catch{
                
                throw;
            }
            
        }

        protected void Initialize(PropertyDescriptor propInfo) {
            propertyInfo = propInfo;

            this.isSerializeContentsProp = (propertyInfo.SerializationVisibility == DesignerSerializationVisibility.Content);
            

            Debug.Assert(propInfo != null, "Can't create propEntry because of null prop info");

            if (!this.activeXHide && IsPropertyReadOnly) {
                SetFlag(FLAG_TEXT_EDITABLE, false);
            }

            if (isSerializeContentsProp && TypeConverter.GetPropertiesSupported()) {
                SetFlag(FL_EXPANDABLE, true);
            }
        }

        protected virtual void NotifyParentChange(GridEntry ge) {
            // now see if we need to notify the parent(s) up the chain
            while (ge != null &&
                   ge is PropertyDescriptorGridEntry &&
                   ((PropertyDescriptorGridEntry)ge).propertyInfo.Attributes.Contains(NotifyParentPropertyAttribute.Yes)) {

                // find the next parent property with a differnet value owner
                object owner = ge.GetValueOwner();

                // find the next property descriptor with a different parent
                while (!(ge is PropertyDescriptorGridEntry) || owner == ge.GetValueOwner()) {
                    ge = ge.ParentGridEntry;
                    if (ge == null) {
                        break;
                    }
                }

                // fire the change on that owner
                if (ge != null) {
                    owner = ge.GetValueOwner();

                    IComponentChangeService changeService = ComponentChangeService;
                    
                    if (changeService != null) {
                        changeService.OnComponentChanging(owner, ((PropertyDescriptorGridEntry)ge).propertyInfo);
                        changeService.OnComponentChanged(owner, ((PropertyDescriptorGridEntry)ge).propertyInfo, null, null);
                    }
                }
            }
        }
        
        internal override bool NotifyValueGivenParent(object obj, int type) {
            if (obj is ICustomTypeDescriptor) {
                obj = ((ICustomTypeDescriptor)obj).GetPropertyOwner(propertyInfo);
            }

            switch (type) {
                case NOTIFY_RESET:
                    propertyInfo.ResetValue(obj);
                    if (pvUIItems != null) {
                        for (int i = 0; i < pvUIItems.Length; i++) {
                            pvUIItems[i].Reset();
                        }
                    }
                    pvUIItems = null;
                    
                    RefreshPropertiesAttribute refreshAttr = (RefreshPropertiesAttribute)propertyInfo.Attributes[typeof(RefreshPropertiesAttribute)];
                    if ((refreshAttr != null && !refreshAttr.RefreshProperties.Equals(RefreshProperties.None))) {
                        this.GridEntryHost.Refresh(refreshAttr != null && refreshAttr.Equals(RefreshPropertiesAttribute.All));
                    }
                    return false;
            case NOTIFY_CAN_RESET:
                    try {
                        return propertyInfo.CanResetValue(obj) || (pvUIItems != null && pvUIItems.Length > 0);
                    }
                    catch {
                    
                        if (this.exceptionConverter == null) {
                            // clear the flags
                            this.Flags = 0;
                            this.exceptionConverter = new ExceptionConverter();
                            this.exceptionEditor = new ExceptionEditor();
                        }
                        return false;
                    }
            case NOTIFY_SHOULD_PERSIST:
                try{
                    return propertyInfo.ShouldSerializeValue(obj);
                }
                catch {
                    
                    if (this.exceptionConverter == null) {
                        // clear the flags
                        this.Flags = 0;
                        this.exceptionConverter = new ExceptionConverter();
                        this.exceptionEditor = new ExceptionEditor();
                    }
                    return false;
                }
                    
                case NOTIFY_DBL_CLICK:
                case NOTIFY_RETURN:
                    if (eventBindings == null) {
                        eventBindings = (IEventBindingService)GetService(typeof(IEventBindingService));
                    }
                    if (eventBindings != null) {
                        EventDescriptor descriptor = eventBindings.GetEvent(propertyInfo);
                        if (descriptor != null) {
                            return ViewEvent(obj, null, null, true);
                        }
                    }
                break;
            }
            return false;
        }

        public override bool OnMouseClick(int x, int y, int count, MouseButtons button) {
            if (pvUIItems != null && count == 2 && ((button & MouseButtons.Left) == MouseButtons.Left)) {
                for (int i = 0; i < pvUIItems.Length; i++) {
                    if (uiItemRects[i].Contains(x, GridEntryHost.GetGridEntryHeight() / 2)) {
                        pvUIItems[i].InvokeHandler.Invoke(this, propertyInfo, pvUIItems[i]);
                        return true;
                    }
                }
            }
            return base.OnMouseClick(x, y, count, button);
        }

        public override void PaintLabel(System.Drawing.Graphics g, Rectangle rect, Rectangle clipRect, bool selected, bool paintFullLabel) {
            base.PaintLabel(g, rect, clipRect, selected, paintFullLabel);

            IPropertyValueUIService propValSvc = this.PropertyValueUIService;

            if (propValSvc == null) {
                return;
            }

            pvUIItems = propValSvc.GetPropertyUIValueItems(this, propertyInfo);

            if (pvUIItems != null) {
                if (uiItemRects == null || uiItemRects.Length != pvUIItems.Length) {
                    uiItemRects = new Rectangle[pvUIItems.Length];
                }
                for (int i = 0; i < pvUIItems.Length; i++) {
                    uiItemRects[i] = new Rectangle(rect.Right - ((IMAGE_SIZE+1)*(i+1)), (rect.Height - IMAGE_SIZE) / 2, IMAGE_SIZE, IMAGE_SIZE);
                    g.DrawImage(pvUIItems[i].Image, uiItemRects[i]);
                }    
                GridEntryHost.LabelPaintMargin = (IMAGE_SIZE + 1) * pvUIItems.Length;
            }
        }



        private object SetPropertyValue(object obj,object objVal) {
            DesignerTransaction trans = null;
            try {

                object oldValue = GetPropertyValueCore(obj);

                if (objVal != null && objVal.Equals(oldValue)) {
                    return objVal;
                }
                
                ClearCachedValues();
                
                IDesignerHost host = DesignerHost;
                
                
                if (host != null) {
                     trans = host.CreateTransaction(SR.GetString(SR.PropertyGridSetValue, propertyInfo.Name));
                }
                
                // Usually IComponent things are sited and this notification will be
                // fired automatically by the PropertyDescriptor.  However, for non-IComponent sub objects
                // or sub objects that are non-sited sub components, we need to manuall fire
                // the notification.
                //
                bool needChangeNotify  = !(obj is IComponent) || ((IComponent)obj).Site == null;
                
                if (needChangeNotify) {
                        try {
                            if (ComponentChangeService != null) {
                                ComponentChangeService.OnComponentChanging(obj, propertyInfo);
                            }
                        }
                        catch (CheckoutException coEx) {
                            if (coEx == CheckoutException.Canceled) {
                                return oldValue;
                            }
                            throw coEx;
                        }
                    
                }

                
                bool wasExpanded = this.InternalExpanded;
                int childCount = -1;
                if (wasExpanded) {
                    childCount = this.ChildCount;
                }

                RefreshPropertiesAttribute refreshAttr = (RefreshPropertiesAttribute)propertyInfo.Attributes[typeof(RefreshPropertiesAttribute)];
                bool needsRefresh = wasExpanded || (refreshAttr != null && !refreshAttr.RefreshProperties.Equals(RefreshProperties.None));

                if (needsRefresh) {
                    DisposeChildren();
                }
                
                // Determine if this is an event being created, and if so, navigate to the event code
                //
                
                EventDescriptor eventDesc = null;
                
                // This is possibly an event.  Check it out.
                //
                if (obj != null && objVal is string) {
                
                    if (eventBindings == null) {
                        eventBindings = (IEventBindingService)GetService(typeof(IEventBindingService));
                    }
                    if (eventBindings != null) {
                        eventDesc = eventBindings.GetEvent(propertyInfo);
                    }
                    
                    // For a merged set of properties, the event binding service won't
                    // find an event.  So, we ask type descriptor directly.
                    //
                    if (eventDesc == null) {
                        // If we have a merged property descriptor, pull out one of
                        // the elements.
                        //
                        object eventObj = obj;
                        
                        if (propertyInfo is MergePropertyDescriptor && obj is Array) {
                            Array objArray = obj as Array;
                            if (objArray.Length > 0) {
                                eventObj = objArray.GetValue(0);
                            }
                        }
                        eventDesc = TypeDescriptor.GetEvents(eventObj)[propertyInfo.Name];
                    }
                }

                try {
                    if (eventDesc != null) {
                        ViewEvent(obj, (string)objVal, eventDesc, false);
                    }
                    else { // Not an event
                        SetPropertyValueCore(obj,objVal, true);
                    }
                        
                    // Now notify the change service that the change was successful.
                    //
                    if (needChangeNotify && ComponentChangeService != null) {
                        ComponentChangeService.OnComponentChanged(obj, propertyInfo, null, objVal);
                    }
    
                    NotifyParentChange(this);
                }
                finally {
                    // see if we need to refresh the property browser
                    // 1) if this property has the refreshpropertiesattribute, or
                    // 2) it's got expanded sub properties
                    //
                    if (needsRefresh && this.GridEntryHost != null) {
                        RecreateChildren(childCount);
                        this.GridEntryHost.Refresh(refreshAttr != null && refreshAttr.Equals(RefreshPropertiesAttribute.All));
                    }
                } 
            }
            catch (CheckoutException checkoutEx) {
                if (checkoutEx != CheckoutException.Canceled) {
                    throw checkoutEx;
                }
                return null;
            }
            finally {
                if (trans != null) {
                    trans.Commit();
                }
            }
            return obj;
        }

        protected void SetPropertyValueCore(object obj, object value, bool doUndo) {
                                                  
            if (propertyInfo == null) {
                return;
            }

            // Store the current cursor and set it to the HourGlass.
            //
            Cursor oldCursor = Cursor.Current;
            try {
                Cursor.Current = Cursors.WaitCursor;

                object target = obj;

                if (target is ICustomTypeDescriptor) {
                    target = ((ICustomTypeDescriptor)target).GetPropertyOwner(propertyInfo);
                }

                // check the type of the object we are modifying.  If it's a value type or an array,
                // we need to modify the object and push the value back up to the parent.
                //
                bool treatAsValueType = false;

                if (ParentGridEntry != null) {
                    Type propType = ParentGridEntry.PropertyType;
                    treatAsValueType = propType.IsValueType || propType.IsArray;
                }

                if (target != null) {

                    propertyInfo.SetValue(target, value);

                    // SBurke, okay, since the value that we modified may not
                    // be stored by the parent property, we need to push this
                    // value back into the parent.  An example here is Size or
                    // Location, which return Point objects that are unconnected
                    // to the object they relate to.  So we modify the Point object and
                    // push it back into the object we got it from.
                    //
                    if (treatAsValueType) {
                        GridEntry parent = this.ParentGridEntry;
                        if (parent != null && parent.IsValueEditable) {
                            parent.PropertyValue = obj;
                        }
                    }
                }
            }
            finally {
                // Flip back to the old cursor.
                //
                Cursor.Current = oldCursor;
            }
        }

        /// <include file='doc\PropertyDescriptorGridEntry.uex' path='docs/doc[@for="PropertyDescriptorGridEntry.ViewEvent"]/*' />
        /// <devdoc>
        ///     Navigates code to the given event.
        /// </devdoc>
        protected bool ViewEvent(object obj, string newHandler, EventDescriptor eventdesc, bool alwaysNavigate) {
            string handler = (string)GetPropertyValueCore(obj);
            
            if (newHandler == null && handler != null && handler != "") {
                newHandler = handler;
            }
            else if (handler == newHandler && newHandler != null && newHandler != "") {
               return true;
            }
            
            IComponent component = obj as IComponent;
            
            if (component == null && propertyInfo is MergePropertyDescriptor) {
            
                // It's possible that multiple objects are selected, and we're trying to create an event for each of them
                //
                Array objArray = obj as Array;
                if (objArray != null && objArray.Length > 0) {
                    component = objArray.GetValue(0) as IComponent;
                }
            }
            
            if (component == null) {
                return false;
            }
            
            if (propertyInfo.IsReadOnly) {
                return false;
            }
            
            if (eventdesc == null) {
                if (eventBindings == null) {
                    eventBindings = (IEventBindingService)GetService(typeof(IEventBindingService));
                }
                if (eventBindings != null) {
                    eventdesc = eventBindings.GetEvent(propertyInfo);
                }
            }
            
            IDesignerHost host = this.DesignerHost;
            DesignerTransaction trans = null;

            try {
                // This check can cause exceptions if the event has unreferenced dependencies, which we want to cath.
                // This must be done before the transaction is started or the commit/cancel will also throw.
                if (eventdesc.EventType == null) {
                    return false;
                }
                
                if (host != null) {
                    string compName = component.Site != null ? component.Site.Name : component.GetType().Name;
                    trans = DesignerHost.CreateTransaction(SR.GetString(SR.WindowsFormsSetEvent, compName + "." + this.PropertyName));
                }
             
                if (eventBindings == null) {
                    ISite site = component.Site;
                    if (site != null) {
                        eventBindings = (IEventBindingService)site.GetService(typeof(IEventBindingService));
                    }
                }
                
                if (newHandler == null && eventBindings != null) {
                    newHandler = eventBindings.CreateUniqueMethodName(component, eventdesc);
                }

                
                if (newHandler != null) {

                    // now walk through all the matching methods to see if this one exists.
                    // if it doesn't we'll wanna show code.
                    //
                    if (eventBindings != null) {
                        bool methodExists = false;
                        foreach (string methodName in eventBindings.GetCompatibleMethods(eventdesc)) {
                            if (newHandler == methodName) {
                                methodExists = true;
                                break;
                            }
                        }
                        if (!methodExists) {
                            alwaysNavigate = true;
                        }
                    }
                    propertyInfo.SetValue(obj, newHandler);
                }
                
                if (alwaysNavigate && eventBindings != null) {
                    eventBindings.ShowCode(component, eventdesc);
                }
            }
            catch {
                if (trans != null) {
                    trans.Cancel();
                    trans = null;
                }
                throw;
            }
            finally {
                if (trans != null) {
                    trans.Commit();
                }
            }
            return true;
        }

        /// <include file='doc\PropertyDescriptorGridEntry.uex' path='docs/doc[@for="PropertyDescriptorGridEntry.ExceptionConverter"]/*' />
        /// <devdoc>
        ///      The exception converter is a type converter that displays an exception to the user.
        /// </devdoc>
        private class ExceptionConverter : TypeConverter {

            /// <include file='doc\PropertyDescriptorGridEntry.uex' path='docs/doc[@for="PropertyDescriptorGridEntry.ExceptionConverter.ConvertTo"]/*' />
            /// <devdoc>
            ///      Converts the given object to another type.  The most common types to convert
            ///      are to and from a string object.  The default implementation will make a call
            ///      to ToString on the object if the object is valid and if the destination
            ///      type is string.  If this cannot convert to the desitnation type, this will
            ///      throw a NotSupportedException.
            /// </devdoc>
            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
                if (destinationType == typeof(string)) {
                    if (value is Exception) {
                        Exception ex = (Exception)value;
                        if (ex.InnerException != null) {
                            ex = ex.InnerException;
                        }
                        return ex.Message;
                    }
                    return null;
                }
                throw GetConvertToException(value, destinationType);
            }
        }

        /// <include file='doc\PropertyDescriptorGridEntry.uex' path='docs/doc[@for="PropertyDescriptorGridEntry.ExceptionEditor"]/*' />
        /// <devdoc>
        ///      The exception editor displays a message to the user.
        /// </devdoc>
        private class ExceptionEditor : UITypeEditor {

            /// <include file='doc\PropertyDescriptorGridEntry.uex' path='docs/doc[@for="PropertyDescriptorGridEntry.ExceptionEditor.EditValue"]/*' />
            /// <devdoc>
            ///      Edits the given object value using the editor style provided by
            ///      GetEditorStyle.  A service provider is provided so that any
            ///      required editing services can be obtained.
            /// </devdoc>
            public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {
                if (value is Exception) {
                    IUIService uis = null;

                    if (context != null) {
                        uis = (IUIService)context.GetService(typeof(IUIService));
                    }

                    if (uis != null) {
                        uis.ShowError((Exception)value, value.ToString());
                    }
                    else {
                        MessageBox.Show(value.ToString(), SR.GetString(SR.PropertyGridExceptionInfo));
                    }
                }
                return value;
            }

            /// <include file='doc\PropertyDescriptorGridEntry.uex' path='docs/doc[@for="PropertyDescriptorGridEntry.ExceptionEditor.GetEditStyle"]/*' />
            /// <devdoc>
            ///      Retrieves the editing style of the Edit method.  If the method
            ///      is not supported, this will return None.
            /// </devdoc>
            public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
                return UITypeEditorEditStyle.Modal;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\singleselectrootgridentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="SingleSelectRootGridEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.PropertyGridInternal {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Reflection;    
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;
    using Microsoft.Win32;


    internal class SingleSelectRootGridEntry : GridEntry, IRootGridEntry {
        protected object             objValue;
        protected GridEntry          propDefault;
        protected IDesignerHost      host;
        protected IServiceProvider baseProvider = null;
        protected PropertyTab        tab = null;
        protected PropertyGridView     gridEntryHost    = null;
        protected AttributeCollection  browsableAttributes = null;
        private   IComponentChangeService changeService;
        protected bool forceReadOnlyChecked;
        
        internal SingleSelectRootGridEntry(PropertyGridView gridEntryHost, object value, GridEntry parent, IServiceProvider baseProvider, IDesignerHost host, PropertyTab tab, PropertySort sortType)
        : base(parent) {
            Debug.Assert(value != null,"Can't browse a null object!");
            this.host = host;
            this.gridEntryHost = gridEntryHost;
            this.baseProvider = baseProvider;
            this.tab = tab;
            this.objValue = value;

            this.IsExpandable = true;
            // default to categories
            this.PropertySort = sortType;
            this.InternalExpanded = true;
        }

        internal SingleSelectRootGridEntry(PropertyGridView view, object value, IServiceProvider baseProvider, IDesignerHost host, PropertyTab tab, PropertySort sortType) : this(view, value,null, baseProvider, host, tab, sortType) {
        }   

        /// <include file='doc\SingleSelectRootGridEntry.uex' path='docs/doc[@for="SingleSelectRootGridEntry.BrowsableAttributes"]/*' />
        /// <devdoc>
        /// The set of attributes that will be used for browse filtering
        /// </devdoc>
        public override AttributeCollection BrowsableAttributes {
            get {
                if (browsableAttributes == null) {
                    browsableAttributes = new AttributeCollection(new Attribute[]{BrowsableAttribute.Yes});
                }
                return this.browsableAttributes;
            }
            set {
                if (value == null) {
                    ResetBrowsableAttributes();
                    return;
                }

                bool same = true;

                if (this.browsableAttributes != null && value != null && this.browsableAttributes.Count == value.Count) {
                    Attribute[] attr1 = new Attribute[browsableAttributes.Count];
                    Attribute[] attr2 = new Attribute[value.Count];

                    browsableAttributes.CopyTo(attr1, 0);
                    value.CopyTo(attr2, 0);
                    
                    Array.Sort(attr1, GridEntry.AttributeTypeSorter);
                    Array.Sort(attr2, GridEntry.AttributeTypeSorter);
                    for (int i = 0; i < attr1.Length; i++) {
                        if (!attr1[i].Equals(attr2[i])) {
                            same = false;
                            break;
                        }
                    }
                }
                else {
                    same = false;
                }

                this.browsableAttributes = value;

                if (!same && Children != null && Children.Count > 0) {
                    DisposeChildren();
                }
            }
        }
        
        protected override IComponentChangeService ComponentChangeService {
            get {
               if (changeService == null) {
                    changeService = (IComponentChangeService)GetService(typeof(IComponentChangeService));
               }
               return changeService;
            }
        }
        
        internal override bool AlwaysAllowExpand {
            get {
               return true;
            }
        }

        public override PropertyTab CurrentTab {
            get {
                return tab;
            }
            set {
                this.tab = value;
            }
        }

        internal override GridEntry DefaultChild {
            get {
                return propDefault;
            }
            set {
                this.propDefault = value;
            }
        }

        internal override IDesignerHost DesignerHost {
            get {
                return host;
            }
            set {
                host = value;
            }
        }

        internal override bool ForceReadOnly {
            get {
                if (!forceReadOnlyChecked) {
                    ReadOnlyAttribute readOnlyAttr = (ReadOnlyAttribute)TypeDescriptor.GetAttributes(this.objValue)[typeof(ReadOnlyAttribute)];
                    if ((readOnlyAttr != null && !readOnlyAttr.IsDefaultAttribute()) || TypeDescriptor.GetAttributes(this.objValue).Contains(InheritanceAttribute.InheritedReadOnly)) {
                        flags |= FLAG_FORCE_READONLY;
                    }
                    forceReadOnlyChecked = true;
                }
                return base.ForceReadOnly || (GridEntryHost != null && !GridEntryHost.Enabled);
            }
        }

        internal override PropertyGridView GridEntryHost {
            get {       
                return this.gridEntryHost;
            }
            set {
                this.gridEntryHost = value;
            }
        }
        
        public override GridItemType GridItemType {
            get {
                return GridItemType.Root;
            }
        } 

        /// <include file='doc\SingleSelectRootGridEntry.uex' path='docs/doc[@for="SingleSelectRootGridEntry.HelpKeyword"]/*' />
        /// <devdoc>
        ///     Retrieves the keyword that the VS help dynamic help window will
        ///     use when this IPE is selected.
        /// </devdoc>
        public override string HelpKeyword {
            get {
                return TypeDescriptor.GetClassName(objValue);
            }
        }

        public override string PropertyLabel {
            get {
                if (objValue is IComponent) {
                    ISite site = ((IComponent)objValue).Site;
                    if (site == null) {
                        return objValue.GetType().Name;
                    }
                    else {
                        return site.Name;
                    }
                }
                else if (objValue != null) {
                    return objValue.ToString();
                }
                return null;
            }
        }
          
        /// <include file='doc\SingleSelectRootGridEntry.uex' path='docs/doc[@for="SingleSelectRootGridEntry.PropertyValue"]/*' />
        /// <devdoc>
        /// Gets or sets the value for the property that is represented 
        /// by this GridEntry.
        /// </devdoc>
        public override object PropertyValue{
            get {
                return objValue;
            }
            set {
                objValue = value;
            }
        }

        protected override bool CreateChildren() {
            bool fReturn = base.CreateChildren();
            CategorizePropEntries();
            return fReturn;
        }
        
        protected override void Dispose(bool disposing) {
            if (disposing) {
                host = null;
                baseProvider = null;
                tab = null;
                gridEntryHost = null;
                changeService = null;
            }
            this.objValue = null;
            this.propDefault = null;
            base.Dispose(disposing);
        }

        public override object GetService(Type serviceType) {
            object service = null;
            
            if (host != null) {
                service = host.GetService(serviceType);
            }
            if (service == null && baseProvider != null) {
                service = baseProvider.GetService(serviceType);
            }
            return service;
        }

        /// <include file='doc\SingleSelectRootGridEntry.uex' path='docs/doc[@for="SingleSelectRootGridEntry.ResetBrowsableAttributes"]/*' />
        /// <devdoc>
        /// Reset the Browsable attributes to the default (BrowsableAttribute.Yes)
        /// </devdoc>
        public void ResetBrowsableAttributes() {
            this.browsableAttributes = new AttributeCollection(new Attribute[]{BrowsableAttribute.Yes});
        }


        /// <include file='doc\SingleSelectRootGridEntry.uex' path='docs/doc[@for="SingleSelectRootGridEntry.ShowCategories"]/*' />
        /// <devdoc>
        /// Sets the value of this GridEntry from text
        /// </devdoc>
        public virtual void ShowCategories(bool fCategories) {
            if (((this.PropertySort &= PropertySort.Categorized) !=0) != fCategories) {
                
                if (fCategories) { 
                  this.PropertySort |= PropertySort.Categorized;
                }
                else {
                  this.PropertySort &= ~PropertySort.Categorized;
                }
                
                
                // recreate the children
                if (this.Expandable && this.ChildCollection != null) {
                    CreateChildren();
                }
            }
        }

        internal void CategorizePropEntries() {
            if (Children.Count > 0) {
                
                GridEntry[] childEntries = new GridEntry[this.Children.Count];
                this.Children.CopyTo(childEntries, 0);
                
                if ((this.PropertySort & PropertySort.Categorized) != 0) {


                    // first, walk through all the entires and 
                    // group them by their category by adding
                    // them to a hashtable of arraylists.
                    //
                    Hashtable bins = new Hashtable();
                    for (int i = 0; i < childEntries.Length; i++) {
                        GridEntry pe = childEntries[i];
                        string category = pe.PropertyCategory;
                        ArrayList bin = (ArrayList) bins[category];
                        if (bin == null) {
                            bin = new ArrayList();
                            bins[category] = bin;
                        }
                        bin.Add(pe);
                    }

                    // now walk through the hashtable
                    // and create a categorygridentry for each
                    // category that holds all the properties
                    // of that category.
                    //
                    ArrayList propList = new ArrayList();
                    IDictionaryEnumerator enumBins = (IDictionaryEnumerator)bins.GetEnumerator();
                    while (enumBins.MoveNext()) {
                        ArrayList bin = (ArrayList)enumBins.Value;
                        if (bin != null) {
                            string category = (string)enumBins.Key;
                            if (bin.Count > 0) {
                                GridEntry[] rgpes = new GridEntry[bin.Count];
                                bin.CopyTo(rgpes, 0);
                                try {
                                    propList.Add(new CategoryGridEntry(this,category,rgpes));
                                }
                                catch (Exception) {
                                }
                            }
                        }
                    }

                    childEntries = new GridEntry[propList.Count];
                    propList.CopyTo(childEntries, 0);
                    StringSorter.Sort(childEntries);
                    
                    ChildCollection.Clear();
                    ChildCollection.AddRange(childEntries);
              }
           }
        }
       }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\componentmodel\compmodswitches.cs ===
//------------------------------------------------------------------------------
// <copyright file="Component.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Diagnostics;

    /// <internalonly/>
    internal sealed class CompModSwitches {
        private static TraceSwitch xmlSchema;
        private static BooleanSwitch keepTempFiles;        
        private static TraceSwitch xmlSerialization;
        
        public static TraceSwitch XmlSchema {
            get {
                if (xmlSchema == null) {
                    xmlSchema = new TraceSwitch("XmlSchema", "Enable tracing for the XmlSchema class.");
                }
                return xmlSchema;
            }
        }        
        
        public static BooleanSwitch KeepTempFiles {
            get {
                if (keepTempFiles == null) {
                    keepTempFiles = new BooleanSwitch("XmlSerialization.Compilation", "Keep XmlSerialization generated (temp) files.");
                }
                return keepTempFiles;
            }
        }
        
        public static TraceSwitch XmlSerialization {
            get {
                if (xmlSerialization == null) {
                    xmlSerialization = new TraceSwitch("XmlSerialization", "Enable tracing for the System.Xml.Serialization component.");
                }
                return xmlSerialization;
            }
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\propertygridcommands.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyGridCommands.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.PropertyGridInternal {

    using System.Diagnostics;
    using System;
    using System.ComponentModel.Design;
    using Microsoft.Win32;

    /// <include file='doc\PropertyGridCommands.uex' path='docs/doc[@for="PropertyGridCommands"]/*' />
    /// <devdoc>
    ///     This class contains the set of menu commands our property browser
    ///     uses.
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class PropertyGridCommands{

        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.wfcMenuGroup"]/*' />
        /// <devdoc>
        ///      This guid corresponds to the menu grouping windows forms will use for its menus.  This is
        ///      defined in the windows forms menu CTC file, but we need it here so we can define what
        ///      context menus to use.
        /// </devdoc>
        protected static readonly Guid wfcMenuGroup = new Guid("{74D21312-2AEE-11d1-8BFB-00A0C90F26F7}");

        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.wfcCommandSet"]/*' />
        /// <devdoc>
        ///     This guid corresponds to the windows forms command set.
        /// </devdoc>
        protected static readonly Guid wfcMenuCommand = new Guid("{74D21313-2AEE-11d1-8BFB-00A0C90F26F7}");

        /// <include file='doc\PropertyGridCommands.uex' path='docs/doc[@for="PropertyGridCommands.Reset"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID Reset          = new CommandID(wfcMenuCommand, 0x3000);
        /// <include file='doc\PropertyGridCommands.uex' path='docs/doc[@for="PropertyGridCommands.Description"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID Description    = new CommandID(wfcMenuCommand, 0x3001);
        /// <include file='doc\PropertyGridCommands.uex' path='docs/doc[@for="PropertyGridCommands.Hide"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID Hide           = new CommandID(wfcMenuCommand, 0x3002);
        /// <include file='doc\PropertyGridCommands.uex' path='docs/doc[@for="PropertyGridCommands.Commands"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID Commands       = new CommandID(wfcMenuCommand, 0x3010);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\base64encoder.cs ===
//------------------------------------------------------------------------------
// <copyright file="Base64Encoder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
using System.Text;

namespace System.Xml {
    internal class Base64Encoder {

        byte[] _byteBuffer;

        internal string EncodeToBase64(byte[] inArray, int offsetIn, int count) {

            if (null == inArray) {
                throw new ArgumentNullException("inArray");
            }

            if (0 > offsetIn) {
                throw new ArgumentOutOfRangeException("offsetIn");
            }

            if (0 > count) {
                throw new ArgumentOutOfRangeException("count");
            }

            if (count > inArray.Length - offsetIn) {
                throw new ArgumentException("count > inArray.Length - offsetIn");
            }

            //byte[] newInArray;
            int internalBufferLen = (null == _byteBuffer) ? 0: _byteBuffer.Length;
            String strLeftOver = String.Empty;

            if( internalBufferLen > 0) {
                byte[] tempArray = new byte[3];
                int i = 0;
                for(; i < internalBufferLen; i++) {
                    tempArray[i] = _byteBuffer[i];
                }

                do {
                    tempArray[i++] = inArray[offsetIn++];
                    count--;
                }
                while(i < 3 && (0 != count));

                if (0 == count && i < 3) {
                    // the total number of bytes we have is less than 3
                    _byteBuffer = new byte[i];
                    for(int j=0; j < i; _byteBuffer[j] = tempArray[j++]);
                    return String.Empty;
                }

                strLeftOver = Convert.ToBase64String(tempArray, 0, 3);
            }

            int newLeftOverBytes = count % 3;
            _byteBuffer = null;

            if (0 != newLeftOverBytes) {
                count -= newLeftOverBytes;
                // save the bytes for later
                _byteBuffer = new byte[newLeftOverBytes];
                for(int j = 0; j < newLeftOverBytes; j++) {
                    _byteBuffer[j] = inArray[count + offsetIn + j];
                }
            }

            return String.Concat(strLeftOver, Convert.ToBase64String(inArray, offsetIn, count));
        }

        internal string Flush() {

            String returnValue = (null == _byteBuffer) ? String.Empty
                                                       : Convert.ToBase64String(_byteBuffer, 0, _byteBuffer.Length);
            _byteBuffer = null;

            return returnValue;
        }



    } // class
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\binhexdecoder.cs ===
//------------------------------------------------------------------------------
// <copyright file="BinHexDecoder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
using System.Text;

namespace System.Xml {
    internal class BinHexDecoder {

        private ArrayManager   _charBuffer = new ArrayManager();
        bool _HighNibblePresent = false;
        byte _highHalfByte = 0;

        internal byte[] DecodeBinHex(char[] inArray, int offset, bool flush){
            int len = inArray.Length;

            // divide in 1/2 with round up since two chars will be encoded into one byte
            byte[] outArray = new byte[(len - offset + 1) / 2];
            int retLength = DecodeBinHex(inArray, offset, inArray.Length, outArray, 0, outArray.Length, flush);

            if (retLength != outArray.Length) {
                byte[] tmpResult = new byte[retLength];
                Array.Copy(outArray, tmpResult, retLength);
                outArray = tmpResult;
            }

            return outArray;
        }

        internal int DecodeBinHex(char[] inArray, int offset, int inLength, byte[] outArray, int offsetOut, int countOut, bool flush) {

            String msg;

            if (0 > offset) {
                throw new ArgumentOutOfRangeException("offset");
            }

            if (0 > offsetOut) {
                throw new ArgumentOutOfRangeException("offsetOut");
            }

            int len = (null == inArray) ? 0 : inArray.Length;
            if (len < inLength) {
                throw new ArgumentOutOfRangeException("inLength");
            }

            // make sure that countOut + offsetOut are okay
            int outArrayLen = outArray.Length;
            if (outArrayLen < (countOut + offsetOut)){
                throw new ArgumentOutOfRangeException("offsetOut");
            }

            int inBufferCount = inLength - offset;

            if (flush)
                _charBuffer.Refresh();

            if (inBufferCount > 0)
                _charBuffer.Append(inArray, offset, inLength);

            if ((_charBuffer.Length == 0) || (countOut == 0))
                return 0;

            // let's just make sure countOut > 0 and countOut < outArray.Length
            countOut += offsetOut;
            byte lowHalfByte;

            // walk hex digits pairing them up and shoving the value of each pair into a byte
            int internalBufferLength = _charBuffer.Length;
            int offsetOutCur = offsetOut;
            char ch;
            int internalBufferOffset = 0;
            do {
                ch = _charBuffer[internalBufferOffset++];
                if (ch >= 'a' && ch <= 'f') {
                    lowHalfByte = (byte)(10 + ch - 'a');
                }
                else if (ch >= 'A' && ch <= 'F') {
                    lowHalfByte = (byte)(10 + ch - 'A');
                }
                else if (ch >= '0' && ch <= '9') {
                    lowHalfByte = (byte)(ch - '0');
                }
                else if (XmlCharType.IsWhiteSpace(ch)) {
                    continue; // skip whitespace
                }
                else {
                    msg = new String(_charBuffer.CurrentBuffer, _charBuffer.CurrentBufferOffset, (_charBuffer.CurrentBuffer == null) ? 0:(_charBuffer.CurrentBufferLength - _charBuffer.CurrentBufferOffset));
                    throw new XmlException(Res.Xml_InvalidBinHexValue, msg);
                }

                if (_HighNibblePresent) {
                    outArray[offsetOutCur ++] = (byte)((_highHalfByte << 4) + lowHalfByte);
                    _HighNibblePresent = false;
                    if (offsetOutCur == countOut) {
                        break;
                    }
                }
                else {
                    // shift nibble into top half of byte
                    _highHalfByte = lowHalfByte;
                    _HighNibblePresent = true;
                }
            }
            while (internalBufferOffset < internalBufferLength);

            _charBuffer.CleanUp(internalBufferOffset);

            return offsetOutCur - offsetOut;
        }

        internal int BitsFilled {
            get { return (_HighNibblePresent ? 4 : 0); }
        }
        internal void Flush() {
            if (null != _charBuffer) {
                _charBuffer.Refresh();
            }
            _HighNibblePresent = false;
        }

    } // class
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\propertygridinternal\gridentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="GridEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//#define PBRS_PAINT_DEBUG
/*
 */
namespace System.Windows.Forms.PropertyGridInternal {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Reflection;
    using System.Globalization;

    using System.Drawing.Design;    
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;
    using System.Drawing.Drawing2D;
    using Microsoft.Win32;

    /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry"]/*' />
    /// <devdoc>
    ///     Base Entry for properties to be displayed in properties window.
    /// </devdoc>
    internal abstract class GridEntry : GridItem, ITypeDescriptorContext {

        protected static readonly Point InvalidPoint = new Point(int.MinValue, int.MinValue);
        private static BooleanSwitch PbrsAssertPropsSwitch = new BooleanSwitch("PbrsAssertProps", "PropertyBrowser : Assert on broken properties");

        internal static AttributeTypeSorter AttributeTypeSorter = new AttributeTypeSorter();
        
        // Type flags
        internal const int FLAG_TEXT_EDITABLE             = 0x0001;
        internal const int FLAG_ENUMERABLE                = 0x0002;
        internal const int FLAG_CUSTOM_PAINT              = 0x0004;
        internal const int FLAG_IMMEDIATELY_EDITABLE      = 0x0008;
        internal const int FLAG_CUSTOM_EDITABLE           = 0x0010;
        internal const int FLAG_DROPDOWN_EDITABLE         = 0x0020;
        internal const int FLAG_LABEL_BOLD                = 0x0040;
        internal const int FLAG_READONLY_EDITABLE         = 0x0080;
        internal const int FLAG_RENDER_READONLY           = 0x0100;
        internal const int FLAG_IMMUTABLE                 = 0x0200;
        internal const int FLAG_FORCE_READONLY            = 0x0400;
        internal const int FLAG_MASK                      = 0x03FF;

        internal const int FLAG_DISPOSED                  = 0x1000;

        internal const int FL_EXPAND                   = 0x00010000;
        internal const int FL_EXPANDABLE               = 0x00020000;
        //protected const int FL_EXPANDABLE_VALID         = 0x00040000;
        internal const int FL_EXPANDABLE_FAILED        = 0x00080000;
        internal const int FL_NO_CUSTOM_PAINT          = 0x00100000;
        internal const int FL_CATEGORIES               = 0x00200000;
        internal const int FL_CHECKED                  = unchecked((int)0x80000000);

        // rest are GridEntry constants.

        protected const int NOTIFY_RESET                = 1;
        protected const int NOTIFY_CAN_RESET            = 2;
        protected const int NOTIFY_DBL_CLICK            = 3;
        protected const int NOTIFY_SHOULD_PERSIST       = 4;
        protected const int NOTIFY_RETURN               = 5;

        protected const int     OUTLINE_ICON_PADDING    = 5;
        
        protected static IComparer DisplayNameComparer    = new DisplayNameSortComparer();
        
        private static StringFormat stringFormat;

        [Flags]
        internal enum PaintValueFlags{
            None = 0,
            DrawSelected = 0x1,
            FetchValue   = 0x2,
            CheckShouldSerialize = 0x4,
            PaintInPlace = 0x8
        }
        
        static GridEntry() {
            stringFormat = new StringFormat(StringFormatFlags.NoWrap);
            stringFormat.Trimming = StringTrimming.None;
        }

        private class CacheItems {
            public string lastLabel;
            public Font   lastLabelFont;
            public int    lastLabelWidth;
            public string lastValueString;
            public Font   lastValueFont;
            public int    lastValueTextWidth;
            public object lastValue;
            public bool   useValueString;
            public bool   lastShouldSerialize;
            public bool   useShouldSerialize;
        }

        private CacheItems cacheItems;




        // instance variables.
        protected TypeConverter     converter    = null;
        protected UITypeEditor      editor       = null;
        internal GridEntry         parentPE     = null;
        private  GridEntryCollection       childCollection = null;
        internal int               flags           = 0;
        private int               propertyDepth     = 0;
        protected bool              hasFocus = false;
        private Rectangle         outlineRect = Rectangle.Empty;
        protected PropertySort      PropertySort;

        protected Point             labelTipPoint = InvalidPoint;
        protected Point             valueTipPoint = InvalidPoint;

        private   static object      EVENT_VALUE_CLICK = new object();
        private   static object      EVENT_LABEL_CLICK = new object();
        private   static object      EVENT_OUTLINE_CLICK = new object();
        private   static object      EVENT_VALUE_DBLCLICK = new object();
        private   static object      EVENT_LABEL_DBLCLICK = new object();
        private   static object      EVENT_OUTLINE_DBLCLICK = new object();
        private   static object      EVENT_RECREATE_CHILDREN = new object();

        private GridEntryAccessibleObject accessibleObject = null;

        protected GridEntry(GridEntry peParent) {
            parentPE = peParent;
            if (peParent != null) {
                propertyDepth = peParent.PropertyDepth + 1;
                this.PropertySort = peParent.PropertySort;

                if (peParent.ForceReadOnly) {
                    flags |= FLAG_FORCE_READONLY;
                }

            }
            else {
                propertyDepth = -1;
            }
        }


        public AccessibleObject AccessibilityObject {

            get {
                if (accessibleObject == null) {
                    accessibleObject = new GridEntryAccessibleObject(this);
                }
                return accessibleObject;
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.AllowMerge"]/*' />
        /// <devdoc>
        /// specify that this grid entry should be allowed to be merged for.
        /// multi-select.
        /// </devdoc>
        public virtual bool AllowMerge {
            get {
                return true;
            }
        }
        
        internal virtual bool AlwaysAllowExpand {
            get {
               return false;
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.BackgroundBrush"]/*' />
        /// <devdoc>
        /// Gets the value of the background brush to use.  Override
        /// this member to cause the entry to paint it's background in a different color.
        /// The base implementation returns null.
        /// </devdoc>
        protected virtual Brush GetBackgroundBrush(Graphics g) {
            return GridEntryHost.GetBackgroundBrush(g);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.BrowsableAttributes"]/*' />
        /// <devdoc>
        /// The set of attributes that will be used for browse filtering
        /// </devdoc>
        public virtual AttributeCollection BrowsableAttributes {
            get{
                if (parentPE != null) {
                    return parentPE.BrowsableAttributes;
                }
                return null;
            }
            set{
                parentPE.BrowsableAttributes = value;
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.Component"]/*' />
        /// <devdoc>
        ///      Retrieves the component that is invoking the
        ///      method on the formatter object.  This may
        ///      return null if there is no component
        ///      responsible for the call.
        /// </devdoc>
        public virtual IComponent Component {
            get {
                object owner = GetValueOwner();
                if (owner is IComponent) {
                    return(IComponent) owner;
                }
                if (parentPE != null) {
                    return parentPE.Component;
                }
                return null;
            }
        }

        protected virtual IComponentChangeService ComponentChangeService {
            get {
                return parentPE.ComponentChangeService;
            }

        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.Container"]/*' />
        /// <devdoc>
        ///      Retrieves the container that contains the
        ///      set of objects this formatter may work
        ///      with.  It may return null if there is no
        ///      container, or of the formatter should not
        ///      use any outside objects.
        /// </devdoc>
        public virtual IContainer Container {
            get {
                IComponent component = Component;
                if (component != null) {
                    ISite site = component.Site;
                    if (site != null) {
                        return site.Container;
                    }
                }
                return null;
            }
        }

        protected GridEntryCollection ChildCollection{
            get {
                if (childCollection == null) {
                    childCollection = new GridEntryCollection(this, null);
                }
                return childCollection;
            }
            set {
                Debug.Assert(value == null || !Disposed, "Why are we putting new children in after we are disposed?");
                if (this.childCollection != value) {
                    if (this.childCollection != null) {
                        this.childCollection.Dispose();
                        this.childCollection = null;
                    }
                    this.childCollection = value;
                }
            }
        }

        public int ChildCount {
            get {
                if (Children != null) {
                    return Children.Count;
                }
                return 0;
            }
        }

        public virtual GridEntryCollection Children {
            get {
                if (childCollection == null && !Disposed) {
                    CreateChildren();
                }
                return childCollection;
            }
        }

        public virtual PropertyTab CurrentTab{
            get{
                if (parentPE != null) {
                    return parentPE.CurrentTab;
                }
                return null;
            }
            set{
                if (parentPE != null) {
                    parentPE.CurrentTab = value;
                }
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.DefaultChild"]/*' />
        /// <devdoc>
        /// Returns the default child GridEntry of this item.  Usually the default property
        /// of the target object.
        /// </devdoc>
        internal virtual GridEntry DefaultChild {
            get {
                return null;
            }
            set{}
        }

        internal virtual IDesignerHost DesignerHost{
            get{
                if (parentPE != null) {
                    return parentPE.DesignerHost;
                }
                return null;
            }
            set {
                if (parentPE != null) {
                    parentPE.DesignerHost = value;
                }
            }
        }

        internal bool Disposed{
            get {
                return GetFlagSet(FLAG_DISPOSED);
            }
        }

        internal virtual bool Enumerable {
            get {
                return(this.Flags & GridEntry.FLAG_ENUMERABLE) != 0;
            }
        }


        public override bool Expandable {
            get {
                bool fExpandable = GetFlagSet(FL_EXPANDABLE);

                if (fExpandable && childCollection != null && childCollection.Count > 0) {
                    return true;
                }

                if (GetFlagSet(FL_EXPANDABLE_FAILED)) {
                    return false;
                }

                if (fExpandable && (cacheItems == null || cacheItems.lastValue == null) && this.PropertyValue == null) {
                    fExpandable = false;
                }

                return fExpandable;
            }
        }

        public override bool Expanded {
            get{
                return InternalExpanded;
            }
            set {
                GridEntryHost.SetExpand(this, value);
            }
        }

        internal virtual bool ForceReadOnly {
            get {
                return (flags & FLAG_FORCE_READONLY) != 0;
            }
        }
        
         internal virtual bool InternalExpanded {
            get{
                // short circuit if we don't have children
                if (childCollection == null || childCollection.Count == 0) {
                    return false;
                }
                return GetFlagSet(FL_EXPAND);
            }
            set {
                if (!this.Expandable || value == this.InternalExpanded) {
                    return;
                }

                if (childCollection != null && childCollection.Count > 0) {
                    SetFlag(FL_EXPAND,value);
                }
                else {
                    SetFlag(FL_EXPAND,false);
                    if (value) {
                        bool fMakeSure = CreateChildren();
                        SetFlag(FL_EXPAND,fMakeSure);
                    }
                }
            }
        }

        internal virtual int Flags {
            get {
                if ((flags & FL_CHECKED) != 0) {
                    return flags;
                }

                flags |= FL_CHECKED;

                TypeConverter converter = TypeConverter;
                UITypeEditor  uiEditor  = UITypeEditor;
                object value = Instance;
                bool forceReadOnly = this.ForceReadOnly;

                if (value != null) {
                     forceReadOnly |= TypeDescriptor.GetAttributes(value).Contains(InheritanceAttribute.InheritedReadOnly);
                }
                
                if (converter.GetStandardValuesSupported(this)) {
                    flags |= GridEntry.FLAG_ENUMERABLE;
                }

                if (!forceReadOnly && converter.CanConvertFrom(this, typeof(string)) &&
                    !converter.GetStandardValuesExclusive(this)) {
                    flags |= GridEntry.FLAG_TEXT_EDITABLE;
                }
                
                bool isImmutableReadOnly = TypeDescriptor.GetAttributes(this.PropertyType)[typeof(ImmutableObjectAttribute)].Equals(ImmutableObjectAttribute.Yes);
                bool isImmutable = isImmutableReadOnly || converter.GetCreateInstanceSupported(this);
                
                if (isImmutable) {
                    flags |= GridEntry.FLAG_IMMUTABLE;
                }

                if (converter.GetPropertiesSupported(this)) {
                    flags |= GridEntry.FL_EXPANDABLE;

                    // If we're exapndable, but we don't support editing,
                    // make us read only editable so we don't paint grey.
                    //
                    if (!forceReadOnly && (flags & GridEntry.FLAG_TEXT_EDITABLE) == 0 && !isImmutableReadOnly) {
                        flags |= GridEntry.FLAG_READONLY_EDITABLE;
                    }
                }

                if (uiEditor != null) {
                    if (uiEditor.GetPaintValueSupported(this)) {
                        flags |= GridEntry.FLAG_CUSTOM_PAINT;
                    }

                    // We only allow drop-downs if the object is NOT being inherited
                    // I would really rather this not be here, but we have other places where
                    // we make read-only properties editable if they have drop downs.  Not
                    // sure this is the right thing...is it?

                    bool allowButtons = !forceReadOnly;
                    
                    if (allowButtons) {
                        switch (uiEditor.GetEditStyle(this)) {
                            case UITypeEditorEditStyle.Modal:
                                flags |= GridEntry.FLAG_CUSTOM_EDITABLE;
                                if (!isImmutable && !PropertyType.IsValueType) {
                                    flags |= GridEntry.FLAG_READONLY_EDITABLE;
                                }
                                break;
                            case UITypeEditorEditStyle.DropDown:
                                flags |= GridEntry.FLAG_DROPDOWN_EDITABLE;
                                break;
                        }
                    }
                }

                return flags;

            }
            set {
                flags = value;
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.Focus"]/*' />
        /// <devdoc>
        /// Checks if the entry is currently expanded
        /// </devdoc>
        public bool Focus {
            get{
                return this.hasFocus;
            }
            set{

                if (Disposed) {
                    return;
                }

                if (cacheItems != null) {
                    cacheItems.lastValueString = null;
                    cacheItems.useValueString = false;
                    cacheItems.useShouldSerialize = false;
                }
                
                
                this.hasFocus = value;

                // Notify accessibility applications that keyboard focus has changed.
                //
                if (value == true) {
                    int id = ((PropertyGridView)GridEntryHost).AccessibilityGetGridEntryChildID(this);
                    if (id >= 0) {
                        PropertyGridView.PropertyGridViewAccessibleObject gridAccObj = 
                            (PropertyGridView.PropertyGridViewAccessibleObject)((PropertyGridView)GridEntryHost).AccessibilityObject;
                            
                        gridAccObj.NotifyClients(AccessibleEvents.Focus, id);
                        gridAccObj.NotifyClients(AccessibleEvents.Selection, id); 
                    }
                }
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.FullLabel"]/*' />
        /// <devdoc>
        /// Returns the label including the object name, and properties.  For example, the value
        /// of the Font size property on a Button called Button1 would be "Button1.Font.Size"
        /// </devdoc>
        public string FullLabel {
            get {
                string str = null;
                if (parentPE != null) {
                    str = parentPE.FullLabel;
                }

                if (str != null) {
                    str += ".";
                }
                else {
                    str = "";
                }
                str += this.PropertyLabel;

                return str;
            }
        }
        
        public override GridItemCollection GridItems {
            get {
                if (Disposed) {
                    throw new ObjectDisposedException(SR.GetString(SR.GridItemDisposed));
                }
                
                if (IsExpandable && childCollection != null && childCollection.Count == 0) {
                    CreateChildren();
                }
                
                return this.Children;
            }
        }

        internal virtual PropertyGridView GridEntryHost{
            get{        // ACCESSOR: virtual was missing from this get
                if (parentPE != null) {
                    return parentPE.GridEntryHost;
                }
                return null;
            }
            set {
                throw new NotSupportedException();
            }
        }
        
        public override GridItemType GridItemType {
            get {
                return GridItemType.Property;
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.HasValue"]/*' />
        /// <devdoc>
        /// Returns true if this GridEntry has a value field in the right hand column.
        /// </devdoc>
        internal virtual bool HasValue {
            get {
                return true;
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.HelpKeyword"]/*' />
        /// <devdoc>
        ///     Retrieves the keyword that the VS help dynamic help window will
        ///     use when this IPE is selected.
        /// </devdoc>
        public virtual string HelpKeyword {
            get {
                string keyWord = null;

                if (parentPE != null) {
                    keyWord = parentPE.HelpKeyword;
                }
                if (keyWord == null) {
                    keyWord = String.Empty;
                }

                return keyWord;
            }
        }
        
        internal virtual string HelpKeywordInternal{
            get {
               return this.HelpKeyword;
            }
        }

        public virtual bool IsCustomPaint {
            get {
                // prevent full flag population if possible.
                if ((flags & FL_CHECKED) == 0) {
                    UITypeEditor typeEd = this.UITypeEditor;
                    if (typeEd != null) {
                        if ((this.flags & GridEntry.FLAG_CUSTOM_PAINT) != 0 || 
                            (this.flags & GridEntry.FL_NO_CUSTOM_PAINT) != 0) {
                            return(this.flags & GridEntry.FLAG_CUSTOM_PAINT) != 0;
                        }


                        if (typeEd.GetPaintValueSupported(this)) {
                            flags |= GridEntry.FLAG_CUSTOM_PAINT;
                            return true;
                        }
                        else {
                            flags |= GridEntry.FL_NO_CUSTOM_PAINT;
                            return false;
                        }    
                    }
                }
                return(this.Flags & GridEntry.FLAG_CUSTOM_PAINT) != 0;
            }
        }
        
        public virtual bool IsExpandable {
            get {
                return this.Expandable;
            }
            set {
                if (value != GetFlagSet(FL_EXPANDABLE)) {
                    SetFlag(FL_EXPANDABLE_FAILED, false);
                    SetFlag(FL_EXPANDABLE, value);
                }
            }
        }

        public virtual bool IsTextEditable {
            get {
                return this.IsValueEditable && (this.Flags & GridEntry.FLAG_TEXT_EDITABLE) != 0;
            }
        }

        public virtual bool IsValueEditable {
            get {
                return !ForceReadOnly && 0 != (Flags & (GridEntry.FLAG_DROPDOWN_EDITABLE | GridEntry.FLAG_TEXT_EDITABLE | GridEntry.FLAG_CUSTOM_EDITABLE | GridEntry.FLAG_ENUMERABLE));
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.Instance"]/*' />
        /// <devdoc>
        ///      Retrieves the component that is invoking the
        ///      method on the formatter object.  This may
        ///      return null if there is no component
        ///      responsible for the call.
        /// </devdoc>
        public virtual object Instance {
            get {
                object owner = GetValueOwner();

                if (parentPE != null && owner == null) {
                    return parentPE.Instance;
                }
                return owner;
            }
        }
        
        public override string Label {
            get {
                return this.PropertyLabel;
            }
        }
        
        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.PropertyDescriptor"]/*' />
        /// <devdoc>
        ///      Retrieves the PropertyDescriptor that is surfacing the given object/
        /// </devdoc>
        public override PropertyDescriptor PropertyDescriptor {
            get {
                return null;
            }
        }

        

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.PropertyLabelIndent"]/*' />
        /// <devdoc>
        /// Returns the pixel indent of the current GridEntry's label.
        /// </devdoc>
        internal virtual int PropertyLabelIndent {
            get {
                int borderWidth = this.GridEntryHost.GetOutlineIconSize() + OUTLINE_ICON_PADDING;
                return((propertyDepth + 1) * borderWidth) + 1;
            }
        }

        internal virtual Point GetLabelToolTipLocation(int mouseX, int mouseY) {
            return labelTipPoint;
        }

        internal virtual string LabelToolTipText {
            get {
                return this.PropertyLabel;
            }
        }

        public virtual bool NeedsDropDownButton{
            get {
                return(this.Flags & GridEntry.FLAG_DROPDOWN_EDITABLE) != 0;
            }
        }

        public virtual bool NeedsCustomEditorButton{
            get {
                return(this.Flags & GridEntry.FLAG_CUSTOM_EDITABLE) != 0 && (IsValueEditable || (Flags & GridEntry.FLAG_READONLY_EDITABLE) !=0);
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.OutlineRect"]/*' />
        /// <devdoc>
        /// Returns rect that the outline icon (+ or - or arrow) will be drawn into, relative
        /// to the upper left corner of the GridEntry.
        /// </devdoc>
        public Rectangle OutlineRect {
            get {
                if (!outlineRect.IsEmpty) {
                    return outlineRect;
                }
                PropertyGridView gridHost = this.GridEntryHost;
                Debug.Assert(gridHost != null, "No propEntryHost!");
                int outlineSize = gridHost.GetOutlineIconSize();
                int borderWidth = outlineSize + OUTLINE_ICON_PADDING;
                int left = (propertyDepth*borderWidth) + (OUTLINE_ICON_PADDING)/2;//+ 1;
                int top =  (gridHost.GetGridEntryHeight() - outlineSize)/2 - 1;  // figure out edit positioning.
                outlineRect = new Rectangle(left, top, outlineSize, outlineSize);
                return outlineRect;
            }
        }

        public virtual GridEntry ParentGridEntry{
            get {
                return this.parentPE;
            }
            set {
                Debug.Assert(value != this, "how can we be our own parent?");
                this.parentPE = value;
                if (value != null) {
                    propertyDepth = value.PropertyDepth+1;

                    // sburke, why do we do this?
                    if (this.childCollection != null) {
                        for (int i = 0; i < childCollection.Count; i++) {
                            childCollection.GetEntry(i).ParentGridEntry = this;
                        }
                    }
                }
            }
        }
        
        public override GridItem Parent {
            get {
                if (Disposed) {
                    throw new ObjectDisposedException(SR.GetString(SR.GridItemDisposed));
                }
                
                GridItem parent = this.ParentGridEntry;
                
                // don't allow walking all the way up to the parent.
                //
                //if (parent is IRootGridEntry) {
                //    return null;
                //}
                return parent;
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.PropertyCategory"]/*' />
        /// <devdoc>
        /// Returns category name of the current property
        /// </devdoc>
        public virtual string PropertyCategory {
            get {
                return CategoryAttribute.Default.Category;
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.PropertyDepth"]/*' />
        /// <devdoc>
        /// Returns "depth" of this property.  That is, how many parent's between
        /// this property and the root property.  The root property has a depth of -1.
        /// </devdoc>
        public virtual int PropertyDepth {
            get {
                return propertyDepth;
            }
        }


        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.PropertyDescription"]/*' />
        /// <devdoc>
        /// Returns the description helpstring for this GridEntry.
        /// </devdoc>
        public virtual string PropertyDescription {
            get {
                return null;
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.PropertyLabel"]/*' />
        /// <devdoc>
        /// Returns the label of this property.  Usually
        /// this is the property name.
        /// </devdoc>
        public virtual string PropertyLabel {
            get {
                return null;
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.PropertyName"]/*' />
        /// <devdoc>
        /// Returns non-localized name of this property.
        /// </devdoc>
        public virtual string PropertyName {
            get {
                return this.PropertyLabel;
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.PropertyType"]/*' />
        /// <devdoc>
        /// Returns the Type of the value of this GridEntry, or null if the value is null.
        /// </devdoc>
        public virtual Type PropertyType {
            get {
                object obj = this.PropertyValue;
                if (obj != null) {
                    return obj.GetType();
                }
                else {
                    return null;
                }
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.PropertyValue"]/*' />
        /// <devdoc>
        /// Gets or sets the value for the property that is represented
        /// by this GridEntry.
        /// </devdoc>
        public virtual object PropertyValue{
            get {
                if (cacheItems != null) {
                    return cacheItems.lastValue;
                }
                return null;
            }
            set {
            }
        }

        public virtual bool ShouldRenderReadOnly {
            get {
                return ForceReadOnly || (0 != (this.Flags & GridEntry.FLAG_RENDER_READONLY) || (!this.IsValueEditable && (0 == (this.Flags & GridEntry.FLAG_READONLY_EDITABLE))));
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.TypeConverter"]/*' />
        /// <devdoc>
        /// Returns the type converter for this entry.
        /// </devdoc>
        internal virtual TypeConverter TypeConverter {
            get {
                if (converter == null) {
                    object value = this.PropertyValue;
                    if (value == null) {
                        converter = TypeDescriptor.GetConverter(this.PropertyType);
                    }
                    else {
                        converter = TypeDescriptor.GetConverter(value);
                    }
                }
                return converter;
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.UITypeEditor"]/*' />
        /// <devdoc>
        /// Returns the type editor for this entry.  This may return null if there
        /// is no type editor.
        /// </devdoc>
        internal virtual UITypeEditor UITypeEditor {
            get {
                if (editor == null && this.PropertyType != null) {
                    editor = (UITypeEditor)TypeDescriptor.GetEditor(this.PropertyType, typeof(System.Drawing.Design.UITypeEditor));
                }

                return editor;
            }
        }
        
        public override object Value {
            get {
                return this.PropertyValue;
            }
            // note: we don't do set because of the value class semantics, etc.
        }

        internal Point ValueToolTipLocation {
            get {
                return valueTipPoint;
            }
            set{
                valueTipPoint = value;
            }
        }

        internal int VisibleChildCount {
            get{
                if (!Expanded) {
                    return 0;
                }
                int count = ChildCount;
                for (int i = 0; i < count; i++) {
                    count += ChildCollection.GetEntry(i).VisibleChildCount;
                }
                return count;
            }
        }

        
        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.AddOnLabelClick"]/*' />
        /// <devdoc>
        /// Add an event handler to be invoked when the label portion of
        /// the prop entry is clicked
        /// </devdoc>
        public virtual void AddOnLabelClick(EventHandler h) {
            AddEventHandler(EVENT_LABEL_CLICK, h);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.AddOnLabelDoubleClick"]/*' />
        /// <devdoc>
        /// Add an event handler to be invoked when the label portion of
        /// the prop entry is double
        /// </devdoc>
        public virtual void AddOnLabelDoubleClick(EventHandler h) {
            AddEventHandler(EVENT_LABEL_DBLCLICK, h);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.AddOnValueClick"]/*' />
        /// <devdoc>
        /// Add an event handler to be invoked when the value portion of
        /// the prop entry is clicked
        /// </devdoc>
        public virtual void AddOnValueClick(EventHandler h) {
            AddEventHandler(EVENT_VALUE_CLICK, h);
        }


        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.AddOnValueDoubleClick"]/*' />
        /// <devdoc>
        /// Add an event handler to be invoked when the value portion of
        /// the prop entry is double-clicked
        /// </devdoc>
        public virtual void AddOnValueDoubleClick(EventHandler h) {
            AddEventHandler(EVENT_VALUE_DBLCLICK, h);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.AddOnOutlineClick"]/*' />
        /// <devdoc>
        /// Add an event handler to be invoked when the outline icone portion of
        /// the prop entry is clicked
        /// </devdoc>
        public virtual void AddOnOutlineClick(EventHandler h) {
            AddEventHandler(EVENT_OUTLINE_CLICK, h);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.AddOnOutlineDoubleClick"]/*' />
        /// <devdoc>
        /// Add an event handler to be invoked when the outline icone portion of
        /// the prop entry is double clicked
        /// </devdoc>
        public virtual void AddOnOutlineDoubleClick(EventHandler h) {
            AddEventHandler(EVENT_OUTLINE_DBLCLICK, h);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.AddOnRecreateChildren"]/*' />
        /// <devdoc>
        /// Add an event handler to be invoked when the children grid entries are re-created.
        /// </devdoc>
        public virtual void AddOnRecreateChildren(GridEntryRecreateChildrenEventHandler h) {
            AddEventHandler(EVENT_RECREATE_CHILDREN, h);
        }

        internal void ClearCachedValues() {
               if (cacheItems != null) {
                  cacheItems.useValueString = false;
                  cacheItems.lastValue = null;
                  cacheItems.useShouldSerialize = false;
               }
               for (int i = 0; i < ChildCollection.Count; i++) {
                  ChildCollection.GetEntry(i).ClearCachedValues();
               }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.ConvertTextToValue"]/*' />
        /// <devdoc>
        /// Converts the given string of text to a value.
        /// </devdoc>
        public object ConvertTextToValue(string text) {
            if (TypeConverter.CanConvertFrom(this, typeof(string))) {
                return TypeConverter.ConvertFromString(this, text);
            }
            return text;
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.Create"]/*' />
        /// <devdoc>
        /// Create the base prop entries given an object or set of objects
        /// </devdoc>
        internal static IRootGridEntry Create(PropertyGridView view, object[] rgobjs, IServiceProvider baseProvider, IDesignerHost currentHost, PropertyTab tab, PropertySort initialSortType) {
            IRootGridEntry pe = null;

            if (rgobjs == null || rgobjs.Length == 0) {
                return null;
            }

            try {
                if (rgobjs.Length == 1) {
                    pe = new SingleSelectRootGridEntry(view, rgobjs[0], baseProvider, currentHost, tab, initialSortType);
                }
                else {
                    pe = new MultiSelectRootGridEntry(view, rgobjs, baseProvider, currentHost, tab, initialSortType);
                }
            }
            catch (Exception e) {
                //Debug.fail("Couldn't create a top-level GridEntry");
                Debug.Fail(e.ToString());
                throw e;
            }
            return pe;
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.CreateChildren"]/*' />
        /// <devdoc>
        /// Populates the children of this grid entry
        /// </devdoc>
        protected virtual bool CreateChildren() {
            return CreateChildren(false);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.CreateChildren1"]/*' />
        /// <devdoc>
        /// Populates the children of this grid entry
        /// </devdoc>
        protected virtual bool CreateChildren(bool diffOldChildren) {

            Debug.Assert(!Disposed, "Why are we creating children after we are disposed?");

            if (!GetFlagSet(FL_EXPANDABLE)) {
                if (this.childCollection != null) {
                    this.childCollection.Clear();
                }
                else {
                    this.childCollection = new GridEntryCollection(this, new GridEntry[0]);
                }
                return false;
            }


            if (!diffOldChildren && childCollection != null && childCollection.Count > 0) {
                return true;
            }


            GridEntry [] childProps    = GetPropEntries(this,
                                                        this.PropertyValue,
                                                        this.PropertyType);


            bool fExpandable = (childProps != null && childProps.Length > 0);                                            

            if (diffOldChildren && childCollection != null && childCollection.Count > 0) {
                bool same = true;
                if (childProps.Length == childCollection.Count) {
                    for (int i = 0; i < childProps.Length; i++) {
                        if (!childProps[i].NonParentEquals(childCollection[i])) {
                            same = false;
                            break;
                        }
                    }
                }
                else {
                    same = false;
                }

                if (same) {
                    return true;
                }
            }



            if (!fExpandable) {
                SetFlag(FL_EXPANDABLE_FAILED,true);
                if (this.childCollection != null) {
                    this.childCollection.Clear();
                }
                else {
                    this.childCollection = new GridEntryCollection(this, new GridEntry[0]);
                }

                if (this.InternalExpanded) {
                    this.InternalExpanded = false;
                }

            }
            else {
                if (this.childCollection != null) {
                    this.childCollection.Clear();
                    this.childCollection.AddRange(childProps);
                }
                else {
                    this.childCollection = new GridEntryCollection(this, childProps);
                }
            }
            return fExpandable;
        }

        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        protected virtual void Dispose(bool disposing) {
            // make sure we don't accidentally
            // check flags in this state...
            flags  |= FL_CHECKED;

            SetFlag(FLAG_DISPOSED, true);
            
            cacheItems = null;
            converter = null;
            editor = null;
            accessibleObject = null;

            if (disposing) {
                DisposeChildren();
            }
        }


        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.DisposeChildren"]/*' />
        /// <devdoc>
        /// Disposes the array of children
        /// </devdoc>
        public virtual void DisposeChildren() {
            if (childCollection != null) {
                childCollection.Dispose();
                childCollection = null;
            }
        }


        ~GridEntry() {
            Dispose(false);
        }


        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.EditPropertyValue"]/*' />
        /// <devdoc>
        /// Invokes the type editor for editing this item.
        /// </devdoc>
        internal virtual void EditPropertyValue(PropertyGridView iva) {
            if (UITypeEditor != null) {
                try {
                    // this is another icky part.  since edit value can push a modal loop
                    // there is a chance that this gridentry will be zombied before
                    // it returns.  make sure we're not disposed.
                    //
                    object originalValue = iva.Value;
                    object value = UITypeEditor.EditValue(this, (IServiceProvider)(ITypeDescriptorContext)this, originalValue);

                    if (Disposed) {
                        return;
                    }

                    if (value != originalValue && this.IsValueEditable) {
                        iva.Value = value;
                    }

                    RecreateChildren();
                }
                catch (Exception e) {
                    IUIService uiSvc = (IUIService)GetService(typeof(IUIService));
                    if (uiSvc != null) {
                        uiSvc.ShowError(e);
                    }
                    else {
                        MessageBox.Show(GridEntryHost, e.Message, SR.GetString(SR.PBRSErrorTitle), MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    
                }
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.Equals"]/*' />
        /// <devdoc>
        /// Tests two GridEntries for equality
        /// </devdoc>
        public override bool Equals(object obj) {

            if (NonParentEquals(obj)) {
                return((GridEntry)obj).ParentGridEntry == this.ParentGridEntry;
            }
            return false;
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.FindPropertyValue"]/*' />
        /// <devdoc>
        /// Searches for a value of a given property for a value editor user
        /// </devdoc>
        public virtual object FindPropertyValue(string propertyName, Type propertyType) {
            object owner = GetValueOwner();
            PropertyDescriptor property = TypeDescriptor.GetProperties(owner)[propertyName];
            if (property != null && property.PropertyType == propertyType) {
                return property.GetValue(owner);
            }

            if (parentPE != null)
                return parentPE.FindPropertyValue(propertyName, propertyType);

            return null;
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.GetChildIndex"]/*' />
        /// <devdoc>
        /// Returns the index of a child GridEntry
        /// </devdoc>
        internal virtual int GetChildIndex(GridEntry pe) {
            return this.Children.GetEntry(pe);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.GetComponents"]/*' />
        /// <devdoc>
        /// Gets the components that own the current value.  This is usually the value of the
        /// root entry, which is the object being browsed.  Walks up the GridEntry tree
        /// looking for an owner that is an IComponent
        /// </devdoc>
        public virtual IComponent[] GetComponents() {
            IComponent component = Component;
            if (component != null) {
                return new IComponent[] { component};
            }
            return null;
        }

        protected int GetLabelTextWidth(string labelText, Graphics g, Font f) {

            if (cacheItems == null) {
                cacheItems = new CacheItems();
            }
            else if (cacheItems.lastLabel == labelText && f.Equals(cacheItems.lastLabelFont)) {
                return cacheItems.lastLabelWidth;
            }

            cacheItems.lastLabelWidth = (int) g.MeasureString(labelText, f).Width;
            cacheItems.lastLabel = labelText;
            cacheItems.lastLabelFont = f;
            return cacheItems.lastLabelWidth;
        }

        internal int GetValueTextWidth(string valueString, Graphics g, Font f) {

            if (cacheItems == null) {
               cacheItems = new CacheItems();
            } 
            else if (cacheItems.lastValueTextWidth != -1 && cacheItems.lastValueString == valueString && f.Equals(cacheItems.lastValueFont)) {
               return cacheItems.lastValueTextWidth;
            }

            cacheItems.lastValueTextWidth = (int) g.MeasureString(valueString, f).Width;
            cacheItems.lastValueString = valueString;
            cacheItems.lastValueFont = f;
            return cacheItems.lastValueTextWidth;
        }
        //subhag (66503) To check if text contains multiple lines
        //
        internal bool GetMultipleLines(string valueString) {

            if (valueString.IndexOf('\n') > 0  ||  valueString.IndexOf('\r') > 0 )
                return true;
            else 
                return false;
        }
        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.GetValueOwner"]/*' />
        /// <devdoc>
        /// Gets the owner of the current value.  This is usually the value of the
        /// root entry, which is the object being browsed
        /// </devdoc>
        public virtual object GetValueOwner() {
            if (parentPE == null) {
                return this.PropertyValue;
            }

            return parentPE.GetChildValueOwner(this);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.GetValueOwners"]/*' />
        /// <devdoc>
        /// Gets the owners of the current value.  This is usually the value of the
        /// root entry, which is the objects being browsed for a multiselect item
        /// </devdoc>
        public virtual object[] GetValueOwners() {
            object owner = GetValueOwner();
            if (owner != null) {
                return new object[] { owner};
            }
            return null;
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.GetChildValueOwner"]/*' />
        /// <devdoc>
        /// Gets the owner of the current value.  This is usually the value of the
        /// root entry, which is the object being browsed
        /// </devdoc>
        public virtual object GetChildValueOwner(GridEntry childEntry) {

            /*// make sure this is one of our children
            int index = GetChildIndex(childEntry);

            if (index != -1){
               return this.PropertyValue;
            }


            Debug.Fail(childEntry.PropertyLabel + " is not a child of " + this.PropertyLabel);
            return null;*/
            return this.PropertyValue;
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.GetTestingInfo"]/*' />
        /// <devdoc>
        /// Returns a string with info about the currently selected GridEntry
        /// </devdoc>
        public virtual string GetTestingInfo() {
            string str = "object = (";
            string textVal = GetPropertyTextValue();
            if (textVal == null) {
                textVal = "(null)";
            }
            else {
                // make sure we clear any embedded nulls
                textVal = textVal.Replace((char)0, ' ');
            }
            Type type = this.PropertyType;
            if (type==null) {
                type = typeof(object);
            }
            str += this.FullLabel;
            str += "), property = (" + this.PropertyLabel + "," + type.AssemblyQualifiedName + "), value = " + "[" + textVal + "], expandable = " + this.Expandable.ToString() + ", readOnly = " + ShouldRenderReadOnly;;
            return str;
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.GetValueType"]/*' />
        /// <devdoc>
        /// Retrieves the type of the value for this GridEntry
        /// </devdoc>
        public virtual Type GetValueType() {
            return this.PropertyType;
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.GetPropEntries"]/*' />
        /// <devdoc>
        /// Returns the child GridEntries for this item.
        /// </devdoc>
        protected virtual GridEntry[] GetPropEntries(GridEntry peParent, object obj, Type objType) {


            // we don't want to create subprops for null objects.
            if (obj == null) {
                return null;
            }

            GridEntry[] entries = null;

            Attribute[] attributes = new Attribute[this.BrowsableAttributes.Count];
            this.BrowsableAttributes.CopyTo(attributes, 0);

            PropertyTab tab = this.CurrentTab;
            Debug.Assert(tab != null, "No current tab!");

            try {
                 
                bool forceReadOnly = this.ForceReadOnly;

                if (!forceReadOnly) {
                    ReadOnlyAttribute readOnlyAttr = (ReadOnlyAttribute)TypeDescriptor.GetAttributes(obj)[typeof(ReadOnlyAttribute)];
                    forceReadOnly = (readOnlyAttr != null && !readOnlyAttr.IsDefaultAttribute());
                }
                
                // do we want to expose sub properties?
                //
                if (TypeConverter.GetPropertiesSupported(this) || AlwaysAllowExpand) {

                    // ask the tab if we have one.
                    //
                    PropertyDescriptorCollection props = null;
                    PropertyDescriptor defProp = null;
                    if (tab != null) {
                        props = tab.GetProperties(this, obj, attributes);
                        defProp = tab.GetDefaultProperty(obj);
                    }
                    else {
                        props = TypeConverter.GetProperties(this, obj, attributes);
                        defProp = TypeDescriptor.GetDefaultProperty(obj);
                    }
                    
                    if (props == null) {
                        return null;
                    }

                    if ((this.PropertySort & PropertySort.Alphabetical) != 0) {
                        if (objType == null || !objType.IsArray) {
                            props = props.Sort(GridEntry.DisplayNameComparer);
                        }
                        
                        PropertyDescriptor[] propertyDescriptors = new PropertyDescriptor[props.Count];
                        props.CopyTo(propertyDescriptors, 0);
                        
                        props = new PropertyDescriptorCollection(SortParenProperties(propertyDescriptors));
                    }

                    if (defProp == null && props.Count > 0) {
                        defProp = props[0];
                    }

                    // if the target object is an array and nothing else has provided a set of
                    // properties to use, then expand the array.
                    //
                    if ((props == null || props.Count == 0) && objType != null && objType.IsArray && obj != null) {

                        Array objArray = (Array)obj;

                        entries = new GridEntry[objArray.Length]; 

                        for (int i = 0; i < entries.Length; i++) {
                            entries[i] = new ArrayElementGridEntry(peParent, i);
                        }
                    }
                    else {
                        // otherwise, create the proper GridEntries.
                        // 
                        bool createInstanceSupported = TypeConverter.GetCreateInstanceSupported(this);
                        entries = new GridEntry[props.Count];
                        int index = 0;

                        // loop through all the props we got and create property descriptors.
                        //
                        foreach (PropertyDescriptor pd in props) {
                            GridEntry newEntry;

                            // make sure we've got a valid property, otherwise hide it
                            //
                            bool hide = false;
                            try {
                                object owner = obj;
                                if (obj is ICustomTypeDescriptor) {
                                    owner = ((ICustomTypeDescriptor)obj).GetPropertyOwner(pd);
                                }
                                pd.GetValue(owner);
                            }
                            catch (Exception w) {
                                if (PbrsAssertPropsSwitch.Enabled) {
                                    Debug.Fail("Bad property '" + peParent.PropertyLabel + "." + pd.Name + "': " + w.ToString());
                                }
                                hide = true;
                            }

                            if (createInstanceSupported) {
                                newEntry = new ImmutablePropertyDescriptorGridEntry(peParent, pd, hide);
                            }
                            else {
                                newEntry = new PropertyDescriptorGridEntry(peParent, pd, hide);
                            }

                            if (forceReadOnly) {
                                newEntry.flags |= FLAG_FORCE_READONLY;
                            }

                            // check to see if we've come across the default item.
                            //
                            if (pd.Equals(defProp)) {
                                this.DefaultChild = newEntry;   
                            }

                            // add it to the array.
                            //
                            entries[index++] = newEntry;
                        }
                    }
                }
            }
            catch (Exception e) {
                Debug.Fail("Failed to get properties: " + e.GetType().Name + "," + e.Message + "\n" + e.StackTrace);
                //throw e;
                //Debug.fail("couldn't get properties! " + e);
            }
            return entries;
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.ResetPropertyValue"]/*' />
        /// <devdoc>
        /// Resets the current item
        /// </devdoc>
        public virtual void ResetPropertyValue() {
            NotifyValue(NOTIFY_RESET);
            Refresh();
        }

        /*
        /// <summary>
        /// Checks if the value of the current item can be modified by the user.
        /// </summary>
        /// <returns>
        /// True if the value can be modified
        /// </returns>
        public virtual bool CanSetPropertyValue() {
            return 0 != (Flags & (GridEntry.FLAG_DROPDOWN_EDITABLE | GridEntry.FLAG_TEXT_EDITABLE | GridEntry.FLAG_CUSTOM_EDITABLE | GridEntry.FLAG_ENUMERABLE));
        }
        */

        /*
        /// <summary>
        /// Returns if it's an editable item.  An example of a readonly
        /// editable item is a collection property -- the property itself
        /// can not be modified, but it's value (e.g. it's children) can, so
        /// we don't want to draw it as readonly.
        /// </summary>
        /// <returns>
        /// True if the value associated with this property (e.g. it's children) can be modified even if it's readonly.
        /// </returns>
        public virtual bool CanSetReadOnlyPropertyValue() {
            return GetFlagSet(GridEntry.FLAG_READONLY_EDITABLE);
        }
        */

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.CanResetPropertyValue"]/*' />
        /// <devdoc>
        /// Returns if the property can be reset
        /// </devdoc>
        public virtual bool CanResetPropertyValue() {
            return NotifyValue(NOTIFY_CAN_RESET);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.DoubleClickPropertyValue"]/*' />
        /// <devdoc>
        /// Called when the item is double clicked.
        /// </devdoc>
        public virtual bool DoubleClickPropertyValue() {
            return NotifyValue(NOTIFY_DBL_CLICK);
        }


        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.GetPropertyTextValue"]/*' />
        /// <devdoc>
        /// Returns the text value of this property.
        /// </devdoc>
        public virtual string GetPropertyTextValue() {
            return GetPropertyTextValue(this.PropertyValue);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.GetPropertyTextValue1"]/*' />
        /// <devdoc>
        /// Returns the text value of this property.
        /// </devdoc>
        public virtual string GetPropertyTextValue(object value) {
            string str = null;

            TypeConverter converter = TypeConverter;
            try {
                str = converter.ConvertToString(this, value);
            }
            catch (Exception t) {
                Debug.Fail("Bad Type Converter! " + t.GetType().Name + ", " + t.Message  + "," + converter.ToString(), t.ToString());
            }

            if (str == null) {
                str = String.Empty;
            }
            return str;
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.GetPropertyValueList"]/*' />
        /// <devdoc>
        /// Returns the text values of this property.
        /// </devdoc>
        public virtual object[] GetPropertyValueList() {
            ICollection values = TypeConverter.GetStandardValues(this);
            if (values != null) {
                object[] valueArray = new object[values.Count];
                values.CopyTo(valueArray, 0);
                return valueArray;
            }
            return new object[0];
        }

        public override int GetHashCode() {
            // These can be null, so workaround giving hashcode = 0 for null objects.
            object label = this.PropertyLabel;
            object type = this.PropertyType;
            UInt32 h1 = (UInt32)((label == null)  ? 0 : label.GetHashCode());
            UInt32 h2 = (UInt32)((type == null)   ? 0 : type.GetHashCode());
            UInt32 h3 = (UInt32)GetType().GetHashCode();

            return(int)(h1 ^ ((h2 << 13) | (h2 >> 19)) ^ ((h3 << 26) | (h3 >> 6)));
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.GetFlagSet"]/*' />
        /// <devdoc>
        /// Checks if a given flag is set
        /// </devdoc>
        protected virtual bool GetFlagSet(int flag) {
            return((flag & Flags) != 0);
        }

        protected Font GetFont(bool boldFont) {
            if (boldFont)
                return GridEntryHost.GetBoldFont();
            else
                return GridEntryHost.GetBaseFont();
        }

        protected IntPtr GetHfont(bool boldFont) {
            if (boldFont)
                return GridEntryHost.GetBoldHfont();
            else
                return GridEntryHost.GetBaseHfont();
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.GetService"]/*' />
        /// <devdoc>
        ///      Retrieves the requested service.  This may
        ///      return null if the requested service is not
        ///      available.
        /// </devdoc>
        public virtual object GetService(Type serviceType) {
        
            if (serviceType == typeof(GridItem)) {
                return (GridItem)this;
            }
            
            if (parentPE != null) {
                return parentPE.GetService(serviceType);
            }
            return null;
        }

        internal virtual bool NonParentEquals(object obj) {
            if (obj == this) return true;
            if (obj == null) return false;
            if (!(obj is GridEntry)) return false;
            GridEntry pe = (GridEntry)obj;

            return pe.PropertyLabel.Equals(this.PropertyLabel) &&
                   pe.PropertyType.Equals(this.PropertyType) && pe.PropertyDepth == this.PropertyDepth; 
        }


        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.PaintLabel"]/*' />
        /// <devdoc>
        /// Paints the label portion of this GridEntry into the given Graphics object.  This
        /// is called by the GridEntry host (the PropertyGridView) when this GridEntry is
        /// to be painted.
        /// </devdoc>
        public virtual void PaintLabel(System.Drawing.Graphics g, Rectangle rect, Rectangle clipRect, bool selected, bool paintFullLabel) {
            PropertyGridView gridHost = this.GridEntryHost;
            Debug.Assert(gridHost != null, "No propEntryHost");
            string strLabel = this.PropertyLabel;
            
            int borderWidth = gridHost.GetOutlineIconSize()+OUTLINE_ICON_PADDING;

            // fill the background if necessary
            Brush bkBrush = selected ? SystemBrushes.Highlight : this.GetBackgroundBrush(g);
            // if we don't have focus, paint with the line color
            if (selected && !hasFocus) {
                bkBrush = gridHost.GetLineBrush(g);
            }

            bool fBold = ((this.Flags & GridEntry.FLAG_LABEL_BOLD) != 0);
            Font font = GetFont(fBold);

            int labelWidth = GetLabelTextWidth(strLabel, g, font);

            int neededWidth = paintFullLabel ? labelWidth : 0;
            int stringX = rect.X + this.PropertyLabelIndent;
            Brush blank = bkBrush;
            if (paintFullLabel && (neededWidth >= (rect.Width-(stringX+2)))) {
                int totalWidth = stringX + neededWidth + PropertyGridView.GDIPLUS_SPACE; // 5 = extra needed to ensure text draws completely and isn't clipped.
#if PBRS_PAINT_DEBUG
                blank = Brushes.Green;
#endif

                // blank out the space we're going to use
                g.FillRectangle(blank, borderWidth-1, rect.Y, totalWidth-borderWidth+3, rect.Height);

                // draw an end line
                Pen linePen = new Pen(gridHost.GetLineColor());
                g.DrawLine(linePen, totalWidth, rect.Y, totalWidth, rect.Height);
                linePen.Dispose();

                // set the new width that we can draw into
                rect.Width = totalWidth - rect.X;
            }
            else { // Normal case -- no pseudo-tooltip for the label

#if PBRS_PAINT_DEBUG
                blank = Brushes.Red;
#endif
                // Debug.WriteLine(rect.X.ToString() +" "+ rect.Y.ToString() +" "+ rect.Width.ToString() +" "+ rect.Height.ToString());
                g.FillRectangle(blank, rect.X, rect.Y, rect.Width, rect.Height);
            }
            
            // draw the border stripe on the left
            Brush stripeBrush = gridHost.GetLineBrush(g);
            g.FillRectangle(stripeBrush, rect.X, rect.Y, borderWidth, rect.Height);
            
            Brush brush = null;
            bool disposeBrush = false;

            if (selected && hasFocus) {
                g.FillRectangle(SystemBrushes.Highlight, stringX,
                                rect.Y, rect.Width-stringX-1, rect.Height);
                brush = SystemBrushes.FromSystemColor(SystemColors.HighlightText);
            }
            
            
            int maxSpace = Math.Min(rect.Width-stringX-1, labelWidth + PropertyGridView.GDIPLUS_SPACE);
            Rectangle textRect = new Rectangle(stringX, rect.Y + 1, maxSpace, rect.Height - 1);
            if (!Rectangle.Intersect(textRect, clipRect).IsEmpty) {
            
               if (brush == null) {
                  Color brushColor;
                  if (this.ShouldRenderReadOnly) {
                    brushColor = GridEntryHost.GrayTextColor;
                  }
                  else {
                      brushColor = GridEntryHost.GetTextColor();
                  }
                  
                  brush = new SolidBrush(g.GetNearestColor(brushColor));
                  disposeBrush = true;
               }
               
               Region oldClip = g.Clip;
            
               g.SetClip(textRect);
               
               // Do actual drawing
               g.DrawString(strLabel, font, brush, textRect, stringFormat);
 #if PBRS_PAINT_DEBUG
               textRect.Width --;
               textRect.Height--;
               g.DrawRectangle(new Pen(Color.Blue), textRect);
 #endif

               if (disposeBrush) {
                   brush.Dispose();
               }
               g.SetClip(oldClip, CombineMode.Replace);
               oldClip.Dispose();   // clip is actually copied out.
   
               if (maxSpace <= labelWidth) {
                   this.labelTipPoint = new Point(stringX+2, rect.Y+1);
               }
               else {
                   this.labelTipPoint = InvalidPoint;
               }
            }

            rect.Y -= 1;
            rect.Height += 2;

            PaintOutline(g, rect);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.PaintOutline"]/*' />
        /// <devdoc>
        /// Paints the outline portion of this GridEntry into the given Graphics object.  This
        /// is called by the GridEntry host (the PropertyGridView) when this GridEntry is
        /// to be painted.
        /// </devdoc>
        public virtual void PaintOutline(System.Drawing.Graphics g, Rectangle r) {
            // draw outline box.
            if (this.Expandable) {
                bool fExpanded = this.InternalExpanded;
                Rectangle outline = this.OutlineRect;

                // make sure we're in our bounds
                outline = Rectangle.Intersect(r, outline);
                if (outline.IsEmpty) return;

                // draw border area box
                Brush b = this.GetBackgroundBrush(g);
                Pen p;
                Color penColor = GridEntryHost.GetTextColor();
                if (penColor.IsSystemColor) {
                    p = SystemPens.FromSystemColor(penColor);
                }
                else {
                    p = new Pen(penColor);
                }
                
                g.FillRectangle(b, outline);
                g.DrawRectangle(p, outline.X, outline.Y, outline.Width - 1, outline.Height - 1);

                // draw horizontal line for +/-
                int indent = 2;
                g.DrawLine(p, outline.X + indent,outline.Y + outline.Height / 2,
                           outline.X + outline.Width - indent - 1,outline.Y + outline.Height/2);

                // draw vertical line to make a +
                if (!fExpanded) {
                    g.DrawLine(p, outline.X + outline.Width/2, outline.Y + indent,
                               outline.X + outline.Width/2, outline.Y + outline.Height - indent - 1);
                }
                
                if (!penColor.IsSystemColor) {
                    p.Dispose();
                }
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.PaintValue"]/*' />
        /// <devdoc>
        /// Paints the value portion of this GridEntry into the given Graphics object.  This
        /// is called by the GridEntry host (the PropertyGridView) when this GridEntry is
        /// to be painted.
        /// </devdoc>
        public virtual void PaintValue(object val, System.Drawing.Graphics g, Rectangle rect, Rectangle clipRect, PaintValueFlags paintFlags) { 
            PropertyGridView gridHost = this.GridEntryHost;
            Debug.Assert(gridHost != null, "No propEntryHost");
            int cPaint = 0;

            Color textColor = gridHost.GetTextColor();
            if (this.ShouldRenderReadOnly) {
                textColor = GridEntryHost.GrayTextColor;
            }
            
            string strValue;
            
            if ((paintFlags & PaintValueFlags.FetchValue) != PaintValueFlags.None) {
               if (cacheItems != null && cacheItems.useValueString) {
                  strValue = cacheItems.lastValueString;
                  val = cacheItems.lastValue;
               }
               else {
                  val = this.PropertyValue;
                  strValue = GetPropertyTextValue(val);
                  if (cacheItems == null) {
                     cacheItems = new CacheItems();
                  }
                  cacheItems.lastValueString = strValue;
                  cacheItems.useValueString = true;
                  cacheItems.lastValueTextWidth = -1;
                  cacheItems.lastValueFont = null;
                  cacheItems.lastValue = val;
               }
            }
            else {
               strValue = GetPropertyTextValue(val);                  
            }

            // paint out the main rect using the default brush
            //            Brush bkBrush = selected ? SystemBrushes.Highlight : this.BackgroundBrush;
            Brush bkBrush = this.GetBackgroundBrush(g);
            Debug.Assert(bkBrush != null, "We didn't find a good background brush for PaintValue");

            if ((paintFlags & PaintValueFlags.DrawSelected) != PaintValueFlags.None) {
                bkBrush = System.Drawing.SystemBrushes.Highlight;
                textColor = SystemColors.HighlightText;
            }

            Brush blank = bkBrush;
#if PBRS_PAINT_DEBUG
            blank = Brushes.Yellow;
#endif
            //g.FillRectangle(blank, rect.X-1, rect.Y, rect.Width+1, rect.Height);
            g.FillRectangle(blank, clipRect);
            
            if (IsCustomPaint) {
                cPaint = gridHost.GetValuePaintIndent();
                Rectangle rectPaint = new Rectangle(rect.X + 1, rect.Y + 1, gridHost.GetValuePaintWidth(), gridHost.GetGridEntryHeight() - 2);
                
                if (!Rectangle.Intersect(rectPaint, clipRect).IsEmpty) {
                   UITypeEditor uie = UITypeEditor;
                   if (uie != null) {
                       uie.PaintValue(new PaintValueEventArgs(this, val, g, rectPaint));
                   }
   
                   // paint a border around the area
                   rectPaint.Width --;
                   rectPaint.Height--;
                   g.DrawRectangle(SystemPens.WindowText, rectPaint);
                }
            }

            rect.X += cPaint + gridHost.GetValueStringIndent();
            rect.Width -= cPaint + 2 * gridHost.GetValueStringIndent();

            // bold the property if we need to persist it (e.g. it's not the default value)
            bool valueModified = ((paintFlags & PaintValueFlags.CheckShouldSerialize) != PaintValueFlags.None) && ShouldSerializePropertyValue();
            
            
            if (strValue != null && strValue.Length > 0) {
                
                Font f = GetFont(valueModified);
                
                int textWidth = GetValueTextWidth(strValue, g, f);
                bool doToolTip = false;
                
                //subhag (66503) To check if text contains multiple lines
                //
                if (textWidth >= rect.Width ||  GetMultipleLines(strValue)) 
                     doToolTip = true;
                               
                if (Rectangle.Intersect(rect, clipRect).IsEmpty) {
                     return;
                }
                
                // Do actual drawing
                
                //strValue = ReplaceCRLF(strValue);
                
                
                 // AS/URT  55015
                // bump the text down 2 pixels and over 1 pixel.
                if ((paintFlags & PaintValueFlags.PaintInPlace) != PaintValueFlags.None) { 
                    rect.Offset(1, 2);
                }
                else {
                    // only go down one pixel when we're painting in the listbox
                    rect.Offset(1, 1);
                } 

                Matrix m = g.Transform;
                IntPtr hdc = g.GetHdc();
                NativeMethods.RECT lpRect = NativeMethods.RECT.FromXYWH(rect.X + (int)m.OffsetX + 2, rect.Y + (int)m.OffsetY - 1, rect.Width - 4, rect.Height);
                IntPtr hfont = GetHfont(valueModified);
                
                int oldTextColor = 0;
                int oldBkColor = 0;

                Color bkColor = ((paintFlags & PaintValueFlags.DrawSelected) != PaintValueFlags.None) ? SystemColors.Highlight : GridEntryHost.BackColor;
                
                try {
                    oldTextColor = SafeNativeMethods.SetTextColor(new HandleRef(g, hdc), SafeNativeMethods.RGBToCOLORREF(textColor.ToArgb()));
                    oldBkColor = SafeNativeMethods.SetBkColor(new HandleRef(g, hdc), SafeNativeMethods.RGBToCOLORREF(bkColor.ToArgb()));
                    hfont = SafeNativeMethods.SelectObject(new HandleRef(g, hdc), new HandleRef(null, hfont));
                    int format = NativeMethods.DT_EDITCONTROL | NativeMethods.DT_EXPANDTABS | NativeMethods.DT_NOCLIP | NativeMethods.DT_SINGLELINE | NativeMethods.DT_NOPREFIX;
                    if (gridHost.DrawValuesRightToLeft) {
                        format |= NativeMethods.DT_RIGHT | NativeMethods.DT_RTLREADING;
                    }

                    //  asurt 78494 need to multiply the value if we're on an ANSI platform
                    //

                    if (Marshal.SystemDefaultCharSize == 1) {
                        int bytesNeeded = UnsafeNativeMethods.WideCharToMultiByte(0 /*CP_ACP*/, 0, strValue, strValue.Length, null, 0, IntPtr.Zero, IntPtr.Zero);

                        byte[] strBytes = new byte[bytesNeeded];
                        UnsafeNativeMethods.WideCharToMultiByte(0 /*CP_ACP*/, 0, strValue, strValue.Length, strBytes, strBytes.Length, IntPtr.Zero, IntPtr.Zero);

                        SafeNativeMethods.DrawText(new HandleRef(g, hdc), strBytes, strBytes.Length, ref lpRect, format);
                    }
                    else {
                        SafeNativeMethods.DrawText(new HandleRef(g, hdc), strValue, strValue.Length, ref lpRect, format);
                    }

                
                }
                finally {
                    SafeNativeMethods.SetTextColor(new HandleRef(g, hdc), oldTextColor);
                    SafeNativeMethods.SetBkColor(new HandleRef(g, hdc), oldBkColor);
                    hfont = SafeNativeMethods.SelectObject(new HandleRef(g, hdc), new HandleRef(null, hfont));
                    g.ReleaseHdcInternal(hdc);
                }
                
                
                #if PBRS_PAINT_DEBUG
                    rect.Width --;
                    rect.Height--;
                    g.DrawRectangle(new Pen(Color.Purple), rect);
               #endif
               
                if (doToolTip) {
                    this.ValueToolTipLocation = new Point(rect.X+2, rect.Y-1);
                }
                else {
                     this.ValueToolTipLocation = InvalidPoint;
                }
            }

            return;
        }

        public virtual bool OnComponentChanging() {
            if (ComponentChangeService != null) {
                try {
                    ComponentChangeService.OnComponentChanging(GetValueOwner(), PropertyDescriptor);
                }
                catch (CheckoutException coEx) {
                    if (coEx == CheckoutException.Canceled) {
                        return false;
                    }
                    throw coEx;
                }
            }
            return true;
        }

        public virtual void OnComponentChanged() {
            if (ComponentChangeService != null) {
                ComponentChangeService.OnComponentChanged(GetValueOwner(), PropertyDescriptor, null, null);
            }
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.OnLabelClick"]/*' />
        /// <devdoc>
        /// Called when the label portion of this GridEntry is clicked.
        /// Default implmentation fired the event to any listeners, so be sure
        /// to call base.OnLabelClick(e) if this is overrideen.
        /// </devdoc>
        protected virtual void OnLabelClick(EventArgs e) {
            RaiseEvent(EVENT_LABEL_CLICK, e);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.OnLabelDoubleClick"]/*' />
        /// <devdoc>
        /// Called when the label portion of this GridEntry is double-clicked.
        /// Default implmentation fired the event to any listeners, so be sure
        /// to call base.OnLabelDoubleClick(e) if this is overrideen.
        /// </devdoc>
        protected virtual void         OnLabelDoubleClick(EventArgs e) {
            RaiseEvent(EVENT_LABEL_DBLCLICK, e);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.OnMouseClick"]/*' />
        /// <devdoc>
        /// Called when the GridEntry is clicked.
        /// </devdoc>
        public virtual bool OnMouseClick(int x, int y, int count, MouseButtons button) {
            // where are we at?
            PropertyGridView gridHost = this.GridEntryHost;
            Debug.Assert(gridHost != null, "No prop entry host!");

            // make sure it's the left button
            if ((button & MouseButtons.Left) != MouseButtons.Left) {
                return false;
            }


            int labelWidth  = gridHost.GetLabelWidth();

            // are we in the label?
            if (x >= 0 && x <= labelWidth) {

                // are we on the outline?
                if (Expandable) {
                    Rectangle outlineRect = OutlineRect;
                    if (outlineRect.Contains(x, y)) {
                        if (count % 2 == 0) {
                            OnOutlineDoubleClick(EventArgs.Empty);
                        }
                        else {
                            OnOutlineClick(EventArgs.Empty);
                        }
                        return true;
                    }
                }

                if (count % 2 == 0) {
                    OnLabelDoubleClick(EventArgs.Empty);
                }
                else {
                    OnLabelClick(EventArgs.Empty);
                }
                return true;
            }

            // are we in the value?
            labelWidth += gridHost.GetSplitterWidth();
            if (x >= labelWidth  && x <= labelWidth + gridHost.GetValueWidth()) {
                if (count % 2 == 0) {
                    OnValueDoubleClick(EventArgs.Empty);
                }
                else {
                    OnValueClick(EventArgs.Empty);
                }
                return true;
            }
            return false;
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.OnOutlineClick"]/*' />
        /// <devdoc>
        /// Called when the outline icon portion of this GridEntry is clicked.
        /// Default implmentation fired the event to any listeners, so be sure
        /// to call base.OnOutlineClick(e) if this is overrideen.
        /// </devdoc>
        protected virtual void OnOutlineClick(EventArgs e) {
            RaiseEvent(EVENT_OUTLINE_CLICK, e);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.OnOutlineDoubleClick"]/*' />
        /// <devdoc>
        /// Called when the outline icon portion of this GridEntry is double-clicked.
        /// Default implmentation fired the event to any listeners, so be sure
        /// to call base.OnOutlineDoubleClick(e) if this is overrideen.
        /// </devdoc>
        protected virtual void OnOutlineDoubleClick(EventArgs e) {
            RaiseEvent(EVENT_OUTLINE_DBLCLICK, e);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.OnRecreateChildren"]/*' />
        /// <devdoc>
        /// Called when RecreateChildren is called.
        /// Default implmentation fired the event to any listeners, so be sure
        /// to call base.OnOutlineDoubleClick(e) if this is overrideen.
        /// </devdoc>
        protected virtual void OnRecreateChildren(GridEntryRecreateChildrenEventArgs e) {
            Delegate handler = GetEventHandler(EVENT_RECREATE_CHILDREN);
            if (handler != null) ((GridEntryRecreateChildrenEventHandler)handler)(this, e);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.OnValueClick"]/*' />
        /// <devdoc>
        /// Called when the value portion of this GridEntry is clicked.
        /// Default implmentation fired the event to any listeners, so be sure
        /// to call base.OnValueClick(e) if this is overrideen.
        /// </devdoc>
        protected virtual void OnValueClick(EventArgs e) {
            RaiseEvent(EVENT_VALUE_CLICK, e);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.OnValueDoubleClick"]/*' />
        /// <devdoc>
        /// Called when the value portion of this GridEntry is clicked.
        /// Default implmentation fired the event to any listeners, so be sure
        /// to call base.OnValueDoubleClick(e) if this is overrideen.
        /// </devdoc>
        protected virtual void OnValueDoubleClick(EventArgs e) {
            RaiseEvent(EVENT_VALUE_DBLCLICK, e);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.PaintValue1"]/*' />
        /// <devdoc>
        /// Called to paint the current value of this GridEntry.
        /// </devdoc>
        public void PaintValue(System.Drawing.Graphics g, Rectangle rect) {
            PaintValue(null, g,rect, rect, PaintValueFlags.CheckShouldSerialize | PaintValueFlags.FetchValue);
        }
        
        internal bool OnValueReturnKey() {
            return NotifyValue(NOTIFY_RETURN);
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.SetFlag"]/*' />
        /// <devdoc>
        /// Sets the specified flag
        /// </devdoc>
        protected virtual void SetFlag(int flag, bool fVal) {
            SetFlag(flag, (fVal ? flag : 0));
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.SetFlag1"]/*' />
        /// <devdoc>
        /// Sets the default child of this entry, given a valid value mask.
        /// </devdoc>
        protected virtual void SetFlag(int flag_valid, int flag, bool fVal) {
            SetFlag(flag_valid | flag,
                    flag_valid | (fVal ? flag : 0));
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.SetFlag2"]/*' />
        /// <devdoc>
        /// Sets the value of a flag
        /// </devdoc>
        protected virtual void SetFlag(int flag, int val) {
            Flags = (Flags & ~(flag)) | val;
        }
        
        public override bool Select() {
            if (Disposed) {
                return false;
            }
            
            try {
                GridEntryHost.SelectedGridEntry = this;
                return true;
            }
            catch {
            }
            return false;
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.ShouldSerializePropertyValue"]/*' />
        /// <devdoc>
        /// Checks if this value should be persisited.
        /// </devdoc>
        internal virtual bool ShouldSerializePropertyValue() {
            
            if (cacheItems != null) {
                if (cacheItems.useShouldSerialize) {
                     return cacheItems.lastShouldSerialize;
                }
                else {
                    cacheItems.lastShouldSerialize = NotifyValue(NOTIFY_SHOULD_PERSIST);
                    cacheItems.useShouldSerialize = true;
                }
            }
            else {
               cacheItems = new CacheItems();
               cacheItems.lastShouldSerialize = NotifyValue(NOTIFY_SHOULD_PERSIST);
               cacheItems.useShouldSerialize = true;
            }
            return cacheItems.lastShouldSerialize;
        }

        private PropertyDescriptor[] SortParenProperties(PropertyDescriptor[] props) {

            PropertyDescriptor[] newProps = null;
            int newPos = 0;


            // first scan the list and move any parentesized properties to the front.
            for (int i = 0; i < props.Length; i++) {
                if (((ParenthesizePropertyNameAttribute)props[i].Attributes[typeof(ParenthesizePropertyNameAttribute)]).NeedParenthesis) {
                    if (newProps == null) {
                        newProps = new PropertyDescriptor[props.Length];
                    }
                    newProps[newPos++] = props[i];
                    props[i] = null;
                }
            }


            // second pass, copy any that didn't have the parens.
            if (newPos > 0) {
                for (int i = 0; i < props.Length; i++) {
                    if (props[i] != null) {
                        newProps[newPos++] = props[i];
                    }
                } 
                props = newProps;
            }
            return props;
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.NotifyValueGivenParent"]/*' />
        /// <devdoc>
        /// Sends a notify message to this GridEntry, and returns the success result
        /// </devdoc>
        internal virtual bool NotifyValueGivenParent(object obj, int type) {
            return false;
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.NotifyChildValue"]/*' />
        /// <devdoc>
        /// Sends a notify message to the child GridEntry, and returns the success result
        /// </devdoc>
        internal virtual bool NotifyChildValue(GridEntry pe, int type) {
            
            return pe.NotifyValueGivenParent(pe.GetValueOwner(),type);
        }

        internal virtual bool NotifyValue(int type) {
            // KILLME, SBurke, more spagetti
            return parentPE.NotifyChildValue(this, type);
        }

        internal void RecreateChildren() {
            RecreateChildren(-1);
        }
        
        internal void RecreateChildren(int oldCount) {
        
            // cause the flags to be rebuilt as well...
            bool wasExpanded = this.InternalExpanded || oldCount > 0;
            
            if (oldCount == -1) {
                oldCount = this.VisibleChildCount;
            }
            
            ResetState();
            if (oldCount == 0) {
                return;
            }
            
            foreach(GridEntry child in ChildCollection) {
                child.RecreateChildren();
            }
            
            DisposeChildren();
            this.InternalExpanded = wasExpanded;
            OnRecreateChildren(new GridEntryRecreateChildrenEventArgs(oldCount, VisibleChildCount));
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.Refresh"]/*' />
        /// <devdoc>
        /// Refresh the current GridEntry's value and it's children
        /// </devdoc>
        public virtual void Refresh() {

            Type type = this.PropertyType;
            if (type != null && type.IsArray) {
                CreateChildren(true);
            }

            if (this.childCollection != null) {
            
                // check to see if the value has changed.
                //
                if (this.InternalExpanded && cacheItems != null && cacheItems.lastValue != null && cacheItems.lastValue != this.PropertyValue) {
                    ClearCachedValues();
                    RecreateChildren();
                    return;
                }
                else if (this.InternalExpanded) {
                    // otherwise just do a refresh.
                    IEnumerator childEnum = childCollection.GetEnumerator();
                    while (childEnum.MoveNext()) {
                        object o = childEnum.Current;
                        Debug.Assert(o != null, "Collection contains a null element.  But how? Garbage collector hole?  GDI+ corrupting memory?");
                        GridEntry e = (GridEntry) o;
                        e.Refresh();
                    }
                }
                else {
                    DisposeChildren();
                }
            }

            ClearCachedValues();
        }

        public virtual void         RemoveOnLabelClick(EventHandler h) {
            RemoveEventHandler(EVENT_LABEL_CLICK, h);
        }
        public virtual void         RemoveOnLabelDoubleClick(EventHandler h) {
            RemoveEventHandler(EVENT_LABEL_DBLCLICK, h);
        }

        public virtual void         RemoveOnValueClick(EventHandler h) {
            RemoveEventHandler(EVENT_VALUE_CLICK, h);
        }

        public virtual void         RemoveOnValueDoubleClick(EventHandler h) {
            RemoveEventHandler(EVENT_VALUE_DBLCLICK, h);
        }

        public virtual void         RemoveOnOutlineClick(EventHandler h) {
            RemoveEventHandler(EVENT_OUTLINE_CLICK, h);
        }

        public virtual void         RemoveOnOutlineDoubleClick(EventHandler h) {
            RemoveEventHandler(EVENT_OUTLINE_DBLCLICK, h);
        }

        public virtual void         RemoveOnRecreateChildren(GridEntryRecreateChildrenEventHandler h) {
            RemoveEventHandler(EVENT_RECREATE_CHILDREN, h);
        }

        private string ReplaceCRLF(string str) {
            str = str.Replace('\r', (char)1);
            str = str.Replace('\n', (char)1);
            return str;
        }
        
        protected void ResetState() {
            this.Flags = 0;
            ClearCachedValues();
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.SetPropertyTextValue"]/*' />
        /// <devdoc>
        /// Sets the value of this GridEntry from text
        /// </devdoc>
        public virtual bool SetPropertyTextValue(string str) {
            bool fChildrenPrior = (childCollection != null && childCollection.Count > 0);
            this.PropertyValue = ConvertTextToValue(str);
            CreateChildren();
            bool fChildrenAfter = (childCollection != null && childCollection.Count > 0);
            return(fChildrenPrior != fChildrenAfter);
        }

        public override string ToString() {
            return GetType().FullName + " " + this.PropertyLabel;
        }



#if !DONT_SUPPORT_ADD_EVENT_HANDLER
        private EventEntry eventList;

        protected virtual void AddEventHandler(object key, Delegate handler) {
            lock(this) {
                if (handler == null) return;
                for (EventEntry e = eventList; e != null; e = e.next) {
                    if (e.key == key) {
                        e.handler = Delegate.Combine(e.handler, handler);
                        return;
                    }
                }
                eventList = new EventEntry(eventList, key, handler);
            }
        }

        protected virtual void RaiseEvent(object key, EventArgs e) {
            Delegate handler = GetEventHandler(key);
            if (handler != null) ((EventHandler)handler).Invoke(this, e);
        }

        protected virtual Delegate GetEventHandler(object key) {
            lock(this) {
                for (EventEntry e = eventList; e != null; e = e.next) {
                    if (e.key == key) return e.handler;
                }
                return null;
            }
        }

        protected virtual void RemoveEventHandler(object key, Delegate handler) {
            lock(this) {
                if (handler == null) return;
                for (EventEntry e = eventList, prev = null; e != null; prev = e, e = e.next) {
                    if (e.key == key) {
                        e.handler = Delegate.Remove(e.handler, handler);
                        if (e.handler == null) {
                            if (prev == null) {
                                eventList = e.next;
                            }
                            else {
                                prev.next = e.next;
                            }
                        }
                        return;
                    }
                }
            }
        }

        protected virtual void RemoveEventHandlers() {
            eventList = null;
        }

        /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.EventEntry"]/*' />
        /// <devdoc>
        /// </devdoc>
        private sealed class EventEntry {
            internal EventEntry next;
            internal object key;
            internal Delegate handler;

            internal EventEntry(EventEntry next, object key, Delegate handler) {
                this.next = next;
                this.key = key;
                this.handler = handler;
            }
        }
#endif

        [ComVisible(true)]
        public class GridEntryAccessibleObject : AccessibleObject {

            GridEntry owner = null;
            private delegate void SelectDelegate(AccessibleSelection flags);

            public GridEntryAccessibleObject(GridEntry owner) : base() {
                Debug.Assert(owner != null, "GridEntryAccessibleObject must have a valid owner GridEntry");
                this.owner = owner;
            }

            public override Rectangle Bounds {
                get {
                    return PropertyGridView.AccessibilityGetGridEntryBounds(owner);
                }
            }

            public override string Description {
                get {
                    return owner.PropertyDescription;
                }
            }

            public override string Name {
                get {
                    return owner.PropertyLabel;
                }
            }

            public override AccessibleObject Parent {
                get {
                    return((Control)this.owner.GridEntryHost).AccessibilityObject;
                }
            }

            private PropertyGridView PropertyGridView {
                get {
                    return(PropertyGridView)((PropertyGridView.PropertyGridViewAccessibleObject)Parent).Owner;
                }
            }

            public override AccessibleRole Role {
                get {
                    return AccessibleRole.Row;
                }
            }

            public override AccessibleStates State {
                get {
                    AccessibleStates state = AccessibleStates.Selectable | AccessibleStates.Focusable;

                    // Determine focus
                    //
                    if (owner.Focus) {
                        state |= AccessibleStates.Focused;
                    }

                    // Determine selected
                    //
                    Debug.Assert(Parent != null, "GridEntry AO does not have a parent AO");
                    PropertyGridView.PropertyGridViewAccessibleObject parent = (PropertyGridView.PropertyGridViewAccessibleObject)Parent;
                    if (parent.GetSelected() == this) {
                        state |= AccessibleStates.Selected;
                    }
                    
                    // Determine expanded/collapsed state
                    //
                    if (owner.Expandable) {
                        if (owner.Expanded) {
                            state |= AccessibleStates.Expanded;
                        }
                        else {
                            state |= AccessibleStates.Collapsed;
                        }
                    }

                    return state;
                }
            }

            internal override Control MarshalingControl {
                get {
                    return this.owner.GridEntryHost as Control;
                }
            }

            public override string Value {
                get {
                    return owner.GetPropertyTextValue();
                }
                set {
                    owner.SetPropertyTextValue(value);
                }                
            }

            /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.GridEntryAccessibleObject.GetFocused"]/*' />
            /// <devdoc>
            ///      Returns the currently focused child, if any.
            ///      Returns this if the object itself is focused.
            /// </devdoc>
            public override AccessibleObject GetFocused() {

                if (owner.Focus) {
                    return this;
                }
                else {
                    return null;
                }
            }


            /// <include file='doc\GridEntry.uex' path='docs/doc[@for="GridEntry.GridEntryAccessibleObject.Navigate"]/*' />
            /// <devdoc>
            ///      Navigate to the next or previous grid entry.
            /// </devdoc>
            public override AccessibleObject Navigate(AccessibleNavigation navdir) {

                PropertyGridView.PropertyGridViewAccessibleObject parent =
                (PropertyGridView.PropertyGridViewAccessibleObject)Parent;

                switch (navdir) {
                    case AccessibleNavigation.Down:
                    case AccessibleNavigation.Right:
                    case AccessibleNavigation.Next:
                        return parent.Next(this.owner);

                    case AccessibleNavigation.Up:
                    case AccessibleNavigation.Left:
                    case AccessibleNavigation.Previous:
                        return parent.Previous(this.owner);

                    case AccessibleNavigation.FirstChild:
                    case AccessibleNavigation.LastChild:
                        // Fall through and return null,
                        // as this object has no children.
                        break;
                }

                return null;

            }
            public override void Select(AccessibleSelection flags) {

                // vs  77963 -- make sure we're on the right thread.
                //
                if (PropertyGridView.InvokeRequired) {
                    PropertyGridView.Invoke(new SelectDelegate(this.Select), new object[]{flags});
                    return;
                }

                // Focus the PropertyGridView window
                //
                if ( (flags & AccessibleSelection.TakeFocus) == AccessibleSelection.TakeFocus) {
                    bool focused = PropertyGridView.FocusInternal();
                }

                // Select the grid entry
                //
                if ( (flags & AccessibleSelection.TakeSelection) == AccessibleSelection.TakeSelection) {
                    PropertyGridView.AccessibilitySelect(this.owner);
                }
            }

        }

        public class DisplayNameSortComparer : IComparer {
            public int Compare(object left, object right) {
		// review: (davidgut) Is CurrentCulture correct here?  This was already reviewed as invariant...
                return String.Compare(((PropertyDescriptor)left).DisplayName, ((PropertyDescriptor)right).DisplayName, true, CultureInfo.CurrentCulture);
            }
        }
    }

    internal class AttributeTypeSorter : IComparer{

        private static IDictionary typeIds;

        private static string GetTypeIdString(Attribute a) {

            string result;
            object typeId = a.TypeId;


            if (typeId == null) {
                Debug.Fail("Attribute '" + a.GetType().FullName + "' does not have a typeid."); 
                return "";
            }

            if (typeIds == null) {
                typeIds = new Hashtable();
                result = null;
            }
            else {
                result = typeIds[typeId] as string;
            }

            if (result == null) {
                result = typeId.ToString();
                typeIds[typeId] = result;
            }
            return result;
        }

        public int Compare(object obj1, object obj2) {
            Attribute a1 = obj1 as Attribute;
            Attribute a2 = obj2 as Attribute;
        
            if (a1 == null && a2 == null) {
                return 0;
            }
            else if (a1 == null) {
                return -1;
            }
            else if (a2 == null) {
                return 1;
            }
            return String.Compare(AttributeTypeSorter.GetTypeIdString(a1), AttributeTypeSorter.GetTypeIdString(a2), false, CultureInfo.InvariantCulture);
        }
    }
    
    internal delegate void GridEntryRecreateChildrenEventHandler(object sender, GridEntryRecreateChildrenEventArgs rce);
    
    internal class GridEntryRecreateChildrenEventArgs : EventArgs {
        public readonly int OldChildCount;
        public readonly int NewChildCount;
        
        public GridEntryRecreateChildrenEventArgs(int oldCount, int newCount) {
            this.OldChildCount = oldCount;
            this.NewChildCount = newCount;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\documentxpathnavigator.cs ===
//------------------------------------------------------------------------------
// <copyright file="DocumentXPathNavigator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml {
    using System;
    using System.Collections;
    using System.Text;
    using System.Xml.XPath;
    using System.Diagnostics;

    internal sealed class DocumentXPathNavigator: XPathNavigator, IHasXmlNode {
        private XmlNode     _curNode;           //pointer to remember the current node position
        private XmlElement  _parentOfNS;        //parent of the current namespace node -- it should be null if _curNode is not a namespace node
        private XmlDocument _doc;              //pointer to remember the ownerDocument
        private int         _attrInd;           //index of the current attribute in the attribute collection _attrs; only works when _curNode is an attribute        
        private XmlAttributeCollection  _attrs; //AttributeCollection that contains the current attribute, could be used to access next attribute fast when used together with _attrInd
                                                //The values of the above 2 vars doesn't count when _curNode is not an attribute
                                                //Since user can only move to attribute by calling MoveToFirstAttribute() or MoveToAttribute(name),
                                                //  if we make sure these two vars get reset inside these two functions when they succeeded, the continuing using them
                                                //  should be safe.
                                                //they are shared by MoveToAttribute() function set and MoveToNamespace() function set.

        XmlAttribute attrXmlNS;  //Used for "Xml" namespace attribute which should be present on all nodes.
        internal DocumentXPathNavigator( XmlNode node ) {
            Debug.Assert( ( (int)(node.XPNodeType) ) != -1 );
            _curNode = node;
            _doc = (_curNode.NodeType == XmlNodeType.Document) ? (XmlDocument)_curNode : _curNode.OwnerDocument;
            _attrInd = -1;
            attrXmlNS = _doc.CreateAttribute( "xmlns", "xml", XmlDocument.strReservedXmlns );
            attrXmlNS.Value = "http://www.w3.org/XML/1998/namespace";
        }

        private void SetCurrentPosition( DocumentXPathNavigator other ) {
            this._curNode = other.CurNode;
            //Debug.Assert( _curNode.NodeType == XmlNodeType.Document || _doc == _curNode.OwnerDocument );
            this._doc = other.Document;
            //this._root = other.Root;
            this._attrInd = other.CurAttrInd;
            this._attrs = other._attrs;
            this._parentOfNS = other.ParentOfNS;
            this.attrXmlNS = other.attrXmlNS; 
        }
        
        private DocumentXPathNavigator( DocumentXPathNavigator other ) {
            SetCurrentPosition(other);
        }
        
        public override XPathNavigator Clone(){
            return new DocumentXPathNavigator( this );
        }

        //following properties exposed as internal needed by MoveTo() and IsSamePosition() functions
        internal XmlNode CurNode { get { return this._curNode; } }        
        internal XmlElement ParentOfNS { get {return this._parentOfNS; } }
        internal XmlDocument Document { get { return this._doc; } }   
        internal int    CurAttrInd { get { return this._attrInd; } }        
        internal XmlAttributeCollection Attributes { get { return this._attrs; } }

        internal void SetCurNode( XmlNode node ) {
            // We can only set nodes that will not invalidate the cached member vars of DocumentXPathNavigator
            Debug.Assert( node.NodeType != XmlNodeType.Attribute );
            // Make sure we are in a state in which we can change the _curNode (i.e. there is no extra state kept in members that is associated w/ the _curNode)
            Debug.Assert( this._curNode.NodeType != XmlNodeType.Attribute );
            _curNode = node;
        }


        //the function just to get the next sibling node considering XmlEntityReference node is transparent
        private static XmlNode GetXPNextSibling( XmlNode node ) {
            Debug.Assert( node != null );

            XmlNode nextSibling = null;
            do {
                nextSibling = node.NextSibling;
                if ( nextSibling == null ) {
                    // If the node is the last sibling, but it's direct parent is an EntRef node, consider the siblings of
                    // the EntRef node as the siblings of the node
                    XmlNode parent = node.ParentNode;
                    if ( parent != null && parent.NodeType == XmlNodeType.EntityReference ) {
                        node = parent;
                        continue;
                    }
                    return null;
                }
                break;
            } while ( true );

            Debug.Assert( nextSibling != null );
            do {
                // Check for EntRef nodes - if it is EntRef node then drill in
                if ( nextSibling.NodeType == XmlNodeType.EntityReference ) {
                    nextSibling = nextSibling.FirstChild;
                    // Each ent-ref should have at least one child
                    Debug.Assert( nextSibling != null );
                    continue;
                }
                return nextSibling;
            } while ( true );
        }
        
        private static XmlNode GetXPPreviousSibling( XmlNode node ) {
            Debug.Assert( node != null );
            XmlNode prevSibling = null;

            do {
                prevSibling = node.PreviousSibling;
                if ( prevSibling == null ) {
                    XmlNode parent = node.ParentNode;
                    if ( parent != null && parent.NodeType == XmlNodeType.EntityReference ) {
                        node = parent;
                        continue;
                    }
                    return null;
                }
                break;
            } while ( true );

            Debug.Assert( prevSibling != null );
            do {
                // Check for EntRef nodes - if the prevSibling is an EntRef then use the EntRef's LastChild node
                if ( prevSibling.NodeType == XmlNodeType.EntityReference ) {
                    prevSibling = prevSibling.LastChild;
                    // Each EntRef should have at least one child
                    Debug.Assert( prevSibling != null );
                    continue;
                }

                return prevSibling;
            } while ( true );
        }

        private XmlNode GetRootNode( XmlNode node ) {
            XmlNode root = node;
            XmlNode parent = null; 
            //The only chance that there will be namespace node or attribute node present along the path is when
            // the currentNode is namespace/attribute node. This is because namespace/attribute nodes don't have children concept
            // in XPath model.
            if ( node.XPNodeType == XPathNodeType.Namespace ) {
                parent = this._parentOfNS;
                root = parent;
            }
            else if ( node.XPNodeType == XPathNodeType.Attribute ) {
                parent = ((XmlAttribute)node).OwnerElement;
                root = parent;
            }
            parent = root.ParentNode;
            while ( parent != null ) {
                Debug.Assert( parent.NodeType != XmlNodeType.Attribute );
                root = parent;
                parent = parent.ParentNode;
            }
            return root;
        }

        //Convert will deal with nodeType as Attribute or Namespace nodes
        public override XPathNodeType NodeType { 
            get { 
                int xpnt = (int)(_curNode.XPNodeType);
                Debug.Assert( xpnt != -1 );
                return (XPathNodeType)(_curNode.XPNodeType); 
            } 
        }

        public override string LocalName { get { return _curNode.XPLocalName; } }

        public override string NamespaceURI { 
            get { 
                if ( _curNode.XPNodeType == XPathNodeType.Namespace )
                    return string.Empty;
                return _curNode.NamespaceURI; 
            } 
        }

        public override string Name { 
            get {
                switch ( _curNode.XPNodeType ) {
                    case XPathNodeType.Element:
                    case XPathNodeType.Attribute:
                        return _curNode.Name;
                    case XPathNodeType.Namespace:
                        if( _curNode.LocalName != "xmlns" )
                           return _curNode.LocalName;
                        else
                            return "";
                    case XPathNodeType.ProcessingInstruction:
                        return _curNode.Name;
                    default:
                        return string.Empty;
                }
            } 
        }

        public override string Prefix { 
            get { 
                if( _curNode.XPNodeType != XPathNodeType.Namespace )
                    return _curNode.Prefix;                 
                else
                    return "";
            }
        }

        public override string Value { 
            get { 
                if ( _curNode.NodeType == XmlNodeType.Element )
                    return _curNode.InnerText; 
                if ( _curNode.NodeType == XmlNodeType.Document ) {
                    XmlElement rootElem = ((XmlDocument)_curNode).DocumentElement;
                    if ( rootElem != null )
                        return rootElem.InnerText; 
                    return string.Empty;
                }
                if ( XmlDocument.IsTextNode(_curNode.NodeType) ) {
                    //need to concatenate the text nodes
                    XmlNode node = _curNode;
                    string str = "";
                    do {
                        str += node.Value;                        
                        node = DocumentXPathNavigator.GetXPNextSibling(node);
                    } while ( node != null && XmlDocument.IsTextNode( node.NodeType ) );
                    return str;
                }
                return _curNode.Value;
            } 
        }

        public override String BaseURI { get { return _curNode.BaseURI; } }

        public override String XmlLang { get { return _curNode.XmlLang; } }
        
        public override bool IsEmptyElement { 
            get {
                if ( _curNode.NodeType == XmlNodeType.Element )
                    return ((XmlElement)_curNode).IsEmpty;
                return false;
            } 
        }

        public override XmlNameTable NameTable { get { return _doc.NameTable; } }

        // Attributes
        public override bool HasAttributes { 
            get {
                //need to take out the namespace decl attributes out of count
                if ( _curNode.NodeType == XmlNodeType.Element ) {
                    foreach ( XmlAttribute attr in _curNode.Attributes ) {
                        if ( ! Ref.Equal(attr.NamespaceURI, XmlDocument.strReservedXmlns) )
                            return true;
                    }
                }
                return false;
            } 
        }

        public override string GetAttribute( string localName, string namespaceURI ) {
            return _curNode.GetXPAttribute( localName, namespaceURI );
        }

        public override string GetNamespace(string name) {
            //we are checking the namespace nodes backwards comparing its normal order in DOM tree
            if ( name.Length == 3 &&  name == "xml" )
                return XmlDocument.strReservedXml;
            if ( name.Length == 5 && name == "xmlns" )
                return XmlDocument.strReservedXmlns;
            if ( name.Length == 0 )
                name = "xmlns";
            XmlNode node = _curNode;
            XmlNodeType nt = node.NodeType;
            XmlAttribute attr = null;
            while ( node != null ) {
                //first identify an element node in the ancestor + itself
                while ( node != null && ( ( nt = node.NodeType ) != XmlNodeType.Element ) ) {
                    if ( nt == XmlNodeType.Attribute )
                        node = ((XmlAttribute)node).OwnerElement;
                    else
                        node = node.ParentNode;
                }
                //found one -- inside if
                if ( node != null ) {
                    //must be element node
                    attr = ((XmlElement)node).GetAttributeNode(name, XmlDocument.strReservedXmlns);
                    if ( attr != null )
                        return attr.Value;
                    //didn't find it, try the next parentnode
                    node = node.ParentNode;    
                }                
            }
            //nothing happens, then return string.empty.
            return string.Empty;
        }

        public override bool MoveToNamespace(string name) {
            _parentOfNS = _curNode as XmlElement;
            if ( _parentOfNS == null )
                return false; //MoveToNamespace() can only be called on Element node
            string attrName = name;
            if ( attrName.Length == 5 && attrName == "xmlns" )
                attrName = "xmlns:xmlns";
            if ( attrName.Length == 0 )
                attrName = "xmlns";
            XmlNode node = _curNode;
            XmlNodeType nt = node.NodeType;
            XmlAttribute attr = null;
            while ( node != null ) {
                //check current element node
                if ( node != null ) {
                    attr = ((XmlElement)node).GetAttributeNode(attrName, XmlDocument.strReservedXmlns);
                    if ( attr != null ) { //found it
                        _curNode = attr;
                        return true;
                    }
                } 
                //didn't find it, try the next element anccester.
                do {
                    node = node.ParentNode;
                } while ( node != null && node.NodeType != XmlNodeType.Element );
            }            
            //If the namespace being searched is "xml" move to the virtual "xml" node
            if( name == "xml" ) {
                _curNode = attrXmlNS;
                return true;
            }
            //nothing happens, the name doesn't exist as a namespace node.
            _parentOfNS = null;
            return false;
        }

        //Moves to the first namespace node depending upon the namespace scope.
        public override bool MoveToFirstNamespace( XPathNamespaceScope nsScope ) { 
            if( nsScope == XPathNamespaceScope.Local ) {
                _parentOfNS = _curNode as XmlElement;
                if( _parentOfNS == null )
                    return false;
                if( MoveToFirstLocalNamespace( _curNode ) )
                    return true;
                else {
                    _parentOfNS = null;
                    return false;
                }                    
            }
            else if( nsScope == XPathNamespaceScope.ExcludeXml )
                return MoveToFirstNonXmlNamespace();                
            else if( nsScope == XPathNamespaceScope.All ) {                
                _parentOfNS = _curNode as XmlElement;
                XmlElement cache = _parentOfNS;
                if( _parentOfNS == null )
                    return false;
                if( MoveToFirstNonXmlNamespace() )
                    return true;
                _parentOfNS = cache;
                _curNode = attrXmlNS;
                return true;
            }
            else return false;
        }

        //Moves to the next namespace node depending upon the namespace scope.
        public override bool MoveToNextNamespace( XPathNamespaceScope nsScope ) {
            //Navigator should be on a Namespace node when this is called.
            if ( ( _curNode.NodeType != XmlNodeType.Attribute ) || ( ! ( Ref.Equal(_curNode.NamespaceURI, XmlDocument.strReservedXmlns) ) ) )
                return false;
            Debug.Assert(_parentOfNS != null, "This should be true when we position on NS node");
            if( nsScope == XPathNamespaceScope.Local ) {
                XmlAttribute attr = _curNode as XmlAttribute;
                XmlNode owner = attr.OwnerElement;
                if( owner != _parentOfNS )
                    return false;//Navigator is no more in local scope if the following 
                return MoveToNextLocalNamespace( owner, _attrInd );
            }
            else if( nsScope == XPathNamespaceScope.ExcludeXml )
                return MoveToNextNonXmlNamespace();                
            else if( nsScope == XPathNamespaceScope.All ) {
                XmlNode temp = ((XmlAttribute)_curNode).OwnerElement;
                if( temp == null )
                    return false;
                if( MoveToNextNonXmlNamespace() )
                    return true;
                _curNode = attrXmlNS;
                return true;                 
            }
            else
                return false;
        }

        //Moves to first local namespace i.e the namespace nodes physically present on this node
        private bool MoveToFirstLocalNamespace( XmlNode node ) {
            Debug.Assert( node.NodeType == XmlNodeType.Element ); 
            _attrs = node.Attributes;
            _attrInd = _attrs.Count;            
            if ( _attrs != null ) {
                XmlAttribute attr = null;
                while ( _attrInd > 0 ) {                    
                    _attrInd--;
                    attr = _attrs[_attrInd];
                    if ( Ref.Equal(attr.NamespaceURI, XmlDocument.strReservedXmlns) ) {
                        _curNode = attr;
                        return true;
                    }
                }
            }
            //Didnot find even one namespace node.
            return false;
        }

        //This would move to the first namespace node present exclusing just the virtual "xml" node
        //that is presnt on all nodes.
        private bool MoveToFirstNonXmlNamespace() {
            _parentOfNS = _curNode as XmlElement;
            if ( _parentOfNS == null )
                return false; //MoveToFirstNamespace() can only be called on Element node
            XmlNode node = _curNode;
            while ( node != null ) {
                if( MoveToFirstLocalNamespace( node ) )
                    return true;
                do {
                    node = node.ParentNode;
                } while ( node != null && node.NodeType != XmlNodeType.Element );
            }
            //didn't find one namespace node
            _parentOfNS = null;
            return false;
        }
        

        //endElem is on the path from startElem to root is enforced by the caller
        private bool DuplicateNS( XmlElement startElem, XmlElement endElem, string lname) {
            if ( startElem == null || endElem == null )
                return false;
            XmlNode node = startElem; 
            XmlAttribute at = null;
            while ( node != null && node != endElem ) {
                at = ((XmlElement)node).GetAttributeNode( lname, XmlDocument.strReservedXmlns );
                if ( at != null )
                    return true;
                do {
                    node = node.ParentNode;
                } while ( node != null && node.NodeType != XmlNodeType.Element );
            }
            return false;            
        }

        //Moves to next local namespace nodes, this will include only
        // the namespace nodes physically present on this node        
        private bool MoveToNextLocalNamespace( XmlNode node, int attrInd ) {
            Debug.Assert(node != null);
            XmlAttribute attr = null;
            XmlAttributeCollection attrs = node.Attributes;  
            while ( attrInd > 0 ) {
                attrInd--;
                attr = attrs[attrInd];                
                if ( Ref.Equal(attr.NamespaceURI, XmlDocument.strReservedXmlns) 
                      && !DuplicateNS(_parentOfNS, (XmlElement)node, attr.LocalName) ) {
                    this._attrs = attrs;
                    _attrInd = attrInd;
                    _curNode = _attrs[attrInd];
                    return true;
                }
            }
            //no namespace node present
            return false;
        }
        //This would move to the next namespace node present exclusing just the virtual "xml" node
        //that is presnt on all nodes.
        private bool MoveToNextNonXmlNamespace() {
            XmlNode node = ((XmlAttribute)_curNode).OwnerElement;
            if( node == null )
                return false;
            int attrIndex = _attrInd;
            while ( node != null ) {
                if( MoveToNextLocalNamespace( node,attrIndex ) )
                        return true;
                do {
                    node = node.ParentNode;
                } while ( node != null && node.NodeType != XmlNodeType.Element );
                if( node != null ) {
                    attrIndex = node.Attributes.Count;
                }
            }
            //didn't find the next namespace, thus return
            return false;
        }


        public override bool MoveToAttribute( string localName, string namespaceURI ) {
            if ( _curNode.NodeType != XmlNodeType.Element )
                return false; //other type of nodes can't have attributes
            //if supporting Namespace nodes, these attributes are not really attributes
            if ( namespaceURI == XmlDocument.strReservedXmlns )
                return false;
            _attrs = _curNode.Attributes;
            _attrInd = -1;
            foreach ( XmlAttribute attr in _attrs ) {
                _attrInd++;
                if ( attr.LocalName == localName && attr.NamespaceURI == namespaceURI ) {
                    _curNode = attr;
                    return true;
                }
            }
            return false;
        }

        public override bool MoveToFirstAttribute() {
            if ( _curNode.NodeType != XmlNodeType.Element )
                return false; //other type of nodes can't have attributes
            _attrs = _curNode.Attributes;
            _attrInd = -1;
//#if SupportNamespaces 
            foreach ( XmlAttribute attr in _curNode.Attributes ) {
                if ( ! Ref.Equal(attr.NamespaceURI, XmlDocument.strReservedXmlns) ) {
                    _curNode = attr;
                    _attrInd++;
                    return true;
                }
                _attrInd++;
            }
            return false;
/*            
#else
            if ( _attrs.Count > 0 ) {
                _curNode = _attrs[0];
                _attrInd = 0;
                return true;
            }
            return false;
#endif   
*/
        }

//#if SupportNamespaces 
        public override bool MoveToNextAttribute() {
            if ( _curNode.NodeType != XmlNodeType.Attribute ||
                 Ref.Equal(_curNode.NamespaceURI, XmlDocument.strReservedXmlns)) 
                return false;
            XmlAttribute attr = null;
            while ( _attrInd+1 < _attrs.Count ) {
                _attrInd++;
                attr =  _attrs[_attrInd];
                if ( ! Ref.Equal(attr.NamespaceURI, XmlDocument.strReservedXmlns) ) {
                    _curNode = attr;
                    return true;
                }
            }
            return false;
        }
/*
#else
        public override bool MoveToNextAttribute() {
            if ( _curNode.NodeType != XmlNodeType.Attribute ) 
                return false;
            _attrInd++;
            if ( _attrInd < _attrs.Count ) {
                _curNode = _attrs[_attrInd];
                return true;
            }
            return false;
        }
#endif
*/

        // Tree
        public override bool MoveToNext() {
            if ( _curNode.NodeType == XmlNodeType.Attribute ) 
                return false;
            XmlNode parent = GetXPParentNode(_curNode);
            if ( parent == null )
                return false;
            XmlNode nextNode = DocumentXPathNavigator.GetXPNextSibling(_curNode);
            //when nodetype!=-1 then it is valid child of 
            while ( nextNode != null && XmlDocument.IsTextNode(_curNode.NodeType) && XmlDocument.IsTextNode(nextNode.NodeType) ) 
                nextNode = DocumentXPathNavigator.GetXPNextSibling(nextNode);
            while ( nextNode != null && !IsValidChild(parent, nextNode) )
                nextNode = DocumentXPathNavigator.GetXPNextSibling(nextNode);
            if ( nextNode == null )
                return false;
            _curNode = nextNode;
            return true;
        }

        public override bool MoveToPrevious() {
            if ( _curNode.NodeType == XmlNodeType.Attribute ) 
                return false;
            XmlNode parent = GetXPParentNode(_curNode);
            if ( parent == null )
                return false;
            XmlNode prevNode = DocumentXPathNavigator.GetXPPreviousSibling(_curNode);
            if ( prevNode != null && XmlDocument.IsTextNode(prevNode.NodeType) ) {
                XmlNode node = null;
                do {
                    node = prevNode;
                    prevNode = DocumentXPathNavigator.GetXPPreviousSibling(prevNode);
                } while ( prevNode != null && XmlDocument.IsTextNode(prevNode.NodeType) );
                prevNode = node;
            }
            while ( prevNode != null && !IsValidChild(parent, prevNode) )
                prevNode = DocumentXPathNavigator.GetXPPreviousSibling(prevNode);
            if ( prevNode == null )
                return false;
            _curNode = prevNode;
            return true;
        }

        public override bool MoveToFirst() {
            if ( _curNode.NodeType == XmlNodeType.Attribute ) 
                return false;
            XmlNode parent = GetXPParentNode(_curNode);
            if ( parent == null )
                return false;
            XmlNode prevNode = DocumentXPathNavigator.GetXPPreviousSibling(_curNode);
            while ( prevNode != null ) {
                if ( IsValidChild( parent, prevNode ) )
                    _curNode = prevNode;
                prevNode = DocumentXPathNavigator.GetXPPreviousSibling(_curNode);
            }
            return true;
        }

        private static bool IsValidChild( XmlNode parent, XmlNode child ) {
            XPathNodeType xntChild = child.XPNodeType;
            XPathNodeType xnt = parent.XPNodeType;
            switch ( xnt ) {
                case XPathNodeType.Root:
                    if( ( xntChild == XPathNodeType.Element )
                         || ( xntChild == XPathNodeType.ProcessingInstruction )
                         || ( xntChild == XPathNodeType.Comment ) )
                         return true;
                    else
                        return false;
                case XPathNodeType.Element:
                    return ( ((int)xntChild) != -1 );
                default :
                    return false;                    
            }
        }
        
        private XmlNode FirstChild {
            get {
                XmlNode child = _curNode.FirstChild;
                while ( child != null && child.NodeType == XmlNodeType.EntityReference )
                    child = child.FirstChild;
                while ( child != null && !IsValidChild(_curNode, child) ) 
                    child = DocumentXPathNavigator.GetXPNextSibling(child);
                return child;
            } 
        }
        
        public override bool HasChildren { 
            get { 
                if ( _curNode.NodeType == XmlNodeType.EntityReference )
                    return true;
                return FirstChild != null; 
            } 
        }

        public override bool MoveToFirstChild() {
            XmlNode firstChild = FirstChild;
            if ( firstChild != null ) {
                _curNode = firstChild;
                return true;
            }
            return false;
        }

        public override bool MoveToParent() {
            if ( _curNode.XPNodeType == XPathNodeType.Namespace ) {
                Debug.Assert( _parentOfNS != null );
                _curNode = _parentOfNS;
                _parentOfNS = null;
                return true;
            }
            XmlNode parent = GetXPParentNode( _curNode );
            if ( parent != null ) {
                _curNode = parent;
                return true;
            }
            return false;
        }

        public override void MoveToRoot() {
            XmlNode temp = _curNode;
            _curNode = GetRootNode(_curNode);
            if ( temp.XPNodeType == XPathNodeType.Namespace )
                _parentOfNS = null; 
        }

        public override bool MoveTo( XPathNavigator other ) {
            if ( other == null )
                return false;
            DocumentXPathNavigator otherDocXPathNav = other as DocumentXPathNavigator;
            if ( otherDocXPathNav != null ) {
                if ( otherDocXPathNav.Document != this._doc )
                    return false;
                SetCurrentPosition(otherDocXPathNav);
                return true;
            }
            return false;
        }

        public override bool MoveToId( string id ) {
            XmlNode element = _doc.GetElementById(id);
            if( element != null) {
                _curNode = element;
                return true;
            }
            return false;            
        }

        public override bool IsSamePosition( XPathNavigator other ) {
            if ( other == null )
                return false;
            DocumentXPathNavigator otherDocXPathNav = other as DocumentXPathNavigator;
            if ( otherDocXPathNav != null ) {
                if ( this._curNode == otherDocXPathNav.CurNode && this._parentOfNS == otherDocXPathNav._parentOfNS)
                    return true;
            }
            return false;
        }

        /*
        private NodePath BuildPath ( XmlNode node ) {
            if ( node == null )
                return null;
            NodePath retNodeInPath = null;
            XmlNode curNode = node;
            NodePath prevNodeInPath = null;
            while ( curNode != null ) {
                NodePath newNodeInPath = new NodePath( curNode );
                newNodeInPath.ChildInPath = prevNodeInPath;
                prevNodeInPath = newNodeInPath;
                retNodeInPath = newNodeInPath;
                curNode = curNode.ParentNode;
            }
            return retNodeInPath;
        }

        private XmlNodeOrder Compare( XmlNode node1, XmlNode node2 ) {
            Debug.Assert( node1 != null );
            Debug.Assert( node2 != null );
            Debug.Assert( node1 != node2 );
            XmlNode nextNode = node1.NextSibling;
            while ( nextNode != null && nextNode != node2 )
                nextNode = nextNode.NextSibling;
            if ( nextNode == null )
                //didn't meet node2 in the path to the end, thus it has to be in the front of node1
                return XmlNodeOrder.After;
            else
                //met node2 in the path to the end, so node1 is at front
                return XmlNodeOrder.Before;
        }

        //the function returns the order of the position in this XPathNavigator comparing to the position in other XPathNavigator
        // XmlNodeOrder.Before means that the position in this XPathNavigator is in front of the position in other XPathNavigator in DocumentOrder
        public override XmlNodeOrder ComparePosition( XPathNavigator other ) {
            if ( other == null )
                return XmlNodeOrder.Unknown;;
            DocumentXPathNavigator otherDocXPathNav = other as DocumentXPathNavigator;
            if ( otherDocXPathNav == null ) 
                return XmlNodeOrder.Unknown;
            if ( otherDocXPathNav.Root != this._root )
                return XmlNodeOrder.Unknown;            
            if ( otherDocXPathNav.CurNode == this._curNode )
                return XmlNodeOrder.Same;
            NodePath nodesInPath = BuildPath(_curNode);
            NodePath nodesInPathOther = BuildPath( otherDocXPathNav.CurNode );
            while ( nodesInPath != null && nodesInPathOther != null && 
                    nodesInPath.CurrentNode == nodesInPathOther.CurrentNode ) {
                nodesInPath = nodesInPath.ChildInPath;
                nodesInPathOther = nodesInPathOther.ChildInPath;
            }
            if ( nodesInPath == null ) {
                //they can't be both null which means all the nodes along the path are the same including themselves
                Debug.Assert( nodesInPathOther != null );
                return XmlNodeOrder.Before; //node in other navigator is the descendent of the current node, thus before
            }
            if ( nodesInPathOther == null ) {
                //they can't be both null the same reason as above
                Debug.Assert( nodesInPath != null );
                return XmlNodeOrder.After; // current node in this XmlPathNavigator is the descendent of the node in other navigator, thus after
            }
            return Compare( nodesInPath.CurrentNode, nodesInPathOther.CurrentNode );
        }
        */
        
        //this function is used to get the parent node even for XmlAttribute node or Namespace node
        private XmlNode GetXPParentNode( XmlNode node ) {
            if ( node == null )
                return null;
            XPathNodeType xnt = node.XPNodeType;
            if ( xnt == XPathNodeType.Namespace )
                return this._parentOfNS;
            if ( xnt == XPathNodeType.Attribute )
                return ((XmlAttribute)node).OwnerElement;
            XmlNode parent = node.ParentNode;
            while ( parent != null && parent.NodeType == XmlNodeType.EntityReference ) 
                parent = parent.ParentNode;
            return parent;
        }
        

        //what happens if the node is the children of XmlAttribute or is XmlAttribute itself
        private int GetDepth( XmlNode node ) {
            XmlNode parent = GetXPParentNode( node ); 
            int nDepth = 0;
            while ( parent != null ) {
                nDepth++;
                parent = GetXPParentNode( parent );
            }
            return nDepth;
        }

        //Assuming that node1 and node2 are in the same level; Except when they are namespace nodes, they should have the same parent node
        //the returned value is node2's position corresponding to node1 
        private XmlNodeOrder Compare( XmlNode node1, XmlNode node2 ) {
            Debug.Assert( node1 != null );
            Debug.Assert( node2 != null );
            Debug.Assert( node1 != node2 );            
            //Attribute nodes come before other children nodes except namespace nodes
            Debug.Assert( GetXPParentNode(node1) == GetXPParentNode(node2) );
            if ( node1.XPNodeType == XPathNodeType.Attribute && 
                 node2.XPNodeType == XPathNodeType.Attribute ) {
                XmlElement elem = (XmlElement)(GetXPParentNode( node1 ));
                foreach ( XmlAttribute attr in elem.Attributes ) {
                    if ( attr == node1 )
                        return XmlNodeOrder.Before;
                    if ( attr == node2 )
                        return XmlNodeOrder.After;
                }
                return XmlNodeOrder.Unknown;
            }
            if ( node1.XPNodeType == XPathNodeType.Attribute )
                return XmlNodeOrder.Before;
            if ( node2.XPNodeType == XPathNodeType.Attribute )
                return XmlNodeOrder.After;
            
            //neither of the node is Namespace node or Attribute node
            XmlNode nextNode = node1.NextSibling;
            while ( nextNode != null && nextNode != node2 )
                nextNode = nextNode.NextSibling;
            if ( nextNode == null )
                //didn't meet node2 in the path to the end, thus it has to be in the front of node1
                return XmlNodeOrder.After;
            else
                //met node2 in the path to the end, so node1 is at front
                return XmlNodeOrder.Before;
        }

        public override XmlNodeOrder ComparePosition( XPathNavigator other ) {
            //deal with special cases first
            if ( other == null )
                throw new NullReferenceException(Res.GetString(Res.XdomXpNav_NullParam));
            DocumentXPathNavigator otherDocXPathNav = other as DocumentXPathNavigator;
            if ( otherDocXPathNav == null ) 
                return base.ComparePosition(other);
            if ( otherDocXPathNav.Document != this._doc )
                return XmlNodeOrder.Unknown;            
            if ( otherDocXPathNav.CurNode == this._curNode && otherDocXPathNav._parentOfNS == this._parentOfNS )
                return XmlNodeOrder.Same;
            if ( otherDocXPathNav.NodeType == XPathNodeType.Namespace || this.NodeType == XPathNodeType.Namespace )
                return base.ComparePosition(other);
            int depth1 = 0, depth2 = 0;
            depth1 = this.GetDepth( this._curNode );
            depth2 = otherDocXPathNav.GetDepth( otherDocXPathNav.CurNode );
            XmlNode node1 = this._curNode;
            XmlNode node2 = otherDocXPathNav.CurNode;
            if ( depth2 > depth1 ) {
                while ( node2 != null && depth2 > depth1 ) {
                    node2 = otherDocXPathNav.GetXPParentNode( node2 );
                    depth2--;
                }
                if(node1 == node2)
                    return XmlNodeOrder.Before;
            }
            else if ( depth1 > depth2 ) {
                while ( node1 != null && depth1 > depth2 ) {
                    node1 = this.GetXPParentNode( node1 );
                    depth1--;
                }
                if(node1 == node2)
                    return XmlNodeOrder.After;
            }
            
            XmlNode parent1 = this.GetXPParentNode( node1 );
            XmlNode parent2 = otherDocXPathNav.GetXPParentNode( node2 );
            while ( parent1 != null && parent2 != null ) {
                if ( parent1 == parent2 ) 
                    return Compare( node1, node2 );
                node1 = parent1;
                node2 = parent2;
                parent1 = this.GetXPParentNode( node1 );
                parent2 = otherDocXPathNav.GetXPParentNode( node2 );
            }
            return XmlNodeOrder.Unknown;
        }

        //the function just for XPathNodeList to enumerate current Node.
        XmlNode IHasXmlNode.GetNode() { return _curNode; }

        public override XPathNodeIterator SelectDescendants( string localName, string namespaceURI, bool matchSelf ) {
            string nsAtom = _doc.NameTable.Get( namespaceURI );
            if ( nsAtom == null || this._curNode.NodeType == XmlNodeType.Attribute )
                return new DocumentXPathNodeIterator_Empty( this );

            Debug.Assert( this.NodeType != XPathNodeType.Attribute && this.NodeType != XPathNodeType.Namespace && this.NodeType != XPathNodeType.All );

            if ( localName.Length == 0 ) {
                if ( matchSelf )
                    return new DocumentXPathNodeIterator_ElemChildren_AndSelf_NoLocalName( this, nsAtom );
                return new DocumentXPathNodeIterator_ElemChildren_NoLocalName( this, nsAtom );
            }

            string localNameAtom = _doc.NameTable.Get( localName );
            if ( localNameAtom == null )
                return new DocumentXPathNodeIterator_Empty( this );

            if ( matchSelf )
                return new DocumentXPathNodeIterator_ElemChildren_AndSelf( this, localNameAtom, nsAtom );
            return new DocumentXPathNodeIterator_ElemChildren( this, localNameAtom, nsAtom );
        }

        
        public override XPathNodeIterator SelectDescendants( XPathNodeType nt, bool includeSelf ) {
            if ( nt == XPathNodeType.Element ) {
                XmlNodeType curNT = CurNode.NodeType;
                if ( curNT != XmlNodeType.Document && curNT != XmlNodeType.Element ) {
                    //only Document, Entity, Element node can have Element node as children ( descendant )
                    //entity nodes should be invisible to XPath data model
                    return new DocumentXPathNodeIterator_Empty( this );
                }
                if ( includeSelf )
                    return new DocumentXPathNodeIterator_AllElemChildren_AndSelf( this );
                return new DocumentXPathNodeIterator_AllElemChildren( this );
            }
            return base.SelectDescendants( nt, includeSelf );
        }
    }

    // An iterator that matches no nodes
    internal sealed class DocumentXPathNodeIterator_Empty : XPathNodeIterator {
        private XPathNavigator _nav;
        
        internal DocumentXPathNodeIterator_Empty( DocumentXPathNavigator nav )               { _nav = nav.Clone(); }
        internal DocumentXPathNodeIterator_Empty( DocumentXPathNodeIterator_Empty other )    { _nav = other._nav.Clone(); }
        public override XPathNodeIterator Clone()   { return new DocumentXPathNodeIterator_Empty( this ); }
        public override bool MoveNext()         { return false; }
        public override XPathNavigator Current  { get { return _nav; } }
        public override int CurrentPosition     { get { return 0; } }
        public override int Count                { get { return 0; } } 
    }

    // An iterator that can match any child elements that match the Match condition (overrided in the derived class)
    internal abstract class DocumentXPathNodeIterator_ElemDescendants : XPathNodeIterator {
        private DocumentXPathNavigator _nav;
        private int _level;
        private int _position;

        internal DocumentXPathNodeIterator_ElemDescendants( DocumentXPathNavigator nav ) {
            _nav      = (DocumentXPathNavigator)(nav.Clone());
            _level    = 0;
            _position = 0;
        }
        internal DocumentXPathNodeIterator_ElemDescendants( DocumentXPathNodeIterator_ElemDescendants other ) {
            _nav      = (DocumentXPathNavigator)(other._nav.Clone());
            _level    = other._level;
            _position = other._position;
        }

        protected abstract bool Match( XmlNode node );

        public override XPathNavigator Current {
            get { return _nav; }
        }

        public override int CurrentPosition {
            get { return _position; }
        }

        protected void SetPosition( int pos ) {
            _position = pos;
        }

        public override bool MoveNext() {
            // _nav s/b on an element node
            Debug.Assert( _nav.CurNode.NodeType != XmlNodeType.Attribute );

            XmlNode node = _nav.CurNode;

            while ( true ) {
                XmlNode next = node.FirstChild;
                if ( next == null ) {
                    if ( _level == 0 ) {
                        return false;
                    }
                    next = node.NextSibling;
                }
                else {
                    _level ++;
                }

                while ( next == null ) {
                    -- _level;
                    if ( _level == 0 ) {
                        return false;
                    }
                    node = node.ParentNode;
                    if ( node == null )
                        return false;
                    next = node.NextSibling;
                }

                if ( next.NodeType == XmlNodeType.Element && Match( next ) ) {
                    _nav.SetCurNode( next );
                    _position++;
                    return true;
                }

                node = next;
            }
        }
    }

    // Iterate over all element children irrespective of the localName and namespace
    internal class DocumentXPathNodeIterator_AllElemChildren : DocumentXPathNodeIterator_ElemDescendants {
        internal DocumentXPathNodeIterator_AllElemChildren( DocumentXPathNavigator nav ) : base( nav ) {
            Debug.Assert( nav.CurNode.NodeType != XmlNodeType.Attribute );
        }
        internal DocumentXPathNodeIterator_AllElemChildren( DocumentXPathNodeIterator_AllElemChildren other ) : base( other ) {
        }

        public override XPathNodeIterator Clone() {
            return new DocumentXPathNodeIterator_AllElemChildren( this );
        }

        protected override bool Match( XmlNode node ) {
            Debug.Assert( node != null );
            Debug.Assert( node.NodeType == XmlNodeType.Element );
            return true;
        }
    }
    // Iterate over all element children irrespective of the localName and namespace, include the self node when testing for localName/ns
    internal sealed class DocumentXPathNodeIterator_AllElemChildren_AndSelf :  DocumentXPathNodeIterator_AllElemChildren {
        internal DocumentXPathNodeIterator_AllElemChildren_AndSelf( DocumentXPathNavigator nav ) : base( nav ) {
        }
        internal DocumentXPathNodeIterator_AllElemChildren_AndSelf( DocumentXPathNodeIterator_AllElemChildren_AndSelf other ) : base( other ) {
        }

        public override XPathNodeIterator Clone() {
            return new DocumentXPathNodeIterator_AllElemChildren_AndSelf( this );
        }

        public override bool MoveNext() {
            if( CurrentPosition == 0 ) {
                DocumentXPathNavigator nav = (DocumentXPathNavigator)this.Current;
                XmlNode node = nav.CurNode;
                if ( node.NodeType == XmlNodeType.Element && Match( node ) ) {
                    SetPosition( 1 );
                    return true;
                }
            }
            return base.MoveNext();
        }
    }
    // Iterate over all element children that have a given namespace but irrespective of the localName
    internal class DocumentXPathNodeIterator_ElemChildren_NoLocalName : DocumentXPathNodeIterator_ElemDescendants {
        private string _nsAtom;

        internal DocumentXPathNodeIterator_ElemChildren_NoLocalName( DocumentXPathNavigator nav, string nsAtom ) : base( nav ) {
            Debug.Assert( nav.CurNode.NodeType != XmlNodeType.Attribute );
            Debug.Assert( Ref.Equal(nav.NameTable.Get( nsAtom ), nsAtom) );
            _nsAtom = nsAtom;
        }
        internal DocumentXPathNodeIterator_ElemChildren_NoLocalName( DocumentXPathNodeIterator_ElemChildren_NoLocalName other ) : base( other ) {
            _nsAtom = other._nsAtom;
        }
        public override XPathNodeIterator Clone() {
            return new DocumentXPathNodeIterator_ElemChildren_NoLocalName( this );
        }

        protected override bool Match( XmlNode node ) {
            Debug.Assert( node != null );
            Debug.Assert( node.NodeType == XmlNodeType.Element );
            return Ref.Equal(node.NamespaceURI, _nsAtom);
        }
    }
    // Iterate over all element children that have a given namespace but irrespective of the localName, include self node when checking for ns
    internal sealed class DocumentXPathNodeIterator_ElemChildren_AndSelf_NoLocalName :  DocumentXPathNodeIterator_ElemChildren_NoLocalName {

        internal DocumentXPathNodeIterator_ElemChildren_AndSelf_NoLocalName( DocumentXPathNavigator nav, string nsAtom ) : base( nav, nsAtom ) {
        }
        internal DocumentXPathNodeIterator_ElemChildren_AndSelf_NoLocalName( DocumentXPathNodeIterator_ElemChildren_AndSelf_NoLocalName other ) : base( other ) {
        }

        public override XPathNodeIterator Clone() {
            return new DocumentXPathNodeIterator_ElemChildren_AndSelf_NoLocalName( this );
        }

        public override bool MoveNext() {
            if( CurrentPosition == 0 ) {
                DocumentXPathNavigator nav = (DocumentXPathNavigator)this.Current;
                XmlNode node = nav.CurNode;
                if ( node.NodeType == XmlNodeType.Element && Match( node ) ) {
                    SetPosition( 1 );
                    return true;
                }
            }
            return base.MoveNext();
        }
    }
    // Iterate over all element children that have a given name and namespace
    internal class DocumentXPathNodeIterator_ElemChildren : DocumentXPathNodeIterator_ElemDescendants {
        protected string _localNameAtom;
        protected string _nsAtom;

        internal DocumentXPathNodeIterator_ElemChildren( DocumentXPathNavigator nav, string localNameAtom, string nsAtom ) : base( nav ) {
            Debug.Assert( nav.CurNode.NodeType != XmlNodeType.Attribute );
            Debug.Assert( Ref.Equal(nav.NameTable.Get( localNameAtom ), localNameAtom) );
            Debug.Assert( Ref.Equal(nav.NameTable.Get( nsAtom ), nsAtom) );
            Debug.Assert( localNameAtom.Length > 0 );   // Use DocumentXPathNodeIterator_ElemChildren_NoLocalName class for special magic value of localNameAtom

            _localNameAtom = localNameAtom;
            _nsAtom        = nsAtom;
        }

        internal DocumentXPathNodeIterator_ElemChildren( DocumentXPathNodeIterator_ElemChildren other ) : base( other ) {
            _localNameAtom = other._localNameAtom;
            _nsAtom        = other._nsAtom;
        }

        public override XPathNodeIterator Clone() {
            return new DocumentXPathNodeIterator_ElemChildren( this );
        }

        protected override bool Match( XmlNode node ) {
            Debug.Assert( node != null );
            Debug.Assert( node.NodeType == XmlNodeType.Element );
            return Ref.Equal(node.LocalName, _localNameAtom) && Ref.Equal(node.NamespaceURI, _nsAtom);
        }
    }    
    // Iterate over all elem children and itself and check for the given localName (including the magic value "") and namespace
    internal sealed class DocumentXPathNodeIterator_ElemChildren_AndSelf : DocumentXPathNodeIterator_ElemChildren {

        internal DocumentXPathNodeIterator_ElemChildren_AndSelf( DocumentXPathNavigator nav, string localNameAtom, string nsAtom )
            : base( nav, localNameAtom, nsAtom ) {
            Debug.Assert( localNameAtom.Length > 0 );   // Use DocumentXPathNodeIterator_ElemChildren_AndSelf_NoLocalName if localName == String.Empty
        }
        internal DocumentXPathNodeIterator_ElemChildren_AndSelf( DocumentXPathNodeIterator_ElemChildren_AndSelf other ) : base( other ) {
        }

        public override XPathNodeIterator Clone() {
            return new DocumentXPathNodeIterator_ElemChildren_AndSelf( this );
        }

        public override bool MoveNext() {
            if( CurrentPosition == 0 ) {
                DocumentXPathNavigator nav = (DocumentXPathNavigator)this.Current;
                XmlNode node = nav.CurNode;
                if ( node.NodeType == XmlNodeType.Element && Match( node ) ) {
                    SetPosition( 1 );
                    return true;
                }
            }
            return base.MoveNext();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\bufferbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="BufferBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml {
#if !STRINGBUILDER
    using System;

    internal class BufferBuilder {
        private    char[] _Buffer;
        private    int    _BufAlloc;
        private    int    _BufUsed;

        public BufferBuilder(int size) {
            _BufUsed = 0;
            _BufAlloc = size;
            _Buffer = new char[size];
        }

        public BufferBuilder() : this(100) {
        }

        public void Append(String str) {
            Append(str,0,str.Length);
        }

        public void Append(String str, int start, int len) {
            if (_BufUsed + len > _BufAlloc) GrowBuffer(len);
            for(len += start; start < len ; start++,_BufUsed++) {
                _Buffer[_BufUsed] = str[start];	
            }
        }

        public void Append(char[] a, int start, int len) {
            if (_BufUsed + len > _BufAlloc) GrowBuffer(len);
            Array.Copy(a, start, _Buffer, _BufUsed, len);
            _BufUsed += len;
        }

        public void Append(char[] a) {
            Append(a, 0, a.Length);
        }

        public void Append(char ch) {
            if (_BufUsed + 1 > _BufAlloc) GrowBuffer(1);
            _Buffer[_BufUsed++] = ch;
        }   

        public void Reset() {
            _BufUsed = 0;
        }

        public override String ToString() {
            if (_BufUsed != 0)
                return new String(_Buffer, 0, _BufUsed);
            else
                return String.Empty;
        }

        private void GrowBuffer(int len) {
            int newsize = (_BufUsed + len + 100)*2;
            char[] newbuf = new char[newsize];
            if (_BufUsed > 0) Array.Copy(_Buffer, 0, newbuf, 0, _BufUsed);
            _Buffer = newbuf;
            _BufAlloc = newsize;
        }

    };
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\base64decoder.cs ===
//------------------------------------------------------------------------------
// <copyright file="Base64Decoder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
using System.Text;

namespace System.Xml {
    internal class Base64Decoder {

        private ArrayManager   _charBuffer = new ArrayManager();
        UInt64          _bCurrent;      // what we're in the process of filling up
        int             _cbitFilled;    // how many bits in it we've filled

        private static readonly String s_CharsBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        private static readonly byte[] s_MapBase64 = ConstructMapBase64();
        private const byte s_bBad = unchecked((byte)-1);

        private static byte[] ConstructMapBase64() {
            byte[] mapBase64 = new byte[256];
            for (int i = 0; i < 256; i++) {
                mapBase64[i]= s_bBad;
            }
            for (int i = 0; i < s_CharsBase64.Length; i++) {
                mapBase64[(int)s_CharsBase64[i]] = (byte)i;
            }
            return mapBase64;
        }

        internal int DecodeBase64(char[] inArray, int offset, int inLength, byte[] outArray, int offsetOut, int countOut, bool flush) {

            String msg;

            if (0 > offset) {
                throw new ArgumentOutOfRangeException("offset");
            }

            if (0 > offsetOut) {
                throw new ArgumentOutOfRangeException("offsetOut");
            }
            int len = (null == inArray) ? 0 : inArray.Length;
            if (len < inLength && _charBuffer.Length <= 0) {
                throw new IndexOutOfRangeException("inLength");
            }

            // make sure that countOut + offsetOut are okay
            int outArrayLen = (null == outArray) ? 0 : outArray.Length;
            if (outArrayLen < (countOut + offsetOut)) {
                throw new ArgumentOutOfRangeException("offsetOut");
            }

            int inBufferCount = inLength - offset;
            if (flush)
                _charBuffer.Refresh();

            if (inArray != null && inBufferCount > 0)
                _charBuffer.Append(inArray, offset, inLength);

            if ((_charBuffer.Length == 0) || (countOut == 0))
                return 0;


            if (countOut == 0)
                return 0;

            // let's just make sure countOut > 0 and countOut < outArray.Length
            countOut += offsetOut;
            byte bDigit = outArray[countOut-1];

            // walk hex digits pairing them up and shoving the value of each pair into a byte
            int internalBufferLength = _charBuffer.Length;
            int offsetOutCur = offsetOut;
            int internalBufferOffset = 0;
            char ch;

            do {
                ch = _charBuffer[internalBufferOffset];
                // Have we reached the end?
                if (ch == '=')
                    break;

                internalBufferOffset++;
                // Ignore white space
                if (XmlCharType.IsWhiteSpace(ch))
                    continue;

                //
                // How much is this character worth?
                //
                if (ch > 127 || (bDigit = s_MapBase64[ch]) == s_bBad) {
                    goto error;
                }
                //
                // Add in its contribution
                //
                _bCurrent <<= 6;
                _bCurrent |= bDigit;
                _cbitFilled += 6;
                //
                // If we've got enough, output a byte
                //
                if (_cbitFilled >= 8) {
                    UInt64 b = (_bCurrent >> (_cbitFilled-8));       // get's top eight valid bits
                    outArray[offsetOutCur++] = (byte)(b&0xFF);                     // store the byte away
                    _cbitFilled -= 8;
                    if (offsetOutCur == countOut) {
                        _charBuffer.CleanUp(internalBufferOffset);
                        return offsetOutCur - offsetOut;
                    }
                }
            }
            while (internalBufferOffset < internalBufferLength);

            while (internalBufferOffset < internalBufferLength && _charBuffer[internalBufferOffset] == '=') {
                internalBufferOffset ++;
                _cbitFilled = 0;
            }

            if (internalBufferOffset != internalBufferLength) {
                for (internalBufferOffset=internalBufferOffset ;internalBufferOffset < internalBufferLength; internalBufferOffset++) {
                    ch = _charBuffer[internalBufferOffset];
                    // Ignore whitespace after the padding chars.
                    if (!(XmlCharType.IsWhiteSpace(ch))) {
                        goto error;
                    }
                }
            }
            _charBuffer.CleanUp(internalBufferOffset);
            return offsetOutCur - offsetOut;

            error:
            msg = new String(_charBuffer.CurrentBuffer, _charBuffer.CurrentBufferOffset, (_charBuffer.CurrentBuffer == null) ? 0:(_charBuffer.CurrentBufferLength - _charBuffer.CurrentBufferOffset));
            throw new XmlException(Res.Xml_InvalidBase64Value, msg);
        }

        internal int BitsFilled {
            get {  return _cbitFilled; }
        }
        internal void Flush() {
            if (null != _charBuffer) {
                _charBuffer.Refresh();
            }
            _cbitFilled = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\binhexencoder.cs ===
//------------------------------------------------------------------------------
// <copyright file="BinHexEncoder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml {
    internal class BinHexEncoder {

        private const string s_hexDigits = "0123456789ABCDEF";

        internal static string EncodeToBinHex(byte[] inArray, int offsetIn, int count) {

            if (null == inArray) {
                throw new ArgumentNullException("inArray");
            }

            if (0 > offsetIn) {
                throw new ArgumentOutOfRangeException("offsetIn");
            }

            if (0 > count) {
                throw new ArgumentOutOfRangeException("count");
            }

            if (count > inArray.Length - offsetIn) {
                throw new ArgumentException("count > inArray.Length - offsetIn");
            }

            char[] outArray = new char[2 * count];
            int lenOut =  EncodeToBinHex(inArray, offsetIn, count, outArray);
            return new String(outArray, 0, lenOut);
        }

        private static int EncodeToBinHex(byte[] inArray, int offsetIn, int count, char[] outArray) {
            int curOffsetOut =0, offsetOut = 0;
            byte b;
            int lengthOut = outArray.Length;

            for (int j=0; j<count; j++) {
                b = inArray[offsetIn ++];
                outArray[curOffsetOut ++] = s_hexDigits[b >> 4];
                if (curOffsetOut == lengthOut) {
                    break;
                }
                outArray[curOffsetOut ++] = s_hexDigits[b & 0xF];
                if (curOffsetOut == lengthOut) {
                    break;
                }
            }
            return curOffsetOut - offsetOut;
        } // function

    } // class
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\arraymanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="ArrayManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
using System.Collections;

namespace System.Xml {
    internal class ArrayManager {
        internal class Buffer {
            public char[] _charBuffer;
            public int    _offset;
            public int    _size;
            
            public Buffer(char[] buffer, int offset, int size) {
                _charBuffer = buffer;
                _offset     = offset;
                _size       = size;
            }
        }

        private Queue  _BufferQueue;
        private int    _offset;
        private Buffer _CurrentBuffer;
        
        private Queue BufferQueue
        {
            get
            {
                if (_BufferQueue == null)
                    _BufferQueue = new Queue();
                return _BufferQueue;
            }
            set
            {
                _BufferQueue = value;
            }
        }

        private int Offset
        {
            get
            {
                return _offset;
            }
            set
            {
                _offset = value;
            }
        }

        internal char[] CurrentBuffer
        {
            get{
                if (_CurrentBuffer != null)
                    return _CurrentBuffer._charBuffer;
                return null;
            }
        }

        internal int CurrentBufferOffset
        {
            get
            {
                if (_CurrentBuffer != null)
                    return _CurrentBuffer._offset;
                return 0;
            }
        }

        internal int CurrentBufferLength
        {
            get
            {
                if (_CurrentBuffer != null)
                    return _CurrentBuffer._size;
                return 0;
            }
        }

        internal int Length
        {
            get
            {
                int len = 0;
                if (_CurrentBuffer != null)
                    len += (_CurrentBuffer._size - _CurrentBuffer._offset);
                IEnumerator enumerator = BufferQueue.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    Buffer element = (Buffer) enumerator.Current;
                    len += (element._size - element._offset);
                }
                return len;
            }
        }

        internal char this[int index]
        {
            get
            {
                char ch = '\0';
                if (_CurrentBuffer == null) {
                    if (BufferQueue.Count > 0)
                        _CurrentBuffer = (Buffer) BufferQueue.Dequeue();
                    else
                        return ch;
                }

                if (!((_CurrentBuffer._offset + index - Offset) < _CurrentBuffer._size)) {
                    Offset = index;
                    _CurrentBuffer = (BufferQueue.Count > 0) ? (Buffer) BufferQueue.Dequeue():null;
                }

                if (_CurrentBuffer != null)
                    ch = _CurrentBuffer._charBuffer[_CurrentBuffer._offset + (index - Offset)];
                return ch;
            }
        }
            
        internal void Append(char[] buffer, int offset, int size) {
            BufferQueue.Enqueue(new Buffer(buffer, offset, size));
        }

        internal void CleanUp(int internalBufferOffset) {
            if (_CurrentBuffer != null) {
                _CurrentBuffer._offset += internalBufferOffset - Offset;
                Offset = 0;
            }
        }

        internal void Refresh() {
            BufferQueue = new Queue();
            _CurrentBuffer = null;
            _offset = 0;
        }

        internal ArrayManager() {
            BufferQueue     = null;
            _offset         = 0;
            _CurrentBuffer = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\ixmllineinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="IXmlLineInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml {
/// <include file='doc\IXmlLineInfo.uex' path='docs/doc[@for="IXmlLineInfo"]/*' />
public interface IXmlLineInfo {
    /// <include file='doc\IXmlLineInfo.uex' path='docs/doc[@for="IXmlLineInfo.HasLineInfo"]/*' />
    bool HasLineInfo();
    /// <include file='doc\IXmlLineInfo.uex' path='docs/doc[@for="IXmlLineInfo.LineNumber"]/*' />
    int LineNumber { get; }
    /// <include file='doc\IXmlLineInfo.uex' path='docs/doc[@for="IXmlLineInfo.LinePosition"]/*' />
    int LinePosition { get; }
}


internal class PositionInfo : IXmlLineInfo {
    public virtual bool HasLineInfo() { return false; }
    public virtual int LineNumber { get { return 0;} }
    public virtual int LinePosition { get { return 0;} }

    public static PositionInfo GetPositionInfo(Object o) {
        if (o is IXmlLineInfo) {
            return new ReaderPositionInfo(o as IXmlLineInfo);
        }
        else {
            return new PositionInfo();
        }
    }

}

internal class ReaderPositionInfo: PositionInfo {

    private IXmlLineInfo mlineInfo;

    public ReaderPositionInfo(IXmlLineInfo lineInfo) {

        mlineInfo = lineInfo;

    }

    public override bool HasLineInfo() { return mlineInfo.HasLineInfo(); }
    public override int LineNumber { get { return mlineInfo.LineNumber;} }
    public override int LinePosition { get { return mlineInfo.LinePosition;} }

}
}// namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\nametable.cs ===
//------------------------------------------------------------------------------
// <copyright file="NameTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;

namespace System.Xml {

    /// <include file='doc\NameTable.uex' path='docs/doc[@for="NameTable"]/*' />
    /// <devdoc>
    ///    <para>
    ///       XmlNameTable implemented as a simple hash table.
    ///    </para>
    /// </devdoc>
    public class NameTable : XmlNameTable {
        Entry[] buckets;
        int size;
        int max;


        /// <include file='doc\NameTable.uex' path='docs/doc[@for="NameTable.NameTable"]/*' />
        /// <devdoc>
        ///      Public constructor.
        /// </devdoc>
        public NameTable() {
            max = 31;
            buckets = new Entry[max];
        }

        /// <include file='doc\NameTable.uex' path='docs/doc[@for="NameTable.Add"]/*' />
        /// <devdoc>
        ///      Add the given string to the NameTable or return
        ///      the existing string if it is already in the NameTable.
        /// </devdoc>
        public override String Add(String key) {
            if (key == null) {
                throw new ArgumentNullException("key");
            }

            if (key == String.Empty) return String.Empty;
            int hashCode = key[0];
            int len = key.Length;
            for (int i = 0; i < len; i++) hashCode = hashCode * 37 + key[i];
            hashCode &= 0x7FFFFFFF;
            for (Entry e = buckets[hashCode % max]; e != null; e = e.next) {
                if (e.hashCode == hashCode && e.len == len && e.str == key)
                    return e.str;
            }
            return AddEntry(key, hashCode);
        }

        /// <include file='doc\NameTable.uex' path='docs/doc[@for="NameTable.Add1"]/*' />
        /// <devdoc>
        ///      Add the given string to the NameTable or return
        ///      the existing string if it is already in the NameTable.
        /// </devdoc>
        public override String Add(char[] key, int start, int len) {
            if (len == 0) return String.Empty;

            int hashCode = key[start];
            for (int i = 0; i < len; i++) hashCode = hashCode * 37 + key[start+i];
            hashCode &= 0x7FFFFFFF;
            for (Entry e = buckets[hashCode % max]; e != null; e = e.next) {
                if (e.hashCode == hashCode && e.len == len && TextEquals(e.str, key, start, len)) return e.str;
            }
            return AddEntry(new string(key, start, len), hashCode);
        }

        /// <include file='doc\NameTable.uex' path='docs/doc[@for="NameTable.Get"]/*' />
        /// <devdoc>
        ///      Find the matching string in the NameTable.
        /// </devdoc>

        public override String Get( String value ) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            if (value == String.Empty)
                return value;

            int len = value.Length;
            int hashCode = value[0];
            for (int i = 0; i < len; i++) hashCode = hashCode * 37 + value[i];
            hashCode &= 0x7FFFFFFF;
            for (Entry e = buckets[hashCode % max]; e != null; e = e.next) {
                if (e.hashCode == hashCode && e.len == len && TextEquals(e.str, value, 0, len))
                //if (e.hashCode == hashCode && e.len == len && String.CompareOrdinal(e.str, value) == 0 )
                    return e.str;
            }
            return null;
            //return Get(value.ToCharArray(), 0, value.Length);
        }

        /// <include file='doc\NameTable.uex' path='docs/doc[@for="NameTable.Get1"]/*' />
        /// <devdoc>
        ///      Find the matching string atom given a range of
        ///      characters.
        /// </devdoc>

        public override String Get( char[] key, int start, int len ) {
            if (len == 0) return String.Empty;

            int hashCode = key[start];
            for (int i = 0; i < len; i++) hashCode = hashCode * 37 + key[start+i];
            hashCode &= 0x7FFFFFFF;
            for (Entry e = buckets[hashCode % max]; e != null; e = e.next) {
                if (e.hashCode == hashCode && e.len == len && TextEquals(e.str, key, start, len))
                    return e.str;
            }
            return null;
        }
        //============================================================================
        string AddEntry(string str, int hashCode) {
            int bucket = hashCode % max;
            Entry e = new Entry(str, hashCode, buckets[bucket]);
            buckets[bucket] = e;
            if (size++ == max)
                GrowBuckets();
            return e.str;
        }

        void GrowBuckets() {
            int count = max * 2 + 1;
            Entry[] newBuckets = new Entry[count];
            for (int i = max; --i >= 0;) {
                Entry e = buckets[i];
                while (e != null) {
                    int bucket = e.hashCode % count;
                    Entry next = e.next;
                    e.next = newBuckets[bucket];
                    newBuckets[bucket] = e;
                    e = next;
                }
            }
            buckets = newBuckets;
            max = count;
        }

        static bool TextEquals(String array, String text, int start, int textLen) {
             for (int i = textLen; --i >= 0;) {
                if (array[i] != text[start+i])
                    return false;
            }
            return true;
         }

        static bool TextEquals(String array, char[] text, int start, int textLen) {
            for (int i = textLen; --i >= 0;) {
                if (array[i] != text[start+i])
                    return false;
            }
            return true;
        }

        class Entry {
            internal string str;
            //internal char[] array;
            internal int hashCode;
            internal Entry next;
            internal int len;

            internal Entry(string str, int hashCode, Entry next) {
                this.str = str;
                this.len = str.Length;
                //this.array = str.ToCharArray();
                this.hashCode = hashCode;
                this.next = next;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\namespaceresolver.cs ===
//------------------------------------------------------------------------------
// <copyright file="NamespaceResolver.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml {

    internal abstract class NamespaceResolver {
        internal abstract string CurrentDefault { get;}
        internal abstract bool Resolve(string prefix, out string urn);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\entityhandling.cs ===
//------------------------------------------------------------------------------
// <copyright file="EntityHandling.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Xml
{
    /// <include file='doc\EntityHandling.uex' path='docs/doc[@for="EntityHandling"]/*' />
    /// <devdoc>
    ///    Specifies how entities are handled.
    /// </devdoc>
    public enum EntityHandling
    {
        /// <include file='doc\EntityHandling.uex' path='docs/doc[@for="EntityHandling.ExpandEntities"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Expand all entities. This is the default.
        ///    </para>
        ///    <para>
        ///       Nodes of NodeType EntityReference are not returned. The entity text is
        ///       expanded in place of the entity references.
        ///    </para>
        /// </devdoc>
        ExpandEntities      = 1,
        /// <include file='doc\EntityHandling.uex' path='docs/doc[@for="EntityHandling.ExpandCharEntities"]/*' />
        /// <devdoc>
        ///    <para>Expand character entities and return general
        ///       entities as nodes (NodeType=XmlNodeType.EntityReference, Name=the name of the
        ///       entity, HasValue=
        ///       false).</para>
        /// <para>You must call <see cref='System.Xml.XmlReader.ResolveEntity'/> to see what the general entities expand to. This
        ///    allows you to optimize entity handling by only expanding the entity the
        ///    first time it is used.</para>
        /// <para>If you call <see cref='System.Xml.XmlReader.GetAttribute'/> 
        /// , general entities are also expanded as entities are of
        /// no interest in this case.</para>
        /// </devdoc>
        ExpandCharEntities  = 2,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\hwstack.cs ===
//------------------------------------------------------------------------------
// <copyright file="HWStack.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;


namespace System.Xml {

// This stack is designed to minimize object creation for the
// objects being stored in the stack by allowing them to be
// re-used over time.  It basically pushes the objects creating
// a high water mark then as Pop() is called they are not removed
// so that next time Push() is called it simply returns the last
// object that was already on the stack.

    internal class HWStack : ICloneable {
        internal HWStack(int GrowthRate) : this (GrowthRate, int.MaxValue) {}

        internal HWStack(int GrowthRate, int limit) {
            _GrowthRate = GrowthRate;
            _Used = 0;
            _Stack = new Object[GrowthRate];
            _Size = GrowthRate;
            _Limit = limit;
        }

        internal Object Push() {
            if (_Used == _Size) {
                if (_Limit <= _Used) {
                    throw new XmlException(Res.Xml_StackOverflow, string.Empty);
                }
                Object[] newstack = new Object[_Size + _GrowthRate];
                if (_Used > 0) {
                    System.Array.Copy(_Stack, 0, newstack, 0, _Used);
                }
                _Stack = newstack;
                _Size += _GrowthRate;
            }
            return _Stack[_Used++];
        }

        internal Object Pop() {
            if (0 < _Used) {
                _Used--;
                Object result = _Stack[_Used];
                return result;
            }
            return null;
        }

        internal object Peek() {
            return _Used > 0 ? _Stack[_Used - 1] : null;
        }

        internal void AddToTop(object o) {
            if (_Used > 0) {
                _Stack[_Used - 1] = o;
            }
        }

        internal Object this[int index]
        {
            get {
                if (index >= 0 && index < _Used) {
                    Object result = _Stack[index];
                    return result;
                }
                else throw new IndexOutOfRangeException("index");
            }
            set {
                if (index >= 0 && index < _Used) _Stack[index] = value;
                else throw new IndexOutOfRangeException("index");
            }
        }

        internal int Length {
            get { return _Used;}
        }

        //
        // ICloneable
        //

        private HWStack(object[] stack, int growthRate, int used, int size) {
            _Stack      = stack;
            _GrowthRate = growthRate;
            _Used       = used;
            _Size       = size;
        }

        public object Clone() {
            return new HWStack((object[]) _Stack.Clone(), _GrowthRate, _Used, _Size);
        }

        private Object[] _Stack;
        private int _GrowthRate;
        private int _Used;
        private int _Size;
        private int _Limit;
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\ihasxmlnode.cs ===
//------------------------------------------------------------------------------
// <copyright file="IHasXmlNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml {
    /// <include file='doc\IHasXmlNode.uex' path='docs/doc[@for="IHasXmlNode"]/*' />
    public interface IHasXmlNode {
        /// <include file='doc\IHasXmlNode.uex' path='docs/doc[@for="IHasXmlNode.GetNode"]/*' />
        XmlNode GetNode();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\mtnametable.cs ===
//------------------------------------------------------------------------------
// <copyright file="MTNameTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#if MTNAMETABLE
using System;
using System.IO;
using System.Collections;

namespace System.Xml {
    // <doc>
    // <desc>
    //      XmlNameTable implemented as a multi-threaded splay tree.
    // </desc>
    // </doc>
    //
    using System.Threading;

    /// <internalonly/>
    /// <summary>
    /// </summary>
    [Obsolete("This class is going away")]
    public class MTNameTable : XmlNameTable {
        internal MTNameTableNode rootNode;
        internal ReaderWriterLock rwLock;
        internal int timeout;

        public MTNameTable( bool isThreadSafe, int timeout ) {
            if (isThreadSafe) {
                this.rwLock = new ReaderWriterLock();
                this.timeout = timeout;
            }
        }

        public MTNameTable( bool isThreadSafe ): this( isThreadSafe, Timeout.Infinite ) {
        }

        public MTNameTable(): this( false ) {
        }    



        public IEnumerator GetEnumerator() {
            return new MTNameTableEnumerator( this );
        }


        // <doc>
        // <desc>
        //      Find the matching string atom given a string
        // </desc>
        // </doc>
        //

        public override String Get( String value ) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }

            MTNameTableName name = new MTNameTableName(value);
            return Get( ref name );
        }

        public override String Get( char[] key, int start, int len ) {
            if (key == null) {
                throw new ArgumentNullException("key");
            }
            else {
                if ((start < 0) || (len < 0) || (start > key.Length - len))
                    throw new ArgumentOutOfRangeException();
            }

            MTNameTableName name = new MTNameTableName(key, start, len);
            return Get( ref name );
        }

        private String Get( ref MTNameTableName nn ) {
            String name = null;

            if (rootNode != null) {
                if (rwLock != null)
                    rwLock.AcquireReaderLock(timeout);

                MTNameTableNode currentNode = rootNode;

                while (true) {
                    Int64 d = currentNode.Compare(ref nn);

                    if (d == 0) {
                        Promote( currentNode );
                        name = currentNode.value;
                        break;
                    }
                    else if (d < 0) {
                        if (currentNode.leftNode == null)
                            break;

                        currentNode = currentNode.leftNode;
                    }
                    else {
                        if (currentNode.rightNode == null)
                            break;

                        currentNode = currentNode.rightNode;
                    }
                }

                if (rwLock != null)
                    rwLock.ReleaseReaderLock();
            }

            return name;
        }



        // <doc>
        // <desc>
        //      Find the matching string atom given a string, or
        //      insert a new one.
        // </desc>
        // </doc>
        //

        public override String Add(String value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }

            MTNameTableName name = new MTNameTableName( value );
            return Add( ref name, rwLock != null ).value;
        }

        public override String Add(char[] key, int start, int len) {
            if (key == null) {
                throw new ArgumentNullException("key");
            }
            else {
                if ((start < 0) || (len < 0) || (start > key.Length - len))
                    throw new ArgumentOutOfRangeException();
            }

            MTNameTableName name = new MTNameTableName( key, start, len );
            return Add( ref name, rwLock != null ).value;
        }

        private MTNameTableNode Add( ref MTNameTableName name, bool fLock) {
            if (fLock)
                rwLock.AcquireReaderLock(timeout);

            MTNameTableNode currentNode = rootNode;

            while (true) {
                if (currentNode == null) {
                    currentNode = AddRoot( ref name, fLock );
                    break;
                }
                else {
                    Int64 d = currentNode.Compare(ref name);

                    if (d == 0) {
                        Promote( currentNode );
                        break;
                    }
                    else if (d < 0) {
                        if (currentNode.leftNode == null) {
                            currentNode = AddLeft( currentNode, ref name, fLock );
                            break;
                        }
                        else {
                            currentNode = currentNode.leftNode;
                        }
                    }
                    else {
                        if (currentNode.rightNode == null) {
                            currentNode = AddRight( currentNode, ref name, fLock );
                            break;
                        }
                        else {
                            currentNode = currentNode.rightNode;
                        }
                    }
                }
            }

            if (fLock)
                rwLock.ReleaseReaderLock();

            return currentNode;
        }





        // <doc>
        // <desc>
        //     Sets the root node given a string 
        // </desc>
        // </doc>
        //

        private MTNameTableNode AddRoot( ref MTNameTableName name, bool fLock ) {
            MTNameTableNode newNode = null;

            if (fLock) {
                LockCookie lc = rwLock.UpgradeToWriterLock(timeout);

                // recheck for failsafe against race-condition
                if (rootNode == null) {
                    rootNode = newNode = new MTNameTableNode( ref name );
                }
                else {
                    // try again, with write-lock active
                    newNode = Add( ref name, false );
                }

                rwLock.DowngradeFromWriterLock(ref lc);
            }
            else {
                rootNode = newNode = new MTNameTableNode( ref name );
            }

            return newNode;
        }


        // <doc>
        // <desc>
        //     Adds the a node to the left of the specified node given a string
        // </desc>
        // </doc>
        //

        private MTNameTableNode AddLeft( MTNameTableNode node, ref MTNameTableName name, bool fLock ) {
            MTNameTableNode newNode = null;

            if (fLock) {
                LockCookie lc = rwLock.UpgradeToWriterLock(timeout);

                // recheck for failsafe against race-condition
                if (node.leftNode == null) {
                    newNode = new MTNameTableNode( ref name );
                    node.leftNode = newNode;
                    newNode.parentNode = node;
                }
                else {
                    // try again, with write-lock active
                    newNode = Add( ref name, false );
                }

                rwLock.DowngradeFromWriterLock(ref lc);
            }
            else {
                newNode = new MTNameTableNode( ref name );
                node.leftNode = newNode;
                newNode.parentNode = node;
            }

            return newNode;
        }


        // <doc>
        // <desc>
        //     Adds the a node to the right of the specified node, given a string.
        // </desc>
        // </doc>
        //

        private MTNameTableNode AddRight( MTNameTableNode node, ref MTNameTableName name, bool fLock ) {
            MTNameTableNode newNode = null;

            if (fLock) {
                LockCookie lc = rwLock.UpgradeToWriterLock(timeout);

                // recheck for failsafe against race-condition
                if (node.rightNode == null) {
                    newNode = new MTNameTableNode( ref name );
                    node.rightNode = newNode;
                    newNode.parentNode = node;
                }
                else {
                    // try again, with write-lock active
                    newNode = Add( ref name, false );
                }

                rwLock.DowngradeFromWriterLock(ref lc);
            }
            else {
                newNode = new MTNameTableNode( ref name );
                node.rightNode = newNode;
                newNode.parentNode = node;
            }

            return newNode;
        }


        // <doc>
        // <desc>
        //     Promote the node into the parent's position (1 ply closer to the rootNode)
        // </desc>
        // </doc>
        //

        private const int threshhold = 20;

        private void Promote( MTNameTableNode node ) {
            // count number of times promotion requested
            node.counter++;

            if (node != rootNode &&
                node.counter > threshhold &&
                node.counter > node.parentNode.counter * 2) {
                if (rwLock != null) {
                    LockCookie lc = rwLock.UpgradeToWriterLock(timeout);

                    // recheck for failsafe against race-condition
                    if (node != rootNode && 
                        node.counter > threshhold &&
                        node.counter > node.parentNode.counter * 2) {
                        InternalPromote( node );
                    }

                    rwLock.DowngradeFromWriterLock(ref lc);
                }
                else {
                    InternalPromote( node );
                }
            }
        }

        private void InternalPromote( MTNameTableNode node ) {
            MTNameTableNode parent = node.parentNode;

            if (parent != null) {
                MTNameTableNode grandParent = parent.parentNode;

                if (parent.leftNode == node) {
                    parent.leftNode = node.rightNode;
                    node.rightNode = parent;

                    // update lineage
                    if (parent.leftNode != null)
                        parent.leftNode.parentNode = parent;

                    node.parentNode = grandParent;
                    parent.parentNode = node;
                }
                else {
                    parent.rightNode = node.leftNode;
                    node.leftNode = parent;

                    // update lineage
                    if (parent.rightNode != null)
                        parent.rightNode.parentNode = parent;

                    node.parentNode = grandParent;
                    parent.parentNode = node;
                }

                // fixup pointer to promoted node in grand parent
                if (grandParent == null) {
                    rootNode = node;
                }
                else {
                    if (grandParent.leftNode == parent) {
                        grandParent.leftNode = node;
                    }
                    else {
                        grandParent.rightNode = node;
                    }
                }
            }
        }
    }


    internal struct MTNameTableName {
        internal String str;
        internal char[] array;
        internal int start;
        internal int len;
        internal Int64 hash;

        public MTNameTableName( string str ) {
            this.str = str;
            this.hash = Hash(str);
            this.array = null;
            this.start = 0;
            this.len = 0;
        }

        public MTNameTableName( char[] array, int start, int len ) {
            this.array = array;
            this.start = start;
            this.len = len;
            this.str = null;
            this.hash = Hash(array, start, len);
        }

        static private Int64 Hash(String value) {
            Int64 hash = 0;
            int len = value.Length;

            if (len > 0)
                hash = (((Int64)value[0]) & 0xFF) << 48;

            if (len > 1)
                hash = hash | ((((Int64)value[1]) & 0xFF) << 32);

            if (len > 2)
                hash = hash | ((((Int64)value[2]) & 0xFF) << 16);

            if (len > 3)
                hash = hash | (((Int64)value[3]) & 0xFF);

            return hash;
        }    

        static private Int64 Hash(char[] key, int start, int len) {
            Int64 hash = 0;

            if (len > 0)
                hash = (((Int64)key[start]) & 0xFF) << 48;

            if (len > 1)
                hash = hash | ((((Int64)key[start+1]) & 0xFF) << 32);

            if (len > 2)
                hash = hash | ((((Int64)key[start+2]) & 0xFF) << 16);

            if (len > 3)
                hash = hash | (((Int64)key[start+3]) & 0xFF);

            return hash;
        }
    }


    // <doc>
    // <desc>
    //      A MTNameTable node.
    // </desc>
    // </doc>
    //

    internal class MTNameTableNode {
        internal String value;
        internal Int64 hash;
        internal Int64 counter;
        internal MTNameTableNode leftNode;
        internal MTNameTableNode rightNode;
        internal MTNameTableNode parentNode;

        internal MTNameTableNode(ref MTNameTableName name ) {
            if (name.str != null) {
                value = name.str;
            }
            else {
                value = new String(name.array, name.start, name.len);
            }

            this.hash = name.hash;
        }

        internal Int64 Compare( ref MTNameTableName name ) {
            if (name.array != null) {
                return Compare( name.hash, name.array, name.start, name.len );
            }
            else {
                return Compare( name.hash, name.str );
            }
        }

        private Int64 Compare(Int64 hash, string value) {
            Int64 d = hash - this.hash;

            if (d == 0) {
                int valueLength = this.value.Length;
                d = value.Length - valueLength;

                // if length is not equal, break
                if (d != 0)
                    return(Int64)d;

                for (int ii = 4; ii < valueLength; ii++) {
                    int dd = value[ii] - this.value[ii];
                    if (dd != 0) {
                        d = dd;
                        break;
                    }
                }
            }

            return(Int64)d;
        }

        private Int64 Compare(Int64 hash, char[] key, int start, int len) {
            Int64 d = hash - this.hash;

            if (d == 0) {
                int valueLength = this.value.Length;
                d = len - valueLength;

                // if length is not equal, break
                if (d != 0)
                    return(Int64)d;

                for (int ii = 4; ii < valueLength; ii++) {
                    int dd = key[start + ii] - this.value[ii];
                    if (dd != 0) {
                        d = dd;
                        break;
                    }
                }
            }

            return(Int64)d;
        }
    }


    // <doc>
    // <desc>
    //      Enumerates all the names (strings) of a MTNameTable
    // </desc>
    // </doc>
    //

    internal class MTNameTableEnumerator: IEnumerator {
        private ArrayList names;
        private int iName;

        internal MTNameTableEnumerator( MTNameTable nt ) {
            if (nt.rwLock != null)
                nt.rwLock.AcquireReaderLock(nt.timeout);

            names = new ArrayList();
            Walk( nt.rootNode );
            iName = -1;

            if (nt.rwLock != null)
                nt.rwLock.ReleaseReaderLock();
        }

        internal void Walk( MTNameTableNode node ) {
            if (node != null) {
                if (node.leftNode != null)
                    Walk( node.leftNode );

                names.Add( node.value );

                if (node.rightNode != null)
                    Walk( node.rightNode );
            }
        }

        public void Reset() {
            iName = -1;
        }

        public bool MoveNext() {
            iName++;
            return iName < names.Count;
        }

        public object Current {
            get {
                if (iName < names.Count)
                    return names[iName];
                return null;
            }
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\readstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="ReadState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml
{
    /// <include file='doc\ReadState.uex' path='docs/doc[@for="ReadState"]/*' />
    /// <devdoc>
    ///    Specifies the state of the stream.
    /// </devdoc>
    public enum ReadState
    {
        /// <include file='doc\ReadState.uex' path='docs/doc[@for="ReadState.Initial"]/*' />
        /// <devdoc>
        ///    The Read method has not been called.
        /// </devdoc>
        Initial      = 0,
        /// <include file='doc\ReadState.uex' path='docs/doc[@for="ReadState.Interactive"]/*' />
        /// <devdoc>
        ///    Read operation is in progress.
        /// </devdoc>
        Interactive  = 1,
        /// <include file='doc\ReadState.uex' path='docs/doc[@for="ReadState.Error"]/*' />
        /// <devdoc>
        ///    An error occurred that prevents the
        ///    read operation from continuing.
        /// </devdoc>
        Error        = 2,
        /// <include file='doc\ReadState.uex' path='docs/doc[@for="ReadState.EndOfFile"]/*' />
        /// <devdoc>
        ///    The end of the stream has been reached
        ///    successfully.
        /// </devdoc>
        EndOfFile    = 3,
        /// <include file='doc\ReadState.uex' path='docs/doc[@for="ReadState.Closed"]/*' />
        /// <devdoc>
        ///    The Close method has been called.
        /// </devdoc>
        Closed        = 4
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\ref.cs ===
//------------------------------------------------------------------------------
// <copyright file="Ref.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml {
    using System;

    internal class Ref {
        public static bool Equal(string strA, string strB) {
#if DEBUG
            // We can't use Debug.Assert in XmlReader.
            if(((object) strA != (object) strB) && String.Equals(strA, strB)) {
                throw new Exception("ASSERT: String atomization failure str='" + strA + "'");
            }
#endif
            return (object) strA == (object) strB;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlattributecdatanormalizer.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlAttributeCDataNormalizer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlAttributeCDataNormalizer.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    using System;
    using System.Text;
 
    internal class XmlAttributeCDataNormalizer : XmlNormalizer {
        // Xml spec 3.3.3 - CDATA normalization:
        // For a character reference, append the referenced character to the normalized value.
        // For a white space character (#x20, #xD, #xA, #x9), append a space character (#x20) to the normalized value.
        // For another character, append the character to the normalized value.

        public XmlAttributeCDataNormalizer( StringBuilder sb ) : base ( sb ) {
        }

        // This method eol-normalizes and CDATA-normalizes the input value
        public override void AppendTextWithEolNormalization( char[] value, int startIndex, int count ) {
            int endIndex = startIndex + count;
            int i = startIndex;
            char prevChar = (char)0x0;

            for (;;) {
                while ( i < endIndex && !XmlCharType.IsWhiteSpace( value[i] ) ) 
                    i++;

                if ( i > startIndex ) {
                    _sb.Append( value, startIndex, i - startIndex );
                    prevChar = (char)0x0;
                }

                if ( i == endIndex )
                    return;

                if ( value[i] != (char) 0xA  ||  prevChar != 0xD ) 
                    _sb.Append( (char) 0x20 );

                prevChar = value[i];
                i++;
                startIndex = i;
            }
        }

        // This method CDATA-normalizes the input value.
        // NOTE: This method assumes that the value has already been eol-normalized.
        public override void AppendText( string value ) { 
            int endIndex = value.Length;
            int i = 0;
            int startIndex = 0;

            for (;;) {
                while ( i < endIndex && !XmlCharType.IsWhiteSpace( value[i] ) ) 
                    i++;

                if ( i > startIndex ) 
                    _sb.Append( value, startIndex, i - startIndex );

                if ( i == endIndex )
                    return;

                _sb.Append( (char) 0x20 );

                i++;
                startIndex = i;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\whitespacehandling.cs ===
//------------------------------------------------------------------------------
// <copyright file="WhiteSpaceHandling.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml
{
    /// <include file='doc\WhiteSpaceHandling.uex' path='docs/doc[@for="WhitespaceHandling"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how whitespace is handled.
    ///    </para>
    /// </devdoc>
    public enum WhitespaceHandling
    {
        /// <include file='doc\WhiteSpaceHandling.uex' path='docs/doc[@for="WhitespaceHandling.All"]/*' />
        /// <devdoc>
        ///    Return Whitespace and SignificantWhitespace
        ///    only. This is the default.
        /// </devdoc>
        All              = 0,
        /// <include file='doc\WhiteSpaceHandling.uex' path='docs/doc[@for="WhitespaceHandling.Significant"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Return just SignificantWhitespace.
        ///    </para>
        /// </devdoc>
        Significant      = 1,
        /// <include file='doc\WhiteSpaceHandling.uex' path='docs/doc[@for="WhitespaceHandling.None"]/*' />
        /// <devdoc>
        ///    Return no Whitespace and no
        ///    SignificantWhitespace.
        /// </devdoc>
        None             = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\validationtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValidationType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml
{
    /// <include file='doc\ValidationType.uex' path='docs/doc[@for="ValidationType"]/*' />
    /// <devdoc>
    ///    Specifies the type of validation to perform.
    /// </devdoc>
    public enum ValidationType
    {
        /// <include file='doc\ValidationType.uex' path='docs/doc[@for="ValidationType.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Auto member does the following:
        ///    </para>
        ///    <list type='number'>
        ///       <item>
        ///          <term>
        ///             If there is no DTD or schema, it will parse the XML
        ///             without validation.
        ///          </term>
        ///       </item>
        ///       <item>
        ///          <term>
        ///             If there is a DTD defined in a &lt;!DOCTYPE ...&gt;
        ///             declaration, it will load the DTD and process the DTD declarations such that
        ///             default attributes and general entities will be made available. General
        ///             entities are only loaded and parsed if they are used (expanded).
        ///          </term>
        ///       </item>
        ///       <item>
        ///          <term>
        ///             If there is no &lt;!DOCTYPE ...&gt; declaration but
        ///             there is an XSD "schemaLocation" attribute, it will load and process those XSD
        ///             schemas and it will return any default attributes defined in those schemas.
        ///          </term>
        ///       </item>
        ///       <item>
        ///          <term>
        ///             If there is no &lt;!DOCTYPE ...&gt; declaration and no XSD
        ///             "schemaLocation" attribute but there are some namespaces using the MSXML
        ///             "x-schema:" URN prefix, it will load and process those schemas and it will
        ///             return any default attributes defined in those schemas.
        ///          </term>
        ///       </item>
        ///    </list>
        /// </devdoc>

        // ue attention
        None,
        
        /// <include file='doc\ValidationType.uex' path='docs/doc[@for="ValidationType.Auto"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Auto,
        /// <include file='doc\ValidationType.uex' path='docs/doc[@for="ValidationType.DTD"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Validate according to DTD.
        ///    </para>
        /// </devdoc>
        DTD,
        /// <include file='doc\ValidationType.uex' path='docs/doc[@for="ValidationType.XDR"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Validate according to DTD.
        ///    </para>
        /// </devdoc>
        XDR,
        /// <include file='doc\ValidationType.uex' path='docs/doc[@for="ValidationType.Schema"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Validate according to W3C XSD schemas , including inline schemas. An error
        ///       is returned if both XDR and XSD schemas are referenced from the same
        ///       document.
        ///    </para>
        /// </devdoc>
        Schema
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlattributecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlAttributeCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Xml {
    using System;
    using System.Collections;
    using System.Diagnostics;
    
    /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a collection of attributes that can be accessed by name or
    ///       index.
    ///    </para>
    /// </devdoc>
    public class XmlAttributeCollection: XmlNamedNodeMap, ICollection {
        internal XmlAttributeCollection( XmlNode parent ): base( parent ) {
        }

        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.this"]/*' />
        /// <devdoc>
        ///    <para>Gets the attribute with the specified index.</para>
        /// </devdoc>
        [System.Runtime.CompilerServices.IndexerName ("ItemOf")]
        public virtual XmlAttribute this[ int i ] {
            get { 
                try {
                    return(XmlAttribute) Nodes[i];
                } catch ( ArgumentOutOfRangeException ) {
                    throw new IndexOutOfRangeException(Res.GetString(Res.Xdom_IndexOutOfRange));
                }
            }
        }

        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>Gets the attribute with the specified name.</para>
        /// </devdoc>
        [System.Runtime.CompilerServices.IndexerName ("ItemOf")]
        public virtual XmlAttribute this[ string name ]
        {
            get { return(XmlAttribute) GetNamedItem(name);}
        }

        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.this2"]/*' />
        /// <devdoc>
        ///    <para>Gets the attribute with the specified LocalName and NamespaceUri.</para>
        /// </devdoc>
        [System.Runtime.CompilerServices.IndexerName ("ItemOf")]
        public virtual XmlAttribute this[ string localName, string namespaceURI ]
        {
            get { return(XmlAttribute) GetNamedItem( localName, namespaceURI );}
        }

        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.SetNamedItem"]/*' />
        /// <devdoc>
        /// <para>Adds a <see cref='System.Xml.XmlNode'/> using its <see cref='System.Xml.XmlNode.Name'/> property</para>
        /// </devdoc>
        public override XmlNode SetNamedItem(XmlNode node) {
            if (node != null && !(node is XmlAttribute))
                throw new ArgumentException(Res.GetString(Res.Xdom_AttrCol_Object));

            int offset = FindNodeOffset( node.LocalName, node.NamespaceURI );
            if (offset == -1) {
                return AddNode( node );
            }
            else {
                XmlNode oldNode = base.RemoveNodeAt( offset );
                InsertNodeAt( offset, node );
                return oldNode;
            }
        }

        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.Prepend"]/*' />
        /// <devdoc>
        ///    <para>Inserts the specified node as the first node in the collection.</para>
        /// </devdoc>
        public virtual XmlAttribute Prepend( XmlAttribute node ) {
            if (node.OwnerDocument != null && node.OwnerDocument != parent.OwnerDocument)
                throw new ArgumentException(Res.GetString(Res.Xdom_NamedNode_Context));

            if (node.OwnerElement != null)
                Detach( node );

            RemoveDuplicateAttribute( node );

            InsertNodeAt( 0, node );
            return node;
        }

        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.Append"]/*' />
        /// <devdoc>
        ///    <para>Inserts the specified node as the last node in the collection.</para>
        /// </devdoc>
        public virtual XmlAttribute Append( XmlAttribute node ) {
            XmlDocument doc = node.OwnerDocument;
            Debug.Assert( doc != null );
            // PERF: Avoid extra validation during Load phase
            if ( doc == null || doc.IsLoading == false ) {
                if ( doc != null && doc != parent.OwnerDocument)
                    throw new ArgumentException(Res.GetString(Res.Xdom_NamedNode_Context));

                if ( node.OwnerElement != null)
                    Detach( node );

                AddNode( node );
            }
            else {
                XmlNode retNode = base.AddNode( node );
                Debug.Assert( retNode == node );
                InsertParentIntoElementIdAttrMap( (XmlAttribute) node );
            }
            
            return node;
        }

        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.InsertBefore"]/*' />
        /// <devdoc>
        ///    <para>Inserts the specified attribute immediately before the specified reference attribute.</para>
        /// </devdoc>
        public virtual XmlAttribute InsertBefore( XmlAttribute newNode, XmlAttribute refNode ) {
            if ( newNode == refNode )
                return newNode;

            if (refNode == null)
                return Append(newNode);

            if (refNode.OwnerElement != parent)
                throw new ArgumentException(Res.GetString(Res.Xdom_AttrCol_Insert));

            if (newNode.OwnerDocument != null && newNode.OwnerDocument != parent.OwnerDocument)
                throw new ArgumentException(Res.GetString(Res.Xdom_NamedNode_Context));

            if (newNode.OwnerElement != null)
                Detach( newNode );

            int offset = FindNodeOffset( refNode.LocalName, refNode.NamespaceURI );
            Debug.Assert( offset != -1 ); // the if statement above guarrentee that the ref node should be in the collection

            int dupoff = RemoveDuplicateAttribute( newNode );
            if ( dupoff >= 0 && dupoff < offset )
                offset--;
            InsertNodeAt( offset, newNode );

            return newNode;
        }

        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.InsertAfter"]/*' />
        /// <devdoc>
        ///    <para>Inserts the specified attribute immediately after the specified reference attribute.</para>
        /// </devdoc>
        public virtual XmlAttribute InsertAfter( XmlAttribute newNode, XmlAttribute refNode ) {
            if ( newNode == refNode )
                return newNode;

            if (refNode == null)
                return Prepend(newNode);

            if (refNode.OwnerElement != parent)
                throw new ArgumentException(Res.GetString(Res.Xdom_AttrCol_Insert));

            if (newNode.OwnerDocument != null && newNode.OwnerDocument != parent.OwnerDocument)
                throw new ArgumentException(Res.GetString(Res.Xdom_NamedNode_Context));

            if (newNode.OwnerElement != null)
                Detach( newNode );

            int offset = FindNodeOffset( refNode.LocalName, refNode.NamespaceURI );
            Debug.Assert( offset != -1 ); // the if statement above guarrentee that the ref node should be in the collection

            int dupoff = RemoveDuplicateAttribute( newNode );
            if ( dupoff >= 0 && dupoff < offset )
                offset--;
            InsertNodeAt( offset+1, newNode );

            return newNode;
        }

        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para> Removes the specified attribute node from the map.</para>
        /// </devdoc>
        public virtual XmlAttribute Remove( XmlAttribute node ) {
            if (nodes != null) {
                int cNodes = nodes.Count;
                for (int offset = 0; offset < cNodes; offset++) {
                    if (nodes[offset] == node) {
                        RemoveNodeAt( offset );
                        return node;
                    }
                }
            }
            return null;
        }   

        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>Removes the attribute node with the specified index from the map.</para>
        /// </devdoc>
        public virtual XmlAttribute RemoveAt( int i ) {
            if (i < 0 || i >= Count || nodes == null)
                return null;

            return(XmlAttribute) RemoveNodeAt( i );
        }

        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.RemoveAll"]/*' />
        /// <devdoc>
        ///    <para>Removes all attributes from the map.</para>
        /// </devdoc>
        public virtual void RemoveAll() {
            int n = Count;
            while (n > 0) {
                n--;
                RemoveAt( n );
            }
        }

        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.ICollection.CopyTo"]/*' />
        /// <internalonly/>
        void ICollection.CopyTo(Array array, int index) {
            for (int i=0, max=Nodes.Count; i<max; i++, index++)
                array.SetValue(nodes[i], index);
        }

        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get { return false; }
        }

        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get { return this; }
        }

        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.ICollection.Count"]/*' />
        /// <internalonly/>
        int ICollection.Count {
            get { return base.Count; }
        }
        
        /// <include file='doc\XmlAttributeCollection.uex' path='docs/doc[@for="XmlAttributeCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(XmlAttribute[] array, int index) {
            for (int i=0, max=Count; i<max; i++, index++)
                array[index] = (XmlAttribute)(((XmlNode)nodes[i]).CloneNode(true));
        }        

        internal override XmlNode AddNode( XmlNode node ) {
            //should be sure by now that the node doesn't have the same name with an existing node in the collection
            RemoveDuplicateAttribute( (XmlAttribute)node );
            XmlNode retNode = base.AddNode( node );
            Debug.Assert( retNode is XmlAttribute );
            InsertParentIntoElementIdAttrMap( (XmlAttribute) node );
            return retNode;
        }

        internal override XmlNode InsertNodeAt( int i, XmlNode node ) {
            XmlNode retNode = base.InsertNodeAt(i, node);
            InsertParentIntoElementIdAttrMap( (XmlAttribute)node );
            return retNode;
        }
        
        internal override XmlNode RemoveNodeAt( int i ) {
            //remove the node without checking replacement
            XmlNode retNode = base.RemoveNodeAt( i );   
            Debug.Assert(retNode is XmlAttribute);
            RemoveParentFromElementIdAttrMap( (XmlAttribute) retNode );
            // after remove the attribute, we need to check if a default attribute node should be created and inserted into the tree
            XmlAttribute defattr = parent.OwnerDocument.GetDefaultAttribute( (XmlElement)parent, retNode.Prefix, retNode.LocalName, retNode.NamespaceURI );
            if ( defattr != null )
                InsertNodeAt( i, defattr );
            return retNode;
        }

        internal virtual void Detach( XmlAttribute attr ) {
            attr.OwnerElement.Attributes.Remove( attr );
        }

        //insert the parent element node into the map
        internal void InsertParentIntoElementIdAttrMap(XmlAttribute attr)
        {
            XmlElement parentElem = parent as XmlElement;
            if (parentElem != null)
            {
                if (parent.OwnerDocument == null)
                    return;
                XmlName attrname = parent.OwnerDocument.GetIDInfoByElement(parentElem.XmlName);
                if (attrname != null && attrname == attr.XmlName)
                    parent.OwnerDocument.AddElementWithId(attr.Value, parentElem); //add the element into the hashtable
            }
        }

        //remove the parent element node from the map when the ID attribute is removed
        internal void RemoveParentFromElementIdAttrMap(XmlAttribute attr)
        {
            XmlElement parentElem = parent as XmlElement;
            if (parentElem != null)
            {
                if (parent.OwnerDocument == null)
                    return;
                XmlName attrname = parent.OwnerDocument.GetIDInfoByElement(parentElem.XmlName);
                if (attrname != null && attrname == attr.XmlName)
                    parent.OwnerDocument.RemoveElementWithId(attr.Value, parentElem); //add the element into the hashtable
            }
        }

        //the function checks if there is already node with the same name existing in the collection
        // if so , remove it because the new one will be inserted to replace this one (could be in different position though ) 
        //  by the calling function later
        internal int RemoveDuplicateAttribute( XmlAttribute attr ) {
            int ind = FindNodeOffset( attr.LocalName, attr.NamespaceURI );
            if ( ind != -1 ) {
                XmlAttribute at = (XmlAttribute) Nodes[ind];
                base.RemoveNodeAt( ind );                
                RemoveParentFromElementIdAttrMap( at );
            }
            return ind;
        }

        internal void ResetParentInElementIdAttrMap( string attrLocalName, string attrNS, string oldVal, string newVal ) {
            XmlElement parentElem = parent as XmlElement;
            Debug.Assert( parentElem != null );
            XmlDocument doc = parent.OwnerDocument;
            Debug.Assert( doc != null );
            XmlName attrname = doc.GetIDInfoByElement(parentElem.XmlName);
            if (attrname != null && attrname.LocalName == attrLocalName && attrname.NamespaceURI == attrNS) {
                doc.RemoveElementWithId(oldVal, parentElem); //add the element into the hashtable
                doc.AddElementWithId(newVal, parentElem);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml {
    using System;
    using System.Xml.XPath;
    using System.Diagnostics;

    /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an attribute of the XMLElement object. Valid and default values for the attribute are defined in a DTD or schema.
    ///    </para>
    /// </devdoc>
    public class XmlAttribute : XmlNode {
        XmlName name;
        XmlLinkedNode lastChild;

        internal XmlAttribute( XmlName name, XmlDocument doc ): base( doc ) {
            Debug.Assert(name!=null);
            Debug.Assert(doc!=null);
            if ( !doc.IsLoading ) {
                XmlDocument.CheckName( name.Prefix );
                XmlDocument.CheckName( name.LocalName );
            }
            if (name.LocalName=="")
                throw new ArgumentException(Res.GetString(Res.Xdom_Attr_Name));
            this.name = name;
        }

        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.XmlAttribute"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected internal XmlAttribute( string prefix, string localName, string namespaceURI, XmlDocument doc )
        : this(doc.GetAttrXmlName( prefix, localName, namespaceURI ), doc) {
        }

        internal XmlName XmlName {
            get { return name;}
        }

        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a duplicate of this node.
        ///    </para>
        /// </devdoc>
        public override XmlNode CloneNode(bool deep) {
            // CloneNode for attributes is deep irrespective of parameter 'deep' value     
            Debug.Assert( OwnerDocument != null );
            XmlAttribute attr = OwnerDocument.CreateAttribute( Prefix, LocalName, NamespaceURI );
            attr.CopyChildren( this, true );
            return attr;
        }

        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.ParentNode"]/*' />
        /// <devdoc>
        ///    <para>Gets the parent of this node (for nodes that can have
        ///       parents).</para>
        /// </devdoc>
        public override XmlNode ParentNode {
            get { return null;}
        }

        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.Name"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the node.</para>
        /// </devdoc>
        public override String Name { 
            get { return name.Name;}
        }

        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override String LocalName { 
            get { return name.LocalName;}
        }

/// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.NamespaceURI"]/*' />
/// <devdoc>Gets the namespace URI of this node.
/// </devdoc>
        public override String NamespaceURI { 
            get { return name.NamespaceURI;} 
        }

        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.Prefix"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the namespace prefix of this node.</para>
        /// </devdoc>
        public override String Prefix { 
            get { return name.Prefix;}
            set { name = name.Identity.GetNameForPrefix( value );}
        }

        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.NodeType"]/*' />
        /// <devdoc>
        ///    <para>Gets the type of the current node.</para>
        /// </devdoc>
        public override XmlNodeType NodeType {
            get { return XmlNodeType.Attribute;}
        }

        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.OwnerDocument"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Xml.XmlDocument'/> that contains this node.</para>
        /// </devdoc>
        public override XmlDocument OwnerDocument { 
            get { 
                return name.Identity.IdentityTable.Document;
            }
        }

        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.Value"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the value of the node.</para>
        /// </devdoc>
        public override String Value { 
            get { return InnerText; }
            set { InnerText = value; } //use InnerText which has perf optimization
        }

        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.InnerText"]/*' />
        public override String InnerText {
            get { return base.InnerText; }
            set {
                String oldVal = base.InnerText;
                base.InnerText = value;
                XmlElement elem = OwnerElement;
                if ( elem != null ) 
                    elem.Attributes.ResetParentInElementIdAttrMap( LocalName, NamespaceURI, oldVal, value );
            }
        }

        internal override bool IsContainer {
            get { return true;}
        }

        internal override XmlLinkedNode LastNode {
            get { return lastChild;}
            set { lastChild = value;}
        }

        internal override bool IsValidChildType( XmlNodeType type ) {
            return(type == XmlNodeType.Text) || (type == XmlNodeType.EntityReference);
        }

        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.Specified"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the value was explicitly set.
        ///    </para>
        /// </devdoc>
        public virtual bool Specified { 
            get { return true;}
        }

        // DOM Level 2
        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.OwnerElement"]/*' />
        /// <devdoc>
        ///    <para>Gets the XmlElement node that contains this
        ///       attribute.</para>
        /// </devdoc>
        public virtual XmlElement OwnerElement { 
            get { 
                if (parentNode == NullNode)
                    return null;
                return ( XmlElement )parentNode;
            }
        }

        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.InnerXml"]/*' />
        /// <devdoc>
        ///    Gets or sets the markup representing just
        ///    the children of this node.
        /// </devdoc>
        public override string InnerXml {
            get {
                return base.InnerXml;
            }
            set {
                RemoveAll();
                XmlLoader loader = new XmlLoader();
                loader.LoadInnerXmlAttribute( this, value );
            }
        }

        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.WriteTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteTo(XmlWriter w) {
            w.WriteStartAttribute( Prefix, LocalName, NamespaceURI );
            WriteContentTo(w);
            w.WriteEndAttribute();
        }

        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.WriteContentTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves all the children of the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteContentTo(XmlWriter w) {
            foreach( XmlNode n in this )
            n.WriteTo( w );
        }

        /// <include file='doc\XmlAttribute.uex' path='docs/doc[@for="XmlAttribute.BaseURI"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String BaseURI {
            get {
                if ( OwnerElement != null )
                    return OwnerElement.BaseURI;
                return String.Empty;
            }
        }
        
        internal override XmlSpace XmlSpace {
            get {
                if ( OwnerElement != null )
                    return OwnerElement.XmlSpace;
                return XmlSpace.None;
            }
        }

        internal override String XmlLang {
            get {
                if ( OwnerElement != null )
                    return OwnerElement.XmlLang;
                return String.Empty;
            }
        }
        internal override XPathNodeType XPNodeType { 
            get {
                if ( NamespaceURI == XmlDocument.strReservedXmlns )
                    return XPathNodeType.Namespace; 
                return XPathNodeType.Attribute;
            }
        }

        internal override string XPLocalName { 
            get { 
                if ( LocalName == XmlDocument.strXmlns )
                    return string.Empty;
                return LocalName; 
            } 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlchildenumerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlChildEnumerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml {
    using System.Collections;

    /// <include file='doc\XmlChildEnumerator.uex' path='docs/doc[@for="XmlChildEnumerator"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal sealed class XmlChildEnumerator: IEnumerator {
        internal XmlNode container;
        internal XmlNode child;
        internal bool isFirst;

        internal XmlChildEnumerator( XmlNode container ) {
            this.container = container;
            this.child = container.FirstChild;
            this.isFirst = true;
        }

        bool IEnumerator.MoveNext() {
            return this.MoveNext();
        }

        /// <include file='doc\XmlChildEnumerator.uex' path='docs/doc[@for="XmlChildEnumerator.MoveNext"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal bool MoveNext() {
            if (isFirst) {
                child = container.FirstChild;
                isFirst = false;
            }
            else if (child != null) {
                child = child.NextSibling;
            }

            return child != null;
        }

        void IEnumerator.Reset() {
            isFirst = true;
            child = container.FirstChild;
        }

        object IEnumerator.Current {
            get {
                if (isFirst || child == null)
                    throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));

                return child;
            }
        }

        /// <include file='doc\XmlChildEnumerator.uex' path='docs/doc[@for="XmlChildEnumerator.Current"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal XmlNode Current {
            get {
                if (isFirst || child == null)
                    throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));

                return child;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlbasictokeninfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlBasicTokenInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Xml {

    using System;
    using System.Text;
    using System.Xml.Schema;

/*
 * basic token info class
 * 
 * 
 * @internalonly
 * 
 */
    internal class XmlBasicTokenInfo {
        protected XmlNamespaceManager _NsMgr;  // namespace manager
        protected XmlScanner _Scanner;


        //
        // basic token info
        //
        protected XmlNodeType     _NodeType;        
        protected object          _SchemaType;
        protected object          _TypedValue;
        protected int             _Depth;
        protected int             _LineNum;
        protected int             _LinePos;

        protected XmlBasicTokenInfo() {
            _NodeType = XmlNodeType.None;
            _Depth = 0;        
            _LineNum = 0;
            _LinePos = 0;
        } 

        internal XmlBasicTokenInfo(XmlScanner scanner, XmlNamespaceManager nsMgr) : this() {
            _NsMgr = nsMgr;
            _Scanner = scanner;                
        } 

        internal XmlBasicTokenInfo(XmlScanner scanner, XmlNamespaceManager nsMgr, XmlNodeType type, int depth) {
            _Scanner = scanner;                
            _NsMgr = nsMgr;        
            _NodeType = type;        
            _Depth = depth;                
            _LineNum = 0;
            _LinePos = 0;
        } 


        internal XmlNodeType NodeType {
            //
            // perf: NodeType probably does not need to be virtual
            // 
            get {
                return _NodeType;
            }
            set {
                _NodeType = value;
            }
        }

        internal virtual String Name {
            get {           
                return String.Empty;
            }
            set {           
                ;
            }
        }

        internal virtual String NameWPrefix {
            get {           
                return String.Empty;
            }
            set {           
                ;
            }
        }

        internal virtual String Prefix {
            get {
                return String.Empty;
            }
            set {           
                ;
            }
        }

        internal virtual String Namespaces {
            get {
                return String.Empty;
            }
            set {           
                ;
            }
        }

        internal virtual object SchemaType {
            get {
                return _SchemaType;
            }
            set {
                _SchemaType = value;
            }
        }

        internal virtual object TypedValue {
            get {
                return _TypedValue;
            }
            set {
                _TypedValue = value;
            }
        }

        internal virtual int Depth {
            get {
                return _Depth;
            }
            set {
                _Depth = value;                          
            }
        }

        internal virtual String Value {
            get {
                return String.Empty;
            }
            set {
                ;
            }
        }

        internal virtual void SetValue(XmlNormalizer normalizer) {
        }

        internal virtual String GetValue() {
            return String.Empty;
        }

        internal virtual String RawValue {
            get {
                return String.Empty;
            }
            set {
                ;
            }
        }

        internal virtual bool IsEmpty {
            get {
                return false;
            }
            set {           
                ;
            }
        }

        internal virtual int LinePos {
            get {
                return _LinePos;
            }
            set {
                _LinePos = value;
            }
        }

        internal virtual int LineNum {
            get {
                return _LineNum;
            }
            set {
                _LineNum = value;
            }
        }

        internal virtual bool IsAttributeText {
            get {
                return false;
            }
            set {            
            }
        }

        internal virtual bool IsDefault {
            get {
                return false;
            }
            set {            
            }
        }

        internal virtual XmlScanner Scanner {
            set { _Scanner = value;}         
        }

        internal virtual char QuoteChar {
            get { return '"';}
            set {}         
        }

        internal virtual ValueContainEntity ValueContainEntity
        {
            get { return ValueContainEntity.None; }
            set { ;}
        }

        internal virtual bool NsAttribute
        {
            get { return false;}
            set { ;}
        }

    } // XmlBasicTokenInfo
} // System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlcomment.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlComment.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml {
    using System.Xml.XPath;
    using System.Diagnostics;

    /// <include file='doc\XmlComment.uex' path='docs/doc[@for="XmlComment"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the content of an XML comment.
    ///    </para>
    /// </devdoc>
    public class XmlComment: XmlCharacterData {
        /// <include file='doc\XmlComment.uex' path='docs/doc[@for="XmlComment.XmlComment"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected internal XmlComment( string comment, XmlDocument doc ): base( comment, doc ) {
        }

        /// <include file='doc\XmlComment.uex' path='docs/doc[@for="XmlComment.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node.
        ///    </para>
        /// </devdoc>
        public override String Name {
            get { return XmlDocument.strCommentName;}
        }

        /// <include file='doc\XmlComment.uex' path='docs/doc[@for="XmlComment.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the current node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override String LocalName {
            get { return XmlDocument.strCommentName;}
        }

        /// <include file='doc\XmlComment.uex' path='docs/doc[@for="XmlComment.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType {
            get { return XmlNodeType.Comment;}
        }

        /// <include file='doc\XmlComment.uex' path='docs/doc[@for="XmlComment.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a duplicate of this node.
        ///    </para>
        /// </devdoc>
        public override XmlNode CloneNode(bool deep) {
            Debug.Assert( OwnerDocument != null );
            return OwnerDocument.CreateComment( Data );
        }

        /// <include file='doc\XmlComment.uex' path='docs/doc[@for="XmlComment.WriteTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteTo(XmlWriter w) {
            w.WriteComment( Data );
        }

        /// <include file='doc\XmlComment.uex' path='docs/doc[@for="XmlComment.WriteContentTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves all the children of the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteContentTo(XmlWriter w) {
            // Intentionally do nothing
        }

        internal override XPathNodeType XPNodeType { get { return XPathNodeType.Comment; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlcharacterdata.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlCharacterData.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.Xml {
    using System.Diagnostics;
    using System.Text;
    using System.Xml.XPath;

    /// <include file='doc\XmlCharacterData.uex' path='docs/doc[@for="XmlCharacterData"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides text-manipulation methods that are used by several classes.
    ///    </para>
    /// </devdoc>
    public abstract class XmlCharacterData : XmlLinkedNode {
        object data; // string or StringBuilder only

        /// <include file='doc\XmlCharacterData.uex' path='docs/doc[@for="XmlCharacterData.XmlCharacterData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        //base(doc) will throw exception if doc is null.
        protected internal XmlCharacterData( string data, XmlDocument doc ): base( doc ) {
            this.data = data;
        }

        /// <include file='doc\XmlCharacterData.uex' path='docs/doc[@for="XmlCharacterData.Value"]/*' />
        /// <devdoc>
        /// <para>
        ///        Gets or sets the value of the node.
        /// </para>
        /// </devdoc>
        public override String Value {
            get { return Data;}
            set { Data = value;}
        }

        /// <include file='doc\XmlCharacterData.uex' path='docs/doc[@for="XmlCharacterData.InnerText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the concatenated values of the node and
        ///       all its children.
        ///    </para>
        /// </devdoc>
        public override string InnerText {
            get { return Value;}
            set { Value = value;}
        }

        /// <include file='doc\XmlCharacterData.uex' path='docs/doc[@for="XmlCharacterData.Data"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Contains this node's data.
        ///    </para>
        /// </devdoc>
        public virtual string Data {
            get {
                if (data != null) {
                    if (data is StringBuilder)
                        data = ((StringBuilder)data).ToString();

                    return(string) data;
                }
                else {
                    return String.Empty;
                }
            }

            set {
                XmlNode parent = ParentNode;
                XmlNodeChangedEventArgs args = GetEventArgs( this, parent, parent, XmlNodeChangedAction.Change );

                if (args != null)
                    BeforeEvent( args );

                data = value;

                if (args != null)
                    AfterEvent( args );
            }
        }

        /// <include file='doc\XmlCharacterData.uex' path='docs/doc[@for="XmlCharacterData.Length"]/*' />
        /// <devdoc>Gets the length of the data, in characters.
        /// </devdoc>
        public virtual int Length {
            get {
                if (data != null) {
                    if (data is string)
                        return((string)data).Length;
                    else
                        return((StringBuilder)data).Length;
                }
                return 0;
            }
        }

        /// <include file='doc\XmlCharacterData.uex' path='docs/doc[@for="XmlCharacterData.Substring"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a substring of the full string from the specified range.
        ///    </para>
        /// </devdoc>
        public virtual String Substring(int offset, int count) {
            int len = Length;
            if (len > 0) {
                if (len < (offset + count)) {
                    count = len - offset;
                }

                if (data is string) {
                    return((string)data).Substring( offset, count );
                }
                else if (data is StringBuilder) {
                    return((StringBuilder)data).ToString( offset, count );
                }
            }
            return String.Empty;
        }

        internal StringBuilder Builder {
            get {
                if (data == null) {
                    data = new StringBuilder();
                }
                else if (data is string) {
                    data = new StringBuilder( (string) data );
                }

                return(StringBuilder) data;
            }
        }

        /// <include file='doc\XmlCharacterData.uex' path='docs/doc[@for="XmlCharacterData.AppendData"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Appends the specified string to the end of the character
        ///       data of the node.
        ///    </para>
        /// </devdoc>
        public virtual void AppendData(String strData) {
            XmlNode parent = ParentNode;
            XmlNodeChangedEventArgs args = GetEventArgs( this, parent, parent, XmlNodeChangedAction.Change );

            if (args != null)
                BeforeEvent( args );

            Builder.Append(strData);

            if (args != null)
                AfterEvent( args );
        }

        /// <include file='doc\XmlCharacterData.uex' path='docs/doc[@for="XmlCharacterData.InsertData"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Insert the specified string at the specified character offset.
        ///    </para>
        /// </devdoc>
        public virtual void InsertData(int offset, string strData) {
            XmlNode parent = ParentNode;
            XmlNodeChangedEventArgs args = GetEventArgs( this, parent, parent, XmlNodeChangedAction.Change );

            if (args != null)
                BeforeEvent( args );

            Builder.Insert(offset, strData);

            if (args != null)
                AfterEvent( args );
        }

        /// <include file='doc\XmlCharacterData.uex' path='docs/doc[@for="XmlCharacterData.DeleteData"]/*' />
        /// <devdoc>
        ///    Remove a range of characters from the node.
        /// </devdoc>
        public virtual void DeleteData(int offset, int count) {
            //Debug.Assert(offset >= 0 && offset <= Length);

            int len = Length;
            if (len > 0) {
                if (len < (offset + count)) {
                    count = Math.Max ( len - offset, 0);
                }
            }

            XmlNode parent = ParentNode;
            XmlNodeChangedEventArgs args = GetEventArgs( this, parent, parent, XmlNodeChangedAction.Change );

            if (args != null)
                BeforeEvent( args );

            Builder.Remove(offset, count);

            if (args != null)
                AfterEvent( args );
        }

        /// <include file='doc\XmlCharacterData.uex' path='docs/doc[@for="XmlCharacterData.ReplaceData"]/*' />
        /// <devdoc>Replace the specified number of characters starting at the specified offset with the
        ///    specified string.
        /// </devdoc>
        public virtual void ReplaceData(int offset, int count, String strData) {
            //Debug.Assert(offset >= 0 && offset <= Length);

            int len = Length;
            if (len > 0) {
                if (len < (offset + count)) {
                    count = Math.Max ( len - offset, 0);
                }
            }

            XmlNode parent = ParentNode;
            XmlNodeChangedEventArgs args = GetEventArgs( this, parent, parent, XmlNodeChangedAction.Change );

            if (args != null)
                BeforeEvent( args );

            Builder.Remove( offset, count );
            Builder.Insert( offset, strData );

            if (args != null)
                AfterEvent( args );
        }

        internal bool CheckOnData( string data ) {
            for (int i = 0; i < data.Length; i++) {
                if ( !XmlCharType.IsWhiteSpace( data[i] ) )
                    return false;
            }
            return true;
        }

        /// <include file='doc\XmlCharacterData.uex' path='docs/doc[@for="XmlCharacterData.DecideXPNodeTypeForWhitespace"]/*' />
        internal bool DecideXPNodeTypeForTextNodes( XmlNode node, ref XPathNodeType xnt ) {
            //returns true - if all siblings of the node are processed else returns false.
            //The reference XPathNodeType argument being passed in is the watermark that
            //changes according to the siblings nodetype and will contain the correct
            //nodetype when it returns.

            Debug.Assert( XmlDocument.IsTextNode( node.NodeType ) || ( node.ParentNode != null && node.ParentNode.NodeType == XmlNodeType.EntityReference ) );
            while( node != null ) {
                switch( node.NodeType ) {
                    case XmlNodeType.Whitespace :
                        break;
                    case XmlNodeType.SignificantWhitespace :
                        xnt = XPathNodeType.SignificantWhitespace;
                        break;
                    case XmlNodeType.Text :
                    case XmlNodeType.CDATA :
                        xnt = XPathNodeType.Text;
                        return false;
                    case XmlNodeType.EntityReference :
                        bool ret = DecideXPNodeTypeForTextNodes( node.FirstChild, ref xnt );
                        if( !ret ) {
                            return false;
                        }
                        break;
                    default :
                        return false;
                }
                node = node.NextSibling;
            }
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlattributetokeninfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlAttributeTokenInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.Text;
using System.Xml.Schema;

namespace System.Xml {

    using System.Diagnostics;

#if !POST_RTM
    internal enum ValueContainEntity {
#else
    public enum ValueContainEntity {
#endif    
        None,
        NotResolved,
        Resolved,            
    }

/*
 * This class stores the pure data aspect of the token
 *
 *
 * @internalonly
 *
 */
    internal class XmlAttributeTokenInfo : XmlBasicTokenInfo {

        protected String    _NameWPrefix;             // always atomalize
        protected String    _RawValue;
        protected int       _ValueOffset;             // store the offset of the value
        protected int       _ValueLength;             // store the lenght of the value

        protected String    _Value;

        protected String    _IgnoreValue;
        protected String    _ExpandValue;

        protected char      _QuoteChar;
        protected ValueContainEntity   _ValueContainEntity;          
      
        protected bool      _NsAttribute;

        protected bool        _IsDefault;

        private bool        _HasNormalize;
        private bool        _NormalizeText;
        private bool        _IsCDataNormalized;

        private int         _ValueLineNum;
        private int         _ValueLinePos;

        internal XmlAttributeTokenInfo() {
            _NameWPrefix = String.Empty;

            _ValueContainEntity = ValueContainEntity.None;
            _QuoteChar = '"';
            _ValueLineNum = 0;
            _ValueLinePos = 0;

        }

        internal XmlAttributeTokenInfo(XmlScanner scanner, XmlNamespaceManager nsMgr, XmlNodeType type, bool nor) : this() {
            _NsMgr = nsMgr;
            _Scanner = scanner;        
            _NodeType = type;

            _NormalizeText = nor;
            _HasNormalize = !_NormalizeText;
            _IsCDataNormalized = false;
        }

        internal virtual void SetName(XmlScanner scanner, String nameWPrefix, int nameColonPos, int depth, bool isDefault) {
            _Scanner = scanner;        
            _Depth = depth;
            _IsDefault = isDefault;    
            _NameWPrefix = nameWPrefix;
        }

        internal void SetValue(XmlScanner scanner, String value, int offset, int length, bool bIsCDataNormalized) {
            _Scanner = scanner;
            _ExpandValue = value;
            _Value = null;
            _IgnoreValue = null;
            _ValueOffset = offset;
            _ValueLength = length;
            _RawValue = value;

            _HasNormalize = !_NormalizeText;
            _IsCDataNormalized = bIsCDataNormalized;
            _SchemaType = null;
            _TypedValue = null;
        }

        internal override String GetValue() {
            _Value = this.ExpandValue;  // expand and normalize
            return _Value;
        }

        //
        // this function is for default attribute only
        //
        internal virtual String GenerateNS() {
            return String.Empty;
        }


        internal String ExpandValue
        {
            get
            {
                bool isCDATA = IsCDATA;
                //we want non null _ExpandValue
                if (_ExpandValue == null) {                   //if null 
                    _ExpandValue = RawValue;
                }
                //at this stage _ExpandValue must be non null
                if (!_HasNormalize){                            //normalization needed somewhere
                    if (isCDATA) {
                        if ( !_IsCDataNormalized ) 
                            _ExpandValue = XmlComplianceUtil.CDataAttributeValueNormalization(_ExpandValue);
                    }
                    else {
                        if ( _IsCDataNormalized )
                            _ExpandValue = NormalizeNonCDataValue( _ExpandValue );
                        else
                            _ExpandValue = XmlComplianceUtil.NotCDataAttributeValueNormalization(_ExpandValue);
                    }
                    _HasNormalize = true;                       //normalization no longer needed(since _ExpandValue contains normalized value)
                }
                return _ExpandValue;
            }
            set
            {                
                _ExpandValue = value;
                RawValue = value;
                _HasNormalize = !_NormalizeText;
            }
        }
        
        internal String IgnoreValue
        {
            get
            {
                bool isCDATA = IsCDATA;
                if (_IgnoreValue == null) {
                    if (_ValueLength > 0) {                 
                        if (!_HasNormalize) {
                            if (isCDATA) 
                                _IgnoreValue = XmlComplianceUtil.CDataAttributeValueNormalization(
                                                _Scanner.InternalBuffer, _ValueOffset - _Scanner.AbsoluteOffset, _ValueLength);
                            else
                                _IgnoreValue = XmlComplianceUtil.NotCDataAttributeValueNormalization(
                                                _Scanner.InternalBuffer, _ValueOffset - _Scanner.AbsoluteOffset, _ValueLength);
                            _HasNormalize = true;                        
                        }
                        else {
                            _IgnoreValue = new String(_Scanner.InternalBuffer, _ValueOffset - _Scanner.AbsoluteOffset, _ValueLength);
                        }                                 
                    }
                    else { 
                        // this is already normalizied if normalization is true                    
                        _IgnoreValue = this.ExpandValue;
                    }
                }
                else if (!_HasNormalize){
                    if (isCDATA)
                        if ( !_IsCDataNormalized )
                            _IgnoreValue = XmlComplianceUtil.CDataAttributeValueNormalization(_IgnoreValue);
                    else {
                        if ( _IsCDataNormalized ) 
                            _IgnoreValue = NormalizeNonCDataValue(_IgnoreValue);
                        else
                            _IgnoreValue = XmlComplianceUtil.NotCDataAttributeValueNormalization(_IgnoreValue);
                    }
                    _HasNormalize = true;
                }
                return _IgnoreValue;
            }
            set
            {
                _IgnoreValue = value;
                _IsCDataNormalized = false;
                _HasNormalize = !_NormalizeText;
            }
        }

        internal override String Value
        {
            get { return GetValue(); }
            set {
                _ExpandValue = value;
                _IgnoreValue = value;
                _HasNormalize = !_NormalizeText;
                _IsCDataNormalized = false;
                _SchemaType = null;
                _TypedValue = null;
            }
        }

        internal void SetNormalizedValue( string value ) {
            _ExpandValue = value;
            _IgnoreValue = value;
            _HasNormalize = true;
            _IsCDataNormalized = true;
            _SchemaType = null;
            _TypedValue = null;
        }

        internal override String RawValue {
            get {
                if (null == _RawValue) { 
                    _RawValue = new String(_Scanner.InternalBuffer, _ValueOffset - _Scanner.AbsoluteOffset, _ValueLength);
                }
                return _RawValue;
            }
            set {
                _RawValue = value;
                ;
            }
        }


        internal virtual void FixDefaultNSNames() {
        }

        internal virtual void FixNSNames() {
        }

        internal virtual void FixNames() {
        }

        internal override String Name
        {
            get { return _NameWPrefix; }
            set { _NameWPrefix = value; }
        }

        internal virtual int NameColonPos
        {
            get { return 0; }
            set { ; }
        }

        internal override String NameWPrefix
        {
            get { return _NameWPrefix; }
            set { _NameWPrefix = value; }
        }

        internal override String Prefix
        {
            get { return String.Empty; }
            set { ; }
        }

        internal override String Namespaces
        {
            get { return String.Empty;}
            set { ;}
        }

        internal override void SetValue( XmlNormalizer normalizer ) {
            string val = normalizer.ToString();
            _ExpandValue = val;
            _IgnoreValue = val;
            _HasNormalize = true;
            _IsCDataNormalized = true;
            _SchemaType = null;
            _TypedValue = null;
        }

        internal override ValueContainEntity ValueContainEntity
        {
            get { return _ValueContainEntity;}
            set { _ValueContainEntity = value;}
        }

        internal override char QuoteChar
        {
            get { return _QuoteChar;}
            set { _QuoteChar = value;}
        }

        internal override bool IsDefault
        {
            get { return _IsDefault; }
            set { _IsDefault = value;}
        }

        internal override bool NsAttribute
        {
            get { return _NsAttribute;}
            set { _NsAttribute = value;}
        }

        internal int ValueOffset
        {
            get { return _ValueOffset; }
        }

        internal bool Normalization
        {
            set {
                if (value != _NormalizeText) {
                    _NormalizeText = value;
                    _HasNormalize = !_NormalizeText;
                    _ExpandValue = null;
                }
            }
        }

        internal int ValueLinePos {
            get {
                return _ValueLinePos;
            }
            set {
                _ValueLinePos = value;
            }
        }

        internal int ValueLineNum {
            get {
                return _ValueLineNum;
            }
            set {
                _ValueLineNum = value;
            }
        }

        internal override bool IsAttributeText
        {
            get { return true; }
            set { ;            }
        }

        private bool IsCDATA
        {
            get { return _SchemaType == null || (_SchemaType is XmlSchemaDatatype && XmlTokenizedType.CDATA == ((XmlSchemaDatatype)_SchemaType).TokenizedType); }
            set { ;}
        }

        static public string NormalizeNonCDataValue( string Value ) {
            StringBuilder sb = null;
            int i = 0;
            int len = Value.Length;

            while ( i < len && Value[i] == (char)0x20 )
                i++;

            if ( i == len )
                return " ";

            int startIndex = i;
            for (;;) {
                while ( i < len && Value[i] != (char)0x20 )
                    i++;

                if ( i > startIndex ) {
                    if ( i == len && startIndex == 0 )
                        return Value;
                    else {
                        if ( sb == null ) 
                            sb = new StringBuilder();
                        sb.Append( Value, startIndex, i - startIndex );
                    }
                }

                if ( i == len )
                    break;

                i++;
                while ( i < len && Value[i] == (char)0x20 )
                    i++;

                if ( i == len )
                    break;
                else {
                    Debug.Assert( sb != null );
                    sb.Append( (char)0x20 );
                }
                startIndex = i;
            }

            return sb.ToString();
        }

        internal bool IsCDataNormalized { 
            set { _IsCDataNormalized = value; }
        }

    } // XmlAttributeTokenInfo
} // System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlchildnodes.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlChildNodes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.Xml {
    using System.Collections;

    internal class XmlChildNodes: XmlNodeList {
        private XmlNode container;

        public XmlChildNodes( XmlNode container ) {
            this.container = container;
        }

        public override XmlNode Item( int i ) {
            // Out of range indexes return a null XmlNode
            if (i < 0)
                return null;
            for (XmlNode n = container.FirstChild; n != null; n = n.NextSibling, i--) {
                if (i == 0)
                    return n;
            }
            return null;
        }

        public override int Count {
            get {
                int c = 0;
                for (XmlNode n = container.FirstChild; n != null; n = n.NextSibling) {
                    c++;
                }
                return c;
            }
        }

        public override IEnumerator GetEnumerator() {
            return new XmlChildEnumerator( container );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlcdatasection.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlCDATASection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml {
    using System;
    using System.Text;
    using System.Diagnostics;
    using System.Xml.XPath;

    /// <include file='doc\XmlCDATASection.uex' path='docs/doc[@for="XmlCDataSection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Used to quote or escape blocks of text to keep that text from being
    ///       interpreted as markup language.
    ///    </para>
    /// </devdoc>
    public class XmlCDataSection : XmlCharacterData {
        /// <include file='doc\XmlCDATASection.uex' path='docs/doc[@for="XmlCDataSection.XmlCDataSection"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected internal XmlCDataSection( string data, XmlDocument doc ): base( data, doc ) {
        }

        /// <include file='doc\XmlCDATASection.uex' path='docs/doc[@for="XmlCDataSection.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node.
        ///    </para>
        /// </devdoc>
        public override String Name { 
            get {return XmlDocument.strCDataSectionName;}
        }
        /// <include file='doc\XmlCDATASection.uex' path='docs/doc[@for="XmlCDataSection.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override String LocalName { 
            get {return XmlDocument.strCDataSectionName;}
        }

        /// <include file='doc\XmlCDATASection.uex' path='docs/doc[@for="XmlCDataSection.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType {
            get { return XmlNodeType.CDATA;}
        }

        /// <include file='doc\XmlCDATASection.uex' path='docs/doc[@for="XmlCDataSection.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a duplicate of this node.
        ///    </para>
        /// </devdoc>
        public override XmlNode CloneNode(bool deep) {
            Debug.Assert( OwnerDocument != null );
            return OwnerDocument.CreateCDataSection( Data );
        }

        /// <include file='doc\XmlCDATASection.uex' path='docs/doc[@for="XmlCDataSection.WriteTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteTo(XmlWriter w) {
            w.WriteCData( Data );
        }

        /// <include file='doc\XmlCDATASection.uex' path='docs/doc[@for="XmlCDataSection.WriteContentTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteContentTo(XmlWriter w) {
            // Intentionally do nothing
        }

        internal override XPathNodeType XPNodeType { 
            get { return XPathNodeType.Text; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlcomplianceutil.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlComplianceUtil.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.IO;

namespace System.Xml {
    using System.Text;

    internal sealed class XmlComplianceUtil {
        internal static String EndOfLineNormalization(char[] value, int index, int len) {
            char prevChar = (char)0xD;
            char replaceChar = (char)0xA;
            char patternChar = (char)0xD;
            int endPos = index + len;

            if (len < 1)
                return String.Empty;

            //
            // does not help out perf by doing IndexOf first
            // because IndexOf is looking through all the characters anyway
            //
            // if no 0xD is found , no need to do end of line handling
            int pos = Array.IndexOf(value, patternChar, index, len);
            if (pos == -1)
                return new String(value, index, len);

            int i = pos;
            int startPos = index;
            StringBuilder norValue = null;
            for (; i < endPos; i++) {
                switch (value[i]) {
                    case (char) 0xD:
                        if (norValue == null)
                            norValue = new StringBuilder(len);
                        if (i > startPos) {
                            norValue.Append(value, startPos, i-startPos);
                        }
                        norValue.Append(replaceChar);
                        startPos = i+1;
                        break;

                    case (char) 0xA:
                        if (prevChar == patternChar)
                            startPos = i+1;
                        break;
                    default:
                        break;
                }
                prevChar = value[i];
            }
            if (i > startPos) {
               if (norValue == null) {
                   return new string(value, startPos, i-startPos);
               }
               norValue.Append(value, startPos, i-startPos);
            }
            if (norValue == null)
                return String.Empty;
            return norValue.ToString();
        }

        internal static String NotCDataAttributeValueNormalization(char[] value, int index, int len) {
            char replaceChar = (char)0x20;
            int endPos = index + len;

            if (len < 1)
               return String.Empty;

            int startPos = index;

            StringBuilder norValue = null;

            while (value[startPos] == 0x20 || value[startPos] == 0xD ||
                   value[startPos] == 0x9 || value[startPos] == 0xA) {
                startPos++;
                if (startPos == endPos)
                    return String.Copy(" ");
            }

            int i = startPos;
            for (; i < endPos; i++) {
                switch (value[i]) {
                    case (char) 0xD:
                    case (char) 0x9:
                    case (char) 0xA:
                        int j = i + 1;
                        while (j < endPos &&
                                (value[j] == 0x20 || value[j] == 0xD ||
                                 value[j] == 0x9 || value[j] == 0xA)) {
                            j++;
                        }
                        if (j == endPos) {
                            if (norValue == null)
                                norValue = new StringBuilder(i-startPos);
                            norValue.Append(value, startPos, i-startPos);
                            goto cleanup;
                        }
                        else if (j > i) {
                            if (norValue == null)
                                norValue = new StringBuilder(len);
                            norValue.Append(value, startPos, i-startPos);
                            norValue.Append(replaceChar);
                            startPos = j;
                            i = j - 1;
                        }
                        break;

                    case (char) 0x20:
                        j = i + 1;
                        while (j < endPos &&
                                (value[j] == 0x20 || value[j] == 0xD ||
                                 value[j] == 0x9 || value[j] == 0xA)) {
                            j++;
                        }
                        if (j == endPos) {
                            if (norValue == null)
                                norValue = new StringBuilder(i-startPos);
                            norValue.Append(value, startPos, i-startPos);
                            goto cleanup;
                        }
                        else if (j > i+1) {
                            if (norValue == null)

                                norValue = new StringBuilder(len);
                            norValue.Append(value, startPos, i-startPos+1);
                            startPos = j;
                            i = j - 1;
                        }
                        break;

                    default:
                        break;
                }
            }
            if (i > startPos) {
               if (norValue == null) {
                   return new string(value, startPos, i-startPos);
               }
               norValue.Append(value, startPos, i-startPos);
            }
cleanup:
            if (norValue == null)
                return String.Empty;
            return norValue.ToString();
        }

        internal static String CDataAttributeValueNormalization(char[] value, int index, int len) {
            char prevChar = (char)0x0;
            char replaceChar = (char)0x20;
            char patternChar = (char)0xD;
            int endPos = index + len;

            if (len < 1)
               return String.Empty;

            int i= index;
            int startPos = index;

            StringBuilder norValue = null;

            for (; i < endPos; i++) {
                switch (value[i]) {
                    case (char) 0xA:
                        if (prevChar == patternChar) {
                            startPos = i+1;
                        }
                        else {
                            goto case (char) 0x20;
                        }
                        break;
                    case (char) 0x20:
                    case (char) 0xD:
                    case (char) 0x9:
                        if (norValue == null)
                            norValue = new StringBuilder(len);
                        if (i > startPos) {
                            norValue.Append(value, startPos, i-startPos);
                        }
                        norValue.Append(replaceChar);
                        startPos = i+1;
                        break;

                    default:
                        break;
                }
                prevChar = value[i];
            }
            if (i > startPos) {
               if (norValue == null) {
                   return new string(value, startPos, i-startPos);
               }
               norValue.Append(value, startPos, i-startPos);
            }
            return norValue.ToString();
        }

        internal static String EndOfLineNormalization(String value) {
            return EndOfLineNormalization(value.ToCharArray(), 0, value.Length);
        }

        internal static String NotCDataAttributeValueNormalization(String value) {
            return NotCDataAttributeValueNormalization(value.ToCharArray(), 0, value.Length);
        }

        internal static String CDataAttributeValueNormalization(String value) {
            return CDataAttributeValueNormalization(value.ToCharArray(), 0, value.Length);
        }

        internal static bool IsValidLanguageID(char[] value, int startPos, int length) {
            char ch;
            bool fSeenLetter = false;
            int i = startPos;
            int len = length;

            if (len < 2)
                goto error;

            ch = value[i];
            if (XmlCharType.IsLetter(ch)) {
                if (XmlCharType.IsLetter(value[++i])) {
                    if (2 == len)
                        return true;
                    len--;
                    i++;
                }
                else if (('I' != ch && 'i' != ch) && ('X' != ch && 'x' != ch) ) {  //IANA or custom Code
                    goto error;
                }


                if ('-' != value[i])
                    goto error;

                len -= 2;

                while (len-- > 0) {
                    ch = value[++i];
                    if (XmlCharType.IsLetter(ch)) {
                        fSeenLetter = true;
                    }
                    else if ('-' == ch && fSeenLetter) {
                        fSeenLetter = false;
                    }
                    else {
                        goto error;
                    }
                }
                if (fSeenLetter)
                    return true;
            }
            error:
            return false;
        }

    };
} // namespace System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlconvert.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlConvert.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml {
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Globalization;
	using System.Xml.Schema;
    using System.Diagnostics;
    using System.Collections;

    /// <include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert"]/*' />
    /// <devdoc>
    ///    Encodes and decodes XML names according to
    ///    the "Encoding of arbitrary Unicode Characters in XML Names" specification.
    /// </devdoc>
    public class XmlConvert {
        /// <include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.EncodeName"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Converts names, such
        ///       as DataTable or
        ///       DataColumn names, that contain characters that are not permitted in
        ///       XML names to valid names.</para>
        /// </devdoc>
        public static string EncodeName(string name) {
            return EncodeName(name, true/*Name_not_NmToken*/, false/*Local?*/);
        }

        /// <include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.EncodeNmToken"]/*' />
        /// <devdoc>
        ///    <para> Verifies the name is valid
        ///       according to production [7] in the XML spec.</para>
        /// </devdoc>
        public static string EncodeNmToken(string name) {
            return EncodeName(name, false/*Name_not_NmToken*/, false/*Local?*/);
        }
        /// <include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.EncodeLocalName"]/*' />
        /// <devdoc>
        ///    <para>Converts names, such as DataTable or DataColumn names, that contain 
        ///       characters that are not permitted in XML names to valid names.</para>
        /// </devdoc>
        public static string EncodeLocalName(string name) {
            return EncodeName(name, true/*Name_not_NmToken*/, true/*Local?*/);
        }

        /// <include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.DecodeName"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Transforms an XML name into an object name (such as DataTable or DataColumn).</para>
        /// </devdoc>

        public static string DecodeName(string name) {
            if (name == null || name == String.Empty)
		return name;

            StringBuilder bufBld = null;

            char[] source = name.ToCharArray();
            int length = name.Length;
            int copyPosition = 0;

            int underscorePos = name.IndexOf('_');
            MatchCollection mc = null;
            IEnumerator en = null;
            if (underscorePos >= 0)
            {
                mc = c_DecodeCharPattern.Matches(name, underscorePos);
                en = mc.GetEnumerator();
            } else {
                return name;
            }
            int matchPos = -1;
            if (en != null && en.MoveNext())
            {
                Match m = (Match)en.Current;
                matchPos = m.Index;
            }

            for (int position = 0; position < length - c_EncodedCharLength + 1; position ++) {
                if (position == matchPos) {
                    if (en.MoveNext())
                    {
                        Match m = (Match)en.Current;
                        matchPos = m.Index;
                    }
                    
                    if (bufBld == null) {
                        bufBld = new StringBuilder(length + 20);
                    }
                    bufBld.Append(source, copyPosition, position - copyPosition);

                    if (source[position + 6]!='_') { //_x1234_
                        
                        Int32 u =
                            FromHex(source[position + 2]) * 0x10000000 + 
                            FromHex(source[position + 3]) * 0x1000000 +
                            FromHex(source[position + 4]) * 0x100000 +
                            FromHex(source[position + 5]) * 0x10000 +
                            
                            FromHex(source[position + 6]) * 0x1000 + 
                            FromHex(source[position + 7]) * 0x100 +
                            FromHex(source[position + 8]) * 0x10 +
                            FromHex(source[position + 9]);

                        if (u >= 0x00010000) { 
                            if (u <= 0x0010ffff) { //convert to two chars
                                copyPosition = position + c_EncodedCharLength + 4;
                                char x = (char) (((u - 0x10000) / 0x400) + 0xd800);
                                char y = (char) ((u - (( x - 0xd800) * 0x400) ) - 0x10000 + 0xdc00);
                                bufBld.Append(x);
                                bufBld.Append(y);
                            }
                            //else bad ucs-4 char dont convert
                        }
                        else { //convert to single char
                            copyPosition = position + c_EncodedCharLength + 4;
                            bufBld.Append((char)u);
                        }
                        position += c_EncodedCharLength - 1 + 4; //just skip
                        
                    }
                    else {
                        copyPosition = position + c_EncodedCharLength;
                        bufBld.Append((char)(
                            FromHex(source[position + 2]) * 0x1000 + 
                            FromHex(source[position + 3]) * 0x100 +
                            FromHex(source[position + 4]) * 0x10 +
                            FromHex(source[position + 5])));
                        position += c_EncodedCharLength - 1;
                    }
                }
            }
            if (copyPosition == 0) {
                return name;
            } 
            else {
                if (copyPosition < length) {
                    bufBld.Append(source, copyPosition, length - copyPosition);
                }
                return bufBld.ToString();
            }
        }

        private static string EncodeName(string name, bool first, bool local) {
            if (name == null) 
				return name;

			if(name == String.Empty) {
				if(!first)
					throw new XmlException(Res.Xml_InvalidNmToken,name);
				return name;
			}
		        
			StringBuilder bufBld = null;
            char[] source = name.ToCharArray();
            int length = name.Length;
            int copyPosition = 0;
            int position = 0;

            int underscorePos = name.IndexOf('_');
            MatchCollection mc = null;
            IEnumerator en = null;
            if (underscorePos >= 0)
            {
                mc = c_EncodeCharPattern.Matches(name, underscorePos);
                en = mc.GetEnumerator();
            }
            
            int matchPos = -1;
            if (en != null && en.MoveNext())
            {
                Match m = (Match)en.Current;
                matchPos = m.Index - 1;
            }
            if (first) {
                if ((local && !XmlCharType.IsStartNCNameChar(source[0])) ||
                    (!local && !XmlCharType.IsStartNameChar(source[0])) ||
                    matchPos == 0) {

                    if (bufBld == null) {
                        bufBld = new StringBuilder(length + 20);
                    }
               	    bufBld.Append("_x");
                    if (length > 1 && source[0] >= 0xd800 && source[0] <= 0xdbff && source[1] >= 0xdc00 && source[1] <= 0xdfff) {
		                int x = source[0];
            		    int y = source[1];
    		            Int32 u  = (x - 0xD800) * 0x400 + (y - 0xDC00) + 0x10000;
    		            bufBld.Append(u.ToString("X8"));
                        position ++;
                        copyPosition = 2;
                    }
                    else {
                        bufBld.Append(((Int32)source[0]).ToString("X4"));
                        copyPosition = 1;
                    }
                    
                    bufBld.Append("_");
                    position ++;

                    if (matchPos == 0)
                        if (en.MoveNext())
                        {
                            Match m = (Match)en.Current;
                            matchPos = m.Index - 1;
                        }
                }

            }
            for (; position < length; position ++) {
                if ((local && !XmlCharType.IsNCNameChar(source[position])) ||
                    (!local && !XmlCharType.IsNameChar(source[position])) ||
                    (matchPos == position))
                {
                    if (bufBld == null) {
                        bufBld = new StringBuilder(length + 20);
                    }
                    if (matchPos == position)
                        if (en.MoveNext())
                        {
                            Match m = (Match)en.Current;
                            matchPos = m.Index - 1;
                        }

                    bufBld.Append(source, copyPosition, position - copyPosition);
                    bufBld.Append("_x");
                    if ((length > position + 1) && source[position] >= 0xd800 && source[position] <= 0xdbff && source[position + 1] >= 0xdc00 && source[position + 1] <= 0xdfff) {
		                int x = source[position];
            		    int y = source[position + 1];
    		            Int32 u  = (x - 0xD800) * 0x400 + (y - 0xDC00) + 0x10000;
    		            bufBld.Append(u.ToString("X8"));
                        copyPosition = position + 2;
                        position ++;
                    }
                    else {
                        bufBld.Append(((Int32)source[position]).ToString("X4"));
                        copyPosition = position + 1;
                    }
                    bufBld.Append("_");
                }
            }
            if (copyPosition == 0) {
                return name;
            } 
            else {
                if (copyPosition < length) {
                    bufBld.Append(source, copyPosition, length - copyPosition);
                }
                return bufBld.ToString();
            }
        }

        private static readonly int   c_EncodedCharLength = "_xFFFF_".Length;
        private static readonly Regex c_EncodeCharPattern = new Regex("(?<=_)[Xx]([0-9a-fA-F]{4}|[0-9a-fA-F]{8})_");
        private static readonly Regex c_DecodeCharPattern = new Regex("_[Xx]([0-9a-fA-F]{4}|[0-9a-fA-F]{8})_");
        private static int FromHex(char digit) {
            return(digit <= '9')
            ? ((int)digit - (int)'0')
            : (((digit <= 'F')
                ? ((int)digit - (int)'A')
                : ((int)digit - (int)'a'))
               + 10);
        }

        internal static byte[] FromBinHexString(string s) {
            BinHexDecoder binHexDecoder = new BinHexDecoder();
            return binHexDecoder.DecodeBinHex(s.ToCharArray(), 0, true);
        }

     	internal static string ToBinHexString(byte[] inArray) {
            return BinHexEncoder.EncodeToBinHex(inArray, 0, inArray.Length);
        }


        /// <include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.VerifyName"]/*' />
        /// <devdoc>
        ///    <para> 
        ///    </para>
        /// </devdoc>
        public static string VerifyName(string name) {
            if (name == null || name == string.Empty) {
                throw new ArgumentNullException("name");
            }
	
            if (!XmlCharType.IsStartNameChar(name[0])) {
                throw new XmlException(Res.Xml_BadStartNameChar,XmlException.BuildCharExceptionStr(name[0]));
            }
            int nameLength = name.Length;
            int position    = 1;
            while (position < nameLength) {
                if (!XmlCharType.IsNameChar(name[position])) {
                    throw new XmlException(Res.Xml_BadNameChar,XmlException.BuildCharExceptionStr(name[position]));
                }
                position ++;
            }
            return name;
        }

        /// <include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.VerifyNCName"]/*' />
        /// <devdoc>
        ///    <para> 
        ///    </para>
        /// </devdoc>
        public static string VerifyNCName(string name) {
            if (name == null || name == string.Empty) {
                throw new ArgumentNullException("name");
            }
			
            if (!XmlCharType.IsStartNCNameChar(name[0])) {
                throw new XmlException(Res.Xml_BadStartNameChar,XmlException.BuildCharExceptionStr(name[0]));
            }
            int nameLength = name.Length;
            int position    = 1;
            while (position < nameLength) {
                if (!XmlCharType.IsNCNameChar(name[position])) {
                    throw new XmlException(Res.Xml_BadNameChar,XmlException.BuildCharExceptionStr(name[position]));
                }
                position ++;
            }
            return name;
        }

        internal static string VerifyTOKEN(string token) {
            char[] crt = new char[] {'\n', '\r', '\t'};
            if (token == null || token == string.Empty) {
                return token;
            }
            if (token[0] == ' ' || token[token.Length - 1] == ' ' || token.IndexOfAny(crt) != -1 || token.IndexOf("  ") != -1) {
                throw new XmlException(Res.Sch_NotTokenString, token);
            }
            return token;
        }

        internal static string VerifyNMTOKEN(string name) {
            if (name == null) {
                throw new ArgumentNullException("name");
            }
			if(name == string.Empty) {
				throw new XmlException(Res.Xml_InvalidNmToken,name);
			}
            int nameLength = name.Length;
            int position    = 0;
            while (position < nameLength) {
                if (!XmlCharType.IsNameChar(name[position]))
                    throw new XmlException(Res.Xml_BadNameChar,XmlException.BuildCharExceptionStr(name[position]));
                position ++;
            }
            return name;
        }
        
        

        // Value convertors:
        //
        // String representation of Base types in XML (xsd) sometimes differ from
        // one common language runtime offer and for all types it has to be locale independent.
        // o -- means that XmlConvert pass through to common language runtime converter with InvariantInfo FormatInfo
        // x -- means we doing something special to make a convertion.
        //
        // From:  To: Bol Chr SBy Byt I16 U16 I32 U32 I64 U64 Sgl Dbl Dec Dat Tim Str uid
        // ------------------------------------------------------------------------------
        // Boolean                                                                 x
        // Char                                                                    o 
        // SByte                                                                   o
        // Byte                                                                    o
        // Int16                                                                   o
        // UInt16                                                                  o
        // Int32                                                                   o
        // UInt32                                                                  o
        // Int64                                                                   o
        // UInt64                                                                  o
        // Single                                                                  x
        // Double                                                                  x
        // Decimal                                                                 o
        // DateTime                                                                x
        // String      x   o   o   o   o   o   o   o   o   o   o   x   x   o   o       x
        // Guid                                                                    x
        // -----------------------------------------------------------------------------

     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static string ToString(Boolean value)  {
            return value ? "true" : "false";
        }

     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString1"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static string ToString(Char value)  {
            return value.ToString(null);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString2"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static string ToString(Decimal value)  {
            return value.ToString(null, NumberFormatInfo.InvariantInfo);
        }

     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString3"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        [CLSCompliant(false)] 
        public static string ToString(SByte value)  {
            return value.ToString(null, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString4"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static string ToString(Int16 value) {
            return value.ToString(null, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString5"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static string ToString(Int32 value) {
            return value.ToString(null, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString15"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static string ToString(Int64 value) {
            return value.ToString(null, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString6"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static string ToString(Byte value) {
            return value.ToString(null, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString7"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        [CLSCompliant(false)] 
        public static string ToString(UInt16 value) {
            return value.ToString(null, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString8"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        [CLSCompliant(false)] 
        public static string ToString(UInt32 value) {
            return value.ToString(null, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString16"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        [CLSCompliant(false)] 
        public static string ToString(UInt64 value) {
            return value.ToString(null, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString9"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static string ToString(Single value) {
            if (Single.IsNegativeInfinity(value)) return "-INF";
            if (Single.IsPositiveInfinity(value)) return "INF";
            return value.ToString("R", NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString10"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static string ToString(Double value) {
            if (Double.IsNegativeInfinity(value)) return "-INF";
            if (Double.IsPositiveInfinity(value)) return "INF";
            return value.ToString("R", NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString11"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static string ToString(TimeSpan value) {
            StringBuilder sb = new StringBuilder(20);
            bool negate = false;
            
            if(value.Ticks < 0) { // negative interval
                sb.Append("-");
                // calling negate on the the timespan does not work for all values (e.g. TimeSpan.MinValue)
                negate = true;
            }
            int days    = value.Days;
            int hours   = value.Hours;
            int minutes = value.Minutes;
            int seconds = value.Seconds;
            double milliseconds = RemainderMillisFromTicks(value.Ticks) / 1000; //milliseconds actually represents all fractional seconds
                                                                             //This value * 1000 will give the number of milliseconds
            if (negate) {
                Debug.Assert(0 >= days 
                            && 0 >= hours
                            && 0 >= minutes
                            && 0 >= seconds
                            && 0 >= milliseconds, "All values should be negative or 0");
                days *= -1;
                hours *= -1;
                minutes *= -1;
                seconds *= -1;
                milliseconds *= -1;
            }

            sb.Append("P");
            if(days != 0) {
                sb.Append(ToString(days));
                sb.Append("D");
            }
            if(hours != 0 || minutes != 0 || seconds != 0) {
                sb.Append("T");
                if(hours != 0) {
                    sb.Append(ToString(hours));
                    sb.Append("H");
                }
                if(minutes != 0) {
                    sb.Append(ToString(minutes));
                    sb.Append("M");
                }
                if(seconds != 0 || milliseconds != 0) {
                    sb.Append(ToString(seconds + milliseconds));
                    sb.Append("S");
                }
            }
            if(days == 0 && hours == 0 && minutes == 0 && seconds == 0 && milliseconds == 0) {
                sb.Append("T0S");
            }
            return sb.ToString();
        }
        

     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString12"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static string ToString(DateTime value) {
            return ToString(value, "yyyy-MM-ddTHH:mm:ss.fffffffzzzzzz");
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString13"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static string ToString(DateTime value, string format) {
            return value.ToString(format, DateTimeFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToString14"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static string ToString(Guid value) {
            return value.ToString();
        }

     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToBoolean"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static Boolean ToBoolean (string s) {
            s = s.Trim();
            if (s == "1" || s == "true" ) return true;
            if (s == "0" || s == "false") return false;
            throw new FormatException(Res.GetString(Res.XmlConvert_BadBoolean));
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToChar"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static Char ToChar (string s) {
            return Char.Parse(s);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToDecimal"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static Decimal ToDecimal (string s) {
            return Decimal.Parse(s, NumberStyles.AllowLeadingSign|NumberStyles.AllowDecimalPoint|NumberStyles.AllowLeadingWhite|NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
        }

        internal static Decimal ToInteger (string s) {
            return Decimal.Parse(s, NumberStyles.AllowLeadingSign|NumberStyles.AllowLeadingWhite|NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToSByte"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        [CLSCompliant(false)] 
        public static SByte ToSByte (string s) {
            return SByte.Parse(s, NumberStyles.AllowLeadingSign|NumberStyles.AllowLeadingWhite|NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToInt16"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static Int16 ToInt16 (string s) {
            return Int16.Parse(s, NumberStyles.AllowLeadingSign|NumberStyles.AllowLeadingWhite|NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToInt32"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static Int32 ToInt32 (string s) {
            return Int32.Parse(s, NumberStyles.AllowLeadingSign|NumberStyles.AllowLeadingWhite|NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToInt64"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static Int64 ToInt64 (string s) {
            return Int64.Parse(s, NumberStyles.AllowLeadingSign|NumberStyles.AllowLeadingWhite|NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToByte"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static Byte ToByte (string s) {
            return Byte.Parse(s, NumberStyles.AllowLeadingWhite|NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToUInt16"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        [CLSCompliant(false)] 
        public static UInt16 ToUInt16 (string s) {
            return UInt16.Parse(s, NumberStyles.AllowLeadingWhite|NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToUInt32"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        [CLSCompliant(false)] 
        public static UInt32 ToUInt32 (string s) {
            return UInt32.Parse(s, NumberStyles.AllowLeadingWhite|NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToUInt64"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        [CLSCompliant(false)] 
        public static UInt64 ToUInt64 (string s) {
            return UInt64.Parse(s, NumberStyles.AllowLeadingWhite|NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToSingle"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static Single ToSingle (string s) {
            if(s == "-INF") return Single.NegativeInfinity;
            if(s == "INF") return Single.PositiveInfinity;
            return Single.Parse(s, NumberStyles.AllowLeadingSign|NumberStyles.AllowDecimalPoint|NumberStyles.AllowExponent|NumberStyles.AllowLeadingWhite|NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToDouble"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static Double ToDouble (string s) {
            if(s == "-INF") return Double.NegativeInfinity;
            if(s == "INF") return Double.PositiveInfinity;
            return Double.Parse(s, NumberStyles.AllowLeadingSign|NumberStyles.AllowDecimalPoint|NumberStyles.AllowExponent|NumberStyles.AllowLeadingWhite|NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
        }

        internal static Double ToXPathDouble (Object s) {
            try {
                switch (Type.GetTypeCode(s.GetType())) {
                case TypeCode.String :
                    try {
                        string str = ((string)s).TrimStart();
                        if (str[0] != '+') {
                            return Double.Parse(str, NumberStyles.AllowLeadingSign|NumberStyles.AllowDecimalPoint|NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
                        }
                    }
                    catch {};
                    return Double.NaN;
                case TypeCode.Double :
                    return (double) s;
                case TypeCode.Boolean :
                    return (bool) s == true ? 1.0 : 0.0;
                default :
                    // Script functions can fead us with Int32 & Co.
                        return Convert.ToDouble(s, NumberFormatInfo.InvariantInfo); 
                }
            }
            catch {};
            return Double.NaN;
        }

        internal static String ToXPathString(Object value){
            try {
                switch (Type.GetTypeCode(value.GetType())) {
                case TypeCode.Double :
                    return ((double)value).ToString("R", NumberFormatInfo.InvariantInfo);
                case TypeCode.Boolean :
                    return (bool)value ? "true" : "false";
                default :
                        return Convert.ToString(value, NumberFormatInfo.InvariantInfo);

                }
            }
            catch {};
            return String.Empty;
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToTimeSpan"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static TimeSpan ToTimeSpan(string s) {
            bool negate = false;
            int years = 0;
            int months = 0;
            int days = 0;
            int hours = 0;
            int minutes = 0;
            int seconds = 0;
            double milliseconds = 0;

            s = s.Trim();
            int length = s.Length;
            int pos = 0;
            int powerCnt = 0;
            try {
                if (s[pos] == '-') {
                    pos ++;
                    negate = true;
                }
                if (s[pos ++] != 'P') goto error;

                int count = _parseCount(s, ref pos);
                if (s[pos] == 'Y') {
                    years = count;
                    if (++ pos == length) goto success;
                    count = _parseCount(s, ref pos);
                }
                if (s[pos] == 'M') {
                    months = count;
                    if (++ pos == length) goto success;
                    count = _parseCount(s, ref pos);
                }
                if (s[pos] == 'D') {
                    days = count;
                    if (++ pos == length) goto success;
                }
                if (s[pos] == 'T') {
                    pos ++;
                    count = _parseCount(s, ref pos);
                    if (s[pos] == 'H') {
                        hours = count;
                        if (++ pos == length) goto success;
                        count = _parseCount(s, ref pos);
                    }
                    if (s[pos] == 'M') {
                        minutes = count;
                        if (++ pos == length) goto success;
                        count = _parseCount(s, ref pos);
                    }
                    if (s[pos] == '.') {
                        seconds = count;
                        if (++ pos == length) goto error;
                        milliseconds = _parseCount(s, ref pos, ref powerCnt) / Math.Pow(10,powerCnt);
                        if (s[pos] != 'S') goto error;
                        if (++ pos == length) goto success;
                    }
                    if (s[pos] == 'S') {
                        seconds = count;
                        if (++ pos == length) goto success;
                    }
                }
                if (pos != length) goto error;
            } 
            catch(Exception) {
                goto error;
            }
            success:
                if(years == -1 || months == -1 || days == -1 || hours == -1 || minutes == -1 || seconds == -1) {
                    goto error;
                }
                if (negate) {
                    years *= -1;
                    months *= -1;
                    days *= -1;
                    hours *= -1;
                    minutes *= -1;
                    seconds *= -1;
                    milliseconds *= -1;                    
                }
                years += months / 12;
                months = months % 12;
                TimeSpan value = CreateTimeSpan(365 * years + 30 * months + days, hours, minutes, seconds, milliseconds * 1000);
                return value;

            error:
                throw new FormatException(Res.GetString(Res.XmlConvert_BadTimeSpan));
        }

        private static TimeSpan CreateTimeSpan(int days, int hours, int minutes, int seconds, double milliseconds)  {
            decimal ticks = new TimeSpan(days, hours, minutes, seconds).Ticks;
            ticks += (decimal)milliseconds * TimeSpan.TicksPerMillisecond;
            return new TimeSpan((long)ticks);
        }

        private static double RemainderMillisFromTicks(long ticks) {
            double temp = (double)(((decimal)ticks / TimeSpan.TicksPerMillisecond) % 1000); 
            return temp;
        }


        static string[] allDateTimeFormats = new string[] {
            "yyyy-MM-ddTHH:mm:ss",          // dateTime
            "yyyy-MM-ddTHH:mm:ss.f",
            "yyyy-MM-ddTHH:mm:ss.ff",
            "yyyy-MM-ddTHH:mm:ss.fff",
            "yyyy-MM-ddTHH:mm:ss.ffff",
            "yyyy-MM-ddTHH:mm:ss.fffff",
            "yyyy-MM-ddTHH:mm:ss.ffffff",
            "yyyy-MM-ddTHH:mm:ss.fffffff",
            "yyyy-MM-ddTHH:mm:ssZ",
            "yyyy-MM-ddTHH:mm:ss.fZ",
            "yyyy-MM-ddTHH:mm:ss.ffZ",
            "yyyy-MM-ddTHH:mm:ss.fffZ",
            "yyyy-MM-ddTHH:mm:ss.ffffZ",
            "yyyy-MM-ddTHH:mm:ss.fffffZ",
            "yyyy-MM-ddTHH:mm:ss.ffffffZ",
            "yyyy-MM-ddTHH:mm:ss.fffffffZ",
            "yyyy-MM-ddTHH:mm:sszzzzzz",
            "yyyy-MM-ddTHH:mm:ss.fzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.ffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.fffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.ffffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.fffffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.ffffffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.fffffffzzzzzz",
            "HH:mm:ss",                     // time
            "HH:mm:ss.f",
            "HH:mm:ss.ff",
            "HH:mm:ss.fff",
            "HH:mm:ss.ffff",
            "HH:mm:ss.fffff",
            "HH:mm:ss.ffffff",
            "HH:mm:ss.fffffff",
            "HH:mm:ssZ",
            "HH:mm:ss.fZ",
            "HH:mm:ss.ffZ",
            "HH:mm:ss.fffZ",
            "HH:mm:ss.ffffZ",
            "HH:mm:ss.fffffZ",
            "HH:mm:ss.ffffffZ",
            "HH:mm:ss.fffffffZ",
            "HH:mm:sszzzzzz",
            "HH:mm:ss.fzzzzzz",
            "HH:mm:ss.ffzzzzzz",
            "HH:mm:ss.fffzzzzzz",
            "HH:mm:ss.ffffzzzzzz",
            "HH:mm:ss.fffffzzzzzz",
            "HH:mm:ss.ffffffzzzzzz",
            "HH:mm:ss.fffffffzzzzzz",
            "yyyy-MM-dd",                   // date
            "yyyy-MM-ddZ",
            "yyyy-MM-ddzzzzzz",
            "yyyy-MM",                      // yearMonth
            "yyyy-MMZ",
            "yyyy-MMzzzzzz",
            "yyyy",                         // year
            "yyyyZ",
            "yyyyzzzzzz",
            "--MM-dd",                      // monthDay
            "--MM-ddZ",
            "--MM-ddzzzzzz",
            "---dd",                        // day
            "---ddZ",
            "---ddzzzzzz",          
            "--MM--",                       // month
            "--MM--Z",
            "--MM--zzzzzz",
        };

     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToDateTime"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static DateTime ToDateTime(string s) {
            return ToDateTime(s, allDateTimeFormats);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToDateTime1"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static DateTime ToDateTime(string s, string format) {
            return DateTime.ParseExact(s, format, DateTimeFormatInfo.InvariantInfo, DateTimeStyles.AllowLeadingWhite|DateTimeStyles.AllowTrailingWhite);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToDateTime2"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static DateTime ToDateTime(string s, string[] formats) {
            return DateTime.ParseExact(s, formats, DateTimeFormatInfo.InvariantInfo, DateTimeStyles.AllowLeadingWhite|DateTimeStyles.AllowTrailingWhite);
        }
        
     	///<include file='doc\XmlConvert.uex' path='docs/doc[@for="XmlConvert.ToGuid"]/*' />
     	/// <devdoc>
     	///    <para>[To be supplied.]</para>
     	/// </devdoc>
        public static Guid ToGuid (string s) {
            return new Guid(s);
        }

        internal static XmlSchemaUri ToUri(string s) {
            s = s.Trim();
            if (s == string.Empty || s.IndexOf("##") != -1) {
                throw new FormatException(Res.GetString(Res.XmlConvert_BadUri));
            }
            if (s.IndexOf(":") != -1) { // absolute URI
                return new XmlSchemaUri(s, true);
            }
            try {
                return new XmlSchemaUri(s, Path.IsPathRooted(s));
            }
            catch {
                throw new FormatException(Res.GetString(Res.XmlConvert_BadUri));
            }
        }

        private static int _parseCount(string s, ref int pos) {
            int count = -1;
            while ('0' <= s[pos] && s[pos] <= '9') {
                if (count == -1) {
                    count = 0;
                } 
                else {
                    count *= 10;
                }
                count += s[pos ++] - '0';
            }
            return count;
        }
        
        private static int _parseCount(string s, ref int pos, ref int powerCnt) {
            int count = -1;
            while ('0' <= s[pos] && s[pos] <= '9') {
                if (count == -1) {
                    count = 0;
                } 
                else {
                    count *= 10;
                }
                count += s[pos ++] - '0';
                powerCnt++;
            }
            return count;
        }

        private static int _parseCount(string s, ref int pos, int maxLength) {
            int count = -1;
            while ('0' <= s[pos] && s[pos] <= '9') {
                if (-- maxLength > 0) {
                    if (count == -1) {
                        count = 0;
                    } 
                    else {
                        count *= 10;
                    }
                    count += s[pos] - '0';
                }
                pos ++;
            }
            return count;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlchartype.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlCharType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml {


    /// <include file='doc\XmlCharType.uex' path='docs/doc[@for="XmlCharType"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///  The XmlCharType class is used for quick character type recognition
    ///  which is optimized for the first 127 ascii characters.
    /// </devdoc>
    internal sealed class XmlCharType
    {
        // Whitespace chars -- Section 2.3 [3]
        // Letters -- Appendix B [84]
        // Starting name characters -- Section 2.3 [5]
        // Name characters -- Section 2.3 [4]
        // Character data characters -- Section 2.2 [2]
        // PubidChar ::=  #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%] Section 2.3 of spec
        public const int FWHITESPACE    = 1;
        public const int FLETTER        = 2;
        public const int FSTARTNAME     = 4;
        public const int FNAME          = 8;
        public const int FCHARDATA      = 16;
        public const int FPUBLICID      = 32;

        public const char MAXWCHAR      = (char)0xffff;
        public const int  MAXCHARDATA   = 0x10ffff;

        internal const string s_Whitespace =
            "\u0009\u000a\u000d\u000d\u0020\u0020";

        const string s_Letter =
            "\u0041\u005a\u0061\u007a\u00c0\u00d6\u00d8\u00f6" +
            "\u00f8\u0131\u0134\u013e\u0141\u0148\u014a\u017e" +
            "\u0180\u01c3\u01cd\u01f0\u01f4\u01f5\u01fa\u0217" +
            "\u0250\u02a8\u02bb\u02c1\u0386\u0386\u0388\u038a" +
            "\u038c\u038c\u038e\u03a1\u03a3\u03ce\u03d0\u03d6" +
            "\u03da\u03da\u03dc\u03dc\u03de\u03de\u03e0\u03e0" +
            "\u03e2\u03f3\u0401\u040c\u040e\u044f\u0451\u045c" +
            "\u045e\u0481\u0490\u04c4\u04c7\u04c8\u04cb\u04cc" +
            "\u04d0\u04eb\u04ee\u04f5\u04f8\u04f9\u0531\u0556" +
            "\u0559\u0559\u0561\u0586\u05d0\u05ea\u05f0\u05f2" +
            "\u0621\u063a\u0641\u064a\u0671\u06b7\u06ba\u06be" +
            "\u06c0\u06ce\u06d0\u06d3\u06d5\u06d5\u06e5\u06e6" +
            "\u0905\u0939\u093d\u093d\u0958\u0961\u0985\u098c" +
            "\u098f\u0990\u0993\u09a8\u09aa\u09b0\u09b2\u09b2" +
            "\u09b6\u09b9\u09dc\u09dd\u09df\u09e1\u09f0\u09f1" +
            "\u0a05\u0a0a\u0a0f\u0a10\u0a13\u0a28\u0a2a\u0a30" +
            "\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59\u0a5c" +
            "\u0a5e\u0a5e\u0a72\u0a74\u0a85\u0a8b\u0a8d\u0a8d" +
            "\u0a8f\u0a91\u0a93\u0aa8\u0aaa\u0ab0\u0ab2\u0ab3" +
            "\u0ab5\u0ab9\u0abd\u0abd\u0ae0\u0ae0\u0b05\u0b0c" +
            "\u0b0f\u0b10\u0b13\u0b28\u0b2a\u0b30\u0b32\u0b33" +
            "\u0b36\u0b39\u0b3d\u0b3d\u0b5c\u0b5d\u0b5f\u0b61" +
            "\u0b85\u0b8a\u0b8e\u0b90\u0b92\u0b95\u0b99\u0b9a" +
            "\u0b9c\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8\u0baa" +
            "\u0bae\u0bb5\u0bb7\u0bb9\u0c05\u0c0c\u0c0e\u0c10" +
            "\u0c12\u0c28\u0c2a\u0c33\u0c35\u0c39\u0c60\u0c61" +
            "\u0c85\u0c8c\u0c8e\u0c90\u0c92\u0ca8\u0caa\u0cb3" +
            "\u0cb5\u0cb9\u0cde\u0cde\u0ce0\u0ce1\u0d05\u0d0c" +
            "\u0d0e\u0d10\u0d12\u0d28\u0d2a\u0d39\u0d60\u0d61" +
            "\u0e01\u0e2e\u0e30\u0e30\u0e32\u0e33\u0e40\u0e45" +
            "\u0e81\u0e82\u0e84\u0e84\u0e87\u0e88\u0e8a\u0e8a" +
            "\u0e8d\u0e8d\u0e94\u0e97\u0e99\u0e9f\u0ea1\u0ea3" +
            "\u0ea5\u0ea5\u0ea7\u0ea7\u0eaa\u0eab\u0ead\u0eae" +
            "\u0eb0\u0eb0\u0eb2\u0eb3\u0ebd\u0ebd\u0ec0\u0ec4" +
            "\u0f40\u0f47\u0f49\u0f69\u10a0\u10c5\u10d0\u10f6" +
            "\u1100\u1100\u1102\u1103\u1105\u1107\u1109\u1109" +
            "\u110b\u110c\u110e\u1112\u113c\u113c\u113e\u113e" +
            "\u1140\u1140\u114c\u114c\u114e\u114e\u1150\u1150" +
            "\u1154\u1155\u1159\u1159\u115f\u1161\u1163\u1163" +
            "\u1165\u1165\u1167\u1167\u1169\u1169\u116d\u116e" +
            "\u1172\u1173\u1175\u1175\u119e\u119e\u11a8\u11a8" +
            "\u11ab\u11ab\u11ae\u11af\u11b7\u11b8\u11ba\u11ba" +
            "\u11bc\u11c2\u11eb\u11eb\u11f0\u11f0\u11f9\u11f9" +
            "\u1e00\u1e9b\u1ea0\u1ef9\u1f00\u1f15\u1f18\u1f1d" +
            "\u1f20\u1f45\u1f48\u1f4d\u1f50\u1f57\u1f59\u1f59" +
            "\u1f5b\u1f5b\u1f5d\u1f5d\u1f5f\u1f7d\u1f80\u1fb4" +
            "\u1fb6\u1fbc\u1fbe\u1fbe\u1fc2\u1fc4\u1fc6\u1fcc" +
            "\u1fd0\u1fd3\u1fd6\u1fdb\u1fe0\u1fec\u1ff2\u1ff4" +
            "\u1ff6\u1ffc\u2126\u2126\u212a\u212b\u212e\u212e" +
            "\u2180\u2182\u3007\u3007\u3021\u3029\u3041\u3094" +
            "\u30a1\u30fa\u3105\u312c\u4e00\u9fa5\uac00\ud7a3";

        const string s_StartName =
            "\u003a\u003a\u0041\u005a\u005f\u005f\u0061\u007a" +
            "\u00c0\u00d6\u00d8\u00f6\u00f8\u0131\u0134\u013e" +
            "\u0141\u0148\u014a\u017e\u0180\u01c3\u01cd\u01f0" +
            "\u01f4\u01f5\u01fa\u0217\u0250\u02a8\u02bb\u02c1" +
            "\u0386\u0386\u0388\u038a\u038c\u038c\u038e\u03a1" +
            "\u03a3\u03ce\u03d0\u03d6\u03da\u03da\u03dc\u03dc" +
            "\u03de\u03de\u03e0\u03e0\u03e2\u03f3\u0401\u040c" +
            "\u040e\u044f\u0451\u045c\u045e\u0481\u0490\u04c4" +
            "\u04c7\u04c8\u04cb\u04cc\u04d0\u04eb\u04ee\u04f5" +
            "\u04f8\u04f9\u0531\u0556\u0559\u0559\u0561\u0586" +
            "\u05d0\u05ea\u05f0\u05f2\u0621\u063a\u0641\u064a" +
            "\u0671\u06b7\u06ba\u06be\u06c0\u06ce\u06d0\u06d3" +
            "\u06d5\u06d5\u06e5\u06e6\u0905\u0939\u093d\u093d" +
            "\u0958\u0961\u0985\u098c\u098f\u0990\u0993\u09a8" +
            "\u09aa\u09b0\u09b2\u09b2\u09b6\u09b9\u09dc\u09dd" +
            "\u09df\u09e1\u09f0\u09f1\u0a05\u0a0a\u0a0f\u0a10" +
            "\u0a13\u0a28\u0a2a\u0a30\u0a32\u0a33\u0a35\u0a36" +
            "\u0a38\u0a39\u0a59\u0a5c\u0a5e\u0a5e\u0a72\u0a74" +
            "\u0a85\u0a8b\u0a8d\u0a8d\u0a8f\u0a91\u0a93\u0aa8" +
            "\u0aaa\u0ab0\u0ab2\u0ab3\u0ab5\u0ab9\u0abd\u0abd" +
            "\u0ae0\u0ae0\u0b05\u0b0c\u0b0f\u0b10\u0b13\u0b28" +
            "\u0b2a\u0b30\u0b32\u0b33\u0b36\u0b39\u0b3d\u0b3d" +
            "\u0b5c\u0b5d\u0b5f\u0b61\u0b85\u0b8a\u0b8e\u0b90" +
            "\u0b92\u0b95\u0b99\u0b9a\u0b9c\u0b9c\u0b9e\u0b9f" +
            "\u0ba3\u0ba4\u0ba8\u0baa\u0bae\u0bb5\u0bb7\u0bb9" +
            "\u0c05\u0c0c\u0c0e\u0c10\u0c12\u0c28\u0c2a\u0c33" +
            "\u0c35\u0c39\u0c60\u0c61\u0c85\u0c8c\u0c8e\u0c90" +
            "\u0c92\u0ca8\u0caa\u0cb3\u0cb5\u0cb9\u0cde\u0cde" +
            "\u0ce0\u0ce1\u0d05\u0d0c\u0d0e\u0d10\u0d12\u0d28" +
            "\u0d2a\u0d39\u0d60\u0d61\u0e01\u0e2e\u0e30\u0e30" +
            "\u0e32\u0e33\u0e40\u0e45\u0e81\u0e82\u0e84\u0e84" +
            "\u0e87\u0e88\u0e8a\u0e8a\u0e8d\u0e8d\u0e94\u0e97" +
            "\u0e99\u0e9f\u0ea1\u0ea3\u0ea5\u0ea5\u0ea7\u0ea7" +
            "\u0eaa\u0eab\u0ead\u0eae\u0eb0\u0eb0\u0eb2\u0eb3" +
            "\u0ebd\u0ebd\u0ec0\u0ec4\u0f40\u0f47\u0f49\u0f69" +
            "\u10a0\u10c5\u10d0\u10f6\u1100\u1100\u1102\u1103" +
            "\u1105\u1107\u1109\u1109\u110b\u110c\u110e\u1112" +
            "\u113c\u113c\u113e\u113e\u1140\u1140\u114c\u114c" +
            "\u114e\u114e\u1150\u1150\u1154\u1155\u1159\u1159" +
            "\u115f\u1161\u1163\u1163\u1165\u1165\u1167\u1167" +
            "\u1169\u1169\u116d\u116e\u1172\u1173\u1175\u1175" +
            "\u119e\u119e\u11a8\u11a8\u11ab\u11ab\u11ae\u11af" +
            "\u11b7\u11b8\u11ba\u11ba\u11bc\u11c2\u11eb\u11eb" +
            "\u11f0\u11f0\u11f9\u11f9\u1e00\u1e9b\u1ea0\u1ef9" +
            "\u1f00\u1f15\u1f18\u1f1d\u1f20\u1f45\u1f48\u1f4d" +
            "\u1f50\u1f57\u1f59\u1f59\u1f5b\u1f5b\u1f5d\u1f5d" +
            "\u1f5f\u1f7d\u1f80\u1fb4\u1fb6\u1fbc\u1fbe\u1fbe" +
            "\u1fc2\u1fc4\u1fc6\u1fcc\u1fd0\u1fd3\u1fd6\u1fdb" +
            "\u1fe0\u1fec\u1ff2\u1ff4\u1ff6\u1ffc\u2126\u2126" +
            "\u212a\u212b\u212e\u212e\u2180\u2182\u3007\u3007" +
            "\u3021\u3029\u3041\u3094\u30a1\u30fa\u3105\u312c" +
            "\u4e00\u9fa5\uac00\ud7a3";

        const string s_Name =
            "\u002d\u002e\u0030\u003a\u0041\u005a\u005f\u005f" +
            "\u0061\u007a\u00b7\u00b7\u00c0\u00d6\u00d8\u00f6" +
            "\u00f8\u0131\u0134\u013e\u0141\u0148\u014a\u017e" +
            "\u0180\u01c3\u01cd\u01f0\u01f4\u01f5\u01fa\u0217" +
            "\u0250\u02a8\u02bb\u02c1\u02d0\u02d1\u0300\u0345" +
            "\u0360\u0361\u0386\u038a\u038c\u038c\u038e\u03a1" +
            "\u03a3\u03ce\u03d0\u03d6\u03da\u03da\u03dc\u03dc" +
            "\u03de\u03de\u03e0\u03e0\u03e2\u03f3\u0401\u040c" +
            "\u040e\u044f\u0451\u045c\u045e\u0481\u0483\u0486" +
            "\u0490\u04c4\u04c7\u04c8\u04cb\u04cc\u04d0\u04eb" +
            "\u04ee\u04f5\u04f8\u04f9\u0531\u0556\u0559\u0559" +
            "\u0561\u0586\u0591\u05a1\u05a3\u05b9\u05bb\u05bd" +
            "\u05bf\u05bf\u05c1\u05c2\u05c4\u05c4\u05d0\u05ea" +
            "\u05f0\u05f2\u0621\u063a\u0640\u0652\u0660\u0669" +
            "\u0670\u06b7\u06ba\u06be\u06c0\u06ce\u06d0\u06d3" +
            "\u06d5\u06e8\u06ea\u06ed\u06f0\u06f9\u0901\u0903" +
            "\u0905\u0939\u093c\u094d\u0951\u0954\u0958\u0963" +
            "\u0966\u096f\u0981\u0983\u0985\u098c\u098f\u0990" +
            "\u0993\u09a8\u09aa\u09b0\u09b2\u09b2\u09b6\u09b9" +
            "\u09bc\u09bc\u09be\u09c4\u09c7\u09c8\u09cb\u09cd" +
            "\u09d7\u09d7\u09dc\u09dd\u09df\u09e3\u09e6\u09f1" +
            "\u0a02\u0a02\u0a05\u0a0a\u0a0f\u0a10\u0a13\u0a28" +
            "\u0a2a\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39" +
            "\u0a3c\u0a3c\u0a3e\u0a42\u0a47\u0a48\u0a4b\u0a4d" +
            "\u0a59\u0a5c\u0a5e\u0a5e\u0a66\u0a74\u0a81\u0a83" +
            "\u0a85\u0a8b\u0a8d\u0a8d\u0a8f\u0a91\u0a93\u0aa8" +
            "\u0aaa\u0ab0\u0ab2\u0ab3\u0ab5\u0ab9\u0abc\u0ac5" +
            "\u0ac7\u0ac9\u0acb\u0acd\u0ae0\u0ae0\u0ae6\u0aef" +
            "\u0b01\u0b03\u0b05\u0b0c\u0b0f\u0b10\u0b13\u0b28" +
            "\u0b2a\u0b30\u0b32\u0b33\u0b36\u0b39\u0b3c\u0b43" +
            "\u0b47\u0b48\u0b4b\u0b4d\u0b56\u0b57\u0b5c\u0b5d" +
            "\u0b5f\u0b61\u0b66\u0b6f\u0b82\u0b83\u0b85\u0b8a" +
            "\u0b8e\u0b90\u0b92\u0b95\u0b99\u0b9a\u0b9c\u0b9c" +
            "\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8\u0baa\u0bae\u0bb5" +
            "\u0bb7\u0bb9\u0bbe\u0bc2\u0bc6\u0bc8\u0bca\u0bcd" +
            "\u0bd7\u0bd7\u0be7\u0bef\u0c01\u0c03\u0c05\u0c0c" +
            "\u0c0e\u0c10\u0c12\u0c28\u0c2a\u0c33\u0c35\u0c39" +
            "\u0c3e\u0c44\u0c46\u0c48\u0c4a\u0c4d\u0c55\u0c56" +
            "\u0c60\u0c61\u0c66\u0c6f\u0c82\u0c83\u0c85\u0c8c" +
            "\u0c8e\u0c90\u0c92\u0ca8\u0caa\u0cb3\u0cb5\u0cb9" +
            "\u0cbe\u0cc4\u0cc6\u0cc8\u0cca\u0ccd\u0cd5\u0cd6" +
            "\u0cde\u0cde\u0ce0\u0ce1\u0ce6\u0cef\u0d02\u0d03" +
            "\u0d05\u0d0c\u0d0e\u0d10\u0d12\u0d28\u0d2a\u0d39" +
            "\u0d3e\u0d43\u0d46\u0d48\u0d4a\u0d4d\u0d57\u0d57" +
            "\u0d60\u0d61\u0d66\u0d6f\u0e01\u0e2e\u0e30\u0e3a" +
            "\u0e40\u0e4e\u0e50\u0e59\u0e81\u0e82\u0e84\u0e84" +
            "\u0e87\u0e88\u0e8a\u0e8a\u0e8d\u0e8d\u0e94\u0e97" +
            "\u0e99\u0e9f\u0ea1\u0ea3\u0ea5\u0ea5\u0ea7\u0ea7" +
            "\u0eaa\u0eab\u0ead\u0eae\u0eb0\u0eb9\u0ebb\u0ebd" +
            "\u0ec0\u0ec4\u0ec6\u0ec6\u0ec8\u0ecd\u0ed0\u0ed9" +
            "\u0f18\u0f19\u0f20\u0f29\u0f35\u0f35\u0f37\u0f37" +
            "\u0f39\u0f39\u0f3e\u0f47\u0f49\u0f69\u0f71\u0f84" +
            "\u0f86\u0f8b\u0f90\u0f95\u0f97\u0f97\u0f99\u0fad" +
            "\u0fb1\u0fb7\u0fb9\u0fb9\u10a0\u10c5\u10d0\u10f6" +
            "\u1100\u1100\u1102\u1103\u1105\u1107\u1109\u1109" +
            "\u110b\u110c\u110e\u1112\u113c\u113c\u113e\u113e" +
            "\u1140\u1140\u114c\u114c\u114e\u114e\u1150\u1150" +
            "\u1154\u1155\u1159\u1159\u115f\u1161\u1163\u1163" +
            "\u1165\u1165\u1167\u1167\u1169\u1169\u116d\u116e" +
            "\u1172\u1173\u1175\u1175\u119e\u119e\u11a8\u11a8" +
            "\u11ab\u11ab\u11ae\u11af\u11b7\u11b8\u11ba\u11ba" +
            "\u11bc\u11c2\u11eb\u11eb\u11f0\u11f0\u11f9\u11f9" +
            "\u1e00\u1e9b\u1ea0\u1ef9\u1f00\u1f15\u1f18\u1f1d" +
            "\u1f20\u1f45\u1f48\u1f4d\u1f50\u1f57\u1f59\u1f59" +
            "\u1f5b\u1f5b\u1f5d\u1f5d\u1f5f\u1f7d\u1f80\u1fb4" +
            "\u1fb6\u1fbc\u1fbe\u1fbe\u1fc2\u1fc4\u1fc6\u1fcc" +
            "\u1fd0\u1fd3\u1fd6\u1fdb\u1fe0\u1fec\u1ff2\u1ff4" +
            "\u1ff6\u1ffc\u20d0\u20dc\u20e1\u20e1\u2126\u2126" +
            "\u212a\u212b\u212e\u212e\u2180\u2182\u3005\u3005" +
            "\u3007\u3007\u3021\u302f\u3031\u3035\u3041\u3094" +
            "\u3099\u309a\u309d\u309e\u30a1\u30fa\u30fc\u30fe" +
            "\u3105\u312c\u4e00\u9fa5\uac00\ud7a3";

        const string s_CharData =
            "\u0009\u000a\u000d\u000d\u0020\ud7ff\udc00\udeff" +
            "\ue000\ufffd";

        const string s_PublicID =
            "\u000a\u000a\u000d\u000d\u0020\u0021\u0023\u0025" +
            "\u0027\u003b\u003d\u003d\u003f\u005a\u005f\u005f" +
            "\u0061\u007a";

        static byte [] s_CharProperties;

        static XmlCharType()
        {
            s_CharProperties = new byte[65536];

            SetProperties(s_Whitespace, FWHITESPACE);
            SetProperties(s_Letter,     FLETTER);
            SetProperties(s_StartName,  FSTARTNAME);
            SetProperties(s_Name,       FNAME);
            SetProperties(s_CharData,   FCHARDATA);
            SetProperties(s_PublicID,   FPUBLICID);
        }

        // Don't create any instances of this class
        private XmlCharType() {
        }

        private static void SetProperties(string ranges, byte value)
        {
            for (int p = 0; p < ranges.Length; p += 2) {
                for (int i = ranges[p], last = ranges[p + 1]; i <= last; i++) {
                    s_CharProperties[i] |= value;
                }
            }
        }

        // methods for efficiently querying the character type.
        public static bool IsWhiteSpace(char ch) {
            return (s_CharProperties[ch] & FWHITESPACE) != 0;
        }

        public static bool IsLetter(char ch) {
            return (s_CharProperties[ch] & FLETTER) != 0;
        }

        public static bool IsDigit(char ch) {
            return (ch >= 0x30 && ch <= 0x39);
        }

        public static bool IsHexDigit(char ch) {
            return (ch >= 0x30 && ch <= 0x39) || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F');
        }

        public static bool IsCombiningChar(char ch) {
            return false;
        }

        public static bool IsExtender(char ch) {
            return (ch == 0xb7);
        }

        public static bool IsNameChar(char ch) {
            return (s_CharProperties[ch] & FNAME) != 0;
        }

        public static bool IsStartNameChar(char ch) {
            return (s_CharProperties[ch] & FSTARTNAME ) != 0;
        }

        public static bool IsNCNameChar(char ch) {
            return IsNameChar(ch) && ch != ':';
        }

        public static bool IsStartNCNameChar(char ch) {
            return IsStartNameChar(ch) && ch != ':';
        }

        public static bool IsCharData(char ch) {
            return (s_CharProperties[ch] & FCHARDATA) != 0;
        }

        // [13] PubidChar ::=  #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%] Section 2.3 of spec
        public static bool IsPubidChar(char ch) {
            return (s_CharProperties[ch] & FPUBLICID) != 0;
        }

        internal static bool IsOnlyWhitespace(string str) {
            if (str != null) {
                for (int index = 0; index < str.Length; index ++) {
                    if (! IsWhiteSpace(str[index]))
                        return false;
                }
            }
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmldocumenttype.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlDocumentType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlDocumentType.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml {

    using System.Diagnostics;

    /// <include file='doc\XmlDocumentType.uex' path='docs/doc[@for="XmlDocumentType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Contains information associated with the document type declaration.
    ///    </para>
    /// </devdoc>
    public class XmlDocumentType : XmlLinkedNode {
        string name;
        string publicId;
        string systemId;
        string internalSubset;
        bool namespaces;
        XmlNamedNodeMap entities;
        XmlNamedNodeMap notations;


        /// <include file='doc\XmlDocumentType.uex' path='docs/doc[@for="XmlDocumentType.XmlDocumentType"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected internal XmlDocumentType( string name, string publicId, string systemId, string internalSubset, XmlDocument doc ) : base( doc ) {
            this.name     = name;
            this.publicId = publicId;
            this.systemId = systemId;
            this.namespaces = true;
            this.internalSubset = internalSubset;
            Debug.Assert( doc != null );
            if ( !doc.IsLoading ) {
                doc.IsLoading = true;
                XmlLoader loader = new XmlLoader();
                loader.ParseDocumentType( this ); //will edit notation nodes, etc.
                doc.IsLoading = false;
            }
        }

        /// <include file='doc\XmlDocumentType.uex' path='docs/doc[@for="XmlDocumentType.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node.
        ///    </para>
        /// </devdoc>
        public override string Name {
            get { return name;}
        }

        /// <include file='doc\XmlDocumentType.uex' path='docs/doc[@for="XmlDocumentType.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the current node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override string LocalName {
            get { return name;}
        }

        /// <include file='doc\XmlDocumentType.uex' path='docs/doc[@for="XmlDocumentType.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType {
            get { return XmlNodeType.DocumentType;}
        }

        /// <include file='doc\XmlDocumentType.uex' path='docs/doc[@for="XmlDocumentType.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a duplicate of this node.
        ///    </para>
        /// </devdoc>
        public override XmlNode CloneNode(bool deep) {
            Debug.Assert( OwnerDocument != null );
            return OwnerDocument.CreateDocumentType( name, publicId, systemId, internalSubset );
        }

        // Microsoft extensions
        /// <include file='doc\XmlDocumentType.uex' path='docs/doc[@for="XmlDocumentType.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the node is read-only.
        ///    </para>
        /// </devdoc>
        public override bool IsReadOnly {
            get { 
                return true;        // Make entities and notations readonly
            }
        }

        /// <include file='doc\XmlDocumentType.uex' path='docs/doc[@for="XmlDocumentType.Entities"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of XmlEntity nodes declared in the document type declaration.</para>
        /// </devdoc>
        public XmlNamedNodeMap Entities { 
            get { 
                if (entities == null)
                    entities = new XmlNamedNodeMap( this );

                return entities;
            }
        }

        /// <include file='doc\XmlDocumentType.uex' path='docs/doc[@for="XmlDocumentType.Notations"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of XmlNotation nodes present in the document type declaration.</para>
        /// </devdoc>
        public XmlNamedNodeMap Notations { 
            get {
                if (notations == null)
                    notations = new XmlNamedNodeMap( this );

                return notations;
            }
        }

        // DOM Level 2
        /// <include file='doc\XmlDocumentType.uex' path='docs/doc[@for="XmlDocumentType.PublicId"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the value of the public identifier on the DOCTYPE declaration.
        ///    </para>
        /// </devdoc>
        public string PublicId { 
            get { return publicId;} 
        }

        /// <include file='doc\XmlDocumentType.uex' path='docs/doc[@for="XmlDocumentType.SystemId"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the value of
        ///       the system identifier on the DOCTYPE declaration.
        ///    </para>
        /// </devdoc>
        public string SystemId { 
            get { return systemId;} 
        }

        /// <include file='doc\XmlDocumentType.uex' path='docs/doc[@for="XmlDocumentType.InternalSubset"]/*' />
        /// <devdoc>Gets the entire value of the DTD internal subset
        /// on the DOCTYPE
        /// declaration.
        /// </devdoc>
        public string InternalSubset { 
            get { return internalSubset;}
        }

        internal bool ParseWithNamespaces {
            get { return namespaces; }
            set { namespaces = value; }
        }

        /// <include file='doc\XmlDocumentType.uex' path='docs/doc[@for="XmlDocumentType.WriteTo"]/*' />
        /// <devdoc>
        ///    <para>Saves the node to the specified XmlWriter.</para>
        /// </devdoc>
        public override void WriteTo(XmlWriter w) {
            w.WriteDocType( name, publicId, systemId, internalSubset );
        }

        /// <include file='doc\XmlDocumentType.uex' path='docs/doc[@for="XmlDocumentType.WriteContentTo"]/*' />
        /// <devdoc>
        ///    <para>Saves all the children of the node to the specified XmlWriter.</para>
        /// </devdoc>
        public override void WriteContentTo(XmlWriter w) {
            // Intentionally do nothing
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmldocumentfragment.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlDocumentFragment.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------
/*
 * <code>DocumentFragment</code> is a "lightweight" or "minimal" 
 * <code>Document</code> object. It is very common to want to be able to 
 * extract a portion of a document's tree or to create a new fragment of a 
 * document. Imagine implementing a user command like cut or rearranging a 
 * document by moving fragments around. It is desirable to have an object 
 * which can hold such fragments and it is quite natural to use a Node for 
 * this purpose. While it is true that a <code>Document</code> object could 
 * fulfil this role,  a <code>Document</code> object can potentially be a 
 * heavyweight  object, depending on the underlying implementation. What is 
 * really needed for this is a very lightweight object.  
 * <code>DocumentFragment</code> is such an object.
 * <p>Furthermore, various operations -- such as inserting nodes as children 
 * of another <code>Node</code> -- may take <code>DocumentFragment</code> 
 * objects as arguments;  this results in all the child nodes of the 
 * <code>DocumentFragment</code>  being moved to the child list of this node.
 * <p>The children of a <code>DocumentFragment</code> node are zero or more 
 * nodes representing the tops of any sub-trees defining the structure of the 
 * document. <code>DocumentFragment</code> nodes do not need to be 
 * well-formed XML documents (although they do need to follow the rules 
 * imposed upon well-formed XML parsed entities, which can have multiple top 
 * nodes).  For example, a <code>DocumentFragment</code> might have only one 
 * child and that child node could be a <code>Text</code> node. Such a 
 * structure model  represents neither an HTML document nor a well-formed XML 
 * document.  
 * <p>When a <code>DocumentFragment</code> is inserted into a  
 * <code>Document</code> (or indeed any other <code>Node</code> that may take 
 * children) the children of the <code>DocumentFragment</code> and not the 
 * <code>DocumentFragment</code>  itself are inserted into the 
 * <code>Node</code>. This makes the <code>DocumentFragment</code> very 
 * useful when the user wishes to create nodes that are siblings; the 
 * <code>DocumentFragment</code> acts as the parent of these nodes so that the
 *  user can use the standard methods from the <code>Node</code>  interface, 
 * such as <code>insertBefore()</code> and  <code>appendChild()</code>.  
 */

namespace System.Xml {

    using System.Diagnostics;
    using System.Xml.XPath;

    /// <include file='doc\XmlDocumentFragment.uex' path='docs/doc[@for="XmlDocumentFragment"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a lightweight object that is useful for tree insert
    ///       operations.
    ///    </para>
    /// </devdoc>
    public class XmlDocumentFragment : XmlNode {
        XmlLinkedNode lastChild;

        /// <include file='doc\XmlDocumentFragment.uex' path='docs/doc[@for="XmlDocumentFragment.XmlDocumentFragment"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected internal XmlDocumentFragment( XmlDocument ownerDocument ): base( ) {
            if ( ownerDocument == null )
                throw new ArgumentException(Res.GetString(Res.Xdom_Node_Null_Doc));
            parentNode= ownerDocument;
        }

        /// <include file='doc\XmlDocumentFragment.uex' path='docs/doc[@for="XmlDocumentFragment.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node.
        ///    </para>
        /// </devdoc>
        public override String Name { 
            get { return XmlDocument.strDocumentFragmentName;}
        }

        /// <include file='doc\XmlDocumentFragment.uex' path='docs/doc[@for="XmlDocumentFragment.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the current node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override String LocalName { 
            get { return XmlDocument.strDocumentFragmentName;}
        }

        /// <include file='doc\XmlDocumentFragment.uex' path='docs/doc[@for="XmlDocumentFragment.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType {
            get { return XmlNodeType.DocumentFragment;}
        }

        /// <include file='doc\XmlDocumentFragment.uex' path='docs/doc[@for="XmlDocumentFragment.ParentNode"]/*' />
        /// <devdoc>
        ///    <para>Gets the parent of this node (for nodes that can have
        ///       parents).</para>
        /// </devdoc>
        public override XmlNode ParentNode {
            get { return null;}
        }

        /// <include file='doc\XmlDocumentFragment.uex' path='docs/doc[@for="XmlDocumentFragment.OwnerDocument"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Xml.XmlDocument'/> that contains this node.
        ///    </para>
        /// </devdoc>
        public override XmlDocument OwnerDocument {
            get { 
                return (XmlDocument)parentNode;
            }

        }

        /// <include file='doc\XmlDocumentFragment.uex' path='docs/doc[@for="XmlDocumentFragment.InnerXml"]/*' />
        /// <devdoc>
        ///    Gets or sets the markup representing just
        ///    the children of this node.
        /// </devdoc>
        public override string InnerXml {
            get {
                return base.InnerXml;
            }
            set {
                RemoveAll();
                XmlLoader loader = new XmlLoader();
                //Hack that the content is the same element
                loader.ParsePartialContent( this, value, XmlNodeType.Element );
            }
        }
        
        /// <include file='doc\XmlDocumentFragment.uex' path='docs/doc[@for="XmlDocumentFragment.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>Creates a duplicate of this node.</para>
        /// </devdoc>
        public override XmlNode CloneNode(bool deep) {
            Debug.Assert( OwnerDocument != null );
            XmlDocumentFragment clone = OwnerDocument.CreateDocumentFragment();
            if(deep)
                clone.CopyChildren( this, deep );
            return clone;                
        }

        internal override bool IsContainer {
            get { return true;}
        }

        internal override XmlLinkedNode LastNode {
            get { return lastChild;}
            set { lastChild = value;}
        }

        internal override bool IsValidChildType( XmlNodeType type ) {
            switch (type) {
                case XmlNodeType.Element:
                case XmlNodeType.Text:
                case XmlNodeType.EntityReference:
                case XmlNodeType.Comment:
                case XmlNodeType.Whitespace:
                case XmlNodeType.SignificantWhitespace:
                case XmlNodeType.ProcessingInstruction:
                case XmlNodeType.CDATA:
                    return true;

                default:
                    return false;
            }
        }

        /// <include file='doc\XmlDocumentFragment.uex' path='docs/doc[@for="XmlDocumentFragment.WriteTo"]/*' />
        /// <devdoc>
        ///    <para>Saves the node to the specified XmlWriter.</para>
        /// </devdoc>
        public override void WriteTo(XmlWriter w) {
            WriteContentTo( w );
        }

        /// <include file='doc\XmlDocumentFragment.uex' path='docs/doc[@for="XmlDocumentFragment.WriteContentTo"]/*' />
        /// <devdoc>
        ///    <para>Saves all the children of the node to the specified XmlWriter.</para>
        /// </devdoc>
        public override void WriteContentTo(XmlWriter w) {
            foreach( XmlNode n in this ) {
                n.WriteTo( w );
            }
        }

        internal override XPathNodeType XPNodeType { get { return XPathNodeType.Root; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmldeclaration.cs ===
/*
*
* Copyright (c) 2000 Microsoft Corporation. All rights reserved.
*
*/

namespace System.Xml {
    using System.Text;
    using System.Diagnostics;

    /// <include file='doc\XmlDeclaration.uex' path='docs/doc[@for="XmlDeclaration"]/*' />
    /// <devdoc>
    ///    <para>Represents the xml declaration nodes: &lt;?xml version='1.0' ...?&gt; </para>
    /// </devdoc>

    public class XmlDeclaration : XmlLinkedNode {

        const string YES = "yes";
        const string NO = "no";
        const string VERNUM = "1.0";

        private string  encoding;
        private string  standalone;

        /// <include file='doc\XmlDeclaration.uex' path='docs/doc[@for="XmlDeclaration.XmlDeclaration"]/*' />
        protected internal XmlDeclaration( string version, string encoding, string standalone, XmlDocument doc ) : base( doc ) {
            if ( version != VERNUM )
                throw new ArgumentException( Res.GetString( Res.Xdom_Version ) );
            if( ( standalone != null ) && ( standalone != String.Empty )  )
                if ( ( standalone != YES ) && ( standalone != NO ) )
                    throw new ArgumentException( Res.GetString(Res.Xdom_standalone, standalone) );
            this.Encoding = encoding;
            this.Standalone = standalone;
        }


        /// <include file='doc\XmlDeclaration.uex' path='docs/doc[@for="XmlDeclaration.Version"]/*' />
        /// <devdoc>
        ///    <para>The version attribute (1.0) for &lt;?xml version= '1.0' ... ?&gt;.</para>
        /// </devdoc>
        public string Version {
            get { return VERNUM; }
        }

        /// <include file='doc\XmlDeclaration.uex' path='docs/doc[@for="XmlDeclaration.Encoding"]/*' />
        /// <devdoc>
        ///    <para>Specifies the value of the encoding attribute, as for
        ///       &lt;?xml version= '1.0' encoding= 'UTF-8' ?&gt;.</para>
        /// </devdoc>
        public string Encoding {
            get { return this.encoding; }
            set { this.encoding = ( (value == null) ? String.Empty : value ); }
        }

        /// <include file='doc\XmlDeclaration.uex' path='docs/doc[@for="XmlDeclaration.Standalone"]/*' />
        /// <devdoc>
        ///    <para>Specifies the value of the standalone attribute.</para>
        /// </devdoc>
        public string Standalone {
            get { return this.standalone; }
            set {
                if ( value == null )
                    this.standalone = String.Empty;
                else if ( value == String.Empty || value == YES || value == NO )
                    this.standalone = value;
                else
                    throw new ArgumentException( Res.GetString(Res.Xdom_standalone, value) );
            }
        }

        /// <include file='doc\XmlDeclaration.uex' path='docs/doc[@for="XmlDeclaration.Value"]/*' />
        public override String Value {
            get { return InnerText; }
            set { InnerText = value; }
        }


        /// <include file='doc\XmlDeclaration.uex' path='docs/doc[@for="XmlDeclaration.InnerText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the concatenated values of the node and
        ///       all its children.
        ///    </para>
        /// </devdoc>
        public override string InnerText {
            get {
                StringBuilder strb = new StringBuilder("version=\"" + Version + "\"");
                if ( Encoding != String.Empty ) {
                    strb.Append(" encoding=\"");
                    strb.Append(Encoding);
                    strb.Append("\"");
                }
                if ( Standalone != String.Empty ) {
                    strb.Append(" standalone=\"");
                    strb.Append(Standalone);
                    strb.Append("\"");
                }
                return strb.ToString();
            }

            set {
                string tempVersion = null;
                string tempEncoding = null;
                string tempStandalone = null;
                string orgEncoding   = this.Encoding;
                string orgStandalone = this.Standalone;

                XmlLoader.ParseXmlDeclarationValue( value, out tempVersion, out tempEncoding, out tempStandalone );

                try {
                    if ( tempVersion != null && tempVersion != VERNUM )
                        throw new ArgumentException(Res.GetString(Res.Xdom_Version));
                    if ( tempEncoding != null )
                        Encoding = tempEncoding;
                    if ( tempStandalone != null )
                        Standalone = tempStandalone;
                }
                catch {
                    Encoding = orgEncoding;
                    Standalone = orgStandalone;
                    throw;
                }
            }
        }

        //override methods and properties from XmlNode

        /// <include file='doc\XmlDeclaration.uex' path='docs/doc[@for="XmlDeclaration.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node.
        ///    </para>
        /// </devdoc>
        public override String Name {
            get {
                return "xml";
            }
        }

        /// <include file='doc\XmlDeclaration.uex' path='docs/doc[@for="XmlDeclaration.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the current node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override string LocalName {
            get { return Name;}
        }

        /// <include file='doc\XmlDeclaration.uex' path='docs/doc[@for="XmlDeclaration.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType {
            get { return XmlNodeType.XmlDeclaration;}
        }

        /// <include file='doc\XmlDeclaration.uex' path='docs/doc[@for="XmlDeclaration.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>Creates a duplicate of this node.</para>
        /// </devdoc>
        public override XmlNode CloneNode(bool deep) {
            Debug.Assert( OwnerDocument != null );
            return OwnerDocument.CreateXmlDeclaration( Version, Encoding, Standalone );
        }

        /// <include file='doc\XmlDeclaration.uex' path='docs/doc[@for="XmlDeclaration.WriteTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteTo(XmlWriter w) {
            w.WriteProcessingInstruction(Name, InnerText);
        }


        /// <include file='doc\XmlDeclaration.uex' path='docs/doc[@for="XmlDeclaration.WriteConntentTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves all the children of the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteContentTo(XmlWriter w) {
            // Intentionally do nothing since the node doesn't have children.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmldomtextwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlDomTextWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml {

    using System;
    //using System.Collections;
    using System.IO;
    //using System.Globalization;
    using System.Text;
    //using System.Diagnostics;
    //using System.ComponentModel;

    /// <devdoc>
    ///    <para>
    ///       Represents a writer that will make it possible to work with prefixes even
    ///       if the namespace is not specified.
    ///       This is not possible with XmlTextWriter. But this class inherits XmlTextWriter.
    ///    </para>
    /// </devdoc>

    internal class XmlDOMTextWriter : XmlTextWriter {

        public XmlDOMTextWriter( Stream w, Encoding encoding ) : base( w,encoding ) {
        }

        public XmlDOMTextWriter( String filename, Encoding encoding ) : base( filename,encoding ){
        }

        public XmlDOMTextWriter( TextWriter w ) : base( w ){
        }

        /// <devdoc>
        ///    <para> Overrides the baseclass implementation so that emptystring prefixes do
        ///           do not fail if namespace is not specified.
        ///    </para>
        /// </devdoc>
        public override void WriteStartElement( string prefix, string localName, string ns ){
            if( ( ns.Length == 0 ) && ( prefix.Length != 0 ) )
                prefix = "" ;

            base.WriteStartElement( prefix, localName, ns );
        }

        /// <devdoc>
        ///    <para> Overrides the baseclass implementation so that emptystring prefixes do
        ///           do not fail if namespace is not specified.
        ///    </para>
        /// </devdoc>
        public override  void WriteStartAttribute( string prefix, string localName, string ns ){
            if( ( ns.Length == 0 ) && ( prefix.Length != 0 )  )
                prefix = "" ;

            base.WriteStartAttribute( prefix, localName, ns );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmldtdtokeninfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlDtdTokenInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


using System.Xml.Schema;

namespace System.Xml {

    internal class XmlDtdTokenInfo : XmlNameValueTokenInfo {
        internal DtdParser _DtdParser;

        internal XmlDtdTokenInfo(XmlScanner scanner, XmlNamespaceManager nsMgr, XmlNodeType type,
            int depth, bool nor) : base(scanner, nsMgr, type, depth, nor) {
            _DtdParser = null;
        }

        internal override String GetValue() {
            if (_DtdParser != null )
                _Value = _DtdParser.InternalDTD;
            return base.GetValue();
        }
    }
 } // System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlelementtokeninfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlElementTokenInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.Text;
namespace System.Xml {

    internal class XmlElementTokenInfo : XmlBasicTokenInfo {
        internal String          _NameWPrefix;
        internal String          _Name;                    
        internal String          _Prefix;
        internal String          _NamespaceURI;
        internal bool            _IsEmpty;
        internal int             _NameColonPos;

        internal XmlElementTokenInfo(XmlScanner scanner, XmlNamespaceManager nsMgr, XmlNodeType type, int depth
                                    ) : base(scanner, nsMgr, type, depth) {
        }

        internal XmlElementTokenInfo(XmlScanner scanner, XmlNamespaceManager nsMgr, XmlNodeType type,
                                     String name, int nameOffset, int nameLength, int nameColonPos, 
                                     int depth, bool isEmpty) : base(scanner, nsMgr, type, depth) {
            _NameColonPos = nameColonPos;
            _Name = (name == null) ? _Scanner.GetTextAtom(nameOffset, nameLength) : _Scanner.GetTextAtom(name);
        }

        internal virtual void SetName(XmlScanner scanner, int offset, int length, int colon, int depth) {
            _Scanner = scanner;
            _NameColonPos = colon;
            _Depth = depth;

            _Name = _Scanner.GetTextAtom(offset,length);
            _SchemaType = null;
            _TypedValue = null;
        }

        internal virtual void FixNames() {
        }

        internal void SetName(String nameWPrefix, String localName, String prefix,
                               String ns, int depth, XmlScanner scanner) {
            _NameWPrefix = nameWPrefix;
            _Name = localName;
            _Prefix = prefix;
            _NamespaceURI = ns;
            _Depth = depth;
            _Scanner = scanner;
        }

        internal override String Name {
            get {
                return _Name;
            }
            set {
                _Name = value;
                _SchemaType = null;
                _TypedValue = null;
            }
        }

        internal override String NameWPrefix {
            get { return this.Name; }
            set { this.Name = value; }            
        }

        internal int NameColonPos {
            get {
                return _NameColonPos;
            }
            set {
                _NameColonPos = value;
            }
        }

        internal override bool IsEmpty {
            get {
                return _IsEmpty;
            }
            set {
                _IsEmpty = value;
            }
        }

    } // XmlElementTokenInfo
} // System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmldocument.cs ===
/*
*
* Copyright (c) 1998,1999 Microsoft Corporation. All rights reserved.
*
*/

// Set in SOURCES file now...
// [assembly:System.Runtime.InteropServices.ComVisible(false)]
namespace System.Xml
{
    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Xml.Schema;
    using System.Xml.XPath;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an entire document. An XmlDocument contains XML
    ///       data.
    ///    </para>
    /// </devdoc>
    public class XmlDocument: XmlNode {
        XmlImplementation implementation;
        XmlIdentityTable idTable;
        XmlLinkedNode lastChild;
        XmlDocumentFragment nullNode;
        XmlNamedNodeMap entities;
        internal XmlElementIdMap eleIds;
        private SchemaInfo _schemaInfo;
        //This variable represents the actual loading status. Since, IsLoading will
        //be manipulated soemtimes for adding content to EntityReference this variable
        //has been added which would always represent the loading status of document.
        private bool actualLoadingStatus;

        private XmlNodeChangedEventHandler onNodeInsertingDelegate = null;
        private XmlNodeChangedEventHandler onNodeInsertedDelegate = null;
        private XmlNodeChangedEventHandler onNodeRemovingDelegate = null;
        private XmlNodeChangedEventHandler onNodeRemovedDelegate = null;
        private XmlNodeChangedEventHandler onNodeChangingDelegate = null;
        private XmlNodeChangedEventHandler onNodeChangedDelegate = null;

        // false if there are no ent-ref present, true if ent-ref nodes are or were present (i.e. if all ent-ref were removed, the doc will not clear this flag)
        internal bool fEntRefNodesPresent;
        internal bool fIsEdited; // true if the document have been edited
        internal bool fCDataNodesPresent = false;

        XmlLoader loader;
        private bool preserveWhitespace = false;
        bool isLoading;

        // special name strings for
        internal const string strDocumentName = "#document";
        internal const string strDocumentFragmentName = "#document-fragment";
        internal const string strCommentName = "#comment";
        internal const string strTextName = "#text";
        internal const string strCDataSectionName = "#cdata-section";
        internal const string strEntityName = "#entity";
        internal const string strID = "id";
        internal const string strXmlns = "xmlns";
        internal const string strXml = "xml";
        internal const string strSpace = "space";
        internal const string strLang = "lang";
        internal string strEmpty = String.Empty;

//the next two strings are for XmlWhitespace and XmlSignificantWhitespace node Names -- for Beta2
        internal const string strNonSignificantWhitespaceName = "#whitespace";
        internal const string strSignificantWhitespaceName = "#significant-whitespace";
        internal const string strReservedXmlns = "http://www.w3.org/2000/xmlns/";
        internal const string strReservedXml = "http://www.w3.org/XML/1998/namespace";

        internal String baseURI = String.Empty;


        private XmlResolver resolver;
        internal bool       bSetResolver;
        internal object     objLock;

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.XmlDocument"]/*' />
        /// <devdoc>
        ///    <para>Initializes a new instance of the XmlDocument class.</para>
        /// </devdoc>
        public XmlDocument(): this( new XmlImplementation() ) {
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.XmlDocument1"]/*' />
        /// <devdoc>
        ///    <para>Initializes a new instance
        ///       of the XmlDocument class with the specified XmlNameTable.</para>
        /// </devdoc>
        public XmlDocument( XmlNameTable nt ) : this( new XmlImplementation( nt ) ) {
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.XmlDocument2"]/*' />
        protected internal XmlDocument( XmlImplementation imp ): base() {

            this.implementation = imp;
            idTable = new XmlIdentityTable( this );

            // force the following string instances to be default in the nametable
            XmlNameTable nt = this.NameTable;
            nt.Add( string.Empty );
            nt.Add( strDocumentName );
            nt.Add( strDocumentFragmentName );
            nt.Add( strCommentName );
            nt.Add( strTextName );
            nt.Add( strCDataSectionName );
            nt.Add( strEntityName );
            nt.Add( strID );
            nt.Add( strNonSignificantWhitespaceName );
            nt.Add( strSignificantWhitespaceName );
            nt.Add( strXmlns );
            nt.Add( strXml );
            nt.Add( strSpace );
            nt.Add( strLang );
            nt.Add( strReservedXmlns );
            nt.Add( strEmpty );

            nullNode = new XmlDocumentFragment( this );
            eleIds = new XmlElementIdMap(this);
            loader = new XmlLoader();
            _schemaInfo = null;
            isLoading = false;

            fEntRefNodesPresent = false;
            fIsEdited = false;
            fCDataNodesPresent = false;

            bSetResolver = false;
            resolver = null;

            this.objLock = new object();
        }

        internal SchemaInfo SchemaInformation {
            get { return _schemaInfo; }
            set { _schemaInfo = value; }
        }

        internal override XmlNode NullNode
        {
            get { return nullNode;}
        }

        internal static void CheckName( String name ) {
            for ( int i = 0; i < name.Length; i++ ) {
                if ( !XmlCharType.IsNCNameChar(name[i]) )
                    throw new XmlException(Res.Xml_BadNameChar, XmlException.BuildCharExceptionStr(name[i]));
            }
        }

        internal XmlName GetXmlName( string name, string namespaceURI ) {
            string prefix = String.Empty;
            string localName = String.Empty;

            SplitName( name, out prefix, out localName );

            return GetXmlName( prefix, localName, namespaceURI );
        }

        internal XmlName GetXmlName( string prefix, string localName, string namespaceURI ) {
            XmlName n = idTable.GetName( prefix, localName, namespaceURI );
            Debug.Assert( (prefix == null) ? (n.Prefix == String.Empty) : (prefix == n.Prefix) );
            Debug.Assert( n.LocalName == localName );
            Debug.Assert( (namespaceURI == null) ? (n.NamespaceURI == String.Empty) : (n.NamespaceURI == namespaceURI) );
            return n;
        }

        internal XmlName GetAttrXmlName( String prefix, String localName, String namespaceURI ) {
            XmlName xmlName = GetXmlName( prefix, localName, namespaceURI );
            Debug.Assert( (prefix == null) ? (xmlName.Prefix == String.Empty) : (prefix == xmlName.Prefix) );
            Debug.Assert( xmlName.LocalName == localName );
            Debug.Assert( (namespaceURI == null) ? (xmlName.NamespaceURI == String.Empty) : (xmlName.NamespaceURI == namespaceURI) );

            // Use atomized versions instead of prefix, localName and nsURI
            object oPrefix       = xmlName.Prefix;
            object oNamespaceURI = xmlName.NamespaceURI;
            object oLocalName    = xmlName.LocalName;
            if ( !this.IsLoading ) {
                if ( ( oPrefix == (object)strXmlns || ( oPrefix == (object)strEmpty && oLocalName == (object)strXmlns ) ) ^ ( oNamespaceURI == (object)strReservedXmlns ) )
                    throw new ArgumentException( Res.GetString( Res.Xdom_Attr_Reserved_XmlNS, namespaceURI ) );
            }
            return xmlName;
        }

        internal bool AddIdInfo( XmlName eleName, XmlName attrName ) {
            return eleIds.BindIDAttributeWithElementType(eleName, attrName);
        }

        internal XmlName GetIDInfoByElement( XmlName eleName ) {
            return eleIds.GetIDAttributeByElement(eleName);
        }

        internal void AddElementWithId( string id, XmlElement elem ) {
            eleIds.AddElementWithId(id, elem);
        }

        internal void RemoveElementWithId( string id, XmlElement elem ) {
            eleIds.RemoveElementWithId(id, elem);
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>Creates a duplicate of this node.</para>
        /// </devdoc>
        public override XmlNode CloneNode( bool deep ) {
            XmlDocument clone = Implementation.CreateDocument();
            clone.SetBaseURI(this.baseURI);
            if (deep)
                clone.ImportChildren( this, clone, deep );

            return clone;
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType {
            get { return XmlNodeType.Document; }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.DocumentType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the node for the DOCTYPE declaration.
        ///    </para>
        /// </devdoc>
        public virtual XmlDocumentType DocumentType {
            get { return(XmlDocumentType) FindChild( XmlNodeType.DocumentType ); }
        }

        internal virtual XmlDeclaration Declaration {
            get {
                if ( HasChildNodes ) {
                    XmlDeclaration dec = FirstChild as XmlDeclaration;
                    return dec;
                }
                return null;
            }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.Implementation"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the XmlImplementation object for this document.
        ///    </para>
        /// </devdoc>
        public XmlImplementation Implementation {
            get { return this.implementation; }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node.
        ///    </para>
        /// </devdoc>
        public override String Name  {
            get { return strDocumentName; }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the current node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override String LocalName {
            get { return strDocumentName; }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.DocumentElement"]/*' />
        /// <devdoc>
        /// <para>Gets the root <see cref='System.Xml.XmlElement'/> for the document.</para>
        /// </devdoc>
        public XmlElement DocumentElement {
            get { return(XmlElement)FindChild(XmlNodeType.Element); }
        }

        internal override bool IsContainer {
            get { return true; }
        }

        internal override XmlLinkedNode LastNode
        {
            get { return lastChild; }
            set { lastChild = value; }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.OwnerDocument"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Xml.XmlDocument'/> that contains this node.
        ///    </para>
        /// </devdoc>
        public override XmlDocument OwnerDocument
        {
            get { return null; }
        }

        internal bool HasSetResolver {
            get { return bSetResolver; }
        }

        internal XmlResolver GetResolver() {
           return resolver;
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.XmlResolver"]/*' />
        public virtual XmlResolver XmlResolver {
            set {
                if ( value != null ) {
                    try {
                        new NamedPermissionSet( "FullTrust" ).Demand();
                    }
                    catch ( SecurityException ) {
                        throw new SecurityException( Res.Xml_UntrustedCodeSettingResolver );
                    }
                }   

                resolver = value;
                if ( !bSetResolver )
                    bSetResolver = true;
            }
        }
        internal override bool IsValidChildType( XmlNodeType type ) {
            switch ( type ) {
                case XmlNodeType.ProcessingInstruction:
                case XmlNodeType.Comment:
                case XmlNodeType.Whitespace:
                case XmlNodeType.SignificantWhitespace:
                    return true;

                case XmlNodeType.DocumentType:
                    if ( DocumentType != null )
                        throw new InvalidOperationException( Res.GetString(Res.Xdom_DualDocumentTypeNode) );
                    return true;

                case XmlNodeType.Element:
                    if ( DocumentElement != null )
                        throw new InvalidOperationException( Res.GetString(Res.Xdom_DualDocumentElementNode) );
                    return true;

                case XmlNodeType.XmlDeclaration:
                    if ( Declaration != null )
                        throw new InvalidOperationException( Res.GetString(Res.Xdom_DualDeclarationNode) );
                    return true;

                default:
                    return false;
            }
        }
        // the function examines all the siblings before the refNode
        //  if any of the nodes has type equals to "nt", return true; otherwise, return false;
        private bool HasNodeTypeInPrevSiblings( XmlNodeType nt, XmlNode refNode ) {
            if ( refNode == null )
                return false;

            XmlNode node = null;
            if ( refNode.ParentNode != null )
                node = refNode.ParentNode.FirstChild;
            while ( node != null ) {
                if ( node.NodeType == nt )
                    return true;
                if ( node == refNode )
                    break;
                node = node.NextSibling;
            }
            return false;
        }

        // the function examines all the siblings after the refNode
        //  if any of the nodes has the type equals to "nt", return true; otherwise, return false;
        private bool HasNodeTypeInNextSiblings( XmlNodeType nt, XmlNode refNode ) {
            XmlNode node = refNode;
            while ( node != null ) {
                if ( node.NodeType == nt )
                    return true;
                node = node.NextSibling;
            }
            return false;
        }

        internal override bool CanInsertBefore( XmlNode newChild, XmlNode refChild ) {
            if ( refChild == null )
                refChild = FirstChild;

            if ( refChild == null )
                return true;

            switch ( newChild.NodeType ) {
                case XmlNodeType.XmlDeclaration:
                    return ( refChild == FirstChild );

                case XmlNodeType.ProcessingInstruction:
                case XmlNodeType.Comment:
                    return refChild.NodeType != XmlNodeType.XmlDeclaration;

                case XmlNodeType.DocumentType: {
                    if ( refChild.NodeType != XmlNodeType.XmlDeclaration ) {
                        //if refChild is not the XmlDeclaration node, only need to go through the sibling before and including refChild to
                        //  make sure no Element ( rootElem node ) before the current position
                        return !HasNodeTypeInPrevSiblings( XmlNodeType.Element, refChild.PreviousSibling );
                    }
                }
                break;

                case XmlNodeType.Element: {
                    if ( refChild.NodeType != XmlNodeType.XmlDeclaration ) {
                        //if refChild is not the XmlDeclaration node, only need to go through the siblings after and including the refChild to
                        //  make sure no DocType node and XmlDeclaration node after the current posistion.
                        return !HasNodeTypeInNextSiblings( XmlNodeType.DocumentType, refChild );
                    }
                }
                break;
            }

            return false;
        }

        internal override bool CanInsertAfter( XmlNode newChild, XmlNode refChild ) {
            if ( refChild == null )
                refChild = LastChild;

            if ( refChild == null )
                return true;

            switch ( newChild.NodeType ) {
                case XmlNodeType.ProcessingInstruction:
                case XmlNodeType.Comment:
                case XmlNodeType.Whitespace:
                case XmlNodeType.SignificantWhitespace:
                    return true;

                case XmlNodeType.DocumentType: {
                    //we will have to go through all the siblings before the refChild just to make sure no Element node ( rootElem )
                    //  before the current position
                    return !HasNodeTypeInPrevSiblings( XmlNodeType.Element, refChild );
                }

                case XmlNodeType.Element: {
                    return !HasNodeTypeInNextSiblings( XmlNodeType.DocumentType, refChild.NextSibling );
                }

            }

            return false;
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateAttribute"]/*' />
        /// <devdoc>
        /// <para>Creates an <see cref='XmlAttribute'/> with the specified name.</para>
        /// </devdoc>
        public XmlAttribute CreateAttribute( String name ) {
            String prefix = String.Empty;
            String localName = String.Empty;
            String namespaceURI = String.Empty;

            SplitName( name, out prefix, out localName );

            SetDefaultNamespace( prefix, localName, ref namespaceURI );

            return CreateAttribute( prefix, localName, namespaceURI );
        }

        internal void SetDefaultNamespace( String prefix, String localName, ref String namespaceURI ) {
            if ( prefix == strXmlns
                || ( prefix == "" && localName == strXmlns ) )
                namespaceURI = strReservedXmlns;

        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateCDataSection"]/*' />
        /// <devdoc>
        /// <para>Creates a <see cref='System.Xml.XmlCDataSection'/> containing the specified data.</para>
        /// </devdoc>
        public virtual XmlCDataSection CreateCDataSection( String data ) {
            fCDataNodesPresent = true;
            return new XmlCDataSection( data, this );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateComment"]/*' />
        /// <devdoc>
        /// <para>Creates an <see cref='System.Xml.XmlComment'/> containing the specified data.</para>
        /// </devdoc>
        public virtual XmlComment CreateComment( String data ) {
            return new XmlComment( data, this );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateDocumentType"]/*' />
        /// <devdoc>
        /// <para>Returns a new <see cref='System.Xml.XmlDocumentType'/> object.</para>
        /// </devdoc>
        [PermissionSetAttribute( SecurityAction.InheritanceDemand, Name = "FullTrust" )]
        public virtual XmlDocumentType CreateDocumentType( string name, string publicId, string systemId, string internalSubset ) {
            return new XmlDocumentType( name, publicId, systemId, internalSubset, this );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateDocumentFragment"]/*' />
        /// <devdoc>
        /// <para>Creates an <see cref='System.Xml.XmlDocumentFragment'/> .</para>
        /// </devdoc>
        public virtual XmlDocumentFragment CreateDocumentFragment() {
            return new XmlDocumentFragment( this );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateElement"]/*' />
        /// <devdoc>
        ///    <para>Creates an element with the specified name.</para>
        /// </devdoc>
        public XmlElement CreateElement( String name ) {
            string prefix = String.Empty;
            string localName = String.Empty;
            SplitName( name, out prefix, out localName );
            return CreateElement( prefix, localName, string.Empty );
        }


        internal void AddDefaultAttributes( XmlElement elem ) {
            SchemaInfo schInfo = SchemaInformation;
            SchemaElementDecl ed = GetSchemaElementDecl( elem );
            if ( ed != null && ed.AttDefs != null ) {
                IDictionaryEnumerator _attrDefs = ed.AttDefs.GetEnumerator();
                while ( _attrDefs.MoveNext() ) {
                    SchemaAttDef attdef = (SchemaAttDef)_attrDefs.Value;
                    if ( attdef.Presence == SchemaDeclBase.Use.Default ||
                         attdef.Presence == SchemaDeclBase.Use.Fixed ) {
                         //build a default attribute and return
                         string attrPrefix = string.Empty;
                         string attrLocalname = attdef.Name.Name;
                         string attrNamespaceURI = string.Empty;
                         if ( schInfo.SchemaType == SchemaType.DTD )
                            attrPrefix = attdef.Name.Namespace;
                         else {
                            attrPrefix = attdef.Prefix;
                            attrNamespaceURI = attdef.Name.Namespace;
                         }
                         XmlAttribute defattr = PrepareDefaultAttribute( attdef, attrPrefix, attrLocalname, attrNamespaceURI );
                         elem.SetAttributeNode( defattr );
                    }
                }
            }
        }

        private SchemaElementDecl GetSchemaElementDecl( XmlElement elem ) {
            SchemaInfo schInfo = SchemaInformation;
            if ( schInfo != null ) {
                //build XmlQualifiedName used to identify the element schema declaration
                XmlQualifiedName   qname = new XmlQualifiedName( elem.LocalName, schInfo.SchemaType == SchemaType.DTD ? elem.Prefix : elem.NamespaceURI );
                //get the schema info for the element
                return ( (SchemaElementDecl)schInfo.ElementDecls[qname] );
            }
            return null;
        }

        //Will be used by AddDeafulatAttributes() and GetDefaultAttribute() methods
        private XmlAttribute PrepareDefaultAttribute( SchemaAttDef attdef, string attrPrefix, string attrLocalname, string attrNamespaceURI ) {
            SetDefaultNamespace( attrPrefix, attrLocalname, ref attrNamespaceURI );
            XmlAttribute defattr = CreateDefaultAttribute( attrPrefix, attrLocalname, attrNamespaceURI );
            //parsing the default value for the default attribute
            defattr.InnerXml = attdef.DefaultValueRaw;
            //during the expansion of the tree, the flag could be set to true, we need to set it back.
            XmlUnspecifiedAttribute unspAttr = defattr as XmlUnspecifiedAttribute;
            if ( unspAttr != null ) {
                unspAttr.SetSpecified( false );
            }
            return defattr;
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateEntityReference"]/*' />
        /// <devdoc>
        /// <para>Creates an <see cref='System.Xml.XmlEntityReference'/> with the specified name.</para>
        /// </devdoc>
        public virtual XmlEntityReference CreateEntityReference( String name ) {
            return new XmlEntityReference( name, this );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateProcessingInstruction"]/*' />
        /// <devdoc>
        /// <para>Creates a <see cref='System.Xml.XmlProcessingInstruction'/> with the specified name
        ///    and data strings.</para>
        /// </devdoc>
        public virtual XmlProcessingInstruction CreateProcessingInstruction( String target, String data ) {
            return new XmlProcessingInstruction( target, data, this );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateXmlDeclaration"]/*' />
        /// <devdoc>
        /// <para>Creates a <see cref='System.Xml.XmlDeclaration'/> node with the specified values.</para>
        /// </devdoc>
        public virtual XmlDeclaration CreateXmlDeclaration( String version, string encoding, string standalone ) {
            return new XmlDeclaration( version, encoding, standalone, this );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateTextNode"]/*' />
        /// <devdoc>
        /// <para>Creates an <see cref='System.Xml.XmlText'/> with the specified text.</para>
        /// </devdoc>
        public virtual XmlText CreateTextNode( String text ) {
            return new XmlText( text, this );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateSignificantWhitespace"]/*' />
        /// <devdoc>
        ///    <para>Creates a XmlSignificantWhitespace node.</para>
        /// </devdoc>
        public virtual XmlSignificantWhitespace CreateSignificantWhitespace( string text ) {
            return new XmlSignificantWhitespace( text, this );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateNavigator"]/*' />
        internal protected virtual XPathNavigator CreateNavigator( XmlNode node ) {
            if( node.NodeType != XmlNodeType.Document ) {
                if(  ( (int)node.XPNodeType ) == -1 )
                    return null;
                if( ( IsTextNode( node.NodeType ) ) && ( IsAttributeChild( node ) ))
                    return null;
                if ( IsTextNode( node.NodeType ) )
                    node = NormalizeText( node );
            }
            return new DocumentXPathNavigator(node);
        }

        internal static bool IsTextNode( XmlNodeType nt ) {
            switch( nt ) {
                case XmlNodeType.Text:
                case XmlNodeType.CDATA:
                case XmlNodeType.Whitespace:
                case XmlNodeType.SignificantWhitespace:
                    return true;
                default:
                    return false;
            }
        }

        private XmlNode NormalizeText( XmlNode n ) {
            XmlNode retnode = null;
            while( IsTextNode( n.NodeType ) ) {
                retnode = n;
                n = n.PreviousSibling;

                if( n == null ) {
                    XmlNode intnode = retnode;
                    while ( true ) {
                        if  (intnode.ParentNode.NodeType == XmlNodeType.EntityReference ) {
                            if (intnode.ParentNode.PreviousSibling != null ) {
                                n = intnode.ParentNode.PreviousSibling;
                                break;
                            }
                            else {
                                intnode = intnode.ParentNode;
                                if( intnode == null )
                                break;
                            }
                        }
                        else
                            break;
                    }
                }

                if( n == null )
                    break;
                if( n.NodeType == XmlNodeType.EntityReference )
                    n = n.LastChild;
            }
            return retnode;
        }


         //trace to the top to find out if any ancestor node ai attribute.
        internal bool IsAttributeChild( XmlNode n ) {
            XmlNode parent = n.ParentNode;
            while (parent != null && !( parent.NodeType == XmlNodeType.Attribute ))
                parent = parent.ParentNode;
            return parent != null;
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateWhitespace"]/*' />
        /// <devdoc>
        ///    <para>Creates a XmlWhitespace node.</para>
        /// </devdoc>
        public virtual XmlWhitespace CreateWhitespace( string text ) {
            return new XmlWhitespace( text, this );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.GetElementsByTagName"]/*' />
        /// <devdoc>
        /// <para>Returns an <see cref='XmlNodeList'/> containing
        ///    a list of all descendant elements that match the specified name.</para>
        /// </devdoc>
        public virtual XmlNodeList GetElementsByTagName( String name ) {
            return new XmlElementList( this, name );
        }

        // DOM Level 2
        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateAttribute1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an <see cref='XmlAttribute'/> with the specified LocalName
        ///       and NamespaceURI.
        ///    </para>
        /// </devdoc>
        public XmlAttribute CreateAttribute( String qualifiedName, String namespaceURI ) {
            string prefix = String.Empty;
            string localName = String.Empty;

            SplitName( qualifiedName, out prefix, out localName );
            return CreateAttribute( prefix, localName, namespaceURI );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateElement1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an XmlElement with the specified LocalName and
        ///       NamespaceURI.
        ///    </para>
        /// </devdoc>
        public XmlElement CreateElement( String qualifiedName, String namespaceURI ) {
            string prefix = String.Empty;
            string localName = String.Empty;

            SplitName( qualifiedName, out prefix, out localName );
            return CreateElement( prefix, localName, namespaceURI );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.GetElementsByTagName1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns an <see cref='XmlNodeList'/> containing
        ///       a list of all descendant elements that match the specified name.
        ///    </para>
        /// </devdoc>
        public virtual XmlNodeList GetElementsByTagName( String localName, String namespaceURI ) {
            return new XmlElementList( this, localName, namespaceURI );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.GetElementById"]/*' />
        /// <devdoc>
        ///    Returns the XmlElement with the specified ID.
        /// </devdoc>
        public virtual XmlElement GetElementById( string elementId ) {
            XmlElement elem = eleIds.GetElementById( elementId );
            return elem;
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.ImportNode"]/*' />
        /// <devdoc>
        ///    <para>Imports a node from another document to this document.</para>
        /// </devdoc>
        public virtual XmlNode ImportNode( XmlNode node, bool deep ) {
            return ImportNodeInternal( node, deep );
        }

        private XmlNode ImportNodeInternal( XmlNode node, bool deep ) {
            XmlNode newNode = null;

            if ( node == null ) {
                throw new InvalidOperationException(  Res.GetString(Res.Xdom_Import_NullNode) );
            }
            else {
                switch ( node.NodeType ) {
                    case XmlNodeType.Element:
                        newNode = CreateElement( node.Prefix, node.LocalName, node.NamespaceURI );
                        ImportAttributes( node, newNode );
                        if ( deep )
                            ImportChildren( node, newNode, deep );
                        break;

                    case XmlNodeType.Attribute:
                        Debug.Assert( ((XmlAttribute)node).Specified );
                        newNode = CreateAttribute( node.Prefix, node.LocalName, node.NamespaceURI );
                        ImportChildren( node, newNode, true );
                        break;

                    case XmlNodeType.Text:
                        newNode = CreateTextNode( node.Value );
                        break;
                    case XmlNodeType.Comment:
                        newNode = CreateComment( node.Value);
                        break;
                    case XmlNodeType.ProcessingInstruction:
                        newNode = CreateProcessingInstruction( node.Name, node.Value );
                        break;
                    case XmlNodeType.XmlDeclaration:
                        XmlDeclaration decl = (XmlDeclaration) node;
                        newNode = CreateXmlDeclaration( decl.Version, decl.Encoding, decl.Standalone );
                        break;
                    case XmlNodeType.CDATA:
                        newNode = CreateCDataSection( node.Value );
                        break;
                    case XmlNodeType.DocumentType:
                        XmlDocumentType docType = (XmlDocumentType)node;
                        newNode = CreateDocumentType( docType.Name, docType.PublicId, docType.SystemId, docType.InternalSubset );
                        break;
                    case XmlNodeType.DocumentFragment:
                        newNode = CreateDocumentFragment();
                        if (deep)
                            ImportChildren( node, newNode, deep );
                        break;

                    case XmlNodeType.EntityReference:
                        newNode = CreateEntityReference( node.Name );
                        // we don't import the children of entity reference because they might result in different
                        // children nodes given different namesapce context in the new document.
                        break;

                    case XmlNodeType.Whitespace:
                        newNode = CreateWhitespace( node.Value );
                        break;

                    case XmlNodeType.SignificantWhitespace:
                        newNode = CreateSignificantWhitespace( node.Value );
                        break;

                    default:
                        throw new InvalidOperationException( String.Format( Res.GetString(Res.Xdom_Import), node.NodeType.ToString() ) );
                }
            }

            return newNode;
        }

        private void ImportAttributes( XmlNode fromElem, XmlNode toElem ) {
            int cAttr = fromElem.Attributes.Count;
            for ( int iAttr = 0; iAttr < cAttr; iAttr++ ) {
                if ( fromElem.Attributes[iAttr].Specified )
                    toElem.Attributes.SetNamedItem( ImportNodeInternal( fromElem.Attributes[iAttr], true ) );
            }
        }

        private void ImportChildren( XmlNode fromNode, XmlNode toNode, bool deep ) {
            Debug.Assert( toNode.NodeType != XmlNodeType.EntityReference );
            for ( XmlNode n = fromNode.FirstChild; n != null; n = n.NextSibling ) {
                toNode.AppendChild( ImportNodeInternal( n, deep ) );
            }
        }

        // Microsoft extensions
        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.NameTable"]/*' />
        /// <devdoc>
        ///    <para>Gets the XmlNameTable associated with this
        ///       implementation.</para>
        /// </devdoc>
        public XmlNameTable NameTable
        {
            get { return implementation.NameTable; }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateAttribute2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an <see cref='XmlAttribute'/> with the specified Prefix, LocalName,
        ///       and NamespaceURI.
        ///    </para>
        /// </devdoc>
        public virtual XmlAttribute CreateAttribute( string prefix, string localName, string namespaceURI ) {
            return new XmlAttribute( GetAttrXmlName( prefix, localName, namespaceURI ), this );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateDefaultAttribute"]/*' />
        protected internal virtual XmlAttribute CreateDefaultAttribute( string prefix, string localName, string namespaceURI ) {
            return new XmlUnspecifiedAttribute( prefix, localName, namespaceURI, this );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateElement2"]/*' />
        public virtual XmlElement CreateElement( string prefix, string localName, string namespaceURI) {
            XmlElement elem = new XmlElement( GetXmlName( prefix, localName, namespaceURI ), true, this );
            if ( !IsLoading )
                AddDefaultAttributes( elem );
            return elem;
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.PreserveWhitespace"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether to preserve whitespace.</para>
        /// </devdoc>
        public bool PreserveWhitespace {
            get { return preserveWhitespace;}
            set { preserveWhitespace = value;}
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the node is read-only.
        ///    </para>
        /// </devdoc>
        public override bool IsReadOnly {
            get { return false;}
        }

        internal XmlNamedNodeMap Entities {
            get {
                if ( entities == null )
                    entities = new XmlNamedNodeMap( this );
                return entities;
            }
            set { entities = value; }
        }

        internal bool IsLoading {
            get { return isLoading;}
            set { isLoading = value; }
        }

        internal bool ActualLoadingStatus{
            get { return actualLoadingStatus;}
            set { actualLoadingStatus = value; }
        }


        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateNode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a XmlNode with the specified XmlNodeType, Prefix, Name, and NamespaceURI.
        ///    </para>
        /// </devdoc>
        public virtual XmlNode CreateNode( XmlNodeType type, string prefix, string name, string namespaceURI ) {
            switch (type) {
                case XmlNodeType.Element:
                    if (prefix != null)
                        return CreateElement( prefix, name, namespaceURI );
                    else
                        return CreateElement( name, namespaceURI );

                case XmlNodeType.Attribute:
                    if (prefix != null)
                        return CreateAttribute( prefix, name, namespaceURI );
                    else
                        return CreateAttribute( name, namespaceURI );

                case XmlNodeType.Text:
                    return CreateTextNode( string.Empty );

                case XmlNodeType.CDATA:
                    return CreateCDataSection( string.Empty );

                case XmlNodeType.EntityReference:
                    return CreateEntityReference( name );

                case XmlNodeType.ProcessingInstruction:
                    return CreateProcessingInstruction( name, string.Empty );

                case XmlNodeType.XmlDeclaration:
                    return CreateXmlDeclaration( "1.0", null, null );

                case XmlNodeType.Comment:
                    return CreateComment( string.Empty );

                case XmlNodeType.DocumentFragment:
                    return CreateDocumentFragment();

                case XmlNodeType.DocumentType:
                    return CreateDocumentType( name, string.Empty, string.Empty, string.Empty );

                case XmlNodeType.Document:
                    return new XmlDocument();

                case XmlNodeType.SignificantWhitespace:
                    return CreateSignificantWhitespace( string.Empty );

                case XmlNodeType.Whitespace:
                    return CreateWhitespace( string.Empty );

                default:
                    throw new ArgumentOutOfRangeException("type");
            }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateNode1"]/*' />
        /// <devdoc>
        ///    <para>Creates
        ///       an XmlNode with the specified node type, Name, and
        ///       NamespaceURI.</para>
        /// </devdoc>
        public virtual XmlNode CreateNode( string nodeTypeString, string name, string namespaceURI ) {
            return CreateNode( ConvertToNodeType( nodeTypeString ), name, namespaceURI );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.CreateNode2"]/*' />
        /// <devdoc>
        ///    <para>Creates an XmlNode with the specified XmlNodeType, Name, and
        ///       NamespaceURI.</para>
        /// </devdoc>
        public virtual XmlNode CreateNode( XmlNodeType type, string name, string namespaceURI ) {
            return CreateNode( type, null, name, namespaceURI );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.ReadNode"]/*' />
        /// <devdoc>
        ///    <para>Creates an XmlNode object based on the information in the XmlReader.
        ///       The reader must be positioned on a node or attribute.</para>
        /// </devdoc>
        [PermissionSetAttribute( SecurityAction.InheritanceDemand, Name = "FullTrust" )]
        public virtual XmlNode ReadNode( XmlReader reader ) {
            XmlNode node = null;
            try {
                IsLoading = true;
                node = loader.ReadCurrentNode( this, reader );
            }
            finally {
                IsLoading = false;
            }
            return node;
        }

        internal XmlNodeType ConvertToNodeType( string nodeTypeString ) {
            if ( nodeTypeString == "element" ) {
                return XmlNodeType.Element;
            }
            else if ( nodeTypeString == "attribute" ) {
                return XmlNodeType.Attribute;
            }
            else if ( nodeTypeString == "text" ) {
                return XmlNodeType.Text;
            }
            else if ( nodeTypeString == "cdatasection" ) {
                return XmlNodeType.CDATA;
            }
            else if ( nodeTypeString == "entityreference" ) {
                return XmlNodeType.EntityReference;
            }
            else if ( nodeTypeString == "entity" ) {
                return XmlNodeType.Entity;
            }
            else if ( nodeTypeString == "processinginstruction" ) {
                return XmlNodeType.ProcessingInstruction;
            }
            else if ( nodeTypeString == "comment" ) {
                return XmlNodeType.Comment;
            }
            else if ( nodeTypeString == "document" ) {
                return XmlNodeType.Document;
            }
            else if ( nodeTypeString == "documenttype" ) {
                return XmlNodeType.DocumentType;
            }
            else if ( nodeTypeString == "documentfragment" ) {
                return XmlNodeType.DocumentFragment;
            }
            else if ( nodeTypeString == "notation" ) {
                return XmlNodeType.Notation;
            }
            else if ( nodeTypeString == "significantwhitespace" ) {
                return XmlNodeType.SignificantWhitespace;
            }
            else if ( nodeTypeString == "whitespace" ) {
                return XmlNodeType.Whitespace;
            }
            throw new ArgumentException( Res.GetString( Res.Xdom_Invalid_NT_String, nodeTypeString ) );
        }


        private XmlValidatingReader CreateValidatingReader( XmlTextReader tr ) {
            XmlValidatingReader vr = new XmlValidatingReader( tr );
            vr.EntityHandling = EntityHandling.ExpandCharEntities;
            vr.ValidationType = ValidationType.None;
            if ( this.HasSetResolver )
                vr.XmlResolver = GetResolver();
            return vr;
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.Load"]/*' />
        /// <devdoc>
        ///    <para>Loads the XML document from the specified URL.</para>
        /// </devdoc>
        public virtual void Load( string filename ) {
            XmlTextReader reader = new XmlTextReader( filename, NameTable );
            XmlValidatingReader vr = CreateValidatingReader( reader );
            try {
                Load( vr );
            }
            finally {
                vr.Close();
            }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.Load3"]/*' />
        public virtual void Load( Stream inStream ) {
            XmlValidatingReader vr = CreateValidatingReader( new XmlTextReader( inStream, NameTable ) );
            try {
                Load( vr );
            }
            finally {
                vr.Close( false );
            }

        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.Load1"]/*' />
        /// <devdoc>
        ///    <para>Loads the XML document from the specified TextReader.</para>
        /// </devdoc>
        public virtual void Load( TextReader txtReader ) {
            XmlValidatingReader vr = CreateValidatingReader( new XmlTextReader( txtReader, NameTable ) );
            try {
                Load( vr );
            }
            finally {
                vr.Close( false );
            }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.Load2"]/*' />
        /// <devdoc>
        ///    <para>Loads the XML document from the specified XmlReader.</para>
        /// </devdoc>
        public virtual void Load( XmlReader reader ) {
            try {
                IsLoading = true;
                actualLoadingStatus = true;
                RemoveAll();
                fEntRefNodesPresent = false;
                fIsEdited           = false;
                fCDataNodesPresent  = false;

                loader.Load( this, reader, preserveWhitespace );
            }
            finally {
                IsLoading = false;
                actualLoadingStatus = false;
            }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.LoadXml"]/*' />
        /// <devdoc>
        ///    <para>Loads the XML document from the specified string.</para>
        /// </devdoc>
        public virtual void LoadXml( string xml ) {
            XmlValidatingReader reader = CreateValidatingReader( new XmlTextReader( new StringReader( xml ) ));
            try {
                Load( reader );
            }
            finally {
                reader.Close();
            }
        }

        //TextEncoding is the one from XmlDeclaration if there is any
        internal Encoding TextEncoding {
            get {
                if ( Declaration != null )
                {
                    string value = Declaration.Encoding;
                    if ( value != string.Empty ) {
                        return System.Text.Encoding.GetEncoding( value );
                    }
                }
                return null;
            }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.InnerXml"]/*' />
        public override string InnerXml {
            get {
                return base.InnerXml;
            }
            set {
                LoadXml( value );
            }
        }


        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.Save"]/*' />
        /// <devdoc>
        ///    <para>Saves the XML document to the specified file.</para>
        /// </devdoc>
        //Saves out the to the file with exact content in the XmlDocument.
        public virtual void Save( string filename ) {
            if ( DocumentElement == null )
                throw new XmlException( Res.Xml_InvalidXmlDocument, Res.GetString( Res.Xdom_NoRootEle ) );
            XmlDOMTextWriter xw = new XmlDOMTextWriter( filename, TextEncoding );
            try {
                if ( preserveWhitespace == false )
                    xw.Formatting = Formatting.Indented;
                 WriteTo( xw );
            }
            finally {
                xw.Flush();
                xw.Close();
            }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.Save3"]/*' />
        //Saves out the to the file with exact content in the XmlDocument.
        public virtual void Save( Stream outStream ) {
            XmlDOMTextWriter xw = new XmlDOMTextWriter( outStream, TextEncoding );
            if ( preserveWhitespace == false )
                xw.Formatting = Formatting.Indented;
            WriteTo( xw );
            xw.Flush();
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.Save1"]/*' />
        /// <devdoc>
        ///    <para>Saves the XML document to the specified TextWriter.</para>
        /// </devdoc>
        //Saves out the file with xmldeclaration which has encoding value equal to
        //that of textwriter's encoding
        public virtual void Save( TextWriter writer ) {
            XmlDOMTextWriter xw = new XmlDOMTextWriter( writer );
            if ( preserveWhitespace == false )
                    xw.Formatting = Formatting.Indented;
            Save( xw );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.Save2"]/*' />
        /// <devdoc>
        ///    <para>Saves the XML document to the specified XmlWriter.</para>
        /// </devdoc>
        //Saves out the file with xmldeclaration which has encoding value equal to
        //that of textwriter's encoding
        public virtual void Save( XmlWriter w ) {
            XmlNode n = this.FirstChild;
            if( n == null )
                return;
            if( w.WriteState == WriteState.Start ) {
                if( n is XmlDeclaration ) {
                    if( Standalone == String.Empty )
                        w.WriteStartDocument();
                    else if( Standalone == "yes" )
                        w.WriteStartDocument( true );
                    else if( Standalone == "no" )
                        w.WriteStartDocument( false );
                    n = n.NextSibling;
                }
                else {
                    w.WriteStartDocument();
                }
            }
            while( n != null ) {
                Debug.Assert( n.NodeType != XmlNodeType.XmlDeclaration );
                n.WriteTo( w );
                n = n.NextSibling;
            }
            w.Flush();
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.WriteTo"]/*' />
        /// <devdoc>
        ///    <para>Saves the node to the specified XmlWriter.</para>
        /// </devdoc>
        //Writes out the to the file with exact content in the XmlDocument.
        public override void WriteTo( XmlWriter w ) {
            WriteContentTo( w );
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.WriteContentTo"]/*' />
        /// <devdoc>
        ///    <para>Saves all the children of the node to the specified XmlWriter.</para>
        /// </devdoc>
        //Writes out the to the file with exact content in the XmlDocument.
        public override void WriteContentTo( XmlWriter xw ) {
            foreach( XmlNode n in this ) {
                n.WriteTo( xw );
            }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.NodeInserting"]/*' />
        /// <devdoc>
        /// </devdoc>
        public event XmlNodeChangedEventHandler NodeInserting {
            add {
                onNodeInsertingDelegate += value;
            }
            remove {
                onNodeInsertingDelegate -= value;
            }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.NodeInserted"]/*' />
        /// <devdoc>
        /// </devdoc>
        public event XmlNodeChangedEventHandler NodeInserted {
            add {
                onNodeInsertedDelegate += value;
            }
            remove {
                onNodeInsertedDelegate -= value;
            }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.NodeRemoving"]/*' />
        /// <devdoc>
        /// </devdoc>
        public event XmlNodeChangedEventHandler NodeRemoving {
            add {
                onNodeRemovingDelegate += value;
            }
            remove {
                onNodeRemovingDelegate -= value;
            }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.NodeRemoved"]/*' />
        /// <devdoc>
        /// </devdoc>
        public event XmlNodeChangedEventHandler NodeRemoved {
            add {
                onNodeRemovedDelegate += value;
            }
            remove {
                onNodeRemovedDelegate -= value;
            }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.NodeChanging"]/*' />
        /// <devdoc>
        /// </devdoc>
        public event XmlNodeChangedEventHandler NodeChanging {
            add {
                onNodeChangingDelegate += value;
            }
            remove {
                onNodeChangingDelegate -= value;
            }
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.NodeChanged"]/*' />
        /// <devdoc>
        /// </devdoc>
        public event XmlNodeChangedEventHandler NodeChanged {
            add {
                onNodeChangedDelegate += value;
            }
            remove {
                onNodeChangedDelegate -= value;
            }
        }

        internal override XmlNodeChangedEventArgs GetEventArgs( XmlNode node, XmlNode oldParent, XmlNode newParent, XmlNodeChangedAction action ) {
            if ((action == XmlNodeChangedAction.Insert && (onNodeInsertingDelegate != null || onNodeInsertedDelegate != null))
                || (action == XmlNodeChangedAction.Remove && (onNodeRemovingDelegate != null || onNodeRemovedDelegate != null))
                || (action == XmlNodeChangedAction.Change && (onNodeChangingDelegate != null || onNodeChangedDelegate != null))) {
                return new XmlNodeChangedEventArgs( node, oldParent, newParent, action );
            }

            return null;
        }

        internal XmlNodeChangedEventArgs GetInsertEventArgsForLoad( XmlNode node, XmlNode newParent ) {
            if ( onNodeInsertingDelegate != null || onNodeInsertedDelegate != null )
                return new XmlNodeChangedEventArgs( node, null, newParent, XmlNodeChangedAction.Insert );
            return null;
        }

        internal override void BeforeEvent( XmlNodeChangedEventArgs args ) {
            if ( args != null ) {
                switch ( args.Action ) {
                    case XmlNodeChangedAction.Insert:
                        if ( onNodeInsertingDelegate != null )
                            onNodeInsertingDelegate( this, args );
                        break;

                    case XmlNodeChangedAction.Remove:
                        if ( onNodeRemovingDelegate != null )
                            onNodeRemovingDelegate( this, args );
                        break;

                    case XmlNodeChangedAction.Change:
                        if ( onNodeChangingDelegate != null )
                            onNodeChangingDelegate( this, args );
                        break;
                }
            }
        }

        internal override void AfterEvent( XmlNodeChangedEventArgs args ) {
            if ( args != null ) {
                switch ( args.Action ) {
                    case XmlNodeChangedAction.Insert:
                        if ( onNodeInsertedDelegate != null )
                            onNodeInsertedDelegate( this, args );
                        break;

                    case XmlNodeChangedAction.Remove:
                        if ( onNodeRemovedDelegate != null )
                            onNodeRemovedDelegate( this, args );
                        break;

                    case XmlNodeChangedAction.Change:
                        if ( onNodeChangedDelegate != null )
                            onNodeChangedDelegate( this, args );
                        break;
                }
            }
        }

        // The function such through schema info to find out if there exists a default attribute with passed in names in the passed in element
        // If so, return the newly created default attribute (with children tree);
        // Otherwise, return null.

        internal XmlAttribute GetDefaultAttribute( XmlElement elem, string attrPrefix, string attrLocalname, string attrNamespaceURI ) {
            SchemaInfo schInfo = SchemaInformation;
            SchemaElementDecl ed = GetSchemaElementDecl( elem );
            if ( ed != null && ed.AttDefs != null ) {
                IDictionaryEnumerator _attrDefs = ed.AttDefs.GetEnumerator();
                while ( _attrDefs.MoveNext() ) {
                    SchemaAttDef attdef = (SchemaAttDef)_attrDefs.Value;
                    if ( attdef.Presence == SchemaDeclBase.Use.Default ||
                        attdef.Presence == SchemaDeclBase.Use.Fixed ) {
                        if ( attdef.Name.Name == attrLocalname ) {
                            if ( ( schInfo.SchemaType == SchemaType.DTD && attdef.Name.Namespace == attrPrefix ) ||
                                 ( schInfo.SchemaType != SchemaType.DTD && attdef.Name.Namespace == attrNamespaceURI ) ) {
                                 //find a def attribute with the same name, build a default attribute and return
                                 XmlAttribute defattr = PrepareDefaultAttribute( attdef, attrPrefix, attrLocalname, attrNamespaceURI );
                                 return defattr;
                            }
                        }
                    }
                }
            }
            return null;
        }

        internal String Version {
            get {
                XmlDeclaration decl = Declaration;
                if ( decl != null )
                    return decl.Version;
                return null;
            }
        }

        internal String Encoding {
            get {
                XmlDeclaration decl = Declaration;
                if ( decl != null )
                    return decl.Encoding;
                return null;
            }
        }

        internal String Standalone {
            get {
                XmlDeclaration decl = Declaration;
                if ( decl != null )
                    return decl.Standalone;
                return null;
            }
        }

        internal XmlEntity GetEntityNode( String name ) {
            if ( DocumentType != null ) {
                XmlNamedNodeMap entites = DocumentType.Entities;
                if ( entites != null )
                    return (XmlEntity)(entites.GetNamedItem( name ));
            }
            return null;
        }

        /// <include file='doc\XmlDocument.uex' path='docs/doc[@for="XmlDocument.BaseURI"]/*' />
        public override String BaseURI {
            get { return baseURI; }
        }

        internal void SetBaseURI( String inBaseURI ) {
            baseURI = inBaseURI;
        }

        internal override XmlNode AppendChildForLoad( XmlNode newChild, XmlDocument doc ) {
            Debug.Assert( doc == this );

            if ( !IsValidChildType( newChild.NodeType ))
                throw new InvalidOperationException( Res.GetString(Res.Xdom_Node_Insert_TypeConflict) );

            if ( !CanInsertAfter( newChild, LastChild ) )
                throw new InvalidOperationException( Res.GetString(Res.Xdom_Node_Insert_Location) );

            XmlNodeChangedEventArgs args = GetInsertEventArgsForLoad( newChild, this );

            if ( args != null )
                BeforeEvent( args );

            XmlLinkedNode newNode = (XmlLinkedNode) newChild;

            if ( lastChild == null ) {
                newNode.next = newNode;
            }
            else {
                newNode.next = lastChild.next;
                lastChild.next = newNode;
            }

            lastChild = newNode;
            newNode.SetParentForLoad( this );

            if ( args != null )
                AfterEvent( args );

            return newNode;
        }

        internal override XPathNodeType XPNodeType { get { return XPathNodeType.Root; } }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlelementlist.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlElementList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlElementList.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml {
    using System;
    using System.Collections;
    using System.Diagnostics;

    internal class XmlElementList: XmlNodeList {
        string      asterisk;
        int         changeCount; //recording the total number that the dom tree has been changed ( insertion and deletetion )
        //the member vars below are saved for further reconstruction        
        string      name;         //only one of 2 string groups will be initialized depends on which constructor is called.
        string      localName; 
        string      namespaceURI;
        XmlNode     rootNode;
        // the memeber vars belwo serves the optimization of accessing of the elements in the list
        int         curInd;       // -1 means the starting point for a new search round
        XmlNode     curElem;      // if sets to rootNode, means the starting point for a new search round
        bool        empty;        // whether the list is empty
        bool        atomized;     //whether the localname and namespaceuri are aomized

        private XmlElementList( XmlNode parent) {
            Debug.Assert ( parent != null );
            Debug.Assert( parent.NodeType == XmlNodeType.Element || parent.NodeType == XmlNodeType.Document );
            this.rootNode = parent;
            Debug.Assert( parent.Document != null );
            parent.Document.NodeInserted +=  new XmlNodeChangedEventHandler( this.OnListChanged ) ;
            parent.Document.NodeRemoved +=  new XmlNodeChangedEventHandler( this.OnListChanged ) ;
            this.curInd = -1;
            this.curElem = rootNode;
            this.changeCount = 0;
            this.empty = false;
            this.atomized = true; 
        }

        private void OnListChanged( object sender, XmlNodeChangedEventArgs args ) {
            if( atomized == false ) {
                this.localName = this.rootNode.Document.NameTable.Add( this.localName );
                this.namespaceURI = this.rootNode.Document.NameTable.Add( this.namespaceURI );
                this.atomized = true;
            }                
            if ( IsMatch( args.Node ) ) {
                this.changeCount++ ;
                this.curInd = -1;
                this.curElem = rootNode;
                if( args.Action == XmlNodeChangedAction.Insert )
                    this.empty = false;
            }
        }

        internal XmlElementList( XmlNode parent, string name ): this( parent ) {
            Debug.Assert( parent.Document != null );            
            XmlNameTable nt = parent.Document.NameTable;
            Debug.Assert( nt != null );
            asterisk = nt.Add("*");
            this.name = nt.Add( name );
            this.localName = null;
            this.namespaceURI = null;
        }

        internal XmlElementList( XmlNode parent, string localName, string namespaceURI ): this( parent ) {
            Debug.Assert( parent.Document != null );
            XmlNameTable nt = parent.Document.NameTable;
            Debug.Assert( nt != null );
            asterisk = nt.Add("*");
            this.localName = nt.Get( localName );
            this.namespaceURI = nt.Get( namespaceURI );
            if( (this.localName == null) || (this.namespaceURI== null) ) {
                this.empty = true;
                this.atomized = false;
                this.localName = localName;
                this.namespaceURI = namespaceURI;
            }   
                this.name = null;
        }
        
        internal int ChangeCount {
            get { return changeCount; }
        }

        // return the next element node that is in PreOrder
        private XmlNode NextElemInPreOrder( XmlNode curNode ) {
            Debug.Assert( curNode != null );
            //For preorder walking, first try its child
            XmlNode retNode = curNode.FirstChild;
            if ( retNode == null ) {
                //if no child, the next node forward will the be the NextSibling of the first ancestor which has NextSibling
                //so, first while-loop find out such an ancestor (until no more ancestor or the ancestor is the rootNode
                retNode = curNode;
                while ( retNode != null 
                        && retNode != rootNode 
                        && retNode.NextSibling == null ) {
                    retNode = retNode.ParentNode;
                }
                //then if such ancestor exists, set the retNode to its NextSibling
                if ( retNode != null && retNode != rootNode )
                    retNode = retNode.NextSibling;
            }
            if ( retNode == this.rootNode ) 
                //if reach the rootNode, consider having walked through the whole tree and no more element after the curNode
                retNode = null;
            return retNode;
        }

        // return the previous element node that is in PreOrder
        private XmlNode PrevElemInPreOrder( XmlNode curNode ) {
            Debug.Assert( curNode != null );
            //For preorder walking, the previous node will be the right-most node in the tree of PreviousSibling of the curNode
            XmlNode retNode = curNode.PreviousSibling;
            // so if the PreviousSibling is not null, going through the tree down to find the right-most node
            while ( retNode != null ) {
                if ( retNode.LastChild == null )
                    break;
                retNode = retNode.LastChild;
            }
            // if no PreviousSibling, the previous node will be the curNode's parentNode
            if ( retNode == null )
                retNode = curNode.ParentNode;
            // if the final retNode is rootNode, consider having walked through the tree and no more previous node
            if ( retNode == this.rootNode )
                retNode = null;
            return retNode;
        }

        // if the current node a matching element node
        private bool IsMatch ( XmlNode curNode ) {
            if (curNode.NodeType == XmlNodeType.Element) {
                if ( this.name != null ) {
                    if ( Ref.Equal(this.name, asterisk) || Ref.Equal(curNode.Name, this.name) )
                        return true;
                } 
                else {
                    if (
                        (Ref.Equal(this.localName, asterisk) || Ref.Equal(curNode.LocalName, this.localName) ) && 
                        (Ref.Equal(this.namespaceURI, asterisk) || curNode.NamespaceURI == this.namespaceURI )
                    ) {
                        return true;
                    }
                }
            }     
            return false;
        }

        private XmlNode GetMatchingNode( XmlNode n, bool bNext ) {
            Debug.Assert( n!= null );
            XmlNode node = n;            
            do {
                if ( bNext )
                    node = NextElemInPreOrder( node );
                else
                    node = PrevElemInPreOrder( node );
            } while ( node != null && !IsMatch( node ) );
            return node;
        }

        private XmlNode GetNthMatchingNode( XmlNode n, bool bNext, int nCount ) {
            Debug.Assert( n!= null );
            XmlNode node = n;
            for ( int ind = 0 ; ind < nCount; ind++ ) {
                node = GetMatchingNode( node, bNext );
                if ( node == null )
                    return null;
            } 
            return node;
        }

        //the function is for the enumerator to find out the next available matching element node
        public XmlNode GetNextNode( XmlNode n ) {
            if( this.empty == true )
                return null;
            XmlNode node = ( n == null ) ? rootNode : n;
            return GetMatchingNode( node, true );
        }

        public override XmlNode Item(int index) {
            if ( rootNode == null || index < 0 ) 
                return null;

            if( this.empty == true )
                return null;
            if ( curInd == index )
                return curElem;
            int nDiff = index - curInd;
            bool bForward = ( nDiff > 0 );
            if ( nDiff < 0 )
                nDiff = -nDiff;
            XmlNode node;
            if ( ( node = GetNthMatchingNode( curElem, bForward, nDiff ) ) != null ) {
                curInd = index;
                curElem = node;
                return curElem;
            } 
            return null;
        }

        public override int Count { 
            get { 
                if( this.empty == true )
                    return 0;
                int nCount = 0;
                XmlNode node = rootNode;
                while ( ( node = GetMatchingNode( node, true ) ) != null ) 
                    nCount++;
                return nCount;
            }
        }
    
        public override IEnumerator GetEnumerator() {
            if( this.empty == true )
                return new XmlEmptyElementListEnumerator(this);;
            return new XmlElementListEnumerator(this);
        }
    }

     internal class XmlElementListEnumerator : IEnumerator {
        XmlElementList  list;
        XmlNode         curElem;
        int             changeCount; //save the total number that the dom tree has been changed ( insertion and deletetion ) when this enumerator is created

        public XmlElementListEnumerator( XmlElementList list ) {
            this.list = list;
            this.curElem = null;
            this.changeCount = list.ChangeCount;
        }

        public bool MoveNext() { 
            if ( list.ChangeCount != this.changeCount ) {
                //the number mismatch, there is new change(s) happened since last MoveNext() is called.
                throw new InvalidOperationException( Res.GetString(Res.Xdom_Enum_ElementList) );
            } 
            else  {
                curElem = list.GetNextNode( curElem );                
            }
            return curElem != null;
        }

        public void Reset() {
            curElem = null;
            //reset the number of changes to be synced with current dom tree as well
            this.changeCount = list.ChangeCount;
        }

        public object Current {
            get { return curElem; }
        }
    }
    
    internal class XmlEmptyElementListEnumerator : IEnumerator {        
        public XmlEmptyElementListEnumerator( XmlElementList list ) {
        }

        public bool MoveNext() { 
            return false;
        }

        public void Reset() {
        }
        
        public object Current {
            get { return null; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmldownloadmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlDownloadManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml {

    using System;
    using System.IO;
    using System.Net;
    using System.Xml.Schema;
    using System.Collections;

    internal class XmlDownloadManager {
        Hashtable _connections = new Hashtable();

        internal XmlDownloadManager () { }

        internal Stream GetStream(Uri uri, ICredentials credentials) {
            if (uri.Scheme == "file") {
                return new FileStream(uri.LocalPath, FileMode.Open, FileAccess.Read, FileShare.Read);
            }
            else {
                return GetNonFileStream(uri, credentials);
            }
        }

        private Stream GetNonFileStream(Uri uri, ICredentials credentials) {
            WebRequest req = WebRequest.Create(uri);
            if (credentials != null) {
                req.Credentials = credentials;
            }
            WebResponse resp = req.GetResponse();
            if (req is HttpWebRequest) {
                HttpWebRequest req1 = (HttpWebRequest)req;
                lock (_connections) {
                    XmlWebConnectionLimit limit = (XmlWebConnectionLimit)_connections[req1.Address.Host];
                    if (limit == null) {
                        limit = new XmlWebConnectionLimit(req1.ServicePoint.ConnectionLimit);
                        _connections.Add(req1.Address.Host, limit);
                    }
                    limit.Limit++;
                    req1.ServicePoint.ConnectionLimit = limit.Limit;
                }
                return new XmlEntityStream(resp.GetResponseStream(), this, req1.Address);
            }
            else {
                return resp.GetResponseStream();
            }
        }

        internal void Remove(XmlEntityStream stream) {
            lock (_connections) {
                XmlWebConnectionLimit limit = (XmlWebConnectionLimit)_connections[stream.Uri.Host];
                if (limit != null) {
                    limit.Limit--;
                    if (limit.Limit <= limit.OriginalLimit)
                        _connections.Remove(stream.Uri.Host);
                }
            }
        }

    }

    internal class XmlWebConnectionLimit {
        int _originalLimit;
        int _limit;

        internal XmlWebConnectionLimit(int originalLimit) {
            _limit = _originalLimit = originalLimit;
        }

        internal int OriginalLimit {
            get { return _originalLimit; }
            set { _originalLimit = value; }
        }

        internal int Limit {
            get { return _limit; }
            set { _limit = value; }
        }
    }

    internal class XmlEntityStream : Stream {
        Stream _stream;
        XmlDownloadManager _downloadManager;
        Uri _uri;

        //
        // constructor:
        //
        internal XmlEntityStream(Stream stream, XmlDownloadManager downloadManager, Uri uri) {
            _stream = stream;
            _downloadManager = downloadManager;
            _uri = uri;
        }

        //
        // destructor:
        //
        ~XmlEntityStream() {
            Close();
        } // Finalize()

        public override IAsyncResult BeginRead(Byte[] buffer, Int32 offset, Int32 count, AsyncCallback callback, Object state) {
            return _stream.BeginRead(buffer, offset, count, callback, state);
        }

        public override IAsyncResult BeginWrite(Byte[] buffer, Int32 offset, Int32 count, AsyncCallback callback, Object state) {
            return BeginWrite(buffer, offset, count, callback, state);
        }

        public override void Close () {
            if (_stream != null) {
                _downloadManager.Remove(this);
                _stream.Close();
                _stream = null;
            }
        }

        public override Int32 EndRead(IAsyncResult asyncResult) {
            return _stream.EndRead(asyncResult);
        }

        public override void EndWrite(IAsyncResult asyncResult) {
            _stream.EndWrite(asyncResult);
        }

        public override void Flush( ) {
            _stream.Flush();
        }

        public override Int32 Read(Byte[] buffer, Int32 offset, Int32 count) {
            return _stream.Read(buffer, offset, count);
        }

        public override Int32 ReadByte( ) {
            return _stream.ReadByte();
        }

        public override Int64 Seek(Int64 offset, SeekOrigin origin) {
            return _stream.Seek(offset, origin);
        }

        public override void SetLength(Int64 value) {
            _stream.SetLength(value);
        }

        public override void Write(Byte[] buffer, Int32 offset, Int32 count) {
            _stream.Write(buffer, offset, count);
        }

        public override void WriteByte(Byte value) {
            _stream.WriteByte(value);
        }

        public override Boolean CanRead {
            get { return _stream.CanRead; }
        }

        public override Boolean CanSeek {
            get { return _stream.CanSeek; }
        }

        public override Boolean CanWrite {
            get { return _stream.CanWrite; }
        }

        public override Int64 Length {
            get { return _stream.Length; }
        }

        public override Int64 Position {
            get { return _stream.Position; }
            set { _stream.Position = value; }
        }

        internal Uri Uri{
            get { return _uri; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlelementidmap.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlElementIdMap.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlElementIdMap.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml
{
    using System.Collections;

    internal class XmlElementIdMap
    {
        internal XmlDocument    doc;
        internal Hashtable      htElementIdMap;
        internal Hashtable      htElementIDAttrDecl; //key: id; object: the ArrayList of the elements that have the same id (connected or disconnected)

        internal XmlElementIdMap( XmlDocument doc )
        {
            this.doc = doc;
            htElementIDAttrDecl = new Hashtable();
            htElementIdMap = new Hashtable();
        }

        internal bool BindIDAttributeWithElementType(XmlName eleName, XmlName attrName)
        {
            if ( htElementIDAttrDecl[eleName] == null ) {
                htElementIDAttrDecl.Add(eleName, attrName);
                return true;
            }
            return false;
        }

        internal XmlName GetIDAttributeByElement(XmlName eleName)
        {
            return (XmlName)(htElementIDAttrDecl[eleName]);
        }

        internal void AddElementWithId(string id, XmlElement elem)
        {
            if (!htElementIdMap.Contains(id)) {
                ArrayList elementList = new ArrayList();
                elementList.Add(elem);
                htElementIdMap.Add(id, elementList);
            }
            else {
                // there are other element(s) that has the same id
                ArrayList elementList = (ArrayList)(htElementIdMap[id]);
                if (!(elementList.Contains(elem)))
                    elementList.Add(elem);
            }
        }

        internal void RemoveElementWithId(string id, XmlElement elem)
        {
            if (htElementIdMap != null && htElementIdMap.Contains(id)) {
                ArrayList elementList = (ArrayList)(htElementIdMap[id]);
                if (elementList.Contains(elem)) {
                    elementList.Remove(elem);
                    if (elementList.Count == 0)
                        htElementIdMap.Remove(id);
                }
            }
        }

        internal XmlElement GetElementById(string id)
        {
            ArrayList elementList = (ArrayList)(htElementIdMap[id]);
            if (elementList != null) {
                foreach (XmlElement elem in elementList) {
                    if (elem.IsConnected())
                        return elem;
                }
            }
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlencoding.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlEncoding.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlEncoding.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    using System.Text;


    internal abstract class Ucs4Decoder : Decoder {

        internal byte [] temp = new byte[4];
        internal int tempBytes=0;
        internal bool byteOrderMarkSkipped=false;

        public override int GetCharCount(byte[] bytes,int index,int count) {
            return (count + tempBytes)/4;
        }

        internal abstract int skipByteOrderMark(byte[] bytes, int byteIndex);
        internal int skipByteOrderMark(byte[] bytes, int byteIndex,int byteCount)
        {
            if (byteCount < 4)
                return 0;
            return skipByteOrderMark(bytes, byteIndex);
        }

        internal abstract int GetFullChars(byte[] bytes,int byteIndex,int byteCount,char[] chars,int charIndex);

        public override int GetChars(byte[] bytes,int byteIndex,int byteCount,char[] chars,int charIndex) {
            int i = tempBytes;

            if (byteOrderMarkSkipped == false) {
                if (skipByteOrderMark(bytes, byteIndex, byteCount) == 4) {
                    byteIndex += 4;
                    byteCount -= 4;
                    byteOrderMarkSkipped = true;
                }
            }

            if( tempBytes > 0) {
                for(; i < 4; i++) {
                    temp[i] = bytes[byteIndex];
                    byteIndex++;
                    byteCount--;
                }
                i = 1;
                GetFullChars(temp, 0 , 4, chars, charIndex);
                charIndex++;
            }
            else i = 0;
            i = GetFullChars(bytes, byteIndex , byteCount, chars, charIndex) + i;

            int j = ( tempBytes + byteCount ) % 4;
            byteCount += byteIndex;
            byteIndex =  byteCount - j;
            tempBytes = 0;

            if(byteIndex >= 0)
                for(; byteIndex < byteCount; byteIndex++){
                    temp[tempBytes] = bytes[byteIndex];
                    tempBytes++;
                }
            return i;
        }

        internal char UnicodeToUTF16( UInt32 code) {
            byte lowerByte, higherByte;
            lowerByte = (byte) (0xD7C0 + (code >> 10));
            higherByte = (byte) (0xDC00 | code & 0x3ff);
            return ((char) ((higherByte << 8) | lowerByte));
        }
    }


    internal class Ucs4Decoder4321 : Ucs4Decoder  {

        internal override int skipByteOrderMark(byte[] bytes, int byteIndex){
            if (XmlScanner.AutoDetectEncoding(bytes, byteIndex) == 7 )
                return 4;
            return 0;
        }
        internal override int GetFullChars(byte[] bytes,int byteIndex,int byteCount,char[] chars,int charIndex) {
            UInt32 code;
            int i, j;
            byteCount += byteIndex;
            for (i = byteIndex, j = charIndex; i+3 < byteCount;) {
                code =  (UInt32) (((bytes[i+3])<<24) | (bytes[i+2]<<16) | (bytes[i+1]<<8) | (bytes[i]));
                if (code > 0x10FFFF) {
                    throw new XmlException(Res.Xml_InvalidCharInThisEncoding, string.Empty);
                }
                else if (code > 0xFFFF) {
                    chars[j] = UnicodeToUTF16(code);
                    j++;
                }
                else {
                    if (code >= 0xD800 && code <= 0xDFFF) {
                        throw new XmlException(Res.Xml_InvalidCharInThisEncoding, string.Empty);
                    }
                    else {
                        chars[j] = (char) code;
                    }
                }
                j++;
                i += 4;
            }
            return j - charIndex;
        }
    };

    internal class Ucs4Decoder1234 : Ucs4Decoder  {

        internal override int skipByteOrderMark(byte[] bytes, int byteIndex){
            if (XmlScanner.AutoDetectEncoding(bytes, byteIndex) == 5 )
                return 4;
            return 0;
        }

        internal override int GetFullChars(byte[] bytes,int byteIndex,int byteCount,char[] chars,int charIndex)
        {
            UInt32 code;
            int i,j;
            byteCount += byteIndex;
            for (i = byteIndex, j = charIndex; i+3 < byteCount;) {
                code = (UInt32) (((bytes[i])<<24) | (bytes[i+1]<<16) | (bytes[i+2]<<8) | (bytes[i+3]));
                if (code > 0x10FFFF) {
                    throw new XmlException(Res.Xml_InvalidCharInThisEncoding, string.Empty);
                }
                else if (code > 0xFFFF) {
                    chars[j] = UnicodeToUTF16(code);
                    j++;
                }
                else {
                    if (code >= 0xD800 && code <= 0xDFFF) {
                        throw new XmlException(Res.Xml_InvalidCharInThisEncoding, string.Empty);
                    }
                    else {
                        chars[j] = (char) code;
                    }
                }
                j++;
                i += 4;
            }
            return j - charIndex;
        }
    }


    internal class Ucs4Decoder2143 : Ucs4Decoder  {

        internal override int skipByteOrderMark(byte[] bytes, int byteIndex){
            if (XmlScanner.AutoDetectEncoding(bytes, byteIndex) == 11 )
                return 4;
            return 0;
        }

        internal override int GetFullChars(byte[] bytes,int byteIndex,int byteCount,char[] chars,int charIndex)
        {
            UInt32 code;
            int i,j;
            byteCount += byteIndex;
            for (i = byteIndex, j = charIndex; i+3 < byteCount;) {
                code = (UInt32) (((bytes[i+1])<<24) | (bytes[i]<<16) | (bytes[i+3]<<8) | (bytes[i+2]));
                if (code > 0x10FFFF) {
                    throw new XmlException(Res.Xml_InvalidCharInThisEncoding, string.Empty);

                }
                else if (code > 0xFFFF) {
                    chars[j] = UnicodeToUTF16(code);
                    j++;
                }
                else {
                    if (code >= 0xD800 && code <= 0xDFFF) {
                        throw new XmlException(Res.Xml_InvalidCharInThisEncoding, string.Empty);
                    }
                    else {
                        chars[j] = (char) code;
                    }
                }
                j++;
                i += 4;
            }
            return j - charIndex;
        }
    }


    internal class Ucs4Decoder3412 : Ucs4Decoder  {

        internal override int skipByteOrderMark(byte[] bytes, int byteIndex){
            if (XmlScanner.AutoDetectEncoding(bytes, byteIndex) == 9 )
                return 4;
            return 0;
        }

        internal override int GetFullChars(byte[] bytes,int byteIndex,int byteCount,char[] chars,int charIndex)
        {
            UInt32 code;
            int i,j;
            byteCount += byteIndex;
            for (i = byteIndex, j = charIndex; i+3 < byteCount;) {
                code = (UInt32) (((bytes[i+2])<<24) | (bytes[i+3]<<16) | (bytes[i]<<8) | (bytes[i+1]));
                if (code > 0x10FFFF) {
                    throw new XmlException(Res.Xml_InvalidCharInThisEncoding, string.Empty);
                }
                else if (code > 0xFFFF) {
                    chars[j] = UnicodeToUTF16(code);
                    j++;
                }
                else {
                    if (code >= 0xD800 && code <= 0xDFFF) {
                        throw new XmlException(Res.Xml_InvalidCharInThisEncoding, string.Empty);
                    }
                    else {
                        chars[j] = (char) code;
                    }
                }
                j++;
                i += 4;
            }
            return j - charIndex;
        }
    }

    internal class Ucs4Encoding : Encoding  {
        internal Ucs4Decoder ucs4Decoder;

        public override Decoder GetDecoder() {
            return ucs4Decoder;
        }


        //Encoder based functions
        public override int GetByteCount (char[] chars, int index, int count) {
            return count*4;
        }

        public override Int32 GetByteCount (Char[] chars) {
            return chars.Length * 4;
        }

        public override Byte[] GetBytes (String s) {
            return null; //ucs4Decoder.GetByteCount(chars, index, count);
        }
        public override Int32 GetBytes (Char[] chars, Int32 charIndex, Int32 charCount, Byte[] bytes, Int32 byteIndex) {
            return 0;
        }
        public override Int32 GetMaxByteCount (Int32 charCount)  {
            return 0;
        }

        public override Int32 GetCharCount (Byte[] bytes, Int32 index, Int32 count) {
            return ucs4Decoder.GetCharCount(bytes, index, count);
        }

        public override Int32 GetChars (Byte[] bytes, Int32 byteIndex, Int32 byteCount, Char[] chars, Int32 charIndex) {
            return ucs4Decoder.GetChars(bytes, byteIndex, byteCount, chars, charIndex);
        }

        public override Int32 GetMaxCharCount (Int32 byteCount) {
            return (byteCount+3)/4;
        }

        public override Int32 CodePage {
            get { return 0;}
        }

        public override Int32 GetCharCount (Byte[] bytes) {
            return bytes.Length / 4;
        }

        public override Encoder GetEncoder ( ) {
            return null;
        }

        internal static Encoding UCS4_Littleendian {
            get{
                return new Ucs4Encoding4321();
            }
        }

        internal static Encoding UCS4_Bigendian {
            get {
                return new Ucs4Encoding1234();
            }
        }

        internal static Encoding UCS4_2143 {
            get {
                return new Ucs4Encoding2143();
            }
        }
        internal static Encoding UCS4_3412 {
            get {
                return  new Ucs4Encoding3412();
            }
        }
    }

    internal class Ucs4Encoding1234 : Ucs4Encoding {

        public Ucs4Encoding1234()
        {
            ucs4Decoder = new Ucs4Decoder1234();
        }

        public override String EncodingName
        {
            get { return "ucs-4 (Bigendian)";}
        }

        public override byte[] GetPreamble() {
            byte[] buffer = new byte[4];
            buffer[0] = 0x00;
            buffer[1] = 0x00;
            buffer[2] = 0xfe;
            buffer[3] = 0xff;
            return buffer;
        }
    }

    internal class Ucs4Encoding4321 : Ucs4Encoding {
        public Ucs4Encoding4321()
        {
            ucs4Decoder = new Ucs4Decoder4321();
        }

        public override String EncodingName
        {
            get { return "ucs-4";}
        }
        public override byte[] GetPreamble() {
            byte[] buffer = new byte[4];
            buffer[0] = 0xff;
            buffer[1] = 0xfe;
            buffer[2] = 0x00;
            buffer[3] = 0x00;
            return buffer;
        }
    }

    internal class Ucs4Encoding2143 : Ucs4Encoding {
        public Ucs4Encoding2143()
        {
            ucs4Decoder = new Ucs4Decoder2143();
        }

        public override String EncodingName {
            get { return "ucs-4 (order 2143)";}
        }
        public override byte[] GetPreamble() {
            byte[] buffer = new byte[4];
            buffer[0] = 0x00;
            buffer[1] = 0x00;
            buffer[2] = 0xff;
            buffer[3] = 0xfe;
            return buffer;
        }
    }

    internal class Ucs4Encoding3412 : Ucs4Encoding {
        public Ucs4Encoding3412()
        {
            ucs4Decoder = new Ucs4Decoder3412();
        }

        public override String EncodingName {
            get { return "ucs-4 (order 3412)";}
        }

        public override byte[] GetPreamble() {
            byte[] buffer = new byte[4];
            buffer[0] = 0xfe;
            buffer[1] = 0xff;
            buffer[2] = 0x00;
            buffer[3] = 0x00;
            return buffer;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlentityreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlEntityReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml
{
    using System.IO;
    using System.Text;

    internal class XmlEntityReader : XmlTextReader {
        String      _PrevXmlLang;
        XmlSpace    _PrevXmlSpace;
        int         _PrevLineNum;
        int         _PrevLinePos;
        Encoding    _EndEntityEncoding;
        bool        _IsAttributeText;
        bool        _IsScanner;
        String      _OriginalBaseUri;

        internal XmlEntityReader(XmlScanner scanner, XmlNameTable nt, XmlNamespaceManager nsMgr, XmlNodeType node, String entityName, int depth, Encoding encoding, String baseURI,
                                bool isExternal, bool isAttributeText, bool standAlone, String originalBaseURI) :
                                base((scanner == null ? new XmlScanner(new StringReader("a"), nt) : scanner), nt, nsMgr, node, depth, encoding, baseURI, isExternal, standAlone) {
            if (scanner == null) {
                _IsScanner = false;
                _AttributeTextToken = new XmlNSAttributeTokenInfo(_Scanner, _NsMgr, XmlNodeType.Text, Normalization, _XmlNs);
                _AttributeTextToken.Value = String.Empty;
                _AttributeTextToken.Depth = depth + 1;
            }
            else {
                _IsScanner = true;
            }
            _IsExternal = isExternal;
            //We only need to return the EndEntity token when EntityHandling = ExpandCharEntity
            _EndEntityToken = new XmlNameValueTokenInfo(_Scanner, _NsMgr, XmlNodeType.EndEntity, depth-1, String.Empty, false);
            _EndEntityToken.Name = entityName;
            _EndEntityEncoding = encoding;
            _IsAttributeText = isAttributeText;
            _PrevXmlSpace = XmlSpace.None;
            _PrevXmlLang = String.Empty;
            _OriginalBaseUri = originalBaseURI;
        }

        internal override bool IsAttrText
        {
            get { return _IsAttributeText || IsReadingAttributeValue || this.PartialContentNodeType == XmlNodeType.Attribute;}
        }

        public override bool Read() {
            if (_IsScanner && base.Read()) {
                _PrevXmlLang = _XmlLang;
                _PrevXmlSpace = _XmlSpace;
                _PrevLineNum = this.LineNumber;
                _PrevLinePos = this.LinePosition;
                return true;
            } else {
                return ProduceExtraNodes();
            }
        }

        internal override bool ReadAttributeValue(EntityHandling ehMode) {
            if ( this.PartialContentNodeType == XmlNodeType.Attribute) {
                return Read();
            }

            if(!_IsScanner) {
                return ProduceExtraNodes();
            }

            if (base.ReadAttributeValue(ehMode)) {
                _PrevXmlLang = _XmlLang;
                _PrevXmlSpace = _XmlSpace;
                return true;
            }

            return false;
        }


    private bool ProduceExtraNodes() {
        if (_IsScanner) {
            if (this.NodeType == XmlNodeType.EndEntity) {
                _ReadState = ReadState.EndOfFile;
                ResetToCloseState();
                return false;
            }
            else {
                _ReadState = ReadState.Interactive;
                _CurrentToken = _EndEntityToken;
                _EndEntityToken.LineNum = _PrevLineNum;
                _EndEntityToken.LinePos = _PrevLinePos;
                _XmlLang = _PrevXmlLang;
                _XmlSpace = _PrevXmlSpace;
                _Encoding = _EndEntityEncoding;
                _BaseURI = _OriginalBaseUri;
                return true;
            }
        } else {
                if (_ReadState == ReadState.EndOfFile) {
                    return false;
                }
                switch(this.NodeType) {
                    case XmlNodeType.EndEntity:
                        _ReadState = ReadState.EndOfFile;
                        ResetToCloseState();
                        _ReadState = ReadState.EndOfFile;
                        return false;
                    case XmlNodeType.Text:
                        _ReadState = ReadState.Interactive;
                        _CurrentToken = _EndEntityToken;
                        _EndEntityToken.LineNum = _PrevLineNum;
                        _EndEntityToken.LinePos = _PrevLinePos;
                        _XmlLang = _PrevXmlLang;
                        _XmlSpace = _PrevXmlSpace;
                        _Encoding = _EndEntityEncoding;
                        _BaseURI = _OriginalBaseUri;
                        break;
                    default:
                        _AttributeTextToken.Value = String.Empty;
                        _ReadState = ReadState.Interactive;
                        _CurrentToken = _AttributeTextToken;
                        _XmlLang = _PrevXmlLang;
                        _XmlSpace = _PrevXmlSpace;
                        break;
                }
                return true;
        }
    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlentityreference.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlEntityReference.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

/*
 *  <code>EntityReference</code> objects may be inserted into the structure 
 * model when an entity reference is in the source document, or when the user 
 * wishes to insert an entity reference. Note that  character references and 
 * references to predefined entities are considered to be expanded by the 
 * HTML or XML processor so that characters are represented by their Unicode 
 * equivalent rather than by an entity reference. Moreover, the XML  
 * processor may completely expand references to entities while building the 
 * structure model, instead of providing <code>EntityReference</code> 
 * objects. If it does provide such objects, then for a given 
 * <code>EntityReference</code> node, it may be that there is no 
 * <code>Entity</code> node representing the referenced entity; but if such 
 * an <code>Entity</code> exists, then the child list of the 
 * <code>EntityReference</code> node is the same as that of the 
 * <code>Entity</code> node. As with the <code>Entity</code> node, all 
 * descendants of the <code>EntityReference</code> are readonly.
 * <p>The resolution of the children of the <code>EntityReference</code> (the  
 * replacement value of the referenced <code>Entity</code>) may be lazily  
 * evaluated; actions by the user (such as calling the  
 * <code>childNodes</code> method on the <code>EntityReference</code> node)  
 * are assumed to trigger the evaluation.
 */

namespace System.Xml {

    using System.Diagnostics;

    /// <include file='doc\XmlEntityReference.uex' path='docs/doc[@for="XmlEntityReference"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an entity reference node.
    ///    </para>
    /// </devdoc>
    public class XmlEntityReference : XmlLinkedNode {
        string name;
        XmlLinkedNode lastChild;

        /// <include file='doc\XmlEntityReference.uex' path='docs/doc[@for="XmlEntityReference.XmlEntityReference"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected internal XmlEntityReference( string name, XmlDocument doc ) : base( doc ) {
            if ( !doc.IsLoading ) {
                if( name != "" )
                    if( name[0] == '#' )
                        throw new ArgumentException( Res.GetString( Res.Xdom_InvalidCharacter_EntityReference ) );
            }
            this.name = doc.NameTable.Add(name);
            doc.fEntRefNodesPresent = true;
        }

        /// <include file='doc\XmlEntityReference.uex' path='docs/doc[@for="XmlEntityReference.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node.
        ///    </para>
        /// </devdoc>
        public override string Name {
            get { return name;}
        }

        /// <include file='doc\XmlEntityReference.uex' path='docs/doc[@for="XmlEntityReference.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override string LocalName {
            get { return name;}
        }

        /// <include file='doc\XmlEntityReference.uex' path='docs/doc[@for="XmlEntityReference.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the value of the node.
        ///    </para>
        /// </devdoc>
        public override String Value { 
            get {
                return null;
            }

            set {
                throw new InvalidOperationException(Res.GetString(Res.Xdom_EntRef_SetVal));
            }
        }

        /// <include file='doc\XmlEntityReference.uex' path='docs/doc[@for="XmlEntityReference.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType {
            get { return XmlNodeType.EntityReference;}
        }

        /// <include file='doc\XmlEntityReference.uex' path='docs/doc[@for="XmlEntityReference.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a duplicate of this node.
        ///    </para>
        /// </devdoc>
        public override XmlNode CloneNode(bool deep) {
            Debug.Assert( OwnerDocument != null );
            XmlEntityReference eref = OwnerDocument.CreateEntityReference( name );
            return eref;
        }

        // Microsoft extensions
        /// <include file='doc\XmlEntityReference.uex' path='docs/doc[@for="XmlEntityReference.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the node is read-only.
        ///    </para>
        /// </devdoc>
        public override bool IsReadOnly {
            get { 
                return true;        // Make entity references readonly
            }
        }

        internal override bool IsContainer {
            get { return true;}
        }

        internal override void SetParent( XmlNode node ) {
            base.SetParent(node);
            if ( LastNode == null && node != null && node != OwnerDocument.NullNode ) {
                //first time insert the entity reference into the tree, we should expand its children now
                XmlLoader loader = new XmlLoader();
                loader.ExpandEntityReference(this);
                
            }
        }

        internal override void SetParentForLoad( XmlNode node ) {
         this.SetParent(  node );
        }

        internal override XmlLinkedNode LastNode {
            get { 
                return lastChild;
            }
            set { lastChild = value;}
        }

        internal override bool IsValidChildType( XmlNodeType type ) {
            switch (type) {
                case XmlNodeType.Element:
                case XmlNodeType.Text:
                case XmlNodeType.EntityReference:
                case XmlNodeType.Comment:
                case XmlNodeType.Whitespace:
                case XmlNodeType.SignificantWhitespace:
                case XmlNodeType.ProcessingInstruction:
                case XmlNodeType.CDATA:
                    return true;

                default:
                    return false;
            }
        }

        /// <include file='doc\XmlEntityReference.uex' path='docs/doc[@for="XmlEntityReference.WriteTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteTo(XmlWriter w) {
            w.WriteEntityRef(name);
        }

        /// <include file='doc\XmlEntityReference.uex' path='docs/doc[@for="XmlEntityReference.WriteContentTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves all the children of the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteContentTo(XmlWriter w) {
            // -- eventually will the fix. commented out waiting for finalizing on the issue.
            foreach( XmlNode n in this ) {
                n.WriteTo( w );
            } //still use the old code to generate the output
            /*
            foreach( XmlNode n in this ) {
                if ( n.NodeType != XmlNodeType.EntityReference )
                n.WriteTo( w );
                else
                    n.WriteContentTo( w );
            }*/
        }

        /// <include file='doc\XmlEntityReference.uex' path='docs/doc[@for="XmlEntityReference.BaseURI"]/*' />
        public override String BaseURI {
            get {
                return OwnerDocument.BaseURI;
            }
        }

        private string ConstructBaseURI( string baseURI, string systemId ) {
            if ( baseURI == null )
                return systemId;
            int nCount = baseURI.LastIndexOf('/')+1;
            string buf = baseURI;
            if ( nCount > 0 && nCount < baseURI.Length )
                buf = baseURI.Substring(0, nCount);
            else if ( nCount == 0 )
                buf = buf + "\\";
            return (buf + systemId.Replace('\\', '/')); 
        }

        //childrenBaseURI returns where the entity reference node's children come from
        internal String ChildBaseURI {
            get {
                //get the associate entity and return its baseUri
                XmlEntity ent = OwnerDocument.GetEntityNode( name );
                if ( ent != null ) {
                    if ( ent.SystemId != null && ent.SystemId != string.Empty )
                        return ConstructBaseURI(ent.BaseURI, ent.SystemId); 
                    else
                        return ent.BaseURI;
                }
                return String.Empty;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlelement.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlElement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlElement.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
using System;
using System.Xml.XPath;
using System.Collections;
using System.Diagnostics;
using System.Globalization;

namespace System.Xml {
    /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an element.
    ///    </para>
    /// </devdoc>
    public class XmlElement : XmlLinkedNode {
        XmlName name;
        XmlAttributeCollection attributes;
        XmlLinkedNode lastChild;

        static readonly XmlElement emptyElem = new XmlElement();

        //This should be used only to create the emptyElem as above.
        private XmlElement(): base() {
            this.name = null;
            this.lastChild = null;            
        }

        internal XmlElement( XmlName name, bool empty, XmlDocument doc ): base( doc ) {
            Debug.Assert(name!=null);
            if ( !doc.IsLoading ) {
                XmlDocument.CheckName( name.Prefix );
                XmlDocument.CheckName( name.LocalName );
            }
            if (name.LocalName == "") 
                throw new ArgumentException(Res.GetString(Res.Xdom_Empty_LocalName));
            if ( name.Prefix.Length >= 3 && (! doc.IsLoading) && String.Compare( name.Prefix, 0, "xml", 0, 3, true, CultureInfo.InvariantCulture) == 0 )
                throw new ArgumentException(Res.GetString(Res.Xdom_Ele_Prefix));
            this.name = name;
            if (empty)
                lastChild = emptyElem;
            else
                lastChild = null;
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.XmlElement"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        internal XmlElement( string name, string namespaceURI, XmlDocument doc )
        : this( doc.GetXmlName( name, namespaceURI ), true, doc ) {
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.XmlElement1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected internal XmlElement( string prefix, string localName, string namespaceURI, XmlDocument doc ) 
        : this( doc.GetXmlName( prefix, localName, namespaceURI ), true, doc ) {
        }

        internal XmlName XmlName {
            get { return name;}
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>Creates a duplicate of this node.</para>
        /// </devdoc>
        public override XmlNode CloneNode(bool deep) {
            Debug.Assert( OwnerDocument != null );
            bool OrigLoadingStatus = OwnerDocument.IsLoading;
            OwnerDocument.IsLoading = true;
            XmlElement element = OwnerDocument.CreateElement( Prefix, LocalName, NamespaceURI );
            if ( element.IsEmpty != IsEmpty )
                element.IsEmpty = this.IsEmpty;
            OwnerDocument.IsLoading = OrigLoadingStatus;

            if (HasAttributes) {
                foreach( XmlAttribute attr in Attributes ) {
                    XmlAttribute newAttr = (XmlAttribute)(attr.CloneNode(true));
                    if (attr is XmlUnspecifiedAttribute && attr.Specified == false)
                        ( ( XmlUnspecifiedAttribute )newAttr).SetSpecified(false);
                    element.Attributes.Append( newAttr );
                }
            }
            if (deep)
                element.CopyChildren( this, deep );

            return element;
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node.
        ///    </para>
        /// </devdoc>
        public override string Name { 
            get { return name.Name;}
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the current node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override string LocalName { 
            get { return name.LocalName;}
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.NamespaceURI"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the namespace URI of this node.
        ///    </para>
        /// </devdoc>
        public override string NamespaceURI { 
            get { return name.NamespaceURI;} 
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.Prefix"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the namespace prefix of this node.</para>
        /// </devdoc>
        public override string Prefix { 
            get { return name.Prefix;}
            set { name = name.Identity.GetNameForPrefix( value );} 
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.NodeType"]/*' />
        /// <devdoc>
        ///    <para>Gets the type of the current node.</para>
        /// </devdoc>
        public override XmlNodeType NodeType {
            get { return XmlNodeType.Element;}
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.OwnerDocument"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Xml.XmlDocument'/> that contains this node.
        ///    </para>
        /// </devdoc>
        public override XmlDocument OwnerDocument { 
            get { 
                return name.Identity.IdentityTable.Document;
            }
        }

        internal override bool IsContainer {
            get { return true;}
        }

        internal override XmlNode AppendChildForLoad( XmlNode newChild, XmlDocument doc ) {
            XmlNodeChangedEventArgs args = doc.GetInsertEventArgsForLoad( newChild, this );

            if (args != null)
                doc.BeforeEvent( args );

            XmlLinkedNode newNode = (XmlLinkedNode) newChild;

            if (lastChild == null || lastChild == emptyElem) {
                newNode.next = newNode;
            }
            else {
                newNode.next = lastChild.next;
                lastChild.next = newNode;
            }

            lastChild = newNode;
            newNode.SetParentForLoad( this );

            if (args != null)
                doc.AfterEvent( args );

            return newNode;
        }
        
        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.IsEmpty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets whether the element does not have any children.
        ///    </para>
        /// </devdoc>
        public bool IsEmpty {
            get { 
                return lastChild == emptyElem;
            }

            set { 
                if (value && lastChild != emptyElem) {
                    RemoveAllChildren(); 
                    lastChild = emptyElem;
                }
                else if (!value && lastChild == emptyElem) {
                    lastChild = null;
                }
            }
        }

        internal override XmlLinkedNode LastNode {
            get { 
                if (lastChild == emptyElem)
                    return null;

                return lastChild; 
            }

            set { 
                lastChild = value;
            }
        }

        internal override bool IsValidChildType( XmlNodeType type ) {
            switch (type) {
                case XmlNodeType.Element:
                case XmlNodeType.Text:
                case XmlNodeType.EntityReference:
                case XmlNodeType.Comment:
                case XmlNodeType.Whitespace:
                case XmlNodeType.SignificantWhitespace:
                case XmlNodeType.ProcessingInstruction:
                case XmlNodeType.CDATA:
                    return true;

                default:
                    return false;
            }
        }


        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.Attributes"]/*' />
        /// <devdoc>
        /// <para>Gets a <see cref='System.Xml.XmlAttributeCollection'/> containing the list of attributes for this node.</para>
        /// </devdoc>
        public override XmlAttributeCollection Attributes { 
            get { 
                if (attributes == null) {
                    lock ( OwnerDocument.objLock ) {
                        if ( attributes == null ) {
                            attributes = new XmlAttributeCollection(this);
                        }
                    }
                }

                return attributes; 
            }
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.HasAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the current node
        ///       has any attributes.
        ///    </para>
        /// </devdoc>
        public virtual bool HasAttributes {
            get {
                if ( this.attributes == null )
                    return false;
                else
                    return this.attributes.Count > 0;
            }
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.GetAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the value for the attribute with the specified name.
        ///    </para>
        /// </devdoc>
        public virtual string GetAttribute(string name) {
            XmlAttribute attr = GetAttributeNode(name);
            if (attr != null)
                return attr.Value;
            return String.Empty;
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.SetAttribute"]/*' />
        /// <devdoc>
        ///    <para>Sets the value of the attribute
        ///       with the specified name.</para>
        /// </devdoc>

        public virtual void SetAttribute(string name, string value) {
            XmlAttribute attr = GetAttributeNode(name);
            if (attr == null) {
                attr = OwnerDocument.CreateAttribute(name);
                attr.Value = value;
                Attributes.AddNode( attr );
            }
            else {
                attr.Value = value;
            }
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.RemoveAttribute"]/*' />
        /// <devdoc>
        ///    <para>Removes an attribute by name.</para>
        /// </devdoc>
        public virtual void RemoveAttribute(string name) {
            if (HasAttributes)
                Attributes.RemoveNamedItem(name);
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.GetAttributeNode"]/*' />
        /// <devdoc>
        ///    <para>Returns the XmlAttribute with the specified name.</para>
        /// </devdoc>
        public virtual XmlAttribute GetAttributeNode(string name) {
            if (HasAttributes)
                return Attributes[name];
            return null;
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.SetAttributeNode"]/*' />
        /// <devdoc>
        ///    <para>Adds the specified XmlAttribute.</para>
        /// </devdoc>
        public virtual XmlAttribute SetAttributeNode(XmlAttribute newAttr) {
            if ( newAttr.OwnerElement != null )
                throw new InvalidOperationException( Res.GetString(Res.Xdom_Attr_InUse) );
            return(XmlAttribute) Attributes.SetNamedItem(newAttr);
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.RemoveAttributeNode"]/*' />
        /// <devdoc>
        ///    <para>Removes the specified XmlAttribute.</para>
        /// </devdoc>
        public virtual XmlAttribute RemoveAttributeNode(XmlAttribute oldAttr) {
            if (HasAttributes)
                return(XmlAttribute) Attributes.Remove(oldAttr);
            return null;
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.GetElementsByTagName"]/*' />
        /// <devdoc>
        /// <para>Returns an <see cref='XmlNodeList'/> containing
        ///    a list of all descendant elements that match the specified name.</para>
        /// </devdoc>
        public virtual XmlNodeList GetElementsByTagName(string name) {
            return new XmlElementList( this, name );
        }

        // DOM Level 2
        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.GetAttribute1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the value for the attribute with the specified LocalName and NamespaceURI.
        ///    </para>
        /// </devdoc>
        public virtual string GetAttribute(string localName, string namespaceURI) {
            XmlAttribute attr = GetAttributeNode( localName, namespaceURI );
            if (attr != null)
                return attr.Value;
            return String.Empty;
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.SetAttribute1"]/*' />
        /// <devdoc>
        ///    <para>Sets the value of the attribute with the specified name
        ///       and namespace.</para>
        /// </devdoc>
        public virtual string SetAttribute(string localName, string namespaceURI, string value) {
            XmlAttribute attr = GetAttributeNode( localName, namespaceURI );
            if (attr == null) {
                attr = OwnerDocument.CreateAttribute( string.Empty, localName, namespaceURI );
                attr.Value = value;
                Attributes.AddNode( attr );

            }
            else {
                attr.Value = value;
            }

            return value;
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.RemoveAttribute1"]/*' />
        /// <devdoc>
        ///    <para>Removes an attribute specified by LocalName and NamespaceURI.</para>
        /// </devdoc>
        public virtual void RemoveAttribute(string localName, string namespaceURI) {
            Debug.Assert(namespaceURI != null);
            if (HasAttributes)
                Attributes.RemoveNamedItem( localName, namespaceURI );
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.GetAttributeNode1"]/*' />
        /// <devdoc>
        ///    <para>Returns the XmlAttribute with the specified LocalName and NamespaceURI.</para>
        /// </devdoc>
        public virtual XmlAttribute GetAttributeNode(string localName, string namespaceURI) {
            Debug.Assert(namespaceURI != null);
            if (HasAttributes)
                return Attributes[ localName, namespaceURI ];
            return null;
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.SetAttributeNode1"]/*' />
        /// <devdoc>
        ///    <para>Adds the specified XmlAttribute.</para>
        /// </devdoc>
        public virtual XmlAttribute SetAttributeNode(string localName, string namespaceURI) {
            XmlAttribute attr = GetAttributeNode( localName, namespaceURI );
            if (attr == null) {
                attr = OwnerDocument.CreateAttribute( string.Empty, localName, namespaceURI );
                Attributes.AddNode( attr );
            }
            return attr;
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.RemoveAttributeNode1"]/*' />
        /// <devdoc>
        ///    <para>Removes the XmlAttribute specified by LocalName and NamespaceURI.</para>
        /// </devdoc>
        public virtual XmlAttribute RemoveAttributeNode(string localName, string namespaceURI) {
            Debug.Assert(namespaceURI != null);
            if (HasAttributes)
                return(XmlAttribute) Attributes.RemoveNamedItem( localName, namespaceURI );
            return null;
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.GetElementsByTagName1"]/*' />
        /// <devdoc>
        /// <para>Returns an <see cref='XmlNodeList'/> containing 
        ///    a list of all descendant elements that match the specified name.</para>
        /// </devdoc>
        public virtual XmlNodeList GetElementsByTagName(string localName, string namespaceURI) {
            Debug.Assert(namespaceURI != null);
            return new XmlElementList( this, localName, namespaceURI );
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.HasAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines whether the current node has the specified
        ///       attribute.
        ///    </para>
        /// </devdoc>
        public virtual bool HasAttribute(string name) {
            return GetAttributeNode(name) != null;
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.HasAttribute1"]/*' />
        /// <devdoc>
        ///    <para>Determines whether the current node has the specified
        ///       attribute from the specified namespace.</para>
        /// </devdoc>
        public virtual bool HasAttribute(string localName, string namespaceURI) {
            return GetAttributeNode(localName, namespaceURI) != null;
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.WriteTo"]/*' />
        /// <devdoc>
        ///    <para>Saves the current node to the specified XmlWriter.</para>
        /// </devdoc>
        public override void WriteTo(XmlWriter w) {

            w.WriteStartElement( Prefix, LocalName, NamespaceURI );

            if ( HasAttributes ) {
                foreach( XmlAttribute attr in Attributes ) {
                    attr.WriteTo( w );
                }
            }

            if (!IsEmpty) {
                WriteContentTo( w );
            }
            if (IsEmpty)
                w.WriteEndElement();
            else
                w.WriteFullEndElement();
        }

        // override this
        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.WriteContentTo"]/*' />
        /// <devdoc>
        ///    <para>Saves all the children of the node to the specified XmlWriter.</para>
        /// </devdoc>
        public override void WriteContentTo(XmlWriter w) {
            foreach( XmlNode n in this ) {
                n.WriteTo( w );
            }
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.RemoveAttributeAt"]/*' />
        /// <devdoc>
        ///    <para>Removes the attribute node with the specified index from the attribute collection.</para>
        /// </devdoc>
        public virtual XmlNode RemoveAttributeAt(int i) {
            if (HasAttributes)
                return attributes.RemoveAt( i );
            return null;
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.RemoveAllAttributes"]/*' />
        /// <devdoc>
        ///    <para>Removes all attributes from the element.</para>
        /// </devdoc>
        public virtual void RemoveAllAttributes() {
            if (HasAttributes) {
                attributes.RemoveAll();
            }
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.RemoveAll"]/*' />
        /// <devdoc>
        ///    <para>Removes all the children and/or attributes
        ///       of the current node.</para>
        /// </devdoc>
        public override void RemoveAll() {
            //remove all the children
            base.RemoveAll(); 
            //remove all the attributes
            RemoveAllAttributes();
        }
        
        internal void RemoveAllChildren() {
            base.RemoveAll();
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.InnerXml"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the markup representing just
        ///       the children of this node.</para>
        /// </devdoc>
        public override string InnerXml {
            get {
                return base.InnerXml;
            }
            set {
                RemoveAllChildren();
                XmlLoader loader = new XmlLoader();
                loader.LoadInnerXmlElement( this, value );
            }
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.InnerText"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the concatenated values of the
        ///       node and all its children.</para>
        /// </devdoc>
        public override string InnerText { 
            get {
                return base.InnerText;
            }
            set {
                if ( lastChild != null && //there is one child
                     lastChild.NodeType == XmlNodeType.Text && //which is text node
                     lastChild.next == lastChild ) // and it is the only child 
                {
                    //this branch is for perf reason, event fired when TextNode.Value is changed.
                    lastChild.Value = value;
                } 
                else {
                    RemoveAllChildren();
                    AppendChild( OwnerDocument.CreateTextNode( value ) );
                }
            }
        }

        /// <include file='doc\XmlElement.uex' path='docs/doc[@for="XmlElement.NextSibling"]/*' />
        public override XmlNode NextSibling { 
            get { 
                if (parentNode.LastNode != this)
                    return next;
                return null; 
            } 
        }

        internal override XPathNodeType XPNodeType { get { return XPathNodeType.Element; } }

        internal override string XPLocalName { get { return LocalName; } }

        internal override string GetXPAttribute( string localName, string ns ) {
            if ( ns == XmlDocument.strReservedXmlns )
                return null;
            XmlAttribute attr = GetAttributeNode( localName, ns );
            if ( attr != null )
                return attr.Value;
            return string.Empty;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml {
    using System;
    using System.IO;
    using System.Resources;
    using System.Runtime.Serialization;
    using System.Text;
    using System.Diagnostics;
    using System.Security.Permissions;

    /// <include file='doc\XmlException.uex' path='docs/doc[@for="XmlException"]/*' />
    /// <devdoc>
    ///    <para>Returns detailed information about the last parse error, including the error
    ///       number, line number, character position, and a text description.</para>
    /// </devdoc>
    [Serializable]
    public class XmlException : SystemException {
        string res;
        string[] args;
        int lineNumber;
        int linePosition;
        string message;

        /// <include file='doc\XmlException.uex' path='docs/doc[@for="XmlException.XmlException5"]/*' />
        protected XmlException(SerializationInfo info, StreamingContext context) : base(info, context) {
            res                 = (string)  info.GetValue("res"  , typeof(string));
            args                = (string[])info.GetValue("args", typeof(string[]));
            lineNumber          = (int)     info.GetValue("lineNumber", typeof(int));
            linePosition        = (int)     info.GetValue("linePosition", typeof(int));
        }

        /// <include file='doc\XmlException.uex' path='docs/doc[@for="XmlException.GetObjectData"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand,SerializationFormatter=true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            base.GetObjectData(info, context);
            info.AddValue("res",                res);
            info.AddValue("args",               args);
            info.AddValue("lineNumber",         lineNumber);
            info.AddValue("linePosition",       linePosition);
        }

        //provided to meet the ECMA standards
        /// <include file='doc\XmlException.uex' path='docs/doc[@for="XmlException.XmlException1"]/*' />
        public XmlException() : this(null) {
        }

        //provided to meet the ECMA standards
        /// <include file='doc\XmlException.uex' path='docs/doc[@for="XmlException.XmlException2"]/*' />
        public XmlException(String message) : this (message, ((Exception)null), 0, 0) {
	#if DEBUG
            Debug.Assert(!message.StartsWith("Xml_"), "Do not pass a resource here!");
        #endif
        }
        
        //provided to meet ECMA standards
        /// <include file='doc\XmlException.uex' path='docs/doc[@for="XmlException.XmlException0"]/*' />
        public XmlException(String message, Exception innerException) : this (message, innerException, 0, 0) {
        } 

	//provided to meet ECMA standards
        /// <include file='doc\XmlException.uex' path='docs/doc[@for="XmlException.XmlException3"]/*' />
        public XmlException(String message, Exception innerException, int lineNumber, int linePosition) : base(message, innerException) {
            HResult = HResults.Xml;
            if (message == null) {
                this.res = Res.Xml_DefaultException;
            }
            else {
                this.res = Res.Xml_UserException;
            }
            this.args = new string[] { message };
            this.lineNumber = lineNumber;
            this.linePosition = linePosition;
	}

        internal XmlException(string res, string[] args) :
            this(res, args, 0, 0) {}

        internal XmlException(string res, string arg) :
            this(res,  new string[] { arg }, 0, 0) {}


        internal XmlException(string res, String arg,  IXmlLineInfo lineInfo) :
            this(res, new string[] { arg },  lineInfo) {}

        internal XmlException(string res, string[] args,  IXmlLineInfo lineInfo) {
            HResult = HResults.Xml;
            this.res = res;
            this.args = args;
            this.lineNumber = null == lineInfo ? 0 : lineInfo.LineNumber;
            this.linePosition = null == lineInfo ? 0 : lineInfo.LinePosition;
        }

        internal XmlException(string res,  int lineNumber, int linePosition) :
            this(res, (string[])null, lineNumber, linePosition) {}

        internal XmlException(string res, string arg, int lineNumber, int linePosition) :
            this(res,  new string[] { arg }, lineNumber, linePosition) {}

        internal XmlException(string res, string[] args, int lineNumber, int linePosition) {
            HResult = HResults.Xml;
            this.res = res;
            this.args = args;
            this.lineNumber = lineNumber;
            this.linePosition = linePosition;
        }


        internal static string[] BuildCharExceptionStr(char ch) {
            string[] aStringList= new string[2];
            aStringList[0] = ch.ToString();
            aStringList[1] = "0x"+ ((int)ch).ToString("X2");
            return aStringList;
        }


        /*
         * Returns the XML exception description.
         */
        /// <include file='doc\XmlException.uex' path='docs/doc[@for="XmlException.Message"]/*' />
        public override string Message {
            get {
                string message = this.message;
                if (message == null) {
                    try {
                        message = Res.GetString(this.res, this.args);
                    }
                    catch {
                        message = "UNKNOWN("+this.res+")";
                    }

                    if (this.lineNumber != 0) {
                        string[] msg = new string[2];
                        msg[0] = this.lineNumber.ToString();
                        msg[1] = this.linePosition.ToString();
                        message += " " + Res.GetString(Res.Xml_ErrorPosition, msg);
                    }
                    this.message = message;
                }
                return message;
            }
        }

        internal string ErrorCode {
            get { return this.res; }
        }

        /// <include file='doc\XmlException.uex' path='docs/doc[@for="XmlException.LineNumber"]/*' />
        public int LineNumber {
            get { return this.lineNumber; }
        }

        /// <include file='doc\XmlException.uex' path='docs/doc[@for="XmlException.LinePosition"]/*' />
        public int LinePosition {
            get { return this.linePosition; }
        }

        internal string[] msg {
            get { return args; }
        }
    };
} // namespace System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlentity.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlEntity.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlEntity.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml {
    using System.Diagnostics;

    /// <include file='doc\XmlEntity.uex' path='docs/doc[@for="XmlEntity"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a parsed or unparsed entity in the XML document.
    ///    </para>
    /// </devdoc>
    public class XmlEntity : XmlNode {
        string _publicId;
        string _systemId;
        String _notationName;
        String _name;
        String _unparsedReplacementStr;
        String _baseURI;
        XmlLinkedNode lastChild;
        private bool childrenFoliating;

        internal XmlEntity( String name, String strdata, string publicId, string systemId, String notationName, XmlDocument doc ) : base( doc ) {
            this._name = doc.NameTable.Add(name);
            this._publicId = publicId;
            this._systemId = systemId;
            this._notationName = notationName;
            this._unparsedReplacementStr = strdata;
            this.childrenFoliating = false;
        }

        /// <include file='doc\XmlEntity.uex' path='docs/doc[@for="XmlEntity.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Throws an excption since an entity can not be cloned.
        ///    </para>
        /// </devdoc>
        public override XmlNode CloneNode(bool deep) {

              throw new InvalidOperationException(Res.GetString(Res.Xdom_Node_Cloning));
        }

        // Microsoft extensions
        /// <include file='doc\XmlEntity.uex' path='docs/doc[@for="XmlEntity.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the node is read-only.
        ///    </para>
        /// </devdoc>
        public override bool IsReadOnly {
            get {
                return true;        // Make entities readonly
            }
        }


        /// <include file='doc\XmlEntity.uex' path='docs/doc[@for="XmlEntity.Name"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the node.</para>
        /// </devdoc>
        public override string Name {
            get { return _name;}
        }

        /// <include file='doc\XmlEntity.uex' path='docs/doc[@for="XmlEntity.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override string LocalName {
            get { return _name;}
        }

        /// <include file='doc\XmlEntity.uex' path='docs/doc[@for="XmlEntity.InnerText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the concatenated values of the entity node and
        ///       all its children.
        ///       The property is read-only and when tried to be set, exception will be thrown.
        ///    </para>
        /// </devdoc>
        public override string InnerText {
            get { return base.InnerText; }
            set {
                throw new InvalidOperationException(Res.GetString(Res.Xdom_Ent_Innertext));
            }
        }

        internal override bool IsContainer {
            get { return true;}
        }

        internal override XmlLinkedNode LastNode {
            get {
                if (lastChild == null && !childrenFoliating)
                { //expand the unparsedreplacementstring
                    childrenFoliating = true;
                    //wrap the replacement string with an element
                    XmlLoader loader = new XmlLoader();
                    loader.ExpandEntity(this);
                }
                return lastChild;
            }
            set { lastChild = value;}
        }

        internal override bool IsValidChildType( XmlNodeType type ) {
            return(type == XmlNodeType.Text ||
                   type == XmlNodeType.Element ||
                   type == XmlNodeType.ProcessingInstruction ||
                   type == XmlNodeType.Comment ||
                   type == XmlNodeType.CDATA ||
                   type == XmlNodeType.Whitespace ||
                   type == XmlNodeType.SignificantWhitespace ||
                   type == XmlNodeType.EntityReference);
        }

        /// <include file='doc\XmlEntity.uex' path='docs/doc[@for="XmlEntity.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType {
            get { return XmlNodeType.Entity;}
        }

        /// <include file='doc\XmlEntity.uex' path='docs/doc[@for="XmlEntity.PublicId"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       the value of the public identifier on the entity declaration.</para>
        /// </devdoc>
        public String PublicId {
            get { return _publicId;}
        }

        /// <include file='doc\XmlEntity.uex' path='docs/doc[@for="XmlEntity.SystemId"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of
        ///       the system identifier on the entity declaration.</para>
        /// </devdoc>
        public String SystemId {
            get { return _systemId;}
        }

        /// <include file='doc\XmlEntity.uex' path='docs/doc[@for="XmlEntity.NotationName"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       the name of the optional NDATA attribute on the
        ///       entity declaration.</para>
        /// </devdoc>
        public String NotationName {
            get { return _notationName;}
        }

        //Without override these two functions, we can't guarantee that WriteTo()/WriteContent() functions will never be called
        /// <include file='doc\XmlEntity.uex' path='docs/doc[@for="XmlEntity.OuterXml"]/*' />
        public override String OuterXml {
            get { return String.Empty; }
        }

        /// <include file='doc\XmlEntity.uex' path='docs/doc[@for="XmlEntity.InnerXml"]/*' />
        public override String InnerXml {
            get { return String.Empty; }
            set { throw new InvalidOperationException( Res.GetString(Res.Xdom_Set_InnerXml ) ); }
        }


        /// <include file='doc\XmlEntity.uex' path='docs/doc[@for="XmlEntity.WriteTo"]/*' />
        /// <devdoc>
        ///    Saves the node to the specified XmlWriter.
        /// </devdoc>
        public override void WriteTo(XmlWriter w) {
            // You should never call this function since entities are readonly to the user)
            Debug.Assert(false);
        }
        /// <include file='doc\XmlEntity.uex' path='docs/doc[@for="XmlEntity.WriteContentTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves all the children of the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteContentTo(XmlWriter w) {
            // You should never call this function since entities are readonly to the user)
            Debug.Assert(false);
        }

        /// <include file='doc\XmlEntity.uex' path='docs/doc[@for="XmlEntity.BaseURI"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String BaseURI {
            get { return _baseURI; }
        }

        internal void SetBaseURI( String inBaseURI ) {
            _baseURI = inBaseURI;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmleolnormalizer.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlEolNormalizer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlEolNormalizer.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    using System;
    using System.Text;
    using System.Diagnostics;
 
    internal class XmlEolNormalizer : XmlNormalizer {
        
        public XmlEolNormalizer( StringBuilder sb ) : base ( sb ) {
        }

        public override void AppendTextWithEolNormalization( char[] value, int startIndex, int count ) {
            Debug.Assert( count > 0 );
            int pos = startIndex;
            int endPos = startIndex + count;

            while ( pos < endPos ) {
                if ( value[pos] != (char)0xD ) {
                    pos++;
                    continue;
                }

                if ( pos - startIndex > 0 ) 
                    _sb.Append( value, startIndex, pos - startIndex );

                _sb.Append( (char)0xA );
                pos++;

                if ( pos < endPos && value[pos] == (char)0xA ) 
                     pos++;

                startIndex = pos;
            }
            if ( pos - startIndex > 0 ) 
                _sb.Append( value, startIndex, pos - startIndex );
        }

        public override void AppendText( string value ) { 
            _sb.Append( value );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlidentity.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlIdentity.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlIdentity.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml {

    internal class XmlIdentity {
        internal XmlIdentityTable table;
        string localName;
        string namespaceURI;
        XmlName firstName;

        internal XmlIdentity( XmlIdentityTable table, string localName, string namespaceURI ) {
            this.table = table;
            this.localName = table.NameTable.Add( localName );
            this.namespaceURI = table.NameTable.Add( namespaceURI );
        }

        public String LocalName {
            get { return localName;}
        }

        public String NamespaceURI {
            get { return namespaceURI;}
        }

        public XmlIdentityTable IdentityTable {
            get { return table;}
        }

        public XmlName GetNameForPrefix( string prefix ) {
            prefix = table.NameTable.Add( prefix );

            XmlName n = firstName;
            for (; n != null; n = n.next) {
                if ((object)n.Prefix == (object)prefix)
                    return n;
            }

            n = new XmlName( this, prefix );
            n.next = firstName;
            firstName = n;

            return n;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmleventchangedaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlEventChangedAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlEventChangedAction.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml
{
    /// <include file='doc\XmlEventChangedAction.uex' path='docs/doc[@for="XmlNodeChangedAction"]/*' />    
    /// <devdoc>
    ///    <para>TODO: Specifies the type of node change </para>
    /// </devdoc>
    public enum XmlNodeChangedAction
    {
        /// <include file='doc\XmlEventChangedAction.uex' path='docs/doc[@for="XmlNodeChangedAction.Insert"]/*' />
        /// <devdoc>
        ///    <para>TODO: A node is beeing inserted in the tree.</para>
        /// </devdoc>
        Insert = 0,
        /// <include file='doc\XmlEventChangedAction.uex' path='docs/doc[@for="XmlNodeChangedAction.Remove"]/*' />
        /// <devdoc>
        ///    <para>TODO: A node is beeing removed from the tree.</para>
        /// </devdoc>
        Remove = 1,
        /// <include file='doc\XmlEventChangedAction.uex' path='docs/doc[@for="XmlNodeChangedAction.Change"]/*' />
        /// <devdoc>
        ///    <para>TODO: A node value is beeing changed.</para>
        /// </devdoc>
        Change = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlidentitytable.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlIdentityTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlIdentityTable.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    using System;
    using System.Collections;

    internal class XmlIdentityTable {
        XmlDocument document;
        Hashtable namespaces;

        public XmlIdentityTable( XmlDocument document ) {
            this.document = document;
            namespaces = new Hashtable();
        }

        public XmlDocument Document {
            get { return document; }
        }

        public XmlNameTable NameTable {
            get { return document.NameTable; }
        }

        public XmlIdentity GetIdentity( string localName, string namespaceURI ) {
            Hashtable localNames = (Hashtable) namespaces[namespaceURI];

            if (localNames == null) {
                XmlIdentity id = new XmlIdentity( this, localName, namespaceURI );

                localNames = new Hashtable();
                localNames[localName] = id;
                namespaces[namespaceURI] = localNames;

                return id;
            }
            else {
                XmlIdentity id = (XmlIdentity) localNames[localName];

                if (id == null) {
                    id = new XmlIdentity( this, localName, namespaceURI );
                    localNames[localName] = id;
                }

                return id;
            }
        }

        public XmlName GetName( string prefix, string localName, string namespaceURI ) {
            if ( prefix == null )
                prefix = String.Empty;
            if ( namespaceURI == null )
                namespaceURI = String.Empty;
            return GetIdentity( localName, namespaceURI ).GetNameForPrefix( prefix );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmllinkednode.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlLinkedNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlLinkedNode.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml {

    /// <include file='doc\XmlLinkedNode.uex' path='docs/doc[@for="XmlLinkedNode"]/*' />
    /// <devdoc>
    ///    <para>Gets the node immediately preceeding or following this node.</para>
    /// </devdoc>
    public abstract class XmlLinkedNode: XmlNode {
        internal XmlLinkedNode next;

        internal XmlLinkedNode(): base() {
            next = null;
        }
        internal XmlLinkedNode( XmlDocument doc ): base( doc ) {
            next = null;
        }

        /// <include file='doc\XmlLinkedNode.uex' path='docs/doc[@for="XmlLinkedNode.PreviousSibling"]/*' />
        /// <devdoc>
        ///    Gets the node immediately preceding this
        ///    node.
        /// </devdoc>
        public override XmlNode PreviousSibling {
            get {
                XmlNode parent = ParentNode;
                if (parent != null) {
                    XmlNode node = parent.FirstChild;
                    while (node != null && node.NextSibling != this) {
                        node = node.NextSibling;
                    }
                    return node;
                }
                return null;
            }
        }

        /// <include file='doc\XmlLinkedNode.uex' path='docs/doc[@for="XmlLinkedNode.NextSibling"]/*' />
        /// <devdoc>
        ///    Gets the node immediately following this
        ///    node.
        /// </devdoc>
        public override XmlNode NextSibling {
            get {
                XmlNode parent = ParentNode;
                if (parent != null) {
                    if (next != parent.FirstChild)
                        return next;
                }
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlimplementation.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlImplementation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlImplementation.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
using System.Globalization;

namespace System.Xml {

    /// <include file='doc\XmlImplementation.uex' path='docs/doc[@for="XmlImplementation"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides methods for performing operations that are independent of any
    ///       particular instance of the document object model.
    ///    </para>
    /// </devdoc>
    public class XmlImplementation {

        private XmlNameTable nameTable;


        /// <include file='doc\XmlImplementation.uex' path='docs/doc[@for="XmlImplementation.XmlImplementation"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the XmlImplementation class.
        ///    </para>
        /// </devdoc>
        public XmlImplementation() : this( new NameTable() ) {
        }

        internal XmlImplementation( XmlNameTable nt ) {
            nameTable = nt;
        }


        /// <include file='doc\XmlImplementation.uex' path='docs/doc[@for="XmlImplementation.HasFeature"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Test if the DOM implementation implements a specific feature.
        ///    </para>
        /// </devdoc>
        public bool HasFeature(string strFeature, string strVersion) {
            if (String.Compare("XML", strFeature, true, CultureInfo.InvariantCulture) == 0) {
                if (strVersion == null || strVersion == "1.0" || strVersion == "2.0")
                    return true;
            }
            return false;
        }

        /// <include file='doc\XmlImplementation.uex' path='docs/doc[@for="XmlImplementation.CreateDocument"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new XmlDocument.  All documents created from the same XmlImplementation object
        ///       share the same name table.
        ///    </para>
        /// </devdoc>
        public virtual XmlDocument CreateDocument() {
            return new XmlDocument( this );
        }

        internal XmlNameTable NameTable {
            get { return nameTable; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlname.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlName.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlName.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml {
    using System.Text;
    using System.Diagnostics;

    internal class XmlName {
        internal XmlName next;
        XmlIdentity identity;
        string prefix;
        string name;

        internal XmlName( XmlIdentity identity, string prefix ) {
            this.identity = identity;
            this.prefix = prefix;
        }

        public String Prefix {
            get { return prefix;}
        }

        public String Name {
            get {
                if ( name == null ) {
                    if ( ( prefix != null ) && ( ( prefix.Length ) != 0 )) {
                        if ( ( ( identity.LocalName.Length ) != 0 ) ) {
                            StringBuilder temp = new StringBuilder( prefix );
                            temp.Append( ":" );
                            temp.Append( identity.LocalName );
                            lock( identity.IdentityTable.NameTable ) {
                                if( name == null )
                                    name = identity.IdentityTable.NameTable.Add( temp.ToString() );
                            }
                        }
                        else {
                            name = prefix;
                        }
                    }
                    else {
                        name = identity.LocalName;
                    }
                    Debug.Assert( Ref.Equal(name, identity.IdentityTable.NameTable.Get( name ) ) );
                }
                return name;
            }
        }

        public String LocalName {
            get { return identity.LocalName;}
        }

        public String NamespaceURI {
            get { return identity.NamespaceURI;}
        }

        public XmlIdentity Identity {
            get { return identity;}
        }

        public override int GetHashCode() {
            return LocalName.GetHashCode();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnamespacemanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNamespaceManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml {
    using System;
    using System.IO;
    using System.Collections;
    using System.Diagnostics;

    /// <include file='doc\XmlNamespaceManager.uex' path='docs/doc[@for="XmlNamespaceManager"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlNamespaceManager : IEnumerable {

        private sealed class NsDecl {
            internal string Prefix;
            internal string Uri;
        }

        private sealed class Scope {
            internal NsDecl Default;
            internal int Count;

        }
        
        HWStack decls;
        HWStack scopes;
        NsDecl defaultNs;
        int count;
        XmlNameTable nameTable;
        string namespaceXml;
        string namespaceXmlNs;
        string xml;
        string xmlNs;

        internal XmlNamespaceManager(){}

        /// <include file='doc\XmlNamespaceManager.uex' path='docs/doc[@for="XmlNamespaceManager.XmlNamespaceManager"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlNamespaceManager(XmlNameTable nameTable) {
            this.nameTable = nameTable;
            namespaceXml = nameTable.Add(XmlReservedNs.NsXml);
            namespaceXmlNs = nameTable.Add(XmlReservedNs.NsXmlNs);       
            xml = nameTable.Add("xml");
            xmlNs = nameTable.Add("xmlns");       

            decls = new HWStack(60);
            scopes = new HWStack(60);
            defaultNs = null;
            count = 0;
        }

        /// <include file='doc\XmlNamespaceManager.uex' path='docs/doc[@for="XmlNamespaceManager.NameTable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlNameTable NameTable { get { return nameTable; }}

        /// <include file='doc\XmlNamespaceManager.uex' path='docs/doc[@for="XmlNamespaceManager.DefaultNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual string DefaultNamespace {
            get { return (defaultNs == null) ? string.Empty : defaultNs.Uri;}
        }

        /// <include file='doc\XmlNamespaceManager.uex' path='docs/doc[@for="XmlNamespaceManager.PushScope"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void PushScope() {
            Scope current = (Scope)scopes.Push();
            if (current == null) {
                current = new Scope();
                scopes.AddToTop(current);
            }
            current.Default = defaultNs;
            current.Count = count;
            count = 0;
        }

        /// <include file='doc\XmlNamespaceManager.uex' path='docs/doc[@for="XmlNamespaceManager.PopScope"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool PopScope() {
            Scope current = (Scope)scopes.Pop();
            if (current == null) {
                return false;
            } 
            else {
                for(int declIndex = 0; declIndex < count; declIndex ++) {
                    decls.Pop();
                }
                defaultNs = current.Default;
                count = current.Count;
                return true;
            }
        }

        /// <include file='doc\XmlNamespaceManager.uex' path='docs/doc[@for="XmlNamespaceManager.AddNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void AddNamespace(string prefix, string uri) {
            if (uri == null) {
                throw new ArgumentNullException("uri");
            }
            if (prefix == null) {
                throw new ArgumentNullException("prefix");
            }
            prefix = nameTable.Add(prefix);
            uri = nameTable.Add(uri);

            if (Ref.Equal(xml, prefix) || Ref.Equal(xmlNs, prefix)) {
                throw new ArgumentException(Res.GetString(Res.Xml_InvalidPrefix));
            }

            for(int declIndex = decls.Length - 1; declIndex >= decls.Length - count; declIndex --) {
                NsDecl decl = (NsDecl)decls[declIndex];
                if (Ref.Equal(decl.Prefix, prefix)) {
                    decl.Uri = uri;
                    return; // redefine
                }
            } /* else */ {
                NsDecl decl = (NsDecl) decls.Push();
                if (decl == null) {
                    decl = new NsDecl();
                    decls.AddToTop(decl);
                }
                decl.Prefix = prefix;
                decl.Uri = uri;
                count ++;
                if (prefix == string.Empty) {
                    defaultNs = decl;
                }
            }
        }

        /// <include file='doc\XmlNamespaceManager.uex' path='docs/doc[@for="XmlNamespaceManager.RemoveNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void RemoveNamespace(string prefix, string uri) {
            if (uri == null) {
                throw new ArgumentNullException("uri");
            }
            if (prefix == null) {
                throw new ArgumentNullException("prefix");
            }
            prefix = nameTable.Get(prefix);
            uri = nameTable.Get(uri);
            if (prefix != null && uri != null) {
                for(int declIndex = decls.Length - 1; declIndex >= decls.Length - count; declIndex --) {
                    NsDecl decl = (NsDecl)decls[declIndex];
                    if (Ref.Equal(decl.Prefix, prefix) && Ref.Equal(decl.Uri, uri)) {
                        decl.Uri = null;
                    }
                }
            }
        }

        /// <include file='doc\XmlNamespaceManager.uex' path='docs/doc[@for="XmlNamespaceManager.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual IEnumerator GetEnumerator() {
            Hashtable prefixes = new Hashtable(count);
            for(int declIndex = decls.Length - 1; declIndex >= 0; declIndex --) {
                NsDecl decl = (NsDecl)decls[declIndex];
                if (decl.Prefix != string.Empty && decl.Uri != null) {
                    prefixes[decl.Prefix] = decl.Uri;
                }
            }
            prefixes[string.Empty] = DefaultNamespace;
            prefixes[xml] = namespaceXml;
            prefixes[xmlNs] = namespaceXmlNs;
            return prefixes.Keys.GetEnumerator();
        }

        /// <include file='doc\XmlNamespaceManager.uex' path='docs/doc[@for="XmlNamespaceManager.LookupNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual string LookupNamespace(string prefix) {
            return LookupNamespace(prefix, decls.Length - 1);
        }

        /// <include file='doc\XmlNamespaceManager.uex' path='docs/doc[@for="XmlNamespaceManager.LookupPrefix"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual string LookupPrefix(string uri) {
            if (uri == null) {
                return null;
            }
            if (DefaultNamespace == uri) {
                return string.Empty;
            }
            if (Ref.Equal(namespaceXml, uri)) {
                return xml;
            }
            if (Ref.Equal(namespaceXmlNs, uri)) {
                return xmlNs;
            }
            for(int declIndex = decls.Length - 1; declIndex >= 0; declIndex --) {
                NsDecl decl = (NsDecl)decls[declIndex];
                if (Ref.Equal(decl.Uri, uri) && decl.Prefix != string.Empty) {
                    return decl.Prefix;
                }
            }
            return null;
        }

        /// <include file='doc\XmlNamespaceManager.uex' path='docs/doc[@for="XmlNamespaceManager.HasNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool HasNamespace(string prefix) {
            if (prefix == null) {
                return false;
            }
            for(int declIndex = decls.Length - 1; declIndex >= decls.Length - count; declIndex --) {
                NsDecl decl = (NsDecl)decls[declIndex];
                if (Ref.Equal(decl.Prefix, prefix) && decl.Uri != null) {
                    return true;
                }
            }
            return false;
        }
/*
        internal void ReplaceNamespace(string uriOld, string uri) {
            for(int declIndex = decls.Length - 1; declIndex >= decls.Length - count; declIndex --) {
                NsDecl decl = (NsDecl)decls[declIndex];
                if (decl.Uri == (object)uriOld) {
                    decl.Uri = uri; //nameTable.Add(uri);
                }
            }
        }
*/
        internal string LookupNamespaceBefore(string prefix) {
            return LookupNamespace(prefix, decls.Length - count - 1);
        }

        private string LookupNamespace(string prefix, int declIndex1) {
            if (prefix == null) {
                return null;
            }
            if (prefix == string.Empty) {
                return DefaultNamespace;
            }
            if (Ref.Equal(xml, prefix)) {
                return namespaceXml;
            }
            if (Ref.Equal(xmlNs, prefix)) {
                return namespaceXmlNs;
            }
            for(int declIndex = declIndex1; declIndex >= 0; declIndex --) {
                NsDecl decl = (NsDecl)decls[declIndex];
                if (Ref.Equal(decl.Prefix, prefix) && decl.Uri != null) {
                    return decl.Uri;
                }
            }
            return null;
        }
   }; //XmlNamespaceManager

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnamednodemap.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNamedNodeMap.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlNamedNodeMap.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    using System.Collections;

    /// <include file='doc\XmlNamedNodeMap.uex' path='docs/doc[@for="XmlNamedNodeMap"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a
    ///       collection of nodes that can be accessed by name or index.
    ///    </para>
    /// </devdoc>
    public class XmlNamedNodeMap : IEnumerable {
        internal XmlNode parent;
        internal ArrayList nodes;

        internal XmlNamedNodeMap( XmlNode parent ) {
            this.parent = parent;
            this.nodes = null;
        }

        /// <include file='doc\XmlNamedNodeMap.uex' path='docs/doc[@for="XmlNamedNodeMap.GetNamedItem"]/*' />
        /// <devdoc>
        /// <para>Retrieves an <see cref='System.Xml.XmlNode'/>
        /// specified by name.</para>
        /// </devdoc>
        public virtual XmlNode GetNamedItem(String name) {
            int offset = FindNodeOffset(name);
            if (offset >= 0)
                return(XmlNode) Nodes[offset];
            return null;
        }

        /// <include file='doc\XmlNamedNodeMap.uex' path='docs/doc[@for="XmlNamedNodeMap.SetNamedItem"]/*' />
        /// <devdoc>
        /// <para>Adds a <see cref='System.Xml.XmlNode'/> using its <see cref='System.Xml.XmlNode.Name'/> property</para>
        /// </devdoc>
        public virtual XmlNode SetNamedItem(XmlNode node) {
            if ( node == null )
                return null;

            int offset = FindNodeOffset( node.LocalName, node.NamespaceURI );
            if (offset == -1) {
                AddNode( node );
                return null;
            }
            else {
                return ReplaceNodeAt( offset, node );
            }
        }

        /// <include file='doc\XmlNamedNodeMap.uex' path='docs/doc[@for="XmlNamedNodeMap.RemoveNamedItem"]/*' />
        /// <devdoc>
        ///    <para>Removes the node specified by name.</para>
        /// </devdoc>
        public virtual XmlNode RemoveNamedItem(String name) {
            int offset = FindNodeOffset(name);
            if (offset >= 0) {
                return RemoveNodeAt( offset );
            }
            return null;
        }

        /// <include file='doc\XmlNamedNodeMap.uex' path='docs/doc[@for="XmlNamedNodeMap.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the number of nodes in this
        ///    <see langword='XmlNamedNodeMap'/> .</para>
        /// </devdoc>
        public virtual int Count {
            get {
                if (nodes != null)
                    return nodes.Count;
                return 0;
            }
        }

        /// <include file='doc\XmlNamedNodeMap.uex' path='docs/doc[@for="XmlNamedNodeMap.Item"]/*' />
        /// <devdoc>
        ///    <para>Retrieves the node at the specified index in this
        ///    <see cref='System.Xml.XmlNamedNodeMap'/>
        ///    .</para>
        /// </devdoc>
        public virtual XmlNode Item(int index) {
            if (index < 0 || index >= Nodes.Count)
                return null;
            try {
                return(XmlNode) Nodes[index];
            } catch ( ArgumentOutOfRangeException ) {
                throw new IndexOutOfRangeException(Res.GetString(Res.Xdom_IndexOutOfRange));
            }
        }

        // DOM Level 2
        /// <include file='doc\XmlNamedNodeMap.uex' path='docs/doc[@for="XmlNamedNodeMap.GetNamedItem1"]/*' />
        /// <devdoc>
        /// <para>Retrieves a node specified by <see cref='System.Xml.XmlNode.LocalName'/> and <see cref='System.Xml.XmlNode.NamespaceURI'/>
        /// .</para>
        /// </devdoc>
        public virtual XmlNode GetNamedItem(String localName, String namespaceURI) {
            int offset = FindNodeOffset( localName, namespaceURI );
            if (offset >= 0)
                return(XmlNode) Nodes[offset];
            return null;
        }

        /// <include file='doc\XmlNamedNodeMap.uex' path='docs/doc[@for="XmlNamedNodeMap.RemoveNamedItem1"]/*' />
        /// <devdoc>
        ///    <para>Removes a node specified by local name and namespace URI.</para>
        /// </devdoc>
        public virtual XmlNode RemoveNamedItem(String localName, String namespaceURI) {
            int offset = FindNodeOffset( localName, namespaceURI );
            if (offset >= 0) {
                return RemoveNodeAt( offset );
            }
            return null;
        }

        internal ArrayList Nodes {
            get {
                if (nodes == null)
                    nodes = new ArrayList();

                return nodes;
            }
        }

        /// <include file='doc\XmlNamedNodeMap.uex' path='docs/doc[@for="XmlNamedNodeMap.GetEnumerator"]/*' />
        public virtual IEnumerator GetEnumerator() {
            return new XmlNodeEnumerator(Nodes);
        }

        internal int FindNodeOffset( string name ) {
            int c = this.Count;
            for (int i = 0; i < c; i++) {
                XmlNode node = (XmlNode) Nodes[i];

                if (name == node.Name)
                    return i;
            }

            return -1;
        }

        internal int FindNodeOffset( string localName, string namespaceURI ) {
            int c = this.Count;
            for (int i = 0; i < c; i++) {
                XmlNode node = (XmlNode) Nodes[i];

                if (node.LocalName == localName && node.NamespaceURI == namespaceURI)
                    return i;
            }

            return -1;
        }

        internal virtual XmlNode AddNode( XmlNode node ) {
            XmlNode oldParent;
            if ( node.NodeType == XmlNodeType.Attribute )
                oldParent = ((XmlAttribute)node).OwnerElement;
            else
                oldParent = node.ParentNode;
            XmlNodeChangedEventArgs args = parent.GetEventArgs( node, oldParent, parent, XmlNodeChangedAction.Insert );

            if (args != null)
                parent.BeforeEvent( args );

            Nodes.Add( node );
            node.SetParent( parent );

            if (args != null)
                parent.AfterEvent( args );

            return node;
        }

        internal virtual XmlNode RemoveNodeAt( int i ) {
            XmlNode oldNode = (XmlNode)Nodes[i];

            XmlNodeChangedEventArgs args = parent.GetEventArgs( oldNode, parent, null, XmlNodeChangedAction.Remove );

            if (args != null)
                parent.BeforeEvent( args );

            Nodes.RemoveAt(i);
            oldNode.SetParent( null );

            if (args != null)
                parent.AfterEvent( args );

            return oldNode;
        }

        internal XmlNode ReplaceNodeAt( int i, XmlNode node ) {
            XmlNode oldNode = RemoveNodeAt( i );
            InsertNodeAt( i, node );
            return oldNode;
        }

        internal virtual XmlNode InsertNodeAt( int i, XmlNode node ) {
            XmlNode oldParent;
            if ( node.NodeType == XmlNodeType.Attribute )
                oldParent = ((XmlAttribute)node).OwnerElement;
            else
                oldParent = node.ParentNode;

            XmlNodeChangedEventArgs args = parent.GetEventArgs( node, oldParent, parent, XmlNodeChangedAction.Insert );

            if (args != null)
                parent.BeforeEvent( args );

            Nodes.Insert( i, node );
            node.SetParent( parent );

            if (args != null)
                parent.AfterEvent( args );

            return node;
        }
    }


    /// <include file='doc\XmlNamedNodeMap.uex' path='docs/doc[@for="XmlNodeEnumerator"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal sealed class XmlNodeEnumerator: IEnumerator {
        private IEnumerator     _Enumerator;

        internal XmlNodeEnumerator( ArrayList nodes ) {
            _Enumerator = nodes.GetEnumerator();
        }

        /*
        void IEnumerator.Reset() {
            _Enumerator.Reset();
        }

        bool IEnumerator.MoveNext() {
            return _Enumerator.MoveNext();
        }

        object IEnumerator.Current {
            get {
                return _Enumerator.Current;
            }
        }
        */

        /// <include file='doc\XmlNamedNodeMap.uex' path='docs/doc[@for="XmlNodeEnumerator.MoveNext"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool MoveNext() {
            return _Enumerator.MoveNext();
        }

        public object Current {
            get {
                return (_Enumerator.Current);
            }
        }

        public void Reset() {
            _Enumerator.Reset();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlloader.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlLoader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlLoader.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    using System.IO;
    using System.Collections;
    using System.Diagnostics;
    using System.Text;
    using System.Xml.Schema;

    internal class XmlLoader {
        XmlDocument doc;
        XmlReader   reader;
        bool        preserveWhitespace;


        public XmlLoader() {
        }

        internal void Load(XmlDocument doc, XmlReader reader, bool preserveWhitespace ) {
            this.doc = doc;
            this.reader = reader;
            this.preserveWhitespace = preserveWhitespace;
            if (doc == null)
                throw new ArgumentException(Res.GetString(Res.Xdom_Load_NoDocument));
            if (reader == null)
                throw new ArgumentException(Res.GetString(Res.Xdom_Load_NoReader));
            doc.SetBaseURI( reader.BaseURI );
            if ( this.reader.ReadState != ReadState.Interactive ) {
                if ( !this.reader.Read() )
                    return;
            }
            LoadDocSequence( doc);
        }

        //The function will start loading the document from where current XmlReader is pointing at.
        private void LoadDocSequence( XmlDocument parentDoc ) {
            Debug.Assert( this.reader != null );
            Debug.Assert( parentDoc != null );
            XmlNode node = null;
            while ( ( node = LoadCurrentNode() ) != null ) {
                parentDoc.AppendChildForLoad( node, parentDoc );
                if ( !this.reader.Read() )
                    return;
            }
        }

        internal XmlNode ReadCurrentNode(XmlDocument doc, XmlReader reader) {
            this.doc = doc;
            this.reader = reader;
            // WS are optional only for loading (see XmlDocument.PreserveWhitespace)
            this.preserveWhitespace = true;
            if (doc == null)
                throw new ArgumentException(Res.GetString(Res.Xdom_Load_NoDocument));
            if (reader == null)
                throw new ArgumentException(Res.GetString(Res.Xdom_Load_NoReader));

            if( reader.ReadState == ReadState.Initial ) {
                reader.Read();
            }
            if( reader.ReadState == ReadState.Interactive ) {
                XmlNode n = LoadCurrentNode();

                // Move to the next node
                if ( n.NodeType != XmlNodeType.Attribute )
                    reader.Read();

                return n;
            }
            return null;
        }

        // The way it is getting called guarantees that the reader is pointing at an element node or entity node, or the reader is
        // at Initial status. In this cases, LoadChildren will stop when nodes in the lower level are all consumed.
        private void LoadChildren( XmlNode parent ) {
            Debug.Assert( parent != null );
            XmlNode node = null;
            while ( reader.Read() && (node = LoadCurrentNode()) != null ) {
                parent.AppendChildForLoad( node, doc );
            }
        }

        private XmlNode LoadCurrentNode() {
            switch (reader.NodeType) {
                case XmlNodeType.Element:
                    return LoadElementNode();
                case XmlNodeType.Attribute:
                    return LoadAttributeNode();
                case XmlNodeType.Text:
                    return doc.CreateTextNode( reader.Value );
                case XmlNodeType.SignificantWhitespace:
                    return doc.CreateSignificantWhitespace( reader.Value );
                case XmlNodeType.Whitespace:
                    // Cannot create a function from this code, b/c this code does not return a whitespace node if preserceWS is false
                    if ( preserveWhitespace )
                        return doc.CreateWhitespace( reader.Value );

                    // if preserveWhitespace is false skip all subsequent WS nodes and position on the first non-WS node
                    do {
                        if (! reader.Read() )
                            return null;
                    } while (reader.NodeType == XmlNodeType.Whitespace);
                    return LoadCurrentNode();   // Skip WS node if preserveWhitespace is false
                case XmlNodeType.CDATA:
                    return doc.CreateCDataSection( reader.Value );
                case XmlNodeType.EntityReference:
                    return LoadEntityReferenceNode();
                case XmlNodeType.XmlDeclaration:
                    return LoadDeclarationNode();
                case XmlNodeType.ProcessingInstruction:
                    return doc.CreateProcessingInstruction( reader.Name, reader.Value );
                case XmlNodeType.Comment:
                    return doc.CreateComment( reader.Value );
                case XmlNodeType.DocumentType:
                    return LoadDocumentTypeNode();
                case XmlNodeType.EndElement:
                case XmlNodeType.EndEntity:
                    return null;

                default:
                    throw new InvalidOperationException(string.Format(Res.GetString(Res.Xdom_Load_NodeType),reader.NodeType.ToString()));
            }
        }


        private XmlElement LoadElementNode() {
            Debug.Assert( reader.NodeType == XmlNodeType.Element );

            bool fEmptyElement = reader.IsEmptyElement;

            XmlElement element = doc.CreateElement( reader.Prefix, reader.LocalName, reader.NamespaceURI );
            element.IsEmpty = fEmptyElement;

            while(reader.MoveToNextAttribute()) {
                XmlAttribute attr = (XmlAttribute) LoadCurrentNode();
                element.Attributes.Append( attr );
            }

            // recursively load all children.
            if (! fEmptyElement)
                LoadChildren( element );

            return element;
        }

        private XmlAttribute LoadAttributeNode() {
            Debug.Assert( reader.NodeType == XmlNodeType.Attribute );

            XmlAttribute attr;
            if (reader.IsDefault) {
                attr = doc.CreateDefaultAttribute( reader.Prefix, reader.LocalName, reader.NamespaceURI );
                LoadAttributeChildren( attr );
                XmlUnspecifiedAttribute defAttr = attr as XmlUnspecifiedAttribute;
                // If user overrrides CreateDefaultAttribute, then attr will NOT be a XmlUnspecifiedAttribute instance.
                if ( defAttr != null )
                    defAttr.SetSpecified( false );
                return attr;
            }

            attr = doc.CreateAttribute( reader.Prefix, reader.LocalName, reader.NamespaceURI );
            LoadAttributeChildren( attr );
            return attr;
        }

        private XmlEntityReference LoadEntityReferenceNode() {
            Debug.Assert( reader.NodeType == XmlNodeType.EntityReference );

            XmlEntityReference eref = doc.CreateEntityReference( reader.Name );
            if ( reader.CanResolveEntity ) {
                reader.ResolveEntity();
                LoadChildren( eref );
                // Code internally relies on the fact that an EntRef nodes has at least one child (even an empty text node). Ensure that this holds true,
                // if the reader does not present any children for the ent-ref
                if ( eref.LastChild == null )
                    eref.AppendChild( doc.CreateTextNode("") );
            }
            return eref;
        }

        private XmlDeclaration LoadDeclarationNode() {
            Debug.Assert( reader.NodeType == XmlNodeType.XmlDeclaration );

            //parse data
            string version = null;
            string encoding = null;
            string standalone = null;

            // Try first to use the reader to get the xml decl "attributes". Since not all readers are required to support this, it is possible to have
            // implementations that do nothing
            while(reader.MoveToNextAttribute()) {
                switch (reader.Name) {
                    case "version":
                        version = reader.Value;
                        break;
                    case "encoding":
                        encoding = reader.Value;
                        break;
                    case "standalone":
                        standalone = reader.Value;
                        break;
                    default:
                        Debug.Assert( false );
                        break;
                }
            }

            // For readers that do not break xml decl into attributes, we must parse the xml decl ourselfs. We use version attr, b/c xml decl MUST contain
            // at least version attr, so if the reader implements them as attr, then version must be present
            if ( version == null )
                ParseXmlDeclarationValue( reader.Value, out version, out encoding, out standalone );

            return doc.CreateXmlDeclaration( version, encoding, standalone );
        }

        private XmlDocumentType LoadDocumentTypeNode() {
            Debug.Assert( reader.NodeType == XmlNodeType.DocumentType );

            String publicId = null;
            String systemId = null;
            String internalSubset = reader.Value;
            String localName = reader.LocalName;
            while (reader.MoveToNextAttribute()) {
                switch (reader.Name) {
                  case "PUBLIC" :
                        publicId = reader.Value;
                        break;
                  case "SYSTEM":
                        systemId = reader.Value;
                        break;
                }
            }

            XmlDocumentType dtNode = doc.CreateDocumentType( localName, publicId, systemId, internalSubset );
            XmlValidatingReader vr = reader as XmlValidatingReader;
            if ( vr != null )
                LoadDocumentType( vr, dtNode );
            else {
                //construct our own XmlValidatingReader to parse the DocumentType node so we could get Entities and notations information
                XmlTextReader tr = reader as XmlTextReader;
                if ( tr != null ) {
                    dtNode.ParseWithNamespaces = tr.Namespaces;
                    ParseDocumentType( dtNode, true, tr.GetResolver());
                }
                else
                    ParseDocumentType( dtNode );
            }
            return dtNode;
        }

        private void LoadAttributeChildren( XmlNode parent ) {
            while (reader.ReadAttributeValue()) {
                switch (reader.NodeType) {
                    case XmlNodeType.EndEntity:
                        // exit read loop
                        return;

                    case XmlNodeType.Text:
                        parent.AppendChild( doc.CreateTextNode( reader.Value ) );
                        break;

                    case XmlNodeType.EntityReference: {
                        XmlEntityReference eref = doc.CreateEntityReference( reader.LocalName );
                        if ( reader.CanResolveEntity ) {
                            reader.ResolveEntity();
                            LoadAttributeChildren( eref );
                            //what if eref doesn't have children at all? should we just put a Empty String text here?
                            if ( eref.ChildNodes.Count == 0 )
                                eref.AppendChild( doc.CreateTextNode(String.Empty) );
                        }
                        parent.AppendChild( eref );
                        break;
                    }

                    default:
                        throw new InvalidOperationException(Res.GetString(Res.Xdom_Load_NodeType) + reader.NodeType);
                }
            }
        }

        private void LoadEntityChildren( XmlNode parent ) {
            Debug.Assert( parent != null );
            XmlNode node = null;
            while ( reader.Read() && (node = LoadEntityChildren()) != null )
                parent.AppendChildForLoad( node, doc );
        }

        private XmlNode LoadEntityChildren() {
            XmlNode node = null;

            // We do not use creator functions on XmlDocument, b/c we do not want to let users extend the nodes that are children of entity nodes (also, if we do
            // this, XmlDataDocument will have a problem, b/c they do not know that those nodes should not be mapped).
            switch (reader.NodeType) {
                case XmlNodeType.EndElement:
                case XmlNodeType.EndEntity:
                    break;

                case XmlNodeType.Element: {
                    bool fEmptyElement = reader.IsEmptyElement;

                    XmlElement element = new XmlElement( reader.Prefix, reader.LocalName, reader.NamespaceURI, this.doc );
                    element.IsEmpty = fEmptyElement;

                    while(reader.MoveToNextAttribute()) {
                        XmlAttribute attr = (XmlAttribute) LoadEntityChildren();
                        element.Attributes.Append( attr );
                    }

                    // recursively load all children.
                    if (! fEmptyElement)
                        LoadEntityChildren( element );

                    node = element;
                    break;
                }

                case XmlNodeType.Attribute:
                    if (reader.IsDefault) {
                        XmlUnspecifiedAttribute attr = new XmlUnspecifiedAttribute( reader.Prefix, reader.LocalName, reader.NamespaceURI, this.doc );
                        LoadEntityAttributeChildren( attr );
                        attr.SetSpecified( false );
                        node = attr;
                    }
                    else {
                        XmlAttribute attr = new XmlAttribute( reader.Prefix, reader.LocalName, reader.NamespaceURI, this.doc );
                        LoadEntityAttributeChildren( attr );
                        node = attr;
                    }
                    break;

                case XmlNodeType.SignificantWhitespace:
                    node = new XmlSignificantWhitespace( reader.Value, this.doc );
                    break;

                case XmlNodeType.Whitespace:
                    if ( preserveWhitespace )
                        node = new XmlWhitespace( reader.Value, this.doc );
                    else {
                        // if preserveWhitespace is false skip all subsequent WS nodes and position on the first non-WS node
                        do {
                            if (! reader.Read() )
                                return null;
                        } while (reader.NodeType == XmlNodeType.Whitespace);
                        node = LoadEntityChildren();   // Skip WS node if preserveWhitespace is false
                    }
                    break;

                case XmlNodeType.Text:
                    node = new XmlText( reader.Value, this.doc );
                    break;

                case XmlNodeType.CDATA:
                    node = new XmlCDataSection( reader.Value, this.doc );
                    break;

                case XmlNodeType.EntityReference:{
                    XmlEntityReference eref = new XmlEntityReference( reader.Name, this.doc );
                    if ( reader.CanResolveEntity ) {
                        reader.ResolveEntity();
                        LoadEntityChildren( eref );
                        //what if eref doesn't have children at all? should we just put a Empty String text here?
                        if ( eref.ChildNodes.Count == 0 )
                            eref.AppendChild( new XmlText("") );
                    }
                    node = eref;
                    break;
                }

                case XmlNodeType.ProcessingInstruction:
                    node = new XmlProcessingInstruction( reader.Name, reader.Value, this.doc );
                    break;

                case XmlNodeType.Comment:
                    node = new XmlComment( reader.Value, this.doc );
                    break;

                default:
                    throw new InvalidOperationException(string.Format(Res.GetString(Res.Xdom_Load_NodeType),reader.NodeType.ToString()));
            }

            return node;
        }

        private void LoadEntityAttributeChildren( XmlNode parent ) {
            while (reader.ReadAttributeValue()) {
                switch (reader.NodeType) {
                    case XmlNodeType.EndEntity:
                        // exit read loop
                        return;

                    case XmlNodeType.Text:
                        parent.AppendChild( new XmlText( reader.Value, this.doc ) );
                        break;

                    case XmlNodeType.EntityReference: {
                        XmlEntityReference eref = new XmlEntityReference( reader.LocalName, this.doc );
                        reader.ResolveEntity();
                        LoadEntityAttributeChildren( eref );
                        //what if eref doesn't have children at all? should we just put a Empty String text here?
                        if ( eref.ChildNodes.Count == 0 )
                            eref.AppendChild( new XmlText("") );
                        parent.AppendChild( eref );
                        break;
                    }

                    default:
                        throw new InvalidOperationException(Res.GetString(Res.Xdom_Load_NodeType) + reader.NodeType);
                }
            }
        }

        internal void ParseDocumentType ( XmlDocumentType dtNode ) {
            XmlDocument doc = dtNode.OwnerDocument;
            //if xmlresolver is set on doc, use that one, otherwise use the default one being created by xmlvalidatingreader
            if ( doc.HasSetResolver )
                ParseDocumentType( dtNode, true, doc.GetResolver() );
            else
                ParseDocumentType( dtNode, false, null );
        }

        private void ParseDocumentType ( XmlDocumentType dtNode, bool bUseResolver, XmlResolver resolver ) {
            this.doc = dtNode.OwnerDocument;
            XmlNameTable nt = this.doc.NameTable;
            XmlNamespaceManager mgr = new XmlNamespaceManager( nt );
            XmlParserContext pc = new XmlParserContext( nt,
                                                        mgr,
                                                        dtNode.Name,
                                                        dtNode.PublicId,
                                                        dtNode.SystemId,
                                                        dtNode.InternalSubset,
                                                        this.doc.BaseURI,
                                                        String.Empty,
                                                        XmlSpace.None
                                                        );
            XmlValidatingReader vr = new XmlValidatingReader( "", XmlNodeType.Element, pc );
            vr.Namespaces = dtNode.ParseWithNamespaces;
            if ( bUseResolver )
                vr.XmlResolver = resolver;
            vr.ValidationType = ValidationType.None;
            vr.Read();
            LoadDocumentType( vr, dtNode );
            vr.Close();
        }

        private void LoadDocumentType( XmlValidatingReader vr , XmlDocumentType dtNode ) {
            SchemaInfo schInfo = vr.GetSchemaInfo();
            if (schInfo != null) {
                //set the schema information into the document
                doc.SchemaInformation = schInfo;

                // Notation hashtable
                if (schInfo.Notations != null) {
                    foreach( SchemaNotation scNot in schInfo.Notations.Values ) {
                        dtNode.Notations.SetNamedItem(new XmlNotation( scNot.Name.Name, scNot.Pubid, scNot.SystemLiteral, doc ));
                    }
                }

                // Entity hashtables
                if (schInfo.GeneralEntities != null) {
                    foreach( SchemaEntity scEnt in schInfo.GeneralEntities.Values ) {
                        XmlEntity ent = new XmlEntity( scEnt.Name.Name, scEnt.Text, scEnt.Pubid, scEnt.Url, scEnt.NData.IsEmpty ? null : scEnt.NData.Name, doc );
                        ent.SetBaseURI( scEnt.DeclaredURI );
                        dtNode.Entities.SetNamedItem( ent );
                    }
                }

                if (schInfo.ParameterEntities != null) {
                    foreach( SchemaEntity scEnt in schInfo.ParameterEntities.Values ) {
                        XmlEntity ent = new XmlEntity( scEnt.Name.Name, scEnt.Text, scEnt.Pubid, scEnt.Url, scEnt.NData.IsEmpty ? null : scEnt.NData.Name, doc );
                        ent.SetBaseURI( scEnt.DeclaredURI );
                        dtNode.Entities.SetNamedItem( ent );
                    }
                }
                doc.Entities = dtNode.Entities;

                //extract the elements which has attribute defined as ID from the element declarations
                IDictionaryEnumerator elementDecls = schInfo.ElementDecls.GetEnumerator();
                if (elementDecls != null) {
                    elementDecls.Reset();
                    while (elementDecls.MoveNext()) {
                        SchemaElementDecl elementDecl = (SchemaElementDecl)elementDecls.Value;
                        if (elementDecl.AttDefs != null) {
                            IDictionaryEnumerator attDefs =  elementDecl.AttDefs.GetEnumerator();
                            while (attDefs.MoveNext()) {
                                SchemaAttDef attdef = (SchemaAttDef)attDefs.Value;
                                if (attdef.Datatype.TokenizedType == XmlTokenizedType.ID) {
                                    doc.AddIdInfo(
                                        doc.GetXmlName(elementDecl.Name.Name, elementDecl.Name.Namespace),
                                        doc.GetXmlName(attdef.Name.Name, attdef.Name.Namespace));
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }

        private XmlParserContext GetContext ( XmlNode node ) {
            String  lang = null;
            XmlSpace spaceMode = XmlSpace.None;
            XmlDocumentType docType = this.doc.DocumentType;
            String  baseURI = this.doc.BaseURI;
            //constructing xmlnamespace
            Hashtable prefixes = new Hashtable();
            XmlNameTable nt = this.doc.NameTable;
            XmlNamespaceManager mgr = new XmlNamespaceManager( nt );
            bool     bHasDefXmlnsAttr = false;

            // Process all xmlns, xmlns:prefix, xml:space and xml:lang attributes
            while ( node != null && node != doc && node != doc.NullNode ) {
                if ( node is XmlElement && ((XmlElement)node).HasAttributes ) {
                    mgr.PushScope();
                    foreach( XmlAttribute attr in ((XmlElement)node).Attributes ) {
                        if ( attr.Prefix == XmlDocument.strXmlns && prefixes.Contains( attr.LocalName ) == false ) {
                            // Make sure the next time we will not add this prefix
                            prefixes.Add( attr.LocalName, attr.LocalName );
                            mgr.AddNamespace( attr.LocalName, attr.Value );
                        }
                        else if ( !bHasDefXmlnsAttr && attr.Prefix == String.Empty && attr.LocalName == XmlDocument.strXmlns ) {
                            // Save the case xmlns="..." where xmlns is the LocalName
                            mgr.AddNamespace( String.Empty, attr.Value );
                            bHasDefXmlnsAttr = true;
                        }
                        else if ( spaceMode == XmlSpace.None && attr.Prefix == XmlDocument.strXml && attr.LocalName == XmlDocument.strSpace ) {
                            // Save xml:space context
                            if ( attr.Value=="default" )
                                spaceMode = XmlSpace.Default;
                            else if (attr.Value=="preserve")
                                spaceMode = XmlSpace.Preserve;
                        }
                        else if ( lang == null && attr.Prefix == XmlDocument.strXml && attr.LocalName == XmlDocument.strLang ) {
                            // Save xml:lag context
                            lang = attr.Value;
                        }
                    }
                }
                node = node.ParentNode;
            }
            return new XmlParserContext(
                nt,
                mgr,
                ( docType == null ) ? null : docType.Name,
                ( docType == null ) ? null : docType.PublicId,
                ( docType == null ) ? null : docType.SystemId,
                ( docType == null ) ? null : docType.InternalSubset,
                baseURI,
                lang,
                spaceMode
                );
        }



        internal XmlNamespaceManager ParsePartialContent( XmlNode parentNode, string innerxmltext, XmlNodeType nt) {
            //the function shouldn't be used to set innerxml for XmlDocument node
            Debug.Assert( parentNode.NodeType != XmlNodeType.Document );
            this.doc = parentNode.OwnerDocument;
            Debug.Assert( this.doc != null );
            XmlParserContext pc = GetContext( parentNode );
            this.reader = CreateInnerXmlValidatingReader( innerxmltext, nt, pc, this.doc );
            this.preserveWhitespace = true;
            bool bOrigLoading = doc.IsLoading;
            doc.IsLoading = true;
            if ( nt == XmlNodeType.Entity )
                LoadEntityChildren( parentNode );
            else
                LoadChildren( parentNode);
            doc.IsLoading = bOrigLoading;
            reader.Close();
            return pc.NamespaceManager;
        }

        internal void LoadInnerXmlElement(XmlElement node, string innerxmltext ) {
            //construct a tree underneth the node
            XmlNamespaceManager mgr = ParsePartialContent( node, innerxmltext, XmlNodeType.Element );
            //remove the duplicate namesapce
            if ( node.ChildNodes.Count > 0 )
                RemoveDuplicateNamespace( (XmlElement) node, mgr, false );
        }

        internal void LoadInnerXmlAttribute(XmlAttribute node, string innerxmltext ) {
            ParsePartialContent( node, innerxmltext, XmlNodeType.Attribute );
        }


        private void RemoveDuplicateNamespace( XmlElement elem, XmlNamespaceManager mgr, bool fCheckElemAttrs ) {
            //remove the duplicate attributes on current node first
            mgr.PushScope();
            XmlAttributeCollection attrs = elem.Attributes;
            int cAttrs = attrs.Count;
            if ( fCheckElemAttrs && cAttrs > 0 ) {
                for ( int i = cAttrs - 1; i >= 0; --i ) {
                    XmlAttribute attr = attrs[i];
                    if ( attr.Prefix == XmlDocument.strXmlns ) {
                        string nsUri = mgr.LookupNamespace(attr.LocalName);
                        if ( nsUri != null ) {
                            if ( attr.Value == nsUri )
                                elem.Attributes.RemoveNodeAt(i);
                        }
                        else {
                            // Add this namespace, so it we will behave corectly when setting "<bar xmlns:p="BAR"><foo2 xmlns:p="FOO"/></bar>" as
                            // InnerXml on this foo elem where foo is like this "<foo xmlns:p="FOO"></foo>"
                            // If do not do this, then we will remove the inner p prefix definition and will let the 1st p to be in scope for
                            // the subsequent InnerXml_set or setting an EntRef inside.
                            mgr.AddNamespace( attr.LocalName, attr.Value );
                        }
                    }
                    else if ( attr.Prefix == String.Empty && attr.LocalName == XmlDocument.strXmlns ) {
                        string nsUri = mgr.DefaultNamespace;
                        if ( nsUri != null ) {
                            if ( attr.Value == nsUri )
                                elem.Attributes.RemoveNodeAt(i);
                        }
                        else {
                            // Add this namespace, so it we will behave corectly when setting "<bar xmlns:p="BAR"><foo2 xmlns:p="FOO"/></bar>" as
                            // InnerXml on this foo elem where foo is like this "<foo xmlns:p="FOO"></foo>"
                            // If do not do this, then we will remove the inner p prefix definition and will let the 1st p to be in scope for
                            // the subsequent InnerXml_set or setting an EntRef inside.
                            mgr.AddNamespace( attr.LocalName, attr.Value );
                        }
                    }
                }
            }
            //now recursively remove the duplicate attributes on the children
            XmlNode child = elem.FirstChild;
            while ( child != null ) {
                XmlElement childElem = child as XmlElement;
                if ( childElem != null )
                    RemoveDuplicateNamespace( childElem, mgr, true );
                child = child.NextSibling;
            }
            mgr.PopScope();
        }

        private String EntitizeName(String name) {
            return "&"+name+";";
        }

        //The function is called when expanding the entity when its children being asked
        internal void ExpandEntity(XmlEntity ent) {
            ParsePartialContent( ent, EntitizeName(ent.Name), XmlNodeType.Entity );
        }

        //The function is called when expanding the entity ref. ( inside XmlEntityReference.SetParent )
        internal void ExpandEntityReference(XmlEntityReference eref)
        {
            //when the ent ref is not associated w/ an entity, append an empty string text node as child
            this.doc = eref.OwnerDocument;
            bool bOrigLoadingState = doc.IsLoading;
            doc.IsLoading = true;
            switch ( eref.Name ) {
                case "lt":
                    eref.AppendChild( doc.CreateTextNode( "<" ) );
                    doc.IsLoading = bOrigLoadingState;
                    return;
                case "gt":
                    eref.AppendChild( doc.CreateTextNode( ">" ) );
                    doc.IsLoading = bOrigLoadingState;
                    return;
                case "amp":
                    eref.AppendChild( doc.CreateTextNode( "&" ) );
                    doc.IsLoading = bOrigLoadingState;
                    return;
                case "apos":
                    eref.AppendChild( doc.CreateTextNode( "'" ) );
                    doc.IsLoading = bOrigLoadingState;
                    return;
                case "quot":
                    eref.AppendChild( doc.CreateTextNode( "\"" ) );
                    doc.IsLoading = bOrigLoadingState;
                    return;
            }

            XmlNamedNodeMap entities = doc.Entities;
            foreach ( XmlEntity ent in entities ) {
               if ( Ref.Equal( ent.Name, eref.Name ) ) {
                    ParsePartialContent( eref, EntitizeName(eref.Name), XmlNodeType.EntityReference );
                    return;
                }
            }
            //no fit so far
            if( !( doc.ActualLoadingStatus ) ) {
                eref.AppendChild( doc.CreateTextNode( "" ) );
                doc.IsLoading = bOrigLoadingState;
            }
            else {
                doc.IsLoading = bOrigLoadingState;
                throw new XmlException( Res.Xml_UndeclaredParEntity, eref.Name );
            }
        }

        // Creates a XmlValidatingReader suitable for parsing InnerXml strings
        private XmlReader CreateInnerXmlValidatingReader( String xmlFragment, XmlNodeType nt, XmlParserContext context, XmlDocument doc ) {
            XmlNodeType contentNT = nt;
            if ( contentNT == XmlNodeType.Entity || contentNT == XmlNodeType.EntityReference )
                contentNT = XmlNodeType.Element;
            XmlValidatingReader xmlvr = new XmlValidatingReader( xmlFragment, contentNT, context);
            if( doc.DocumentType != null )
                xmlvr.Namespaces = doc.DocumentType.ParseWithNamespaces;
            if ( doc.HasSetResolver )
                xmlvr.XmlResolver = doc.GetResolver();
            xmlvr.ValidationType = ValidationType.None;
            if( !( doc.ActualLoadingStatus ) )
                xmlvr.DisableUndeclaredEntityCheck = true;
            // all these settings are alreay the default setting in XmlTextReader
            xmlvr.EntityHandling = EntityHandling.ExpandCharEntities;
            if ( nt == XmlNodeType.Entity || nt == XmlNodeType.EntityReference ) {
                xmlvr.Read(); //this will skip the first element "wrapper"
                xmlvr.ResolveEntity();
            }
            return xmlvr;
        }

        internal static void ParseXmlDeclarationValue( string strValue, out string version, out string encoding, out string standalone ) {
            version = null;
            encoding = null;
            standalone = null;
            XmlTextReader tempreader = new XmlTextReader( strValue, (XmlParserContext)null);
            tempreader.Read();
            //get version info.
            if (tempreader.MoveToAttribute( "version" ))
                version = tempreader.Value;
            //get encoding info
            if (tempreader.MoveToAttribute( "encoding" ))
                encoding = tempreader.Value;
            //get standalone info
            if (tempreader.MoveToAttribute( "standalone" ))
                standalone = tempreader.Value;

            tempreader.Close();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnamevaluetokeninfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNameValueTokenInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


using System.Text;
using System.Diagnostics;
namespace System.Xml {

    /*
     * NameValueTokenInfo class for token that has simple name and value.
     * for DocType and PI node types.
     * This class has to worry about atomalize
     * name but does not have to handle prefix, namespace.
     */
    internal class XmlNameValueTokenInfo : XmlValueTokenInfo {
        private String _Name;

        internal XmlNameValueTokenInfo(XmlScanner scanner, XmlNamespaceManager nsMgr, XmlNodeType type,
                                        int depth, bool nor) : base(scanner, nsMgr, type, depth, nor) {
            _Name = String.Empty;
        }

        internal XmlNameValueTokenInfo(XmlScanner scanner, XmlNamespaceManager nsMgr, XmlNodeType type,
                                        int depth, String value, bool nor) :
                                            base(scanner, nsMgr, type, depth, nor) {
            _Name = String.Empty;
            base.SetValue(scanner, value, -1, -1);
        }

        internal override String Name {
            get {
                return _Name;
            }
            set {
                _Name = value;
                _SchemaType = null;
                _TypedValue = null;
                Debug.Assert(_Name != null, "Name should not be set to null");
            }
        }

        internal override String NameWPrefix {
            get {
                return this.Name;
            }
        }
    } // XmlNameValueTokenInfo
} // System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnodechangedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNodeChangedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlNodeChangedEventHandler.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml {
    /// <include file='doc\XmlNodeChangedEventHandler.uex' path='docs/doc[@for="XmlNodeChangedEventHandler"]/*' />
    /// <devdoc>
    /// </devdoc>
    public delegate void XmlNodeChangedEventHandler( object sender, XmlNodeChangedEventArgs e );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnode.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlNode.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    using System;
    using System.IO;
    using System.Collections;
    using System.Text;
    using System.Diagnostics;
    using System.Xml.XPath;
    using System.Globalization;
    
    /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a single node in the document.
    ///    </para>
    /// </devdoc>
    public abstract class XmlNode : ICloneable, IEnumerable, IXPathNavigable {
        internal XmlNode parentNode; //this pointer is reused to save the userdata information, need to prevent internal user access the pointer directly.

        internal XmlNode () {
        }
        
        internal XmlNode( XmlDocument doc ) {
            if ( doc == null )
                throw new ArgumentException(Res.GetString(Res.Xdom_Node_Null_Doc));
            this.parentNode = doc.NullNode;
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.CreateNavigator"]/*' />
        public XPathNavigator CreateNavigator() {
            if( this is XmlDocument ) {
                return ((XmlDocument)this).CreateNavigator( this );
            }
            else {
                XmlDocument doc = OwnerDocument;
                Debug.Assert( doc != null );
                return doc.CreateNavigator( this );
            }
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.SelectSingleNode"]/*' />
        /// <devdoc>
        ///    <para>Selects the first node that matches the xpath expression</para>
        /// </devdoc>
        public XmlNode SelectSingleNode( string xpath ) {
            try {
                XmlNodeList list = SelectNodes(xpath);
                return list[0];
            }
            catch( ArgumentOutOfRangeException ) {
                return null;
            }
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.SelectSingleNode1"]/*' />
        /// <devdoc>
        ///    <para>Selects the first node that matches the xpath expression and given namespace context.</para>
        /// </devdoc>
        public XmlNode SelectSingleNode( string xpath, XmlNamespaceManager nsmgr ) {
            XPathNavigator xn = (this).CreateNavigator();
            XPathExpression exp = xn.Compile(xpath);
            exp.SetContext(nsmgr);
            try {            
                XmlNodeList list = new XPathNodeList( xn.Select(exp) );;
                return list[0];
            }
            catch( ArgumentOutOfRangeException ) {
                return null;
            }
        }
                
        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.SelectNodes"]/*' />
        /// <devdoc>
        ///    <para>Selects all nodes that match the xpath expression</para>
        /// </devdoc>
        public XmlNodeList SelectNodes( string xpath ) {
            XPathNavigator n = (this).CreateNavigator();
            Debug.Assert( n != null );
            return new XPathNodeList( n.Select(xpath) );
        }
        
        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.SelectNodes1"]/*' />
        /// <devdoc>
        ///    <para>Selects all nodes that match the xpath expression and given namespace context.</para>
        /// </devdoc>
        public XmlNodeList SelectNodes( string xpath, XmlNamespaceManager nsmgr ) {
            XPathNavigator xn = (this).CreateNavigator();
            XPathExpression exp = xn.Compile(xpath);
            exp.SetContext(nsmgr);
            return new XPathNodeList( xn.Select(exp) );
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.Name"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the node.</para>
        /// </devdoc>
        public abstract string Name { 
            get; 
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.Value"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the value of the node.</para>
        /// </devdoc>
        public virtual string Value { 
            get { return null;}
            set { throw new InvalidOperationException(string.Format(Res.GetString(Res.Xdom_Node_SetVal), NodeType.ToString()));}
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public abstract XmlNodeType NodeType {
            get;
        }

        internal virtual XmlNode NullNode {
            get {
                XmlDocument ownerDocument = OwnerDocument;

                if (ownerDocument != null)
                    return ownerDocument.NullNode;

                return null;
            }
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.ParentNode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the parent of this node (for nodes that can have
        ///       parents).
        ///    </para>
        /// </devdoc>
        public virtual XmlNode ParentNode { 
            get {
                if ( parentNode == NullNode )
                    return null;
                return parentNode;
            }
        }

/*
        internal XmlNode OwnerNode {
            get {
                if (parentNode == NullNode)
                    return null;
                return parentNode;
            }
        }
*/
        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.ChildNodes"]/*' />
        /// <devdoc>
        ///    <para>Gets all children of this node.</para>
        /// </devdoc>
        public virtual XmlNodeList ChildNodes { 
            get { return new XmlChildNodes(this);}
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.PreviousSibling"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the node immediately preceding this node.
        ///    </para>
        /// </devdoc>
        public virtual XmlNode PreviousSibling { 
            get { return null;}
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.NextSibling"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the node immediately following this node.
        ///    </para>
        /// </devdoc>
        public virtual XmlNode NextSibling { 
            get { return null;} 
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.Attributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an <see cref='System.Xml.XmlAttributeCollection'/>
        ///       containing the attributes
        ///       of this node.
        ///    </para>
        /// </devdoc>
        public virtual XmlAttributeCollection Attributes { 
            get { return null;} 
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.OwnerDocument"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Xml.XmlDocument'/> that contains this node.
        ///    </para>
        /// </devdoc>
        public virtual XmlDocument OwnerDocument { 
            get { 
                //parentNode should not be null, it should at least be NullNode
                Debug.Assert( parentNode != null );
                if ( parentNode.NodeType == XmlNodeType.Document)
                    return (XmlDocument)parentNode;
                return parentNode.OwnerDocument;
            } 
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.FirstChild"]/*' />
        /// <devdoc>
        ///    <para>Gets the first child of this node.</para>
        /// </devdoc>
        public virtual XmlNode FirstChild { 
            get { 
                if (LastNode != null)
                    return LastNode.next;

                return null; 
            }
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.LastChild"]/*' />
        /// <devdoc>
        ///    <para>Gets the last child of this node.</para>
        /// </devdoc>
        public virtual XmlNode LastChild { 
            get { return LastNode;}
        }

        internal virtual bool IsContainer {
            get { return false;}
        }

        internal virtual XmlLinkedNode LastNode {
            get { return null;}
            set {}
        }

        internal bool AncesterNode(XmlNode node) {
            XmlNode n = this.ParentNode;

            while (n != null && n != this) {
                if (n == node)
                    return true;
                n = n.ParentNode;
            }

            return false;
        }

        //trace to the top to find out its parent node.
        internal bool IsConnected()
        {
            XmlNode parent = ParentNode;
            while (parent != null && !( parent.NodeType == XmlNodeType.Document ))
                parent = parent.ParentNode;           
            return parent != null;
        }
        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.InsertBefore"]/*' />
        /// <devdoc>
        ///    <para>Inserts the specified node immediately before the specified reference node.</para>
        /// </devdoc>
        public virtual XmlNode InsertBefore(XmlNode newChild, XmlNode refChild) {
            if (this == newChild || AncesterNode(newChild))
                throw new ArgumentException(Res.GetString(Res.Xdom_Node_Insert_Child));

            if (refChild == null)
                return AppendChild(newChild);

            if (!IsContainer)
                throw new InvalidOperationException(Res.GetString(Res.Xdom_Node_Insert_Contain));

            if (refChild.ParentNode != this)
                throw new ArgumentException(Res.GetString(Res.Xdom_Node_Insert_Path));

            if (newChild == refChild)
                return newChild;

            XmlDocument childDoc = newChild.OwnerDocument;
            XmlDocument thisDoc = OwnerDocument;
            if (childDoc != null && childDoc != thisDoc && childDoc != this)
                throw new ArgumentException(Res.GetString(Res.Xdom_Node_Insert_Context));

            if (!CanInsertBefore( newChild, refChild ))
                throw new InvalidOperationException(Res.GetString(Res.Xdom_Node_Insert_Location));

            if (newChild.ParentNode != null)
                newChild.ParentNode.RemoveChild( newChild );

            // special case for doc-fragment.
            if (newChild.NodeType == XmlNodeType.DocumentFragment) {
                XmlNode first = newChild.FirstChild;
                XmlNode node = first;
                if (node != null) {
                    newChild.RemoveChild( node );
                    InsertBefore( node, refChild );
                    // insert the rest of the children after this one.
                    InsertAfter( newChild, node );
                }
                return first;
            }

            if (!(newChild is XmlLinkedNode) || !IsValidChildType(newChild.NodeType))
                throw new InvalidOperationException(Res.GetString(Res.Xdom_Node_Insert_TypeConflict));

            XmlLinkedNode newNode = (XmlLinkedNode) newChild;
            XmlLinkedNode refNode = (XmlLinkedNode) refChild;

            XmlNodeChangedEventArgs args = GetEventArgs( newChild, newChild.ParentNode, this, XmlNodeChangedAction.Insert );

            if (args != null)
                BeforeEvent( args );

            if (refNode == FirstChild) {
                newNode.next = (XmlLinkedNode) FirstChild;
                LastNode.next = newNode;
            }
            else {
                XmlLinkedNode prev = (XmlLinkedNode) refNode.PreviousSibling;
                newNode.next = refNode;
                prev.next = newNode;
            }

            newNode.SetParent( this );

            if (args != null)
                AfterEvent( args );

            return newNode;
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.InsertAfter"]/*' />
        /// <devdoc>
        ///    <para>Inserts the specified node immediately after the specified reference node.</para>
        /// </devdoc>
        public virtual XmlNode InsertAfter(XmlNode newChild, XmlNode refChild) {
            if (this == newChild || AncesterNode(newChild))
                throw new ArgumentException(Res.GetString(Res.Xdom_Node_Insert_Child));

            if (refChild == null)
                return PrependChild(newChild);

            if (!IsContainer)
                throw new InvalidOperationException(Res.GetString(Res.Xdom_Node_Insert_Contain));

            if (refChild.ParentNode != this)
                throw new ArgumentException(Res.GetString(Res.Xdom_Node_Insert_Path));

            if (newChild == refChild)
                return newChild;

            XmlDocument childDoc = newChild.OwnerDocument;
            XmlDocument thisDoc = OwnerDocument;
            if (childDoc != null && childDoc != thisDoc && childDoc != this)
                throw new ArgumentException(Res.GetString(Res.Xdom_Node_Insert_Context));

            if (!CanInsertAfter( newChild, refChild ))
                throw new InvalidOperationException(Res.GetString(Res.Xdom_Node_Insert_Location));

            if (newChild.ParentNode != null)
                newChild.ParentNode.RemoveChild( newChild );

            // special case for doc-fragment.
            if (newChild.NodeType == XmlNodeType.DocumentFragment) {
                XmlNode last = refChild;
                XmlNode first = newChild.FirstChild;
                XmlNode node = first;
                while (node != null) {
                    XmlNode next = node.NextSibling;
                    newChild.RemoveChild( node );
                    InsertAfter( node, last );
                    last = node;
                    node = next;
                }
                return first;
            }

            if (!(newChild is XmlLinkedNode) || !IsValidChildType(newChild.NodeType))
                throw new InvalidOperationException(Res.GetString(Res.Xdom_Node_Insert_TypeConflict));

            XmlLinkedNode newNode = (XmlLinkedNode) newChild;
            XmlLinkedNode refNode = (XmlLinkedNode) refChild;

            XmlNodeChangedEventArgs args = GetEventArgs( newChild, newChild.ParentNode, this, XmlNodeChangedAction.Insert );

            if (args != null)
                BeforeEvent( args );

            newNode.next = refNode.next;
            refNode.next = newNode;

            if (LastNode == refNode)
                LastNode = newNode;

            newNode.SetParent( this );

            if (args != null)
                AfterEvent( args );

            return newNode;
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.ReplaceChild"]/*' />
        /// <devdoc>
        /// <para>Replaces the child node <paramref name="oldChild"/> 
        /// with <paramref name="newChild"/> node.</para>
        /// </devdoc>
        public virtual XmlNode ReplaceChild(XmlNode newChild, XmlNode oldChild) {
            XmlNode nextNode = oldChild.NextSibling;
            RemoveChild(oldChild);
            XmlNode node = InsertBefore( newChild, nextNode );
            return oldChild;
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.RemoveChild"]/*' />
        /// <devdoc>
        ///    <para>Removes specified child node.</para>
        /// </devdoc>
        public virtual XmlNode RemoveChild(XmlNode oldChild) {
            if (!IsContainer)
                throw new InvalidOperationException(Res.GetString(Res.Xdom_Node_Remove_Contain));

            if (oldChild.ParentNode != this)
                throw new ArgumentException(Res.GetString(Res.Xdom_Node_Remove_Child));

            XmlLinkedNode oldNode = (XmlLinkedNode) oldChild;

            XmlNodeChangedEventArgs args = GetEventArgs( oldNode, this, null, XmlNodeChangedAction.Remove );

            if (args != null)
                BeforeEvent( args );

            if (oldNode == FirstChild) {
                if (LastNode.next == LastNode) {
                    LastNode = null;
                }
                else {
                    LastNode.next = (XmlLinkedNode) FirstChild.NextSibling;
                }
            }
            else {
                XmlLinkedNode prev = (XmlLinkedNode) oldNode.PreviousSibling;

                prev.next = oldNode.next;

                if (oldNode == LastNode)
                    LastNode = prev;
            }

            oldNode.next = null;
            oldNode.SetParent( null );

            if (args != null)
                AfterEvent( args );

            return oldChild;
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.PrependChild"]/*' />
        /// <devdoc>
        ///    <para>Adds the specified node to the beginning of the list of children of
        ///       this node.</para>
        /// </devdoc>
        public virtual XmlNode PrependChild(XmlNode newChild) {
            return InsertBefore(newChild, FirstChild);
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.AppendChild"]/*' />
        /// <devdoc>
        ///    <para>Adds the specified node to the end of the list of children of
        ///       this node.</para>
        /// </devdoc>
        public virtual XmlNode AppendChild(XmlNode newChild) {
            XmlDocument thisDoc = OwnerDocument;
            if ( thisDoc == null ) {
                thisDoc = this as XmlDocument;
            }
            if (!IsContainer)
                throw new InvalidOperationException(Res.GetString(Res.Xdom_Node_Insert_Contain));

            if (this == newChild || AncesterNode(newChild))
                throw new ArgumentException(Res.GetString(Res.Xdom_Node_Insert_Child));

            if (newChild.ParentNode != null)
                newChild.ParentNode.RemoveChild( newChild );

            XmlDocument childDoc = newChild.OwnerDocument;
            if (childDoc != null && childDoc != thisDoc && childDoc != this)
                throw new ArgumentException(Res.GetString(Res.Xdom_Node_Insert_Context));

            // special case for doc-fragment.
            if (newChild.NodeType == XmlNodeType.DocumentFragment) {
                XmlNode first = newChild.FirstChild;
                XmlNode node = first;
                while (node != null) {
                    XmlNode next = node.NextSibling;
                    newChild.RemoveChild( node );
                    AppendChild( node );
                    node = next;
                }
                return first;
            }

            if (!(newChild is XmlLinkedNode) || !IsValidChildType(newChild.NodeType))
                throw new InvalidOperationException(Res.GetString(Res.Xdom_Node_Insert_TypeConflict));

            if (!CanInsertAfter( newChild, LastChild ))
                throw new InvalidOperationException(Res.GetString(Res.Xdom_Node_Insert_Location));

            XmlNodeChangedEventArgs args = GetEventArgs( newChild, newChild.ParentNode, this, XmlNodeChangedAction.Insert );

            if (args != null)
                BeforeEvent( args );

            XmlLinkedNode newNode = (XmlLinkedNode) newChild;

            if (LastNode == null) {
                newNode.next = newNode;
            }
            else {
                newNode.next = LastNode.next;
                LastNode.next = newNode;
            }

            LastNode = newNode;
            newNode.SetParent( this );

            if (args != null)
                AfterEvent( args );

            return newNode;
        }

        //the function is provided only at Load time to speed up Load process
        internal virtual XmlNode AppendChildForLoad(XmlNode newChild, XmlDocument doc) {
            XmlNodeChangedEventArgs args = doc.GetInsertEventArgsForLoad( newChild, this );

            if (args != null)
                doc.BeforeEvent( args );

            XmlLinkedNode newNode = (XmlLinkedNode) newChild;

            if (LastNode == null) {
                newNode.next = newNode;
            }
            else {
                newNode.next = LastNode.next;
                LastNode.next = newNode;
            }

            LastNode = newNode;
            newNode.SetParentForLoad( this );

            if (args != null)
                doc.AfterEvent( args );

            return newNode;
        }
        
        internal virtual bool IsValidChildType( XmlNodeType type ) {
            return false;
        }

        internal virtual bool CanInsertBefore( XmlNode newChild, XmlNode refChild ) {
            return true;
        }

        internal virtual bool CanInsertAfter( XmlNode newChild, XmlNode refChild ) {
            return true;
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.HasChildNodes"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this node has any child nodes.</para>
        /// </devdoc>
        public virtual bool HasChildNodes { 
            get { return LastNode != null;}
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a duplicate of this node.
        ///    </para>
        /// </devdoc>
        public abstract XmlNode CloneNode(bool deep);

        internal virtual void CopyChildren( XmlNode container, bool deep ) {
            XmlDocument doc = this.OwnerDocument;
            for (XmlNode child = container.FirstChild; child != null; child = child.NextSibling) {
                AppendChild( child.CloneNode(deep) );
            }
        }

        // DOM Level 2
        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.Normalize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Puts all XmlText nodes in the full depth of the sub-tree
        ///       underneath this XmlNode into a "normal" form where only
        ///       markup (e.g., tags, comments, processing instructions, CDATA sections,
        ///       and entity references) separates XmlText nodes, that is, there
        ///       are no adjacent XmlText nodes.
        ///    </para>
        /// </devdoc>
        public virtual void Normalize() {
            XmlNode firstChildTextLikeNode = null;
            StringBuilder sb = new StringBuilder();            
            for ( XmlNode crtChild = this.FirstChild; crtChild != null; ) {
                XmlNode nextChild = crtChild.NextSibling;
                switch ( crtChild.NodeType ) {
                    case XmlNodeType.Text:
                    case XmlNodeType.Whitespace: 
                    case XmlNodeType.SignificantWhitespace: {                        
                        sb.Append( crtChild.Value );
                        XmlNode winner = NormalizeWinner( firstChildTextLikeNode, crtChild );
                        if ( winner == firstChildTextLikeNode ) {
                            this.RemoveChild( crtChild );
                        } 
                        else {
                            if ( firstChildTextLikeNode != null )
                                this.RemoveChild( firstChildTextLikeNode );
                            firstChildTextLikeNode = crtChild;
                        }
                        break;
                    }
                    case XmlNodeType.Element: {
                        crtChild.Normalize();
                        goto default;
                    }
                    default : {
                        if ( firstChildTextLikeNode != null ) {
                            firstChildTextLikeNode.Value = sb.ToString();
                            firstChildTextLikeNode = null;
                        }
                        sb.Remove( 0, sb.Length );
			break;
                    }
                }
                crtChild = nextChild;
            }
            if ( firstChildTextLikeNode != null && sb.Length > 0 )
                firstChildTextLikeNode.Value = sb.ToString();
        }

        private XmlNode NormalizeWinner( XmlNode firstNode, XmlNode secondNode ) {
            //first node has the priority
            if ( firstNode == null )
                return secondNode;
            Debug.Assert( firstNode.NodeType == XmlNodeType.Text 
                        || firstNode.NodeType == XmlNodeType.SignificantWhitespace
                        || firstNode.NodeType == XmlNodeType.Whitespace
                        || secondNode.NodeType == XmlNodeType.Text 
                        || secondNode.NodeType == XmlNodeType.SignificantWhitespace
                        || secondNode.NodeType == XmlNodeType.Whitespace );
            if ( firstNode.NodeType == XmlNodeType.Text )
                return firstNode;
            if ( secondNode.NodeType == XmlNodeType.Text )
                return secondNode;
            if ( firstNode.NodeType == XmlNodeType.SignificantWhitespace )
                return firstNode;
            if ( secondNode.NodeType == XmlNodeType.SignificantWhitespace )
                return secondNode;
            if ( firstNode.NodeType == XmlNodeType.Whitespace )
                return firstNode;
            if ( secondNode.NodeType == XmlNodeType.Whitespace )
                return secondNode;
            Debug.Assert( true, "shouldn't have fall through here." );
            return null;
        }
        
        /*
        public virtual void Normalize() {
            XmlNode firstChildTextLikeNode = null;
            for (XmlNode crtChild = this.FirstChild; crtChild != null;) {
                XmlNode nextChild   = crtChild.NextSibling;
                XmlNodeType crtType = crtChild.NodeType;
                switch ( crtType ) {
                    case XmlNodeType.Text: {
                        if ( firstChildTextLikeNode != null ) {
                            if ( firstChildTextLikeNode.NodeType == XmlNodeType.Text ) {
                                ((XmlCharacterData)firstChildTextLikeNode).AppendData( crtChild.Value );
                                this.RemoveChild( crtChild );
                            } 
                            else {
                                ((XmlCharacterData)crtChild).InsertData( 0, firstChildTextLikeNode.Value );
                                this.RemoveChild( firstChildTextLikeNode );
                                firstChildTextLikeNode = crtChild;
                            }
                        } 
                        else {
                            firstChildTextLikeNode = crtChild;
                            }
                        break;
                    }
                    case XmlNodeType.SignificantWhitespace: {
                        if ( firstChildTextLikeNode != null ) {
                            if ( firstChildTextLikeNode.NodeType == XmlNodeType.Text 
                                || firstChildTextLikeNode.NodeType == XmlNodeType.SignificantWhitespace ) {
                                ((XmlCharacterData)firstChildTextLikeNode).AppendData( crtChild.Value );
                                this.RemoveChild( crtChild );
                            } 
                            else {
                                ((XmlCharacterData)crtChild).InsertData( 0, firstChildTextLikeNode.Value );
                                this.RemoveChild( firstChildTextLikeNode );
                                firstChildTextLikeNode = crtChild;
                            }
                        } 
                        else
                            firstChildTextLikeNode = crtChild;
                        break;
                    }
                    case XmlNodeType.Whitespace: {
                        if ( firstChildTextLikeNode != null ) {
                            ((XmlCharacterData)firstChildTextLikeNode).AppendData( crtChild.Value );
                            this.RemoveChild( crtChild );
                        } 
                        else 
                            firstChildTextLikeNode = crtChild;
                        break;                            
                    }
                    case XmlNodeType.Element: {
                        crtChild.Normalize();
                        firstChildTextLikeNode = null;
                        break;
                    }
                    default:
                        firstChildTextLikeNode = null;                        
                }
                crtChild = nextChild;
            }
        }*/

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.Supports"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Test if the DOM implementation implements a specific feature.
        ///    </para>
        /// </devdoc>
        public virtual bool Supports(string feature, string version) {
            if ( String.Compare("XML", feature, true, CultureInfo.InvariantCulture) == 0 ) {
                if ( version == null || version == "1.0" || version == "2.0" )
                    return true;
            }
            return false;
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.NamespaceURI"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the namespace URI of this node.
        ///    </para>
        /// </devdoc>
        public virtual string NamespaceURI { 
            get { return string.Empty;} 
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.Prefix"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the namespace prefix of this node.</para>
        /// </devdoc>
        public virtual string Prefix { 
            get { return string.Empty;} 
            set {} 
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public abstract string LocalName { 
            get;
        }

        // Microsoft extensions
        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the node is read-only.
        ///    </para>
        /// </devdoc>
        public virtual bool IsReadOnly {
            get { 
                XmlDocument doc = OwnerDocument;
                return HasReadOnlyParent( this );
            }
        }

        internal static bool HasReadOnlyParent( XmlNode n ) {
            while (n != null) {
                switch (n.NodeType) {
                    case XmlNodeType.EntityReference:
                    case XmlNodeType.Entity:
                        return true;

                    case XmlNodeType.Attribute:
                    n = ((XmlAttribute)n).OwnerElement;
                        break;

                    default:
                    n = n.ParentNode;
                        break;
                }
            }
            return false;
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.Clone"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a duplicate of this node.
        ///    </para>
        /// </devdoc>
        public virtual XmlNode Clone() {
            return this.CloneNode(true);
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.ICloneable.Clone"]/*' />
        /// <internalonly/>
        object ICloneable.Clone() {
            return this.CloneNode(true);
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Provides a simple ForEach-style iteration over the
        /// collection of nodes in this XmlNamedNodeMap.
        /// </para>
        /// </devdoc>
        IEnumerator IEnumerable.GetEnumerator() {
            return new XmlChildEnumerator(this);
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator() {
            return new XmlChildEnumerator(this);
        }

        private void AppendChildText( StringBuilder builder ) {
            for (XmlNode child = FirstChild; child != null; child = child.NextSibling) {
                if (child.FirstChild == null) {
                    if (child.NodeType == XmlNodeType.Text || child.NodeType == XmlNodeType.CDATA
                        || child.NodeType == XmlNodeType.Whitespace || child.NodeType == XmlNodeType.SignificantWhitespace)
                        builder.Append( child.InnerText );
                }
                else {
                    child.AppendChildText( builder );
                }
            }
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.InnerText"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the concatenated values of the node and
        ///       all its children.</para>
        /// </devdoc>
        public virtual string InnerText { 
            get {
                XmlNode fc = FirstChild;
                if (fc == null) {
                    return string.Empty;
                }
                else if (fc.NextSibling == null
                    && (fc.NodeType == XmlNodeType.Text ||  fc.NodeType == XmlNodeType.CDATA
                        || fc.NodeType == XmlNodeType.Whitespace || fc.NodeType == XmlNodeType.SignificantWhitespace)) {
                    return fc.Value;
                }
                else {
                    StringBuilder builder = new StringBuilder();
                    AppendChildText( builder );
                    return builder.ToString();
                }
            }

            set {
                XmlNode firstChild = FirstChild;
                if ( firstChild != null  //there is one child
                    && firstChild.NextSibling == null // and exactly one 
                    && firstChild.NodeType == XmlNodeType.Text )//which is a text node
                {
                    //this branch is for perf reason and event fired when TextNode.Value is changed
                    firstChild.Value = value;
                } 
                else {
                    RemoveAll();
                    AppendChild( OwnerDocument.CreateTextNode( value ) );
                }
            }
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.OuterXml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the markup
        ///       representing this node and all its children.
        ///    </para>
        /// </devdoc>
        public virtual string OuterXml { 
            get {
                StringWriter sw = new StringWriter();
                XmlDOMTextWriter xw = new XmlDOMTextWriter( sw );

                WriteTo( xw );
                xw.Close();

                return sw.ToString();
            }
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.InnerXml"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the markup representing
        ///       just the children of this node.</para>
        /// </devdoc>
        public virtual string InnerXml {
            get { 
                StringWriter sw = new StringWriter();
                XmlDOMTextWriter xw = new XmlDOMTextWriter( sw );

                WriteContentTo( xw );
                xw.Close();

                return sw.ToString();
            }

            set { 
                throw new InvalidOperationException( Res.GetString(Res.Xdom_Set_InnerXml ) );
            }
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.BaseURI"]/*' />
        public virtual String BaseURI {
            get {
                XmlNode curNode = this.ParentNode; //save one while loop since if going to here, the nodetype of this node can't be document, entity and entityref
                while ( curNode != null ) {
                    XmlNodeType nt = curNode.NodeType;
                    //EntityReference's children come from the dtd where they are defined.
                    //we need to investigate the same thing for entity's children if they are defined in an external dtd file.
                    if ( nt == XmlNodeType.EntityReference )
                        return ((XmlEntityReference)curNode).ChildBaseURI;
                    if ( nt == XmlNodeType.Document 
                        || nt == XmlNodeType.Entity 
                        || nt == XmlNodeType.Attribute )
                        return curNode.BaseURI;
                    curNode = curNode.ParentNode;
                }
                return String.Empty;
            }
        }

        // override this
        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.WriteTo"]/*' />
        /// <devdoc>
        ///    <para>Saves the current node to the specified XmlWriter.</para>
        /// </devdoc>
        public abstract void WriteTo(XmlWriter w);
        // override this
        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.WriteContentTo"]/*' />
        /// <devdoc>
        ///    <para>Saves all the children of the node to the specified XmlWriter.</para>
        /// </devdoc>
        public abstract void WriteContentTo(XmlWriter w);

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.RemoveAll"]/*' />
        /// <devdoc>
        ///    <para>Removes all the children and/or attributes
        ///       of the current node.</para>
        /// </devdoc>
        public virtual void RemoveAll() {
            XmlNode child = FirstChild;
            XmlNode sibling = null;

            while (child != null) {
                sibling = child.NextSibling;
                RemoveChild( child );
                child = sibling;
            }
        }

        internal XmlDocument Document {
            get {
                if (NodeType == XmlNodeType.Document)
                    return(XmlDocument) this;
                return OwnerDocument;
            }
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.GetNamespaceOfPrefix"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Looks up the closest xmlns declaration for the given
        ///       prefix that is in scope for the current node and returns
        ///       the namespace URI in the declaration.
        ///    </para>
        /// </devdoc>
        public virtual string GetNamespaceOfPrefix(string prefix) {
            XmlDocument doc = Document;
            if (doc != null) {
                prefix = doc.NameTable.Get(prefix);
                if(prefix == null)
                    return string.Empty;
                XmlNode node = this;
                while (node != null) {
                    if (node.NodeType == XmlNodeType.Element) {
                        // short-circuit.. if this nodes' prefix is the right one,
                        // then this node's namespace is the right one, or else
                        // there is an implied namespace decl that would get generated
                        // on write.
                        if (Ref.Equal(node.Prefix, prefix)) 
                            return node.NamespaceURI;

                        // search for namespace decl in attributes
                        XmlElement e = (XmlElement) node;
                        if (e.HasAttributes) {
                            int cAttr = e.Attributes.Count;
                            for (int iAttr = cAttr - 1; iAttr >= 0; iAttr--) {
                                XmlNode attr = e.Attributes[iAttr];
                                if (
                                    Ref.Equal(attr.Prefix   , XmlDocument.strXmlns) && 
                                    Ref.Equal(attr.LocalName, prefix)
                                ) {
                                    return attr.Value;
                                }
                            }
                        }
                        node = node.ParentNode;
                    }
                    else if (node.NodeType == XmlNodeType.Attribute) {
                        node = ((XmlAttribute)node).OwnerElement;
                    }
                    else {
                        node = node.ParentNode;
                    }
                }
            }
            return string.Empty;
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.GetPrefixOfNamespace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Looks up the closest xmlns declaration for the given namespace
        ///       URI that is in scope for the current node and returns
        ///       the prefix defined in that declaration.
        ///    </para>
        /// </devdoc>
        public virtual string GetPrefixOfNamespace(string namespaceURI) {
            XmlDocument doc = Document;
            //Should we add the default namespace part inside "if (doc!=null)" statement?
            //the reason to leave it here is that it is generic enough to return the prefix for default ns
            if ( namespaceURI == XmlDocument.strReservedXmlns )
                return XmlDocument.strXmlns;
            
            if (doc != null) {
                namespaceURI = doc.NameTable.Add(namespaceURI);

                XmlNode node = this;
                while (node != null) {
                    if (node.NodeType == XmlNodeType.Element) {
                        if (Ref.Equal(node.NamespaceURI, namespaceURI))
                            return node.Prefix;

                        // search for namespace decl in attributes
                        XmlElement e = (XmlElement) node;
                        if (e.HasAttributes) {
                            int cAttr = e.Attributes.Count;
                            for (int iAttr = cAttr - 1; iAttr >= 0; iAttr--) {
                                XmlNode attr = e.Attributes[iAttr];
                                if (Ref.Equal(attr.Prefix, XmlDocument.strXmlns) && attr.Value == namespaceURI) {
                                    return attr.LocalName;
                                }
                            }
                        }
                        node = node.ParentNode;
                    }
                    else if (node.NodeType == XmlNodeType.Attribute) {
                        node = ((XmlAttribute)node).OwnerElement;
                    }
                    else {
                        node = node.ParentNode;
                    }
                }
            }
            return string.Empty;
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves the first child element with the specified name.
        ///    </para>
        /// </devdoc>
        public virtual XmlElement this[string name]
        {
            get { 
                for (XmlNode n = FirstChild; n != null; n = n.NextSibling) {
                    if (n.NodeType == XmlNodeType.Element && n.Name == name)
                        return(XmlElement) n;
                }
                return null;
            }
        }

        /// <include file='doc\XmlNode.uex' path='docs/doc[@for="XmlNode.this1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves the first child element with the specified LocalName and
        ///       NamespaceURI.
        ///    </para>
        /// </devdoc>
        public virtual XmlElement this[string localname, string ns]
        {
            get { 
                for (XmlNode n = FirstChild; n != null; n = n.NextSibling) {
                    if (n.NodeType == XmlNodeType.Element && n.LocalName == localname && n.NamespaceURI == ns)
                        return(XmlElement) n;
                }
                return null; 
            }
        }

        
        internal virtual void SetParent( XmlNode node ) {
            if (node == null) {
                this.parentNode = NullNode;
            }
            else {
                this.parentNode = node;
            }
        }

        internal virtual void SetParentForLoad( XmlNode node ) {
            this.parentNode = node;
        }

        internal static void SplitName( string name, out string prefix, out string localName ) {
            int colonPos = name.IndexOf(":");
            if (-1 == colonPos || 0 == colonPos || name.Length-1 == colonPos) {
                prefix = string.Empty;
                localName = name;
            }
            else {
                prefix = name.Substring(0, colonPos);
                localName = name.Substring(colonPos+1);
            }
        }

        internal virtual XmlNode FindChild( XmlNodeType type ) {
            for (XmlNode child = FirstChild; child != null; child = child.NextSibling) {
                if (child.NodeType == type) {
                    return child;
                }
            }
            return null;
        }

        internal virtual XmlNodeChangedEventArgs GetEventArgs( XmlNode node, XmlNode oldParent, XmlNode newParent, XmlNodeChangedAction action  ) {
            XmlDocument doc = OwnerDocument;
            if (doc != null) {
                if ( ! doc.IsLoading ) {
                    if ( ( (newParent != null && newParent.IsReadOnly) || ( oldParent != null && oldParent.IsReadOnly ) ) )
                        throw new InvalidOperationException( Res.GetString(Res.Xdom_Node_Modify_ReadOnly));
                    doc.fIsEdited = true;
                }
                return doc.GetEventArgs( node, oldParent, newParent, action );
            }
            return null;
        }
        
        internal virtual void BeforeEvent( XmlNodeChangedEventArgs args ) {
            if (args != null)
                OwnerDocument.BeforeEvent( args );
        }

        internal virtual void AfterEvent( XmlNodeChangedEventArgs args ) {
            if (args != null)
                OwnerDocument.AfterEvent( args );
        }

        internal virtual XmlSpace XmlSpace {
            get {
                XmlNode node = this;
                XmlElement elem = null;
                do {
                    elem = node as XmlElement;
                    if ( elem != null && elem.HasAttribute( "xml:space" ) ) {
                        String xmlSpaceVal = elem.GetAttribute( "xml:space" );
                        if ( xmlSpaceVal.ToLower(CultureInfo.InvariantCulture) == "default" )
                            return XmlSpace.Default;
                        else if ( xmlSpaceVal.ToLower(CultureInfo.InvariantCulture) == "preserve" )
                            return XmlSpace.Preserve;
                        //should we throw exception if value is otherwise?
                    }
                    node = node.ParentNode;
                } while ( node != null );
                return XmlSpace.None;
            }
        }

        internal virtual String XmlLang {
            get {
                XmlNode node = this;
                XmlElement elem = null;
                do {
                    elem = node as XmlElement;
                    if ( elem != null ) {
                        if ( elem.HasAttribute( "xml:lang" ) )
                            return elem.GetAttribute( "xml:lang" );
                    }
                    node = node.ParentNode;
                } while ( node != null );
                return String.Empty;
            }
        }

        internal virtual XPathNodeType XPNodeType { get { return (XPathNodeType)(-1); } }
        internal virtual string XPLocalName { get { return string.Empty; } }
        internal virtual string GetXPAttribute( string localName, string namespaceURI ) {
            return String.Empty;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnodelist.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNodeList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlNodeList.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    using System.Collections;

    /// <include file='doc\XmlNodeList.uex' path='docs/doc[@for="XmlNodeList"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an ordered collection of nodes.
    ///    </para>
    /// </devdoc>
    public abstract class XmlNodeList: IEnumerable {

        /// <include file='doc\XmlNodeList.uex' path='docs/doc[@for="XmlNodeList.Item"]/*' />
        /// <devdoc>
        ///    <para>Retrieves a node at the given index.</para>
        /// </devdoc>
        public abstract XmlNode Item(int index);

        /// <include file='doc\XmlNodeList.uex' path='docs/doc[@for="XmlNodeList.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the number of nodes in this XmlNodeList.</para>
        /// </devdoc>
        public abstract int Count { get;}

        /// <include file='doc\XmlNodeList.uex' path='docs/doc[@for="XmlNodeList.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>Provides a simple ForEach-style iteration over the collection of nodes in
        ///       this XmlNodeList.</para>
        /// </devdoc>
        public abstract IEnumerator GetEnumerator();
        /// <include file='doc\XmlNodeList.uex' path='docs/doc[@for="XmlNodeList.this"]/*' />
        /// <devdoc>
        ///    <para>Retrieves a node at the given index.</para>
        /// </devdoc>
        [System.Runtime.CompilerServices.IndexerName ("ItemOf")]
        public virtual XmlNode this[int i] { get { return Item(i);}}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnametable.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNameTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml {

    /// <include file='doc\XmlNameTable.uex' path='docs/doc[@for="XmlNameTable"]/*' />
    /// <devdoc>
    ///    <para> Table of atomized string objects. This provides an
    ///       efficient means for the XML parser to use the same string object for all
    ///       repeated element and attribute names in an XML document. This class is
    ///    <see langword='abstract'/>
    ///    .</para>
    /// </devdoc>
    public abstract class XmlNameTable {

        /// <include file='doc\XmlNameTable.uex' path='docs/doc[@for="XmlNameTable.Get"]/*' />
        /// <devdoc>
        ///    <para>Gets the atomized String object containing the same
        ///       chars as the specified range of chars in the given char array.</para>
        /// </devdoc>
        public abstract String Get(char[] array, int offset, int length);

        /// <include file='doc\XmlNameTable.uex' path='docs/doc[@for="XmlNameTable.Get1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the atomized String object containing the same
        ///       value as the specified string.
        ///    </para>
        /// </devdoc>
        public abstract String Get(String array);

        /// <include file='doc\XmlNameTable.uex' path='docs/doc[@for="XmlNameTable.Add"]/*' />
        /// <devdoc>
        ///    <para>Creates a new atom for the characters at the specified range
        ///       of chararacters in the specified string.</para>
        /// </devdoc>
        public abstract String Add(char[] array, int offset, int length);

        /// <include file='doc\XmlNameTable.uex' path='docs/doc[@for="XmlNameTable.Add1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new atom for the specified string.
        ///    </para>
        /// </devdoc>
        public abstract String Add(String array);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnodechangedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNodeChangedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlNodeChangedEventArgs.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Xml {
    /// <include file='doc\XmlNodeChangedEventArgs.uex' path='docs/doc[@for="XmlNodeChangedEventArgs"]/*' />
    /// <devdoc>
    /// </devdoc>
    public class XmlNodeChangedEventArgs {
        private XmlNodeChangedAction action;
        private XmlNode     node;
        private XmlNode     oldParent;
        private XmlNode     newParent;

        /// <include file='doc\XmlNodeChangedEventArgs.uex' path='docs/doc[@for="XmlNodeChangedEventArgs.Action"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlNodeChangedAction Action { get { return action; } }
        /// <include file='doc\XmlNodeChangedEventArgs.uex' path='docs/doc[@for="XmlNodeChangedEventArgs.Node"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlNode Node { get { return node; } }
        /// <include file='doc\XmlNodeChangedEventArgs.uex' path='docs/doc[@for="XmlNodeChangedEventArgs.OldParent"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlNode OldParent { get { return oldParent; } }
        /// <include file='doc\XmlNodeChangedEventArgs.uex' path='docs/doc[@for="XmlNodeChangedEventArgs.NewParent"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlNode NewParent { get { return newParent; } }
        

        internal XmlNodeChangedEventArgs( XmlNode node, XmlNode oldParent, XmlNode newParent, XmlNodeChangedAction action ) {
            this.node      = node;
            this.oldParent = oldParent;
            this.newParent = newParent;
            this.action    = action;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnodeorder.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNodeOrder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlNodeOrder.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    /// <include file='doc\XmlNodeOrder.uex' path='docs/doc[@for="XmlNodeOrder"]/*' />
    public enum XmlNodeOrder {
        /// <include file='doc\XmlNodeOrder.uex' path='docs/doc[@for="XmlNodeOrder.Before"]/*' />
        Before,
        /// <include file='doc\XmlNodeOrder.uex' path='docs/doc[@for="XmlNodeOrder.After"]/*' />
        After,
        /// <include file='doc\XmlNodeOrder.uex' path='docs/doc[@for="XmlNodeOrder.Same"]/*' />
        Same,
        /// <include file='doc\XmlNodeOrder.uex' path='docs/doc[@for="XmlNodeOrder.Unknown"]/*' />
        Unknown        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnodereader.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNodeReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlNodeReader.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml
{
    using System;
    using System.Text;
    using System.IO;
    using System.Diagnostics;

    internal class XmlNodeReaderNavigator {
    //The idea for XmlNodeReaderNavigator is to wrap up partial XmlNavigator's interface with the considering of reader's interface
    //For example, XmlNavigator:GetAttribute(...) will always return String.Empty if the attribute doesn't exists;
    //  while XmlNodeReaderNavigator:GetAttribute(...( will return null.
    //Especially, if the reader is pointing at an attribute (by calling MoveToAttribute(..)), it's node's properties
    //  (Name, LocalName, Prefix, Value,etc) will return those of the attribute, while some others (HasAttribute,
    //  AttributeCount, MoveToAttribute) will return those of its owner element.
    //So XmlNodeReaderNavigator will return what Reader should return, but move as navigator should move.

            //XmlNavigator nav;
            //XmlNavigator tempNav;
            //XmlNavigator elemNav;
            //XmlNavigator logNav;

            XmlNode     curNode;
            XmlNode     tempNode;
            XmlNode     elemNode;
            XmlNode     logNode;
            int         _attrIndex;
            int         logAttrIndex;

            //presave these 2 variables since they shouldn't change.
            XmlNameTable    nameTable;
            XmlDocument     doc;

            int     nAttrInd; //used to identify virtual attributes of DocumentType node and XmlDeclaration node

            const String     strPublicID     = "PUBLIC";
            const String     strSystemID     = "SYSTEM";
            const String     strVersion      = "version";
            const String     strStandalone   = "standalone";
            const String     strEncoding     = "encoding";


            //caching variables for perf reasons
            int     nDeclarationAttrCount;
            int     nDocTypeAttrCount;

            //variables for roll back the moves
            int     nLogLevel;
            int     nLogAttrInd;
            bool    bLogOnAttrVal;
            bool bCreatedOnAttribute;

            public struct VirtualAttribute {
                public String name;
                public String value;

                public VirtualAttribute(String name, String value) {
                    this.name = name;
                    this.value = value;
                }
            };

            public VirtualAttribute [] decNodeAttributes = {
                new VirtualAttribute( null, null ),
                new VirtualAttribute( null, null ),
                new VirtualAttribute( null, null )
            };

            public VirtualAttribute [] docTypeNodeAttributes = {
                new VirtualAttribute( null, null ),
                new VirtualAttribute( null, null )
            };

            public bool bOnAttrVal;

            public XmlNodeReaderNavigator( XmlNode node ) {
                curNode = node;
                tempNode = node;
                logNode = node;
                XmlNodeType nt = curNode.NodeType;
                if ( nt == XmlNodeType.Attribute ) {
                    elemNode = null;
                    _attrIndex = -1;
                    bCreatedOnAttribute = true;
                }
                else {
                    elemNode = node;
                    _attrIndex = -1;
                    bCreatedOnAttribute = false;
                }
                //presave this for pref reason since it shouldn't change.
                if ( nt == XmlNodeType.Document )
                    this.doc = (XmlDocument)curNode;
                else
                    this.doc = node.OwnerDocument;
                this.nameTable = doc.NameTable;
                this.nAttrInd = -1;
                //initialize the caching variables
                this.nDeclarationAttrCount = -1;
                this.nDocTypeAttrCount = -1;
                this.bOnAttrVal = false;
                this.bLogOnAttrVal = false;
            }

            public XmlNodeType NodeType {
                get {
                    XmlNodeType nt = curNode.NodeType;
                    if ( nAttrInd != -1 ) {
                        Debug.Assert( nt == XmlNodeType.XmlDeclaration || nt == XmlNodeType.DocumentType );
                        if ( this.bOnAttrVal )
                            return XmlNodeType.Text;
                        else
                            return XmlNodeType.Attribute;
                    }
                    return nt;
                }
            }

            public String NamespaceURI {
                get { return curNode.NamespaceURI; }
            }

            public String Name {
                get {
                    if ( nAttrInd != -1 ) {
                        Debug.Assert( curNode.NodeType == XmlNodeType.XmlDeclaration || curNode.NodeType == XmlNodeType.DocumentType );
                        if ( this.bOnAttrVal )
                            return String.Empty; //Text node's name is String.Empty
                        else {
                            Debug.Assert( nAttrInd >= 0 && nAttrInd < AttributeCount );
                            if ( curNode.NodeType == XmlNodeType.XmlDeclaration )
                                return decNodeAttributes[nAttrInd].name;
                            else
                                return docTypeNodeAttributes[nAttrInd].name;
                        }
                    }
                    if ( IsLocalNameEmpty ( curNode.NodeType ) )
                        return String.Empty;
                    return curNode.Name;
                }
            }

            public String LocalName {
                get {
                    if ( nAttrInd != -1 )
                        //for the nodes in this case, their LocalName should be the same as their name
                        return Name;
                    if ( IsLocalNameEmpty( curNode.NodeType ))
                        return String.Empty;
                    return curNode.LocalName;
                }
            }

            internal bool IsOnAttrVal {
                get {
                    return this.bOnAttrVal;
                }
            }

            internal XmlNode OwnerElementNode {
                get {
                    if( this.bCreatedOnAttribute )
                        return null;
                    return  this.elemNode;
                }
            }

            internal bool CreatedOnAttribute {
                get {
                    return  this.bCreatedOnAttribute;
                }
            }

            private bool IsLocalNameEmpty ( XmlNodeType nt) {
                switch ( nt ) {
                    case XmlNodeType.None :
                    case XmlNodeType.Text :
                    case XmlNodeType.CDATA :
                    case XmlNodeType.Comment :
                    case XmlNodeType.Document :
                    case XmlNodeType.DocumentFragment :
                    case XmlNodeType.Whitespace :
                    case XmlNodeType.SignificantWhitespace :
                    case XmlNodeType.EndElement :
                    case XmlNodeType.EndEntity :
                        return true;
                    case XmlNodeType.Element :
                    case XmlNodeType.Attribute :
                    case XmlNodeType.EntityReference :
                    case XmlNodeType.Entity :
                    case XmlNodeType.ProcessingInstruction :
                    case XmlNodeType.DocumentType :
                    case XmlNodeType.Notation :
                    case XmlNodeType.XmlDeclaration :
                        return false;
                    default :
                        return true;
                }
            }

            public String Prefix {
                get { return curNode.Prefix; }
            }

            public bool HasValue {
                //In DOM, DocumentType node and XmlDeclaration node doesn't value
                //In XmlNavigator, XmlDeclaration node's value is its InnerText; DocumentType doesn't have value
                //In XmlReader, DocumentType node's value is its InternalSubset which is never null ( at least String.Empty )
                get {
                    if ( nAttrInd != -1 ) {
                        //Pointing at the one of virtual attributes of Declaration or DocumentType nodes
                        Debug.Assert( curNode.NodeType == XmlNodeType.XmlDeclaration || curNode.NodeType == XmlNodeType.DocumentType );
                        Debug.Assert( nAttrInd >= 0 && nAttrInd < AttributeCount );
                        return true;
                    }
                    if ( curNode.Value != null || curNode.NodeType == XmlNodeType.DocumentType )
                        return true;
                    return false;
                }
            }

            public String Value {
                //See comments in HasValue
                get {
                    String retValue = null;
                    XmlNodeType nt = curNode.NodeType;
                    if ( nAttrInd != -1 ) {
                        //Pointing at the one of virtual attributes of Declaration or DocumentType nodes
                        Debug.Assert( nt == XmlNodeType.XmlDeclaration || nt == XmlNodeType.DocumentType );
                        Debug.Assert( nAttrInd >= 0 && nAttrInd < AttributeCount );
                        if ( curNode.NodeType == XmlNodeType.XmlDeclaration )
                            return decNodeAttributes[nAttrInd].value;
                        else
                            return docTypeNodeAttributes[nAttrInd].value;
                    }
                    if ( nt == XmlNodeType.DocumentType )
                        retValue = ((XmlDocumentType)curNode).InternalSubset; //in this case nav.Value will be null
                    else if ( nt == XmlNodeType.XmlDeclaration ) {
                        StringBuilder strb = new StringBuilder(String.Empty);
                        if ( nDeclarationAttrCount == -1 )
                            InitDecAttr();
                        for ( int i = 0; i < nDeclarationAttrCount; i++ ) {
                            strb.Append(decNodeAttributes[i].name + "=\"" +decNodeAttributes[i].value + "\"");
                            if( i != ( nDeclarationAttrCount-1 ) )
                                strb.Append( " " );
                        }
                        retValue = strb.ToString();
                    } else
                        retValue = curNode.Value;
                    return ( retValue == null )? String.Empty : retValue;
                }
            }

            public String BaseURI {
                get { return curNode.BaseURI; }
            }

            public XmlSpace XmlSpace {
                get { return curNode.XmlSpace; }
            }

            public String XmlLang {
                get { return curNode.XmlLang; }
            }

            public bool IsEmptyElement {
                get {
                    if (curNode.NodeType == XmlNodeType.Element) {
                        return((XmlElement)curNode).IsEmpty;
                    }
                    return false;
                }
            }

            public bool IsDefault {
                get {
                    if (curNode.NodeType == XmlNodeType.Attribute) {
                        return !((XmlAttribute)curNode).Specified;
                    }
                    return false;
                }
            }

            public XmlNameTable NameTable {
                get { return nameTable; }
            }

            public int AttributeCount {
                get {
                    if( this.bCreatedOnAttribute )
                        return 0;
                    XmlNodeType nt = curNode.NodeType;
                    if ( nt == XmlNodeType.Element )
                        return ((XmlElement)curNode).Attributes.Count;
                    else if ( nt == XmlNodeType.Attribute
                            || ( this.bOnAttrVal && nt != XmlNodeType.XmlDeclaration && nt != XmlNodeType.DocumentType ) )
                        return elemNode.Attributes.Count;
                    else if ( nt == XmlNodeType.XmlDeclaration ) {
                        if ( nDeclarationAttrCount != -1 )
                            return nDeclarationAttrCount;
                        InitDecAttr();
                        return nDeclarationAttrCount;
                    } else if ( nt == XmlNodeType.DocumentType ) {
                        if ( nDocTypeAttrCount != -1 )
                            return nDocTypeAttrCount;
                        InitDocTypeAttr();
                        return nDocTypeAttrCount;
                    }
                    return 0;
                }
            }

            private String WriteAttributeContent( String prefix, String localName, String ns, String value, bool bMarkup ) {
                StringWriter sw = new StringWriter();
                XmlDOMTextWriter xw = new XmlDOMTextWriter( sw );
                if ( bMarkup )
                    xw.WriteStartAttribute( prefix, localName, ns );
                xw.WriteString( value );
                if ( bMarkup )
                    xw.WriteEndAttribute();
                xw.Close();
                return sw.ToString();
            }

            //What does the spec says about the innerxml and outerxml for virtual attributes for
            //  XmlDeclaration and DocumentType nodes
            public String InnerXml {
                get {
                    XmlNodeType nt = curNode.NodeType;
                    if ( nAttrInd != -1 ) {
                        if ( nt == XmlNodeType.XmlDeclaration )
                            return decNodeAttributes[nAttrInd].value;
                        else if ( nt == XmlNodeType.DocumentType )
                            return docTypeNodeAttributes[nAttrInd].value;
                    }
                    return curNode.InnerXml;
                }
            }

            public String OuterXml {
                get {
                    XmlNodeType nt = curNode.NodeType;
                    if ( nAttrInd != -1 ) {
                        if ( nt == XmlNodeType.XmlDeclaration )
                            return WriteAttributeContent( String.Empty, decNodeAttributes[nAttrInd].name, String.Empty, decNodeAttributes[nAttrInd].value, true );
                        else if ( nt == XmlNodeType.DocumentType )
                            return WriteAttributeContent( String.Empty, docTypeNodeAttributes[nAttrInd].name, String.Empty, docTypeNodeAttributes[nAttrInd].value, true );
                    }
                    return curNode.OuterXml;
                }
            }

            private void CheckIndexCondition(int attributeIndex) {
                if (attributeIndex < 0 || attributeIndex >= AttributeCount) {
                    throw new ArgumentOutOfRangeException( "attributeIndex" );
                }
            }

            //8 functions below are the helper functions to deal with virtual attributes of XmlDeclaration nodes and DocumentType nodes.
            private void InitDecAttr() {
                int i = 0;
                String strTemp = doc.Version;
                if ( strTemp != null && strTemp != String.Empty ) {
                    decNodeAttributes[i].name = strVersion;
                    decNodeAttributes[i].value = strTemp;
                    i++;
                }
                strTemp = doc.Encoding;
                if ( strTemp != null && strTemp != String.Empty ) {
                    decNodeAttributes[i].name = strEncoding;
                    decNodeAttributes[i].value = strTemp;
                    i++;
                }
                strTemp = doc.Standalone;
                if ( strTemp != null && strTemp != String.Empty ) {
                    decNodeAttributes[i].name = strStandalone;
                    decNodeAttributes[i].value = strTemp;
                    i++;
                }
                nDeclarationAttrCount = i;
            }

            public String GetDeclarationAttr( XmlDeclaration decl, String name ) {
                //PreCondition: curNode is pointing at Declaration node or one of its virtual attributes
                if ( name == strVersion )
                    return decl.Version;
                if ( name == strEncoding )
                    return decl.Encoding;
                if ( name == strStandalone )
                    return decl.Standalone;
                return null;
            }

            public String GetDeclarationAttr( int i ) {
                if ( nDeclarationAttrCount == -1 )
                    InitDecAttr();
                return decNodeAttributes[i].value;
            }

            public int GetDecAttrInd( String name ) {
                if ( nDeclarationAttrCount == -1 )
                    InitDecAttr();
                for ( int i = 0 ; i < nDeclarationAttrCount; i++ ) {
                    if ( decNodeAttributes[i].name == name )
                        return i;
                }
                return -1;
            }

            private void InitDocTypeAttr() {
                int i = 0;
                XmlDocumentType docType = doc.DocumentType;
                if ( docType == null ) {
                    nDocTypeAttrCount = 0;
                    return;
                }
                String strTemp = docType.PublicId;
                if ( strTemp != null ) {
                    docTypeNodeAttributes[i].name = strPublicID;
                    docTypeNodeAttributes[i].value = strTemp;
                    i++;
                }
                strTemp = docType.SystemId;
                if ( strTemp != null ) {
                    docTypeNodeAttributes[i].name = strSystemID;
                    docTypeNodeAttributes[i].value = strTemp;
                    i++;
                }
                nDocTypeAttrCount = i;
            }

            public String GetDocumentTypeAttr ( XmlDocumentType docType, String name ) {
                //PreCondition: nav is pointing at DocumentType node or one of its virtual attributes
                if ( name == strPublicID )
                    return docType.PublicId;
                if ( name == strSystemID )
                    return docType.SystemId;
                return null;
            }

            public String GetDocumentTypeAttr( int i ) {
                if ( nDocTypeAttrCount == -1 )
                    InitDocTypeAttr();
                return docTypeNodeAttributes[i].value;
            }

            public int GetDocTypeAttrInd( String name ) {
                if ( nDocTypeAttrCount == -1 )
                    InitDocTypeAttr();
                for ( int i = 0 ; i < nDocTypeAttrCount; i++ ) {
                    if ( docTypeNodeAttributes[i].name == name )
                        return i;
                }
                return -1;
            }

            private String GetAttributeFromElement( XmlElement elem, String name ) {
                XmlAttribute attr = elem.GetAttributeNode( name );
                if ( attr != null )
                    return attr.Value;
                return null;
            }

            public String GetAttribute( String name ) {
                if( this.bCreatedOnAttribute )
                    return null;
                switch ( curNode.NodeType ) {
                    case XmlNodeType.Element:
                        return GetAttributeFromElement((XmlElement)curNode, name);
                    case XmlNodeType.Attribute :
                        return GetAttributeFromElement((XmlElement)elemNode, name);
                    case XmlNodeType.XmlDeclaration:
                        return GetDeclarationAttr( (XmlDeclaration)curNode, name );
                    case XmlNodeType.DocumentType:
                        return GetDocumentTypeAttr( (XmlDocumentType)curNode, name );
                }
                return null;
            }

            private String GetAttributeFromElement( XmlElement elem, String name, String ns ) {
                XmlAttribute attr = elem.GetAttributeNode( name, ns );
                if ( attr != null )
                    return attr.Value;
                return null;
            }
            public String GetAttribute( String name, String ns ) {
                if( this.bCreatedOnAttribute )
                    return null;
                switch ( curNode.NodeType ) {
                    case XmlNodeType.Element:
                        return GetAttributeFromElement((XmlElement)curNode, name, ns);
                    case XmlNodeType.Attribute :
                        return GetAttributeFromElement((XmlElement)elemNode, name, ns);
                    case XmlNodeType.XmlDeclaration:
                        return (ns == String.Empty) ? GetDeclarationAttr( (XmlDeclaration)curNode, name ) : null;
                    case XmlNodeType.DocumentType:
                        return (ns == String.Empty) ? GetDocumentTypeAttr( (XmlDocumentType)curNode, name ) : null;
                }
                return null;
            }

            public String GetAttribute( int attributeIndex ) {
                if( this.bCreatedOnAttribute )
                    return null;
                switch ( curNode.NodeType ) {
                    case XmlNodeType.Element:
                        CheckIndexCondition( attributeIndex );
                        return ((XmlElement)curNode).Attributes[attributeIndex].Value;
                    case XmlNodeType.Attribute :
                        CheckIndexCondition( attributeIndex );
                        return ((XmlElement)elemNode).Attributes[attributeIndex].Value;
                    case XmlNodeType.XmlDeclaration: {
                        CheckIndexCondition( attributeIndex );
                        return GetDeclarationAttr( attributeIndex );
                    }
                    case XmlNodeType.DocumentType: {
                        CheckIndexCondition( attributeIndex );
                        return GetDocumentTypeAttr( attributeIndex );
                    }
                }
                throw new ArgumentOutOfRangeException( "attributeIndex" ); //for other senario, AttributeCount is 0, i has to be out of range
            }

            public void LogMove( int level ) {
                logNode = curNode;
                nLogLevel = level;
                nLogAttrInd = nAttrInd;
                logAttrIndex = _attrIndex;
                this.bLogOnAttrVal = this.bOnAttrVal;
            }

            //The function has to be used in pair with ResetMove when the operation fails after LogMove() is
            //    called because it relies on the values of nOrigLevel, logNav and nOrigAttrInd to be acurate.
            public void RollBackMove( ref int level ) {
                curNode = logNode;
                level = nLogLevel;
                nAttrInd = nLogAttrInd;
                _attrIndex = logAttrIndex;
                this.bOnAttrVal = this.bLogOnAttrVal;
             }

            private bool IsOnDeclOrDocType {
                get {
                    XmlNodeType nt = curNode.NodeType;
                    return ( nt == XmlNodeType.XmlDeclaration || nt == XmlNodeType.DocumentType );
                }
            }

            public void ResetToAttribute( ref int level ) {
                //the current cursor is pointing at one of the attribute children -- this could be caused by
                //  the calls to ReadAttributeValue(..)
                if( this.bCreatedOnAttribute )
                    return;
                if ( this.bOnAttrVal ) {
                    if ( IsOnDeclOrDocType ) {
                        level-=2;
                    } else {
                        while ( curNode.NodeType != XmlNodeType.Attribute && ( ( curNode = curNode.ParentNode ) != null ) )
                            level-- ;
                    }
                    this.bOnAttrVal = false;
                }
            }

            public void ResetMove( ref int level, ref XmlNodeType nt ) {
                LogMove( level );
                if( this.bCreatedOnAttribute )
                    return;
                if ( nAttrInd != -1 ) {
                    Debug.Assert( IsOnDeclOrDocType );
                    if ( this.bOnAttrVal ) {
                        level--;
                        this.bOnAttrVal = false;
                    }
                    nLogAttrInd = nAttrInd;
                    level--;
                    nAttrInd = -1;
                    nt = curNode.NodeType;
                    return;
                }
                if ( this.bOnAttrVal && curNode.NodeType != XmlNodeType.Attribute )
                    ResetToAttribute( ref level );
                if ( curNode.NodeType == XmlNodeType.Attribute ) {
                    curNode = ((XmlAttribute)curNode).OwnerElement;
                    _attrIndex = -1;
                    level--;
                    nt = XmlNodeType.Element;
                }
                if ( curNode.NodeType == XmlNodeType.Element )
                    elemNode = curNode;
            }

            public bool MoveToAttribute( string name ) {
                return MoveToAttribute( name, string.Empty );
            }
            private bool MoveToAttributeFromElement( XmlElement elem, String name, String ns ) {
                XmlAttribute attr = null;
                if( ns == String.Empty )
                    attr = elem.GetAttributeNode( name );
                else
                    attr = elem.GetAttributeNode( name, ns );
                if ( attr != null ) {
                    this.bOnAttrVal = false;
                    elemNode = elem;
                    curNode = (XmlNode) attr;
                    _attrIndex = getAttributeIndex( name, elem );
                    return true;
                }
                return false;
            }

            public bool MoveToAttribute( string name, string namespaceURI ) {
                if( this.bCreatedOnAttribute )
                    return false;
                XmlNodeType nt = curNode.NodeType;
                if ( nt == XmlNodeType.Element )
                    return MoveToAttributeFromElement((XmlElement)curNode, name, namespaceURI );
                else if ( nt == XmlNodeType.Attribute )
                    return MoveToAttributeFromElement((XmlElement)elemNode, name, namespaceURI );
                else if (  nt == XmlNodeType.XmlDeclaration && namespaceURI == String.Empty ) {
                    if ( ( nAttrInd = GetDecAttrInd( name ) ) != -1 ) {
                        this.bOnAttrVal = false;
                        return true;
                    }
                } else if ( nt == XmlNodeType.DocumentType && namespaceURI == String.Empty ) {
                    if ( ( nAttrInd = GetDocTypeAttrInd( name ) ) != -1 ) {
                        this.bOnAttrVal = false;
                        return true;
                    }
                }
                return false;
            }

            public void MoveToAttribute( int attributeIndex ) {
                if( this.bCreatedOnAttribute )
                    return;
                XmlAttribute attr = null;
                switch ( curNode.NodeType ) {
                    case XmlNodeType.Element:
                        CheckIndexCondition( attributeIndex );
                        attr = ((XmlElement)curNode).Attributes[attributeIndex];
                        if ( attr != null ) {
                            elemNode = curNode;
                            curNode = (XmlNode) attr;
                            _attrIndex = attributeIndex;
                        }
                        break;
                    case XmlNodeType.Attribute:
                        CheckIndexCondition( attributeIndex );
                        attr = ((XmlElement)elemNode).Attributes[attributeIndex];
                        if ( attr != null ) {
                            curNode = (XmlNode) attr;
                            _attrIndex = attributeIndex;
                        }
                        break;
                    case XmlNodeType.XmlDeclaration :
                    case XmlNodeType.DocumentType :
                        CheckIndexCondition( attributeIndex );
                        nAttrInd = attributeIndex;
                        break;
                }
            }

            private int getAttributeIndex( string name, XmlElement elemNode ) {
                int i = 0;
                if ( elemNode != null ) {
                    foreach ( XmlAttribute at in elemNode.Attributes ) {
                        if ( name == at.Name )
                            return i;
                        else
                            i++;
                    }
                }
                return -1;
            }

            public bool MoveToNextAttribute( ref int level ) {
                if( this.bCreatedOnAttribute )
                        return false;
                XmlNodeType nt = curNode.NodeType;
                if ( nt == XmlNodeType.Attribute ) {
                    if( _attrIndex >= ( elemNode.Attributes.Count-1 ) )
                        return false;
                    else {
                        curNode = elemNode.Attributes[++_attrIndex];
                        return true;
                    }
                } else if ( nt == XmlNodeType.Element ) {
                    if ( curNode.Attributes.Count > 0 ) {
                        level++;
                        elemNode = curNode;
                        curNode = curNode.Attributes[0];
                        _attrIndex = 0;
                        return true;
                    }
                } else if ( nt == XmlNodeType.XmlDeclaration ) {
                    if ( nDeclarationAttrCount == -1 )
                        InitDecAttr();
                    nAttrInd++;
                    if ( nAttrInd < nDeclarationAttrCount ) {
                        if ( nAttrInd == 0 ) level++;
                        this.bOnAttrVal = false;
                        return true;
                    }
                    nAttrInd--;
                } else if ( nt == XmlNodeType.DocumentType ) {
                    if ( nDocTypeAttrCount == -1 )
                        InitDocTypeAttr();
                    nAttrInd++;
                    if ( nAttrInd < nDocTypeAttrCount ) {
                        if ( nAttrInd == 0 ) level++;
                        this.bOnAttrVal = false;
                        return true;
                    }
                    nAttrInd--;
                }
                return false;
            }

            public bool MoveToParent() {
                XmlNode parent = curNode.ParentNode;
                if ( parent != null ) {
                    curNode = parent;
                    if( !bOnAttrVal )
                        _attrIndex = 0;
                    return true;
                }
                return false;
            }

            public bool MoveToFirstChild() {
                XmlNode firstChild = curNode.FirstChild;
                if ( firstChild != null ) {
                    curNode = firstChild;
                    if( !bOnAttrVal )
                        _attrIndex = -1;
                    return true;
                }
                return false;
            }

            private bool MoveToNextSibling( XmlNode node ) {
                XmlNode nextSibling = node.NextSibling;
                if ( nextSibling != null ) {
                    curNode = nextSibling;
                    if( !bOnAttrVal )
                        _attrIndex = -1;
                    return true;
                }
                return false;
            }

            public bool MoveToNext() {
                if ( curNode.NodeType != XmlNodeType.Attribute )
                    return MoveToNextSibling( curNode );
                else
                    return MoveToNextSibling( elemNode );
            }

            public bool MoveToElement() {
                if( this.bCreatedOnAttribute )
                    return false;
                switch ( curNode.NodeType ) {
                    case XmlNodeType.Attribute :
                        if ( elemNode != null ) {
                            curNode = elemNode;
                            _attrIndex = -1;
                            return true;
                        }
                        break;
                    case XmlNodeType.XmlDeclaration :
                    case XmlNodeType.DocumentType : {
                        if ( nAttrInd != -1 ) {
                            nAttrInd = -1;
                            return true;
                        }
                        break;
                    }
                }
                return false;
            }

            public String LookupNamespace(string prefix) {
                if( this.bCreatedOnAttribute )
                    return null;
                XmlAttribute tempAttr = null;
                XmlElement tempElem = null;
                tempNode = curNode;
                do {
                    if ( tempNode.NodeType == XmlNodeType.Attribute )
                        tempNode = ((XmlAttribute)tempNode).OwnerElement;
                    if ( tempNode.NodeType == XmlNodeType.Element ) {
                        tempElem = (XmlElement)tempNode;
                        if ( prefix == String.Empty )
                            tempAttr = tempElem.GetAttributeNode( "xmlns" );
                        else
                            tempAttr = tempElem.GetAttributeNode("xmlns:" + prefix);
                        if ( tempAttr != null )
                            return tempAttr.Value;
                    }
                    tempNode = tempNode.ParentNode;
                } while ( tempNode != null );
                return null;
            }

            public bool ReadAttributeValue( ref int level, ref bool bResolveEntity, ref XmlNodeType nt ) {
                if ( nAttrInd != -1 ) {
                    Debug.Assert( curNode.NodeType == XmlNodeType.XmlDeclaration || curNode.NodeType == XmlNodeType.DocumentType );
                    if ( !this.bOnAttrVal ) {
                        this.bOnAttrVal = true;
                        level++;
                        nt = XmlNodeType.Text;
                        return true;
                    }
                    return false;
                }
                if( curNode.NodeType == XmlNodeType.Attribute ) {
                    XmlNode firstChild = curNode.FirstChild;
                    if ( firstChild != null ) {
                        curNode = firstChild;
                        nt = curNode.NodeType;
                        level++;
                        this.bOnAttrVal = true;
                        return true;
                    }
                }
                else if ( this.bOnAttrVal ) {
                    XmlNode nextSibling = null;
                    if ( curNode.NodeType == XmlNodeType.EntityReference && bResolveEntity ) {
                        //going down to ent ref node
                        curNode = curNode.FirstChild;
                        nt = curNode.NodeType;
                        Debug.Assert( curNode != null );
                        level++;
                        bResolveEntity = false;
                        return true;
                    }
                    else
                        nextSibling = curNode.NextSibling;
                    if ( nextSibling == null ) {
                        XmlNode parentNode = curNode.ParentNode;
                        //Check if its parent is entity ref node is sufficient, because in this senario, ent ref node can't have more than 1 level of children that are not other ent ref nodes
                        if ( parentNode != null && parentNode.NodeType == XmlNodeType.EntityReference ) {
                            //come back from ent ref node
                            curNode = parentNode;
                            nt = XmlNodeType.EndEntity;
                            level--;
                            return true;
                        }
                    }
                    if ( nextSibling != null ) {
                        curNode = nextSibling;
                        nt = curNode.NodeType;
                        return true;
                    }
                    else
                        return false;
                }
                return false;
            }

    }

    /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader"]/*' />
    /// <devdoc>
    ///    <para>Represents a reader that provides fast, non-cached forward only stream access
    ///       to XML data in an XmlDocument or a specific XmlNode within an XmlDocument.</para>
    /// </devdoc>
    public class XmlNodeReader: XmlReader
    {
        XmlNodeReaderNavigator  readerNav;
        private const char      chQuote = (char) 0x22;
        private const char      chSingleQuote = (char) 0x27;

        XmlNodeType             nodeType;   // nodeType of the node that the reader is currently positioned on
        int                     curDepth;   // depth of attrNav ( also functions as reader's depth )
        ReadState               readState;  // current reader's state
        bool                    fEOF;       // flag to show if reaches the end of file
        internal const String   strReservedXmlns = "http://www.w3.org/2000/xmlns/";
        //mark to the state that EntityReference node is supposed to be resolved
        bool                    bResolveEntity;
        bool                    bStartFromDocument;


        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.XmlNodeReader"]/*' />
        /// <devdoc>
        ///    <para>Creates an instance of the XmlNodeReader class using the specified
        ///       XmlNavigator.</para>
        /// </devdoc>
        public XmlNodeReader ( XmlNode node ) {
            Init( node );
        }

        private void Init( XmlNode node ) {
            readerNav = new XmlNodeReaderNavigator( node );
            this.curDepth = 0;

            readState = ReadState.Initial;
            fEOF = false;
            nodeType = XmlNodeType.None;
            bResolveEntity = false;
            bStartFromDocument = false;
        }

        //function returns if the reader currently in valid reading states
        internal bool IsInReadingStates() {
            return ( readState == ReadState.Interactive ); // || readState == ReadState.EndOfFile
        }

        /*
        //function filter out the return string considering if the reader is in reading states or not;
        //if not, return string.Empty
        internal string RetStrWithinReadingStates( string str ) {
            if ( IsInReadingStates() )
                return str;
            return string.Empty;
        }

        //function filter out the return bool considering if the reader is in reading states or not;
        //if not, return false as default
        internal bool RetBoolWithinReadingStates( bool b ) {
            if ( IsInReadingStates() )
                return b;
            return false;
        }
        */

        // Node Properties
        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType {
            get { return ( IsInReadingStates() )? nodeType : XmlNodeType.None; }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.Name"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of
        ///       the current node, including the namespace prefix.</para>
        /// </devdoc>
        public override string Name {
            get {
                if ( !IsInReadingStates() )
                    return String.Empty;
                return readerNav.Name;
            }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the current node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override string LocalName {
            get {
                if ( !IsInReadingStates() )
                    return String.Empty;
                return readerNav.LocalName;
            }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.NamespaceURI"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the namespace URN (as defined in the W3C Namespace Specification) of the current namespace scope.
        ///    </para>
        /// </devdoc>
        public override string NamespaceURI {
            get {
                if ( !IsInReadingStates() )
                    return String.Empty;
                return readerNav.NamespaceURI;
            }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.Prefix"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the namespace prefix associated with the current node.
        ///    </para>
        /// </devdoc>
        public override string Prefix {
            get {
                if ( !IsInReadingStates() )
                    return String.Empty;
                return readerNav.Prefix;
            }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.HasValue"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether
        ///    <see cref='System.Xml.XmlNodeReader.Value'/> has a value to return.</para>
        /// </devdoc>
        public override bool HasValue {
            get {
                if ( !IsInReadingStates() )
                    return false;
                return readerNav.HasValue;
            }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the text value of the current node.
        ///    </para>
        /// </devdoc>
        public override string Value {
            get {
                if ( !IsInReadingStates() )
                    return String.Empty;
                return readerNav.Value;
            }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.Depth"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the depth of the
        ///       current node in the XML element stack.
        ///    </para>
        /// </devdoc>
        public override int Depth {
            get { return curDepth; }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.BaseURI"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the base URI of the current node.
        ///    </para>
        /// </devdoc>
        public override String BaseURI {
            get { return readerNav.BaseURI; }
        }

        //UE Atention
        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.CanResolveEntity"]/*' />
        public override bool CanResolveEntity {
            get { return true; }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.IsEmptyElement"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether
        ///       the current
        ///       node is an empty element (for example, &lt;MyElement/&gt;).</para>
        /// </devdoc>
        public override bool IsEmptyElement {
            get {
                if ( !IsInReadingStates() )
                    return false;
                return readerNav.IsEmptyElement;
            }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.IsDefault"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the current node is an
        ///       attribute that was generated from the default value defined
        ///       in the DTD or schema.
        ///    </para>
        /// </devdoc>
        public override bool IsDefault {
            get {
                if ( !IsInReadingStates() )
                    return false;
                return readerNav.IsDefault;
            }
        }

        // Return whatever we can find in the attribute value, otherwise returns "
        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.QuoteChar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the quotation mark character used to enclose the value of an attribute
        ///       node.
        ///    </para>
        /// </devdoc>
        public override char QuoteChar {
            get { return chQuote; }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.XmlSpace"]/*' />
        /// <devdoc>
        ///    <para>Gets the current xml:space scope.</para>
        /// </devdoc>
        public override XmlSpace XmlSpace {
            get {
                if ( !IsInReadingStates() )
                    return XmlSpace.None;
                return readerNav.XmlSpace;
            }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.XmlLang"]/*' />
        /// <devdoc>
        ///    <para>Gets the current xml:lang scope.</para>
        /// </devdoc>
        public override string XmlLang {
            // Assume everything is in Unicode
            get {
                if ( !IsInReadingStates() )
                    return String.Empty;
                return readerNav.XmlLang;
            }
        }

        // Attribute Accessors

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.AttributeCount"]/*' />
        /// <devdoc>
        ///    <para>Gets the number of attributes on the current node.</para>
        /// </devdoc>
        public override int AttributeCount {
            get {
                if ( !IsInReadingStates() || nodeType == XmlNodeType.EndElement )
                    return 0;
                return readerNav.AttributeCount;
            }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.GetAttribute"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified name.</para>
        /// </devdoc>
        public override string GetAttribute(string name) {
            //if not on Attribute, only element node could have attributes
            if ( !IsInReadingStates() )
                return null;
            return readerNav.GetAttribute( name );
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.GetAttribute1"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified name and namespace.</para>
        /// </devdoc>
        public override string GetAttribute(string name, string namespaceURI) {
            //if not on Attribute, only element node could have attributes
            if ( !IsInReadingStates() )
                return null;
            String ns = ( namespaceURI == null ) ? String.Empty : namespaceURI;
            return readerNav.GetAttribute( name, ns );
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.GetAttribute2"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified index.</para>
        /// </devdoc>
        public override string GetAttribute(int attributeIndex) {
            if ( !IsInReadingStates() )
                throw new ArgumentOutOfRangeException( "attributeIndex" );
            //CheckIndexCondition( i );
            //Debug.Assert( nav.NodeType == XmlNodeType.Element );
            return readerNav.GetAttribute( attributeIndex );
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.MoveToAttribute"]/*' />
        /// <devdoc>
        ///    <para>Moves to the attribute with the specified name.</para>
        /// </devdoc>
        public override bool MoveToAttribute(string name) {
            if ( !IsInReadingStates() )
                return false;
            readerNav.ResetMove( ref curDepth, ref nodeType );
            if ( readerNav.MoveToAttribute( name ) ) { //, ref curDepth ) ) {
                curDepth++;
                nodeType = readerNav.NodeType;
                return true;
            }
            readerNav.RollBackMove(ref curDepth);
            return false;
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.MoveToAttribute1"]/*' />
        /// <devdoc>
        ///    <para>Moves to the attribute with the specified name and namespace.</para>
        /// </devdoc>
        public override bool MoveToAttribute(string name, string namespaceURI) {
            if ( !IsInReadingStates() )
                return false;
            readerNav.ResetMove( ref curDepth, ref nodeType );
            String ns = ( namespaceURI == null ) ? String.Empty : namespaceURI;
            if ( readerNav.MoveToAttribute( name,  ns ) ) { //, ref curDepth ) ) {
                curDepth++;
                nodeType = readerNav.NodeType;
                return true;
            }
            readerNav.RollBackMove(ref curDepth);
            return false;
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.MoveToAttribute2"]/*' />
        /// <devdoc>
        ///    <para>Moves to the attribute with the specified index.</para>
        /// </devdoc>
        public override void MoveToAttribute(int attributeIndex) {
            if ( !IsInReadingStates() )
                throw new ArgumentOutOfRangeException( "attributeIndex" );
            readerNav.ResetMove( ref curDepth, ref nodeType );
            try {
                if (AttributeCount > 0) {
                    readerNav.MoveToAttribute( attributeIndex );
                }
                else
                throw new ArgumentOutOfRangeException( "attributeIndex" );
            } catch ( Exception e ) {
                readerNav.RollBackMove(ref curDepth);
                throw e;
            }
            curDepth++;
            nodeType = readerNav.NodeType;
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.MoveToFirstAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Moves to the first attribute.
        ///    </para>
        /// </devdoc>
        public override bool MoveToFirstAttribute() {
            if ( !IsInReadingStates() )
                return false;
            readerNav.ResetMove( ref curDepth, ref nodeType );
            if (AttributeCount > 0) {
                readerNav.MoveToAttribute( 0 );
                curDepth++;
                nodeType = readerNav.NodeType;
                return true;
            }
            readerNav.RollBackMove( ref curDepth );
            return false;
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.MoveToNextAttribute"]/*' />
        /// <devdoc>
        ///    <para>Moves to the next attribute.</para>
        /// </devdoc>
        public override bool MoveToNextAttribute() {
            if ( !IsInReadingStates() || nodeType == XmlNodeType.EndElement )
                return false;
            readerNav.LogMove( curDepth );
            readerNav.ResetToAttribute( ref curDepth );
            if ( readerNav.MoveToNextAttribute( ref curDepth ) ) {
                nodeType = readerNav.NodeType;
                return true;
            }
            readerNav.RollBackMove( ref curDepth );
            return false;
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.MoveToElement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Moves to the element that contains the current attribute node.
        ///    </para>
        /// </devdoc>
        public override bool MoveToElement() {
            if ( !IsInReadingStates() )
                return false;
            readerNav.LogMove( curDepth );
            readerNav.ResetToAttribute( ref curDepth );
            if ( readerNav.MoveToElement() ) {
                curDepth--;
                nodeType = readerNav.NodeType;
                return true;
            }
            readerNav.RollBackMove( ref curDepth );
            return false;
        }

        // Moving through the Stream
        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.Read"]/*' />
        /// <devdoc>
        ///    <para>Reads the next
        ///       node from the stream.</para>
        /// </devdoc>
        public override bool Read() {
            return Read( false );
        }
        private bool Read( bool fSkipChildren ) {
            if( fEOF )
                return false;

            if ( readState == ReadState.Initial ) {
                // if nav is pointing at the document node, start with its children
                // otherwise,start with the node.
                if ( ( readerNav.NodeType == XmlNodeType.Document ) || ( readerNav.NodeType == XmlNodeType.DocumentFragment ) ) {
                    bStartFromDocument = true;
                    if ( !ReadNextNode(fSkipChildren) ) {
                        readState = ReadState.Error;
                        return false;
                    }
                }
                ReSetReadingMarks();
                readState = ReadState.Interactive;
                nodeType = readerNav.NodeType;
                //_depth = 0;
                curDepth = 0;
                return true;
            }

            bool bRead = false;
            if( ( readerNav.CreatedOnAttribute ) )
                return false;
            ReSetReadingMarks();
            bRead = ReadNextNode(fSkipChildren);
            if ( bRead ) {
                return true;
            } else {
                if ( readState == ReadState.Initial || readState == ReadState.Interactive )
                    readState = ReadState.Error;
                if ( readState == ReadState.EndOfFile )
                    nodeType = XmlNodeType.None;
                return false;
            }
        }

        private bool ReadNextNode( bool fSkipChildren ) {
            if ( readState != ReadState.Interactive && readState != ReadState.Initial ) {
                nodeType = XmlNodeType.None;
                return false;
            }

            bool bDrillDown = !fSkipChildren;
            XmlNodeType nt = readerNav.NodeType;
            //only goes down when nav.NodeType is of element or of document at the initial state, other nav.NodeType will not be parsed down
            //if nav.NodeType is of EntityReference, ResolveEntity() could be called to get the content parsed;
            bDrillDown = bDrillDown
                        && ( nodeType != XmlNodeType.EndElement )
                        && ( nodeType != XmlNodeType.EndEntity )
                        && ( nt == XmlNodeType.Element || ( nt == XmlNodeType.EntityReference && bResolveEntity ) ||
                            ( ( ( readerNav.NodeType == XmlNodeType.Document ) || ( readerNav.NodeType == XmlNodeType.DocumentFragment ) ) && readState == ReadState.Initial) );
            //first see if there are children of current node, so to move down
            if ( bDrillDown ) {
                if ( readerNav.MoveToFirstChild() ) {
                    nodeType = readerNav.NodeType;
                    curDepth++;
                    if ( bResolveEntity )
                        bResolveEntity = false;
                    return true;
                } else if ( readerNav.NodeType == XmlNodeType.Element
                            && !readerNav.IsEmptyElement ) {
                    nodeType = XmlNodeType.EndElement;
                    return true;
                }
                //entity reference node shall always have at least one child ( at least a text node with empty string )
                Debug.Assert( readerNav.NodeType != XmlNodeType.EntityReference );
                // if fails to move to it 1st Child, try to move to next below
                return ReadForward( fSkipChildren );
            } else {
                if ( readerNav.NodeType == XmlNodeType.EntityReference && bResolveEntity ) {
                    //The only way to get to here is because Skip() is called directly after ResolveEntity()
                    // in this case, user wants to skip the first Child of EntityRef node and fSkipChildren is true
                    // We want to pointing to the first child node.
                    readerNav.MoveToFirstChild(); //it has to succeeded
                    nodeType = readerNav.NodeType;
                    curDepth++;
                    bResolveEntity = false;
                    return true;
                }
            }
            return ReadForward( fSkipChildren );  //has to get the next node by moving forward
        }

        private void SetEndOfFile() {
            fEOF = true;
            readState = ReadState.EndOfFile;
            nodeType = XmlNodeType.None;
        }

        private bool ReadAtZeroLevel(bool fSkipChildren) {
            Debug.Assert( curDepth == 0 );
            if ( !fSkipChildren
                && nodeType != XmlNodeType.EndElement
                && readerNav.NodeType == XmlNodeType.Element
                && !readerNav.IsEmptyElement ) {
                nodeType = XmlNodeType.EndElement;
                return true;
            } else {
                SetEndOfFile();
                return false;
            }
        }

        private bool ReadForward( bool fSkipChildren ) {
            if ( readState == ReadState.Error )
                return false;

            /* spec was changed to not to put the pointer at the last text node but the next markup
            if ( chPointer != -1 && nav.NodeType == XmlNodeType.Text ) {
                //was in reading characters mode, has to position the reader to the last text node
                while ( nav.MoveToNext() && nav.NodeType == XmlNodeType.Text ) ;
                if ( nav.NodeType != XmlNodeType.Text )
                    nav.MoveToPrevious();
            }*/
            if ( !bStartFromDocument && curDepth == 0 ) {
                //already on top most node and we shouldn't move to next
                return ReadAtZeroLevel(fSkipChildren);
            }
            //else either we are not on top level or we are starting from the document at the very beginning in which case
            //  we will need to read all the "top" most nodes
            if ( readerNav.MoveToNext() ) {
                nodeType = readerNav.NodeType;
                return true;
            } else {
                //need to check its parent
                if ( curDepth == 0 )
                    return ReadAtZeroLevel(fSkipChildren);
                if ( readerNav.MoveToParent() ) {
                    if ( readerNav.NodeType == XmlNodeType.Element ) {
                        curDepth--;
                        nodeType = XmlNodeType.EndElement;
                        return true;
                    } else if ( readerNav.NodeType == XmlNodeType.EntityReference ) {
                        //coming back from entity reference node -- must be getting down through call ResolveEntity()
                        curDepth--;
                        nodeType = XmlNodeType.EndEntity;
                        return true;
                    }
                    return true;
                }
            }
            return false;
        }

        //the function reset the marks used for ReadChars() and MoveToAttribute(...), ReadAttributeValue(...)
        private void ReSetReadingMarks() {
            //_attrValInd = -1;
            readerNav.ResetMove( ref curDepth, ref nodeType );
            //attrNav.MoveTo( nav );
            //curDepth = _depth;
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.EOF"]/*' />
        /// <devdoc>
        ///    <para>Gets a
        ///       value indicating whether the reader is positioned at the end of the
        ///       stream.</para>
        /// </devdoc>
        public override bool EOF {
            get { return (readState != ReadState.Closed) && fEOF; }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.Close"]/*' />
        /// <devdoc>
        /// <para>Closes the stream, changes the <see cref='System.Xml.XmlNodeReader.ReadState'/>
        /// to Closed, and sets all the properties back to zero.</para>
        /// </devdoc>
        public override void Close() {
            readState = ReadState.Closed;
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.ReadState"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the read state of the stream.
        ///    </para>
        /// </devdoc>
        public override ReadState ReadState {
            get { return readState; }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.Skip"]/*' />
        /// <devdoc>
        ///    <para>Skips to the end tag of the current element.</para>
        /// </devdoc>
        public override void Skip() {
            Read( true );
        }

        
        //function move the navigator down to the text node of the current element node, if there is any; change the depth and attrNav as well
        //  1)construct the reading text once, starting the current node;
        //  2)adjust the reader's position to the last Text Node so that next Read() will have the right position
        //if not position on the text type node, no reading is done and no movement
        private string GetTextContent() {
            StringBuilder retstr = new StringBuilder();
            Boolean flag;
            do{
                flag = false;
                switch (this.NodeType) {
                    case XmlNodeType.CDATA:
                    case XmlNodeType.Text:
                    case XmlNodeType.Whitespace:
                    case XmlNodeType.SignificantWhitespace:
                        retstr.Append( this.Value );
                        if (! Read())
                            throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
                        flag = true;
                    break;
                }
            } while(flag);
            return retstr.ToString();
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.ReadString"]/*' />
        /// <devdoc>
        ///    <para>Reads the contents of an element as a string.</para>
        /// </devdoc>
	    public override string ReadString() {
		    if ((this.NodeType == XmlNodeType.EntityReference) && bResolveEntity) {
			    if (! this.Read()) {
                    		    throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
			    }
		    }
		    return base.ReadString();
	    }
	
        // Partial Content Read Methods
        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.HasAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the current node
        ///       has any attributes.
        ///    </para>
        /// </devdoc>
        public override bool HasAttributes {
            get {
                return ( AttributeCount > 0 );
            }
        }

        // Nametable and Namespace Helpers
        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.NameTable"]/*' />
        /// <devdoc>
        ///    <para>Gets the XmlNameTable associated with this
        ///       implementation.</para>
        /// </devdoc>
        public override XmlNameTable NameTable {
            get { return readerNav.NameTable; }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.LookupNamespace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resolves a namespace prefix in the current element's scope.
        ///    </para>
        /// </devdoc>
        public override String LookupNamespace(string prefix) {
            if ( !IsInReadingStates() )
                return null;
            if ( prefix == "xmlns" )
                return strReservedXmlns;
            return readerNav.LookupNamespace( prefix );
        }

        // Entity Handling
        // Entity Handling
        // <summary>
        //    <para>
        //       Gets or sets a value that specifies how the XmlReader handles entities.
        //    </para>
        // </summary>
        // <value>
        //    <para>
        //       One of the <see cref='System.Xml.EntityHandling'/> values.
        //    </para>
        // </value>
        // <exception cref='IndexOutOfRangeException'>
        //    Invalid value was specified.
        // </exception>
        // <remarks>
        //    <para>
        //       This property can be changed on the fly and the new behavior begins after the
        //       next <see cref='System.Xml.XmlTextReader.Read'/> call.
        //    </para>
        // </remarks>
        /*
        private EntityHandling EntityHandling {
            get { return entityHandlingFlag; }
            set { entityHandlingFlag = value; }
        }
        internal bool FExpandEntity() {
            if (entityHandlingFlag == EntityHandling.ExpandEntities)
                return true;

            return false;
        }

        internal bool FExpandCharEntity() {
            if (entityHandlingFlag == EntityHandling.ExpandCharEntities || entityHandlingFlag == EntityHandling.ExpandEntities)
                return true;

            return false;
        }*/

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.ResolveEntity"]/*' />
        /// <devdoc>
        ///    <para>Resolves the entity reference for nodes of NodeType EntityReference.</para>
        /// </devdoc>
        public override void ResolveEntity() {
            if ( !IsInReadingStates() || ( nodeType != XmlNodeType.EntityReference ) )
                throw new InvalidOperationException(Res.GetString(Res.Xnr_ResolveEntity));
            bResolveEntity = true;;
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.ReadAttributeValue"]/*' />
        /// <devdoc>
        ///    <para>Parses the attribute value into one or more Text and/or EntityReference node
        ///       types.</para>
        /// </devdoc>
        public override bool ReadAttributeValue() {
            if ( !IsInReadingStates() )
                return false;
            return readerNav.ReadAttributeValue( ref curDepth, ref bResolveEntity, ref nodeType );
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.this"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified index.</para>
        /// </devdoc>
        public override string this [ int i ] {
            get { return GetAttribute(i); }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.this1"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified name.</para>
        /// </devdoc>
        public override string this [ string name ] {
            get { return GetAttribute(name); }
        }

        /// <include file='doc\XmlNodeReader.uex' path='docs/doc[@for="XmlNodeReader.this2"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified name and namespace.</para>
        /// </devdoc>
        public override string this [ string name,string namespaceURI ] {
            get { return GetAttribute(name, namespaceURI); }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnodetype.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNodeType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Xml {
    /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType"]/*' />
    /// <devdoc>
    ///    Specifies the type of node.
    /// </devdoc>
    public enum XmlNodeType {
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.None"]/*' />
        /// <devdoc>
        ///    For XmlNavigator, cursor is not positioned
        ///    on a node.
        /// </devdoc>
        None,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.Element"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An Element.
        ///    </para>
        ///    <para>
        ///       Example XML: &lt;Name&gt;
        ///    </para>
        ///    An Element node can have
        ///    the following child node types: Element, Text, Comment, ProcessingInstruction,
        ///    CDATA, and EntityReference. The Element node can be the child of the Document,
        ///    DocumentFragment, EntityReference, and Element nodes.
        /// </devdoc>
        Element,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.Attribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An
        ///       Attribute.
        ///    </para>
        ///    <para>
        ///       Example XML: id='123'
        ///    </para>
        ///    <para>
        ///       An Attribute node can have the following child node types: Text and
        ///       EntityReference. The Attribute node does not appear as the child node of any
        ///       other node type; note that it is not considered a child node of an Element.
        ///    </para>
        /// </devdoc>
        Attribute,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       text content of an element.
        ///    </para>
        ///    <para>
        ///       A Text node cannot have any child nodes. The Text node can appear as the
        ///       child node of the Attribute, DocumentFragment, Element, and EntityReference
        ///       nodes.
        ///    </para>
        /// </devdoc>
        Text,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.CDATA"]/*' />
        /// <devdoc>
        ///    A CDATA section.
        ///    Example XML: &lt;![CDATA[my escaped text]]&gt;
        ///    CDATA sections are used to escape blocks of text that would otherwise be
        ///    recognized as markup. A CDATASection node cannot have any child nodes. The
        ///    CDATASection node can appear as the child of the DocumentFragment,
        ///    EntityReference, and Element nodes.
        /// </devdoc>
        CDATA,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.EntityReference"]/*' />
        /// <devdoc>
        ///    <para>A reference to an entity.</para>
        ///    <para>Example XML: &amp;foo;</para>
        ///    <para>This applies to all entities, including character entity references. An
        ///       EntityReference node can have the following child node types: Element,
        ///       ProcessingInstruction, Comment, Text, CDATASection, and EntityReference. The
        ///       EntityReference node can appear as the child of the Attribute, DocumentFragment,
        ///       Element, and EntityReference nodes.</para>
        /// </devdoc>
        EntityReference,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.Entity"]/*' />
        /// <devdoc>
        ///    <para>An entity declaration.</para>
        ///    <para>Example XML: &lt;!ENTITY ...&gt;</para>
        ///    <para>An Entity node can have child nodes that represent the expanded entity (for
        ///       example, Text and EntityReference nodes). The Entity node can appear as the
        ///       child of the DocumentType node.</para>
        /// </devdoc>
        Entity,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.ProcessingInstruction"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A processing instruction (PI).
        ///    </para>
        ///    <para>
        ///       Example XML: &lt;?pi test?&gt;
        ///    </para>
        ///    <para>
        ///       A PI node cannot have any child nodes. The PI node can
        ///       appear as the child of the Document, DocumentFragment, Element, and
        ///       EntityReference nodes.
        ///    </para>
        /// </devdoc>
        ProcessingInstruction,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.Comment"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A Comment.
        ///    </para>
        ///    <para>
        ///       Example XML: &lt;!-- my comment --&gt;
        ///    </para>
        ///    <para>
        ///       A Comment node cannot have any child nodes. The Comment node can appear as
        ///       the child of the Document, DocumentFragment, Element, and EntityReference
        ///       nodes.
        ///    </para>
        /// </devdoc>
        Comment,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.Document"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A document object, which, as the root of the document tree, provides access
        ///       to the entire XML document.
        ///    </para>
        ///    <para>
        ///       A Document node can have the following child node types: Element (maximum of
        ///       one), ProcessingInstruction, Comment, and DocumentType. The Document node cannot
        ///       appear as the child of any node types.
        ///    </para>
        /// </devdoc>
        Document,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.DocumentType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The document type declaration, indicated by the &lt;!DOCTYPE&gt; tag.
        ///    </para>
        ///    <para>
        ///       Example XML: &lt;!DOCTYPE ...&gt;
        ///    </para>
        ///    <para>
        ///       A DocumentType node can have the following child node types: Notation and
        ///       Entity. The DocumentType node can appear as the child of the Document node.
        ///    </para>
        /// </devdoc>
        DocumentType,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.DocumentFragment"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A document fragment.
        ///    </para>
        ///    <para>
        ///       The DocumentFragment node associates a node or subtree with a document
        ///       without actually being contained within the document. A DocumentFragment node
        ///       can have the following child node types: Element, ProcessingInstruction,
        ///       Comment, Text, CDATASection, and EntityReference. The DocumentFragment node
        ///       cannot appear as the child of any node types.
        ///    </para>
        /// </devdoc>
        DocumentFragment,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.Notation"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A notation in the document type declaration.
        ///    </para>
        ///    <para>
        ///       Example XML: &lt;!NOTATION ...&gt;
        ///    </para>
        ///    <para>
        ///       A Notation node cannot have any child nodes. The Notation node can appear as
        ///       the child of the DocumentType node.
        ///    </para>
        /// </devdoc>
        Notation,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.Whitespace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Whitespace between markup.
        ///    </para>
        /// </devdoc>
        Whitespace,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.SignificantWhitespace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Whitespace between markup in a mixed content model.
        ///    </para>
        /// </devdoc>
        SignificantWhitespace,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.EndElement"]/*' />
        /// <devdoc>
        ///    <para>Returned when XmlReader gets to the end of an element.</para>
        ///    <para>Example XML: &lt;/foo&gt;</para>
        /// </devdoc>
        EndElement,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.EndEntity"]/*' />
        /// <devdoc>
        ///    <para>Returned when XmlReader gets to the end of the entity 
        ///       replacement as a result of a call to <see cref='System.Xml.XmlReader.ResolveEntity'/>
        ///       .</para>
        /// </devdoc>
        EndEntity,
        /// <include file='doc\XmlNodeType.uex' path='docs/doc[@for="XmlNodeType.XmlDeclaration"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The XML declaration node..
        ///    </para>
        ///    <para>
        ///       Example XML: &lt;?xml version='1.0'?&gt;;
        ///    </para>
        ///    <para>
        ///        This has to be the first node in the document. It can have no children. 
        ///        It is a child of the root node. It can have attributes that provide version 
        ///        and encoding information.
        ///    </para>
        /// </devdoc>
        XmlDeclaration
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnselementtokeninfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNSElementTokenInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.Text;
namespace System.Xml {

    using System.Diagnostics;

    internal class XmlNSElementTokenInfo : XmlElementTokenInfo {
        internal XmlNSElementTokenInfo(XmlScanner scanner, XmlNamespaceManager nsMgr, XmlNodeType type, String name, int nameOffset, int nameLength, int nameColonPos,
                                       int depth, bool isEmpty) : base(scanner, nsMgr, type, depth) {
            _NsMgr = nsMgr;
            _Scanner = scanner;
            _NameColonPos = nameColonPos;
            _NameWPrefix = String.Empty;
            _Name = String.Empty;
            _Prefix = String.Empty;
            _NamespaceURI = String.Empty;
        }

        internal override void SetName(XmlScanner scanner, int offset, int length, int colon, int depth) {
            _Scanner = scanner;
            _NameColonPos = colon;
            _Depth = depth;

            _NameWPrefix = _Scanner.GetTextAtom(offset,length);
            _SchemaType = null;
            _TypedValue = null;
        }

        internal override void FixNames() {
            if (_NameColonPos > 0) {
                _Prefix = _Scanner.GetTextAtom(_NameWPrefix.Substring(0, _NameColonPos));
                _Name = _Scanner.GetTextAtom(_NameWPrefix.Substring(_NameColonPos+1));
                _NamespaceURI = _NsMgr.LookupNamespace(_Prefix);
                if (_NamespaceURI == null) {
                    throw new XmlException(Res.Xml_UnknownNs,_Prefix, LineNum, LinePos);
                }
            }
            else {
                _Prefix = String.Empty;
                _Name = _NameWPrefix;
                _NamespaceURI = _NsMgr.DefaultNamespace;
                
            }
        }

        internal override String NameWPrefix {
            get {
                return _NameWPrefix;
            }
            set {            
                Debug.Assert(_Scanner == null || Ref.Equal(value, _Scanner.GetTextAtom(value)), "FullName should be atomalized");
                _NameWPrefix = value;
                _SchemaType = null;
                _TypedValue = null;
            }
        }

        internal override String Name {
            get { return _Name;}
        }

        internal override String Prefix {
            get { return _Prefix;}
        }

        internal override String Namespaces {
            get { return _NamespaceURI;}
        }

    } // XmlNSElementTokenInfo
} // System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnonnormalizer.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNonNormalizer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlNonNormalizer.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    using System;
    using System.Text;
 
    internal class XmlNonNormalizer : XmlNormalizer {
        public XmlNonNormalizer( StringBuilder sb ) : base ( sb ) {
        }

        public override void AppendTextWithEolNormalization( char[] value, int startIndex, int count ) {
            _sb.Append( value, startIndex, count );
        }

        public override void AppendText( string value ) { 
            _sb.Append( value );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlparsercontext.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlParserContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Xml;
using System.Text;
using System;

namespace System.Xml {
    /// <include file='doc\XmlParserContext.uex' path='docs/doc[@for="XmlParserContext"]/*' />
    /// <devdoc>
    ///    Specifies the Context that the Parser will use for xml fragment
    /// </devdoc>
    public class XmlParserContext {
    
        private XmlNameTable            _nt             = null;
        private XmlNamespaceManager     _nsMgr          = null;
        private String                  _docTypeName    = String.Empty;
        private String                  _pubId          = String.Empty;
        private String                  _sysId          = String.Empty;
        private String                  _internalSubset = String.Empty;
        private String                  _xmlLang        = String.Empty;
        private XmlSpace                _xmlSpace;
        private String                  _baseURI        = String.Empty;
        private Encoding                _encoding       = null;
        
        /// <include file='doc\XmlParserContext.uex' path='docs/doc[@for="XmlParserContext.XmlParserContext"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr,String xmlLang, XmlSpace xmlSpace)
        : this(nt, nsMgr, null, null, null, null, String.Empty, xmlLang, xmlSpace)
        {
            // Intentionally Empty
        }

        /// <include file='doc\XmlParserContext.uex' path='docs/doc[@for="XmlParserContext.XmlParserContext2"]/*' />
        public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr,String xmlLang, XmlSpace xmlSpace, Encoding enc)
        : this(nt, nsMgr, null, null, null, null, String.Empty, xmlLang, xmlSpace, enc)
        {
            // Intentionally Empty
        }
        /// <include file='doc\XmlParserContext.uex' path='docs/doc[@for="XmlParserContext.XmlParserContext1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr, String docTypeName,
                  String pubId, String sysId, String internalSubset, String baseURI,
                  String xmlLang, XmlSpace xmlSpace) 
        : this(nt, nsMgr, docTypeName, pubId, sysId, internalSubset, baseURI, xmlLang, xmlSpace, null)
        {
            // Intentionally Empty
        }
        
        /// <include file='doc\XmlParserContext.uex' path='docs/doc[@for="XmlParserContext.XmlParserContext3"]/*' />
        public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr, String docTypeName,
                          String pubId, String sysId, String internalSubset, String baseURI,
                          String xmlLang, XmlSpace xmlSpace, Encoding enc)
        {
            
            if (nsMgr != null) {
                if (nt == null) {
                    _nt = nsMgr.NameTable;
                }
                else {
                    if ( (object)nt != (object)  nsMgr.NameTable ) {
                        throw new XmlException(Res.Xml_NotSameNametable, string.Empty);
                    }
                    _nt = nt;
                }
            }
            else {
                _nt = nt;
            }
            
            _nsMgr              = nsMgr;
            _docTypeName        = (null == docTypeName ? String.Empty : docTypeName);
            _pubId              = (null == pubId ? String.Empty : pubId);
            _sysId              = (null == sysId ? String.Empty : sysId);
            _internalSubset     = (null == internalSubset ? String.Empty : internalSubset);
            _baseURI            = (null == baseURI ? String.Empty : baseURI);
            _xmlLang            = (null == xmlLang ? String.Empty : xmlLang);
            _xmlSpace           = xmlSpace;
            _encoding           = enc;
            
        }
        
        /// <include file='doc\XmlParserContext.uex' path='docs/doc[@for="XmlParserContext.NameTable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlNameTable NameTable {
            get {
                return _nt;            
            }
            set {
                _nt = value;
            }            
        }

        /// <include file='doc\XmlParserContext.uex' path='docs/doc[@for="XmlParserContext.NamespaceManager"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlNamespaceManager  NamespaceManager {
            get {
                return _nsMgr;            
            }
            set {
                _nsMgr = value;
            }            
        }

        /// <include file='doc\XmlParserContext.uex' path='docs/doc[@for="XmlParserContext.DocTypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public String  DocTypeName {
            get {
                return _docTypeName;            
            }
            set {
                _docTypeName = (null == value ? String.Empty : value);
            }            
        }

        /// <include file='doc\XmlParserContext.uex' path='docs/doc[@for="XmlParserContext.PublicId"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public String PublicId {
            get {
                return _pubId;            
            }
            set {
                _pubId = (null == value ? String.Empty : value);
            }            
        }

        /// <include file='doc\XmlParserContext.uex' path='docs/doc[@for="XmlParserContext.SystemId"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public String SystemId {
            get {
                return _sysId;       
            }
            set {
                _sysId = (null == value ? String.Empty : value);
            }            
        }

        /// <include file='doc\XmlParserContext.uex' path='docs/doc[@for="XmlParserContext.BaseURI"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public String BaseURI {
            get {
                return _baseURI;       
            }
            set {
                _baseURI = (null == value ? String.Empty : value);
            }            
        }

        /// <include file='doc\XmlParserContext.uex' path='docs/doc[@for="XmlParserContext.InternalSubset"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public String InternalSubset {
            get {
                return _internalSubset;       
            }
            set {
                _internalSubset = (null == value ? String.Empty : value);
            }            
        }

        /// <include file='doc\XmlParserContext.uex' path='docs/doc[@for="XmlParserContext.XmlLang"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public String XmlLang {
            get {
                return _xmlLang;       
            }
            set {
                _xmlLang = (null == value ? String.Empty : value);
            }            
        }

        /// <include file='doc\XmlParserContext.uex' path='docs/doc[@for="XmlParserContext.XmlSpace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSpace XmlSpace {
            get {
                return _xmlSpace;       
            }
            set {
                _xmlSpace = value;
            }            
        }

        /// <include file='doc\XmlParserContext.uex' path='docs/doc[@for="XmlParserContext.Encoding"]/*' />
        public Encoding Encoding {
            get {
                return _encoding;       
            }
            set {
                _encoding = value;
            }            
        }

    } // class XmlContext
} // namespace System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnormalizer.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNormalizer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlNormalizer.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    using System;
    using System.Text;
 
    internal abstract class XmlNormalizer {
        protected StringBuilder _sb;

        public XmlNormalizer( StringBuilder sb ) {
            _sb = sb;
        }

        public StringBuilder StringBuilder {
            get {
                return _sb;
            }
        }

        public virtual void Reset() {
            _sb.Length = 0;
        }

        public override string ToString() {
            return _sb.ToString();
        }

        public abstract void AppendTextWithEolNormalization( char[] value, int startIndex, int count );
        public abstract void AppendText( string value );

        public virtual void AppendRaw( string value ) {
            _sb.Append( value );
        }

        public virtual void AppendCharEntity( char[] ch ) {
            _sb.Append( ch );
        }
        public virtual void AppendCharEntity( char ch ) {
            _sb.Append( ch );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnullresolver.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNullResolver.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

/*
 * @(#)XmlNullResolver.cs 1.0 5/15/00
 *
 * Defines the XmlNullResolver class
 *
 * Copyright (c) 2000 Microsoft, Corp. All Rights Reserved.
 *
 */

namespace System.Xml {
    using System;

    internal class XmlNullResolver : XmlUrlResolver {
        public override Object GetEntity(Uri absoluteUri, string role, Type ofObjectToReturn) {
            throw new XmlException(Res.Xml_NullResolver, string.Empty);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnsattributetokeninfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNSAttributeTokenInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.Text;
using System.Globalization;
namespace System.Xml {

    using System.Diagnostics;

    internal class XmlNSAttributeTokenInfo : XmlAttributeTokenInfo {
        protected String    _Name;                    // always atomalize
        protected int       _NameColonPos;            // store colon info
        protected String    _Prefix;                  // always atomalize
        protected String    _NamespaceURI;            // always atomalize

        internal  String    _XmlNs;

//        private static String   s_XmlNsNamespace = null;


        internal XmlNSAttributeTokenInfo(XmlScanner scanner, XmlNamespaceManager nsMgr, XmlNodeType type,
                                         bool nor, String xmlNs) : base(scanner, nsMgr, type, nor) {
            _XmlNs = xmlNs;
        }
	
	//Called only on xmlns or xmlns: attribute
	internal override void FixNSNames() {
	    String value = GetValue();
	    // should not binding to the reserved xmlns namespace
            if (value == XmlReservedNs.NsXmlNs)
                throw new XmlException(Res.Xml_CanNotBindToReservedNamespace, ValueLineNum, ValueLinePos);

	    _NamespaceURI = XmlReservedNs.NsXmlNs;

	    if ((object)_NameWPrefix == (Object)_XmlNs) {
	    	_Prefix = String.Empty;
		_Name = _NameWPrefix;
		_NsMgr.AddNamespace(String.Empty, value);
	    }
	    else {
	    	_Prefix = _Scanner.GetTextAtom(_NameWPrefix.Substring(0,5));
		Debug.Assert((object)_Prefix == (Object)_XmlNs);
		_Name = _Scanner.GetTextAtom(_NameWPrefix.Substring(6));
		//xmlns:xmlns not allowed
                if ( ((object)_Name == (Object)_XmlNs) ||
		      (String.Compare(_Name,"xml", false, CultureInfo.InvariantCulture) ==0) ) {
                    throw new XmlException(Res.Xml_ReservedNs,_Name, LineNum, LinePos);
                }
	
                if (value == String.Empty && _Name.Length > 0)  {
                    throw new XmlException(Res.Xml_BadNamespaceDecl, ValueLineNum, ValueLinePos);
                }
			
                if ((_Name.Length > 0 && _Name[0] != '_' && XmlCharType.IsLetter(_Name[0]) == false) ) {
                    throw new XmlException(Res.Xml_BadNameChar, XmlException.BuildCharExceptionStr(_Name[0]));
		}
		
		_NsMgr.AddNamespace(_Name, value);
	    }	    
	}


        internal override void FixNames() {
            if (_NameColonPos > 0) {
                _Prefix = _Scanner.GetTextAtom(_NameWPrefix.Substring(0, _NameColonPos));
                _Name = _Scanner.GetTextAtom(_NameWPrefix.Substring(_NameColonPos+1));
                _NamespaceURI = _NsMgr.LookupNamespace(_Prefix);
                if (_NamespaceURI == null) {
                    throw new XmlException(Res.Xml_UnknownNs,_Prefix, LineNum, LinePos);
                }
            }
            else {
                _Prefix = String.Empty;
                _Name = _NameWPrefix;
                _NamespaceURI = String.Empty;
            }
        }

        internal override void SetName(XmlScanner scanner, String nameWPrefix, int nameColonPos, int depth, bool isDefault) {
            _Scanner = scanner;
            _NameColonPos = nameColonPos;
            _Depth = depth;
            _IsDefault = isDefault;    
            _NameWPrefix = nameWPrefix;
            // PERF - we now do this instead of calling reset.
            _RawValue = String.Empty;
            _Name = null;
        }

        internal override String GenerateNS() {
            if (!_NsAttribute && _Prefix != String.Empty) {
                _NamespaceURI = _NsMgr.LookupNamespace(_Prefix);
                if (_NamespaceURI == null) {
                    throw new XmlException(Res.Xml_UnknownNs,_Prefix, LineNum, LinePos);
                }
            }
            else {
                _NamespaceURI = String.Empty;
            }
            return _NamespaceURI;
        }

        internal override String Name {
            get {
                return _Name;
            }
            set {
                _Name = value;
                _NameWPrefix = _Name;                
            }
        }

        internal override int NameColonPos {
            get {
                return _NameColonPos;
            }
            set {
                _NameColonPos = value;
            }
        }

        internal override String Prefix {
            get {
                return _Prefix;
            }
            set {
                Debug.Assert(Ref.Equal(value, _Scanner.GetTextAtom(value)), "Prefix should be atomalized");
                _Prefix = value;
            }
        }

        internal override String Namespaces {
            get {
                return _NamespaceURI;
            }
            set {
                _NamespaceURI = value;                
            }
        }
    } // XmlNSAttributeTokenInfo
} // System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlnotation.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlNotation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlNotation.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    using System;
    using System.Diagnostics;

    /// <include file='doc\XmlNotation.uex' path='docs/doc[@for="XmlNotation"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Contains a notation declared in the DTD or schema.
    ///    </para>
    /// </devdoc>
    public class XmlNotation : XmlNode {
        String _publicId;
        String _systemId;
        String _name;

        internal XmlNotation( String name, String publicId, String systemId, XmlDocument doc ): base( doc ) {
            this._name = doc.NameTable.Add(name);
            this._publicId = publicId;
            this._systemId = systemId;
        }

        /// <include file='doc\XmlNotation.uex' path='docs/doc[@for="XmlNotation.Name"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the node.</para>
        /// </devdoc>
        public override string Name { 
            get { return _name;}
        }

        /// <include file='doc\XmlNotation.uex' path='docs/doc[@for="XmlNotation.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the current node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override string LocalName { 
            get { return _name;}
        }

        /// <include file='doc\XmlNotation.uex' path='docs/doc[@for="XmlNotation.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType {
            get { return XmlNodeType.Notation;}
        }

        /// <include file='doc\XmlNotation.uex' path='docs/doc[@for="XmlNotation.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Throws an InvalidOperationException since Notation can not be cloned.
        ///    </para>
        /// </devdoc>
        public override XmlNode CloneNode(bool deep) {

            throw new InvalidOperationException(Res.GetString(Res.Xdom_Node_Cloning));
        }

        // Microsoft extensions
        /// <include file='doc\XmlNotation.uex' path='docs/doc[@for="XmlNotation.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the node is read-only.
        ///    </para>
        /// </devdoc>
        public override bool IsReadOnly {
            get { 
                return true;        // Make notations readonly
            }
        }

        /// <include file='doc\XmlNotation.uex' path='docs/doc[@for="XmlNotation.PublicId"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       the value of the public identifier on the notation declaration.</para>
        /// </devdoc>
        public String PublicId { 
            get { return _publicId;}
        }

        /// <include file='doc\XmlNotation.uex' path='docs/doc[@for="XmlNotation.SystemId"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of
        ///       the system identifier on the notation declaration.</para>
        /// </devdoc>
        public String SystemId { 
            get { return _systemId;}
        }

        //Without override these two functions, we can't guarantee that WriteTo()/WriteContent() functions will never be called
        /// <include file='doc\XmlNotation.uex' path='docs/doc[@for="XmlNotation.OuterXml"]/*' />
        public override String OuterXml { 
            get { return String.Empty; }
        }        
                
        /// <include file='doc\XmlNotation.uex' path='docs/doc[@for="XmlNotation.InnerXml"]/*' />
        public override String InnerXml { 
            get { return String.Empty; }
            set { throw new InvalidOperationException( Res.GetString(Res.Xdom_Set_InnerXml ) ); }
        }        
        
        /// <include file='doc\XmlNotation.uex' path='docs/doc[@for="XmlNotation.WriteTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteTo(XmlWriter w) {
            // You should never call this function since notations are readonly to the user)


            Debug.Assert(false);
        }

        /// <include file='doc\XmlNotation.uex' path='docs/doc[@for="XmlNotation.WriteContentTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves all the children of the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteContentTo(XmlWriter w) {
            // You should never call this function since notations are readonly to the user)
            Debug.Assert(false);
        }

    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlqualifiedname.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlQualifiedName.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml {

    /// <include file='doc\XmlQualifiedName.uex' path='docs/doc[@for="XmlQualifiedName"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class XmlQualifiedName {
        string name;
        string ns;
        Int32  hash;

        /// <include file='doc\XmlQualifiedName.uex' path='docs/doc[@for="XmlQualifiedName.Empty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly XmlQualifiedName Empty = new XmlQualifiedName(null);

        /// <include file='doc\XmlQualifiedName.uex' path='docs/doc[@for="XmlQualifiedName.XmlQualifiedName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlQualifiedName() : this(string.Empty, string.Empty) {}

        /// <include file='doc\XmlQualifiedName.uex' path='docs/doc[@for="XmlQualifiedName.XmlQualifiedName1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlQualifiedName(string name) : this(name, string.Empty) {}

        /// <include file='doc\XmlQualifiedName.uex' path='docs/doc[@for="XmlQualifiedName.XmlQualifiedName2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlQualifiedName(string name, string ns) {
            this.ns   = ns   == null ? string.Empty : ns;
            this.name = name == null ? string.Empty : name;
        }

        /// <include file='doc\XmlQualifiedName.uex' path='docs/doc[@for="XmlQualifiedName.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return ns; }
        }

        /// <include file='doc\XmlQualifiedName.uex' path='docs/doc[@for="XmlQualifiedName.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Name {
            get { return name; }
        }

        /// <include file='doc\XmlQualifiedName.uex' path='docs/doc[@for="XmlQualifiedName.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            if(hash == 0) {
                hash = Name.GetHashCode() /*+ Namespace.GetHashCode()*/; // for perf reasons we are not taking ns's hashcode.
            }
            return hash;
        }

        /// <include file='doc\XmlQualifiedName.uex' path='docs/doc[@for="XmlQualifiedName.IsEmpty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsEmpty {
            get { return Name.Length == 0 && Namespace.Length == 0; }
        }

        /// <include file='doc\XmlQualifiedName.uex' path='docs/doc[@for="XmlQualifiedName.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string ToString() {
            return Namespace == string.Empty ? Name : Namespace + ":" + Name;
        }

        /// <include file='doc\XmlQualifiedName.uex' path='docs/doc[@for="XmlQualifiedName.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(object other) {
            XmlQualifiedName qname = other as XmlQualifiedName;
            if (qname == null) {
                return false;
            }
            return (
                ((object)Name == (object)qname.Name && (object)Namespace == (object)qname.Namespace) ||
                (        Name ==         qname.Name &&         Namespace ==         qname.Namespace)
            );
        }

        /// <include file='doc\XmlQualifiedName.uex' path='docs/doc[@for="XmlQualifiedName.operator=="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static bool operator ==(XmlQualifiedName a, XmlQualifiedName b) {
            if ((object)a == null && (object)b == null)
                return true;
            if ((object)a == null || (object)b == null)
                return false;

            return (
                ((object)a.Name == (object)b.Name && (object)a.Namespace == (object)b.Namespace) ||
                (        a.Name ==         b.Name &&         a.Namespace ==         b.Namespace)
            );
        }

        /// <include file='doc\XmlQualifiedName.uex' path='docs/doc[@for="XmlQualifiedName.operator!="]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static bool operator !=(XmlQualifiedName a, XmlQualifiedName b) {
            return !(a == b);
        }

        /// <include file='doc\XmlQualifiedName.uex' path='docs/doc[@for="XmlQualifiedName.ToString1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string ToString(string name, string ns) {
            return ns == null || ns == string.Empty ? name : ns + ":" + name;
        }

        // --------- Some useful internal stuff -----------------
        internal void Verify() {
            XmlConvert.VerifyNCName(name);
            if (ns != string.Empty) {
                XmlConvert.ToUri(ns);
            }
        }

        internal void Atomize(XmlNameTable nameTable) {
            name = nameTable.Add(name);
            if (ns != string.Empty) {
                ns = nameTable.Add(ns);
            }
        }

        internal static XmlQualifiedName Parse(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr, out string prefix) {
            int colonPos = s.IndexOf(':');
            if (colonPos > 0) {
                char[] text = s.ToCharArray();
                prefix = nameTable.Add(text, 0, colonPos);
                XmlConvert.VerifyNCName(prefix);
                s = nameTable.Add(text, colonPos + 1, text.Length - colonPos - 1);
            }
            else {
                prefix = string.Empty;
                s = nameTable.Add(s);
            }
            XmlConvert.VerifyNCName(s);
            string uri = nsmgr.LookupNamespace(prefix);
            if (uri == null) {
                throw new XmlException(Res.Xml_UnknownNs, prefix);
            }
            return new XmlQualifiedName(s, uri);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlresolver.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlResolver.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml
{
    using System;
    using System.IO;
    using System.Net;
    using System.Text;
    using System.Security;
    using System.Security.Policy;
    using System.Security.Permissions;

    /// <include file='doc\XmlResolver.uex' path='docs/doc[@for="XmlResolver"]/*' />
    /// <devdoc>
    ///    <para>Resolves external XML resources named by a Uniform 
    ///       Resource Identifier (URI). This class is <see langword='abstract'/>
    ///       .</para>
    /// </devdoc>
    public abstract class XmlResolver {
        /// <include file='doc\XmlResolver.uex' path='docs/doc[@for="XmlResolver.GetEntity1"]/*' />
        /// <devdoc>
        ///    <para>Maps a
        ///       URI to an Object containing the actual resource.</para>
        /// </devdoc>

        public abstract Object GetEntity(Uri absoluteUri, 
                                         string role, 
                                         Type ofObjectToReturn);

        /// <include file='doc\XmlResolver.uex' path='docs/doc[@for="XmlResolver.ResolveUri"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSetAttribute( SecurityAction.InheritanceDemand, Name = "FullTrust" )]
        public virtual Uri ResolveUri(Uri baseUri, string relativeUri) {
            if (null == relativeUri) {
                relativeUri = String.Empty;
            }
            int prefixed = IsPrefixed(relativeUri);
            if (prefixed == PREFIXED) {
                if (relativeUri.StartsWith("file:"))
                    return new Uri(Escape(relativeUri), true);
                else
                    return new Uri(relativeUri);
            }
            else if (prefixed == ABSOLUTENOTPREFIXED) {
                if (relativeUri.StartsWith("file:"))
                    return new Uri(Escape(relativeUri), true);
                else
                    return new Uri(Escape("file://" + relativeUri), true);
            }
            else if (prefixed == SYSTEMROOTMISSING) {
                // we have gotten a path like "/foo/bar.xml" we should use the drive letter from the baseUri if available.
                if (null == baseUri)
                    return new Uri(Escape(Path.GetFullPath(relativeUri)), true);
                else
                    if ("file" == baseUri.Scheme) {
                        return new Uri(Escape(Path.GetFullPath(Path.GetPathRoot(baseUri.LocalPath) + relativeUri)), true);
                    }
                    return new Uri(baseUri, relativeUri);
            }
            else if (baseUri != null) {
                if (baseUri.Scheme == "file"){
                    baseUri = new Uri(Escape(baseUri.ToString()), true);   
                    return new Uri(baseUri, Escape(relativeUri), true);
                }   
                else
                    return new Uri(baseUri, relativeUri);
            }
            else {
                return new Uri(Escape(Path.GetFullPath(relativeUri)), true);
            }
        }

        //UE attension
        /// <include file='doc\XmlResolver.uex' path='docs/doc[@for="XmlResolver.Credentials"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract ICredentials Credentials {
            set;
        }

        private const int NOTPREFIXED         = -1;
        private const int PREFIXED            =  1;
        private const int ABSOLUTENOTPREFIXED =  2;
        private const int SYSTEMROOTMISSING   =  3;

        private static string Escape(string path) {
            StringBuilder b = new StringBuilder();
            char c;
            for (int i = 0; i < path.Length; i++) {
                c = path[i];
                if (c == '\\')
                    b.Append('/');
                else if (c == '#')
                    b.Append("%23");
                else
                    b.Append(c);
            }
            return b.ToString();
        }

        internal static string UnEscape(string path) {
        if (null != path && path.StartsWith("file")) {
                return path.Replace("%23", "#");
        }
        return path;
        }


        private static int IsPrefixed(string uri) {
            if (uri != null && uri.IndexOf("://") >= 0)
                return PREFIXED;
            else if (uri.IndexOf(":\\") > 0)
                return ABSOLUTENOTPREFIXED;
            else if (uri.Length > 1 && uri[0] == '\\' && uri[1] != '\\')
                return SYSTEMROOTMISSING;
            else
                return NOTPREFIXED;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlscanner.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlScanner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------
using System;
using System.Globalization;
using System.IO;
using System.Resources;


namespace System.Xml {
    using System.Text;

    /*
     * The XmlScanner class scans through some given XML input
     * and returns low level xml tokens.  When the input is a StreamReader
     * it buffers the input in 4k chunks and manages the cross buffer token
     * case so that these are still returned as single tokens.
     *
     * @internalonly
     * @see XmlScanner
     */

    internal enum IncrementalReadType {
        Chars,
        Base64,
        BinHex,
    }

    internal sealed class XmlScanner {
        private int _nToken;
        private int _nStartLine; // start of token that contains error (like a comment for example)
        private int _nStartLinePos; // position on _nStartLine of start of token that contains error (like a comment for example)
        private int _nLineNum;
        private int _nLinePos;
        private int _nLinePosOffSet;
        private int _nLineOffSet;
        private int _nPos;
        private int _nStart;
        private int _nUsed;
        private int _nSize;

        private XmlNameTable    _nameTable;
        private char            _chQuoteChar;
        private char[]          _achText;
        private int             _nColon;
        private bool            _fDTD;
        private int             _ReadBufferConsistency;
        private int             _nAbsoluteOffset;

        //
        private bool            _Normalization;
        private int             _nCodePage;
        private Encoding        _Encoding;
        private XmlStreamReader _StreamReader = null;
        private TextReader      _TextReader = null;
        private Decoder         _Decoder;
        private byte[]          _ByteBuffer;
        private int             _ByteLen;
        private bool            _PermitEncodingChange;
        private bool            _EncodingSetByDefault = false;
        private BinHexDecoder   _BinHexDecoder;
        private Base64Decoder   _Base64Decoder;

        private bool            _PreviousError;
        private int             _PreviousErrorOffset;
        private bool            _Reset;
        private int             _ByteStart = 0;
        private int             _ByteDocumentStart = 0;

        private static  int[,]  _sEncodings = null;

        private static string s_ucs4= "ucs-4";
        private const int Invalid   = 1; //Bad Encoding
        private const int UniCodeBE = 2; //Unicode Big Endian
        private const int UniCode   = 3; //Unicode Little Endian
        private const int UCS4BE    = 4; //UCS4 BigEndian
        private const int UCS4BEB   = 5; //UCS4 BigEnding with Byte order mark
        private const int UCS4      = 6; //UCS4 Little Endian
        private const int UCS4B     = 7; //UCS4 Little Ending with Byte order mark
        private const int UCS434    = 8; //UCS4 order 3412
        private const int UCS434B   = 9; //UCS4 order 3412 with Byte order mark
        private const int UCS421    = 10;//UCS4 order 2143
        private const int UCS421B   = 11;//UCS4 order 2143 with Byte order mark
        private const int EBCDIC    = 12;
        private const int UTF8      = 13;

        //
        // whether the scanner needs to support namespace spec
        // if yes,
        // 1) name should not start with :
        // 2) there shouldn't be more than one colon in the name
        // 3) name should not end with :
        //
        private bool _NamespaceSupport;


        internal const int BUFSIZE = 4096;

        public bool Normalization
        {
            set
            {
                _Normalization = value;
            }
        }

        /*
         * Initialize the scanner given a StreamReader.
         */
        private XmlScanner(XmlNameTable ntable) {
            _nameTable = ntable;
            _nLinePos = 0;
            _nPos = 0;
            _nStart = 0;
            _nUsed = 0;
            _nStartLinePos = 0;
            _nLineNum = 1;
            _nLinePosOffSet = 0;
            _nLineOffSet = 0;
            _ReadBufferConsistency = -1;
            _nAbsoluteOffset = 0;
        }

        /*
         * Initialize the scanner given a zero-terminated array of characters.
         */
        internal XmlScanner(char[] text, XmlNameTable ntable) : this(text, 0, text.Length, ntable, 1, 0) {
        }


        internal XmlScanner(char[] text, XmlNameTable ntable, int lineNum, int linePos) : this(text, ntable) {
            _nLineOffSet = _nLineNum = lineNum;
            _nLinePosOffSet = linePos - 1;
            _nLinePos  = 0;
        }

        /*
         * Initialize the scanner given a zero-terminated array of characters.
         */
        internal XmlScanner(char[] text, int offset, int length, XmlNameTable ntable, int lineNum, int linePos) : this(ntable) {
            int len = length;
            if (len == 0 || text[len-1] != (char)0) {
                // need to NULL terminate it.
                _achText = new char [len + 1 ];
                System.Array.Copy(text, offset, _achText, 0, len);
                _achText[len] = (char)0;
            }
            else {
                _achText = text;
            }
            _nLineOffSet = _nLineNum = lineNum;
            _nLinePosOffSet = linePos;
            _nLinePos = 0;
            _PermitEncodingChange = false;
            _Encoding = Encoding.Unicode;
            _nSize = _nUsed = len;
        }

        /*
         * Initialize the scanner given a StreamReader.
         */
        internal XmlScanner(TextReader reader, XmlNameTable ntable)  : this(ntable) {
            const int BUFSIZE_SMALL = 256;
            _TextReader = reader;
            _StreamReader = null;
            _nSize = BUFSIZE;
            StreamReader streamReader = reader as StreamReader;
            if (streamReader != null) {
                Stream stream = streamReader.BaseStream;
                if (stream.CanSeek && stream.Length < BUFSIZE) {
                    _nSize = BUFSIZE_SMALL;
                }
            }
            _achText = new char[_nSize+1];
            _PermitEncodingChange = false;
            _Encoding = Encoding.Unicode;

            //no need to check Encoding, start reading
            Read();
        }

        internal static int GetEncodingIndex(int c1){
            switch(c1)
            {
                case 0x0000:    return 1;
                case 0xfeff:    return 2;
                case 0xfffe:    return 3;
                case 0xefbb:    return 4;
                case 0x3c00:    return 5;
                case 0x003c:    return 6;
                case 0x3f00:    return 7;
                case 0x003f:    return 8;
                case 0x3c3f:    return 9;
                case 0x786d:    return 10;
                case 0x4c6f:    return 11;
                case 0xa794:    return 12;
                default:        return 0; //unknown
            }
        }

        internal static int AutoDetectEncoding(byte[] buffer)
        {
            return AutoDetectEncoding(buffer, 0);
        }

        internal static int AutoDetectEncoding(byte[] buffer, int index)
        {
            if (2 > (buffer.Length - index)) {
                return Invalid;
            }
            int c1 = buffer[index + 0] << 8 | buffer[index + 1];

            int c4,c5;
            //Assign an index (label) value for first two bytes
            c4 = GetEncodingIndex(c1);

            if (4 > (buffer.Length - index)) {
                c5 = 0; // unkown;
            }
            else {
                int c2 = buffer[index + 2] << 8 | buffer[index + 3];
                //Assign an index (label) value for 3rd and 4th byte
                c5 = GetEncodingIndex(c2);
            }


            //Bellow table is to identify Encoding type based on
            //first four bytes, those we have converted in index
            //values for this look up table
            //values on rows are first two bytes and
            //values on columns are 3rd and 4th byte

            if (null == _sEncodings) {
                int[,] encodings =  {
                              //Unknown     0000         feff         fffe         efbb         3c00         003c         3f00         003f          3c3f          786d          4c6f          a794
                   /*Unknown*/ {Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid      ,Invalid      ,Invalid      ,Invalid      ,Invalid     },
                      /*0000*/ {Invalid     ,Invalid     ,UCS4BEB     ,UCS421B     ,Invalid     ,UCS421      ,UCS4BE      ,Invalid     ,Invalid      ,Invalid      ,Invalid      ,Invalid      ,Invalid     },
                      /*feff*/ {UniCodeBE   ,UCS434   ,UniCodeBE   ,UniCodeBE   ,UniCodeBE   ,UniCodeBE   ,UniCodeBE   ,UniCodeBE   ,UniCodeBE    ,UniCodeBE    ,UniCodeBE    ,UniCodeBE    ,UniCodeBE   },
                      /*fffe*/ {UniCode     ,UCS4B       ,UniCode     ,UniCode     ,UniCode     ,UniCode     ,UniCode     ,UniCode     ,UniCode      ,UniCode      ,UniCode      ,UniCode      ,UniCode     },
                      /*efbb*/ {Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid      ,Invalid      ,Invalid      ,Invalid      ,Invalid     },
                      /*3c00*/ {Invalid     ,UCS4        ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,UniCode     ,Invalid      ,Invalid      ,Invalid      ,Invalid      ,Invalid     },
                      /*003c*/ {Invalid     ,UCS434      ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,UniCodeBE    ,Invalid      ,Invalid      ,Invalid      ,Invalid     },
                      /*3f00*/ {Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid      ,Invalid      ,Invalid      ,Invalid      ,Invalid     },
                      /*003f*/ {Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid      ,Invalid      ,Invalid      ,Invalid      ,Invalid     },
                      /*3c3f*/ {Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid      ,Invalid      ,UTF8         ,Invalid      ,Invalid     },
                      /*786d*/ {Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid      ,Invalid      ,Invalid      ,Invalid      ,Invalid     },
                      /*4c6f*/ {Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid      ,Invalid      ,Invalid      ,Invalid      ,EBCDIC      },
                      /*a794*/ {Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid     ,Invalid      ,Invalid      ,Invalid      ,Invalid      ,Invalid     }
                };
                _sEncodings = encodings;
            }

            return _sEncodings[c4,c5];

        }

        internal XmlScanner(XmlStreamReader reader, XmlNameTable ntable) : this(reader, ntable, null) {
            // Intentionally Empty
        }

        internal XmlScanner(XmlStreamReader reader, XmlNameTable ntable, Encoding enc) : this(ntable) {
            _nLineNum = 1;
            _StreamReader = reader;
            _TextReader = null;
            _nSize = (int) ((reader.CanCalcLength && reader.Length < BUFSIZE) ? reader.Length:BUFSIZE);
            _ByteBuffer = new byte[_nSize+1];
            _ByteLen = _StreamReader.Read(_ByteBuffer, 0, _nSize);
            _ByteStart = 0;
            _ByteDocumentStart = 0;

            _nCodePage = 0;
            if (null != enc) {
                _Encoding = enc;
            }
            else {
                _Encoding = null;
                switch(AutoDetectEncoding(_ByteBuffer))
                {
                case UniCodeBE://2:
                    _Encoding = Encoding.BigEndianUnicode;
                    break;
                case UniCode: //3:
                    _Encoding = Encoding.Unicode;
                    break;
                case UCS4BE: //4:
                case UCS4BEB: // 5:
                    _Encoding = Ucs4Encoding.UCS4_Bigendian;
                    break;

                case UCS4: //6:
                case UCS4B: //7:
                    _Encoding = Ucs4Encoding.UCS4_Littleendian;
                    break;

                case UCS434://8:
                case UCS434B: //9:
                    _Encoding = Ucs4Encoding.UCS4_3412;
                    break;
                case UCS421: //10:
                case UCS421B://11:
                    _Encoding = Ucs4Encoding.UCS4_2143;
                    break;

                case EBCDIC: //12: ebcdic
                    throw new XmlException(Res.Xml_UnknownEncoding, "ebcdic", LineNum, LinePos);
                    //break;
                case UTF8: //13:
                    _EncodingSetByDefault = true;
                    _Encoding = new UTF8Encoding(true, true);
                    break;
                default:
                    _Encoding = new UTF8Encoding(true, true);

                    break;
                }

            }

            _Decoder = _Encoding.GetDecoder();
            _PermitEncodingChange = true;
            if(_Encoding != null)
                _nCodePage = _Encoding.CodePage;
            _achText = new char[_nSize+1];

            int preambleLength = 0;
            try {
                byte[] preamble = _Encoding.GetPreamble();
                preambleLength = preamble.Length;
                bool hasByteOrderMark = true;
                for (int i = 0; i < preambleLength && hasByteOrderMark; i++) {
                    hasByteOrderMark &= (_ByteBuffer[i] == preamble[i]);
                }
                if (hasByteOrderMark) {
                    _ByteStart = preambleLength;
                }
            }
            catch (Exception) {
            }

            _nUsed += GetChars(_ByteBuffer, ref _ByteStart , _ByteLen - _ByteStart, _achText, 0, true);

            _achText[_nUsed] = (char)0;
        }

        /*
         * Close the Stream.
         */
        internal void Close() {
            Close(true);
        }
        internal void Close(bool closeStream) {
            if (!closeStream){
                // the user does not want to close the StreamReader or the TextReader;
                return;
            }
            if (_StreamReader != null) {
                _StreamReader.Close();
            }
            else if (_TextReader != null) {
                _TextReader.Close();
            }

        }

        /*
         * Return the current line number.
         */
        internal int StartLineNum {
            get { return _nStartLine; }
        }

        internal int StartLinePos {
            get { return _nStartLinePos; }
        }

        internal int LineNum
        {
            get { return _nLineNum;}
            set { _nLineNum = value;}
        }

        internal int AbsoluteLinePos
        {
            get {
                return _nLinePos;
            }
            set { _nLinePos = value;}
        }

        internal int LinePos
        {
            get {
                if (_nLineOffSet != _nLineNum )
                    return _nPos - _nLinePos + 1;
                return _nPos - _nLinePos + _nLinePosOffSet + 1;
            }
            set { _nLinePos = value;}
        }

        internal int StartPos
        {
            get { return _nStart + _nAbsoluteOffset; }
            set { _nStart = value - _nAbsoluteOffset; }
        }

        internal int CurrentPos
        {
            get { return _nPos + _nAbsoluteOffset; }
            set { _nPos = value - _nAbsoluteOffset;}
        }

        internal bool InDTD
        {
            get { return _fDTD;}
            set { _fDTD = value;}
        }

        internal bool NamespaceSupport
        {
            set { _NamespaceSupport = value;}
        }

        internal Encoding Encoding
        {
            get { return _Encoding; }
        }

        internal char[] InternalBuffer {
            get { return _achText; }
        }

        internal int TextOffset {
            get { return _nStart; }
        }

        internal int TextLength {
            get {return _nPos - _nStart;}
        }

        internal int AbsoluteOffset {
            get { return _nAbsoluteOffset; }
        }


        internal void VerifyEncoding() {
            if (_EncodingSetByDefault) {
                    Encoding oldEncoding = _Encoding;
                    _Encoding = new UTF8Encoding(true, true);
                    _Decoder = _Encoding.GetDecoder();
                    _nCodePage = _Encoding.CodePage;
                    _nLineOffSet = _nLineNum;
                    _nLinePosOffSet = LinePos - 1;
                    _ByteStart = _ByteDocumentStart + oldEncoding.GetByteCount( _achText, 0, _nPos );
                    _PreviousError = false;
                    _nUsed = GetChars(_ByteBuffer, ref _ByteStart, _ByteLen - _ByteStart , _achText, 0, false);
                    _nPos = 0;
                    _achText[_nUsed] = (char)0;
                    _EncodingSetByDefault = false;
            }

        }

        internal void SwitchEncoding(String encoding) {
            Encoding oldEncoding = _Encoding;

            if (_StreamReader != null) {
                // need to remove this code once we get retrieve the encoding from GetEncoding
                encoding = encoding.ToLower(CultureInfo.InvariantCulture);
                if (encoding.Equals("ucs-2") || encoding.Equals("utf-16") ||
                         encoding.Equals("iso-10646-ucs-2") || encoding == s_ucs4) {
                    if (_nCodePage != Encoding.BigEndianUnicode.CodePage && _nCodePage != Encoding.Unicode.CodePage && encoding != s_ucs4) {
                        _nPos = _nStart;
                        throw new XmlException(Res.Xml_MissingByteOrderMark, string.Empty);
                    }
                    // no need to call SwitchEncoding
                    goto cleanup;
                }
                else if (_PermitEncodingChange) {
                    Encoding enc = null;
                    int codepage = -1;
                    try {
                        enc = Encoding.GetEncoding(encoding);
                        codepage = enc.CodePage;
                    }
                    catch (Exception) {
                    }

                    if (codepage == -1) {
                        _nPos = _nStart;
                        throw new XmlException(Res.Xml_UnknownEncoding, encoding, LineNum, LinePos - encoding.Length - 1);
                    }

                    if (codepage == _nCodePage)
                        goto cleanup;

                    _Encoding = enc;
                    _nCodePage = codepage;
                    _Decoder = _Encoding.GetDecoder();
                    _nLineOffSet = _nLineNum;
                    _nLinePosOffSet = LinePos - 1;
                    _ByteStart = _ByteDocumentStart + oldEncoding.GetByteCount( _achText, 0, _nPos );
                    _PreviousError = false;
                    _nUsed = GetChars(_ByteBuffer, ref _ByteStart, _ByteLen - _ByteStart, _achText, 0, false);
                    _nPos = 0;
                    _achText[_nUsed] = (char)0;
                    _PermitEncodingChange = false;
                }
            }
            cleanup:
            return;
        }


        internal char GetStartChar() {
            return _achText[_nStart];
        }


        /*
         * Retrieve the currently scanned token text as a String
         */
        internal String GetText() {
            if (_nStart >= _nPos)
                return String.Empty;
            return new String(_achText, _nStart, _nPos - _nStart);
        }

        internal String GetText(int offset, int length) {
            if (length < 1)
                return String.Empty;
            return new String(_achText, offset - _nAbsoluteOffset, length);
        }

        internal char GetChar(int offset) {
            return _achText[offset - _nAbsoluteOffset];
        }

        internal String GetTextAtom() {
            if (_nStart >= _nPos)
                return String.Empty;

            return _nameTable.Add( _achText, _nStart, _nPos - _nStart);
        }

        internal string GetRemainder()
        {
            StringBuilder stringBuilder = new StringBuilder();
            do
            {
                _nStart = _nPos;
                _nPos = _nUsed;
                stringBuilder.Append(_achText,  _nStart, _nPos - _nStart);
            }while(Read() != 0);

            return stringBuilder.ToString();
        }

        internal String GetTextAtom(int offset, int length) {
            if (length < 1)
                return String.Empty;

            return _nameTable.Add( _achText, offset - _nAbsoluteOffset, length);
        }

        internal String GetTextAtom(String name) {
            if (name == String.Empty)
                return String.Empty;

            return _nameTable.Add( name );
        }

        /*
         * returns true if the element name just parsed matches the given name.
         */
        internal bool IsToken(String pszName) {
            int i = _nStart;
            if (pszName.Length == _nPos - _nStart) {
                int j = 0;
                while (i < _nPos && _achText[i] == pszName[j]) {
                    i++; j++;
                }
            }
            return(i == _nPos);
        }

        internal bool IsToken(int token) {
            return IsToken(XmlToken.ToString(token));
        }

        /*
         */
        internal int ScanDtdContent() {
            char ch;
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;

            //already crossed the line?
            if (_nPos > 0 && _achText[_nPos - 1] == 0 && Read() == 0) {
                _nToken = XmlToken.EOF;
                goto done;
            }

            while (true) {
                ch = _achText[_nPos];
                switch (ch) {
                    case ' ':
                    case (char)0x9:
                        ++_nPos;
                        _nStartLinePos= this.LinePos;
                        break;
                    case (char)0xa:
                        ++_nPos;
                        ++_nLineNum;
                        _nLinePos = _nPos;
                        _nStartLine = _nLineNum;
                        _nStartLinePos= this.LinePos;
                        break;
                    case (char)0xd:
                        ++_nPos;
                        ++_nLineNum;
                        if (_achText[_nPos] == 0) Read();
                        if (_achText[_nPos] == 0xa) ++_nPos;
                        _nLinePos = _nPos;
                        _nStartLine = _nLineNum;
                        _nStartLinePos= this.LinePos;
                        break;
                    case (char)0:
                        if (Read() == 0) {
                            _nToken = XmlToken.EOF;
                            goto done;
                        }
                        break;
                    case '%':
                        ++_nPos;
                        ScanParEntityRef();
                        goto done;
                    case '<':
                        ++_nPos;
                        ch = _achText[_nPos];
                        if (ch == 0) {
                            if (Read() == 0)
                                throw new XmlException(Res.Xml_UnexpectedEOF, XmlToken.ToString(XmlToken.NAME), LineNum, LinePos);
                            ch = _achText[_nPos];
                        }

                        switch (ch) {
                            case '?':
                                ++_nPos;
                                InDTD = false;
                                ScanName();
                                InDTD = true;
                                _nToken = XmlToken.PI;
                                goto done;
                            case '!':
                                ++_nPos;
                                if (_nPos+1 >= _nUsed)
                                    Read();
                                if (_achText[_nPos] == '-' && _achText[_nPos+1] == '-') {
                                    _nPos += 2;
                                    ScanComment();
                                }
                                else if (_achText[_nPos] == '[') {
                                    ++_nPos;
                                    _nToken = XmlToken.CONDSTART;
                                }
                                else {
                                    ScanName();
                                    ch = _achText[_nStart];
                                    _nToken = XmlToken.NONE;

                                    switch (ch) {
                                        case 'E':
                                            if (IsToken(XmlToken.ELEMENT))
                                                _nToken = XmlToken.ELEMENT;
                                            else if (IsToken(XmlToken.ENTITY))
                                                _nToken = XmlToken.ENTITY;
                                            break;
                                        case 'A':
                                            if (IsToken(XmlToken.ATTLIST))
                                                _nToken = XmlToken.ATTLIST;
                                            break;
                                        case 'N':
                                            if (IsToken(XmlToken.NOTATION))
                                                _nToken = XmlToken.NOTATION;
                                            break;
                                    }

                                    if (_nToken == XmlToken.NONE)
                                        throw new XmlException(Res.Xml_ExpectDtdMarkup, LineNum, LinePos - TextLength);
                                }
                break;
                        }
                        goto done;
                    case ']':
                        if (_nPos+2 >= _nUsed)
                            Read();
                        if (_achText[_nPos+1] == ']' && _achText[_nPos+2] == '>') {
                            _nPos += 3;
                            _nToken = XmlToken.CDATAEND;
                        }
                        else {
                            _nToken = XmlToken.RSQB;
                        }
                        goto done;
                    default:
                        throw new XmlException(Res.Xml_ExpectDtdMarkup, LineNum, LinePos);
                }
            }

            done:
            return _nToken;
        }


        /*
         * return the next token inside a dtd markup declaration (between <! and >)
         * and consume it.
         */
        internal int ScanDtdMarkup() {
            char ch;
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;

            //already crossed the line?
            if (_nPos > 0 && _achText[_nPos - 1] == 0 && Read() == 0) {
                _nToken = XmlToken.EOF;
                goto cleanup;
            }

            while (true) {
                _nStart = _nPos;
                switch (ch = _achText[_nPos]) {
                    case (char)0:
                        if (Read() == 0) {
                            _nToken = XmlToken.EOF;
                            goto cleanup;
                        }
                        break;

                    case ' ':
                    case '\t':
                        _nPos++;
                        while (_achText[_nPos] == ch)
                            ++_nPos;
                        _nStartLinePos= this.LinePos;
                         break;

                    case (char)0xa:
                        _nPos++;
                        ++_nLineNum;
                        _nLinePos = _nPos;
                        _nStartLine = _nLineNum;
                        _nStartLinePos= this.LinePos;
                        break;

                    case (char)0xd:
                        _nPos++;
                        ++_nLineNum;
                        if (_achText[_nPos] == 0) Read();
                        if (_achText[_nPos] == 0xa) ++_nPos;
                        _nLinePos = _nPos;
                        _nStartLine = _nLineNum;
                        _nStartLinePos= this.LinePos;
                        break;

                    case '/':
                        _nPos++;
                        if (_achText[_nPos] == 0)
                            Read();
                        if (_achText[_nPos] == '>') {
                            _nPos++;
                            _nToken = XmlToken.EMPTYTAGEND;
                        }
                        else {
                            _nPos++; // point to problem character.
                            throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.TAGEND), LineNum, LinePos);
                        }
                        goto cleanup;

                    case '>':
                        _nPos++;
                        _nToken = XmlToken.TAGEND;
                        goto cleanup;

                    case '?':
                        if (_achText[_nPos + 1] == 0) Read();
                        if (_achText[_nPos + 1] == '>') {
                            _nPos += 2;
                            _nToken = XmlToken.ENDPI;
                        }
                        else {
                            _nPos++;
                            _nToken = XmlToken.QMARK;
                        }
                        goto cleanup;

                    case '=':
                        _nPos++;
                        _nToken = XmlToken.EQUALS;
                        goto cleanup;

                    case '"':
                    case '\'':
                        _nPos++;
                        _chQuoteChar = ch;
                        _nToken = XmlToken.QUOTE;
                        goto cleanup;

                    case '[':
                        _nPos++;
                        _nToken = XmlToken.LSQB;
                        goto cleanup;

                    case ']':
                        _nPos++;
                        if ((_nPos + 1) >= _nUsed)
                            Read();
                        if (_achText[_nPos + 1] == ']' && _achText[_nPos + 2] == '>') {
                            _nPos += 2;
                            _nToken = XmlToken.CDATAEND;
                        }
                        else {
                            _nToken = XmlToken.RSQB;
                        }
                        goto cleanup;

                    case ',':
                        _nPos++;
                        _nToken = XmlToken.COMMA;
                        goto cleanup;

                    case '|':
                        _nPos++;
                        _nToken = XmlToken.OR;
                        goto cleanup;

                    case ')':
                        _nPos++;
                        _nToken = XmlToken.RPAREN;
                        goto cleanup;

                    case '(':
                        _nPos++;
                        _nToken = XmlToken.LPAREN;
                        goto cleanup;

                    case '*':
                        _nPos++;
                        _nToken = XmlToken.ASTERISK;
                        goto cleanup;

                    case '+':
                        _nPos++;
                        _nToken = XmlToken.PLUS;
                        goto cleanup;

                    case '%':
                        _nPos++;
                        ch = _achText[_nPos];
                        if (ch == 0) {
                            if (Read() == 0) {
                                _nToken = XmlToken.PERCENT;
                                goto cleanup;
                            }
                            ch = _achText[_nPos];
                        }

                        if (XmlCharType.IsWhiteSpace(ch))
                            _nToken = XmlToken.PERCENT;
                        else
                            ScanParEntityRef();
                        goto cleanup;

                    case '#':
                        _nPos++;
                        _nToken = XmlToken.HASH;
                        goto cleanup;

                    default: // better be a name then
                        ScanName();
                        goto cleanup;
                }
            }

            cleanup:
            return _nToken;
        }

        /*
         */
        internal int ScanIgnoreSect() {
            char ch;
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;

            while (true) {
                ch = _achText[_nPos];
                switch (ch) {
                    case ' ':
                    case (char)0x9:
                        ++_nPos;
                        _nStartLinePos= this.LinePos;
                        break;
                    case (char)0xa:
                        ++_nPos;
                        ++_nLineNum;
                        _nLinePos = _nPos;
                        _nStartLine = _nLineNum;
                        _nStartLinePos= this.LinePos;
                        break;
                    case (char)0xd:
                        ++_nPos;
                        ++_nLineNum;
                        if (_achText[_nPos] == 0) Read();
                        if (_achText[_nPos] == 0xa) ++_nPos;
                        _nLinePos = _nPos;
                        _nStartLine = _nLineNum;
                        _nStartLinePos= this.LinePos;
                        break;
                    case (char)0:
                        if (Read() == 0) {
                            throw new XmlException(Res.Xml_UnexpectedEOF, XmlToken.ToString(_nToken), LineNum, LinePos);
                        }
                        break;
                    case '>':
                        ++_nPos;
                        if (_nPos > 2 && _achText[_nPos - 2] == ']' && _achText[_nPos - 3] == ']') {
                            _nToken = XmlToken.CDATAEND;
                            goto done;
                        }
                        break;
                    case '[':
                        ++_nPos;
                        if (_nPos > 2 && _achText[_nPos - 2] == '!' && _achText[_nPos - 3] == '<') {
                            _nToken = XmlToken.CONDSTART;
                            goto done;
                        }
                        break;

                    default:
                        ++_nPos;
                        break;
                }
                _nStartLinePos= this.LinePos;

            }
            done:
            return _nToken;
        }

        /* if ReadBufferConsistency is false, the offset of the data in
         *  the buffer can be changed.
         *  meaning the data can be copied from one offset to the other.
         *  if ReadBufferConsistency is true, the offset of the data in
         *  the buffer cannot be changed. If read needs more buffer, it will
         *  have to grow it instead of moving the data around
         */
        internal int ReadBufferConsistency
        {
            set
            {
                if (value < 0) {
                    _ReadBufferConsistency = value;
                }
                else if (_ReadBufferConsistency < 0 || (((value - _nAbsoluteOffset) < _ReadBufferConsistency) && (value - _nAbsoluteOffset) > 0)) {
                    _ReadBufferConsistency = value - _nAbsoluteOffset;
                }
            }
        }

        /*
         * The various ScanXxxx methods are designed to be used in very specific
         * contexts during the parsing of an XML document.   ScanContent is the
         * very first method to call.  This skips whitespace and/or text content
         * until it finds the beginning of the markup character (<) and it returns
         * XmlToken.EOF, XmlToken.WHITESPACE or XmlToken.TEXT or XmlToken.ENTITYREF depending
         * on what it found.
         */
        /*
         * Scan until the next tag
         */
        internal int ScanContent() {
            // eat leading whitespace
            _nStart = _nPos;
            _nStartLine = _nLineNum;
            _nStartLinePos = this.LinePos;
            char ch;

            while (true) {
                ch = _achText[_nPos];
                switch (ch) {
                    case ' ':
                    case (char)0x9:
                        ++_nPos;
                        break;
                    case (char)0xA:
                        ++_nPos;
                        ++_nLineNum;
                        _nLinePos = _nPos;
                        break;
                    case (char)0xD:
                        ++_nPos;
                        ++_nLineNum;
                        if (_achText[_nPos] == 0) Read();
                        if (_achText[_nPos] == 0xA) ++_nPos;
                        _nLinePos = _nPos;
                        break;
                    case '&':
                        if (_nPos > _nStart) {
                            _nToken = XmlToken.WHITESPACE;
                            goto done;
                        }
                        ScanEscape();
                        goto done;
                    case '<':
                        if (_nPos == _nStart)
                            _nToken = XmlToken.NONE;
                        else
                            _nToken = XmlToken.WHITESPACE;
                        goto done;
                    case (char)0:
                        if (Read() == 0) {
                            if (_nPos == _nStart)
                                _nToken = XmlToken.EOF;
                            else
                                _nToken = XmlToken.WHITESPACE;
                            goto done;
                        }
                        break;
                    default:
                        // whitespace leading text content is part of the text.
                        goto pcdata;
                }
            }

            pcdata:
            while (true) {
                ch = _achText[_nPos];
                switch (ch) {
                    case (char)0:
                        if (Read() == 0)
                            goto cleanup;
                        break;
                    case (char)0xA:
                        _nPos++;
                        ++_nLineNum;
                        _nLinePos = _nPos;
                        break;
                    case (char)0xD:
                        _nPos++;
                        ++_nLineNum;
                        if (_achText[_nPos] == 0) Read();
                        if (_achText[_nPos] == 0xA) ++_nPos;
                        _nLinePos = _nPos;
                        break;
                    case '&':
                        if (_nPos > _nStart)
                            goto cleanup; // return text so far.
                        ScanEscape();
                        goto done;
                    case '<':
                        goto cleanup;

                    case ']':
                        if (_achText[_nPos + 1] == 0 || _achText[_nPos + 2] == 0) Read();
                        if (']' == _achText[_nPos + 1] && '>' == _achText[_nPos + 2]) {
                            throw new XmlException(Res.Xml_BadElementData, LineNum, LinePos);
                        }
                        _nPos++;
                        break;
                    case (char)0x9:
                        _nPos++;
                        break;
                    default:
                        if (ch >= 0x0020 && ch <= 0xD7FF || ch >= 0xE000 && ch <= 0xFFFD) {
                            _nPos++;
                            break;
                        }
                        else if (ch >= 0xd800 && ch <=0xdbff) {
                            _nPos++;
                            if (_achText[_nPos] == 0) Read();
                            if (_achText[_nPos] >=0xdc00 && _achText[_nPos] <= 0xdfff)
                            {
                                _nPos++;
                                break;
                            }
                        }
                        throw new XmlException(Res.Xml_InvalidCharacter, XmlException.BuildCharExceptionStr(ch), LineNum, LinePos);
                }
            }

            cleanup:
            _nToken = XmlToken.TEXT;
            done:
            return _nToken;
        }

        /*
         * ScanMarkup is called after ScanContent (assuming ScanContent didn't return
         * XmlToken.EOF) to scan inside a markup declaration (between < and >) and
         * it can return XmlTokens.  Then you call ScanMarkup again, or another Scan
         * method depending on what token you get back.  Possible return tokens are:
         * XmlToken.ENDTAG, XmlToken.PI, XmlToken.COMMENT, XmlToken.CDATA, XmlToken.DECL,
         * XmlToken.EMPTYTAGEND, XmlToken.TAGEND, or XmlToken.XMLNS.  If XMLNS is returned
         * then call ScanXMLNS to scan for any more XMLNS attributes.
         */

        /*
         * Return the next token inside a markup declaration (between < and >)
         * and consume it.
         */
        internal int ScanMarkup() {
            char ch;
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;

            while (true) {
                _nStart = _nPos;
                switch (ch = _achText[_nPos]) {
                    case (char)0:
                        if (Read() == 0) {
                            _nToken = XmlToken.EOF;
                            goto cleanup;
                        }
                        break;
                    case (char)0xA:
                        _nPos++;
                        ++_nLineNum;
                        _nLinePos = _nPos;
                        break;
                    case (char)0xD:
                        _nPos++;
                        ++_nLineNum;
                        if (_achText[_nPos] == 0) Read();
                        if (_achText[_nPos] == 0xA) ++_nPos;
                        _nLinePos = _nPos;
                        break;
                    case '<':
                        ++_nPos;
                        ch = _achText[_nPos];
                        if (ch == 0) {
                            if (Read() == 0)
                                throw new XmlException(Res.Xml_UnexpectedEOF, XmlToken.ToString(XmlToken.NAME), LineNum, LinePos);
                            ch = _achText[_nPos];
                        }

                        switch (ch) {
                            case '/':
                                ++_nPos;
                                _nToken = XmlToken.ENDTAG;
                                goto cleanup;
                            case '?':
                                ++_nPos;
                                ScanName();
                                _nToken = XmlToken.PI;
                                goto cleanup;
                            case '!':
                                ++_nPos;
                                if (_nPos+1 >= _nUsed)
                                    Read();
                                if (_achText[_nPos] == '-' && _achText[_nPos + 1] == '-') {
                                    _nPos += 2;
                                    ScanComment();
                                    goto cleanup;
                                }
                                else if (_achText[_nPos] == '[') {
                                    if ((_nPos + 6) >= _nUsed)
                                        Read();

                                    if (_achText[_nPos + 1] == 'C' &&
                                        _achText[_nPos + 2] == 'D' &&
                                        _achText[_nPos + 3] == 'A' &&
                                        _achText[_nPos + 4] == 'T' &&
                                        _achText[_nPos + 5] == 'A') {
                                        _nPos += 6;
                                        if (_achText[_nPos] != '[') {
                                            _nPos++;
                                            throw new XmlException(Res.Xml_UnexpectedToken,"[", LineNum, LinePos - 1);
                                        }
                                        _nPos++;
                                        ScanCData();
                                        goto cleanup;
                                    }
                                }
                                _nToken = XmlToken.DECL;
                                goto cleanup;
                        }
                        _nToken = XmlToken.TAG;
                        goto cleanup;
                    case '/':
                        _nPos++;
                        if (_achText[_nPos] == 0)
                            Read();
                        if (_achText[_nPos] == '>') {
                            _nPos++;
                            _nToken = XmlToken.EMPTYTAGEND;
                        }
                        else {
                            _nPos++; // point to problem character.
                            throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.TAGEND), LineNum, LinePos -1);
                        }

                        goto cleanup;
                    case '>':
                        _nPos++;
                        _nToken = XmlToken.TAGEND;
                        goto cleanup;
                    case '?':
                        if (_achText[_nPos + 1] == 0) Read();
                        if (_achText[_nPos + 1] == '>') {
                            _nPos += 2;
                            _nToken = XmlToken.ENDPI;
                            goto cleanup;
                        }
                        else {
                            _nPos++; // point to problem character.
                            throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.TAGEND), LineNum, LinePos);
                        }
                    case '=':
                        _nPos++;
                        _nToken = XmlToken.EQUALS;
                        goto cleanup;

                    case '"':
                    case '\'':
                        _nPos++;
                        _chQuoteChar = ch;
                        _nToken = XmlToken.QUOTE;
                        goto cleanup;

                    case '\t':
                        _nPos++;
                        while (_achText[_nPos] == '\t')
                            ++_nPos;
                        break;

                    case ' ':
                        _nPos++;
                        if (_achText[_nPos] == ' ') {
                            ++_nPos;
                            if (_achText[_nPos] == ' ') {
                                ++_nPos;
                                if (_achText[_nPos] == ' ') {
                                    ++_nPos;
                                    if (_achText[_nPos] == ' ') {
                                        ++_nPos;
                                        while (_achText[_nPos] == ' ')
                                            ++_nPos;
                                    }
                                }
                            }
                        }
                        break;
                    default: // better be a name then
                        ScanName();
                        goto cleanup;
                }
            }
            cleanup:
            return _nToken;
        }

        /*
         * Calls ScanMarkup() and returns the expected token, or throws unexpected token
         * if it finds something else.
         */
        internal int ScanToken(int expected) {
            int result = 0;

            result = ScanMarkup();

            if (result != expected) {
                throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(expected), LineNum, LinePos - TextLength);
            }
            return result;
        }

        /*
         * scan till the ENDQUOTE, do basic checking
         * this function is used by XmlParser to return whatever inside the quote
         */
        internal bool ScanLiteral() {
            _nStart = _nPos;
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;
            char ch;
            bool hasEntity = false;

            while (true) {
                switch (ch = _achText[_nPos]) {
                    case (char)0:
                        if (Read() == 0) {
                            throw new XmlException(Res.Xml_UnclosedQuote, LineNum, LinePos);
                        }
                        continue; // without incrementing _nPos;
                    case (char)0xA:
                        ++_nLineNum;
                        _nLinePos = _nPos + 1;
                        break;
                    case (char)0xD:
                        ++_nLineNum;
                        if (_achText[_nPos + 1] == 0) Read();
                        if (_achText[_nPos + 1] == 0xA) ++_nPos;
                        _nLinePos = _nPos + 1;
                        break;
                    case '&':
                        hasEntity = true;
                        break;
                    case '\'':
                    case '"':
                        if (ch == _chQuoteChar) {
                            _nToken = XmlToken.ENDQUOTE;
                            goto done;
                        }
                        break;
                    case '<':
                        throw new XmlException(Res.Xml_BadAttributeChar, XmlException.BuildCharExceptionStr('<'), LineNum, LinePos);
//                break;
                    default:
                        if (ch >= 0x0020 && ch <= 0xD7FF || ch >= 0xE000 && ch <= 0xFFFD || ch == (char)0x9) {
                            break;
                        }
                        else if (ch >= 0xd800 && ch <=0xdbff) {
                            _nPos++;
                            if (_achText[_nPos] == 0) Read();
                            if (_achText[_nPos] >=0xdc00 && _achText[_nPos] <= 0xdfff)
                                break;
                        }
                        throw new XmlException(Res.Xml_InvalidCharacter, XmlException.BuildCharExceptionStr(ch), LineNum, LinePos);
                }
                _nPos++;
            }
            done:
            return hasEntity;
        }

        /*
         * When ScanMarkup returns XmlToken.QUOTE call this method to
         * parse the text of the LITERAL.  This can return a combination of
         * one or more of the following XmlTokens: TEXT, ENTITYREF, NUMENTREF, HEXENTREF,
         * and is terminated by XmlToken.ENDQUOTE.  Must call Advance()
         * after GetText() before calling ScanMarkup().
         */
        internal int ScanLiteral(bool fGenEntity, bool fParEntity, bool fEndQuote, bool fInEntityValue) {
            _nStart = _nPos;
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;
            char ch;

            while (true) {
                switch (ch = _achText[_nPos]) {
                    case (char)0:
                        if (Read() == 0) {
                            if (fParEntity || !fEndQuote) {
                                if (_nPos > _nStart) {
                                    goto cleanup;   //return TEXT so far
                                }
                                else {
                                    _nToken = XmlToken.EOF;
                                    goto done;
                                }
                            }
                            else {
                                throw new XmlException(Res.Xml_UnclosedQuote, LineNum, LinePos);
                            }
                        }
                        continue; // without incrementing _nPos;
//              break;

                    case (char)0xA:
                        ++_nLineNum;
                        _nLinePos = _nPos + 1;
                        break;
                    case (char)0xD:
                        ++_nLineNum;
                        if (_achText[_nPos + 1] == 0) Read();
                        if (_achText[_nPos + 1] == 0xA) ++_nPos;
                        _nLinePos = _nPos + 1;
                        break;
                    case '&':
                        if (fGenEntity) {
                            if (_nPos > _nStart)
                                goto cleanup;   // return the TEXT so far before scanning entity
                            ScanEscape();
                            goto done;
                        }
                        break;
                    case '%':
                        if (fParEntity) {
                            if (_nPos > _nStart)
                                goto cleanup;   // return the TEXT so far before scanning entity
                            ++_nPos;
                            ScanParEntityRef();
                            goto done;
                        }
                        else if (fGenEntity && fInEntityValue) {
                            throw new XmlException(Res.Xml_InvalidCharacter, XmlException.BuildCharExceptionStr('%'), LineNum, LinePos);
                        }
                        break;
                    case '\'':
                    case '"':
                        if (ch == _chQuoteChar && fEndQuote) {
                            if (_nPos > _nStart)
                                goto cleanup;   // return the TEXT so far before returning ENDQUOTE

                            _nToken = XmlToken.ENDQUOTE;
                            goto done;
                        }
                        break;
                    case '<':
                        if (!fParEntity && fGenEntity) {
                            throw new XmlException(Res.Xml_BadAttributeChar, XmlException.BuildCharExceptionStr('<'), LineNum, LinePos);
                        }
                        break;
                    case (char)0x9:
                        break;
                    default:
                        if (ch >= 0x0020 && ch <= 0xD7FF || ch >= 0xE000 && ch <= 0xFFFD) {
                            break;
                        }
                        else if (ch >= 0xd800 && ch <=0xdbff) {
                            _nPos++;
                            if (_achText[_nPos] == 0) Read();
                            if (_achText[_nPos] >=0xdc00 && _achText[_nPos] <= 0xdfff)
                                break;
                        }
                        throw new XmlException(Res.Xml_InvalidCharacter,XmlException.BuildCharExceptionStr(ch), LineNum, LinePos);
                }
                _nPos++;
            }
            cleanup:
            _nToken = XmlToken.TEXT;
            done:
            return _nToken;
        }


        /*
         * After getting the XmlToken.NAME from ScanMarkup for a PI, call ScanPI
         * to scan the rest of the PI contents.
         */
        internal void ScanPI() {
            _nStart = _nPos;
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;
            bool ws = true;
            char ch;

            while (true) {
                ch = _achText[_nPos];
                switch (ch) {
                    case (char)0:
                        if (Read() == 0) {
                            throw new XmlException(Res.Xml_UnexpectedEOF, XmlToken.ToString(XmlToken.PI), LineNum, LinePos);
                        }
                        break;

                    case ' ':
                    case '\t':
                        break;

                    case (char)0xA:
                        ++_nLineNum;
                        _nLinePos = _nPos + 1;
                        break;

                    case (char)0xC:
                        // Form Feed
                        throw new XmlException(Res.Xml_UnexpectedCharacter, XmlException.BuildCharExceptionStr(ch), LineNum, LinePos);

                    case (char)0xD:
                        ++_nLineNum;
                        if (_achText[_nPos + 1] == 0) Read();
                        if (_achText[_nPos + 1] == 0xA) ++_nPos;
                        _nLinePos = _nPos + 1;
                        break;
                    case '?':
                        if (ws) {
                            _nStart = _nPos;
                            _nStartLine = _nLineNum;
                            _nStartLinePos= this.LinePos;
                            ws = false;
                        }
                        if (_achText[_nPos + 1] == 0) Read();
                        if (_achText[_nPos + 1] == '>') {
                            goto cleanup;
                        }
                        break;
                    default:
                        if (ch >= 0x0020 && ch <= 0xD7FF || ch >= 0xE000 && ch <= 0xFFFD || ch == (char)0x9) {
                            if (ws) {
                                _nStart = _nPos;
                                _nStartLine = _nLineNum;
                                _nStartLinePos= this.LinePos;
                                ws = false;
                            }
                            break;
                        }
                        else if (ch >= 0xd800 && ch <=0xdbff) {
                            if (ws) {
                                _nStart = _nPos;
                                _nStartLine = _nLineNum;
                                _nStartLinePos= this.LinePos;
                                ws = false;
                            }
                            _nPos++;
                            if (_achText[_nPos] == 0) Read();
                            if (_achText[_nPos] >=0xdc00 && _achText[_nPos] <= 0xdfff) {
                                break;
                            }
                        }
                        throw new XmlException(Res.Xml_InvalidCharacter, XmlException.BuildCharExceptionStr(ch), LineNum, LinePos);
                }
                ++_nPos;
            }
            cleanup:
            _nToken = XmlToken.TEXT;
        }

        /*
         * This is called when ScanContent returns XmlToken.ENTITYREF.
         * It returns the Unicode character equivalent if it was a builtin entity,
         * otherwise it returns 0 and the token is the name of a general entity.
         * (must call Advance after querying GetText)
         */
        internal char ScanNamedEntity() {
            int tempLineNum = LineNum;
            int tempLinePos = LinePos;
            _nStart = _nPos;
            char result = (char)0;
            // prepare for maximum lookahead of 4 chars.
            if ((_nPos + 4) >= _nUsed) Read();
            char ch = _achText[_nPos];
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;

            switch (ch) {
                case 'l':
                    if (_achText[_nPos + 1] == 't' && _achText[_nPos + 2] == ';') {
                        _nPos += 2;
                        result = '<';
                        goto cleanup;
                    }
                    break;
                case 'g':
                    if (_achText[_nPos + 1] == 't' && _achText[_nPos + 2] == ';') {
                        _nPos += 2;
                        result = '>';
                        goto cleanup;
                    }
                    break;
                case 'a':
                    if (_achText[_nPos + 1] == 'm' && _achText[_nPos + 2] == 'p' && _achText[_nPos + 3] == ';') {
                        _nPos += 3;
                        result = '&';
                        goto cleanup;
                    }
                    if (_achText[_nPos + 1] == 'p' && _achText[_nPos + 2] == 'o' && _achText[_nPos + 3] == 's' && _achText[_nPos + 4] == ';') {
                        _nPos += 4;
                        result = '\'';
                        goto cleanup;
                    }
                    break;
                case 'q':
                    if (_achText[_nPos + 1] == 'u' && _achText[_nPos + 2] == 'o' && _achText[_nPos + 3] == 't' && _achText[_nPos + 4] == ';') {
                        _nPos += 4;
                        result = '"';
                        goto cleanup;
                    }
                    break;
            }
            try {
                ScanName();
            } catch {
                throw new XmlException(Res.Xml_ErrorParsingEntityName, tempLineNum, tempLinePos);
            }
            // #50921
            if (_NamespaceSupport && _nColon != -1)
                throw new XmlException(Res.Xml_BadNameChar, XmlException.BuildCharExceptionStr(':'));

            if (_achText[_nPos] == 0) Read();
            if (_achText[_nPos] != ';') {
                _nPos++; // point to problem character.
                throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.SEMICOLON), LineNum, LinePos-1);
            }

            cleanup:
            return result;
        }

        internal void Surrogates(int xmlChar, ref char[] output) {
            xmlChar -= 0x10000;

            int highStart = 0xd800;
            int lowStart = 0xdc00;

            int low = lowStart + xmlChar % 1024;
            int high = highStart + xmlChar / 1024;
            output[0] = (char)high;
            output[1] = (char)low;
            return;
        }

        /*
         * This is called when ScanContent returns XmlToken.NUMENTREF.
         * It returns the character value of the numeric entity.
         */
        internal char[] ScanDecEntity() {
            int result = 0;
            int digit;
            _nStart = _nPos;
            _nStartLine = _nLineNum;
            _nStartLinePos = this.LinePos;
            char ch;

            while (true) {
                if (_achText[_nPos] == 0) Read();
                ch = _achText[_nPos];
                if (XmlCharType.IsDigit(ch)) {
                    digit =(ch - '0');
                }
                else if (ch != ';') {
                    _nPos++; // point to problem character.
                    throw new XmlException(Res.Xml_BadDecimalEntity, LineNum, LinePos - 1);
                }
                else {
                    _nPos++; // skip the ';'
                    goto cleanup;
                }

                if (result > ((XmlCharType.MAXCHARDATA - digit)/10)) {
                    throw new XmlException(Res.Xml_NumEntityOverflow, _nStartLine, _nStartLinePos);
                }

                result = (result*10)+digit;
                _nPos++;
            }
            cleanup:
            char[] output = null;
            if (result > char.MaxValue) {
                output = new char[2];
                Surrogates(result, ref output);
                if (!_Normalization)
                    return output;
                ch = output[0];
                if (ch >= 0xd800 && ch <=0xdbff) {
                    ch = output[1];
                    if (ch >=0xdc00 && ch <= 0xdfff)
                        return output;
                }
                throw new XmlException(Res.Xml_InvalidCharacter, XmlException.BuildCharExceptionStr(ch), _nStartLine, _nStartLinePos);
            }
            else {
                output = new char[1];
                output[0] = ch = (char)result;
                if (!_Normalization)
                    return output;
                if (ch >= 0x0020 && ch <= 0xD7FF || ch == 0xD || ch == 0xA || ch >= 0xE000 && ch <= 0xFFFD || ch == (char)0x9)
                    return output;
                throw new XmlException(Res.Xml_InvalidCharacter,XmlException.BuildCharExceptionStr(ch), _nStartLine, _nStartLinePos);
            }
        }


        /*
         * This is called when ScanContent returns XmlToken.NUMENTREF.
         * It returns the character value of the hexadecimal entity.
         */
        internal char[] ScanHexEntity() {
            int result = 0;
            int digit = 0;
            _nStart = _nPos;
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;
            char ch;
            while (true) {
                if (_achText[_nPos] == 0) Read();
                ch = _achText[_nPos];
                if (XmlCharType.IsDigit(ch)) {
                    digit = (ch - '0');
                }
                else if (ch >= 'a' && ch <= 'f') {
                    digit = (ch-'a') + 10;
                }
                else if (ch >= 'A' && ch <= 'F') {
                    digit = (ch-'A') + 10;
                }
                else if (ch != ';') {
                    _nPos++;  // skip the ';'
                    throw new XmlException(Res.Xml_BadHexEntity, LineNum, LinePos - 1);
                }
                else {
                    _nPos++;  // skip the ';'
                    goto cleanup;
                }
                if (digit >= 0) {
                    if (result > ((XmlCharType.MAXCHARDATA - digit)/16)) {
                        throw new XmlException(Res.Xml_NumEntityOverflow, _nStartLine, _nStartLinePos);
                    }
                    result = (result*16)+digit;
                }
                _nPos++;
            }
            cleanup:
            char[] output = null;
            if (result > char.MaxValue) {
                output = new char[2];
                Surrogates(result, ref output);
                if (!_Normalization)
                    return output;
                ch = output[0];
                if (ch >= 0xd800 && ch <=0xdbff) {
                    ch = output[1];
                    if (ch >=0xdc00 && ch <= 0xdfff)
                        return output;
                }
                throw new XmlException(Res.Xml_InvalidCharacter, XmlException.BuildCharExceptionStr(ch), _nStartLine, _nStartLinePos);
            }
            else {
                output = new char[1];
                output[0] = ch = (char)result;
                if (!_Normalization)
                    return output;
                if (ch >= 0x0020 && ch <= 0xD7FF || ch == 0xD || ch == 0xA || ch >= 0xE000 && ch <= 0xFFFD || ch == (char)0x9)
                    return output;
                throw new XmlException(Res.Xml_InvalidCharacter, XmlException.BuildCharExceptionStr(ch), _nStartLine, _nStartLinePos);
            }
        }

        /*
         * For performance reasons the parser calls Advance in certain
         * situations where the token text did not include all of the
         * input.  For example, comments include "-->" after the body
         * so the parser calls GetText() to get the body then Advance(3)
         * to skip over the "-->" string.
         */
        internal void Advance(int amount) {
            _nPos += amount;
        }

        internal void Advance() {
            Advance(1);
        }

        internal int Colon() {
            return _nColon;
        }

        internal char QuoteChar() {
            return _chQuoteChar;
        }

        /*
         * Used internally by various other internal scan methods.
         */
        internal bool ScanPIName() {
            bool hasBody = true;
            char ch;

            while (true) {
                ch = _achText[_nPos];
                // In XML these are all the things that legally terminate a Name token.
                // Anything else will result in a BadNameChar exception.
                switch (ch) {
                    case (char)0:
                        if (Read() == 0) {
                            //_nToken = XmlToken.EOF;
                            goto cleanup;
                        }
                        break;
                    case (char)0x20:
                    case (char)0x09:
                    case (char)0x0d:
                    case (char)0x0a:
                        goto cleanup;
                    case '?':
                        if ((_achText[_nPos + 1] == (char) 0) && Read() == 0) {
                            throw new XmlException(Res.Xml_BadNameChar, XmlException.BuildCharExceptionStr(ch), LineNum, LinePos);
                        }

                        if (_achText[_nPos + 1] != '>') {
                            throw new XmlException(Res.Xml_BadNameChar, XmlException.BuildCharExceptionStr(ch), LineNum, LinePos);
                        }
                        hasBody = false;
                        goto cleanup;
                    default:
                        _nPos++; // ok, so move to the next char then.
                        if (! XmlCharType.IsNameChar(ch))
                            throw new XmlException(Res.Xml_BadNameChar, XmlException.BuildCharExceptionStr(ch), LineNum, LinePos - 1);
                        break;
                }
            }
            cleanup:
            if (_nPos <= _nStart) {
                throw new XmlException(Res.Xml_UnexpectedEOF,XmlToken.ToString(XmlToken.NAME), LineNum, LinePos);
            }
            if (_NamespaceSupport && _nColon != -1 && _nColon == _nPos - _nStart + 1) {
                //
                // ':' can't be the last one
                //
                throw new XmlException(Res.Xml_BadNameChar, XmlException.BuildCharExceptionStr(ch), LineNum, LinePos - 1);
            }
            return hasBody;
        }

        /*
         * Used internally by various other internal scan methods.
         */
        internal void ScanNameWOCharChecking() {

            _nStart = _nPos;
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;
            _nColon = -1;
            char ch;

            ch = _achText[_nPos];
            if (ch == 0) {
                if (Read() == 0)
                    throw new XmlException(Res.Xml_UnexpectedEOF,XmlToken.ToString(XmlToken.NAME), LineNum, LinePos);
                else
                    ch = _achText[_nPos++];
            }
            else {
                _nPos++;
            }

            while (true) {
                ch = _achText[_nPos];
                // In XML these are all the things that legally terminate a Name token.
                // Anything else will result in a BadNameChar exception.
                switch (ch) {
                    case (char)0:
                        if (Read() == 0) {
                            //_nToken = XmlToken.EOF;
                            goto cleanup;
                        }
                        break;
                    case ' ':
                    case '\n':
                    case '\r':
                    case '\t':
                    case '>':
                    case '/':
                    case '=':
                    case ';':
                    case '?':
                    case '*':
                    case '+':
                    case '(':
                    case ')':
                    case ',':
                    case '|':
                    case '[':
                    case ']':
                    case '%':
                        goto cleanup;

                    default:
                        _nPos++; // ok, so move to the next char then.
                        break;
                }
            }
            cleanup:
            if (_nPos <= _nStart) {
                throw new XmlException(Res.Xml_UnexpectedEOF,XmlToken.ToString(XmlToken.NAME), LineNum, LinePos);
            }
        }

        /*
         * Used internally by various other internal scan methods.
         */
        private void ScanName() {

            _nStart = _nPos;
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;
            _nColon = -1;
            char ch;

            ch = _achText[_nPos];
            if (ch == 0) {
                if (Read() == 0)
                    throw new XmlException(Res.Xml_UnexpectedEOF,XmlToken.ToString(XmlToken.NAME), LineNum, LinePos);
                else
                    ch = _achText[_nPos++];
            }
            else {
                _nPos++;
            }
            // The first character of a name has special requirements.
            if (!XmlCharType.IsStartNameChar(ch)) {
                if (InDTD && XmlCharType.IsNameChar(ch)) {
                    _nToken = XmlToken.NMTOKEN;
                }
                else {
                    throw new XmlException(Res.Xml_BadStartNameChar, XmlException.BuildCharExceptionStr(ch), LineNum, LinePos - 1);
                }
            }
            else {
                if (_NamespaceSupport && ch == ':') {
                    if (InDTD)
                        _nToken = XmlToken.NMTOKEN;
                    else
                        throw new XmlException(Res.Xml_BadNameChar, XmlException.BuildCharExceptionStr(ch), LineNum, LinePos - 1);
                }
                else {
                    _nToken = XmlToken.NAME;
                }
            }

            while (true) {
                ch = _achText[_nPos];
                // In XML these are all the things that legally terminate a Name token.
                // Anything else will result in a BadNameChar exception.
                switch (ch) {
                    case (char)0:
                        if (Read() == 0) {
                            //_nToken = XmlToken.EOF;
                            goto cleanup;
                        }
                        break;
                    case ':':
                        if (_NamespaceSupport && _nColon != -1)
                            throw new XmlException(Res.Xml_BadNameChar, XmlException.BuildCharExceptionStr(ch), LineNum, LinePos);
                        _nColon = _nPos - _nStart;
                        _nPos++;
                        break;
                    case ' ':
                    case '\n':
                    case '\r':
                    case '\t':
                    case '>':
                    case '/':
                    case '=':
                    case ';':
                    case '?':
                    case '*':
                    case '+':
                    case '(':
                    case ')':
                    case ',':
                    case '|':
                    case '[':
                    case ']':
                    case '%':
                        goto cleanup;

                    default:
                        if (! XmlCharType.IsNameChar(ch)) {
                            throw new XmlException(Res.Xml_BadNameChar, XmlException.BuildCharExceptionStr(ch), LineNum, LinePos);
                        }
                        _nPos++; // ok, so move to the next char then.
                        break;
                }
            }
            cleanup:
            if (_nPos <= _nStart) {
                throw new XmlException(Res.Xml_UnexpectedEOF,XmlToken.ToString(XmlToken.NAME), LineNum, LinePos);
            }
            if (_NamespaceSupport && _nColon != -1 && _nColon == _nPos - _nStart - 1 && XmlToken.NMTOKEN != _nToken) {
                //
                // ':' can't be the last one unless it is an NMToken
                //
                if (InDTD) {
                    _nToken = XmlToken.NMTOKEN;
                    return;
                }
                throw new XmlException(Res.Xml_BadNameChar, XmlException.BuildCharExceptionStr(':'), LineNum, LinePos - 1);
            }
        }


        /*
         * Scan until end of comment.
         */
        private void ScanComment() {
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;
            _nStart = _nPos;
            int startLinePos = _nLinePos;
            int start = _nStart;
            char ch;

            while (true) {
                ch = _achText[_nPos];
                switch (ch) {
                    case (char)0:
                        if (Read() == 0) {
                            throw new XmlException(Res.Xml_UnexpectedEOF,XmlToken.ToString(XmlToken.COMMENT), LineNum, LinePos);
                        }
                        continue; // without incrementing _nPos;
                    case (char)0xA:
                        ++_nLineNum;
                        _nLinePos = _nPos + 1;
                        break;
                    case (char)0xD:
                        ++_nLineNum;
                        if (_achText[_nPos + 1] == 0) Read();
                        if (_achText[_nPos + 1] == 0xA) ++_nPos;
                        _nLinePos = _nPos + 1;
                        break;
                    case '-':
                        if (_achText[_nPos + 1] == 0) Read();
                        if (_achText[_nPos + 1] == '-') {
                            if (_achText[_nPos + 2] == 0) Read();
                            if (_achText[_nPos + 2] == '>') {
                                goto cleanup;
                            }
                            _nPos+=3;
                            throw new XmlException(Res.Xml_BadComment, LineNum, LinePos);
                        }
                        break;
                    case (char)0x9:
                        break;
                    default:
                        if (ch >= 0x0020 && ch <= 0xD7FF || ch >= 0xE000 && ch <= 0xFFFD) {
                            break;
                        }
                        else if (ch >= 0xd800 && ch <=0xdbff) {
                            _nPos++;
                            if (_achText[_nPos] == 0) Read();
                            if (_achText[_nPos] >=0xdc00 && _achText[_nPos] <= 0xdfff)
                                break;
                        }
                        throw new XmlException(Res.Xml_InvalidCharacter, XmlException.BuildCharExceptionStr(ch), LineNum, LinePos);
                }
                ++_nPos;
            }
            cleanup:
            _nToken = XmlToken.COMMENT;
        }

        private void ScanEscape() {
            // skip over the '&'
            _nStart = ++_nPos;
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;
            loop:
            switch (_achText[_nPos]) {
                case (char)0:
                    if (Read() == 0)
                        throw new XmlException(Res.Xml_UnexpectedEOF,XmlToken.ToString(XmlToken.ENTITYREF), LineNum, LinePos);
                    goto loop;
                case '#':
                    _nPos++;
                    if (_achText[_nPos] == 0) Read();
                    if (_achText[_nPos] == 'x') {
                        _nPos++;
                        _nToken = XmlToken.HEXENTREF;
                    }
                    else
                        _nToken = XmlToken.NUMENTREF;
                    break;

                default:
                    _nToken = XmlToken.ENTITYREF;
                    break;
            }
        }

        /*
         * Scan until end of cdata block.
         */
        private void ScanCData() {
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;
            _nStart = _nPos;
            char ch;

            while (true) {
                ch = _achText[_nPos];
                switch (ch) {
                    case (char)0:
                        if (Read() == 0)
                            throw new XmlException(Res.Xml_UnexpectedEOF,XmlToken.ToString(XmlToken.CDATA), LineNum, LinePos);
                        continue; // without incrementing _nPos;
                    case (char)0xA:
                        ++_nLineNum;
                        _nLinePos = _nPos + 1;
                        break;
                    case (char)0xD:
                        ++_nLineNum;
                        if (_achText[_nPos + 1] == 0) Read();
                        if (_achText[_nPos + 1] == 0xA) ++_nPos;
                        _nLinePos = _nPos +1;
                        break;
                    case ']':
                        if (_achText[_nPos + 1] == 0) Read();
                        if (_achText[_nPos + 1] == ']') {
                            if (_achText[_nPos + 2] == 0) Read();
                            if (_achText[_nPos + 2] == '>') {
                                goto cleanup;
                            }
                        }
                        break;
                    case (char)0x9:
                        break;
                    default:
                        if (ch >= 0x0020 && ch <= 0xD7FF || ch >= 0xE000 && ch <= 0xFFFD) {
                            break;
                        }
                        else if (ch >= 0xd800 && ch <=0xdbff) {
                            _nPos++;
                            if (_achText[_nPos] == 0) Read();
                            if (_achText[_nPos] >=0xdc00 && _achText[_nPos] <= 0xdfff)
                                break;
                        }
                        throw new XmlException(Res.Xml_InvalidCharacter, XmlException.BuildCharExceptionStr(ch), LineNum, LinePos);
                }
                ++_nPos;
            }
            cleanup:
            _nToken = XmlToken.CDATA;
        }

        private int GetChars(byte[] srcBuffer, ref int srcOffset, int srcLen, char[] destBuffer, int destOffset, bool zeroedOut)
        {
            if (null == _Decoder || srcOffset == srcBuffer.Length) {
                return 0;
            }
            if (_Reset) {
                _PreviousError = false;
                _Reset = false;

                int newSrcOffset = DetermineEncoding(srcBuffer, srcOffset);
                srcOffset += newSrcOffset;
                srcLen -= newSrcOffset;
                //Call GetChars recursively because there could be more than two documents in this stream and the documents could be really small.
                return GetChars(srcBuffer, ref srcOffset, srcLen, destBuffer, destOffset, false);
            }

            int result;
            try {
                result = _Decoder.GetChars(srcBuffer, srcOffset, srcLen, destBuffer, destOffset);
                _PreviousError = false;
                return result;
            }
            catch (Exception e) {
                if (_PreviousError) {
                    // We have already Encountered an error before and the user has not called reset since then so this must be an
                    // error in the data and we should surface it.
                    if ( e is ArgumentException && ((ArgumentException)e).ParamName == null )  {
                        throw new XmlException(Res.Xml_InvalidCharInThisEncoding, LineNum, LinePos );
                    }
                    else
                        throw e;
                }
                // This is the first time we are seeing this error. We should figure out how many bytes to decode also mark the _PreviousError flag
                _PreviousError = true;
                _PreviousErrorOffset = srcOffset;
                return FigureOutNewBytes(srcBuffer, ref _PreviousErrorOffset, srcLen, destBuffer, destOffset, zeroedOut);
            }

        }


        private int FigureOutNewBytes(byte[] srcBuffer, ref int srcOffset, int srcLen, char[] destBuffer, int destOffset, bool zeroedOut) {
            if (!zeroedOut) {
                for (int i = destOffset; i < destBuffer.Length; i++) {
                    destBuffer[i] = (char)0;
                }

                int result;
                try {
                    result = _Decoder.GetChars(srcBuffer, srcOffset, srcLen, destBuffer, destOffset);
                    //We throw Exception instead of using Debug.Assert because the configuration system uses this code and it cause them
                    // to have a cyclic dependency if we use Debug.Assert
                    throw new Exception("Unexpected Internal State");
                }
                catch (Exception) {
                    // do nothing;
                }
            }

            int j = destOffset;
            while ((char)0 != destBuffer[j] && j < destBuffer.Length) {
                j++;
            }
            if (destBuffer.Length == j) {
                //We throw Exception instead of using Debug.Assert because the configuration system uses this code and it cause them
                // to have a cyclic dependency if we use Debug.Assert
                throw new Exception("Unexpected Internal State");
            }
            int byteCount = _Encoding.GetByteCount(destBuffer, destOffset, j - destOffset);
            srcOffset += byteCount;
            //srcLen -= byteCount;

            return j - destOffset;

        }


        private int DetermineEncoding(byte[] srcBuffer, int srcOffset) {
            _Encoding = null;
            switch(AutoDetectEncoding(srcBuffer, srcOffset))
            {
            case UniCodeBE://2:
                _Encoding = Encoding.BigEndianUnicode;
                break;
            case UniCode: //3:
                _Encoding = Encoding.Unicode;
                break;
            case UCS4BE: //4:
            case UCS4BEB: // 5:
                _Encoding = Ucs4Encoding.UCS4_Bigendian;
                break;

            case UCS4: //6:
            case UCS4B: //7:
                _Encoding = Ucs4Encoding.UCS4_Littleendian;
                break;

            case UCS434://8:
            case UCS434B: //9:
                _Encoding = Ucs4Encoding.UCS4_3412;
                break;
            case UCS421: //10:
            case UCS421B://11:
                _Encoding = Ucs4Encoding.UCS4_2143;
                break;

            case EBCDIC: //12: ebcdic
                throw new XmlException(Res.Xml_UnknownEncoding, "ebcdic", LineNum, LinePos);
                //break;
            case UTF8: //13:
                _EncodingSetByDefault = true;
                _Encoding = new UTF8Encoding(true);
                break;
            default:
                _Encoding = new UTF8Encoding(true, true);

                break;
            }

            _Decoder = _Encoding.GetDecoder();
            _PermitEncodingChange = true;

            if(_Encoding != null)
                _nCodePage = _Encoding.CodePage;
            //_achText = new char[_nSize+1];

            int startDecodingIndex = 0;
            int preambleLength = 0;
            try {
                byte[] preamble = _Encoding.GetPreamble();
                preambleLength = preamble.Length;
                bool hasByteOrderMark = true;
                for (int i = srcOffset; i < srcOffset + preambleLength && hasByteOrderMark; i++) {
                    hasByteOrderMark &= (srcBuffer[i] == preamble[i - srcOffset]);
                }
                if (hasByteOrderMark) {
                    startDecodingIndex = preambleLength;
                }
            }
            catch (Exception) {
            }

            return startDecodingIndex;

        }

        internal void Reset() {
            _Reset = true;

            if (null == _StreamReader) {
                return;
            }

            if (_nUsed == _nPos) {
                if (0 == Read()) {
                    return;
                }
            }
            else {
                int byteCount = _Encoding.GetByteCount(_achText, 0, _nPos);
                _ByteStart = _ByteStart + byteCount;
                _ByteDocumentStart = _ByteStart;
                _nUsed = 0;
                _nPos = 0;
                _nUsed = GetChars(_ByteBuffer, ref _ByteStart, _ByteLen - _ByteStart, _achText, _nPos, false);
                _achText[_nUsed]=(char)0;
            }
            _Reset = false;
        }

        private int Read() {

            if (null != _StreamReader && _PreviousError) {
                _ByteStart = _PreviousErrorOffset;
                if (_Reset) {
                        _nUsed = GetChars(_ByteBuffer, ref _ByteStart, _ByteLen - _ByteStart, _achText, 0, false);
                        _nPos = 0;
                        _nStart = 0;
                        _achText[_nUsed] = (char)0;
                        return _nUsed;
                }
                return GetChars(_ByteBuffer, ref _ByteStart, _ByteLen - _ByteStart, _achText, _nUsed, false);
            }

            int result = 0;

            // If we are reading from a stream, then we
            // allocate a buffer to read bytes into
            if (_StreamReader != null || _TextReader != null) {
                // if ReadBufferConsistency is false, the offset of the data in
                // the buffer can be changed.
                // meaning the data can be copied from one offset to the other.
                // if ReadBufferConsistency is true, the offset of the data in
                // the buffer cannot be changed. If read needs more buffer, it will
                // have to grow it instead of moving the data around
                if (_ReadBufferConsistency < 0  && _nStart > 0 && (_nUsed - _nStart + 20) < _nSize) {
                    if (_nUsed > _nStart)
                        System.Array.Copy(_achText, _nStart, _achText, 0, _nUsed - _nStart);
                    _nUsed -= _nStart;
                    _nLinePos -= _nStart;
                    _nPos -= _nStart;
                    _nAbsoluteOffset += _nStart;
                    _nStart = 0;
                }
                else if (_ReadBufferConsistency > 0 && (_nUsed - _ReadBufferConsistency + 20) < _nSize) {
                    if (_nUsed > _ReadBufferConsistency)
                        System.Array.Copy(_achText, _ReadBufferConsistency, _achText, 0, _nUsed - _ReadBufferConsistency);
                    _nUsed -= _ReadBufferConsistency;
                    _nLinePos -= _ReadBufferConsistency;
                    _nStart -= _ReadBufferConsistency;
                    _nPos -= _ReadBufferConsistency;
                    _nAbsoluteOffset += _ReadBufferConsistency ;
                    _ReadBufferConsistency = 0;
                }

                if (_nSize <= (_nUsed+20)) {
                    // have to grow the buffer, so let's double it.
                    _nSize = _nSize * 2;
                    char[] newbuf = new char[_nSize+1];
                    System.Array.Copy(_achText, (_ReadBufferConsistency >= 0) ? _ReadBufferConsistency:_nStart, newbuf, 0, (_ReadBufferConsistency >= 0) ? _nUsed - _ReadBufferConsistency:_nUsed - _nStart);
                    _achText = newbuf;
                    if (_ReadBufferConsistency > 0) {
                        _nUsed -= _ReadBufferConsistency;
                        _nLinePos -= _ReadBufferConsistency;
                        _nStart -= _ReadBufferConsistency;
                        _nPos -= _ReadBufferConsistency;
                        _nAbsoluteOffset += _ReadBufferConsistency;
                        _ReadBufferConsistency = 0;
                    }
                    else  if (_ReadBufferConsistency < 0) {
                        _nUsed -= _nStart;
                        _nLinePos -= _nStart;
                        _nPos -= _nStart;
                        _nAbsoluteOffset += _nStart;
                        _nStart = 0;
                    }
                    if (_StreamReader != null) {
                        byte[] newbytebuf = new byte[_nSize+1];
                        _ByteBuffer = newbytebuf;
                    }
                }

                // Try to read in as much information as will fit into the
                // new buffer.
                if (_StreamReader != null ) {
                    int length = _nSize - _nUsed;
                    _ByteLen = _StreamReader.Read(_ByteBuffer, 0, length);
                    _ByteStart = 0;
                    if ( 0 == _ByteLen) {
                        result = 0;
                    }
                    else {
                        result = GetChars(_ByteBuffer, ref _ByteStart, _ByteLen, _achText, _nUsed, false);
                    }
                    _nUsed += result;
                    _achText[_nUsed] = (char)0;

                }
                else if (_TextReader != null) {
                    result = _TextReader.Read(_achText, _nUsed, _nSize - _nUsed);
                    if (0 >= result)
                    {
                        result = 0;
                    }
                    _nUsed += result;
                    _achText[_nUsed] = (char)0;
                }
            }
            return result;
        }

        internal int GetCharCount(int count, IncrementalReadType readType) {
            int loopCount;
            switch (readType) {
            case IncrementalReadType.Base64:
                loopCount = count * 8;
                loopCount = (loopCount % 6 > 0 ? (loopCount / 6) + 1 : loopCount / 6);
                if (_Base64Decoder != null) {
                    loopCount -= _Base64Decoder.BitsFilled / 6;
                 }
                 break;
            case IncrementalReadType.BinHex:
                loopCount = count * 2;
                if (_BinHexDecoder != null) {
                    loopCount -= (_BinHexDecoder.BitsFilled /4);
                }
                break;
            default:
                loopCount = count;
                break;
            }
            return loopCount;
        }
        internal int IncrementalRead(object destBuffer, int index, int count, XmlTextReader reader,IncrementalReadType readType ) {
            int nStart = _nPos;
            int initialDestStartIndex = index;
            int loopCount;
            int offset = index;
            int lineNumber = LineNum;
            int linePosition = LinePos;
            bool lastCharD = false;
            int i;

            loopCount = GetCharCount(count, readType);
            try {
                for(i = 0; i < loopCount; i++) {
                    if (_nPos == _nUsed) {
                                index = IncrementalReadHelper(destBuffer, index, readType, nStart, count - index + offset);
                                _nStart = _nPos;
                                int diff = count - index + offset ;
                                if (IncrementalReadType.Base64 == readType || IncrementalReadType.BinHex == readType ) {
                                    loopCount += GetCharCount(diff , readType);
                                }
                                if (diff == 0)
                                    return index - initialDestStartIndex;
                                if (Read() == 0)
                                   throw new XmlException(Res.Xml_UnexpectedEOF, XmlToken.ToString(XmlToken.TAG), LineNum, LinePos);
                                nStart = _nPos;
                                lineNumber = LineNum;
                                linePosition = LinePos;

                     }

                    switch(_achText[_nPos]) {
                        case '<':
                            {
                                index = IncrementalReadHelper(destBuffer, index, readType, nStart, count - index + offset);
                                int diff = count - index + offset ;
                                if (IncrementalReadType.Base64 == readType || IncrementalReadType.BinHex == readType ) {
                                    loopCount += GetCharCount(diff , readType);
                                }
                                if (diff == 0)
                                    return index - initialDestStartIndex;
                            }

                            // Refill buffer to ensure that the calls from ContinueReadFromBuffer will not cause
                            // The buffer size to increase
                            _nStart = _nPos;
                            Read(); //as its not end of input we just calling read to make sure buffer is enough full so no need to check the result

                            nStart = _nPos;
                            lineNumber = LineNum;
                            linePosition = LinePos;

                            // set ReadBufferConsistency in case name of the tag is bigger than 4k. Highly unlikely but possible.
                            if (reader.ContinueReadFromBuffer(ScanMarkup())) {
                                // We can continue filling up the buffer but _nPos might have moved.
                                if (nStart < _nPos) {
                                    // Some stuff was read by the textReader;
                                    if (_nPos - nStart > loopCount - (index - offset)) {
                                        _nPos = nStart + loopCount - (index - offset);
                                        i = loopCount - 1;
                                        _nStart = _nPos;
                                    }
                                    else {
                                        i += _nPos - nStart -1;
                                    }
                                } //if (nStart < _nPos)
                            }
                            else {
                                return index - initialDestStartIndex;
                            } // if ... else ...
                            lastCharD = false;
                            break;
                        case (char)0xA:
                            if (!lastCharD) {
                                ++_nLineNum;
                            }
                            _nPos++;
                            _nLinePos = _nPos;
                            lastCharD = false;
                            break;
                        case (char)0xD:
                            ++_nLineNum;
                            lastCharD = true;
                            _nPos++;
                            _nLinePos = _nPos;
                            break;
                        default:
                            _nPos++;
                            lastCharD = false;
                            break;
                    }

                    if (i == loopCount -1) {
                        index = IncrementalReadHelper(destBuffer, index, readType, nStart, count - index + offset);

                        int diff = count - index + offset ;

                        if (IncrementalReadType.Base64 == readType || IncrementalReadType.BinHex == readType ) {
                          loopCount += GetCharCount(diff , readType);
                        }
                        nStart = _nStart = _nPos;
                        lineNumber = LineNum;
                        linePosition = LinePos;

                        if (diff == 0)
                            return index - initialDestStartIndex;
                    }
                }
            }
            catch (XmlException e) {
                throw new XmlException(e.ErrorCode, e.msg, lineNumber, linePosition);
            }

            return index - initialDestStartIndex;
        }

        private int IncrementalReadHelper(object destBuffer, int destIndex, IncrementalReadType readType, int srcIndex, int count) {
            switch (readType) {
                case IncrementalReadType.Chars:
                    char[] charBuffer = destBuffer as char[];
                    Array.Copy(_achText, srcIndex, charBuffer, destIndex, _nPos - srcIndex);
                    return destIndex + (_nPos - srcIndex);

                case IncrementalReadType.Base64:
                    byte[] base64ByteBuffer = destBuffer as byte[];
                    if (null == _Base64Decoder) {
                        _Base64Decoder = new Base64Decoder();
                    }
                    return destIndex + _Base64Decoder.DecodeBase64(_achText, srcIndex, _nPos, base64ByteBuffer, destIndex, count, false);

                case IncrementalReadType.BinHex:
                    byte[] binhexByteBuffer = destBuffer as byte[];
                    if (null == _BinHexDecoder) {
                        _BinHexDecoder = new BinHexDecoder();
                    }
                    return destIndex + _BinHexDecoder.DecodeBinHex(_achText, srcIndex, _nPos, binhexByteBuffer, destIndex, count, false);
                default:
                    throw new XmlException(Res.Xml_InternalError, string.Empty);
            } // switch

        }


        internal void FinishIncrementalRead(XmlTextReader reader) {
            if (null != _BinHexDecoder) {
                _BinHexDecoder.Flush();
            }
            if (null != _Base64Decoder) {
                _Base64Decoder.Flush();
            }
            while(true) {
                if (_nPos == _nUsed) {
                    _nStart = _nPos;
                    int i = Read();
                    if (0 == i ) return;
                }
                if ('<' == _achText[_nPos]) {
                    if (!reader.ContinueReadFromBuffer(ScanMarkup())) {
                        return;
                    }
                }
                _nPos++;
            }
        }

        internal bool ScanWhitespace() {
            char ch = _achText[_nPos];
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;

            if (ch == 0) {
                if (Read() == 0 && !InDTD)
                    throw new XmlException(Res.Xml_UnexpectedEOF,XmlToken.ToString(XmlToken.XMLNS), LineNum, LinePos);
                ch = _achText[_nPos];
            }
            if (!(ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t'))
                return false;

            //There is whitespace skip it now

            while (true) {
                ch = _achText[_nPos];
                switch (ch) {
                    case (char)0:
                        if (Read() == 0) {
                            _nStart = _nPos;
                            return true;
                        }
                        continue;
                    case (char)0xA:
                        ++_nLineNum;
                        _nLinePos = _nPos + 1;
                        break;
                    case (char)0xD:
                        ++_nLineNum;
                        if (_achText[_nPos + 1] == 0) Read();
                        if (_achText[_nPos + 1] == 0xA) ++_nPos;
                        _nLinePos = _nPos +1;
                        break;
                    case (char)'\t':
                    case (char)' ':
                        break;
                    default:
                        _nStart = _nPos;
                        return true;
                }
                ++_nPos;
            }
        }
        /*
         */
        private void ScanParEntityRef() {
            _nStartLine = _nLineNum;
            _nStartLinePos= this.LinePos;

            ScanName();
            if (_achText[_nPos] == 0) Read();
            if (_achText[_nPos] != ';') {
                _nPos++; // point to problem character.
                throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.SEMICOLON), LineNum, LinePos - 1);
            }
            _nToken = XmlToken.PENTITYREF;
        }

    } // XmlScanner
} // namespace System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlprocessinginstruction.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlProcessingInstruction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlProcessingInstruction.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
    using System;
    using System.IO;
    using System.Diagnostics;
    using System.Text;
    using System.Xml.XPath;

    /// <include file='doc\XmlProcessingInstruction.uex' path='docs/doc[@for="XmlProcessingInstruction"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a processing instruction, which XML defines to keep
    ///       processor-specific information in the text of the document.
    ///    </para>
    /// </devdoc>
    public class XmlProcessingInstruction : XmlLinkedNode {
        string target;
        string data;

        /// <include file='doc\XmlProcessingInstruction.uex' path='docs/doc[@for="XmlProcessingInstruction.XmlProcessingInstruction"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected internal XmlProcessingInstruction( string target, string data, XmlDocument doc ) : base( doc ) {
            this.target = target;
            this.data = data;
        }

        /// <include file='doc\XmlProcessingInstruction.uex' path='docs/doc[@for="XmlProcessingInstruction.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node.
        ///    </para>
        /// </devdoc>
        public override String Name {
            get {
                if (target != null)
                    return target;
                return String.Empty;
            }
        }

        /// <include file='doc\XmlProcessingInstruction.uex' path='docs/doc[@for="XmlProcessingInstruction.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the current node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override string LocalName {
            get { return Name;}
        }

        /// <include file='doc\XmlProcessingInstruction.uex' path='docs/doc[@for="XmlProcessingInstruction.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the value of the node.
        ///    </para>
        /// </devdoc>
        public override String Value {
            get { return data;}
            set { Data = value; } //use Data instead of data so that event will be fired
        }

        /// <include file='doc\XmlProcessingInstruction.uex' path='docs/doc[@for="XmlProcessingInstruction.Target"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the target of the processing instruction.
        ///    </para>
        /// </devdoc>
        public String Target {
            get { return target;}
        }

        /// <include file='doc\XmlProcessingInstruction.uex' path='docs/doc[@for="XmlProcessingInstruction.Data"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the content of processing instruction,
        ///       excluding the target.
        ///    </para>
        /// </devdoc>
        public String Data {
            get { return data;}
            set { 
                XmlNode parent = ParentNode;
                XmlNodeChangedEventArgs args = GetEventArgs( this, parent, parent, XmlNodeChangedAction.Change );
                if (args != null)
                    BeforeEvent( args );
                data = value;
                if (args != null)
                    AfterEvent( args );
            }
        }

        /// <include file='doc\XmlProcessingInstruction.uex' path='docs/doc[@for="XmlProcessingInstruction.InnerText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the concatenated values of the node and
        ///       all its children.
        ///    </para>
        /// </devdoc>
        public override string InnerText { 
            get { return data;}
            set { Data = value; } //use Data instead of data so that change event will be fired
        }

        /// <include file='doc\XmlProcessingInstruction.uex' path='docs/doc[@for="XmlProcessingInstruction.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType {
            get { return XmlNodeType.ProcessingInstruction;}
        }

        /// <include file='doc\XmlProcessingInstruction.uex' path='docs/doc[@for="XmlProcessingInstruction.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a duplicate of this node.
        ///    </para>
        /// </devdoc>
        public override XmlNode CloneNode(bool deep) {
            Debug.Assert( OwnerDocument != null );
            return OwnerDocument.CreateProcessingInstruction( target, data );
        }

        /// <include file='doc\XmlProcessingInstruction.uex' path='docs/doc[@for="XmlProcessingInstruction.WriteTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteTo(XmlWriter w) {
            w.WriteProcessingInstruction(target, data);
        }

        /// <include file='doc\XmlProcessingInstruction.uex' path='docs/doc[@for="XmlProcessingInstruction.WriteContentTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves all the children of the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteContentTo(XmlWriter w) {
            // Intentionally do nothing
        }

        internal override string XPLocalName { get { return Name; } }
        internal override XPathNodeType XPNodeType { get { return XPathNodeType.ProcessingInstruction; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlReader.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml {
       using System.IO;
       using System.Text;
       using System.Xml.Schema;


    /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader"]/*' />
    /// <devdoc>
    ///    <para>Represents a reader that provides fast, non-cached forward only stream access
    ///       to XML data.</para>
    /// <para>This class is <see langword='abstract'/> .</para>
    /// </devdoc>
    public abstract class XmlReader {
        // Node Properties
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public abstract XmlNodeType NodeType { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.Name"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of
        ///       the current node, including the namespace prefix.</para>
        /// </devdoc>
        public abstract string Name { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the current node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public abstract string LocalName { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.NamespaceURI"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the namespace URN (as defined in the W3C Namespace Specification) of the current namespace scope.
        ///    </para>
        /// </devdoc>
        public abstract string NamespaceURI { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.Prefix"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the namespace prefix associated with the current node.
        ///    </para>
        /// </devdoc>
        public abstract string Prefix { get;}

        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.HasValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether
        ///    <see cref='System.Xml.XmlReader.Value'/> has a value to return.
        ///    </para>
        /// </devdoc>
        public abstract bool HasValue { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the text value of the current node.
        ///    </para>
        /// </devdoc>
        public abstract string Value { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.Depth"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the depth of the
        ///       current node in the XML element stack.
        ///    </para>
        /// </devdoc>
        public abstract int Depth { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.BaseURI"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the base URI of the current node.
        ///    </para>
        /// </devdoc>
        public abstract string BaseURI { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.IsEmptyElement"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether
        ///       the current
        ///       node is an empty element (for example, &lt;MyElement/&gt;).</para>
        /// </devdoc>
        public abstract bool IsEmptyElement { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.IsDefault"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the current node is an
        ///       attribute that was generated from the default value defined
        ///       in the DTD or schema.
        ///    </para>
        /// </devdoc>
        public abstract bool IsDefault { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.QuoteChar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the quotation mark character used to enclose the value of an attribute
        ///       node.
        ///    </para>
        /// </devdoc>
        public abstract char QuoteChar { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.XmlSpace"]/*' />
        /// <devdoc>
        ///    <para>Gets the current xml:space scope.</para>
        /// </devdoc>
        public abstract XmlSpace XmlSpace { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.XmlLang"]/*' />
        /// <devdoc>
        ///    <para>Gets the current xml:lang scope.</para>
        /// </devdoc>
        public abstract string XmlLang { get;}

        // Attribute Accessors
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.AttributeCount"]/*' />
        /// <devdoc>
        ///    <para> The number of attributes on the current node.</para>
        /// </devdoc>
        public abstract int AttributeCount { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.GetAttribute"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified
        ///    <see cref='System.Xml.XmlReader.Name'/> .</para>
        /// </devdoc>
        public abstract string GetAttribute(string name);
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.GetAttribute1"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the
        ///       specified <see cref='System.Xml.XmlReader.LocalName'/> and <see cref='System.Xml.XmlReader.NamespaceURI'/> .</para>
        /// </devdoc>
        public abstract string GetAttribute(string name, string namespaceURI);
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.GetAttribute2"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified index.</para>
        /// </devdoc>
        public abstract string GetAttribute(int i);
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.this"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified index.</para>
        /// </devdoc>
        public abstract string this [ int i ] { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.this1"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified
        ///    <see cref='System.Xml.XmlReader.Name'/> .</para>
        /// </devdoc>
        public abstract string this [ string name ] { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.this2"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the
        ///       specified <see cref='System.Xml.XmlReader.LocalName'/> and <see cref='System.Xml.XmlReader.NamespaceURI'/> .</para>
        /// </devdoc>
        public abstract string this [ string name,string namespaceURI ] { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.MoveToAttribute"]/*' />
        /// <devdoc>
        /// <para>Moves to the attribute with the specified <see cref='System.Xml.XmlReader.Name'/> .</para>
        /// </devdoc>
        public abstract bool MoveToAttribute(string name);

        //UE Atention
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.CanResolveEntity"]/*' />
        public virtual bool CanResolveEntity  {
            get  {
                return false;
            }
        }

        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.MoveToAttribute1"]/*' />
        /// <devdoc>
        /// <para>Moves to the attribute with the specified <see cref='System.Xml.XmlReader.LocalName'/>
        /// and <see cref='System.Xml.XmlReader.NamespaceURI'/> .</para>
        /// </devdoc>
        public abstract bool MoveToAttribute(string name, string ns);
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.MoveToAttribute2"]/*' />
        /// <devdoc>
        ///    <para>Moves to the attribute with the specified index.</para>
        /// </devdoc>
        public abstract void MoveToAttribute(int i);
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.MoveToFirstAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Moves to the first attribute.
        ///    </para>
        /// </devdoc>
        public abstract bool MoveToFirstAttribute();
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.MoveToNextAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Moves to the next attribute.
        ///    </para>
        /// </devdoc>
        public abstract bool MoveToNextAttribute();
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.MoveToElement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Moves to the element that contains the current attribute node.
        ///    </para>
        /// </devdoc>
        public abstract bool MoveToElement();

        // Moving through the Stream
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.Read"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Reads the next
        ///       node from the stream.
        ///    </para>
        /// </devdoc>
        public abstract bool Read();
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.EOF"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       a value indicating whether XmlReader is positioned at the end of the
        ///       stream.
        ///    </para>
        /// </devdoc>
        public abstract bool EOF { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Closes the stream, changes the <see cref='System.Xml.XmlReader.ReadState'/>
        ///       to Closed, and sets all the properties back to zero.
        ///    </para>
        /// </devdoc>
        public abstract void Close();
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.ReadState"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns
        ///       the read state of the stream.
        ///    </para>
        /// </devdoc>
        public abstract ReadState ReadState { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.Skip"]/*' />
        /// <devdoc>
        ///    <para>Skips to the end tag of the current element.</para>
        /// </devdoc>
        public virtual void Skip() {
            if (ReadState != ReadState.Interactive)
                return;

            MoveToElement();
            if (NodeType == XmlNodeType.Element && ! IsEmptyElement) {
                int depth = Depth;

                while (Read() && depth < Depth) {
                    // Nothing, just read on
                }

                // consume end tag
                if( NodeType == XmlNodeType.EndElement )
                    Read();
            }
            else {
                Read();
            }
        }

	/// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.ReadString"]/*' />
	/// <devdoc>
	///    <para>Reads the contents of an element as a string.</para>
	/// </devdoc>
	public virtual string ReadString() {
		if (this.ReadState != ReadState.Interactive ) {
			return string.Empty;
		}
		this.MoveToElement();
		if (this.NodeType == XmlNodeType.Element) {
			if (this.IsEmptyElement) {
				return string.Empty;
			}
			else if (! this.Read()) {
		        	throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
			}
			if (this.NodeType == XmlNodeType.EndElement) {
				return string.Empty;
			}
		}	
		if ( (this.NodeType == XmlNodeType.CDATA)  || 
		    	(this.NodeType == XmlNodeType.Text) ||
		    	(this.NodeType == XmlNodeType.Whitespace) ||
		    	(this.NodeType == XmlNodeType.SignificantWhitespace) ||
		    	(this.NodeType == XmlNodeType.SignificantWhitespace)) {
			return GetTextContent();
		}
		else {
			//move ahead and try to return text content from new position
			if (this.NodeType != XmlNodeType.EndElement && !this.Read()) {
		        	throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
			}
			return string.Empty;
		}
	}
        
        //if not position on the text type node, no reading is done and no movement
        private string GetTextContent() {
            StringBuilder retstr = new StringBuilder();
            Boolean flag;
            do{
                flag = false;
                switch (this.NodeType) {
                    case XmlNodeType.CDATA:
                    case XmlNodeType.Text:
                    case XmlNodeType.Whitespace:
                    case XmlNodeType.SignificantWhitespace:
                        retstr.Append( this.Value );
                        if (! this.Read())
                            throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
                        flag = true;
                    break;
                }
            } while(flag);
            return retstr.ToString();
        }



        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.MoveToContent"]/*' />
        /// <devdoc>
        ///    <para>Checks whether the current node is a content (non-whitespace text, CDATA, Element, EndElement, EntityReference,
        ///       CharacterEntity, or EndEntity) node. If the node is not a content node, then the method
        ///       skips ahead to the next content node or end of file. Skips over nodes of type
        ///    <see langword='ProcessingInstruction'/>, <see langword='DocumentType'/>,
        ///    <see langword='Comment'/>, <see langword='Whitespace'/>, or
        ///    <see langword='SignificantWhitespace'/>.</para>
        /// </devdoc>
        public virtual XmlNodeType MoveToContent() {
            do {
                    switch (this.NodeType) {
                    case XmlNodeType.Attribute:
                        MoveToElement();
                        goto case XmlNodeType.Element;
                    case XmlNodeType.Element:
                    case XmlNodeType.EndElement:
                    case XmlNodeType.CDATA:
                    case XmlNodeType.Text:
                    case XmlNodeType.EntityReference:
                    case XmlNodeType.EndEntity:
                        return this.NodeType;
                    }
            } while (Read());
            return this.NodeType;
        }


        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.ReadStartElement"]/*' />
        /// <devdoc>
        ///    <para>Checks that the current node is an element and advances the reader to the next
        ///       node.</para>
        /// </devdoc>
        public virtual void ReadStartElement()
        {
            if (MoveToContent() != XmlNodeType.Element) {
                throw new XmlException(Res.Xml_InvalidNodeType, this.NodeType.ToString(), this as IXmlLineInfo);
            }
            Read();
        }

        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.ReadStartElement1"]/*' />
        /// <devdoc>
        ///    <para>Checks that the current content node is an element with
        ///       the given <see cref='System.Xml.XmlReader.Name'/> and
        ///       advances the reader to the next node.</para>
        /// </devdoc>
        public virtual void ReadStartElement(String name)
        {
            if (MoveToContent() != XmlNodeType.Element) {
                throw new XmlException(Res.Xml_InvalidNodeType, this.NodeType.ToString(), this as IXmlLineInfo);
            }
            if (this.Name == name) {
                Read();
            }
            else {
                String[] args = new String[2];
                args[0] = this.Name;
                args[1] = this.NamespaceURI;
                throw new XmlException(Res.Xml_UnexpectedElement, args, this as IXmlLineInfo);
            }
        }

        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.ReadStartElement2"]/*' />
        /// <devdoc>
        ///    <para>Checks that the current content node is an element with
        ///       the given <see cref='System.Xml.XmlReader.LocalName'/> and <see cref='System.Xml.XmlReader.NamespaceURI'/>
        ///       and advances the reader to the next node.</para>
        /// </devdoc>
        public virtual void ReadStartElement(String localname, String ns)
        {
            if (MoveToContent() != XmlNodeType.Element) {
                throw new XmlException(Res.Xml_InvalidNodeType, this.NodeType.ToString(), this as IXmlLineInfo);
            }
            if (this.LocalName == localname && this.NamespaceURI == ns) {
                Read();
            }
            else {
                String[] args = new String[2];
                args[0] = this.LocalName;
                args[1] = this.NamespaceURI;
                throw new XmlException(Res.Xml_UnexpectedElement, args, this as IXmlLineInfo);
            }
        }

        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.ReadElementString"]/*' />
        /// <devdoc>
        ///    <para>Reads a text-only element.</para>
        /// </devdoc>
        public virtual String ReadElementString()
        {
            string result = string.Empty;

            if (MoveToContent() != XmlNodeType.Element) {
                throw new XmlException(Res.Xml_InvalidNodeType, this.NodeType.ToString(), this as IXmlLineInfo);
            }
            if (!this.IsEmptyElement) {
                Read();
                result = ReadString();
                if (this.NodeType != XmlNodeType.EndElement) {
                    throw new XmlException(Res.Xml_InvalidNodeType, this.NodeType.ToString(), this as IXmlLineInfo);
                }
                Read();
            }
            else {
                Read();
            }
            return result;
        }

        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.ReadElementString1"]/*' />
        /// <devdoc>
        /// <para>Checks that the <see cref='System.Xml.XmlReader.Name'/>
        /// property of the element found
        /// matches the given string before reading a text-only element.</para>
        /// </devdoc>
        public virtual String ReadElementString(String name)
        {
            string result = string.Empty;

            if (MoveToContent() != XmlNodeType.Element) {
                throw new XmlException(Res.Xml_InvalidNodeType, this.NodeType.ToString(), this as IXmlLineInfo);
            }
            if (this.Name != name) {
                String[] args = new String[2];
                args[0] = this.Name;
                args[1] = this.NamespaceURI;
                throw new XmlException(Res.Xml_UnexpectedElement, args, this as IXmlLineInfo);
            }

            if (!this.IsEmptyElement) {
                //Read();
                result = ReadString();
                if (this.NodeType != XmlNodeType.EndElement) {
                    throw new XmlException(Res.Xml_InvalidNodeType, this.NodeType.ToString(), this as IXmlLineInfo);
                }
                Read();
            }
            else {
                Read();
            }
            return result;
        }

        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.ReadElementString2"]/*' />
        /// <devdoc>
        /// <para>Checks that the <see cref='LocalName'/> and <see cref='System.Xml.XmlReader.NamespaceURI'/> properties of the element found
        ///    matches the given strings before reading a text-only element.</para>
        /// </devdoc>
        public virtual String ReadElementString(String localname, String ns)
        {
            string result = string.Empty;
            if (MoveToContent() != XmlNodeType.Element) {
                throw new XmlException(Res.Xml_InvalidNodeType, this.NodeType.ToString(), this as IXmlLineInfo);
            }
            if (this.LocalName != localname || this.NamespaceURI != ns) {
                String[] args = new String[2];
                args[0] = this.LocalName;
                args[1] = this.NamespaceURI;
                throw new XmlException(Res.Xml_UnexpectedElement, args, this as IXmlLineInfo);
            }

            if (!this.IsEmptyElement) {
                //Read();
                result = ReadString();
                if (this.NodeType != XmlNodeType.EndElement) {
                    throw new XmlException(Res.Xml_InvalidNodeType, this.NodeType.ToString(), this as IXmlLineInfo);
                }
                Read();
            } else {
                Read();
            }

            return result;
        }

        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.ReadEndElement"]/*' />
        /// <devdoc>
        ///   Checks that the current content node is an end tag and advances the reader to
        ///   the next node.</devdoc>
        public virtual void ReadEndElement()
        {
            if (MoveToContent() != XmlNodeType.EndElement) {
               throw new XmlException(Res.Xml_InvalidNodeType, this.NodeType.ToString(), this as IXmlLineInfo);
            }
            Read();
        }

        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.IsStartElement"]/*' />
        /// <devdoc>
        /// <para>Calls <see cref='System.Xml.XmlReader.MoveToContent'/> and tests if the current content
        ///    node is a start tag or empty element tag (XmlNodeType.Element).</para>
        /// </devdoc>
        public virtual bool IsStartElement() {
            return MoveToContent() == XmlNodeType.Element;
        }

        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.IsStartElement1"]/*' />
        /// <devdoc>
        /// <para>Calls <see cref='System.Xml.XmlReader.MoveToContent'/>and tests if the current content node is a
        ///    start tag or empty element tag (XmlNodeType.Element) and if the
        /// <see cref='System.Xml.XmlReader.Name'/>
        /// property of the element found matches the given argument.</para>
        /// </devdoc>
        public virtual bool IsStartElement(string name) {
            return MoveToContent() == XmlNodeType.Element &&
                this.Name == name;
        }

        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.IsStartElement2"]/*' />
        /// <devdoc>
        /// <para>Calls <see cref='System.Xml.XmlReader.MoveToContent'/>and tests if the current
        ///    content node is a start tag or empty element tag (XmlNodeType.Element) and if
        ///    the <see cref='System.Xml.XmlReader.LocalName'/> and
        /// <see cref='System.Xml.XmlReader.NamespaceURI'/>
        /// properties of the element found match the given strings.</para>
        /// </devdoc>
        public virtual bool IsStartElement(string localname, string ns) {
            return MoveToContent() == XmlNodeType.Element &&
                this.LocalName == localname && this.NamespaceURI == ns;
        }

        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.IsName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static bool IsName(string str) {
            if (str == String.Empty || !XmlCharType.IsStartNameChar(str[0])) return false;
            int i = str.Length - 1;
            while (i > 0) {
                if (XmlCharType.IsNameChar(str[i])) {
                    i--;
                }
                else return false;
            }
            return true;
        }


        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.IsNameToken"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static bool IsNameToken(string str) {
            if ( str == String.Empty) return false;
            int i = str.Length - 1;
            while (i >= 0) {
                if (XmlCharType.IsNameChar(str[i])) {
                    i--;
                }
                else return false;
            }
            return true;
        }

        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.ReadInnerXml"]/*' />
        /// <devdoc>
        ///    <para>Reads all the content (including markup) as a string.</para>
        /// </devdoc>
        public virtual string ReadInnerXml() {
	     if ( ReadState != ReadState.Interactive	) {
	     	   return string.Empty;	
	     }
            if ( (this.NodeType != XmlNodeType.Attribute) && (this.NodeType != XmlNodeType.Element) ) {
                Read();
                return string.Empty;
            }
            
            StringWriter sw = new StringWriter();
            XmlTextWriter xtw = new XmlTextWriter(sw);
            if (this.NodeType == XmlNodeType.Attribute) {
		xtw.QuoteChar = this.QuoteChar;
                WriteAttributeValue(xtw);
            }
            if (this.NodeType == XmlNodeType.Element) {
                this.WriteNode(xtw, false);
            }
            xtw.Close();
            return sw.ToString();
            
        }

        private void WriteNode(XmlTextWriter xtw, bool defattr) {
            int d = this.NodeType == XmlNodeType.None ? -1 : this.Depth;
            while (this.Read() && (d < this.Depth)) {
                switch (this.NodeType) {
                    case XmlNodeType.Element:
                        xtw.WriteStartElement(this.Prefix, this.LocalName, this.NamespaceURI);
			xtw.QuoteChar = this.QuoteChar;
                        xtw.WriteAttributes(this, defattr);
                        if (this.IsEmptyElement) {
                            xtw.WriteEndElement();
                        }
                        break;
                    case XmlNodeType.Text:
                        xtw.WriteString(this.Value);
                        break;
                    case XmlNodeType.Whitespace:
                    case XmlNodeType.SignificantWhitespace:
                        xtw.WriteWhitespace(this.Value);
                        break;
                    case XmlNodeType.CDATA:
                        xtw.WriteCData(this.Value);
                        break;
                    case XmlNodeType.EntityReference:
                        xtw.WriteEntityRef(this.Name);
                        break;
                    case XmlNodeType.XmlDeclaration:
                    case XmlNodeType.ProcessingInstruction:
                        xtw.WriteProcessingInstruction(this.Name, this.Value);
                        break;
                    case XmlNodeType.DocumentType:
                        xtw.WriteDocType(this.Name, this.GetAttribute("PUBLIC"), this.GetAttribute("SYSTEM"), this.Value);
                        break;
                    case XmlNodeType.Comment:
                        xtw.WriteComment(this.Value);
                        break;
                    case XmlNodeType.EndElement:
                        xtw.WriteFullEndElement();
                        break;
                }
            }
            if (d==this.Depth && this.NodeType==XmlNodeType.EndElement) {
                Read();
            }
        }
        
        private void  WriteAttributeValue(XmlTextWriter xtw) {
            String attrName = this.Name;
            while (ReadAttributeValue()) {
                if (this.NodeType == XmlNodeType.EntityReference) {
                    xtw.WriteEntityRef(this.Name);
                }
                else {
                    xtw.WriteString(this.Value);
                }
            }
            this.MoveToAttribute(attrName);
        }


        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.ReadOuterXml"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
	public virtual string ReadOuterXml() {	
	     if ( ReadState != ReadState.Interactive	) {
	     	   return string.Empty;	
	     }
            if ( (this.NodeType != XmlNodeType.Attribute) && (this.NodeType != XmlNodeType.Element) ) {
                Read();
                return string.Empty;
            }
            
            StringWriter sw = new StringWriter();
            XmlTextWriter xtw = new XmlTextWriter(sw);
            if (this.NodeType == XmlNodeType.Attribute) {
                xtw.WriteStartAttribute(this.Prefix, this.LocalName, this.NamespaceURI);
                WriteAttributeValue(xtw);    
                xtw.WriteEndAttribute();
            }
            else {
                //this.WriteNode(xtw, false, false);
                xtw.WriteNode(this, false);
            }
            xtw.Close();
            return sw.ToString();
        }


        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.HasAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the current node
        ///       has any attributes.
        ///    </para>
        /// </devdoc>
        public virtual bool HasAttributes {
            get { return AttributeCount > 0;}
        }

        // Nametable and Namespace Helpers
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.NameTable"]/*' />
        /// <devdoc>
        ///    <para>Gets the XmlNameTable associated with this
        ///       implementation.</para>
        /// </devdoc>
        public abstract XmlNameTable NameTable { get;}
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.LookupNamespace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resolves a namespace prefix in the current element's scope.
        ///    </para>
        /// </devdoc>
        public abstract string LookupNamespace(string prefix);
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.ResolveEntity"]/*' />
        /// <devdoc>
        ///    <para>Resolves the entity reference for nodes of NodeType EntityReference.</para>
        /// </devdoc>
        public abstract void ResolveEntity();
        /// <include file='doc\XmlReader.uex' path='docs/doc[@for="XmlReader.ReadAttributeValue"]/*' />
        /// <devdoc>
        ///    <para>Parses the attribute value into one or more Text and/or EntityReference node
        ///       types.</para>
        /// </devdoc>
        public abstract bool ReadAttributeValue();

        // beta2
        // Async Support
        //public abstract IAsyncResult BeginReading(AsyncCallback cb, Object state);
        //public abstract void EndReading(IAsyncResult ar);
        //public abstract bool ReadAsync();

        // validation support begin
        internal virtual XmlNamespaceManager NamespaceManager {
            get { return null;}
        }

        internal virtual bool StandAlone {
            get { return false; }
        }

        internal virtual object SchemaTypeObject {
            get { return null; }
            set { /* noop */ }
        }

        internal virtual object TypedValueObject {
            get { return null; }
            set { /* noop */ }
        }

        internal virtual bool AddDefaultAttribute(Schema.SchemaAttDef attdef) {
            return false;
        }

        // validation support end
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlsecureresolver.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlAttributeTokenInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------
namespace System.Xml {

    using System.Net;
    using System.Security;
    using System.Security.Policy;
    using System.Security.Permissions;
    
    /// <include file='doc\XmlSecureResolver.uex' path='docs/doc[@for="XmlSecureResolver"]/*' />
    public class XmlSecureResolver : XmlResolver {
        XmlResolver resolver;
        PermissionSet permissionSet;

        /// <include file='doc\XmlSecureResolver.uex' path='docs/doc[@for="XmlSecureResolver.XmlSecureResolver1"]/*' />
        public XmlSecureResolver(XmlResolver resolver, string securityUrl) : this(resolver, CreateEvidenceForUrl(securityUrl)) {}

        /// <include file='doc\XmlSecureResolver.uex' path='docs/doc[@for="XmlSecureResolver.XmlSecureResolver2"]/*' />
        public XmlSecureResolver(XmlResolver resolver, Evidence evidence) : this(resolver, SecurityManager.ResolvePolicy(evidence)) {}

        /// <include file='doc\XmlSecureResolver.uex' path='docs/doc[@for="XmlSecureResolver.XmlSecureResolver3"]/*' />
        public XmlSecureResolver(XmlResolver resolver, PermissionSet permissionSet) {
            this.resolver = resolver;
            this.permissionSet = permissionSet;
        }

        /// <include file='doc\XmlSecureResolver.uex' path='docs/doc[@for="XmlSecureResolver.Credentials"]/*' />
        public override ICredentials Credentials {
            set { resolver.Credentials = value; }
        }

        /// <include file='doc\XmlSecureResolver.uex' path='docs/doc[@for="XmlSecureResolver.GetEntity"]/*' />
        public override object GetEntity(Uri absoluteUri, string role, Type ofObjectToReturn) {
            permissionSet.PermitOnly();
            return resolver.GetEntity(absoluteUri, role, ofObjectToReturn);
        }

        /// <include file='doc\XmlSecureResolver.uex' path='docs/doc[@for="XmlSecureResolver.ResolveUri"]/*' />
        public override Uri ResolveUri(Uri baseUri, string relativeUri) {
            return resolver.ResolveUri(baseUri, relativeUri);
        }

        /// <include file='doc\XmlSecureResolver.uex' path='docs/doc[@for="XmlSecureResolver.CreateEvidenceForUri"]/*' />
        public static Evidence CreateEvidenceForUrl(string securityUrl) {
            Evidence evidence = new Evidence();
            if (securityUrl != null && securityUrl != string.Empty) {
                Zone zone = Zone.CreateFromUrl(securityUrl);
                evidence.AddHost(new Url(securityUrl));
                evidence.AddHost(zone);
                if (zone.SecurityZone == SecurityZone.Internet || zone.SecurityZone == SecurityZone.Trusted) {
                    evidence.AddHost(Site.CreateFromUrl(securityUrl));
                }
            }
            return evidence;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlsignificantwhitespace.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSignificantWhitespace.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlSignificantWhitespace.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml
{
    using System;
    using System.Xml.XPath;
    using System.Text;
    using System.Diagnostics;

    /// <include file='doc\XmlSignificantWhitespace.uex' path='docs/doc[@for="XmlSignificantWhitespace"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the text content of an element or attribute.
    ///    </para>
    /// </devdoc>
    public class XmlSignificantWhitespace : XmlCharacterData {
        /// <include file='doc\XmlSignificantWhitespace.uex' path='docs/doc[@for="XmlSignificantWhitespace.XmlSignificantWhitespace"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected internal XmlSignificantWhitespace( string strData, XmlDocument doc ) : base( strData, doc ) {
            if ( !doc.IsLoading && !base.CheckOnData( strData ) )
                throw new ArgumentException(Res.GetString(Res.Xdom_WS_Char));
        }

        /// <include file='doc\XmlSignificantWhitespace.uex' path='docs/doc[@for="XmlSignificantWhitespace.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node.
        ///    </para>
        /// </devdoc>
        public override String Name
        {
            get { return XmlDocument.strSignificantWhitespaceName;}
        }

        /// <include file='doc\XmlSignificantWhitespace.uex' path='docs/doc[@for="XmlSignificantWhitespace.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the current node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override String LocalName
        {
            get { return XmlDocument.strSignificantWhitespaceName;}
        }

        /// <include file='doc\XmlSignificantWhitespace.uex' path='docs/doc[@for="XmlSignificantWhitespace.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType
        {
            get { return XmlNodeType.SignificantWhitespace;}
        }

        /// <include file='doc\XmlSignificantWhitespace.uex' path='docs/doc[@for="XmlSignificantWhitespace.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a duplicate of this node.
        ///    </para>
        /// </devdoc>
        public override XmlNode CloneNode(bool deep) {
            Debug.Assert( OwnerDocument != null );
            return OwnerDocument.CreateSignificantWhitespace( Data );
        }

        /// <include file='doc\XmlSignificantWhitespace.uex' path='docs/doc[@for="XmlSignificantWhitespace.Value"]/*' />
        public override String Value {
            get { return Data;}
            set {
                if ( CheckOnData( value ) )
                    Data = value;
                else
                    throw new ArgumentException(Res.GetString(Res.Xdom_WS_Char));
            }
        }

        /// <include file='doc\XmlSignificantWhitespace.uex' path='docs/doc[@for="XmlSignificantWhitespace.WriteTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteTo(XmlWriter w) {
            w.WriteString(Data);
        }

        /// <include file='doc\XmlSignificantWhitespace.uex' path='docs/doc[@for="XmlSignificantWhitespace.WriteContentTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves all the children of the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteContentTo(XmlWriter w) {
            // Intentionally do nothing
        }

        internal override XPathNodeType XPNodeType {
            get {
                XPathNodeType xnt = XPathNodeType.SignificantWhitespace;
                DecideXPNodeTypeForTextNodes( this, ref xnt );
                return xnt;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlreservedns.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlReservedNS.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml {


    // This file defines a set of common XML names for sharing
    // across multiple files.
    internal class XmlReservedNs {
        internal const string NsDataType = "urn:schemas-microsoft-com:datatypes";
        internal const string NsDataTypeAlias = "uuid:C2F41010-65B3-11D1-A29F-00AA00C14882";
        internal const string NsDataTypeOld = "urn:uuid:C2F41010-65B3-11D1-A29F-00AA00C14882/";
        internal const string NsXml = "http://www.w3.org/XML/1998/namespace";
        internal const string NsXmlNs = "http://www.w3.org/2000/xmlns/";
        internal const string NsXdr = "urn:schemas-microsoft-com:xml-data";
        internal const string NsXdrAlias = "uuid:BDC6E3F0-6DA3-11D1-A2A3-00AA00C14882";
        internal const string NsXsd = "http://www.w3.org/2001/XMLSchema";
        internal const string NsXsi = "http://www.w3.org/2001/XMLSchema-instance";

    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlspace.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlSpace.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml
{
    /// <include file='doc\XmlSpace.uex' path='docs/doc[@for="XmlSpace"]/*' />
    /// <devdoc>
    ///    Specifies the current xml:space scope.
    /// </devdoc>
    public enum XmlSpace
    {
        /// <include file='doc\XmlSpace.uex' path='docs/doc[@for="XmlSpace.None"]/*' />
        /// <devdoc>
        ///    No xml:space scope.
        /// </devdoc>
        None          = 0,
        /// <include file='doc\XmlSpace.uex' path='docs/doc[@for="XmlSpace.Default"]/*' />
        /// <devdoc>
        ///    The xml:space scope equals "default".
        /// </devdoc>
        Default       = 1,
        /// <include file='doc\XmlSpace.uex' path='docs/doc[@for="XmlSpace.Preserve"]/*' />
        /// <devdoc>
        ///    The xml:space scope equals "preserve".
        /// </devdoc>
        Preserve      = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmltextwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlTextWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml {

    using System;
    using System.Collections;
    using System.IO;
    using System.Text;
    using System.Diagnostics;
    using System.Globalization;


    // This class does special handling of text content for XML.  For example
    // it will replace special characters with entities whenever necessary.
    internal class XmlTextEncoder {
        char[] buffer;
        int size;
        int used;
        char[] rawBuffer;
        int rawSize;
        int rawUsed;
        bool inAttribute;
        char quoteChar;
        bool save; // whether to buffer or not.

        const int highStart = 0xd800;
        const int highEnd   = 0xdbff;
        const int lowStart  = 0xdc00;
        const int lowEnd    = 0xdfff;

        Encoding encoding;
        TextWriter textWriter;

        internal XmlTextEncoder(TextWriter textWriter, Encoding enc) {
            this.textWriter = textWriter;
            this.encoding = enc;
            this.save = false;
        }

        internal char QuoteChar {
            set { this.quoteChar = value;}
        }

        internal void CheckSize(int len) {
            if (this.used + len > this.size) {
                int newsize = (this.size+100+len)*2;
                char[] na = new char[newsize];
                if (this.used > 0) {
                    Array.Copy(this.buffer, na, this.used);
                }
                this.buffer = na;
                this.size = newsize;
            }
        }

        internal void CheckRawSize(int len) {
            if (this.rawUsed + len > this.rawSize) {
                int newsize = (this.rawSize+100+len)*2;
                char[] na = new char[newsize];
                if (this.rawUsed > 0) {
                    Array.Copy(this.rawBuffer, na, this.rawUsed);
                }
                this.rawBuffer = na;
                this.rawSize = newsize;
            }
        }

        internal void StartAttribute(bool save) {
            this.inAttribute = true;
            this.save = save;
        }

        internal string RawValue {
            get {
                if (this.used == 0) return String.Empty;
                else return new String(this.rawBuffer, 0, this.rawUsed);
            }
        }

        internal void EndAttribute() {
            this.inAttribute = false;
            this.save = false;
        }

        internal void WriteSurrogateChar(char lowChar, char highChar) {

            if (((int)lowChar >= lowStart && (int)lowChar <= lowEnd) && ((int)highChar >= highStart && (int)highChar <= highEnd)) {
                if (this.rawUsed == this.rawSize) {
                    CheckRawSize(1);
                }
                this.rawBuffer[this.rawUsed++] = highChar;
                this.rawBuffer[this.rawUsed++] = lowChar;

                WriteRawChar(highChar);
                WriteRawChar(lowChar);
            } else {
                throw new ArgumentException(Res.GetString(Res.Xml_InvalidSurrogatePair));
            }
        }

        internal void Write(char[] array, int offset, int count) {

            int i, loop ;
            char ch;

            if (null == array) {
                throw new ArgumentNullException("array");
            }

            if (0 > offset) {
                throw new ArgumentOutOfRangeException("offset");
            }

            if (0 > count) {
                throw new ArgumentOutOfRangeException("count");
            }

            if (count > array.Length - offset) {
                throw new ArgumentException("count > array.Length - offset");
            }

            loop = offset + count - 1;

            for (i = offset; i < loop ; ++i) {
                ch = array[i];
                if ((int)ch >= highStart && (int)ch <= highEnd) {
                    WriteSurrogateChar(array[++i], ch);
                } else if((int)ch >= lowStart && (int)ch <= lowEnd) {
                    throw new ArgumentException(Res.GetString(Res.Xml_InvalidSurrogatePair));
                } else {
                   Write(ch);
                }
            }

            // we don't need to check null array since
            // the calling function already done so.
            if (i <= loop) {
                ch = array[i];

                if ((int)ch >= highStart && (int)ch <= highEnd) {
                   throw new ArgumentException(Res.GetString(Res.Xml_SurrogatePairSplit));
                } else if((int)ch >= lowStart && (int)ch <= lowEnd) {
                    throw new ArgumentException(Res.GetString(Res.Xml_InvalidSurrogatePair));
                } else {
                   Write(ch);
                }
            }
        }

        internal void WriteRawChar(char ch) {
            if (this.save) {
                if (this.used == this.size) {
                    CheckSize(1);
                }
                this.buffer[this.used++] = ch;
            }
            else {
                textWriter.Write(ch);
            }
        }

        internal void Write(char ch) {

            if (this.rawUsed == this.rawSize) {
                CheckRawSize(1);
            }
            this.rawBuffer[this.rawUsed++] = ch;


            if ((ch < 32 && ch != '\t' && ch != '\r' && ch != '\n') || (ch > 0xFFFD)) {
                InternalWriteCharEntity(ch);
                return;
            }

            switch (ch) {
                case '<':
                    InternalWriteEntityRef("lt");
                    break;
                case '>':
                    InternalWriteEntityRef("gt");
                    break;
                case '&':
                    InternalWriteEntityRef("amp");
                    break;
                case '\'':
                    if (this.inAttribute && this.quoteChar == ch) {
                        InternalWriteEntityRef("apos");
                    }
                    else {
                        goto default;
                    }
                    break;
                case '"':
                    if (this.inAttribute && this.quoteChar == ch) {
                        InternalWriteEntityRef("quot");
                    }
                    else {
                        goto default;
                    }
                    break;
                case '\n':
                case '\r':
                    if (this.inAttribute) {
                        InternalWriteCharEntity(ch);
                    }
                    else {
                        goto default;
                    }
                    break;
                default:
                    WriteRawChar(ch);
                    break;
            }
        }


        internal void WriteSurrogateCharEntity(char lowChar, char highChar) {

            int surrogateChar = 0;

            if (((int)lowChar >= lowStart && (int)lowChar <= lowEnd) && ((int)highChar >= highStart && (int)highChar <= highEnd)) {
                surrogateChar = ((int)lowChar - lowStart) | (((int)highChar - highStart) << 10) + 0x10000;
                WriteSurrogateEntity(lowChar, highChar, surrogateChar);
            } else {
                throw new ArgumentException(Res.GetString(Res.Xml_InvalidSurrogatePair));
            }
        }

        internal void Write(String text) {

            char ch;
            int i = 0;

            for (i = 0; i < text.Length - 1; ++i) {
                ch = text[i];
                if ((int)ch >= highStart && (int)ch <= highEnd) {
                    WriteSurrogateChar(text[++i], ch);
                } else if((int)ch >= lowStart && (int)ch <= lowEnd) {
                    throw new ArgumentException(Res.GetString(Res.Xml_InvalidSurrogatePair));
                } else {
                   Write(ch);
                }
            }

            // do special handling for the last char
            // since we may have boundary case
            if (text.Length != 0 && i < text.Length) {
                ch = text[i];
                if ((int)ch >= highStart && (int)ch <= highEnd) {
                   throw new ArgumentException(Res.GetString(Res.Xml_InvalidSurrogatePair));
                } else if((int)ch >= lowStart && (int)ch <= lowEnd) {
                    throw new ArgumentException(Res.GetString(Res.Xml_InvalidSurrogatePair));
                } else {
                   Write(ch);
                }
           }
        }

        internal void WriteRawString(String text) {

            char ch;
            int i = 0;

            for (i = 0; i < text.Length - 1; ++i) {
                ch = text[i];
                if ((int)ch >= highStart && (int)ch <= highEnd) {
                    WriteSurrogateChar(text[++i], ch);
                } else if((int)ch >= lowStart && (int)ch <= lowEnd) {
                    throw new ArgumentException(Res.GetString(Res.Xml_InvalidSurrogatePair));
                } else {
                    WriteRawChar(ch);
                }
            }

            // do special handling for the last char
            // since we may have boundary case
            if (text.Length != 0 && i < text.Length) {
                ch = text[i];
                if ((int)ch >= highStart && (int)ch <= highEnd) {
                   throw new ArgumentException(Res.GetString(Res.Xml_InvalidSurrogatePair));
                } else if((int)ch >= lowStart && (int)ch <= lowEnd) {
                    throw new ArgumentException(Res.GetString(Res.Xml_InvalidSurrogatePair));
                } else {
                   WriteRawChar(ch);
                }
           }
        }

        internal void WriteRaw(string value) {

            if (value == null) {
                return;
            }

            if (this.save) {
                CheckSize(value.Length);
                CheckRawSize(value.Length);

                for (int i = 0; i < value.Length; i++) {
                    this.buffer[this.used++] = value[i];
                    this.rawBuffer[this.rawUsed++] = value[i];
                }
            }
            else {
                WriteRawString(value);
            }
        }

        internal void InternalWriteRaw(string value) {
            if (this.save) {
                CheckSize(value.Length);

                for (int i = 0; i < value.Length; i++) {
                    this.buffer[this.used++] = value[i];
                }
            }
            else {
                textWriter.Write(value);
            }
        }


        internal void WriteRaw(char[] array, int offset, int count) {

            if (null == array) {
                throw new ArgumentNullException("array");
            }

            if (0 > count) {
                throw new ArgumentOutOfRangeException("count");
            }

            if (0 > offset) {
                throw new ArgumentOutOfRangeException("offset");
            }

            if (count > array.Length - offset) {
                throw new ArgumentException("count > array.Length - offset");
            }

            if (this.save) {

                // check to make sure we have enough space in our buffer
                CheckSize(count);
                CheckRawSize(count);

                for (int i=0, j=offset; i < count; i++) {
                    this.buffer[this.used++] = array[j];
                    this.rawBuffer[this.rawUsed++] = array[j++];
                }
            }
            else {
                textWriter.Write(array, offset, count);
            }
        }


        internal void WriteSurrogateEntity(char lowChar, char highChar, int value) {

            if (this.save) {
                string stringValue = value.ToString("X");
                int count = stringValue.Length;

                CheckSize(count + 4);
                CheckRawSize(2);

                this.rawBuffer[this.rawUsed++] = highChar;
                this.rawBuffer[this.rawUsed++] = lowChar;

                this.buffer[this.used++] = '&';
                this.buffer[this.used++] = '#';
                this.buffer[this.used++] = 'x';

                for (int i=0; i < count; i++) {
                    this.buffer[this.used++] = stringValue[i];
                }

                this.buffer[this.used++] = ';';
            }
            else {
                textWriter.Write('&');
                textWriter.Write('#');
                textWriter.Write('x');
                textWriter.Write(value.ToString("X"));
                textWriter.Write(';');
            }
        }


        internal void InternalWriteCharEntity(char ch) {
            if((int)ch >= 0xd800 && (int)ch <= 0xdfff) {
                throw new ArgumentException(Res.GetString(Res.Xml_InvalidSurrogatePair));
            }

            if (this.save) {
                CheckSize(10);
                this.buffer[this.used++] = '&';
                this.buffer[this.used++] = '#';
                this.buffer[this.used++] = 'x';
                string value = ((int)ch).ToString("X");
                InternalWriteRaw(value);
                this.buffer[this.used++] = ';';
            }
            else {
                textWriter.Write('&');
                textWriter.Write('#');
                textWriter.Write('x');
                textWriter.Write(((int)ch).ToString("X"));
                textWriter.Write(';');
            }
        }

        internal void WriteCharEntity(char ch) {
            if((int)ch >= 0xd800 && (int)ch <= 0xdfff) {
                throw new ArgumentException(Res.GetString(Res.Xml_InvalidSurrogatePair));
            }

            if (this.save) {
                CheckSize(10);
                this.buffer[this.used++] = '&';
                this.buffer[this.used++] = '#';
                this.buffer[this.used++] = 'x';
                string value = ((int)ch).ToString("X");
                WriteRaw(value);
                this.buffer[this.used++] = ';';
            }
            else {
                textWriter.Write('&');
                textWriter.Write('#');
                textWriter.Write('x');
                textWriter.Write(((int)ch).ToString("X"));
                textWriter.Write(';');
            }
        }

        internal void InternalWriteEntityRef(string value) {

            if (this.save) {
                CheckSize(value.Length+2);
                this.buffer[this.used++] = '&';
                InternalWriteRaw(value);
                this.buffer[this.used++] = ';';
            }
            else {
                textWriter.Write('&');
                textWriter.Write(value);
                textWriter.Write(';');
            }

        }

        internal void WriteEntityRef(string name) {
            if (this.save) {
                CheckSize(name.Length+2);
                CheckRawSize(name.Length);
                this.buffer[this.used++] = '&';
                WriteRaw(name);
                this.buffer[this.used++] = ';';
            }
            else {
                textWriter.Write('&');
                textWriter.Write(name);
                textWriter.Write(';');
            }
        }

        internal void Flush() {
            if (this.used > 0) {
                textWriter.Write(this.buffer, 0, this.used);
                this.used = 0;
            }
            if (this.rawUsed >0) {
                this.rawUsed = 0;
            }
        }
    }

    /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a writer that provides fast non-cached forward-only way of
    ///       generating XML streams containing XML documents that conform to the W3C
    ///       Extensible Markup Language (XML) 1.0 specification and the Namespaces in XML
    ///       specification.
    ///    </para>
    /// </devdoc>
    public class XmlTextWriter : XmlWriter {
        bool namespaces;
        Formatting formatting;
        bool indented; // perf - faster to check a boolean.
        int  indentation;
        char indentChar;
        TextWriter textWriter;
        XmlTextEncoder xmlEncoder;
        Encoding encoding;
        char quoteChar;
        char curQuoteChar;
        Base64Encoder base64Encoder;
        bool          flush = false;
        TagInfo[] stack;
        int top;

        enum NamespaceState {
            Uninitialized,
            NotDeclaredButInScope,
            DeclaredButNotWrittenOut,
            DeclaredAndWrittenOut
        }

        struct TagInfo {
            internal string name;
            internal string prefix;
            internal string defaultNs;
            internal NamespaceState defaultNsState;
            internal XmlSpace xmlSpace;
            internal string xmlLang;
            internal Scope scopes;
            internal int prefixCount;
            internal bool mixed; // whether to pretty print the contents of this element.
            internal void Init() {
                name = null;
                defaultNs = String.Empty;
                defaultNsState = NamespaceState.Uninitialized;
                xmlSpace = XmlSpace.None;
                xmlLang = null;
                scopes = null;
                prefixCount = 0;
                mixed = false;
            }
        }

        class Scope {
            internal string prefix;
            internal string ns;
            internal bool   declared;
            internal Scope  next;

            internal Scope(string prefix, string ns, bool declared, Scope next) {
                this.prefix = prefix;
                this.ns = ns;
                this.next = next;
                this.declared = declared;
            }
        }

        enum SpecialAttr {
            None,
            XmlSpace,
            XmlLang,
            XmlNs
        };

        SpecialAttr specialAttr;
        string prefixForXmlNs;

        internal XmlTextWriter() {
            namespaces = true;
            formatting = Formatting.None;
            indentation = 2;
            indentChar = ' ';
            stack = new TagInfo[10];
            top = 0;// 0 is an empty sentanial element
            stack[top].Init();
            quoteChar = '"';

            stateTable = stateTableDefault;
            currentState = State.Start;
            lastToken = Token.Empty;
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.XmlTextWriter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an instance of the XmlTextWriter class using the specified
        ///       stream.
        ///    </para>
        /// </devdoc>
        public XmlTextWriter(Stream w, Encoding encoding) : this() {
            this.encoding = encoding;
            if (encoding != null)
                textWriter = new StreamWriter(w, encoding);
            else
                textWriter = new StreamWriter(w);
            xmlEncoder = new XmlTextEncoder(textWriter, encoding);
            xmlEncoder.QuoteChar = this.quoteChar;
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.XmlTextWriter1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an instance of the XmlTextWriter class using the specified file.
        ///    </para>
        /// </devdoc>
        public XmlTextWriter(String filename, Encoding encoding)
        : this(new FileStream(filename, FileMode.Create,
                              FileAccess.Write, FileShare.None), encoding) {
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.XmlTextWriter2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an instance of the XmlTextWriter class using the specified
        ///       TextWriter.
        ///    </para>
        /// </devdoc>
        public XmlTextWriter(TextWriter w) : this() {
            textWriter = w;

            encoding = w.Encoding;
            xmlEncoder = new XmlTextEncoder(w, this.encoding);
            xmlEncoder.QuoteChar = this.quoteChar;
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.BaseStream"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the XmlTextWriter base stream.</para>
        /// </devdoc>
        public Stream BaseStream  {
            get {
                StreamWriter streamWriter = textWriter as StreamWriter;
                return (streamWriter == null ? null : streamWriter.BaseStream);
            }
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.Namespaces"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       or sets a value indicating whether to do namespace support.</para>
        /// </devdoc>
        public bool Namespaces {
            get { return this.namespaces;}
            set {
                if (this.currentState != State.Start)
                    throw new InvalidOperationException(Res.GetString(Res.Xml_NotInWriteState));

                this.namespaces = value;
            }
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.Formatting"]/*' />
        /// <devdoc>
        ///    <para> Indicates how the output
        ///       is formatted.</para>
        /// </devdoc>
        public Formatting Formatting {
            get { return this.formatting;}
            set { this.formatting = value; this.indented = value == Formatting.Indented;}
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.Indentation"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets how many IndentChars to write for each level
        ///       in the hierarchy when <see cref='System.Xml.XmlTextWriter.Formatting'/>
        ///       is set to "Indented".</para>
        /// </devdoc>
        public int Indentation {
            get { return this.indentation;}
            set {
                if (value < 0)
                    throw new ArgumentException(Res.GetString(Res.Xml_InvalidIndentation));
                this.indentation = value;
            }
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.IndentChar"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets which character to use for indenting
        ///       when <see cref='System.Xml.XmlTextWriter.Formatting'/>
        ///       is set to "Indented".</para>
        /// </devdoc>
        public char IndentChar {
            get { return this.indentChar;}
            set { this.indentChar = value;}
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.QuoteChar"]/*' />
        /// <devdoc>
        ///    Gets or sets which character to use to quote attribute
        ///    values.
        /// </devdoc>
        public char QuoteChar {
            get { return this.quoteChar;}
            set {
                if (value != '"' && value != '\'') {
                    throw new ArgumentException(Res.GetString(Res.Xml_InvalidQuote));
                }
                this.quoteChar = value;
            }
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteStartDocument"]/*' />
        /// <devdoc>
        ///    <para>Writes out the XML declaration with the
        ///       version "1.0".</para>
        /// </devdoc>
        public override void WriteStartDocument() {
            StartDocument(-1);
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteStartDocument1"]/*' />
        /// <devdoc>
        ///    Writes out the XML declaration with the
        ///    version "1.0" and the standalone attribute.
        /// </devdoc>
        public override void WriteStartDocument(bool standalone) {
            StartDocument(standalone ? 1 : 0);
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteEndDocument"]/*' />
        /// <devdoc>
        ///    Closes any open elements or attributes and puts the
        ///    writer back in the Start state.
        /// </devdoc>
        public override void WriteEndDocument() {
            AutoCompleteAll();
            if (this.currentState != State.Epilog) {
                throw new ArgumentException(Res.GetString(Res.Xml_NoRoot));
            }
            this.stateTable = stateTableDefault;
            this.currentState = State.Start;
            this.lastToken = Token.Empty;
        }


        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteDocType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes out the DOCTYPE declaration with the specified name
        ///       and optional attributes.
        ///    </para>
        /// </devdoc>
        public override void WriteDocType(string name, string pubid, string sysid, string subset) {

            ValidateName(name, false);

            AutoComplete(Token.Doctype);
            textWriter.Write("<!DOCTYPE ");
            textWriter.Write(name);
            if (pubid != null) {
                textWriter.Write(" PUBLIC " + quoteChar);
                textWriter.Write(pubid);
                textWriter.Write(quoteChar + " " + quoteChar);
                textWriter.Write(sysid);
                textWriter.Write(quoteChar);
            }
            else if (sysid != null) {
                textWriter.Write(" SYSTEM " + quoteChar);
                textWriter.Write(sysid);
                textWriter.Write(quoteChar);
            }
            if (subset != null) {
                textWriter.Write("[");
                textWriter.Write(subset);
                textWriter.Write("]");
            }
            textWriter.Write('>');
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteStartElement"]/*' />
        /// <devdoc>
        ///    <para>Writes out the specified start tag and associates it with the given namespace
        ///       and prefix.</para>
        /// </devdoc>
        public override void WriteStartElement(string prefix, string localName, string ns) {

            AutoComplete(Token.StartElement);
            PushStack();
            textWriter.Write('<');

            if (this.namespaces) {
                // Propagate default namespace and mix model down the stack.
                stack[top].defaultNs = stack[top-1].defaultNs;
                if (stack[top-1].defaultNsState != NamespaceState.Uninitialized)
                    stack[top].defaultNsState = NamespaceState.NotDeclaredButInScope;
                stack[top].mixed = stack[top-1].mixed;
                if (ns == null) {
                    // use defined prefix
                    if (prefix != null && prefix != String.Empty && (FindScopeForPrefix(prefix) == null)) {
                        throw new ArgumentException(Res.GetString(Res.Xml_UndefPrefix));
                    }
                }
                else {
                    if (prefix == null) {
                        string definedPrefix = FindPrefix(ns);
                        if (definedPrefix != null) {
                            prefix = definedPrefix;
                        }
                        else {
                            PushNamespace(null, ns, false); // new default
                        }
                    }
                    else if (prefix == String.Empty) {
                        PushNamespace(null, ns, false); // new default
                    }
                    else {
                        if (ns == String.Empty) {
                            throw new ArgumentException(Res.GetString(Res.Xml_PrefixForEmptyNs));
                        }
                        VerifyPrefixXml(prefix, ns);
                        PushNamespace(prefix, ns, false); // define
                    }
                }
                stack[top].prefix = null;
                if (prefix != null && prefix != String.Empty) {
                    stack[top].prefix = prefix;
                    textWriter.Write(prefix);
                    textWriter.Write(':');
                }
            }
            else {
                if ((ns != null && ns != String.Empty) || (prefix != null && prefix != String.Empty)) {
                    throw new ArgumentException(Res.GetString(Res.Xml_NoNamespaces));
                }
            }
            stack[top].name = localName;
            textWriter.Write(localName);
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteEndElement"]/*' />
        /// <devdoc>
        ///    <para>Closes one element and pops the corresponding namespace scope.</para>
        /// </devdoc>
        public override  void WriteEndElement() {
            InternalWriteEndElement(false);
        }
        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteFullEndElement"]/*' />
        /// <devdoc>
        ///    <para>Closes one element and pops the corresponding namespace scope.</para>
        /// </devdoc>
        public override  void WriteFullEndElement() {
            InternalWriteEndElement(true);
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteStartAttribute"]/*' />
        /// <devdoc>
        ///    <para>Writes the start of an attribute.</para>
        /// </devdoc>
        public override  void WriteStartAttribute(string prefix, string localName, string ns) {
            AutoComplete(Token.StartAttribute);

            this.specialAttr = SpecialAttr.None;
            if (this.namespaces) {

                if (prefix == String.Empty) {
                    prefix = null;
                }

                if (ns == XmlReservedNs.NsXmlNs && prefix == null && localName != "xmlns") {
                    prefix = "xmlns";
                }

                if (prefix == "xml") {
                    if (localName == "lang") {
                        this.specialAttr = SpecialAttr.XmlLang;
                    }
                    else if (localName == "space") {
                        this.specialAttr = SpecialAttr.XmlSpace;
                    }
                    /* bug54408. to be fwd compatible we need to treat xml prefix as reserved
                       and not really insist on a specific value. Who knows in the future it
                       might be OK to say xml:blabla
                    else {
                        throw new ArgumentException(Res.GetString(Res.Xml_InvalidPrefix));
                    }*/
                }
                else if (prefix == "xmlns") {

                    if (XmlReservedNs.NsXmlNs != ns && ns != null) {
                        throw new ArgumentException(Res.GetString(Res.Xml_XmlnsBelongsToReservedNs));
                    }
                    if (localName == null || localName == String.Empty) {
                        localName = prefix;
                        prefix = null;
                        this.prefixForXmlNs = null;
                    }
                    else {
                        this.prefixForXmlNs = localName;
                    }
                    this.specialAttr = SpecialAttr.XmlNs;
                }
                else if (prefix == null && localName == "xmlns") {
                    if (XmlReservedNs.NsXmlNs != ns && ns != null) {
                        // add the below line back in when DOM is fixed
                        throw new ArgumentException(Res.GetString(Res.Xml_XmlnsBelongsToReservedNs));
                    }
                    this.specialAttr = SpecialAttr.XmlNs;
                    this.prefixForXmlNs = null;
                }
                else {
                    if (ns == null) {
                        // use defined prefix
                        if (prefix != null && (FindScopeForPrefix(prefix) == null)) {
                            throw new ArgumentException(Res.GetString(Res.Xml_UndefPrefix));
                        }
                    }
                    else if (ns == String.Empty) {
                        // empty namespace require null prefix
                        if (prefix != null) {
                            throw new ArgumentException(Res.GetString(Res.Xml_PrefixForEmptyNs));
                        }
                    }
                    else { // ns.Length != 0
                        VerifyPrefixXml(prefix, ns);
                        if (prefix != null && null != FindTopScopeForPrefix(prefix)) {
                            prefix = null;
                        }
                        // Now verify prefix validity
                        string definedPrefix = FindPrefix(ns);
                        if (definedPrefix != null && (prefix == null || prefix == definedPrefix)) {
                            prefix = definedPrefix;
                        }
                        else {
                            if (prefix == null) {
                                prefix = GeneratePrefix(); // need a prefix if
                            }
                            PushNamespace(prefix, ns, false);
                        }
                    }
                }
                if (prefix != null && prefix != String.Empty) {
                    textWriter.Write(prefix);
                    textWriter.Write(':');
                }
            }
            else {
                if ((ns != null && ns != String.Empty) || (prefix != null && prefix != String.Empty)) {
                    throw new ArgumentException(Res.GetString(Res.Xml_NoNamespaces));
                }
                if (localName == "xml:lang") {
                    this.specialAttr = SpecialAttr.XmlLang;
                }
                else if (localName == "xml:space") {
                    this.specialAttr = SpecialAttr.XmlSpace;
                }
            }
            xmlEncoder.StartAttribute(this.specialAttr != SpecialAttr.None);

            textWriter.Write(localName);
            textWriter.Write('=');
            if (this.curQuoteChar != this.quoteChar) {
                this.curQuoteChar = this.quoteChar;
                xmlEncoder.QuoteChar = this.quoteChar;
            }
            textWriter.Write(this.curQuoteChar);
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteEndAttribute"]/*' />
        /// <devdoc>
        /// <para>Closes the previous <see cref='System.Xml.XmlTextWriter.WriteStartAttribute'/>
        /// call.</para>
        /// </devdoc>
        public override void WriteEndAttribute() {
            AutoComplete(Token.EndAttribute);
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteCData"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes out a &lt;![CDATA[...]]&gt; block containing
        ///       the specified text.
        ///    </para>
        /// </devdoc>
        public override void WriteCData(string text) {
            AutoComplete(Token.CData);
            if (null != text && text.IndexOf("]]>") >= 0) {
                throw new ArgumentException(Res.GetString(Res.Xml_InvalidCDataChars));
            }
            textWriter.Write("<![CDATA[");

            if (null != text) {
                xmlEncoder.WriteRawString(text);
            }
            textWriter.Write("]]>");
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteComment"]/*' />
        /// <devdoc>
        ///    <para>Writes out a comment &lt;!--...--&gt; containing
        ///       the specified text.</para>
        /// </devdoc>
        public override void WriteComment(string text) {
            if (null != text && (text.IndexOf("--")>=0 || (text != String.Empty && text[text.Length-1] == '-'))) {
                throw new ArgumentException(Res.GetString(Res.Xml_InvalidCommentChars));
            }
            AutoComplete(Token.Comment);
            textWriter.Write("<!--");
            if (null != text) {
                xmlEncoder.WriteRawString(text);
            }
            textWriter.Write("-->");
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteProcessingInstruction"]/*' />
        /// <devdoc>
        ///    <para>Writes out a processing instruction with a space between
        ///       the name and text as follows: &lt;?name text?&gt;.</para>
        /// </devdoc>
        public override void WriteProcessingInstruction(string name, string text) {
            if (null != text && text.IndexOf("?>")>=0) {
                throw new ArgumentException(Res.GetString(Res.Xml_InvalidPiChars));
            }
            if (0 == String.Compare(name, "xml", true, CultureInfo.InvariantCulture) && this.stateTable == stateTableDocument) {
                throw new ArgumentException(Res.GetString(Res.Xml_DupXmlDecl));
            }
            AutoComplete(Token.PI);
            InternalWriteProcessingInstruction(name, text);
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteEntityRef"]/*' />
        /// <devdoc>
        ///    <para>Writes out an entity reference as follows: "&amp;"+name+";".</para>
        /// </devdoc>
        public override void WriteEntityRef(string name) {
            ValidateName(name, false);
            AutoComplete(Token.Content);
            xmlEncoder.WriteEntityRef(name);
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteCharEntity"]/*' />
        /// <devdoc>
        ///    <para>Forces the
        ///       generation of a character entity for the specified Unicode character value.</para>
        /// </devdoc>
        public override void WriteCharEntity(char ch) {
            AutoComplete(Token.Content);
            xmlEncoder.WriteCharEntity(ch);
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteWhitespace"]/*' />
        /// <devdoc>
        ///    Writes out the given whitespace.
        /// </devdoc>
        public override void WriteWhitespace(string ws) {

            if (null == ws || String.Empty == ws) {
                throw new ArgumentException(Res.GetString(Res.Xml_NonWhitespace));
            }

            for (int i = 0; i < ws.Length; i ++) {
                if (!XmlCharType.IsWhiteSpace(ws[i])) {
                    throw new ArgumentException(Res.GetString(Res.Xml_NonWhitespace));
                }
            }
            AutoComplete(Token.Whitespace);
            xmlEncoder.Write(ws);
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes out the specified text content.
        ///    </para>
        /// </devdoc>
        public override void WriteString(string text) {
            if (null != text  && String.Empty != text) {
                AutoComplete(Token.Content);
                xmlEncoder.Write(text);
            }
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteSurrogateCharEntity"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes out the specified text content.
        ///    </para>
        /// </devdoc>

        public override void WriteSurrogateCharEntity(char lowChar, char highChar){
            AutoComplete(Token.Content);
            xmlEncoder.WriteSurrogateCharEntity(lowChar, highChar);
        }


        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteChars"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes text a buffer at a time.
        ///    </para>
        /// </devdoc>
        public override void WriteChars(Char[] buffer, int index, int count) {
            AutoComplete(Token.Content);
            xmlEncoder.Write(buffer, index, count);
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteRaw"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes raw markup manually from a character buffer.
        ///    </para>
        /// </devdoc>
        public override void WriteRaw(Char[] buffer, int index, int count) {

            AutoComplete(Token.RawData);
            xmlEncoder.Flush();
            xmlEncoder.WriteRaw(buffer, index, count);
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteRaw1"]/*' />
        /// <devdoc>
        ///    <para>Writes raw markup manually from a string.</para>
        /// </devdoc>
        public override void WriteRaw(String data) {
            AutoComplete(Token.RawData);
            xmlEncoder.Flush();
            xmlEncoder.WriteRaw(data);
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteBase64"]/*' />
        /// <devdoc>
        ///    <para>Encodes the specified binary bytes as base64 and writes out
        ///       the resulting text.</para>
        /// </devdoc>
        public override void WriteBase64(byte[] buffer, int index, int count) {
            if (!this.flush) {
                AutoComplete(Token.Content);
            }

            this.flush = true;
            // No need for us to explicitly validate the args. The StreamWriter will do
            // it for us.
            if (null == this.base64Encoder) {
                this.base64Encoder = new Base64Encoder();
            }
            WriteRaw(this.base64Encoder.EncodeToBase64(buffer, index, count));
        }


        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteBinHex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Encodes the specified binary bytes as binhex and writes out
        ///       the resulting text.
        ///    </para>
        /// </devdoc>
        public override void WriteBinHex(byte[] buffer, int index, int count) {
            AutoComplete(Token.Content);
            WriteRaw(BinHexEncoder.EncodeToBinHex(buffer, index, count));
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteState"]/*' />
        /// <devdoc>
        /// <para>Gets the state of the stream.</para>
        /// </devdoc>
        public override WriteState WriteState {
            get {
                switch (this.currentState) {
                    case State.Start :
                        return WriteState.Start;
                    case State.Prolog :
                    case State.PostDTD :
                        return WriteState.Prolog;
                    case State.Element :
                        return WriteState.Element;
                    case State.Attribute :
                        return WriteState.Attribute;
                    case State.Content :
                    case State.Epilog :
                        return WriteState.Content;
                    default :
                        return WriteState.Closed;
                }
            }
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.Close"]/*' />
        /// <devdoc>
        ///    <para>Close this stream and the underlying stream.</para>
        /// </devdoc>
        public override void Close() {
            try {
                AutoCompleteAll();
            } catch(Exception){} // never fail
            xmlEncoder.Flush();
            textWriter.Close();
            this.currentState = State.Closed;
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.Flush"]/*' />
        /// <devdoc>
        ///    <para>Flush whatever is in the buffer to the underlying streams and flush the
        ///       underlying stream.</para>
        /// </devdoc>
        public override void Flush() {
            textWriter.Flush();
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteName"]/*' />
        /// <devdoc>
        ///    <para>Writes out the specified name, ensuring it is a valid Name
        ///       according to the XML specification (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name
        ///       ).</para>
        /// </devdoc>
        public override void WriteName(string name) {
            AutoComplete(Token.Content);
            xmlEncoder.Flush();
            InternalWriteName(name, false);
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteQualifiedName"]/*' />
        /// <devdoc>
        ///    <para>Writes out the specified namespace-qualified name by looking up the prefix
        ///       that is in scope for the given namespace.</para>
        /// </devdoc>
        public override void WriteQualifiedName(string localName, string ns) {
            AutoComplete(Token.Content);
            xmlEncoder.Flush();
            if (this.namespaces) {
                if (ns != null && ns != String.Empty && ns != stack[top].defaultNs) {
                    string prefix = FindPrefix(ns);
                    if (prefix == null) {
                        if (this.currentState != State.Attribute) {
                            throw new ArgumentException(Res.GetString(Res.Xml_UndefNamespace, ns));
                        }
                        prefix = GeneratePrefix(); // need a prefix if
                        PushNamespace(prefix, ns, false);
                    }
                    if (prefix != String.Empty) {
                        InternalWriteName(prefix, true);
                        textWriter.Write(':');
                    }
                }
            }
            else if (ns != null && ns != String.Empty) {
                throw new ArgumentException(Res.GetString(Res.Xml_NoNamespaces));
            }
            InternalWriteName(localName, true);
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.LookupPrefix"]/*' />
        /// <devdoc>
        ///    <para>Returns the closest prefix defined in the current
        ///       namespace scope for the specified namespace URI.</para>
        /// </devdoc>
        public override string LookupPrefix(string ns) {
            if (ns == null || ns == String.Empty) {
                throw new ArgumentException(Res.GetString(Res.Xml_EmptyName));
            }
            string s =  FindPrefix(ns);
            if (s == null && ns == stack[top].defaultNs) {
                s = string.Empty;
            }
            return s;
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.XmlSpace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an XmlSpace representing the current xml:space scope.
        ///    </para>
        /// </devdoc>
        public override XmlSpace XmlSpace {
            get {
                for (int i = top; i > 0; i--) {
                    XmlSpace xs = stack[i].xmlSpace;
                    if (xs != XmlSpace.None)
                        return xs;
                }
                return XmlSpace.None;
            }
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.XmlLang"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the current xml:lang scope.
        ///    </para>
        /// </devdoc>
        public override string XmlLang {
            get {
                for (int i = top; i > 0; i--) {
                    String xlang = stack[i].xmlLang;
                    if (xlang != null)
                        return xlang;
                }
                return null;
            }
        }

        /// <include file='doc\XmlTextWriter.uex' path='docs/doc[@for="XmlTextWriter.WriteNmToken"]/*' />
        /// <devdoc>
        ///    <para>Writes out the specified name, ensuring it is a valid NmToken
        ///       according to the XML specification (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name).</para>
        /// </devdoc>
        public override void WriteNmToken(string name) {
            AutoComplete(Token.Content);
            xmlEncoder.Flush();

            if (name == null || name == String.Empty) {
                throw new ArgumentException(Res.GetString(Res.Xml_EmptyName));
            }
            int nameLength = name.Length;
            int position   = 0;

            while (position < nameLength && XmlCharType.IsNameChar(name[position])) {
                position ++;
            }

            if (position < nameLength) {
                throw new ArgumentException(Res.GetString(Res.Xml_InvalidNameChars, name));
            }
            textWriter.Write(name);
        }

        // State machine is working through autocomplete
        private enum State {
            Start,
            Prolog,
            PostDTD,
            Element,
            Attribute,
            Content,
            AttrOnly,
            Epilog,
            Error,
            Closed
        }

        private enum Token {
            PI,
            Doctype,
            Comment,
            CData,
            StartElement,
            EndElement,
            LongEndElement,
            StartAttribute,
            EndAttribute,
            Content,
            RawData,
            Whitespace,
            Empty
        }

        static string[] stateName = {
            "Start",
            "Prolog",
            "PostDTD",
            "Element",
            "Attribute",
            "Content",
            "AttrOnly",
            "Epilog",
            "Error",
            "Closed",
        };

        static string[] tokenName = {
            "PI",
            "Doctype",
            "Comment",
            "CData",
            "StartElement",
            "EndElement",
            "LongEndElement",
            "StartAttribute",
            "EndAttribute",
            "Content",
            "RawData",
            "Whitespace",
            "Empty"
        };

        static readonly State[,] stateTableDefault = {
            //                          State.Start      State.Prolog     State.PostDTD    State.Element    State.Attribute  State.Content   State.AttrOnly   State.Epilog
            //
            /* Token.PI             */{ State.Prolog,    State.Prolog,    State.PostDTD,   State.Content,   State.Content,   State.Content,  State.Error,     State.Epilog},
            /* Token.Doctype        */{ State.PostDTD,   State.PostDTD,   State.Error,     State.Error,     State.Error,     State.Error,    State.Error,     State.Error},
            /* Token.Comment        */{ State.Prolog,    State.Prolog,    State.PostDTD,   State.Content,   State.Content,   State.Content,  State.Error,     State.Epilog},
            /* Token.CData          */{ State.Content,   State.Content,   State.Error,     State.Content,   State.Content,   State.Content,  State.Error,     State.Epilog},
            /* Token.StartElement   */{ State.Element,   State.Element,   State.Element,   State.Element,   State.Element,   State.Element,  State.Error,     State.Element},
            /* Token.EndElement     */{ State.Error,     State.Error,     State.Error,     State.Content,   State.Content,   State.Content,  State.Error,     State.Error},
            /* Token.LongEndElement */{ State.Error,     State.Error,     State.Error,     State.Content,   State.Content,   State.Content,  State.Error,     State.Error},
            /* Token.StartAttribute */{ State.AttrOnly,  State.Error,     State.Error,     State.Attribute, State.Attribute, State.Error,    State.Error,     State.Error},
            /* Token.EndAttribute   */{ State.Error,     State.Error,     State.Error,     State.Error,     State.Element,   State.Error,    State.Epilog,     State.Error},
            /* Token.Content        */{ State.Content,   State.Content,   State.Error,     State.Content,   State.Attribute, State.Content,  State.Attribute, State.Epilog},
            /* Token.RawData        */{ State.Prolog,    State.Prolog,    State.PostDTD,   State.Content,   State.Attribute, State.Content,  State.Attribute, State.Epilog},
            /* Token.Whitespace     */{ State.Prolog,    State.Prolog,    State.PostDTD,   State.Content,   State.Attribute, State.Content,  State.Attribute, State.Epilog},
        };

        static readonly State[,] stateTableDocument = {
            //                          State.Start      State.Prolog     State.PostDTD    State.Element    State.Attribute  State.Content   State.AttrOnly   State.Epilog
            //
            /* Token.PI             */{ State.Error,     State.Prolog,    State.PostDTD,   State.Content,   State.Content,   State.Content,  State.Error,     State.Epilog},
            /* Token.Doctype        */{ State.Error,     State.PostDTD,   State.Error,     State.Error,     State.Error,     State.Error,    State.Error,     State.Error},
            /* Token.Comment        */{ State.Error,     State.Prolog,    State.PostDTD,   State.Content,   State.Content,   State.Content,  State.Error,     State.Epilog},
            /* Token.CData          */{ State.Error,     State.Error,     State.Error,     State.Content,   State.Content,   State.Content,  State.Error,     State.Error},
            /* Token.StartElement   */{ State.Error,     State.Element,   State.Element,   State.Element,   State.Element,   State.Element,  State.Error,     State.Error},
            /* Token.EndElement     */{ State.Error,     State.Error,     State.Error,     State.Content,   State.Content,   State.Content,  State.Error,     State.Error},
            /* Token.LongEndElement */{ State.Error,     State.Error,     State.Error,     State.Content,   State.Content,   State.Content,  State.Error,     State.Error},
            /* Token.StartAttribute */{ State.Error,     State.Error,     State.Error,     State.Attribute, State.Attribute, State.Error,    State.Error,     State.Error},
            /* Token.EndAttribute   */{ State.Error,     State.Error,     State.Error,     State.Error,     State.Element,   State.Error,    State.Error,     State.Error},
            /* Token.Content        */{ State.Error,     State.Error,     State.Error,     State.Content,   State.Attribute, State.Content,  State.Error,     State.Error},
            /* Token.RawData        */{ State.Error,     State.Prolog,    State.PostDTD,   State.Content,   State.Attribute, State.Content,  State.Error,     State.Epilog},
            /* Token.Whitespace     */{ State.Error,     State.Prolog,    State.PostDTD,   State.Content,   State.Attribute, State.Content,  State.Error,     State.Epilog},
        };

        State[,] stateTable;
        State currentState;
        Token lastToken;

        void StartDocument(int standalone) {
            if (this.currentState != State.Start) {
                throw new InvalidOperationException(Res.GetString(Res.Xml_NotTheFirst));
            }
            this.stateTable = stateTableDocument;
            this.currentState = State.Prolog;

            StringBuilder bufBld = new StringBuilder(128);
            bufBld.Append("version=" + quoteChar + "1.0" + quoteChar);
            if (this.encoding != null) {
                bufBld.Append(" encoding=" + quoteChar);
                bufBld.Append(this.encoding.WebName);
                bufBld.Append(quoteChar);
            }
            if (standalone >= 0) {
                bufBld.Append(" standalone=" + quoteChar);
                bufBld.Append(standalone == 0 ? "no" : "yes");
                bufBld.Append(quoteChar);
            }
            InternalWriteProcessingInstruction("xml", bufBld.ToString());
        }

        void AutoComplete(Token token) {
            if (this.currentState == State.Closed) {
                throw new InvalidOperationException(Res.GetString(Res.Xml_Closed));
            }

            State newState = this.stateTable[(int)token, (int)this.currentState];
            if (newState == State.Error) {
                throw new InvalidOperationException(Res.GetString(Res.Xml_WrongToken, tokenName[(int)token], stateName[(int)this.currentState]));
            }

            switch (token) {
                case Token.Doctype:
                    if (this.indented && this.currentState != State.Start) {
                        Indent(false);
                    }
                    break;

                case Token.StartElement:
                case Token.Comment:
                case Token.PI:
                case Token.CData:
                    if (this.currentState == State.Attribute) {
                        WriteEndAttributeQuote();
                        WriteEndStartTag(false);
                    }
                    else if (this.currentState == State.Element) {
                        WriteEndStartTag(false);
                    }
                    xmlEncoder.Flush();
                    if (token == Token.CData) {
                        stack[top].mixed = true;
                    }
                    else if (this.indented && this.currentState != State.Start) {
                        Indent(false);
                    }
                    break;

                case Token.EndElement:
                case Token.LongEndElement:
                    if (this.flush) {
                        FlushEncoders();
                    }
                    if (this.currentState == State.Attribute) {
                        WriteEndAttributeQuote();
                    }
                    if (this.currentState == State.Content) {
                        token = Token.LongEndElement;
                    }
                    else {
                        WriteEndStartTag(token == Token.EndElement);
                    }
                    if (stateTableDocument == this.stateTable && top == 1) {
                        newState = State.Epilog;
                    }
                    break;

                case Token.StartAttribute:
                    if (this.flush) {
                        FlushEncoders();
                    }
                    if (this.currentState == State.Attribute) {
                        WriteEndAttributeQuote();
                        textWriter.Write(' ');
                    }
                    else if (this.currentState == State.Element) {
                        textWriter.Write(' ');
                    }
                    break;

                case Token.EndAttribute:
                    if (this.flush) {
                        FlushEncoders();
                    }
                    WriteEndAttributeQuote();
                    break;

                case Token.Whitespace:
                case Token.Content:
                case Token.RawData:
                    if (this.currentState == State.Element && this.lastToken != Token.Content) {
                        WriteEndStartTag(false);
                    }
                    else if (this.currentState == State.Attribute && this.specialAttr == SpecialAttr.None  && this.lastToken == Token.Content) {
                        // Beta 2
                        // textWriter.Write(' ');
                    }
                    if (newState == State.Content) {
                        stack[top].mixed = true;
                    }
                    break;

                default:
                    throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
            }
            this.currentState = newState;
            this.lastToken = token;
        }

        void AutoCompleteAll() {
            while (top > 0) {
                if (this.flush) {
                    FlushEncoders();
                }
                WriteEndElement();
            }
        }

        void InternalWriteEndElement(bool longFormat) {
            if (top <= 0) {
                throw new InvalidOperationException(Res.GetString(Res.Xml_NoStartTag));
            }
            // if we are in the element, we need to close it.
            AutoComplete(longFormat ?  Token.LongEndElement : Token.EndElement);
            if (this.lastToken == Token.LongEndElement) {
                if (this.indented) {
                    Indent(true);
                }
                textWriter.Write('<');
                textWriter.Write('/');
                if (this.namespaces && stack[top].prefix != null) {
                    textWriter.Write(stack[top].prefix);
                    textWriter.Write(':');
                }
                textWriter.Write(stack[top].name);
                textWriter.Write('>');
            }
            top--;
        }

        internal void WriteNoEndElement() { // XmlToHtmlWriter needs it for <area> & Co.
            AutoComplete(Token.LongEndElement);
            top--;
        }

        void WriteEndStartTag(bool empty) {
            xmlEncoder.StartAttribute(false);
            for (Scope s = stack[top].scopes; s != null; s = s.next) {
                if (! s.declared) {
                    textWriter.Write(" xmlns");
                    textWriter.Write(':');
                    textWriter.Write(s.prefix);
                    textWriter.Write('=');
                    textWriter.Write(this.quoteChar);
                    xmlEncoder.Write(s.ns);
                    textWriter.Write(this.quoteChar);
                }
            }
            // Default
            if ((stack[top].defaultNs != stack[top - 1].defaultNs) &&
                (stack[top].defaultNsState == NamespaceState.DeclaredButNotWrittenOut)) {
                textWriter.Write(" xmlns");
                textWriter.Write('=');
                textWriter.Write(this.quoteChar);
                xmlEncoder.Write(stack[top].defaultNs);
                textWriter.Write(this.quoteChar);
                stack[top].defaultNsState = NamespaceState.DeclaredAndWrittenOut;
            }
            xmlEncoder.EndAttribute();
            if (empty) {
                textWriter.Write(" /");
            }
            textWriter.Write('>');
        }

        void WriteEndAttributeQuote() {
            if (this.specialAttr != SpecialAttr.None) {
                // Ok, now to handle xmlspace, etc.
                HandleSpecialAttribute();
            }
            xmlEncoder.EndAttribute();
            xmlEncoder.Flush();
            textWriter.Write(this.curQuoteChar);
        }

        void Indent(bool beforeEndElement) {
            // pretty printing.
            if (top == 0) {
                textWriter.WriteLine();
            }
            else if (!stack[top].mixed) {
                textWriter.WriteLine();
                int i = beforeEndElement ? top - 1 : top;
                for (i *= this.indentation; i > 0; i--) {
                    textWriter.Write(this.indentChar);
                }
            }
        }

        // pushes new namespace scope, and returns generated prefix, if one
        // was needed to resolve conflicts.
        void PushNamespace(string prefix, string ns, bool declared) {

            //Console.WriteLine("PushNamespace Prefix:{0}, \tns: {1}, \tdeclared:{2}\n", prefix, ns, declared);

            if (XmlReservedNs.NsXmlNs == ns)
            {
                throw new ArgumentException(Res.GetString(Res.Xml_CanNotBindToReservedNamespace));
            }

            if (prefix == null) {
                switch(stack[top].defaultNsState)
                {
                    case NamespaceState.DeclaredButNotWrittenOut:
                        Debug.Assert (declared == true, "Unexpected situation!!");
                        // the first namespace that the user gave us is what we
                        // like to keep. refer to bug 51463 - govinda
                        break;
                    case NamespaceState.Uninitialized:
                    case NamespaceState.NotDeclaredButInScope:
                        // we now got a brand new namespace that we need to remember
                        stack[top].defaultNs = ns;
                        break;
                    default:
                        Debug.Assert(false, "Should have never come here");
                        return;
                }
                stack[top].defaultNsState = (declared ? NamespaceState.DeclaredAndWrittenOut : NamespaceState.DeclaredButNotWrittenOut);
            }
            else {

                if (String.Empty != prefix && String.Empty == ns)
                {
                    throw new ArgumentException(Res.GetString(Res.Xml_PrefixForEmptyNs));
                }

                Scope scopePrefix = FindScopeForPrefix(prefix);
                if (scopePrefix != null && scopePrefix.ns == ns) {
                    // it is already in scope.
                    if (declared) {
                        scopePrefix.declared = true;
                    }
                }
                else {

                    // see if prefix conflicts for the current element
                    if (declared) {
                        Scope s1 = FindTopScopeForPrefix(prefix);
                        if (s1 != null) {
                            s1.declared = true; // old one is silenced now
                        }
                    }

                    stack[top].scopes = new Scope(prefix, ns, declared, stack[top].scopes);
                }
            }

        }

        string GeneratePrefix() {
            int temp = stack[top].prefixCount++ + 1;
            return "d" + top.ToString("d") + "p" + temp.ToString("d");
        }

        void InternalWriteProcessingInstruction(string name, string text) {
            textWriter.Write("<?");
            ValidateName(name, false);
            textWriter.Write(name);
            textWriter.Write(' ');
            if (null != text) {
                xmlEncoder.WriteRawString(text);
            }
            textWriter.Write("?>");
        }

        Scope FindScopeForNs(string ns) {
            for (int i = top; i > 0; i--) {
                for (Scope s = stack[i].scopes; s != null; s = s.next) {
                    if (s.ns == ns) {
                        return s;
                    }
                }
            }
            return null;
        }

        Scope FindScopeForPrefix(string prefix) {
            for (int i = top; i > 0; i--) {
                for (Scope s = stack[i].scopes; s != null; s = s.next) {
                    if (s.prefix == prefix) {
                        return s;
                    }
                }
            }
            return null;
        }

        Scope FindTopScopeForPrefix(string prefix) {
            for (Scope s = stack[top].scopes; s != null; s = s.next) {
                if (s.prefix == prefix) {
                    return s;
                }
            }
            return null;
        }

        string FindPrefix(string ns) {
            Scope s = FindScopeForNs(ns);

            if (s != null && FindScopeForPrefix(s.prefix) != s) {
                s = null;
            }

            return s == null ? null : s.prefix;
        }

        // There are three kind of strings we write out - Name, LocalName and Prefix.
        // Both LocalName and Prefix can be represented with NCName == false and Name
        // can be represented as NCName == true

        void InternalWriteName(string name, bool NCName) {
            ValidateName(name, NCName);
            textWriter.Write(name);
        }

        void ValidateName(string name, bool NCName) {
            if (name == null || name == String.Empty) {
                throw new ArgumentException(Res.GetString(Res.Xml_EmptyName));
            }
            int nameLength = name.Length;
            int position   = 0;
            int colonPosition = -1;
            if (this.namespaces) {
                if (XmlCharType.IsStartNCNameChar(name[0])) {
                    position ++;
                    if (NCName) {
                        while (position < nameLength && XmlCharType.IsNCNameChar(name[position])) {
                            position ++;
                        }
                    }
                    else {
                        while (position < nameLength) {
                            if (! XmlCharType.IsNCNameChar(name[position]))
                            {
                               if (name[position] == ':')
                               {
                                   if (colonPosition == -1)
                                      colonPosition = position;
                                   else
                                      break;
                               }
                               else
                                   break;
                            }
                            position ++;
                        }
                    }
                }
            }
            else {
                if (XmlCharType.IsStartNameChar(name[0])) {
                    position ++;
                    while (position < nameLength && XmlCharType.IsNameChar(name[position])) {
                        position ++;
                    }
                }

            }
            if (position < nameLength || colonPosition == nameLength-1) {
                throw new ArgumentException(Res.GetString(Res.Xml_InvalidNameChars, name));
            }
        }

        void HandleSpecialAttribute() {
            string value = xmlEncoder.RawValue;
            switch (this.specialAttr) {
                case SpecialAttr.XmlLang:
                    stack[top].xmlLang = value;
                    break;
                case SpecialAttr.XmlSpace:
                    // validate XmlSpace attribute
                    if (value == "default") {
                        stack[top].xmlSpace = XmlSpace.Default;
                    }
                    else if (value == "preserve") {
                        stack[top].xmlSpace = XmlSpace.Preserve;
                    }
                    else {
                        throw new ArgumentException(Res.GetString(Res.Xml_InvalidXmlSpace));
                    }
                    break;
                case SpecialAttr.XmlNs:
                    VerifyPrefixXml(this.prefixForXmlNs, value);
                    PushNamespace(this.prefixForXmlNs, value, true);
                    break;
            }
        }


        void VerifyPrefixXml(string prefix, string ns) {

            if (prefix != null && prefix.Length == 3) {
                if (
                   (prefix[0] == 'x' || prefix[0] == 'X') &&
                   (prefix[1] == 'm' || prefix[1] == 'M') &&
                   (prefix[2] == 'l' || prefix[2] == 'L')
                   ) {
                    if (XmlReservedNs.NsXml != ns) {
                        throw new ArgumentException(Res.GetString(Res.Xml_InvalidPrefix));
                    }
                }
            }
        }

        void PushStack() {
            if (top == stack.Length - 1) {
                TagInfo[] na = new TagInfo[stack.Length + 10];
                if (top > 0) Array.Copy(stack,na,top + 1);
                stack = na;
            }

            top ++; // Move up stack
            stack[top].Init();
        }

        void FlushEncoders()
        {
            if (null != this.base64Encoder) {
                WriteString(this.base64Encoder.Flush());
            }

            this.flush = false;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlstreamreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlStreamReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml
{
    using System;
    using System.IO;
    using System.Text;

    internal class XmlStreamReader: TextReader
    {
        internal Stream _Stream = null;

        internal XmlStreamReader(Stream stream) {
            _Stream = stream;
        }

        internal int Read(byte[] data, int offset, int length) {
            return _Stream.Read(data, offset, length);
        }

        public override void Close() {
            _Stream.Close();
            base.Close();
        }

        internal bool CanCalcLength {
            get { return _Stream != null && _Stream.CanSeek; }
        }

        internal long Length {
            get { return _Stream.Length; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmltext.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlText.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlText.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml 
{
    using System;
    using System.Text;
    using System.Diagnostics;
    using System.Xml.XPath;

    /// <include file='doc\XmlText.uex' path='docs/doc[@for="XmlText"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the text content of an element or attribute.
    ///    </para>
    /// </devdoc>
    public class XmlText : XmlCharacterData {
        /// <include file='doc\XmlText.uex' path='docs/doc[@for="XmlText.XmlText"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        internal XmlText( string strData ): this( strData, null ) {
        }

        /// <include file='doc\XmlText.uex' path='docs/doc[@for="XmlText.XmlText1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected internal XmlText( string strData, XmlDocument doc ): base( strData, doc ) {
        }

        /// <include file='doc\XmlText.uex' path='docs/doc[@for="XmlText.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node.
        ///    </para>
        /// </devdoc>
        public override String Name
        { 
            get { return XmlDocument.strTextName;}
        }

        /// <include file='doc\XmlText.uex' path='docs/doc[@for="XmlText.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the current node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override String LocalName
        { 
            get { return XmlDocument.strTextName;}
        }

        /// <include file='doc\XmlText.uex' path='docs/doc[@for="XmlText.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType
        {
            get { return XmlNodeType.Text;}
        }

        /// <include file='doc\XmlText.uex' path='docs/doc[@for="XmlText.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a duplicate of this node.
        ///    </para>
        /// </devdoc>
        public override XmlNode CloneNode(bool deep) {
            Debug.Assert( OwnerDocument != null );
            return OwnerDocument.CreateTextNode( Data );
        }

        /// <include file='doc\XmlText.uex' path='docs/doc[@for="XmlText.Value"]/*' />
        public override String Value {
            get { return Data;}
            set { 
                Data = value;
                XmlNode parent = parentNode;
                if ( parent != null && parent.NodeType == XmlNodeType.Attribute ) {
                    XmlUnspecifiedAttribute attr = parent as XmlUnspecifiedAttribute;
                    if ( attr != null && !attr.Specified ) {
                        attr.SetSpecified( true );
                    }
                }
            }
        }

        /// <include file='doc\XmlText.uex' path='docs/doc[@for="XmlText.SplitText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Splits the node into two nodes at the specified offset, keeping
        ///       both in the tree as siblings.
        ///    </para>
        /// </devdoc>
        public virtual XmlText SplitText(int offset) {
            XmlNode parentNode = this.ParentNode;
            int length = this.Length;
            if( offset > length )
                throw new ArgumentOutOfRangeException( "offset" );
            //if the text node is out of the living tree, throw exception.
            if ( parentNode == null )
                throw new InvalidOperationException(Res.GetString(Res.Xdom_TextNode_SplitText)); 
            
            int count = length - offset;
            String splitData = Substring(offset, count);
            DeleteData(offset, count);
            XmlText newTextNode = OwnerDocument.CreateTextNode(splitData);
            parentNode.InsertBefore(newTextNode,this.NextSibling);
            return newTextNode;
        }

        /// <include file='doc\XmlText.uex' path='docs/doc[@for="XmlText.WriteTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteTo(XmlWriter w) {
            w.WriteString(Data);
        }

        /// <include file='doc\XmlText.uex' path='docs/doc[@for="XmlText.WriteContentTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves all the children of the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteContentTo(XmlWriter w) {
            // Intentionally do nothing
        }

        internal override XPathNodeType XPNodeType { get { return XPathNodeType.Text; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmltokenizedtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlTokenizedType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

 
namespace System.Xml {

    /// <include file='doc\XmlTokenizedType.uex' path='docs/doc[@for="XmlTokenizedType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum XmlTokenizedType {
        /// <include file='doc\XmlTokenizedType.uex' path='docs/doc[@for="XmlTokenizedType.CDATA"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CDATA,
        /// <include file='doc\XmlTokenizedType.uex' path='docs/doc[@for="XmlTokenizedType.ID"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ID,
        /// <include file='doc\XmlTokenizedType.uex' path='docs/doc[@for="XmlTokenizedType.IDREF"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        IDREF,
        /// <include file='doc\XmlTokenizedType.uex' path='docs/doc[@for="XmlTokenizedType.IDREFS"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        IDREFS,
        /// <include file='doc\XmlTokenizedType.uex' path='docs/doc[@for="XmlTokenizedType.ENTITY"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ENTITY,
        /// <include file='doc\XmlTokenizedType.uex' path='docs/doc[@for="XmlTokenizedType.ENTITIES"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ENTITIES,
        /// <include file='doc\XmlTokenizedType.uex' path='docs/doc[@for="XmlTokenizedType.NMTOKEN"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NMTOKEN,
        /// <include file='doc\XmlTokenizedType.uex' path='docs/doc[@for="XmlTokenizedType.NMTOKENS"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NMTOKENS,
        /// <include file='doc\XmlTokenizedType.uex' path='docs/doc[@for="XmlTokenizedType.NOTATION"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NOTATION,
        /// <include file='doc\XmlTokenizedType.uex' path='docs/doc[@for="XmlTokenizedType.ENUMERATION"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ENUMERATION,
        /// <include file='doc\XmlTokenizedType.uex' path='docs/doc[@for="XmlTokenizedType.QName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        QName,
        /// <include file='doc\XmlTokenizedType.uex' path='docs/doc[@for="XmlTokenizedType.NCName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NCName,
        /// <include file='doc\XmlTokenizedType.uex' path='docs/doc[@for="XmlTokenizedType.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlunspecifiedattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlUnspecifiedAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlUnspecifiedAttribute.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml
{
    using System;

    internal class XmlUnspecifiedAttribute: XmlAttribute {
        bool fSpecified = false;


        protected internal XmlUnspecifiedAttribute( string prefix, string localName, string namespaceURI, XmlDocument doc )
        : base( prefix, localName, namespaceURI, doc ) {
        }

        public override bool Specified
        {
            get { return fSpecified;}
        }


        public override XmlNode CloneNode(bool deep) {
            //CloneNode is deep for attributes irrespective of parameter
            XmlUnspecifiedAttribute attr = new XmlUnspecifiedAttribute( Prefix, LocalName, NamespaceURI, OwnerDocument );
            attr.CopyChildren( this, true );
            attr.fSpecified = true; //When clone, should return the specifed attribute as default
            return attr;
        }

        public override XmlNode InsertBefore(XmlNode newChild, XmlNode refChild) {
            XmlNode node = base.InsertBefore( newChild, refChild );
            fSpecified = true;
            return node;
        }

        public override XmlNode InsertAfter(XmlNode newChild, XmlNode refChild) {
            XmlNode node = base.InsertAfter( newChild, refChild );
            fSpecified = true;
            return node;
        }

        public override XmlNode ReplaceChild(XmlNode newChild, XmlNode oldChild) {
            XmlNode node = base.ReplaceChild( newChild, oldChild );
            fSpecified = true;
            return node;
        }

        public override XmlNode RemoveChild(XmlNode oldChild) {
            XmlNode node = base.RemoveChild(oldChild);
            fSpecified = true;
            return node;
        }

        public override XmlNode AppendChild(XmlNode newChild) {
            XmlNode node = base.AppendChild(newChild);
            fSpecified = true;
            return node;
        }

        public override void WriteTo(XmlWriter w) {
            if (fSpecified)
                base.WriteTo( w );
        }

        internal void SetSpecified(bool f) {
            fSpecified = f;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlurlresolver.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlUrlResolver.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml
{
    using System;
    using System.IO;
    using System.Net;
    using System.Security.Permissions;
    using System.Security.Policy;
    using System.Security;

    /// <include file='doc\XmlUrlResolver.uex' path='docs/doc[@for="XmlUrlResolver"]/*' />
    /// <devdoc>
    ///    <para>Resolves external XML resources named by a
    ///       Uniform Resource Identifier (URI).</para>
    /// </devdoc>
    public class XmlUrlResolver : XmlResolver {
        static XmlDownloadManager _DownloadManager = new XmlDownloadManager();
        ICredentials _credentials;

        // Construction

        /// <include file='doc\XmlUrlResolver.uex' path='docs/doc[@for="XmlUrlResolver.XmlUrlResolver"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the XmlUrlResolver class.
        ///    </para>
        /// </devdoc>
        public XmlUrlResolver() {
        }

        //UE attension
        /// <include file='doc\XmlUrlResolver.uex' path='docs/doc[@for="XmlUrlResolver.Credentials"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override ICredentials Credentials {
            set { _credentials = value; }
        }

        // Resource resolution

        /// <include file='doc\XmlUrlResolver.uex' path='docs/doc[@for="XmlUrlResolver.GetEntity"]/*' />
        /// <devdoc>
        ///    <para>Maps a
        ///       URI to an Object containing the actual resource.</para>
        /// </devdoc>
		public override Object GetEntity(Uri absoluteUri,
                                         string role,
                                         Type ofObjectToReturn) {
            if (ofObjectToReturn == null || ofObjectToReturn == typeof(System.IO.Stream)) {
                return _DownloadManager.GetStream(absoluteUri, _credentials);
            }
            else {
                throw new XmlException(Res.Xml_UnsupportedClass, string.Empty);
            }
        }

        /// <include file='doc\XmlUrlResolver.uex' path='docs/doc[@for="XmlUrlResolver.ResolveUri"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlvaluetokeninfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlValueTokenInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


using System;
using System.Text;
using System.Diagnostics;

namespace System.Xml {

/*
 * ValueTokenInfo class for value only token.
 * for Comment and CDATA node types.
 * This class does not have to worry about atomalize 
 * name and handle prefix, namespace.
 */

    internal class XmlValueTokenInfo : XmlBasicTokenInfo {
        //
        // node level properties
        protected int       _ValueOffset;         // store the offset of the value
        protected int       _ValueLength;         // store the lenght of the value
        protected String    _Value;
        protected String    _RawValue;

        XmlNormalizer       _Normalizer;
        protected bool      _HasNormalize;
        protected bool      _NormalizeText;

        internal XmlValueTokenInfo(XmlScanner scanner, XmlNamespaceManager nsMgr, XmlNodeType type, 
                                   int depth, bool nor) :
                                    base(scanner, nsMgr, type, depth) {
            _ValueOffset = -1;
            _ValueLength = -1;
            _Value = null;
            _Normalizer = null;
            _RawValue = String.Empty;        
            _NormalizeText = nor;
            _HasNormalize = !_NormalizeText;
        } 
        
        //
        // ignore EntityHandling flag
        //
        internal override String GetValue() {
            char[] data = null;
            int index = 0, length = 0;
            if (_Value == null) {
                if (_Normalizer != null) {
                    _Value = _Normalizer.ToString();
                    Debug.Assert(_HasNormalize);
                    _HasNormalize = true;
                }
                else {
                    data = _Scanner.InternalBuffer;
                    index = _ValueOffset - _Scanner.AbsoluteOffset;
                    length = _ValueLength;
                    if (!_HasNormalize) {
                        _Value = XmlComplianceUtil.EndOfLineNormalization(data, index, length);
                        _HasNormalize = true;
                    }
                    else 
                        _Value = new String(data, _ValueOffset - _Scanner.AbsoluteOffset, length);
                }
                if (!_HasNormalize) {
                    _HasNormalize = true;
                }
            }
            else if (!_HasNormalize) {
                _Value = XmlComplianceUtil.EndOfLineNormalization(_Value);             
            }
            return _Value;
        }

        internal override String RawValue
        {
            get
            {
                return _RawValue;
            }
            set
            {
                _RawValue = value;
            }
        }

        internal override String Value
        {
            get
            {
                return GetValue();
            }
            set
            {
                _Value = value;  
                _Normalizer = null;                        
                _HasNormalize = !_NormalizeText;
                _SchemaType = null;
                _TypedValue = null;
            }
        }

        internal override void SetValue( XmlNormalizer normalizer) {
            _Normalizer = normalizer;
            _Value = null;
            _HasNormalize = true;
            _SchemaType = null;
            _TypedValue = null;
        }

        internal virtual void SetValue(XmlScanner scanner, String value, int offset, int length ) {
            _Scanner = scanner;
            _Normalizer = null;
            _Value = value;
            _ValueOffset = offset;
            _ValueLength = length;      
            _HasNormalize = !_NormalizeText;
            _SchemaType = null;
            _TypedValue = null;
        }

        internal override bool IsAttributeText
        {
            get
            {
                return false;
            }
            set
            {            
            }
        }

        internal bool Normalization
        {
            set
            {
                _NormalizeText = value;
                _HasNormalize = !_NormalizeText;
            }
        }
    } // XmlValueTokenInfo
} // System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmltextreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="xmltextreader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml
{
    using System;
    using System.IO;
    using System.Collections;
    using System.Diagnostics;
    using System.Text;
    using System.Xml.Schema;
    using System.Globalization;
    using System.Threading;
    using System.Security.Permissions;

    //
    // PERF NOTE: no state machine in this code because it hurts perf
    //
    //

    /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader"]/*' />
    /// <devdoc>
    ///    Represents a reader that provides fast, non-cached
    ///    forward only stream
    ///    access to XML data.
    /// </devdoc>
    [PermissionSetAttribute( SecurityAction.InheritanceDemand, Name = "FullTrust" )]
    public class XmlTextReader : XmlReader, IXmlLineInfo {
        // parse functions index
        private const int _ParseRootIndex           = 1;
        private const int _ParseBeginTagIndex       = 2;
        private const int _ParseElementIndex        = 3;
        private const int _ReadEndElementIndex      = 4;
        private const int _ReadEndEntityIndex       = 5;
        private const int _FinishAttributeIndex     = 6;
        private const int _PopEndElementIndex       = 7;
        private const int _ClosedIndex              = 8;
        private const int _ReadEmptyTextIndex       = 9;
        private const int _PopEntityScannerIndex    = 10;
        private const int _ParseFunctionNext        = 11;
        private const int _FragmentXmlDeclParser    = 12;
        private const int _FragmentTrailingTextNode = 13;
        private const int _FragmentAttributeParser  = 14;
        private const int _FinishReadChars          = 15;
        private const int _InitReader               = 16;

        private const int STACK_INCREMENT = 10;

        // variables for hooking up other components

        private     int                 _CurrentElementStart;
        private     int                 _CurrentEndElementStart;
        private     int                 _CurrentEndElementEnd;
        private     bool                _BufferConsistency;
        private     XmlResolver         _XmlResolver = null;
        private     XmlNameTable        _NameTable = null;
        private     DtdParser           _DtdParser = null;
        private     ValidationEventHandler _ValidationEventHandler = null;

        // condition flags
        private     bool                _Normalization;
        private     bool                _CheckNamespaces;
        private     WhitespaceHandling  _WhitespaceHandling;
        //
        // internal variables for various uses
        private     HWStack             _ScannerStack;
        private     int                 _LastToken;
        private     int                 _RootCount = 0;
        private     int                 _NextFunction;
        private     int                 _NextState;
        private     int                 _PreviousFunction;
        private     bool                _ContinueParsing;
        private     int                 _ElementDepth;
        private     int                 _EntityDepthOffset = 0;
        private     Object              _Entity;
        private     XmlNodeType         _PartialContentNodeType = XmlNodeType.None;
        private     int                 _ReadInnerCharCount = 0;

        //ATOM variables
        internal    String              _StringName;
        internal    String              _MicrosoftSystemNamespace;
        internal    String              _Decimal;
        internal    String              _Hex;
        internal    String              _Amp;
        internal    String              _Lt;
        internal    String              _Gt;
        internal    String              _Quot;
        internal    String              _Apos;
        internal    String              _XmlNs;
        internal    String              _XmlSpaceAtom;
        internal    String              _XmlLangAtom;

        internal    static String       s_Standalone="standalone";
        internal    static String       s_Version   ="version";
        internal    static String       s_Encoding  ="encoding";

        internal    static String       s_VersionNo ="1.0";
        internal    static String       s_Yes       ="yes";
        internal    static String       s_No        ="no";
        // variables for external properties
        //
        // fields collection
        private     int                 _MaxCount;
        private     int                 _Used;
        private     XmlAttributeTokenInfo[] _Fields;

        //
        // token holder for different node type
        //
        private    XmlElementTokenInfo  _ElementToken;
        private    XmlElementTokenInfo  _TmpToken;
        private    XmlElementTokenInfo  _EndElementToken;

        private    XmlWSTokenInfo       _TextToken;
        private    XmlWSTokenInfo       _WhitespaceToken;
        private    XmlValueTokenInfo    _CommentToken;
        private    XmlValueTokenInfo    _CDATAToken;
        private    XmlDtdTokenInfo      _DocTypeToken;

        private    XmlNameValueTokenInfo _PIToken;
        private    XmlNameValueTokenInfo _ERToken;

        private    ElementInfo          _LastElementInfo;
        private    bool                 _ScannerEof;
        private    int                  _ReadCount;

        private    bool                 _StandAlone;
        internal    String               _BaseURI;
        private    int                  _MarkScannerCount;
        private    bool                 _CantHaveXmlDecl;

        private    StringBuilder        _StringBuilder;

        internal   HWStack             _ElementStack;
        internal   XmlNamespaceManager     _NsMgr = null;
        internal   XmlScanner          _Scanner = null;
        internal   XmlBasicTokenInfo   _CurrentToken;
        internal   XmlAttributeTokenInfo _AttributeTextToken;
        internal   XmlNameValueTokenInfo _EndEntityToken;
        internal   bool                 _Eof;
        internal   ReadState            _ReadState;
        internal   XmlSpace             _XmlSpace;
        internal   String               _XmlLang;
        internal   bool                 _IsExternal;
        internal   bool                 _PartialContent;
        internal   Encoding             _Encoding;

        private string                  _url;
        private CompressedStack         _compressedStack;

        private XmlNormalizer               _Normalizer;
        private XmlAttributeCDataNormalizer _CDataNormalizer;
        private XmlNonNormalizer            _NonNormalizer;

        internal sealed class ElementInfo {
            internal String _NameWPrefix;      // name of element.
            internal String _LocalName;      // name of element.
            internal String _Prefix;
            internal String _NS;
            internal int _NameColonPos; // colon position
            internal int _LineNumber;   // line number for element
            internal XmlSpace _XmlSpace;
            internal String _XmlLang;
            internal XmlScanner _Scanner;
        };

        internal sealed class ScannerInfo {
            internal XmlScanner _Scanner; // name of element.
            internal object _Entity;
            internal String _BaseURI;
            internal int _LastToken;
            internal bool _DepthIncrement;
            internal int _NextFunction;
            internal XmlAttributeTokenInfo[] _Fields;
            internal int _ReadCount;
            internal int _Used;
            internal String _EntityName;
            internal int _EntityDepth;
            internal Encoding _Encoding;
            internal bool _StandAlone;
            internal bool _IsExternal;
        };

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlTextReader"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected XmlTextReader() {
        }


        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlTextReader1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Initializes a new instance of the XmlTextReader class with the specified XmlNameTable.</para>
        /// </devdoc>
        protected XmlTextReader( XmlNameTable nt ) {
            //
            // internal variables
            //
            _ElementDepth = -1;
            _EntityDepthOffset = 0;
            _ReadCount = -1;

            //
            // variables for properties
            //
            _ReadState = ReadState.Initial;
            _NextState = 1;

            //
            // create interal components
            //
            _NameTable = nt;
            _ElementStack = new HWStack(STACK_INCREMENT);
            _ScannerStack = new HWStack(STACK_INCREMENT);

            //
            //create atom
            //
            _StringName                 = _NameTable.Add("String");
            _MicrosoftSystemNamespace   = _NameTable.Add("System");
            _Decimal                    = _NameTable.Add("#decimal");
            _Hex                        = _NameTable.Add("#hexidecimal");
            _Amp                        = _NameTable.Add("amp");
            _Lt                         = _NameTable.Add("lt");
            _Gt                         = _NameTable.Add("gt");
            _Quot                       = _NameTable.Add("quot");
            _Apos                       = _NameTable.Add("apos");
            _XmlNs                      = _NameTable.Add("xmlns");
            _XmlSpaceAtom               = _NameTable.Add("xml:space");
            _XmlLangAtom                = _NameTable.Add("xml:lang");

            //
            //fields collection
            //
            _Used = -1;
            _MarkScannerCount = 10000;

            //
            _XmlSpace = XmlSpace.None;
            _XmlLang = String.Empty;
            _WhitespaceHandling = WhitespaceHandling.All;

            _XmlResolver = new XmlUrlResolver();
            _CheckNamespaces = true;

            _TmpToken  = new XmlNSElementTokenInfo(_Scanner, _NsMgr, XmlNodeType.None, String.Empty,-1, -1, -1, 0,false);
            _CurrentToken = _TmpToken;

            // PERF: these node types are not common therefore they
            // will only be constructed when used
            //
            _CommentToken = null;
            _CDATAToken = null;
            _DocTypeToken = null;
            _PIToken = null;
            _EndEntityToken = null;

            _NextFunction = _InitReader;

            _StringBuilder = new StringBuilder(100);
        
            _NonNormalizer = new XmlNonNormalizer( _StringBuilder );
            _Normalizer = _NonNormalizer;
            _CDataNormalizer = null;
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlTextReader2"]/*' />
        /// <devdoc>
        ///    <para>Initializes a new instance of the XmlTextReader class with the specified stream.</para>
        /// </devdoc>
        public XmlTextReader(Stream input) : this(String.Empty, input, new NameTable()) {
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlTextReader3"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlTextReader(String url, Stream input) : this(url, input, new NameTable()) {
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlTextReader4"]/*' />
        /// <devdoc>
        ///    <para>Initializes a new instance of the XmlTextReader class with the specified stream and XmlNameTable.</para>
        /// </devdoc>
        public XmlTextReader(Stream input, XmlNameTable nt) : this(String.Empty, input, nt) {
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlTextReader5"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlTextReader(String url, Stream input, XmlNameTable nt) : this(nt) {
            _NsMgr = new XmlNamespaceManager( _NameTable );
            _Scanner = new XmlScanner(new XmlStreamReader(input), _NameTable);
            _BaseURI = (url==null? String.Empty: url);
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlTextReader6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the XmlTextReader class with the specified TextReader.
        ///    </para>
        /// </devdoc>
        public XmlTextReader(TextReader input): this(String.Empty, input, new NameTable()) {
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlTextReader7"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlTextReader(string url, TextReader input) : this(url, input, new NameTable()) {
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlTextReader8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a
        ///       new instance of the XmlTextReader class with the specified TextReader and XmlNameTable.
        ///    </para>
        /// </devdoc>
        public XmlTextReader(TextReader input, XmlNameTable nt): this(String.Empty, input, nt) {
        }


        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlTextReader9"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlTextReader(string url, TextReader input, XmlNameTable nt) : this(nt) {
            _NsMgr = new XmlNamespaceManager( _NameTable );
            _Scanner = new XmlScanner(input, _NameTable);
            _BaseURI = (url==null? String.Empty: url);
        }
        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlTextReader10"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTextReader(Stream xmlFragment, XmlNodeType fragType, XmlParserContext context)
        : this(null == context || null == context.NameTable ? new NameTable() : context.NameTable ) {
            _Scanner = new XmlScanner(new XmlStreamReader(xmlFragment), _NameTable, (null == context ? null : context.Encoding));
            InitFragmentReader(fragType, context);
        }

        // Following constructor assumes that the fragment node type == XmlDecl
        // We handle this node type separately because there is not real way to determine what the
        // "innerXml" of an XmlDecl is. This internal function is required by DOM. When(if) we handle/allow
        // all nodetypes in InnerXml then we should support them as part of fragment constructor as well.
        // Until then, this internal function will have to do.
        internal XmlTextReader(String xmlFragment, XmlParserContext context)
        : this(null == context || null == context.NameTable ? new NameTable() : context.NameTable ) {

            String  input       = "<?xml " + xmlFragment + "?>";
            _Scanner            = new XmlScanner(input.ToCharArray(), _NameTable);

            InitFragmentReader(XmlNodeType.Document, context);
            _PartialContentNodeType = XmlNodeType.XmlDeclaration;
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlTextReader11"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlTextReader(String xmlFragment, XmlNodeType fragType, XmlParserContext context)
        : this(null == context || null == context.NameTable ? new NameTable() : context.NameTable ) {
            _Scanner = new XmlScanner(xmlFragment.ToCharArray(), _NameTable);
            InitFragmentReader(fragType, context);

        }

        private void InitFragmentReader(XmlNodeType fragType, XmlParserContext context) {

            if (null != context) {
                if (null != context.NamespaceManager) {
                    _NsMgr = context.NamespaceManager;
                }
                else {
                    _NsMgr = new XmlNamespaceManager(_NameTable);
                }
            }
            else {
                _NsMgr = new XmlNamespaceManager(_NameTable);
            }

            _BaseURI                = (null == context ? String.Empty : context.BaseURI);
            _PartialContentNodeType = fragType;

            if (null != context){
                _XmlSpace = context.XmlSpace;
                _XmlLang  = context.XmlLang;
            }

            switch (fragType) {
                case XmlNodeType.Attribute:
                    _RootCount          = 1;
                    _NextState          = 2;
                    break;
                case XmlNodeType.Element:
                {
                    _RootCount          = 1;
                    _NextState          = 2;
                    break;
                }

                case XmlNodeType.Document:
                {
                    _RootCount = 0;
                    break;
                }
                default:
                {
                    throw new XmlException(Res.Xml_PartialContentNodeTypeNotSupported, string.Empty);
                }
            }

        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlTextReader12"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the XmlTextReader class with the specified file.
        ///    </para>
        /// </devdoc>
        public XmlTextReader(String url): this(url, new NameTable()) {
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlTextReader13"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the XmlTextReader class with the specified file and XmlNameTable.
        ///    </para>
        /// </devdoc>
        public XmlTextReader(String url, XmlNameTable nt): this(nt) {
            _NsMgr = new XmlNamespaceManager( _NameTable );

            _compressedStack = CompressedStack.GetCompressedStack();
            _url = url;

            Uri uri = _XmlResolver.ResolveUri(null, url);
            _BaseURI = XmlUrlResolver.UnEscape(uri.ToString());
        }

        private void CreateScanner() {
            Stream stream = null;
            XmlResolver myResolver = (_XmlResolver != null ? _XmlResolver : new XmlUrlResolver());
            Uri uri = myResolver.ResolveUri(null, _url);

            try {
                Debug.Assert(_compressedStack != null);
                
                CompressedStack oldCompressedStack = Thread.CurrentThread.GetCompressedStack();
                if ( oldCompressedStack != null )
                    Thread.CurrentThread.SetCompressedStack(null);

                try {
                    
                    Thread.CurrentThread.SetCompressedStack(_compressedStack);

                    stream = (Stream)myResolver.GetEntity(uri, null,null);
                    _Scanner = new XmlScanner(new XmlStreamReader(stream), _NameTable);
                }
                finally {
                    Thread.CurrentThread.SetCompressedStack(null);
                    if (oldCompressedStack != null)
                        Thread.CurrentThread.SetCompressedStack( oldCompressedStack );
                }
            }
            catch {
                if (stream != null)
                    stream.Close();
                throw;
            }
        }

        private void Init() {
            if (_Scanner == null) {
                CreateScanner();
            }
            _Scanner.Normalization = Normalization;
            _Scanner.NamespaceSupport = _CheckNamespaces;

            if (_Encoding == null) {
                _Encoding = _Scanner.Encoding;
            }

            _TextToken       = new XmlWSTokenInfo(_Scanner, _NsMgr, XmlNodeType.Text, -1, _Normalization);
            _WhitespaceToken = new XmlWSTokenInfo(_Scanner, _NsMgr, XmlNodeType.Whitespace, -1, _Normalization);
            _ERToken         = new XmlNameValueTokenInfo(_Scanner, _NsMgr, XmlNodeType.EntityReference, -1, String.Empty, false);

            if (_CheckNamespaces) {
                _TmpToken           = new XmlNSElementTokenInfo(_Scanner, _NsMgr, XmlNodeType.None, String.Empty,-1, -1, -1, 0,false);
                _ElementToken       = new XmlNSElementTokenInfo(_Scanner, _NsMgr, XmlNodeType.Element, String.Empty,-1, -1, -1, -1,false);
                _EndElementToken    = new XmlNSElementTokenInfo(_Scanner, _NsMgr, XmlNodeType.EndElement, String.Empty,-1, -1, -1, -1,false);
                _AttributeTextToken = new XmlNSAttributeTokenInfo(_Scanner, _NsMgr, XmlNodeType.Text, _Normalization, _XmlNs);
            }
            else {
                _TmpToken           = new XmlElementTokenInfo(_Scanner, _NsMgr, XmlNodeType.None, String.Empty,-1, -1, -1, 0, false);
                _ElementToken       = new XmlElementTokenInfo(_Scanner, _NsMgr, XmlNodeType.Element, String.Empty,-1, -1, -1, -1, false);
                _EndElementToken    = new XmlElementTokenInfo(_Scanner, _NsMgr, XmlNodeType.Element, String.Empty,-1, -1, -1, -1, false);
                _AttributeTextToken = new XmlAttributeTokenInfo(_Scanner, _NsMgr, XmlNodeType.Text, _Normalization);
            }
            _CurrentToken = _TmpToken;
        }

        bool IsAttributeNameDuplicate(String localName, String prefix) {
            int count = _Used+1;
            for (int i = 0; i < count; i++) {
                if ((object)_Fields[i].Name == (Object)localName && (object)_Fields[i].Prefix == (Object)prefix)
                    return true;
            }
            return false;
        }

        // check whether the attribute name is duplicate between the ranges for the array provided.
        bool IsAttributeNameDuplicate(String nameWPrefix, int startPos, int endPos) {
            Debug.Assert(startPos <= endPos && 0 <= startPos && _Used >= endPos);
            for (int i = startPos; i < endPos; i++) {
                if ((object)_Fields[i].NameWPrefix == (Object)nameWPrefix) {
                    return true;
                }
            }
            return false;
        }

        //
        // fields collection
        //
        private void AddAttribute() {
            _Used++;
            if (_Used >= _MaxCount) {
                XmlAttributeTokenInfo[] expandFields=null;
                int oldCount = _MaxCount;
                _MaxCount = (_MaxCount + 10) * 2;
                if (_CheckNamespaces)
                    expandFields = new XmlNSAttributeTokenInfo[_MaxCount];
                else
                    expandFields = new XmlAttributeTokenInfo[_MaxCount];

                if (_Fields != null)
                    Array.Copy(_Fields, 0, expandFields, 0, oldCount);

                if (_CheckNamespaces) {
                    for (int i = oldCount; i < _MaxCount; i++) {
                        expandFields[i] = (XmlAttributeTokenInfo) new XmlNSAttributeTokenInfo(_Scanner, _NsMgr, XmlNodeType.Attribute, _Normalization, _XmlNs);
                    }
                }
                else {
                    for (int i = oldCount; i < _MaxCount; i++) {
                        expandFields[i] = new XmlAttributeTokenInfo(_Scanner, _NsMgr, XmlNodeType.Attribute, _Normalization);
                    }
                }
                _Fields = expandFields;
            }

        }

        private void ResetFieldsCollection() {
            _Used = -1;
            _ReadCount = -1;
        }

        private int GetAttributeCount() {
            switch(this.NodeType)
            {
            case XmlNodeType.Attribute:
            case XmlNodeType.DocumentType:
            case XmlNodeType.Element:
            case XmlNodeType.XmlDeclaration:
                return _Used+1;
            }
            if (_NextFunction == _FinishAttributeIndex)
                return _Used+1;
            return 0;
        }

        private bool GetOrdinal(string localName, string namespaceURI, out int ordinal) {
            int index = 0;

            int count = GetAttributeCount();
            while (index < count) {
                if (_Fields[index].Namespaces == namespaceURI && _Fields[index].Name == localName) {
                    ordinal = index;
                    return true;
                }
                index++;
            }
            ordinal = -1;
            return false;
        }

        private bool GetOrdinal(string name, out int ordinal) {
            int index = 0;

            int count = GetAttributeCount();
            while (index < count) {
                if (_Fields[index].NameWPrefix == name) {
                    ordinal = index;
                    return true;
                }
                index++;
            }
            ordinal = -1;
            return false;
        }

        //
        // functions handle DTDParser, DTD and schema Validation
        //

        private String ParseDtd( XmlScanner scanner ) {
            if (_DtdParser == null)
                _DtdParser = new DtdParser(scanner, (XmlReader)this, this.GetResolver(), _NameTable, _ValidationEventHandler, _CheckNamespaces);
            _DtdParser.Parse();
            return _NameTable.Add(_DtdParser.GetSchemaInfo().DocTypeName.ToString());
        }

        // ISSUE: should be removed
        private void EndEntity(object o) {
            Debug.Assert(o != null, "Should not call EndEntity when SchemaEntity is null");
            ((SchemaEntity)o).IsProcessed = false;
        }

        //
        // populate fields collection and basic error checking
        //
        private void CheckIndexCondition(int i) {
            if (i < 0 || i >= GetAttributeCount()) {
                throw new ArgumentOutOfRangeException("i");
            }
        }

        /*
        * parse tag
        */
        private int ParseTag() {
            int LineNum = _Scanner.LineNum;
            int LinePos = _Scanner.LinePos;

            int token = _Scanner.ScanMarkup();

            switch (token) {
                case XmlToken.TAG:
                    _NextFunction = _ParseElementIndex;
                    _CantHaveXmlDecl = true;
                    _ContinueParsing = true;
                    break;
                case XmlToken.EOF:
                    return XmlToken.EOF;
                case XmlToken.PI:
                    {
                        LinePos += 2; //To Skip markup <?
                        if (_Scanner.IsToken("xml")) {
                            //
                            // if xml is declared, there should not be any token before this
                            // if it is from ResolveEntity(), xml decl is allowed and should
                            // not be returned
                            //
                            if (_CantHaveXmlDecl)
                                throw new XmlException(Res.Xml_XmlDeclNotFirst, LineNum, LinePos);
                            if (_PIToken == null)
                                _PIToken = new XmlNameValueTokenInfo(_Scanner, _NsMgr, XmlNodeType.XmlDeclaration, -1, _Normalization);
                            _PIToken.LineNum = LineNum;
                            _PIToken.LinePos = LinePos;
                            ParseXmlDecl();

                            if (_IsExternal) {
                                _ContinueParsing = true;
                            }
                            else {
                                _PIToken.Name = _NameTable.Add("xml");
                                _PIToken.SetValue(_Normalizer);
                                _PIToken.Depth = _ElementDepth + 1 + _EntityDepthOffset;
                                _CurrentToken = _PIToken;
                            }
                        }
                        else {
                            bool hasBody = _Scanner.ScanPIName();
                            String name = _Scanner.GetTextAtom();
                            if (String.Compare(name, "xml", true, CultureInfo.InvariantCulture) == 0)
                                throw new XmlException(Res.Xml_InvalidPIName, name, LineNum, LinePos);
                            if (_CheckNamespaces && _Scanner.Colon() != -1)
                                throw new XmlException(Res.Xml_InvalidPIName, name, LineNum, LinePos);
                            if (_PIToken == null)
                                _PIToken = new XmlNameValueTokenInfo(_Scanner, _NsMgr, XmlNodeType.ProcessingInstruction,
                                                                        -1, _Normalization);
                            _CantHaveXmlDecl = true;
                            _PIToken.Name = name;
                            _PIToken.NodeType = XmlNodeType.ProcessingInstruction;
                            if (hasBody) {
                                _Scanner.ScanPI();
                                _PIToken.SetValue(_Scanner, null, _Scanner.StartPos, _Scanner.TextLength);
                            }
                            else {
                                _PIToken.Value = String.Empty;
                            }
                            _PIToken.Depth = _ElementDepth + 1 + _EntityDepthOffset;
                            _CurrentToken = _PIToken;
                            _Scanner.Advance(2);
                       }
                    }
                    break;

                case XmlToken.COMMENT:
                    LinePos += 4; //To Skip markup <!--
                    if (_CommentToken == null)
                        _CommentToken = new XmlValueTokenInfo(_Scanner, _NsMgr, XmlNodeType.Comment, -1, _Normalization);
                    _CantHaveXmlDecl = true;
                    _CommentToken.SetValue(_Scanner, null, _Scanner.StartPos, _Scanner.TextLength);
                    _CommentToken.Depth = _ElementDepth + 1 + _EntityDepthOffset;
                    _CurrentToken = _CommentToken;
                    _Scanner.Advance(3);
                    break;

                case XmlToken.CDATA:
                    _CantHaveXmlDecl = true;
                    LinePos += 9; //To skip the Markup <![CDATA[
                    if ((XmlNodeType.Document == _PartialContentNodeType || XmlNodeType.None == _PartialContentNodeType)
                        && (_ElementStack.Length < 1 || _RootCount < 1))
                        throw new XmlException(Res.Xml_InvalidRootData, LineNum, LinePos);
                    if (_CDATAToken == null)
                        _CDATAToken = new XmlValueTokenInfo(_Scanner, _NsMgr, XmlNodeType.CDATA, -1, _Normalization);
                    _CDATAToken.SetValue(_Scanner, null, _Scanner.StartPos, _Scanner.TextLength);
                    _CDATAToken.Depth = _ElementDepth + 1 + _EntityDepthOffset;
                    _CurrentToken = _CDATAToken;
                    _Scanner.Advance(3);
                    break;

                case XmlToken.DECL:
                    {

                        if (_DtdParser != null) {
                            //A document cant have multiple doctyp
                            throw new XmlException(Res.Xml_MultipleDTDsProvided, LineNum, LinePos);
                        }

                        if (_RootCount > 0) {
                            throw new XmlException(Res.Xml_BadDTDLocation, LineNum, LinePos);
                        }

                        int startPos = _Scanner.CurrentPos-2;
                        _Scanner.ReadBufferConsistency = _Scanner.StartPos;

                        if (_DocTypeToken == null)
                            _DocTypeToken = new XmlDtdTokenInfo(_Scanner, _NsMgr, XmlNodeType.DocumentType, -1, _Normalization);
                        _CantHaveXmlDecl = true;
                        _Used = -1;

                        _DocTypeToken.Name = ParseDtd( _Scanner );
                        if (_DtdParser != null) {
                            LinePos = _DtdParser.DTDNameStartPosition;
                            LineNum = _DtdParser.DTDNameStartLine;
                        }
                        if (!_BufferConsistency)
                            _Scanner.ReadBufferConsistency = -1;
                        _DocTypeToken._DtdParser = _DtdParser;
                        _DocTypeToken.Depth = _ElementDepth + 1 + _EntityDepthOffset;
                        _CurrentToken = _DocTypeToken;
                    }
                    break;

                case XmlToken.ENDTAG:
                    {
                        LinePos += 2; //to skip the markup </
                        _Scanner.ScanNameWOCharChecking();
                        if (_LastElementInfo == null) {
                            throw new XmlException(Res.Xml_UnexpectedEndTag, LineNum, LinePos);
                        }

                        int count = _Scanner.TextLength;
                        char[] scannerbuff = _Scanner.InternalBuffer;

                        if(_LastElementInfo._NameWPrefix.Length != count) {
                                // The length of the start tag and end tag should be the same.
                                // If it is not, no need to check char by char.
                                goto errorCase;
                        }
                        int scannerOffset = _Scanner.TextOffset;
                        for (int i = scannerOffset, j = 0; i < (scannerOffset + count)  && j < count; i++, j++) {
                            if (_LastElementInfo._NameWPrefix[j] != scannerbuff[i]) {
                                goto errorCase;

                            }
                        }

                        //
                        // begin and end tag has to come from the same scanner
                        //
                        if (_LastElementInfo._Scanner != _Scanner) {
                            throw new XmlException(Res.Xml_TagNotInTheSameEntity, _LastElementInfo._NameWPrefix, LineNum, LinePos);
                        }

                        _EndElementToken.SetName(_LastElementInfo._NameWPrefix, _LastElementInfo._LocalName, _LastElementInfo._Prefix, _LastElementInfo._NS,
                                              _ElementDepth + _EntityDepthOffset, _Scanner);
                        _CurrentEndElementStart = _Scanner.StartPos-2;
                        ReadEndElementToken();
                        _Scanner.ScanToken(XmlToken.TAGEND); // skip whitespace to the '>'
                        _CurrentEndElementEnd = _Scanner.CurrentPos;
                        _ElementDepth--;
                    }

                    break;

            }

            _CurrentToken.LineNum = LineNum;
            _CurrentToken.LinePos = LinePos;

            return token;
            errorCase:

            String[] args;
            string exceptionCode;
            if (String.Empty != _BaseURI) {
                args = new String[4];
                args[3] = _BaseURI;
                exceptionCode = Res.Xml_TagMismatchFileName;
            }
            else {
                args = new String[3];
                exceptionCode = Res.Xml_TagMismatch;
            }
            args[0] = _LastElementInfo._NameWPrefix;
            args[1] = _LastElementInfo._LineNumber.ToString();
            args[2] = _Scanner.GetText();
            throw new XmlException(exceptionCode, args, LineNum, LinePos);
        }

        //
        // parse element
        //
        private void SetElementValues() {

            _Scanner.ScanToken(XmlToken.NAME);

            int offset = _Scanner.StartPos;
            if (_Scanner.GetChar(offset -1) != '<')
                throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.NAME), _Scanner.LineNum, _Scanner.LinePos - 1);
            //
            // increment the element depth
            //
            _ElementDepth++;
            //
            // setup Record value
            //
            _ElementToken.SetName(_Scanner, offset, _Scanner.TextLength, _Scanner.Colon(), _ElementDepth + _EntityDepthOffset);
            //
            // the rest of the dynamic values
            //
            _CurrentToken = _ElementToken;
            _CurrentElementStart = _Scanner.StartPos-1;
        }

        // parse element
        //
        private void ParseElement() {
            int pos = -1;

            _Scanner.ReadBufferConsistency = _Scanner.StartPos;
            _ElementToken.LineNum = _Scanner.LineNum;
            _ElementToken.LinePos = _Scanner.LinePos;

            //
            // setup element value
            //
            _NsMgr.PushScope();
            SetElementValues();

            while ((_LastToken = _Scanner.ScanMarkup()) != XmlToken.TAGEND
                   && _LastToken != XmlToken.EMPTYTAGEND) {
                //
                // #49290: check whether there is anything between literal value and attribute value
                //
                if (pos == _Scanner.StartPos)
                    throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.NAME), _Scanner.LineNum, _Scanner.LinePos);

                SetAttributeValues();

                _Scanner.Advance();
                pos = _Scanner.CurrentPos;
            }

            // generate element token name, prefix and ns
            _ElementToken.FixNames();

            // PERF PERF: to access the namespace value
            if (_CheckNamespaces) {
                int count = _Used+1;
                for (int i = 0; i < count; i++) {
                    XmlAttributeTokenInfo fld1 = _Fields[i];
                    if (!fld1.NsAttribute)
                        fld1.FixNames();

                    // Check for Name and Namespace value if the _CheckNamespaces is set
                    for (int j = 0; j < i; j++) {
                        XmlAttributeTokenInfo fld2 = _Fields[j];
                        // Bug# 51581
                        // According to the namespace spec http://www.w3.org/TR/REC-xml-namespaces section 5.3
                        // No two attributes may have either identical names or have qualified names with the
                        // same local-part with prefixes which have been bound to namespace names that are identical.
                        if (Ref.Equal(fld1.Name, fld2.Name) && Ref.Equal(fld1.Namespaces, fld2.Namespaces)) {
                            throw new XmlException(Res.Xml_DupAttributeName, fld1.NameWPrefix, fld1.LineNum, fld1.LinePos);
                        }
                    }
                }
            }
            else {
                // check for attributes with duplicate names.
                for (int i = _Used; i > 0 ; i--) {
                    XmlAttributeTokenInfo fld1 = _Fields[i];
                    if (IsAttributeNameDuplicate(fld1.NameWPrefix, 0, i)) {
                        throw new XmlException(Res.Xml_DupAttributeName, _Fields[i].NameWPrefix, _Fields[i].LineNum, _Fields[i].LinePos );
                    }
                }
            }

            if (!_BufferConsistency)
                _Scanner.ReadBufferConsistency = -1;

            if (_LastToken == XmlToken.EMPTYTAGEND) {
                _ElementDepth--;
                _ElementToken.IsEmpty = true;
                _NextFunction = _PopEndElementIndex;
               _CurrentEndElementEnd = _Scanner.CurrentPos;
            }
            else {
                _NextFunction = _ParseBeginTagIndex;
                _ElementToken.IsEmpty = false;
            }

            Push(_ElementToken.NameWPrefix, _ElementToken.Name, _ElementToken.Prefix,
                 _ElementToken.Namespaces, _ElementToken.NameColonPos);
        }

        private XmlSpace ConvertXmlSpace(String space, int LineNum, int LinePos) {
            if (space == "default")
                return XmlSpace.Default;
            else if (space == "preserve")
                return XmlSpace.Preserve;
            else
                throw new XmlException(Res.Xml_InvalidXmlSpace, space, LineNum, LinePos);
        }

        private void SetLiteralValues(XmlAttributeTokenInfo fld) {
            //
            // get the literal token
            //
            _Scanner.ScanToken(XmlToken.EQUALS);
            _Scanner.ScanToken(XmlToken.QUOTE);

            String nameWPrefix = fld.NameWPrefix;
            int nameLength = nameWPrefix.Length;

            fld.QuoteChar = _Scanner.QuoteChar();
            fld.NsAttribute = false;

           //
           // always expand literals and we also need to remember the value offsets
           //
           int pos = _Scanner.CurrentPos;
           int lineNum = _Scanner.LineNum;
           int linePos = _Scanner.AbsoluteLinePos;

           if (_Scanner.ScanLiteral()) {
                _Scanner.CurrentPos = pos;
                _Scanner.AbsoluteLinePos = linePos;
                _Scanner.LineNum = lineNum;
                fld.ValueContainEntity = ValueContainEntity.None;
                ExpandLiteral(fld);
            }
            else {
                fld.ValueContainEntity = ValueContainEntity.None;
                fld.SetValue(_Scanner, null, _Scanner.StartPos, _Scanner.TextLength, false);
            }
            // check xmlns, xml:space, xml:lang
            //
            if (nameWPrefix[0] != 'x' || nameLength < 5) {
                goto cleanup;
            }

            if (nameWPrefix[1] == 'm' && nameWPrefix[2] == 'l') {
                if (nameWPrefix[3] == 'n' && nameWPrefix[4] == 's') {
                    fld.NsAttribute = true;
                    fld.FixNSNames();
                }
                else if ((Object)nameWPrefix == (Object)_XmlSpaceAtom) {
                    //
                    // xml:space
                    //
                    String val = fld.GetValue();
                    _XmlSpace = ConvertXmlSpace(val, fld.LineNum, fld.LinePos );

                    goto cleanup;
                }
                else if ((Object)nameWPrefix == (Object)_XmlLangAtom) {
                    //
                    // xml:lang
                    //
                    _XmlLang = fld.GetValue();
                    goto cleanup;
                }
            }
            cleanup:
            return;
        }

        /*
         * set attribute values
         */
        private void SetAttributeValues() {


            //Do duplicate attribute name checking after collecting all the attribute

            //
            // Add new field
            //
            AddAttribute();
            //
            //
            XmlAttributeTokenInfo fld = _Fields[_Used];

            fld.LineNum = _Scanner.LineNum;
            fld.LinePos = _Scanner.LinePos - _Scanner.TextLength;
            if (_LastToken != XmlToken.NAME)
                throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.NAME), fld.LineNum, fld.LinePos);

            fld.SetName(_Scanner,
                _Scanner.GetTextAtom(),
                _Scanner.Colon(),               // name colon
                _ElementDepth+1 + _EntityDepthOffset,
                false                          // isDefault
                );

            fld.ValueLineNum = _Scanner.LineNum;
            fld.ValueLinePos = _Scanner.LinePos + 1;
            SetLiteralValues(fld);
        }
        /*
        * set attribute values
        */
        internal void SetAttributeValues(string name, string value, int lineNum, int linePos, int valueLineNum, int valueLinePos) {

            AddAttribute();
            //
            //
            XmlAttributeTokenInfo fld = _Fields[_Used];

            fld.SetName(_Scanner,
                name,
                0,               // name colon
                _ElementDepth+1 + _EntityDepthOffset,
                false                          // isDefault
                );
            fld.FixNames();
            fld.Value = value;

            fld.LineNum = lineNum;
            fld.LinePos = linePos;
            fld.ValueLineNum = valueLineNum;
            fld.ValueLinePos = valueLinePos;

        }

        // This method parses the entire attribute value expanding all the entities
        // it finds into an internal buffer.
        private void ExpandLiteral(XmlAttributeTokenInfo currToken) {
            // use our little buffer to build up the expanded attribute value.
            int start = _Scanner.CurrentPos;
            int token = _Scanner.ScanLiteral(true, false, true, false);
            char ch;
            int depth = 0;

            XmlNormalizer normalizer;
            if ( _Normalization ) {
                Debug.Assert( _CDataNormalizer != null );
                normalizer = _CDataNormalizer;
            }
            else
                normalizer = _NonNormalizer;
            normalizer.Reset();
            
            while (token != XmlToken.ENDQUOTE) {
                switch (token) {
                    case XmlToken.TEXT:
                        normalizer.AppendTextWithEolNormalization(_Scanner.InternalBuffer, _Scanner.TextOffset, _Scanner.TextLength);
                        break;
                    case XmlToken.ENTITYREF:
                        ch = _Scanner.ScanNamedEntity();
                        //
                        //  ch == 0 if general entity
                        //  ch != 0 if build in entity, for example: &lt
                        //
                        if (ch == 0) {
                            normalizer.AppendTextWithEolNormalization(_Scanner.InternalBuffer, _Scanner.TextOffset-1, _Scanner.TextLength+1);
                            currToken.ValueContainEntity = ValueContainEntity.NotResolved;
                            break;
                        }
                        else {
                            normalizer.AppendCharEntity( ch );
                            _Scanner.Advance(); // consume the ';'
                        }
                        break;
                    case XmlToken.HEXENTREF:
                        normalizer.AppendCharEntity(_Scanner.ScanHexEntity());
                        break;
                    case XmlToken.NUMENTREF:
                        normalizer.AppendCharEntity( _Scanner.ScanDecEntity() );
                        break;
                    case XmlToken.EOF:
                        depth--;
                        break;
                }
                token = _Scanner.ScanLiteral(true, false, depth==0, false);
            }

            string str = normalizer.ToString();
            currToken.SetValue(_Scanner, str, start, _Scanner.CurrentPos - start, _Normalization);
        }

        // This method is used in token view when ExpandEntities is false and
        // IgnoreEntities is false to return each text and entity reference as an
        // individual record.
        private bool ParseLiteralTokens(XmlScanner scanner, XmlAttributeTokenInfo currToken, int newDepth,
                                        EntityHandling ehMode, bool bNonCDataNormalization, ref int lastToken) {
            //String rawValue = String.Empty;
            String name = String.Empty, dataType = _StringName;
            XmlNodeType nodeType = XmlNodeType.Text;
            int startPos = -1, erPos = -1;
            int LineNum = _Scanner.LineNum;
            int LinePos = _Scanner.LinePos;

            bool hasToken = false/*, hasER = false*/, retValue = false;
            char ch='\0';

            int state = 2;

            XmlNormalizer normalizer;
            if ( _Normalization )
                normalizer = _CDataNormalizer;
            else
                normalizer = _NonNormalizer;
            normalizer.Reset();
            
            do {
                switch (state) {
                    case 2:
                        erPos = scanner.CurrentPos;
                        lastToken = scanner.ScanLiteral(true, false, false, false);
                        switch (lastToken) {
                            case XmlToken.EOF: // reached the end of the literal.
                                state = -1;
                                if (!hasToken) {
                                    retValue = true;
                                    goto cleanup;
                                }
                                goto seeToken;
                            case XmlToken.TEXT:
                                startPos = (hasToken == true) ? startPos : scanner.StartPos;
                                normalizer.AppendTextWithEolNormalization(scanner.InternalBuffer, scanner.TextOffset, scanner.TextLength);
                                hasToken = true;
                                nodeType = XmlNodeType.Text;
                                state = 2;
                                break;
                            case XmlToken.ENTITYREF:
                                startPos = (hasToken == true) ? startPos : scanner.StartPos - 1;
                                ch = scanner.ScanNamedEntity();
                                name = scanner.GetTextAtom();
                                //
                                //  ch == 0 if general entity
                                //  ch != 0 if build in entity, for example: &lt
                                //

                                // #50921
                                if (ch == 0 && _CheckNamespaces && _Scanner.Colon() != -1)
                                    throw new XmlException(Res.Xml_BadNameChar, XmlException.BuildCharExceptionStr(':'), _Scanner.LineNum, _Scanner.LinePos);

                                if (ch != 0) {
                                    normalizer.AppendCharEntity(ch);

                                    dataType = "Char";
                                    scanner.Advance();
                                    hasToken = true;
                                    //hasER = true;
                                    _NextState = 2;
                                    name = String.Empty;
                                    nodeType = XmlNodeType.Text;
                                }
                                else if (hasToken) {
                                    // First return the text we have up to this point.
                                    state = 11;
                                }
                                else {
                                    // Return the entity reference as a node.
                                    state = 10;
                                    nodeType = XmlNodeType.EntityReference;
                                }
                                break;
                            case XmlToken.NUMENTREF:
                                startPos = (hasToken == true) ? startPos : scanner.StartPos - 1;
                                hasToken = true;
                                //hasER = true;
                                normalizer.AppendCharEntity(scanner.ScanDecEntity());
                                state = 2;
                                break;
                            case XmlToken.HEXENTREF:
                                startPos = (hasToken == true) ? startPos : scanner.StartPos - 1;
                                hasToken = true;
                                //hasER = true;
                                normalizer.AppendCharEntity(scanner.ScanHexEntity());
                                state = 2;
                                break;
                            default:
                                throw new XmlException(Res.Xml_InternalError, string.Empty);
                        }
                        break;
                    case 9:
                        scanner.Advance();
                        hasToken = true;
                        //hasER = true;
                        state = 2;
                        goto seeToken;
                    case 10:
                        scanner.Advance();
                        hasToken = true;
                        //hasER = true;
                        state = 2;
                        // general entity special case
                        currToken.Value = String.Empty;
                        LinePos += 1;
                        goto otherToken;
                    case 11:
                        scanner.CurrentPos = erPos;
                        state = 2;
                        name = String.Empty;
                        goto seeToken;
                    case 12:
                        state = 2;
                        ParseTag();
                        goto cleanup;
                    default:
                        Debug.Assert(false, "unknown state within ParseBeginTag()");
                        break;
                }
            } while (true);
            seeToken:
            string val = normalizer.ToString();
            if ( bNonCDataNormalization )
                val = XmlAttributeTokenInfo.NormalizeNonCDataValue( val );
            currToken.SetValue(null, val, 0, 0, true);
            dataType = _StringName;

            //
            // there is no rawValue
            // if (hasER)
            //  rawValue = scanner.GetText(startPos, scanner.CurrentPos - startPos);
            //currToken.RawValue = rawValue;

            otherToken:
            currToken.Name = name;
            currToken.LineNum = LineNum;
            currToken.LinePos = LinePos;
            currToken.NodeType = nodeType;
            currToken.Depth = newDepth;
            cleanup:
            return retValue;
        }
        
        private    void ParseXmlDecl() {
            // In this case we parse the version, encoding and standalone attributes
            // and keep them to ourselves - we don't want to push them out to the handler
            // because they are not really part of the XML tree - they are processing
            int token;
            bool versionSet = false;
            String encodingName = String.Empty;
            int LineNum, LinePos;
            int pos = -1;
            _StringBuilder.Length = 0;

            int i = 0;
            while ((token = _Scanner.ScanMarkup()) != XmlToken.ENDPI) {
                if (token != XmlToken.NAME)
                    throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.NAME), _Scanner.LineNum, _Scanner.LinePos - 1);

                if (_Scanner.StartPos == pos) {
                    throw new XmlException(Res.Xml_InvalidXmlDecl, _PIToken.LineNum, _PIToken.LinePos );
                }

                LineNum = _Scanner.LineNum;
                LinePos = _Scanner.LinePos - _Scanner.TextLength;
                if (_Scanner.IsToken(s_Version)) {
                    if ( pos != -1 )
                        _StringBuilder.Append(_Scanner.InternalBuffer, pos - _Scanner.AbsoluteOffset, _Scanner.CurrentPos - pos);
                    else 
                        _StringBuilder.Append(_Scanner.InternalBuffer, _Scanner.TextOffset, _Scanner.TextLength );
                    pos = _Scanner.CurrentPos;
                    if (0 != i) {
                        throw new XmlException(Res.Xml_InvalidXmlDecl, _PIToken.LineNum, _PIToken.LinePos);
                    }
                    i = 1;

                }
                else if (_Scanner.IsToken(s_Encoding)) {
                    if ( pos != -1 )
                        _StringBuilder.Append(_Scanner.InternalBuffer, pos - _Scanner.AbsoluteOffset, _Scanner.CurrentPos - pos);
                    else 
                        _StringBuilder.Append(_Scanner.InternalBuffer, _Scanner.TextOffset, _Scanner.TextLength );
                    pos = _Scanner.CurrentPos;
                    if (!_IsExternal && 1 != i) {
                        throw new XmlException(Res.Xml_InvalidXmlDecl, _PIToken.LineNum, _PIToken.LinePos);
                    }
                    i = 2;
                }
                else if (_Scanner.IsToken(s_Standalone)) {
                    if ( pos != -1 )
                        _StringBuilder.Append(_Scanner.InternalBuffer, pos - _Scanner.AbsoluteOffset, _Scanner.CurrentPos - pos);
                    else 
                        _StringBuilder.Append(_Scanner.InternalBuffer, _Scanner.TextOffset, _Scanner.TextLength );
                    pos = _Scanner.CurrentPos;
                    //
                    // can't have standalone in external entity [77]
                    //
                    if (_IsExternal) {
                        throw new XmlException(Res.Xml_InvalidXmlDecl, _PIToken.LineNum, _PIToken.LinePos);
                    }
                    if (1 != i && 2 != i) {
                        throw new XmlException(Res.Xml_InvalidXmlDecl, _PIToken.LineNum, _PIToken.LinePos);
                    }
                    i = 3;
                }
                else {
                    throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.NAME), LineNum, LinePos);
                }

                _Scanner.ScanToken(XmlToken.EQUALS);
                _StringBuilder.Append( _Scanner.InternalBuffer, pos - _Scanner.AbsoluteOffset, _Scanner.CurrentPos - pos);
                pos = _Scanner.CurrentPos;

                _Scanner.ScanToken(XmlToken.QUOTE);
                _StringBuilder.Append( _Scanner.InternalBuffer, pos - _Scanner.AbsoluteOffset, _Scanner.CurrentPos - pos);
                pos = _Scanner.CurrentPos;

                token = _Scanner.ScanLiteral(false, false, true, false);
                if (token == XmlToken.TEXT) {
                    String text = _Scanner.GetText();

                    _StringBuilder.Append( _Scanner.InternalBuffer, pos - _Scanner.AbsoluteOffset, _Scanner.CurrentPos - pos);
                    pos = _Scanner.CurrentPos;

                    switch (i) {
                        case 1:
                            //
                            // check version number
                            //
                            if (text != s_VersionNo)
                                throw new XmlException(Res.Xml_InvalidVersionNumber, text, LineNum, LinePos + s_Version.Length + 2);
                            versionSet = true;
                            SetAttributeValues(s_Version,text, LineNum, LinePos, LineNum, LinePos + 8 ); //add the lenght of version=
                            break;
                        case 2:
                            encodingName = text;
                            SetAttributeValues(s_Encoding,text, LineNum, LinePos, LineNum, LinePos + 9 ); //add the lenght of encoding=
                            break;
                        case 3:
                            //
                            // check standalone
                            //
                            if (text == s_Yes)
                                _StandAlone = true;
                            else if (text == s_No)
                                _StandAlone = false;
                            else
                                throw new XmlException(Res.Xml_InvalidXmlDecl, LineNum, LinePos + 11 );
                            SetAttributeValues(s_Standalone,text, LineNum, LinePos, LineNum, LinePos + 11 ); //add the lenght of standalone=
                            break;
                    }
                }
                else {
                    throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.NAME), LineNum, LinePos);
                }
                if (_Scanner.ScanLiteral(false, false, true, false) != XmlToken.ENDQUOTE) {
                    throw new XmlException(Res.Xml_UnexpectedToken, XmlToken.ToString(XmlToken.NAME), _Scanner.LineNum, _Scanner.LinePos);
                }

                _StringBuilder.Append(_Scanner.QuoteChar());

                _Scanner.Advance();
                pos = _Scanner.CurrentPos;
                LineNum = _Scanner.LineNum;
                LinePos = _Scanner.LinePos;
            }

            if (!_IsExternal && !versionSet) {
                throw new XmlException(Res.Xml_InvalidXmlDecl, _PIToken.LineNum, _PIToken.LinePos );
            }
            if (encodingName != String.Empty) {
                _Scanner.SwitchEncoding(encodingName);
                _Encoding = _Scanner.Encoding;
            }
            else {
                if (_IsExternal) {
                    throw new XmlException(Res.Xml_MissingEncodingDecl, _Scanner.LineNum, _Scanner.LinePos);
            }
                _Scanner.VerifyEncoding();
            }
            _CantHaveXmlDecl = true;
        }

        /*
        * parse from root
        */
        private void ParseRoot() {

            int LineNum = _Scanner.LineNum;
            int LinePos = _Scanner.LinePos;

            _LastToken = _Scanner.ScanContent();

            switch (_LastToken) {
                case XmlToken.EOF:
                    _ScannerEof = true;
                    goto cleanup;
                case XmlToken.WHITESPACE:
                    //
                    // no matter what kind of whitespace, don't return any token
                    //
                    _CantHaveXmlDecl = true;
                    if (!ReturnWhitespaceToken(_Scanner)) {
                        _ContinueParsing = true;
                        _CurrentToken = _WhitespaceToken;
                        goto cleanup;
                    }
                    _WhitespaceToken.Depth = _ElementDepth+1 + _EntityDepthOffset;
                    _CurrentToken = _WhitespaceToken;
                    _CurrentToken.LineNum = LineNum;
                    _CurrentToken.LinePos = LinePos;

                    break;
                case XmlToken.NONE:
                    // ok now we've reached the beginning of a tag
                    int token = ParseTag();
                    switch (token) {
                        case XmlToken.TAG:
                            {
                                _CantHaveXmlDecl = true;
                                _RootCount++;
                            }
                break;
                    }
                    break;
                default:
                    throw new XmlException(Res.Xml_InvalidRootData, LineNum, LinePos);
            }
            cleanup:
            if (_RootCount > 1) {
                throw new XmlException(Res.Xml_MultipleRoots, LineNum, LinePos + 1);
            }
        }

        //
        // only come here when EntityHandling.ExpandCharEntities
        //
        private    void ParseBeginTagExpandCharEntities() {
            XmlNodeType nodeType = XmlNodeType.Text;
            String name = String.Empty, dataType = String.Empty;
            // 1: text token, 2: whitespace token
            int hasToken = 0;
            int erPos = -1;
            int oldElementDepth = _ElementDepth;
            char ch='\0';
            bool originalCantHaveXmlDecl = _CantHaveXmlDecl;
            _CantHaveXmlDecl = true;

            _Normalizer.Reset();

            int LineNum = _Scanner.LineNum;
            int LinePos = _Scanner.LinePos;
            do {
                switch (_NextState) {
                    case 1:
                        if (_ElementStack.Length < 1
                            && (XmlNodeType.Document == _PartialContentNodeType || XmlNodeType.None == _PartialContentNodeType )) {
                            _NextFunction = _ParseRootIndex;
                            _ContinueParsing = true;
                            _NextState = 1;
                            goto cleanup;
                        }
                        _NextState = 2;

                        if (!_BufferConsistency)
                            _Scanner.ReadBufferConsistency = -1;
                        goto case 2;
                    case 2:
                        erPos = _Scanner.CurrentPos;
                        _LastToken = _Scanner.ScanContent();
                        _Scanner.ReadBufferConsistency = _Scanner.StartPos;
                        switch (_LastToken) {
                            case XmlToken.NONE:
                                if (XmlNodeType.Attribute == _PartialContentNodeType) {
                                    //there shouldnt be any '<' char while processing attribute value
                                    throw new XmlException(Res.Xml_InvalidCharacter, XmlException.BuildCharExceptionStr('<'), _Scanner.LineNum, _Scanner.LinePos);
                                }
                                _NextState = 12;
                                switch (hasToken) {
                                case 1: goto seeToken;
                                case 2:
                                     _NextState =11;
                                     break;
                                }
                                break;
                            case XmlToken.EOF:
                                _NextState = 1;
                                _ScannerEof = true;
                                switch(hasToken) {
                                   case 0 :
                                        _NextState = 1;
                                        goto cleanup;
                                   case 1 :
                                        if (XmlNodeType.Attribute == _PartialContentNodeType
                                            || XmlNodeType.Element == _PartialContentNodeType) {
                                            // The only way we could have gotten to this point is if someone wanted to parse the
                                            // following valid Mixed Element content "<foo>bar</foo>some more text"
                                            // If we don't do this, we will eat up the last token
                                            _ScannerEof = false;
                                            _NextFunction = _FragmentTrailingTextNode;
                                        }
                                        goto seeToken;
                                   case 2:
                                        if (XmlNodeType.Attribute == _PartialContentNodeType
                                            || XmlNodeType.Element == _PartialContentNodeType) {
                                             // The only way we could have gotten to this point is if someone wanted to parse the
                                            // following valid Mixed Element content "<foo>bar</foo>some more text"
                                            // If we don't do this, we will eat up the last token
                                            _ScannerEof = false;
                                            _NextFunction = _FragmentTrailingTextNode;
                                        }
                                        _NextState = 11;
                                        break;
                               }
                               oldElementDepth = _ElementDepth;
                               break;
                            case XmlToken.ENDQUOTE:
                                _NextState = 1;
                                goto cleanup;
                            case XmlToken.WHITESPACE:
                                if (hasToken == 0) hasToken = 2;
                                _Normalizer.AppendTextWithEolNormalization(_Scanner.InternalBuffer, _Scanner.TextOffset, _Scanner.TextLength);
                                break;
                            case XmlToken.TEXT:
                                hasToken = 1;
                                _Normalizer.AppendTextWithEolNormalization(_Scanner.InternalBuffer, _Scanner.TextOffset, _Scanner.TextLength);
                                nodeType = XmlNodeType.Text;
                                _NextState = 2;
                                break;

                            case XmlToken.ENTITYREF:
                                ch = _Scanner.ScanNamedEntity();
                                //
                                //  ch == 0 if general entity
                                //  ch != 0 if build in entity, for example: &lt
                                //
                                // #50921
                                if (ch == 0 && _CheckNamespaces && _Scanner.Colon() != -1)
                                    throw new XmlException(Res.Xml_BadNameChar, XmlException.BuildCharExceptionStr(':'), _Scanner.LineNum, LinePos + 1);

                                if (ch != 0) {
                                    hasToken = 1;
                                    _Normalizer.AppendCharEntity(ch);
                                    dataType = "Char";
                                    _Scanner.Advance();
                                    _NextState = 2;
                                    //
                                    // only if build in entity needs to be return as its own
                                    //
                                    nodeType = XmlNodeType.Text;
                                    name = String.Empty;
                                    break;
                                }

                                switch (hasToken) {
                                    case 1:
                                        // First return the text we have up to this point.
                                        _Scanner.CurrentPos = erPos;
                                        _NextState = 2;
                                        name = String.Empty;
                                        goto seeToken;
                                    case 2: // already an whitespace token
                                        _Scanner.CurrentPos = erPos;
                                        _NextState = 9;
                                        name = String.Empty;
                                        break;
                                    default:
                                        // Return the entity reference as a node.
                                        name = _Scanner.GetTextAtom();
                                        nodeType = XmlNodeType.EntityReference;
                                        LinePos = _Scanner.LinePos - name.Length;
                                        _NextState = 10;
                                        break;
                                }
                                break;
                            case XmlToken.NUMENTREF:
                                hasToken = 1;
                                _Normalizer.AppendCharEntity(_Scanner.ScanDecEntity());
                                nodeType = XmlNodeType.Text;
                                _NextState = 2;
                                break;
                            case XmlToken.HEXENTREF:
                                char[] chArray = _Scanner.ScanHexEntity();
                                if (1 == chArray.Length && (chArray[0] == 0x0020 || chArray[0] == 0xD || chArray[0] == 0xA || chArray[0] == (char)0x9)) {
                                    // we might have already seen a text node before this and should not chang the node type here if that is true
                                    if (hasToken == 0) {
                                        // We have a whitespace node. This should be reported as such.
                                        nodeType = XmlNodeType.Whitespace;
                                        hasToken = 2;
                                    }
                                }
                                else {
                                    nodeType = XmlNodeType.Text;
                                    hasToken = 1;
                                }
                                _Normalizer.AppendCharEntity(chArray);
                                _NextState = 2;
                                break;
                            default:
                                throw new XmlException(Res.Xml_InternalError, string.Empty);
                        }
                        break;
                    case 9: // whitespace token handling
                        _NextState = 2;
                        hasToken =0;
                        if (!ReturnWhitespaceToken(_Normalizer)) { //this is the string builder wrapped by normalizer
                            _CurrentToken = _WhitespaceToken;
                            _NextState = 2;
                            break;
                        }
                        _WhitespaceToken.Depth = oldElementDepth + 1 + _EntityDepthOffset;
                        _CurrentToken = _WhitespaceToken;
                        goto otherToken;
                    case 10:
                        _Scanner.Advance();
                        hasToken = 1;
                        _NextState = 2;
                        // general entity special case
                        _ERToken.NodeType = nodeType;
                        _ERToken.Name = name;
                        _ERToken.Depth = oldElementDepth +1 + _EntityDepthOffset;
                        _CurrentToken = _ERToken;
                        goto otherToken;
                    case 11: // whitespace token handling, there is no more
                        _NextState = 2;
                        hasToken =0;
                        if (!ReturnWhitespaceToken(_Normalizer)) { //this is the string builder wrapped by normalizer
                            _CurrentToken = _WhitespaceToken;
                            _ContinueParsing = true;
                            goto cleanup;
                        }
                        _WhitespaceToken.Depth = oldElementDepth + 1 + _EntityDepthOffset;
                        _CurrentToken = _WhitespaceToken;
                        goto otherToken;
                    case 12:
                        _NextState = 1;
                        _CantHaveXmlDecl = originalCantHaveXmlDecl;
                        ParseTag();
                        goto cleanup;
                    default:
                        Debug.Assert(false, "unknown state within ParseBeginTag()");
                        break;
                }
            } while (true);

            seeToken:
            _TextToken.SetValue( _Normalizer );
            _TextToken.SetTokenInfo(nodeType, name, oldElementDepth +1 + _EntityDepthOffset);
            _CurrentToken = _TextToken;
            otherToken:
            _CurrentToken.LineNum = LineNum;
            _CurrentToken.LinePos = LinePos;

            cleanup:
            if (!_BufferConsistency)
                _Scanner.ReadBufferConsistency = -1;
            return;
        }

        internal void Push(String nameWPrefix, String localName, String prefix,
                            String ns, int nameColonPos) {
            ElementInfo ei = (ElementInfo)_ElementStack.Push();
            if (ei == null) {
                ei = new ElementInfo();
                _ElementStack[_ElementStack.Length-1] = ei;
            }
            ei._NameWPrefix = nameWPrefix;
            ei._LocalName = localName;
            ei._Prefix = prefix;
            ei._NS = ns;
            ei._NameColonPos = nameColonPos;
            ei._LineNumber = _Scanner.LineNum;
            ei._XmlSpace = _XmlSpace;
            ei._XmlLang = _XmlLang;
            ei._Scanner = _Scanner;

            _LastElementInfo = ei;
        }

        internal ElementInfo Pop() {
            ElementInfo ei = (ElementInfo)_ElementStack.Pop();
            if (ei == null) {
                goto cleanup;
            }
            _NsMgr.PopScope();

            _LastElementInfo = (ElementInfo) _ElementStack.Peek();
            if (_LastElementInfo != null) {
                _XmlLang = _LastElementInfo._XmlLang;
                _XmlSpace = _LastElementInfo._XmlSpace;
            }
            else
            {
                _XmlSpace = XmlSpace.None;
                _XmlLang = String.Empty;
            }

            cleanup:
            return ei;
        }

        private void PushScanner(XmlScanner newScanner, object entity, String baseURI, XmlAttributeTokenInfo[] fields,
                                 int readCount, int usedCount, int lastToken, int nextFunction, bool depthIncrement,
                                 String entityName, int depth, Encoding encoding, bool standalone, bool oldExternal,
                                 bool newExternal) {
            ScannerInfo ei = (ScannerInfo)_ScannerStack.Push();
            if (ei == null) {
                ei = new ScannerInfo();
                _ScannerStack[_ScannerStack.Length-1] = ei;
            }
            ei._Scanner = _Scanner;
            ei._Entity = entity;
            ei._BaseURI = baseURI;
            ei._LastToken = lastToken;
            ei._NextFunction = nextFunction;
            ei._DepthIncrement = depthIncrement;
            ei._Fields = fields;
            ei._ReadCount = readCount;
            ei._Used = usedCount;
            ei._EntityName = entityName;
            ei._EntityDepth = depth;
            ei._Encoding = encoding;
            ei._StandAlone = standalone;
            ei._IsExternal = oldExternal;
            _MaxCount = 0;

            //
            // reset xmldecl flag
            //
            _CantHaveXmlDecl = false;

            if (depthIncrement) {
                if (readCount != -1 && fields != null && fields[readCount] != null)
                    fields[readCount].Depth++;
                else
                    _ElementDepth++;
            }
            _Scanner = newScanner;
            if (newExternal)
                _Encoding = _Scanner.Encoding;
        }

        //
        // this function will keep poping scanner until find one that is not EOF
        // if all the scanner is EOF, it will keep the last one and return EOF token
        //
        private int PopScanner() {
            ScannerInfo ei = (ScannerInfo)_ScannerStack.Pop();

            while (ei != null && ei._LastToken == XmlToken.EOF) {
                ei._Scanner.Close();
                ei = (ScannerInfo)_ScannerStack.Pop();
            }

            if (ei != null) {
                //
                // close the old Scanner and call EndEntity()
                //
                _Scanner.Close();
                if (_Entity != null)
                    EndEntity(_Entity);

                _Scanner = ei._Scanner;
                _Entity = ei._Entity;
               _BaseURI = ei._BaseURI;
                _NextFunction = ei._NextFunction;
                _Fields = ei._Fields;
                _Used = ei._Used;
                _ReadCount = ei._ReadCount;
                _Encoding = ei._Encoding;
                _IsExternal = ei._IsExternal;
                _MaxCount = (null == _Fields) ? 0  : _Fields.Length;

                Debug.Assert(_NextFunction != -1, "PopScanner::_NextFunction should not be -1");

                if (ei._DepthIncrement) {
                    if (_ReadCount != -1 && _Fields != null && _Fields[_ReadCount] != null)
                        _Fields[_ReadCount].Depth--;
                    else
                        _ElementDepth--;
                }
                return ei._LastToken;
            }
            else {
                return XmlToken.EOF;
            }
        }

        private int PopScannerOnce() {
            ScannerInfo ei = (ScannerInfo)_ScannerStack.Pop();

            if (ei != null) {
                //
                // close the old Scanner and call EndEntity()
                //
                _Scanner.Close();
                if (_Entity != null)
                    EndEntity(_Entity);

                _Scanner = ei._Scanner;
                _Entity = ei._Entity;
                _BaseURI = ei._BaseURI;
                _NextFunction = ei._NextFunction;
                _Fields = ei._Fields;
                _Used = ei._Used;
                _ReadCount = ei._ReadCount;
                _IsExternal = ei._IsExternal;
                _MaxCount = (null == _Fields) ? 0  : _Fields.Length;
                Debug.Assert(_NextFunction != -1, "PopScanner::_NextFunction should not be -1");
                if (ei._DepthIncrement) {
                    if (_ReadCount != -1 && _Fields != null && _Fields[_ReadCount] != null)
                        _Fields[_ReadCount].Depth--;
                    else
                        _ElementDepth--;
                }
                return ei._LastToken;
            }
            else {
                return XmlToken.EOF;
            }
        }

        //
        // only pop scanner when the scanner is not pushed by ResolveEntity
        //
        //
        private bool PopScannerWhenNotResolveEntity(ref int token) {
            ScannerInfo scanner = (ScannerInfo)_ScannerStack.Peek();
            //
            // is this scanner from ResolveEntity()
            //
            if (scanner != null && scanner._EntityName != null) {
                //
                // yes
                //
                _NextFunction = _ReadEndEntityIndex;
                return false;
            }
            else {
                //
                //no
                //
                token = PopScanner();
                return true;
            }
        }

        private void ReadEmptyText() {
            if (_CurrentToken.IsAttributeText) {
                _AttributeTextToken.Depth = _CurrentToken.Depth+1;
                _AttributeTextToken.Value = String.Empty;
                _AttributeTextToken.QuoteChar = _CurrentToken.QuoteChar;
                _CurrentToken = _AttributeTextToken;
            }
            else {
                _TextToken.Depth = _CurrentToken.Depth+1;
                _TextToken.Value = String.Empty;
                _CurrentToken = _TextToken;
                _CurrentToken.LineNum = 1;
                _CurrentToken.LinePos = 1;
            }

            //
            // if we are emitting this token because there is no other token
            // the next token, we need to go is endEntity
            //
            if (this.NodeType == XmlNodeType.EntityReference) {
                _NextFunction = _ReadEndEntityIndex;
                _ContinueParsing = true;
                return;
            }
            if (_ElementToken.IsEmpty)
                _NextFunction = _PopEndElementIndex;
            else
                _NextFunction = _ParseBeginTagIndex;
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.ResetToCloseState"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal void ResetToCloseState()
        {
            //
            // reset properties state
            //
            _TmpToken.NameWPrefix = String.Empty;
            _TmpToken.Name = String.Empty;
            _TmpToken.Prefix = String.Empty;
            _TmpToken.Namespaces = String.Empty;
            _TmpToken.LinePos =  (null == _Scanner ? 0 : _Scanner.LinePos); //0;
            _TmpToken.LineNum = (null == _Scanner ? 0 : _Scanner.LineNum); //0;

            _CurrentToken = _TmpToken;

            _XmlSpace = XmlSpace.None;
            _XmlLang = String.Empty;

        }

        private void ReadEndElementToken() {
            _EndElementToken.NodeType = XmlNodeType.EndElement;
            _CurrentToken = _EndElementToken;
            _NextFunction = _PopEndElementIndex;
        }

        // ISSUE: should be removed
        private void ReadEndEntity() {
            ScannerInfo scanner = (ScannerInfo)_ScannerStack.Peek();
            if (_EndEntityToken == null)
                _EndEntityToken = new XmlNameValueTokenInfo(_Scanner, _NsMgr, XmlNodeType.EndEntity, -1, String.Empty, false);
            _CurrentToken = _EndEntityToken;
            _EndEntityToken.Name = scanner._EntityName;
            _EndEntityToken.LineNum = _Scanner.LineNum;
            _EndEntityToken.LinePos = _Scanner.LinePos;
            _EndEntityToken.Depth = scanner._EntityDepth;
        }

        private void FinishAttribute() {
            //
            // pop scanner until the scanner count is restored
            //
            while (_ScannerStack.Length > 0 && _MarkScannerCount < _ScannerStack.Length)
                PopScannerOnce();

            _MarkScannerCount = 10000;
#if XMLREADER_BETA2
            if(_RootCount<1) {
                _NextFunction = _ParseRootIndex;
                _LastToken = XmlToken.NONE;
            }
            else
#endif
                if (_ElementToken.IsEmpty)
                _NextFunction = _PopEndElementIndex;
            else
                _NextFunction = _ParseBeginTagIndex;
            _ContinueParsing = true;
        }

        //
        // XmlReader methods and properties
        //

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType
        {
            get
            {
                return _CurrentToken.NodeType;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.Name"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of
        ///       the current node, including the namespace prefix.</para>
        /// </devdoc>
        public override String Name
        {
            get
            {
                return _CurrentToken.NameWPrefix;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the current node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override String LocalName
        {
            get
            {
                return _CurrentToken.Name;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.NamespaceURI"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the namespace URN (as defined in the W3C Namespace Specification) of the current namespace scope.
        ///    </para>
        /// </devdoc>
        public override String NamespaceURI
        {
            get
            {
                return _CurrentToken.Namespaces;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.Prefix"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the namespace prefix associated with the current node.
        ///    </para>
        /// </devdoc>
        public override String Prefix
        {
            get
            {
                return _CurrentToken.Prefix;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.HasValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether
        ///    <see cref='System.Xml.XmlTextReader.Value'/> has a value to return.
        ///    </para>
        /// </devdoc>
        public override bool HasValue
        {
            get
            {
                XmlNodeType type = this.NodeType;

                switch (type) {
                    case XmlNodeType.Attribute:
                    case XmlNodeType.Text:
                    case XmlNodeType.CDATA:
                    case XmlNodeType.ProcessingInstruction:
                    case XmlNodeType.XmlDeclaration:
                    case XmlNodeType.Comment:
                    case XmlNodeType.DocumentType:
                    case XmlNodeType.Whitespace:
                    case XmlNodeType.SignificantWhitespace:
                        return true;
                    default:
                        return false;
                }
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the text value of the current node.
        ///    </para>
        /// </devdoc>
        public override String Value
        {
            get
            {
                return _CurrentToken.Value;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.Depth"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the depth of the
        ///       current node in the XML element stack.
        ///    </para>
        /// </devdoc>
        public override int Depth
        {
            get
            {
                return _CurrentToken.Depth;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.BaseURI"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the base URI of the current node.
        ///    </para>
        /// </devdoc>
        public override String BaseURI
        {
            get
            {
                return _BaseURI;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.IsEmptyElement"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether
        ///       the current
        ///       node is an empty element (for example, &lt;MyElement/&gt;).</para>
        /// </devdoc>
        public override bool IsEmptyElement
        {
            get
            {
                return _CurrentToken.IsEmpty;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.IsDefault"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the current node is an
        ///       attribute that was generated from the default value defined
        ///       in the DTD or schema.
        ///    </para>
        /// </devdoc>
        public override bool IsDefault
        {
            get
            {
                return _CurrentToken.IsDefault;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.QuoteChar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the quotation mark character used to enclose the value of an attribute
        ///       node.
        ///    </para>
        /// </devdoc>
        public override char QuoteChar
        {
            get
            {
                return _CurrentToken.QuoteChar;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlSpace"]/*' />
        /// <devdoc>
        ///    <para>Gets the current xml:space scope.</para>
        /// </devdoc>
        public override XmlSpace XmlSpace
        {
            get
            {
                return _XmlSpace;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlLang"]/*' />
        /// <devdoc>
        ///    <para>Gets the current xml:lang scope.</para>
        /// </devdoc>
        public override String XmlLang
        {
            get
            {
                return _XmlLang;
            }
        }

        //
        // attribute accessors
        //
        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.AttributeCount"]/*' />
        /// <devdoc>
        ///    <para>Gets the number of attributes on the current node.</para>
        /// </devdoc>
        public override int AttributeCount
        {
            get
            {
                return GetAttributeCount();
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.GetAttribute"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified index.</para>
        /// </devdoc>
        public override String GetAttribute(int i) {
            CheckIndexCondition(i);
            return _Fields[i].Value;
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.GetAttribute1"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified name.</para>
        /// </devdoc>
        public override String GetAttribute(string name) {
            int index;
            if (GetOrdinal(name, out index))
                return _Fields[index].Value;
            else
                return null;
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.GetAttribute2"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified name and namespace.</para>
        /// </devdoc>
        public override String GetAttribute(String localName, String namespaceURI) {
            int index;
            if (namespaceURI == null)
                namespaceURI = String.Empty;
            if (GetOrdinal(localName, namespaceURI, out index))
                return _Fields[index].Value;
            else
                return null;
        }


        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.this"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified index.</para>
        /// </devdoc>
        public override String this [ int i ]
        {
            get
            {
                return GetAttribute(i);
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.this1"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified name.</para>
        /// </devdoc>
        public override string this [ String name ]
        {
            get
            {
                return GetAttribute(name);
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.this2"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified name and namespace.</para>
        /// </devdoc>
        public override string this [ String name, String namespaceURI ]
        {
            get
            {
                return GetAttribute(name, namespaceURI);
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.MoveToAttribute"]/*' />
        /// <devdoc>
        ///    <para>Moves to the attribute with the specified name.</para>
        /// </devdoc>
        public override bool MoveToAttribute(string name) {
            int ordinal;

            if (GetOrdinal(name, out ordinal)) {
                FinishAttribute();
                _ReadCount = ordinal;
                _CurrentToken = _Fields[_ReadCount];
                return true;
            }
            else {
                return false;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.MoveToAttribute1"]/*' />
        /// <devdoc>
        ///    <para>Moves to the attribute with the specified name and namespace.</para>
        /// </devdoc>
        public override bool MoveToAttribute(string localName, string namespaceURI) {
            int ordinal;

            if (namespaceURI == null)
                namespaceURI = String.Empty;
            if (GetOrdinal(localName, namespaceURI, out ordinal)) {
                _ReadCount = ordinal;
                FinishAttribute();
                _CurrentToken = _Fields[_ReadCount];
                return true;
            }
            else {
                return false;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.MoveToAttribute2"]/*' />
        /// <devdoc>
        ///    <para>Moves to the attribute with the specified index.</para>
        /// </devdoc>
        public override void MoveToAttribute(int i) {
            CheckIndexCondition(i);
            FinishAttribute();
            _ReadCount = i;
            _CurrentToken = _Fields[_ReadCount];
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.MoveToFirstAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Moves to the first attribute.
        ///    </para>
        /// </devdoc>
        public override bool MoveToFirstAttribute() {
            if (GetAttributeCount() < 1)
                return false;

            FinishAttribute();
            _ReadCount = 0;
            _CurrentToken = _Fields[_ReadCount];
            return true;
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.MoveToNextAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Moves to the next attribute.
        ///    </para>
        /// </devdoc>
        public override bool MoveToNextAttribute() {
            if ((_ReadCount+1) < GetAttributeCount()) {
                FinishAttribute();
                _ReadCount++;
                _CurrentToken = _Fields[_ReadCount];
                return true;
            }
            return false;
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.MoveToElement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Moves to the element that contains the current attribute node.
        ///    </para>
        /// </devdoc>
        public override bool MoveToElement() {
            if (_CurrentToken.IsAttributeText || this.NodeType == XmlNodeType.Attribute) {
                FinishAttribute();
                if (_RootCount > 0) {
                    _CurrentToken = _ElementToken;
                }
                else {
                    if (_PIToken != null && _DocTypeToken == null) {
                            _CurrentToken = _PIToken;
                    }
                    else if(_DocTypeToken != null) {
                        _CurrentToken = _DocTypeToken;
                    }
                }
                _ReadCount = -1;
                return true;
            }
            return false;
        }

        // All settings remain the same.
        /// <include file='doc\xmltextreader.uex' path='docs/doc[@for="XmlTextReader.ResetState"]/*' />
        public void ResetState() {
           if (XmlNodeType.None != _PartialContentNodeType) {
                    throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidResetStateCall));
           }

            if (ReadState.Initial == ReadState) {
                //noop. we are already at the begining of the document
                return;
            }
            _ReadState = ReadState.Initial;
            _RootCount = 0;

            ResetFieldsCollection();
            _Scanner.Reset();
            _NextFunction = _ParseRootIndex;
            _DtdParser = null;
            _TmpToken  = new XmlNSElementTokenInfo(_Scanner, _NsMgr, XmlNodeType.None, String.Empty,-1, -1, -1, 0,false);
            _CurrentToken = _TmpToken;
            _CantHaveXmlDecl = false;
            _Encoding = _Scanner.Encoding;
            //
            // pop all the pushed elements
            //
            while (Pop() != null)
                ;

        }


        //
        // moving through the Stream
        //
        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.Read"]/*' />
        /// <devdoc>
        ///    <para>Reads the next
        ///       node from the stream.</para>
        /// </devdoc>
        public override bool Read() {


            while (!_Eof) {
                //
                // clear and reset variables
                //
                _ReadState = ReadState.Error;

                int prevState = 0;
                do {
                    _ContinueParsing = false;
                    prevState = _NextFunction;

                    switch (_NextFunction) {
                        case _ParseElementIndex:
                            _Used = -1;
                            _ReadCount = -1;
                            _NextState = 1;
                            ParseElement();
                            break;
                        case _ParseRootIndex:
                            ResetFieldsCollection();
                            ParseRoot();
                            break;
                        case _ReadEndElementIndex:
                            ReadEndElementToken();
                            break;
                        case _PopEndElementIndex:
                            //
                            // pop the element
                            //
                            Pop();
                            _NextFunction = _ParseBeginTagIndex;
                            goto case _ParseBeginTagIndex;
                        case _ParseBeginTagIndex:
                            ResetFieldsCollection();
                            ParseBeginTagExpandCharEntities();
                            break;
                        case _FinishAttributeIndex:
                            FinishAttribute();
                            break;
                        case _ReadEndEntityIndex:
                            //
                            // if there is no token being emitted at all, need to at
                            // least emit the empty text token
                            //
                            if (_CurrentToken.NodeType == XmlNodeType.EntityReference) {
                                _NextFunction = _ReadEmptyTextIndex;
                                _ContinueParsing = true;
                                break;
                            }
                            ReadEndEntity();
                            _NextFunction = _PopEntityScannerIndex;
                            break;
                        case _PopEntityScannerIndex:
                            _LastToken = PopScanner();
                            _ContinueParsing = true;
                            break;
                        case _ClosedIndex:
                            _ReadState = ReadState.Closed;
                            return false;
                        case _ReadEmptyTextIndex:
                            ReadEmptyText();
                            break;
                        case _FragmentXmlDeclParser:
                            ResetFieldsCollection();
                            ParseRoot();
                            int token = _Scanner.ScanContent();
                            if (XmlToken.EOF != token) {
                                throw new XmlException(Res.Xml_InvalidPartialContentData, string.Empty);
                            }
                            break;
                        case _FragmentTrailingTextNode:
                            _Eof = true;
                            _ScannerEof = true;
                            _ReadState = ReadState.EndOfFile;
                            ResetToCloseState();
                            return false;
                        case _FragmentAttributeParser:
                            ResetFieldsCollection();
                            ParseBeginTagExpandCharEntities();
                            break;
                        case _FinishReadChars:
                            _Scanner.FinishIncrementalRead(this);
                            _ContinueParsing = true;
                            _ReadInnerCharCount = 0;
                            break;
                        case _InitReader:
                            {
                                _ContinueParsing = true;
                                Init();
                                switch (_PartialContentNodeType) {
                                    case XmlNodeType.XmlDeclaration:
                                        _NextFunction = _FragmentXmlDeclParser;
                                        break;
                                    case XmlNodeType.Attribute:
                                        _NextFunction = _FragmentAttributeParser;
                                        break;
                                    default:
                                        if (_RootCount > 0)  {
                                            _NextFunction = _ParseBeginTagIndex;
                                        }
                                        else {
                                            _NextFunction = _ParseRootIndex;
                                        }
                                        break;
                                }
                            }
                            break;

                        default:
                            throw new XmlException(Res.Xml_InternalError, string.Empty);
                    }

                    _PreviousFunction = prevState;
                }
                while (_ContinueParsing);

                _ReadState = ReadState.Interactive;
                //
                // EOF only if it's RecordView or the field has all been read
                //
                if (_ScannerEof) {
                    //
                    // if EOF and we never encounter any root, error
                    //
                    if (_RootCount < 1) {
                        throw new XmlException(Res.Xml_MissingRoot, string.Empty);
                    }
                    else if (_ElementStack.Length > 0) {
                        if (_EntityDepthOffset > 0) {
                            throw new XmlException(Res.Xml_IncompleteEntity,_Scanner.LineNum, _Scanner.LinePos);
                        }
                        else {
                            throw new XmlException(Res.Xml_UnexpectedToken, "EndElement",_CurrentToken.LineNum, _CurrentToken.LinePos);
                        }
                    }
                    _Eof = true;
                    ResetToCloseState();
                    _ReadState = ReadState.EndOfFile;
                    return false;
                }

                return true;
            }
            return false;
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.EOF"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       a value indicating whether XmlReader is positioned at the end of the
        ///       stream.
        ///    </para>
        /// </devdoc>
        public override bool EOF
        {
            get
            {
                return _ReadState == ReadState.EndOfFile;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Closes the stream, changes the <see cref='System.Xml.XmlReader.ReadState'/>
        ///       to Closed, and sets all the properties back to zero.
        ///    </para>
        /// </devdoc>

        public override void Close() {
            Close(true);
        }


        // This method is here because there are times when DOM does not what the Stream to be closed, just the readers to be closed.
        internal void Close(bool closeStream) {

            _ReadState = ReadState.Closed;
            _BaseURI = String.Empty;

            //
            // pop all the pushed elements
            //
            while (Pop() != null)
                ;

            //
            // pop all the scanner
            //
            while (_ScannerStack.Length > 0)
                PopScannerOnce();

            if (_Scanner != null) {
                _Scanner.Close(closeStream);
                _Scanner = null;
            }
            ResetToCloseState();
            _NextFunction = _ClosedIndex;

        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.ReadState"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the read state of the stream.
        ///    </para>
        /// </devdoc>
        public override ReadState ReadState
        {
            get
            {
                return _ReadState;
            }
        }


        


        //
        // skip all <E>asdasdasd</E> till reaches EndElement
        //
        private void SkipElementScope() {
            int currElementDepth = _ElementDepth -1;
            while (Read()) {
                if (currElementDepth == _ElementDepth) {
                    Debug.Assert(XmlNodeType.EndElement == this.NodeType , "the node type must be EndElement");
                    return;
                }
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.GetRemainder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TextReader  GetRemainder() {
            if (_NextFunction == _InitReader) {
                if (_Scanner == null)
                    CreateScanner();
                _CurrentToken.Scanner = _Scanner;
            }
            while (_ScannerStack.Length > 0)
                PopScannerOnce();

            string str = String.Empty;
            if (_Scanner != null)
                str = _Scanner.GetRemainder();
            this.Close();
            _Eof = true;
            _ReadState = ReadState.EndOfFile;
            return new StringReader(str);
        }



        //
        //
        // whole Content Read Methods
        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.ReadChars"]/*' />
        /// <devdoc>
        ///    <para>Reads the text contents of an element into a character
        ///       buffer. This method is designed to read large streams of embedded text by
        ///       calling it successively.</para>
        /// </devdoc>
        public int ReadChars(Char[] buffer, int index, int count) {
            return IncrementalRead(buffer, index, count, IncrementalReadType.Chars);
        }

        private int IncrementalRead(Object buffer, int index, int count, IncrementalReadType readType) {
            if (this.NodeType != XmlNodeType.Element) {
                // noop
                return 0;
            }
            if (_ElementToken.IsEmpty) {
                Read();
                return 0;
            }

            if (null == buffer) {
                throw new ArgumentNullException("buffer");
            }

            if (0 > count) {
                throw new ArgumentOutOfRangeException("count");
            }

            if (0 > index) {
                throw new ArgumentOutOfRangeException("index");
            }

            if (readType == IncrementalReadType.Chars) {
                char[] inArray = buffer as char[];
                if (count > inArray.Length - index)
                    throw new ArgumentException("count");
            }
            else if (readType == IncrementalReadType.Base64 || readType == IncrementalReadType.BinHex) {
                byte[] inArray = buffer as byte[];
                if (count > inArray.Length - index)
                    throw new ArgumentException("count");
            }

            ResetFieldsCollection();
            if (_FinishReadChars == _NextFunction) {
                _NextFunction = _PreviousFunction;
            }

            Debug.Assert(_BufferConsistency == false, "_BufferConsistency should be false in this situation");
            _Scanner.ReadBufferConsistency = -1;
            int totalChars = _Scanner.IncrementalRead(buffer, index, count, this, readType);
            if (count > totalChars) {
                _ReadInnerCharCount = 0;
                Read();
            }
            else
            {
                _PreviousFunction = _NextFunction;
                _NextFunction = _FinishReadChars;
            }
            return totalChars;
        }

        internal bool ContinueReadFromBuffer(int token) {

            switch(token) {
                case XmlToken.EOF:
                     throw new XmlException(Res.Xml_UnexpectedEOF, XmlToken.ToString(XmlToken.TAG), _Scanner.LineNum, _Scanner.LinePos);
                case XmlToken.TAG:
                case XmlToken.ENDTAG:
                    //The scanner has already shifted its buffer forward so that the following
                    //      call does not cause the scanner to increase the size of the buffer;
                    _Scanner.ScanNameWOCharChecking();
                    Debug.Assert(_LastElementInfo != null);

                    int count = _Scanner.TextLength;
                    char[] scannerbuff = _Scanner.InternalBuffer;

                    if(_LastElementInfo._NameWPrefix.Length != count) {
                        // The length of this tag and the tag we are looking for are not the same, continue filling the buffer
                            return true;
                    }
                    int scannerOffset = _Scanner.TextOffset;
                    for (int i = scannerOffset, j = 0; i < (scannerOffset + count)  && j < count; i++, j++) {
                        if (_LastElementInfo._NameWPrefix[j] != scannerbuff[i]) {
                            // The two tags are different, continue;
                            return true;
                        }
                    }

                    if (XmlToken.ENDTAG == token) {
                        while(XmlToken.TAGEND != _Scanner.ScanMarkup()) {
                            // Intentionally Empty
                        }

                        if (0 == _ReadInnerCharCount) {
                            _ElementDepth--;
                            _NextFunction = _PopEndElementIndex;
                            return false;
                        }

                        _ReadInnerCharCount--;
                    }
                    else {
                        int nextToken;
                        bool flag = true;
                        while(flag) {
                            nextToken = _Scanner.ScanMarkup();
                            switch (nextToken) {
                                case XmlToken.EOF:
                                     throw new XmlException(Res.Xml_UnexpectedEOF, XmlToken.ToString(XmlToken.TAG), _Scanner.LineNum, _Scanner.LinePos);
                                case XmlToken.TAGEND :
                                    _ReadInnerCharCount++;
                                    flag = false;
                                    break;
                                case XmlToken.EMPTYTAGEND :
                                    return true;
                            } // switch
                        } // while
                    }

                    return true;
            }

            return true;
        }


       
        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.ReadBase64"]/*' />
        /// <devdoc>
        ///    <para> This method reads the text contents of an element into a character buffer.
        ///       Like <see cref='System.Xml.XmlTextReader.ReadChars'/>, this method is designed to read large streams
        ///       of embedded text by calling it successively, except that it does a base64 decode on
        ///       the content and returns the decoded binary bytes (for example, an inline base64
        ///       encoded GIF image.) See RFC 1521. (You can obtain RFCs from the Request for
        ///       Comments Web site at http://www.rfc-editor.org/.)</para>
        ///    <para>Reads the value and convert it from a base64 array to a byte array.</para>
        /// </devdoc>
        public int ReadBase64(byte[] array, int offset, int len) {
            return IncrementalRead(array, offset, len, IncrementalReadType.Base64);
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.ReadBinHex"]/*' />
        /// <devdoc>
        ///    <para> This method reads the text contents of an element into
        ///       a buffer. Like <see cref='System.Xml.XmlTextReader.ReadChars'/>,
        ///       this method is designed to read large
        ///       streams of embedded text by calling it successively, except that it does a binhex
        ///       decode on the content puts the decoded binary bytes (for example, an inline binhex encoded GIF image) into the buffer.</para>
        /// </devdoc>
        public int ReadBinHex(byte[] array, int offset, int len) {
            return IncrementalRead(array, offset, len, IncrementalReadType.BinHex);
        }


        //
        // NameTable and Namespace helpers
        //
        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.NameTable"]/*' />
        /// <devdoc>
        ///    <para>Gets the XmlNameTable associated with this
        ///       implementation.</para>
        /// </devdoc>
        public override XmlNameTable NameTable
        {
            get
            {
                return _NameTable;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.LookupNamespace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resolves a namespace prefix in the current element's scope.
        ///    </para>
        /// </devdoc>
        public override String LookupNamespace(String prefix) {
            String result = null;
            if (!_CheckNamespaces) {
                return result;
            }

            // If the prefix is not in the atom table then we cannot have
            // a namespace for it.
            prefix = _NameTable.Get(prefix);
            if (prefix != null) {
                result = _NsMgr.LookupNamespace(prefix);
                if (result == String.Empty)
                    result = null;
            }
            return result;
        }


        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.ResolveEntity"]/*' />
        /// <devdoc>
        ///    <para>Resolves the entity reference for nodes of NodeType EntityReference.</para>
        /// </devdoc>

        public override void ResolveEntity() {
            throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
        }


        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.ResolveEntity1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Resolves and parses general entities on demand at a later time.
        ///    </para>
        /// </devdoc>
        private void ResolveEntity(string name) {
            throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.ReadAttributeValue"]/*' />
        /// <devdoc>
        ///    <para>Parses the attribute value into one or more Text and/or EntityReference node
        ///       types.</para>
        /// </devdoc>
        public override bool ReadAttributeValue() {
            return ReadAttributeValue(EntityHandling.ExpandCharEntities);
        }

        //
        // XmlTextReader
        //
        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.Namespaces"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to do namespace support.
        ///    </para>
        /// </devdoc>
        public bool Namespaces
        {
            get
            {
                return _CheckNamespaces;
            }

            set
            {
                if (_ReadState != ReadState.Initial)
                    throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));

                _CheckNamespaces = value;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.Normalization"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether to do whitespace
        ///       normalization as specified in the WC3 XML
        ///       recommendation version 1.0 (see http://www.w3.org/TR/1998/REC-xml-19980210 ).</para>
        /// </devdoc>
        public bool Normalization
        {
            get
            {
                return _Normalization;
            }

            set
            {
                if (ReadState.Closed == _ReadState) {
                    throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
                }
                _Normalization = value;

                if (_NextFunction != _InitReader) {
                    _TextToken.Normalization = _Normalization;
                    _WhitespaceToken.Normalization = _Normalization;
                    _AttributeTextToken.Normalization = _Normalization;

                    if (_DocTypeToken != null)
                        _DocTypeToken.Normalization = _Normalization;
                    if (_PIToken != null)
                        _PIToken.Normalization = _Normalization;
                    if (_CommentToken != null)
                        _CommentToken.Normalization = _Normalization;
                    if (_CDATAToken != null)
                        _CDATAToken.Normalization = _Normalization;

                    int count = GetAttributeCount();
                    for (int i = 0; i < count; i++)
                        _Fields[i].Normalization = _Normalization;

                    _Scanner.Normalization = value;
                }

                if ( value ) {
                    if ( _CDataNormalizer == null ) {
                        _CDataNormalizer = new XmlAttributeCDataNormalizer( _StringBuilder );
                    }
                    _Normalizer = new XmlEolNormalizer( _StringBuilder );
                }
                else {
                    _Normalizer = _NonNormalizer;
                }
            }
        }


        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.Encoding"]/*' />
        /// <devdoc>
        ///    <para>Gets the encoding attribute for the
        ///       document.</para>
        /// </devdoc>
        public Encoding Encoding
        {
            get { return (_ReadState == ReadState.Interactive ? _Encoding : null);   }
        }


        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.WhitespaceHandling"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value that specifies how
        ///       whitespace is handled.</para>
        /// </devdoc>
        public WhitespaceHandling WhitespaceHandling
        {
            get { return _WhitespaceHandling; }
            set {
                //
                // PERF PERF: is Switch quicker???
                //
                if (ReadState.Closed == _ReadState) {
                    throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
                }

                if (value != WhitespaceHandling.None && value != WhitespaceHandling.All &&
                    value != WhitespaceHandling.Significant)
                    throw new XmlException(Res.Xml_WhitespaceHandling, string.Empty);

                _WhitespaceHandling = value;
            }
        }


        internal XmlResolver GetResolver() {
            // This is needed because we can't have the setter public and getter internal.
            return _XmlResolver;
        }


        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.XmlResolver"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the XmlResolver used for resolving URLs
        ///       and/or PUBLIC Id's used in external DTDs,
        ///       parameter entities, or XML schemas referenced in namespaces.
        ///    </para>
        /// </devdoc>
        public XmlResolver XmlResolver
        {
          set
            {
                _XmlResolver = value;
            }
        }

        bool IXmlLineInfo.HasLineInfo() { return true; }

        //
        // debug info
        //
        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.LineNumber"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the current line number.
        ///    </para>
        /// </devdoc>
        public int LineNumber
        {
            get
            {
                return _CurrentToken.LineNum;
            }
        }

        /// <include file='doc\XmlTextReader.uex' path='docs/doc[@for="XmlTextReader.LinePosition"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the current line position.
        ///    </para>
        /// </devdoc>
        public int LinePosition
        {
            get
            {
                return _CurrentToken.LinePos;
            }
        }

        internal override XmlNamespaceManager NamespaceManager
        {
            get { return _NsMgr;}
        }

        internal override bool StandAlone
        {
            get { return _StandAlone; }
        }

        internal XmlTextReader(XmlScanner scanner, XmlNameTable nt, XmlNamespaceManager nsMgr, XmlNodeType nodeType, int depth, Encoding encoding, String baseURI, bool external, bool standAlone) : this(nt) {
            _Scanner = scanner;
            _NsMgr  = nsMgr;
            _BaseURI = baseURI==null? String.Empty : XmlUrlResolver.UnEscape(baseURI);
            _RootCount = 1;
            _NextState = 2;
            _ElementDepth = -1;
            _EntityDepthOffset = depth;
            _Encoding = encoding;
            _PartialContent = true;
            // Even thought it doesn't seem like it, we are infact parsing xml fragment with this constructor.
            // this constructor is used when we encounter an entity that points to an external file and
            // the external file contains element content.
            _PartialContentNodeType = nodeType;
            _IsExternal = external;
            _StandAlone = standAlone;
        }

        internal virtual bool IsAttrText
        {
            get { return _CurrentToken.IsAttributeText || IsReadingAttributeValue || this.PartialContentNodeType == XmlNodeType.Attribute;}
        }

        internal virtual String RawValue
        {
            get { return _CurrentToken.RawValue;}
        }

        internal DtdParser DTD
        {
           get { return _DtdParser; }
           set {
            Debug.Assert(null == _DtdParser);
            _DtdParser = value;
           }
        }

        internal String LookupNamespaceBefore(String prefix) {
            String result = null;

            // If the prefix is not in the atom table then we cannot have
            // a namespace for it.
            prefix = _NameTable.Get(prefix);
            if (prefix != null) {
                result = _NsMgr.LookupNamespaceBefore(prefix);
                if (result == String.Empty)
                    result = null;
            }
            return result;
        }

        internal ValueContainEntity ValueContainEntity {
            get { return _CurrentToken.ValueContainEntity; }
            set { _CurrentToken.ValueContainEntity = value; }
        }

        internal bool IsXmlNsAttribute {
            get { return _CurrentToken.NsAttribute; }
        }

        internal void SetAttributeValue( string attributeValue, bool isCDataNormalized ) {
            XmlAttributeTokenInfo fld = _Fields[_ReadCount];
            fld.ExpandValue = attributeValue;
            fld.IsCDataNormalized = isCDataNormalized;
        }

        internal override object SchemaTypeObject
        {
            get { return _CurrentToken.SchemaType; }
            set { _CurrentToken.SchemaType = value; }
        }
        internal override object TypedValueObject
        {
            get { return _CurrentToken.TypedValue; }
            set { _CurrentToken.TypedValue = value; }
        }

        internal String GetValue()
        {
            return _CurrentToken.GetValue();
        }

        internal XmlNodeType PartialContentNodeType {
            get { return _PartialContentNodeType; }
        }

        internal event ValidationEventHandler ValidationEventHandler
        {
            add { _ValidationEventHandler += value; }
            remove { _ValidationEventHandler -= value; }
        }

        internal override bool AddDefaultAttribute(SchemaAttDef attdef) {
            string name = _NameTable.Add(attdef.Name.Name);
            string prefix = _NameTable.Add(attdef.Prefix);
            // Check if the attribute is specified
            if (IsAttributeNameDuplicate(name, prefix)) {
                return false;
            }

            // Since this attribute is not already specified, we need to add it.
            //
            // Add new field
            //
            AddAttribute();
            XmlAttributeTokenInfo fld = _Fields[_Used];
            fld.NsAttribute = false;

            //
            // set name will implicitly set NameWPrefix so
            // make sure NameWPrefix is overwritten later
            //
            string ns;
            if (_DtdParser == null)
                ns = attdef.Name.Namespace;
            else
                ns = String.Empty;

            fld.Name = name;
            fld.Prefix = prefix;
            fld.IsDefault = true;
            fld.Depth = (_LastToken == XmlToken.EMPTYTAGEND) ? _ElementDepth + 2 + _EntityDepthOffset : _ElementDepth + 1 + _EntityDepthOffset;
            fld.ValueContainEntity = attdef.HasEntityRef ? ValueContainEntity.Resolved : ValueContainEntity.None;
            fld.Normalization = _Normalization;
            if (attdef.SchemaType == null)
                fld.SchemaType = attdef.Datatype;
            else
                fld.SchemaType = attdef.SchemaType;
            fld.TypedValue = attdef.DefaultValueTyped;
            fld.LineNum = attdef.LineNum;
            fld.LinePos = attdef.LinePos;
            fld.ValueLineNum = attdef.ValueLineNum;
            fld.ValueLinePos = attdef.ValueLinePos;

            if (prefix.Length > 0) {
#if DEBUG
                if (name == String.Empty)
                    Debug.Assert(false, "This should never happen");
                else
#endif
                    fld.NameWPrefix = _NameTable.Add((prefix + ":" + name));
            }
            else {
                fld.NameWPrefix = fld.Name;
            }
            if (name != String.Empty && ns == String.Empty) {
                fld.Namespaces = fld.GenerateNS();
            }
            else {
                fld.Namespaces = _NameTable.Add(ns);
            }

            fld.ExpandValue = attdef.DefaultValueExpanded;
            fld.IgnoreValue =  attdef.DefaultValueRaw;
            fld.IsCDataNormalized = true;

            fld.NsAttribute = false;

            //
            // handle xmlns, xmlspace and xmllang
            //
            SchemaAttDef.Reserve reserved = attdef.Reserved;
            if (reserved == SchemaAttDef.Reserve.XmlSpace) {
                _XmlSpace = ConvertXmlSpace(fld.ExpandValue, 0, 0);
                ((ElementInfo) _ElementStack.Peek())._XmlSpace = _XmlSpace;
            }
            else if (reserved == SchemaAttDef.Reserve.XmlLang) {
                _XmlLang = fld.ExpandValue;
                ((ElementInfo) _ElementStack.Peek())._XmlLang = _XmlLang;
            }
            else if (
                Ref.Equal(prefix, _XmlNs) ||
                (Ref.Equal(String.Empty, prefix) && Ref.Equal(_XmlNs, name))
            ) {
                fld.NsAttribute = true;
                fld.FixNSNames();
		_ElementToken.FixNames();
            }

            return true;
        }

        internal XmlScanner GetAttribValueScanner() {

            if (_ReadState != ReadState.Interactive || GetAttributeCount() < 1 || _ReadCount < 0) {
                return null;
            }
            XmlAttributeTokenInfo fld = _Fields[_ReadCount];
            return new XmlScanner(fld.IgnoreValue.ToCharArray(), _NameTable, fld.ValueLineNum, fld.ValueLinePos + 1);

        }

        internal bool IsReadingAttributeValue {
            get { return (_NextFunction == _FinishAttributeIndex); }
        }

        internal virtual bool ReadAttributeValue(EntityHandling ehMode) {
            if (_PartialContentNodeType == XmlNodeType.Attribute) {
                return Read();
             }

            if (_ReadState != ReadState.Interactive || GetAttributeCount() < 1 || _ReadCount < 0)
                return false;

            bool ret = true;
            XmlAttributeTokenInfo fld = _Fields[_ReadCount];
            _AttributeTextToken.SchemaType = fld.SchemaType;
            _AttributeTextToken.TypedValue = fld.TypedValue;

            if (_NextFunction != _FinishAttributeIndex) {
                if (ehMode == EntityHandling.ExpandEntities) {
                    ret = true;
                    _CurrentToken = _AttributeTextToken;
                    _AttributeTextToken.SetNormalizedValue( fld.Value );
                    //_CurrentToken.Value = fld.Value; 
                    _CurrentToken.NodeType = XmlNodeType.Text;
                    _CurrentToken.Name = String.Empty;
                    _CurrentToken.Depth = fld.Depth+1;
                    _CurrentToken.LineNum = fld.ValueLineNum;
                    _CurrentToken.LinePos = fld.ValueLinePos + 1;
                    _NextFunction = _FinishAttributeIndex;
                    _LastToken = XmlToken.EOF;
                    goto cleanup;
                }
                else if (fld.ValueContainEntity == ValueContainEntity.None) {
                    ret = true;
                    _CurrentToken = _AttributeTextToken;
                    //_CurrentToken.Value = fld.ExpandValue;
                    _AttributeTextToken.SetNormalizedValue( fld.Value );
                    _CurrentToken.NodeType = XmlNodeType.Text;
                    _CurrentToken.Name = String.Empty;
                    _CurrentToken.Depth = fld.Depth+1;
                    _CurrentToken.LineNum = fld.ValueLineNum;
                    _CurrentToken.LinePos = fld.ValueLinePos + 1;
                    _NextFunction = _FinishAttributeIndex;
                    _LastToken = XmlToken.EOF;
                    goto cleanup;
                }

                _MarkScannerCount = _ScannerStack.Length;
                //
                // push scanner when this function is called the first time
                //
                PushScanner(GetAttribValueScanner() , null, _BaseURI, _Fields, _ReadCount, _Used,
                    _LastToken, _FinishAttributeIndex, false, null, 0, _Encoding, _StandAlone, _IsExternal, _IsExternal);
            }
            else if (_LastToken == XmlToken.EOF) {
                //
                // if there is more than one Scanner being pushed, it could be from ResolveEntity()
                //
                if (_ScannerStack.Length > 0 && (_MarkScannerCount+1) < _ScannerStack.Length) {
                    if (!PopScannerWhenNotResolveEntity(ref _LastToken)) {
                        ReadEndEntity();
                        _LastToken = PopScanner();
                        ret = true;
                        goto cleanup;
                    }
                }
                else {
                    ret = false;
                    goto cleanup;
                }
            }

            XmlBasicTokenInfo saveToken = _CurrentToken;
            _CurrentToken = _AttributeTextToken;
            bool noToken = false;

            bool bIsNonCDataAttribute = _Normalization && saveToken.SchemaType != null &&
                                         saveToken.SchemaType is XmlSchemaDatatype &&
                                        ((XmlSchemaDatatype)saveToken.SchemaType).TokenizedType != XmlTokenizedType.CDATA;

            do {
                noToken = ParseLiteralTokens(_Scanner, _AttributeTextToken, fld.Depth+1, ehMode, 
                                             bIsNonCDataAttribute, ref _LastToken);

                if (noToken && _LastToken == XmlToken.EOF) {
                    if (_ScannerStack.Length > 0 && (_MarkScannerCount+1) < _ScannerStack.Length) {
                        if (!PopScannerWhenNotResolveEntity(ref _LastToken)) {
                            //
                            // need to emit the EndEntity token
                            //
                            ReadEndEntity();
                            _LastToken = PopScanner();
                            noToken = false;
                        }
                    }
                    else {
                        _CurrentToken = saveToken;
                        ret = false;
                        goto cleanup;
                    }
                }
            }
            while (noToken && _LastToken != XmlToken.EOF);

            _NextFunction = _FinishAttributeIndex;
            ret = true;
            cleanup:
            return ret;
        }

        private XmlNodeType CheckWhitespaceNodeType {
            get {
                if (_XmlSpace == XmlSpace.Preserve)
                    return XmlNodeType.SignificantWhitespace;
                else
                    return XmlNodeType.Whitespace;
            }
        }

        private bool ReturnWhitespaceToken(XmlNormalizer normalizer) {
            bool returnWS = false;

            if (_WhitespaceHandling == WhitespaceHandling.None) {
                goto cleanup;
            }

            if (_LastElementInfo == null) {
                _WhitespaceToken.NodeType = XmlNodeType.Whitespace;
            }
            else {
                _WhitespaceToken.NodeType = this.CheckWhitespaceNodeType;
            }

            if (_WhitespaceToken.NodeType == XmlNodeType.Whitespace && _WhitespaceHandling != WhitespaceHandling.All) {
                goto cleanup;
            }

            _WhitespaceToken.SetValue(normalizer);

            _WhitespaceToken.LineNum = _Scanner.LineNum;
            _WhitespaceToken.LinePos = _Scanner.LinePos;
            returnWS = true;
            cleanup:
            return returnWS;
        }

         private bool ReturnWhitespaceToken(XmlScanner scanner) {
            bool returnWS = false;

            if (_WhitespaceHandling == WhitespaceHandling.None) {
                goto cleanup;
            }

            if (_LastElementInfo == null) {
                _WhitespaceToken.NodeType = XmlNodeType.Whitespace;
            }
            else {
                _WhitespaceToken.NodeType = this.CheckWhitespaceNodeType;
            }
            if (_WhitespaceToken.NodeType == XmlNodeType.Whitespace && _WhitespaceHandling != WhitespaceHandling.All) {
                goto cleanup;
            }
            _WhitespaceToken.SetValue(scanner, null, scanner.StartPos, scanner.TextLength);
            _WhitespaceToken.LineNum = _Scanner.LineNum;
            _WhitespaceToken.LinePos = _Scanner.LinePos;
            returnWS = true;
            cleanup:
            return returnWS;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlwhitespace.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlWhitespace.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlWhitespace.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Xml 
{
    using System;
    using System.Xml.XPath;
    using System.Text;
    using System.Diagnostics;

    /// <include file='doc\XmlWhitespace.uex' path='docs/doc[@for="XmlWhitespace"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the text content of an element or attribute.
    ///    </para>
    /// </devdoc>
    public class XmlWhitespace : XmlCharacterData {
        /// <include file='doc\XmlWhitespace.uex' path='docs/doc[@for="XmlWhitespace.XmlWhitespace"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected internal XmlWhitespace( string strData, XmlDocument doc ) : base( strData, doc ) {
            if ( !doc.IsLoading && !base.CheckOnData( strData ) )
                throw new ArgumentException(Res.GetString(Res.Xdom_WS_Char));
        }
        
        /// <include file='doc\XmlWhitespace.uex' path='docs/doc[@for="XmlWhitespace.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the node.
        ///    </para>
        /// </devdoc>
        public override String Name
        { 
            get { return XmlDocument.strNonSignificantWhitespaceName;}
        }

        /// <include file='doc\XmlWhitespace.uex' path='docs/doc[@for="XmlWhitespace.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the current node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override String LocalName
        { 
            get { return XmlDocument.strNonSignificantWhitespaceName;}
        }

        /// <include file='doc\XmlWhitespace.uex' path='docs/doc[@for="XmlWhitespace.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType
        {
            get { return XmlNodeType.Whitespace;}
        }
        
        /// <include file='doc\XmlWhitespace.uex' path='docs/doc[@for="XmlWhitespace.Value"]/*' />
        public override String Value {
            get { return Data;}
            set { 
                if ( CheckOnData( value ) )
                    Data = value;
                else
                    throw new ArgumentException(Res.GetString(Res.Xdom_WS_Char));
            }
        }
        
        /// <include file='doc\XmlWhitespace.uex' path='docs/doc[@for="XmlWhitespace.CloneNode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a duplicate of this node.
        ///    </para>
        /// </devdoc>
        public override XmlNode CloneNode(bool deep) {
            Debug.Assert( OwnerDocument != null );
            return OwnerDocument.CreateWhitespace( Data );
        }

        /// <include file='doc\XmlWhitespace.uex' path='docs/doc[@for="XmlWhitespace.WriteTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteTo(XmlWriter w) {
            w.WriteWhitespace(Data);
        }

        /// <include file='doc\XmlWhitespace.uex' path='docs/doc[@for="XmlWhitespace.WriteContentTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves all the children of the node to the specified XmlWriter.
        ///    </para>
        /// </devdoc>
        public override void WriteContentTo(XmlWriter w) {
            // Intentionally do nothing
        }

        internal override XPathNodeType XPNodeType { 
            get {
                XPathNodeType xnt = XPathNodeType.Whitespace;
                DecideXPNodeTypeForTextNodes( this, ref xnt );
                return xnt;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlwstokeninfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlWSTokenInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.Text;
using System.Diagnostics;
namespace System.Xml {

    using System.Diagnostics;

/*
 * XmlWSTokenInfo class is for Whitespace and Text tokens
 * that may need to be normalized
 */
    internal class XmlWSTokenInfo : XmlValueTokenInfo {
        private String          _Name;

        internal XmlWSTokenInfo(XmlScanner scanner, XmlNamespaceManager nsMgr, XmlNodeType type,
                                int depth,
                                bool nor) : base(scanner, nsMgr, type, depth, nor) {
            _Name = String.Empty;
            _RawValue = String.Empty;
        }

        internal override String Name
        {
            get
            {
                return _Name;
            }
            set
            {
                _Name = value;
                Debug.Assert(Ref.Equal(_Name, _Scanner.GetTextAtom(_Name)), "Name should be atomalized");
                Debug.Assert(_Name != null, "Name should not be set to null");
            }
        }

        internal override String NameWPrefix
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.Name = value;
            }
        }

        internal override String Value
        {
            get
            {
                return base.Value;
            }

            set
            {
                _Value = value;
                _HasNormalize = !_NormalizeText;
            }
        }

        internal void SetTokenInfo(XmlNodeType nodeType, String name, int depth) {
            _NodeType = nodeType;
            //
            // this name should already be atomalized
            _Name = name;
            Debug.Assert(Ref.Equal(_Name, _Scanner.GetTextAtom(name)), "Name should be atomalized");

            _Depth = depth;
        }

    } // XmlWSTokenInfo
} // System.Xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlvalidatingreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="xmlvalidatingreader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml
{
    using System;
    using System.IO;
    using System.Collections;
    using System.Diagnostics;
    using System.Text;
    using System.Xml.Schema;
    using System.Security.Permissions;

    //
    /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader"]/*' />
    /// <devdoc>
    ///    Represents a reader that provides fast, non-cached
    ///    forward only stream
    ///    access to XML data.
    /// </devdoc>
    [PermissionSetAttribute( SecurityAction.InheritanceDemand, Name = "FullTrust" )]
    public class XmlValidatingReader : XmlReader, IXmlLineInfo {
        private static readonly Type _stringType = typeof(string);
        private enum InResolveEntity {
                None,
                AttributeTextPush,
                AttributeTextPop,
                Text,
        };
        private XmlTextReader       _CoreReader;
        private int                 _XmlReaderMark;
        private Validator  _Validator;
        private String              _XmlNs;

        // mode settings
        private bool                _Normalization;
        private WhitespaceHandling  _WhitespaceHandling;

        private bool                _Eof;
        private XmlNodeType         _NodeType;
        private int                 _Depth;
        private String              _BaseURI;
        private bool                _IsEmptyElement;
        private bool                _IsDefault;
        private char                _QuoteChar;
        private String              _FullName;
        private String              _LocalName;
        private String              _NamespaceURI;
        private String              _Prefix;
        private String              _Value;
        private Encoding            _Encoding;
        private int                 _LineNumber;
        private int                 _LinePosition;

        private XmlSpace            _XmlSpace; // for default attribute
        private String              _XmlLang;

        private ValidationEventHandler _ValidationEventHandler;
        private ValidationEventHandler _InternalValidationEventHandler;
        private ValidationType      _ValidationType;

        // EntityHandling
        private EntityHandling      _EntityHandling;
        private bool                _ReadAhead;
        private bool                _InitialReadState;

        private InResolveEntity     _InResolveEntity;
        private bool                _ResolveEntityInternally;
        private bool                _DisableUndeclaredEntityCheck;

        private HWStack             _CoreReaderStack;
        private const int           STACK_INCREMENT = 10;
        private StringBuilder       _StringBuilder;

        private    String           _Decimal;
        private    String           _Hexdecimal;
        private    XmlSchemaCollection  _SchemaCollection;
        private    XmlNodeType         _PartialContentNodeType = XmlNodeType.None;
        private    XmlParserContext     _PartialContentParserContext;
        private    bool             _UseCoreReaderOnly;

        private    XmlAttributeCDataNormalizer _CDataNormalizer;
        private    XmlNonNormalizer             _NonNormalizer;

        private void Init() {
            // internal variables
            _Validator = null;
            _ValidationEventHandler = null;

            _ReadAhead = false;
            _InitialReadState = true;
            _CoreReaderStack = new HWStack(STACK_INCREMENT);
            _StringBuilder = new StringBuilder(100);
            _CDataNormalizer = new XmlAttributeCDataNormalizer( _StringBuilder );
            _NonNormalizer = new XmlNonNormalizer( _StringBuilder );
            _Encoding = null;

            _Eof = false;
            _InResolveEntity = InResolveEntity.None;
            _ResolveEntityInternally = false;
            _DisableUndeclaredEntityCheck = false;

            // default settings
            _Normalization = false;
            _WhitespaceHandling = WhitespaceHandling.All;;
            _EntityHandling = EntityHandling.ExpandEntities;;

            //properties
            InitTokenInfo();
        }

        private void InitTokenInfo() {
            _NodeType = XmlNodeType.None;
            _Depth = 0;
            _BaseURI = String.Empty;
            _IsEmptyElement = false;
            _IsDefault = false;
            _QuoteChar = '\0';
            _FullName = String.Empty;
            _LocalName = String.Empty;
            _NamespaceURI = String.Empty;
            _Prefix = String.Empty;
            _Value = String.Empty;
            _StringBuilder.Length = 0;

            _XmlSpace = XmlSpace.None;
            _XmlLang= String.Empty;
        }

        // ue attention
        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.XmlValidatingReader"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlValidatingReader(XmlReader reader) {
            _CoreReader = reader as XmlTextReader;
            if (_CoreReader == null) {
                throw new ArgumentException("reader");
            }

            Init();

            // copy settings from XmlTextReader
            _Normalization = _CoreReader.Normalization;
            _WhitespaceHandling = _CoreReader.WhitespaceHandling;
            _Decimal = _CoreReader.NameTable.Get("#decimal");
            _Hexdecimal = _CoreReader.NameTable.Get("#hexidecimal");

            _BaseURI = _CoreReader.BaseURI;

            // internal variables
            _InternalValidationEventHandler = new ValidationEventHandler(InternalValidationCallback);

            _ValidationType = ValidationType.Auto;
            _SchemaCollection = new XmlSchemaCollection(_CoreReader.NameTable);
            _Validator = new Validator(_CoreReader.NameTable, new SchemaNames(_CoreReader.NameTable), this);

            _Validator.ValidationFlag = _ValidationType;
            _Validator.XmlResolver = this.GetResolver();
            _Validator.SchemaCollection = _SchemaCollection;
            _SchemaCollection.XmlResolver = this.GetResolver();
            if (_BaseURI != String.Empty) {
                if (null == GetResolver()){
                    _Validator.BaseUri = new Uri(_BaseURI);
                } else {
                    _Validator.BaseUri = GetResolver().ResolveUri(null, _BaseURI);
                }
            }

            // validating callback
            _Validator.ValidationEventHandler += _InternalValidationEventHandler;
            _CoreReader.ValidationEventHandler += _InternalValidationEventHandler;
            _UseCoreReaderOnly = false;


        }

        // ue attention
        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.XmlValidatingReader1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlValidatingReader(String xmlFragment, XmlNodeType fragType, XmlParserContext context)
        :this(new XmlTextReader(xmlFragment, fragType, context))
        {
            _PartialContentNodeType  = fragType;
            _BaseURI = (null != context ? context.BaseURI : String.Empty);

            if (_BaseURI != String.Empty)
                _Validator.BaseUri = GetResolver().ResolveUri(null, _BaseURI);

            _PartialContentParserContext = context;
        }


        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.XmlValidatingReader2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlValidatingReader(Stream xmlFragment, XmlNodeType fragType, XmlParserContext context)
        :this(new XmlTextReader(xmlFragment, fragType, context))
        {
            _PartialContentNodeType  = fragType;
            _BaseURI = (null != context ? context.BaseURI : String.Empty);

            if (_BaseURI != String.Empty)
                _Validator.BaseUri = GetResolver().ResolveUri(null, _BaseURI);

            _PartialContentParserContext = context;
        }


        private void UpdatePartialContentDTDHandling()
        {
                if (null == _PartialContentParserContext || String.Empty == _PartialContentParserContext.DocTypeName) {
                    return;
                }

                Debug.Assert(null == _CoreReader.DTD);

                // Create a DTD parser with the information provided.

                String dtdString = "DOCTYPE " + _PartialContentParserContext.DocTypeName
                                    + (String.Empty == _PartialContentParserContext.PublicId
                                        ? (String.Empty == _PartialContentParserContext.SystemId? String.Empty : " SYSTEM \'" + _PartialContentParserContext.SystemId + "\' ")
                                        : (" PUBLIC \'" + _PartialContentParserContext.PublicId + "\' \'" + _PartialContentParserContext.SystemId + "\' " ))
                                    + (String.Empty == _PartialContentParserContext.InternalSubset ? String.Empty : "[ " + _PartialContentParserContext.InternalSubset + " ]")
                                    + " >";

                XmlScanner dtdScanner = new XmlScanner(dtdString.ToCharArray(), _CoreReader.NameTable);
                dtdScanner.Normalization  = _CoreReader.Normalization;
                dtdScanner.NamespaceSupport = _CoreReader.Namespaces;


                // Since this class creates its own _CoreReader under xmlfragment case, the _CoreReader's ValidationHandler does not need to be
                //  hooked up to the DTD. Only the ValidatingReader's ValidationHanderl does. If the user had given us their own reader, then
                //  we would have to hook up the user's ValidationEventHandler as well.
                DtdParser dtd = new DtdParser(dtdScanner, _CoreReader, this.GetResolver(), _CoreReader.NameTable, _InternalValidationEventHandler, _CoreReader.Namespaces);
                _CoreReader.DTD = dtd;
                dtd.Parse();
                _CoreReader.NameTable.Add(dtd.GetSchemaInfo().DocTypeName.ToString());
                ValidateDtd();
                _PartialContentParserContext = null;
        }

        // ue attention
        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.ValidationEventHandler"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public  event ValidationEventHandler ValidationEventHandler
        {
            add {
                 _ValidationEventHandler += value;

                if (ValidationType.None != _ValidationType) {
                    UpdateValidationCallBack(false);
                }
            }
            remove {
                 _ValidationEventHandler -= value;
                if (ValidationType.None != _ValidationType) {
                    UpdateValidationCallBack(true);
                }
            }
        }

        // XmlReader methods and properties
        //

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.NodeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the current node.
        ///    </para>
        /// </devdoc>
        public override XmlNodeType NodeType
        {
            get
            {
               if (_ReadAhead)
                    return _NodeType;
                else
                   return _CoreReader.NodeType;
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.Name"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of
        ///       the current node, including the namespace prefix.</para>
        /// </devdoc>
        public override String Name
        {
            get
            {
                if (_ReadAhead)
                    return _FullName;
                else
                    return _CoreReader.Name;
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.LocalName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the current node without the namespace prefix.
        ///    </para>
        /// </devdoc>
        public override String LocalName
        {
            get
            {
                if (_ReadAhead)
                    return _LocalName;
                else
                    return _CoreReader.LocalName;
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.NamespaceURI"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the namespace URN (as defined in the W3C Namespace Specification) of the current namespace scope.
        ///    </para>
        /// </devdoc>
        public override String NamespaceURI
        {
            get
            {
                if (_ReadAhead)
                    return _NamespaceURI;
                else
                    return _CoreReader.NamespaceURI;
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.Prefix"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the namespace prefix associated with the current node.
        ///    </para>
        /// </devdoc>
        public override String Prefix
        {
            get
            {
                if (_ReadAhead)
                    return _Prefix;
                else
                    return _CoreReader.Prefix;
            }
        }

        // UE attention
        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.Schemas"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemaCollection Schemas {
            get { return _SchemaCollection; }
        }

        // UE attention
        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.SchemaType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object SchemaType {
            get {
                if (_ValidationType != ValidationType.None)
                    return _CoreReader.SchemaTypeObject;
                else
                    return null;
            }
        }

        // UE attention
        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.TypedValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object ReadTypedValue() {
            if (_ValidationType == ValidationType.None) {
                return null;
            }

            XmlNodeType type = this.NodeType;
            if (type == XmlNodeType.Attribute) {
                return _CoreReader.TypedValueObject;
            }
            else if (type == XmlNodeType.Element && SchemaType != null) {
                XmlSchemaDatatype dtype = (SchemaType is XmlSchemaDatatype) ? (XmlSchemaDatatype)SchemaType : ((XmlSchemaType)SchemaType).Datatype;
                if (dtype != null) {
                    if (!this.IsEmptyElement) {
                        bool flag = true;
                        while(flag) {
                            if (! Read()) {
                                throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
                            }
                            type = this.NodeType;
                            flag = type == XmlNodeType.CDATA
                                || type == XmlNodeType.Text
                                || type == XmlNodeType.Whitespace
                                || type == XmlNodeType.SignificantWhitespace
                                || type == XmlNodeType.Comment;
                        }
                        if (this.NodeType != XmlNodeType.EndElement) {
                            throw new XmlException(Res.Xml_InvalidNodeType, this.NodeType.ToString());
                        }
                    }
                    return _CoreReader.TypedValueObject;
                }
            }
            return null;
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.HasValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether
        ///    <see cref='System.Xml.XmlValidatingReader.Value'/> has a value to return.
        ///    </para>
        /// </devdoc>
        public override bool HasValue
        {
            get {
                XmlNodeType type = this.NodeType;

                switch (type) {
                    case XmlNodeType.Attribute:
                    case XmlNodeType.Text:
                    case XmlNodeType.CDATA:
                    case XmlNodeType.ProcessingInstruction:
                    case XmlNodeType.XmlDeclaration:
                    case XmlNodeType.Comment:
                    case XmlNodeType.DocumentType:
                    case XmlNodeType.Whitespace:
                    case XmlNodeType.SignificantWhitespace:
                        return true;
                    default:
                        return false;
                }
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the text value of the current node.
        ///    </para>
        /// </devdoc>
        public override String Value
        {
            get {
                if (_ReadAhead)
                    return _StringBuilder.ToString();
                else {
                    if (_CoreReader.ValueContainEntity == ValueContainEntity.NotResolved) {
                        ExpandLiteralValue();
                    }
                    return _CoreReader.GetValue();
                }
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.Depth"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the depth of the
        ///       current node in the XML element stack.
        ///    </para>
        /// </devdoc>
        public override int Depth
        {
            get
            {
                if (_UseCoreReaderOnly) {
                    return _CoreReader.Depth;
                }
                return _Depth;
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.BaseURI"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the base URI of the current node.
        ///    </para>
        /// </devdoc>
        public override String BaseURI
        {
            get
            {
                if (_ReadAhead)
                    return _BaseURI;
                else
                   return _CoreReader.BaseURI;
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.IsEmptyElement"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether
        ///       the current
        ///       node is an empty element (for example, &lt;MyElement/&gt;).</para>
        /// </devdoc>
        public override bool IsEmptyElement
        {
            get
            {
                if (_ReadAhead)
                    return _IsEmptyElement;
                else
                     return _CoreReader.IsEmptyElement;
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.IsDefault"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the current node is an
        ///       attribute that was generated from the default value defined
        ///       in the DTD or schema.
        ///    </para>
        /// </devdoc>
        public override bool IsDefault
        {
            get
            {
                if (_ReadAhead)
                    return _IsDefault;
                else
                     return _CoreReader.IsDefault;
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.QuoteChar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the quotation mark character used to enclose the value of an attribute
        ///       node.
        ///    </para>
        /// </devdoc>
        public override char QuoteChar
        {
            get
            {
                if (_ReadAhead)
                    return _QuoteChar;
                else
                     return _CoreReader.QuoteChar;
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.XmlSpace"]/*' />
        /// <devdoc>
        ///    <para>Gets the current xml:space scope.</para>
        /// </devdoc>
        public override XmlSpace XmlSpace
        {
            get {
                if (_ReadAhead)
                    return _XmlSpace;
                else
                     return _CoreReader.XmlSpace;
                }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.XmlLang"]/*' />
        /// <devdoc>
        ///    <para>Gets the current xml:lang scope.</para>
        /// </devdoc>
        public override String XmlLang
        {
            get {
                if (_ReadAhead)
                    return _XmlLang;
                else
                     return _CoreReader.XmlLang;
              }
        }

        //
        // attribute accessors
        //
        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.AttributeCount"]/*' />
        /// <devdoc>
        ///    <para>Gets the number of attributes on the current node.</para>
        /// </devdoc>
        public override int AttributeCount {
            get {
                 if (_ReadAhead || _InResolveEntity == InResolveEntity.AttributeTextPop)
                    return 0;
                 else
                    return _CoreReader.AttributeCount;
            }
        }

        // UE Attention
        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.Reader"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified index.</para>
        /// </devdoc>
        public XmlReader Reader {
            get {
                return (XmlReader) _CoreReader;
            }
        }

        // UE Attention
        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.ValidationType"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified index.</para>
        /// </devdoc>
        public ValidationType ValidationType {
            get {
                return _ValidationType;
            }
            set {
                if (ReadState.Initial != ReadState) {
                    throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
                }
                switch(value) {
                    case ValidationType.None:
                        UpdateValidationCallBack(true);
                        break;
                    case ValidationType.Auto:
                    case ValidationType.XDR:
                    case ValidationType.DTD:
                    case ValidationType.Schema:
                        if (_ValidationType == ValidationType.None) {
                            UpdateValidationCallBack(false);
                        }
                        break;
                    default:
                        throw new ArgumentOutOfRangeException("value");

                }
                _ValidationType = value;
                _Validator.ValidationFlag = _ValidationType;
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.GetAttribute"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified index.</para>
        /// </devdoc>
        public override String GetAttribute(int i) {
            if (i < 0 || i >= this.AttributeCount) {
                throw new ArgumentOutOfRangeException("i");
            }
            return _CoreReader.GetAttribute(i);
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.GetAttribute1"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified name.</para>
        /// </devdoc>
        public override String GetAttribute(string name) {
            if (_ReadAhead || _InResolveEntity == InResolveEntity.AttributeTextPop)
                return null;
            else
                return _CoreReader.GetAttribute(name);
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.GetAttribute2"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified name and namespace.</para>
        /// </devdoc>
        public override String GetAttribute(String localName, String namespaceURI) {
            if (_ReadAhead || _InResolveEntity == InResolveEntity.AttributeTextPop)
                return null;
            else
                return _CoreReader.GetAttribute(localName, namespaceURI);
        }


        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.this"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified index.</para>
        /// </devdoc>
        public override String this [ int i ]
        {
            get { return GetAttribute(i); }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.this1"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified name.</para>
        /// </devdoc>
        public override string this [ String name ]
        {
            get
            {
                return GetAttribute(name);
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.this2"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the attribute with the specified name and namespace.</para>
        /// </devdoc>
        public override string this [ String name, String namespaceURI ]
        {
            //ISSUE
            get
            {
                return GetAttribute(name, namespaceURI);
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.MoveToAttribute"]/*' />
        /// <devdoc>
        ///    <para>Moves to the attribute with the specified name.</para>
        /// </devdoc>
        public override bool MoveToAttribute(string name) {
            //ISSUE
            if (_ReadAhead) {
                return false;
            }
            else if (_InResolveEntity == InResolveEntity.AttributeTextPop) {
                PopResolveEntityAttTextReader();
            }
            if (_CoreReader.MoveToAttribute(name)) {
                UpdateNodeProperties(_CoreReader);
                return true;
            }
            return false;
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.MoveToAttribute1"]/*' />
        /// <devdoc>
        ///    <para>Moves to the attribute with the specified name and namespace.</para>
        /// </devdoc>
        public override bool MoveToAttribute(string localName, string namespaceURI) {
            //ISSUE
            if (_ReadAhead) {
                return false;
            }
            else if (_InResolveEntity == InResolveEntity.AttributeTextPop) {
                PopResolveEntityAttTextReader();
            }
            if (_CoreReader.MoveToAttribute(localName, namespaceURI)) {
                UpdateNodeProperties(_CoreReader);
                 _InResolveEntity = InResolveEntity.None;
                return true;
            }
            return false;
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.MoveToAttribute2"]/*' />
        /// <devdoc>
        ///    <para>Moves to the attribute with the specified index.</para>
        /// </devdoc>
        public override void MoveToAttribute(int i) {
            if (_ReadAhead) {
                return;
            }
            else if (_InResolveEntity == InResolveEntity.AttributeTextPop) {
                PopResolveEntityAttTextReader();
            }
            _CoreReader.MoveToAttribute(i);
            UpdateNodeProperties(_CoreReader);
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.MoveToFirstAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Moves to the first attribute.
        ///    </para>
        /// </devdoc>
        public override bool MoveToFirstAttribute() {
            if (_ReadAhead) {
                return false;
            }
            else if (_InResolveEntity == InResolveEntity.AttributeTextPop) {
                PopResolveEntityAttTextReader();
            }
            if (_CoreReader.MoveToFirstAttribute()) {
                UpdateNodeProperties(_CoreReader);
                _InResolveEntity = InResolveEntity.None;
                return true;
            }
            return false;
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.MoveToNextAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Moves to the next attribute.
        ///    </para>
        /// </devdoc>
        public override bool MoveToNextAttribute() {
            if (_ReadAhead) {
                return false;
            }
            else if (_InResolveEntity == InResolveEntity.AttributeTextPop) {
                PopResolveEntityAttTextReader();
            }
            if(_CoreReader.MoveToNextAttribute()) {
                UpdateNodeProperties(_CoreReader);
                _InResolveEntity = InResolveEntity.None;
                return true;
            }
            return false;
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.MoveToElement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Moves to the element that contains the current attribute node.
        ///    </para>
        /// </devdoc>
        public override bool MoveToElement() {
            if (_ReadAhead) {
                return false;
            }
            else if (_InResolveEntity == InResolveEntity.AttributeTextPop) {
                PopResolveEntityAttTextReader();
            }
            if (_CoreReader.MoveToElement()) {
                UpdateNodeProperties(_CoreReader);
                _InResolveEntity = InResolveEntity.None;
                return true;
            }
            return false;
        }

        //
        // moving through the Stream
        //
        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.Read"]/*' />
        /// <devdoc>
        ///    <para>Reads the next
        ///       node from the stream.</para>
        /// </devdoc>
        public override bool Read() {

            if (_UseCoreReaderOnly) {
                return ReadNoCollectTextToken();
            }
            else {
                return ReadWithCollectTextToken();
            }

        }

        private bool ReadNoCollectTextToken() {
            if (InResolveEntity.Text == _InResolveEntity && !DisableUndeclaredEntityCheck) {
                throw new XmlException(Res.Xml_UndeclaredEntity, this.Name, _CoreReader.LineNumber, _CoreReader.LinePosition);
            }
            if (!_CoreReader.Read()) {
                return false;
            }
            switch (_CoreReader.NodeType) {
                case XmlNodeType.EntityReference:
                    if (EntityHandling.ExpandCharEntities == EntityHandling) {
                        _InResolveEntity = InResolveEntity.Text;
                    } else {
                        throw new XmlException(Res.Xml_UndeclaredEntity, this.Name, _CoreReader.LineNumber, _CoreReader.LinePosition);
                    }
                     break;
                case XmlNodeType.Element:
                    while (_CoreReader.MoveToNextAttribute()) {
                        if (_CoreReader.ValueContainEntity == ValueContainEntity.NotResolved) {
                            // we shouldn't have any references to any entities since there is no DTD that could have defined them.
                            while(_CoreReader.ReadAttributeValue()) {
                                if (XmlNodeType.EntityReference == _CoreReader.NodeType) {
                                    throw new XmlException(Res.Xml_UndeclaredEntity, this.Name, _CoreReader.LineNumber, _CoreReader.LinePosition);
                                }
                            }
                        }
                    }
                    _CoreReader.MoveToElement();
                    break;
                default:
                    break;
            }
            return true;
        }

        private bool ReadWithCollectTextToken() {

            if (null != _PartialContentParserContext ) {
                UpdatePartialContentDTDHandling();
            }

            bool continueParsing;

            do {
                switch(_InResolveEntity) {
                    case InResolveEntity.Text:
                            PushResolveEntityTextReader();
                            if (_ResolveEntityInternally) {
                                ResolveEntityInternally();
                            }
                        break;
                    case InResolveEntity.AttributeTextPush:
                        if (_PartialContentNodeType == XmlNodeType.Attribute) {
                                PushResolveEntityAttTextReader();
                        }
                        break;
                    case InResolveEntity.AttributeTextPop:
                            PopResolveEntityAttTextReader();
                    break;
                }

                _XmlReaderMark = -1;
                continueParsing = false;
                _InitialReadState = false;

                _InResolveEntity = InResolveEntity.None;

                if ((_ReadAhead && !_CoreReader.EOF) || _CoreReader.Read() || (PopXmlReaderTilMark())) {

                    // ISSUE: the following properties are not
                    // expensive therefore we can get it beforehand
                    //
                    _Depth = _CoreReader.Depth;
                    _ReadAhead = false;

                    switch (_CoreReader.NodeType) {
                        case XmlNodeType.Element:
                            // there might be entity defined in attribute value and
                            // namespace declaration, therefore we have to
                            // expand the value to ensure wellformness and reset
                            // the namespace value.
                            // NOTE NOTE
                            // if we remove this code, we need to put ExpandLiteralValue
                            // in Value property
                            //
                            if (0 == Depth) {
                                _UseCoreReaderOnly = (ValidationType.None == ValidationType && null == _CoreReader.DTD);
                            }
                            bool flag = false;
                            while (_CoreReader.MoveToNextAttribute()) {
                                if (_CoreReader.ValueContainEntity == ValueContainEntity.NotResolved) {
                                    if (_CoreReader.IsXmlNsAttribute)  {
                                        ExpandLiteralValue();
                                        NamespaceManager.AddNamespace(_CoreReader.LocalName, _CoreReader.Value); // redefine
                                    }
                                    else {
                                        // just to resolve entity and make sure entity is wellform
                                        ExpandLiteralValue();
                                    }
                                }
                                flag = true;
                            }
                            if (flag)
                                _CoreReader.MoveToElement();
                            _FullName = _CoreReader.Name;
                            _LocalName = _CoreReader.LocalName;
                            _Prefix = _CoreReader.Prefix;
                            _NamespaceURI = _CoreReader.NamespaceURI;
                            _Validator.Validate(ValidationType);
                            _IsEmptyElement = _CoreReader.IsEmptyElement;
                            break;
                        case XmlNodeType.Text:
                            // ISSUE: need to figure out a way to produce this value without generating a string
                            _FullName = String.Empty;
                            _LocalName = String.Empty;
                            _Prefix = String.Empty;
                            _NamespaceURI= String.Empty;
                            _Encoding = _CoreReader.Encoding;
                            _XmlReaderMark = _CoreReaderStack.Length;
                            _NodeType = CollectTextToken(_EntityHandling, _Depth, XmlNodeType.Attribute == _PartialContentNodeType);
                            goto default;
                        case XmlNodeType.Whitespace:
                            if (_Depth > 0
                                || XmlNodeType.Element == _PartialContentNodeType
                                || XmlNodeType.Attribute == _PartialContentNodeType) {
                                _FullName = String.Empty;
                                _LocalName = String.Empty;
                                _Prefix = String.Empty;
                                _NamespaceURI= String.Empty;
                                _Encoding = _CoreReader.Encoding;

                                _XmlReaderMark = _CoreReaderStack.Length;
                                _NodeType = CollectTextToken(_EntityHandling, _Depth, XmlNodeType.Attribute == _PartialContentNodeType);
                                _XmlReaderMark = -1;

                                if (_NodeType == XmlNodeType.Text) {
                                    goto default;
                                }
                                if (_Validator.AllowText()) {
                                     // ISSUE: maybe able to improve the perf by changing AllowText into a
                                     // property
                                    _NodeType = XmlNodeType.SignificantWhitespace;
                                    if (_WhitespaceHandling == WhitespaceHandling.None)
                                        continueParsing = true;
                                }
                                else if (_WhitespaceHandling != WhitespaceHandling.All) {
                                    continueParsing = true;
                                }
                            }
                            else if (_WhitespaceHandling != WhitespaceHandling.All) {
                                continueParsing = true;
                            }
                            if (_Validator.HasSchema)
                                _Validator.ValidateWhitespace();

                            break;
                        case XmlNodeType.EntityReference:
                            if (_EntityHandling == EntityHandling.ExpandEntities) {
                                // ISSUE: need to figure out a way to produce this value without generating a string
                                _FullName = String.Empty;
                                _LocalName = String.Empty;
                                _Prefix = String.Empty;
                                _NamespaceURI= String.Empty;
                                _Encoding = _CoreReader.Encoding;

                                _XmlReaderMark = _CoreReaderStack.Length;
                                _NodeType = CollectTextToken(_EntityHandling, _Depth, XmlNodeType.Attribute == _PartialContentNodeType);
                                if (_NodeType == XmlNodeType.Whitespace && _WhitespaceHandling == WhitespaceHandling.None) {
                                    continueParsing = true;
                                }

                            }
                            else if (!_DisableUndeclaredEntityCheck) {
                                _InResolveEntity = InResolveEntity.Text;
                                _ResolveEntityInternally = true;
                            }
                            goto default;
                        case XmlNodeType.EndElement:
                            _FullName = _CoreReader.Name;
                            _LocalName = _CoreReader.LocalName;
                            _Prefix = _CoreReader.Prefix;
                            _NamespaceURI = _CoreReader.NamespaceURI;
                            goto default;
                        case XmlNodeType.EndEntity:
                            break;
                        case XmlNodeType.DocumentType:
                            ValidateDtd();
                            break;
                        default:
                            if (ValidationType.None != _ValidationType) {
                                _Validator.Validate();
                            }
                            break;
                        }
                    }
                    else {
                        _Eof = true;
                        InitTokenInfo();
                    }
                } while (continueParsing);

            if (!_Eof) {
                return true;
            }
            else {
                _Validator.CompleteValidation();
                return false;
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.EOF"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       a value indicating whether XmlReader is positioned at the end of the
        ///       stream.
        ///    </para>
        /// </devdoc>
        public override bool EOF
        {
            get
            {
                if (_ReadAhead)
                    return false;
                else return _CoreReader.EOF;
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Closes the stream, changes the <see cref='System.Xml.XmlReader.ReadState'/>
        ///       to Closed, and sets all the properties back to zero.
        ///    </para>
        /// </devdoc>
        public override void Close() {
            Close(true);
        }

        // This method is here because there are times when DOM does not what the Stream to be closed, just the readers to be closed.
        internal void Close(bool closeStream) {
             _ReadAhead = false;
             while(PopXmlReader()); // Pop all the core readers that we have pushed on to the stack;
             _CoreReader.Close(closeStream);
             InitTokenInfo();
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.ReadState"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the read state of the stream.
        ///    </para>
        /// </devdoc>
        public override ReadState ReadState
        {
            get
            {
                if (_InitialReadState) {
                    return ReadState.Initial;
                }
                else {
                    if (_ReadAhead)
                        return ReadState.Interactive;
                    else
                        return _CoreReader.ReadState;
                }

            }
        }


        

        //
        // NameTable and Namespace helpers
        //
        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.NameTable"]/*' />
        /// <devdoc>
        ///    <para>Gets the XmlNameTable associated with this
        ///       implementation.</para>
        /// </devdoc>
        public override XmlNameTable NameTable
        {
            get
            {
                return _CoreReader.NameTable;
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.LookupNamespace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resolves a namespace prefix in the current element's scope.
        ///    </para>
        /// </devdoc>
        public override String LookupNamespace(String prefix) {
            String ns;
            if (_ReadAhead && _CoreReader.NodeType == XmlNodeType.Element)
                ns = _CoreReader.LookupNamespaceBefore(prefix);
            else
                ns = _CoreReader.LookupNamespace(prefix);
            return ns;
        }

        //
        // Entity Handling
        //
        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.EntityHandling"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value that specifies how the XmlReader handles entities.</para>
        /// </devdoc>
        public EntityHandling EntityHandling
        {
            get { return _EntityHandling; }
            set {
                  if (value != EntityHandling.ExpandEntities && value != EntityHandling.ExpandCharEntities)
                     throw new XmlException(Res.Xml_EntityHandling, string.Empty);
                  _EntityHandling = value;
            }
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.ResolveEntity"]/*' />
        /// <devdoc>
        ///    <para>Resolves the entity reference for nodes of NodeType EntityReference.</para>
        /// </devdoc>
        public override void ResolveEntity() {
            if (this.NodeType != XmlNodeType.EntityReference)
                throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));

            if (!_Validator.HasSchema) {
                if (_DisableUndeclaredEntityCheck) {
                    return;
                }
                throw new XmlException(Res.Xml_UndeclaredEntity, this.Name, _CoreReader.LineNumber, _CoreReader.LinePosition);
            }

            if (_CoreReader.IsAttrText)
                _InResolveEntity = InResolveEntity.AttributeTextPush;
            else
                _InResolveEntity = InResolveEntity.Text;
            _ResolveEntityInternally = false;
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.ReadAttributeValue"]/*' />
        /// <devdoc>
        ///    <para>Parses the attribute value into one or more Text and/or EntityReference node
        ///       types.</para>
        /// </devdoc>
        public override bool ReadAttributeValue() {
            return ReadAttributeValue(_EntityHandling);
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.Encoding"]/*' />
        /// <devdoc>
        ///    <para>Gets the encoding attribute for the
        ///       document.</para>
        /// </devdoc>
        public Encoding Encoding
        {
            get {
                if (_ReadAhead)
                    return _Encoding;
                else
                    return _CoreReader.Encoding;
            }
        }


        internal XmlResolver GetResolver() {
            // This is needed because we can't have the setter public and getter internal.
            return _CoreReader.GetResolver();
        }


        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.XmlResolver"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the XmlResolver used for resolving URLs
        ///       and/or PUBLIC Id's used in external DTDs,
        ///       parameter entities, or XML schemas referenced in namespaces.
        ///    </para>
        /// </devdoc>
        public XmlResolver XmlResolver
        {
            set {
                _CoreReader.XmlResolver = value;
                _Validator.XmlResolver = value;
                _SchemaCollection.XmlResolver = value;

                if (null != _CoreReader.DTD) {
                    _CoreReader.DTD.Resolver = value;
                }
            }
        }

        //UE Atention
        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.CanResolveEntity"]/*' />
        public override bool CanResolveEntity
        {
            get
            {
		//DOM relies on _DisableUndeclaredEntity bug86563
                if ( _DisableUndeclaredEntityCheck && this.NodeType == XmlNodeType.EntityReference 
		     && _Validator.SchemaInfo.SchemaType != System.Xml.Schema.SchemaType.DTD) {
                    return false;
                }
                return true;
            }
        }


        //
        // XmlOldTextReader
        //
        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.Namespaces"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to do namespace support.
        ///    </para>
        /// </devdoc>
        public bool Namespaces
        {
            get { return _CoreReader.Namespaces; }
            set { _CoreReader.Namespaces = value; }
        }

        bool IXmlLineInfo.HasLineInfo() { return true; }

        /// <include file='doc\xmlvalidatingreader.uex' path='docs/doc[@for="XmlValidatingReader.IXmlLineInfo.LineNumber"]/*' />
        /// <internalonly/>
        int IXmlLineInfo.LineNumber {
            get {
                    if (_ReadAhead) {
                        return _LineNumber;
                    }
                    else {
                        return _CoreReader.LineNumber;
                    }
                }
        }

        /// <include file='doc\xmlvalidatingreader.uex' path='docs/doc[@for="XmlValidatingReader.IXmlLineInfo.LinePosition"]/*' />
        /// <internalonly/>
        int IXmlLineInfo.LinePosition {
            get {
                    if (_ReadAhead) {
                        return _LinePosition;
                    }
                    else {
                        return _CoreReader.LinePosition;
                    }
                }
        }

        internal override XmlNamespaceManager NamespaceManager
        {
            get { return _CoreReader.NamespaceManager; }
        }

        internal override object SchemaTypeObject {
            get { return _CoreReader.SchemaTypeObject; }
            set { _CoreReader.SchemaTypeObject = value; }
        }

        internal override object TypedValueObject {
            get { return _CoreReader.TypedValueObject; }
            set { _CoreReader.TypedValueObject = value; }
        }

        // handshake with XmlTextReader

        internal override bool StandAlone
        {
            get { return _CoreReader.StandAlone; }
        }
        internal virtual String RawValue
        {
            get { return _CoreReader.RawValue;}
        }


        internal bool ReadAttributeValue(EntityHandling ehMode) {
            if (ehMode == EntityHandling.ExpandEntities) {
                // only setting the value
                _Value = this.Value;

            }

            if (_InResolveEntity == InResolveEntity.AttributeTextPush) {
                if (_XmlReaderMark == -1)
                    _XmlReaderMark = _CoreReaderStack.Length;
                PushResolveEntityAttTextReader();
                _InResolveEntity = InResolveEntity.AttributeTextPop;
            }

            do {
                if (_CoreReader.ReadAttributeValue(ehMode)) {
                    _FullName = _CoreReader.Name;
                    _LocalName = _CoreReader.LocalName;
                    _Prefix = _CoreReader.Prefix;
                    _NamespaceURI = _CoreReader.NamespaceURI;
                    _Depth = _CoreReader.Depth;
                    _NodeType = _CoreReader.NodeType;
                    return true;
                }
                // we should only pop if we have actually pushed while we were reading the attribute value;
            } while ((_InResolveEntity == InResolveEntity.AttributeTextPop) && _CoreReaderStack.Length > _XmlReaderMark && PopXmlReader());

            _InResolveEntity = InResolveEntity.None;
            return false;
        }

        internal bool DisableUndeclaredEntityCheck
        {
            get { return _DisableUndeclaredEntityCheck; }
            set { _DisableUndeclaredEntityCheck = value; }
        }

        internal override bool AddDefaultAttribute(SchemaAttDef attdef) {
            bool result = _CoreReader.AddDefaultAttribute(attdef);
            _XmlSpace = _CoreReader._XmlSpace;
            _XmlLang = _CoreReader._XmlLang;
            return result;
        }

        internal SchemaInfo GetSchemaInfo() {
            return _Validator.SchemaInfo;
        }

        // private methods and properties
        private void ResolveEntityInternally() {
            int depth = this.Depth;
            while (Read() && depth < this.Depth) {
            }
            _ResolveEntityInternally = false;
        }

        private void PushResolveEntityTextReader() {
            Object o = null;
            String resolved;
            bool external;

            // ISSUE: should probably create a varialbe in validatreader
            XmlScanner scanner = GetEntityScanner(this.Name, _CoreReader.IsAttrText, ref o, out external, out resolved);
            XmlEntityReader r = new XmlEntityReader(scanner, this.NameTable, _CoreReader.NamespaceManager, XmlNodeType.Element, this.Name, _Depth+1, _CoreReader.Encoding,
                                                    resolved, external, false, _CoreReader.StandAlone, BaseURI);
            PushXmlReader(o, r, external);
            _InResolveEntity = InResolveEntity.None;
        }

        private void PushResolveEntityAttTextReader() {
            Object o = null;
            String resolved;
            bool external;

            // ISSUE: should probably create a varialbe in validatreader
            XmlScanner scanner = GetEntityScanner(this.Name, _CoreReader.IsAttrText, ref o, out external, out resolved);
            XmlEntityReader r;
            if (null != scanner) {
                r = new XmlEntityReader(scanner, this.NameTable, _CoreReader.NamespaceManager, XmlNodeType.Attribute, this.Name, _Depth+1, _CoreReader.Encoding, resolved, external, _CoreReader.IsAttrText, _CoreReader.StandAlone, BaseURI);
                _StringBuilder.Length = 0;
            }
            else {
                // _DisableUndeclaredEntity == true
                r = new XmlEntityReader(scanner, this.NameTable, _CoreReader.NamespaceManager, XmlNodeType.Attribute, this.Name, _Depth+1, _CoreReader.Encoding, resolved, external, _CoreReader.IsAttrText, _CoreReader.StandAlone, BaseURI);
            }
            PushXmlReader(o, r, external);
        }

        private void PopResolveEntityAttTextReader() {
            while (_CoreReaderStack.Length > _XmlReaderMark && PopXmlReader()) {
                // Intentionally Empty
            }


            _InResolveEntity = InResolveEntity.None;
        }

        private void InternalValidationCallback(object sender, ValidationEventArgs e ) {
            if ( this._ValidationEventHandler == null && ValidationType.None != _ValidationType && e.Severity == XmlSeverityType.Error) {
                throw e.Exception;
            }
            if (this._ValidationEventHandler != null && _ValidationType == ValidationType.DTD) {
                if(e.Exception.SourceUri == null && e.Exception.LineNumber == 0 && e.Exception.LinePosition == 0 && _CoreReader.DTD != null) {
                   e.Exception.SetSource(_CoreReader.DTD.BaseUri, _CoreReader._Scanner.StartLineNum, _CoreReader._Scanner.StartLinePos);
                }
            }
            if (this._ValidationEventHandler != null && _ValidationType == ValidationType.XDR) {
                if(e.Exception.SourceUri == null && e.Exception.LineNumber == 0 && e.Exception.LinePosition == 0 && e.Severity != XmlSeverityType.Warning) {
                    e.Exception.SetSource(_CoreReader._BaseURI, _CoreReader.LineNumber, _CoreReader.LinePosition);
                }
            }
        }

        private void ValidateDtd() {
            if (_XmlNs == null)
                _XmlNs = _CoreReader.NameTable.Add("xmlns");

            DtdParser dtd = _CoreReader.DTD;
            if (dtd != null && ( _ValidationType == ValidationType.DTD || _ValidationType == ValidationType.Auto || _ValidationType == ValidationType.None)) {
                _Validator.SchemaInfo = dtd.GetSchemaInfo();
            }
        }
        private void UpdateValidationCallBack(bool fRemove) {
            if ( _ValidationEventHandler != null) {
                if (fRemove) {
                    _CoreReader.ValidationEventHandler -= _ValidationEventHandler;
                    _Validator.ValidationEventHandler -= _ValidationEventHandler;

                    DtdParser dtd = _CoreReader.DTD;
                    if (dtd != null)
                        dtd.ValidationEventHandler -= _ValidationEventHandler;
                }
                else {
                    _CoreReader.ValidationEventHandler += _ValidationEventHandler;
                    _Validator.ValidationEventHandler += _ValidationEventHandler;

                    DtdParser dtd = _CoreReader.DTD;
                    if (dtd != null)
                        dtd.ValidationEventHandler += _ValidationEventHandler;
                }
           }
        }

        private event ValidationEventHandler InternalValidationEventHandler
        {
            add { _InternalValidationEventHandler += value; }
            remove { _InternalValidationEventHandler -= value; }
        }

        private void UpdateNodeProperties(XmlTextReader reader) {
            _NodeType = reader.NodeType;
            _Depth = reader.Depth;
            _IsEmptyElement = reader.IsEmptyElement;
            _IsDefault = reader.IsDefault;
            _QuoteChar = reader.QuoteChar;
        }

        private sealed class CoreReaderInfo {
            internal XmlTextReader _CoreReader;
            internal object _Entity;
        };

        private void PushXmlReader(Object entity, XmlTextReader reader, bool copyNormalizationFlag) {
            CoreReaderInfo r = (CoreReaderInfo)_CoreReaderStack.Push();
            if (r == null) {
                r = new CoreReaderInfo();
                _CoreReaderStack[_CoreReaderStack.Length-1] = r;
            }

            r._Entity = entity;
            r._CoreReader = _CoreReader;
            _CoreReader =  reader;

            Debug.Assert( _CoreReader.Normalization == false );

            if (copyNormalizationFlag)
                _CoreReader.Normalization = _Normalization;
        }

        private bool PopXmlReader() {
            // ISSUE: how about scanner, do we need to close Scanner???
             CoreReaderInfo r = (CoreReaderInfo)_CoreReaderStack.Pop();
             if (r != null) {
                 _CoreReader.Close();
                 _CoreReader = r._CoreReader;
                 if (r._Entity != null)
                   ((SchemaEntity)r._Entity).IsProcessed = false;
                 return true;
             }
             else {
                return false;
             }
        }

        private bool PopXmlReaderTilMark() {
            // ISSUE: how about scanner, do we need to close Scanner???

            while (_CoreReaderStack.Length > _XmlReaderMark) {
                if (PopXmlReader()) {
                    if (_CoreReader.Read())
                        return true;
                }
                else {
                    return false;
                }
            }
            return false;
        }

        private XmlScanner GetEntityScanner(String name, bool isAttrText, ref object o, out bool isExternal,out String resolved) {
            if (!_Validator.HasSchema) {
                if (_DisableUndeclaredEntityCheck ) {
                    goto disableEntityScanner;
                }
                throw new XmlException(Res.Xml_UndeclaredEntity, name, _CoreReader.LineNumber, _CoreReader.LinePosition);
            }
            XmlScanner scanner = _Validator.ResolveEntity(name, isAttrText, ref o, out isExternal, out resolved, _DisableUndeclaredEntityCheck);
            if (null == scanner && _DisableUndeclaredEntityCheck) {
                    goto disableEntityScanner;
            }
            return scanner;

            disableEntityScanner:
                isExternal = false;
                resolved = String.Empty;
                return null;

        }

        private void ExpandLiteralValue() {
            int depth = this._Depth;
            _XmlReaderMark = _CoreReaderStack.Length+1;
            //pass the position of litereal to scanner LineNumber, LinePosition + lenght of attribute name and markups
            XmlTextReader r ;
            XmlScanner scanner = _CoreReader.GetAttribValueScanner();
            r = new XmlTextReader(scanner, this.NameTable, _CoreReader.NamespaceManager,(_CoreReader.IsAttrText ? XmlNodeType.Attribute : XmlNodeType.Element), depth, _CoreReader.Encoding, _BaseURI, false, _CoreReader.StandAlone);

            PushXmlReader(null, r, false); 
            r.Read();
            CollectTextToken(EntityHandling.ExpandEntities, depth, true);
            PopXmlReader();
            _CoreReader.SetAttributeValue( _StringBuilder.ToString(), true );
            _CoreReader.ValueContainEntity = ValueContainEntity.Resolved;
            _ReadAhead = false;
            _XmlReaderMark = -1;
        }

        private XmlNodeType CollectTextToken(EntityHandling ehMode, int depth, bool isAttText) {
            Object o = null;
            String resolved;
            bool external;
            _NodeType = _CoreReader.NodeType;
            _BaseURI = _CoreReader.BaseURI;
            _IsEmptyElement = _CoreReader.IsEmptyElement;
            _IsDefault = _CoreReader.IsDefault;
            _QuoteChar = _CoreReader.QuoteChar;
            _XmlSpace = _CoreReader.XmlSpace;
            _XmlLang = _CoreReader.XmlLang;
            _LineNumber = _CoreReader.LineNumber;
            _LinePosition = _CoreReader.LinePosition;
            _ReadAhead = true;
            int entityDepth = 0;

            XmlNormalizer normalizer;
            if ( isAttText && _Normalization )
                normalizer = _CDataNormalizer;
            else
                normalizer = _NonNormalizer;
            normalizer.Reset();

            XmlNodeType nodeType = _NodeType;

            bool returnFirstNodeInEntityRef = false;
            if (XmlNodeType.EntityReference == nodeType) {
                // If the Entity has no text nodes or the first node in the resolved part is not a text/whitespace node,
                // just return the first node.
                returnFirstNodeInEntityRef = true;
            }
         //PERF checking for _StringBuilder.Length == 0 should be taken out of loop
            do {
                switch (_CoreReader.NodeType) {
                    case XmlNodeType.Whitespace:
                        returnFirstNodeInEntityRef = false;
                        if (_StringBuilder.Length == 0) {
                            nodeType = XmlNodeType.Whitespace;
                            _LineNumber = _CoreReader.LineNumber;
                            _LinePosition = _CoreReader.LinePosition;
                        }
                        if ( entityDepth == 0 )
                            normalizer.AppendRaw(_CoreReader.Value);
                        else
                            normalizer.AppendText(_CoreReader.Value);
                        break;
                    case XmlNodeType.Text:
                        if (_StringBuilder.Length == 0) {
                            _LineNumber = _CoreReader.LineNumber;
                            _LinePosition = _CoreReader.LinePosition;
                        }
                        returnFirstNodeInEntityRef = false;
                        if ( entityDepth == 0 )
                            normalizer.AppendRaw(_CoreReader.Value);
                        else
                            normalizer.AppendText(_CoreReader.Value);
                        nodeType = XmlNodeType.Text;
                        break;
                    case XmlNodeType.EntityReference:
                        if (ehMode == EntityHandling.ExpandEntities) {
                            XmlScanner scanner = GetEntityScanner(_CoreReader.Name, isAttText, ref o, out external, out resolved);
                            if (scanner != null) {
                                PushXmlReader(o, new XmlTextReader(scanner, this.NameTable, _CoreReader.NamespaceManager, (isAttText ? XmlNodeType.Attribute : XmlNodeType.Element), depth, _CoreReader.Encoding, resolved, external, _CoreReader.StandAlone), external);
                                entityDepth++;
                            }
                            else {
                                returnFirstNodeInEntityRef = false;
                                nodeType = XmlNodeType.Text;
                            }
                        }
                        else if (ehMode == EntityHandling.ExpandCharEntities) {
                            returnFirstNodeInEntityRef = false;
                            if (_StringBuilder.Length == 0) {
                                _ReadAhead = false;
                            }
                            goto cleanup;
                        }
                        break;
                    default:
                        if (isAttText && XmlNodeType.EndEntity != _CoreReader.NodeType) {
                                throw new XmlException(Res.Xml_InvalidContentForThisNode, XmlNodeType.Attribute.ToString());
                        }
                        if (returnFirstNodeInEntityRef) {

                            _ReadAhead = false;

                            _NodeType = _CoreReader.NodeType;
                            nodeType = _NodeType;
                            _BaseURI = _CoreReader.BaseURI;
                            _IsEmptyElement = _CoreReader.IsEmptyElement;
                            _IsDefault = _CoreReader.IsDefault;
                            _QuoteChar = _CoreReader.QuoteChar;
                            _XmlSpace = _CoreReader.XmlSpace;
                            _XmlLang = _CoreReader.XmlLang;
                            _ReadAhead = false;
                            _StringBuilder.Length = 0;
                            _FullName = _CoreReader.Name;
                            _LocalName = _CoreReader.LocalName;
                            _Prefix = _CoreReader.Prefix;
                            _NamespaceURI = _CoreReader.NamespaceURI;
                        }

                        return nodeType;
                }
                if (!_CoreReader.Read()) {
                    if (isAttText) {
                        if (!PopXmlReaderTilMark()) {
                            goto cleanup;
                        }
                        entityDepth--;
                    }
                    else {
                        do {
                            if (!PopXmlReader()) {
                                goto cleanup;
                            }
                        } while (!_CoreReader.Read());
                    }
                }
           } while (true);
           // } while (_CoreReader.Read() || PopXmlReaderTilMark());
            cleanup:
            return nodeType;
        }

        /// <include file='doc\XmlValidatingReader.uex' path='docs/doc[@for="XmlValidatingReader.ReadString"]/*' />
        /// <devdoc>
        ///    <para>Reads the contents of an element as a string.</para>
        /// </devdoc>
	    public override string ReadString() {
		    if ((this.NodeType == XmlNodeType.EntityReference) && (_ResolveEntityInternally == false)) {
			    if (! this.Read()) {
                    		    throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation));
			    }
		    }
		    return base.ReadString();
	    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmlwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------
namespace System.Xml {

    using System;
    using System.Collections;
    using System.IO;

/// <include file='doc\XmlWriter.uex' path='docs/doc[@for="Formatting"]/*' />
/// <devdoc>
///    <para>
///       Specifies formatting options for the XmlWriter stream.
///    </para>
/// </devdoc>
    public enum Formatting {
        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="Formatting.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No special formatting is done (this is the default).
        ///    </para>
        /// </devdoc>
        None,
        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="Formatting.Indented"]/*' />
        /// <devdoc>
/// This option causes child elements to be indented using
/// the Indentation and IndentChar properties.  It only indents Element Content
/// (http://www.w3.org/TR/1998/REC-xml-19980210#sec-element-content)
/// and not Mixed Content (http://www.w3.org/TR/1998/REC-xml-19980210#sec-mixed-content)
/// according to the XML 1.0 definitions of these terms.
/// </devdoc>
        Indented,
    };



/// <include file='doc\XmlWriter.uex' path='docs/doc[@for="WriteState"]/*' />
/// <devdoc>
///    <para>
///       Specifies the state of the XmlWriter stream.
///    </para>
/// </devdoc>
    public enum WriteState {
        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="WriteState.Start"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Nothing has been written yet.
        ///    </para>
        /// </devdoc>
        Start,
        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="WriteState.Prolog"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writing the prolog.
        ///    </para>
        /// </devdoc>
        Prolog,
        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="WriteState.Element"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writing a the start tag for an element.
        ///    </para>
        /// </devdoc>
        Element,
        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="WriteState.Attribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writing an attribute value.
        ///    </para>
        /// </devdoc>
        Attribute,
        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="WriteState.Content"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writing element content.
        ///    </para>
        /// </devdoc>
        Content,
        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="WriteState.Closed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Close has been called.
        ///    </para>
        /// </devdoc>
        Closed,
    };

// Abstract base class.
    /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter"]/*' />
    /// <devdoc>
    ///    <para>Represents a writer that provides fast non-cached forward-only way of generating XML streams containing XML documents that conform to the W3C Extensible Markup Language (XML) 1.0 specification and the Namespaces in XML specification.</para>
    /// <para>This class is <see langword='abstract'/> .</para>
    /// </devdoc>
    public abstract class XmlWriter {

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteStartDocument"]/*' />
        /// <devdoc>
        ///    <para>Writes out the XML declaration with the version "1.0".</para>
        /// </devdoc>
        public abstract void WriteStartDocument();
        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteStartDocument1"]/*' />
        /// <devdoc>
        ///    <para>Writes out the XML declaration with the version "1.0" and the
        ///       standalone attribute.</para>
        /// </devdoc>
        public abstract void WriteStartDocument(bool standalone);
        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteEndDocument"]/*' />
        /// <devdoc>
        ///    Closes any open elements or attributes and
        ///    puts the writer back in the Start state.
        /// </devdoc>
        public abstract void WriteEndDocument();

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteDocType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes out the DOCTYPE declaration with the specified name
        ///       and optional attributes.
        ///    </para>
        /// </devdoc>
        public abstract void WriteDocType(string name, string pubid, string sysid, string subset);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteStartElement"]/*' />
        /// <devdoc>
        ///    <para>Writes out the specified start tag and associates it with the
        ///       given namespace.</para>
        /// </devdoc>
        public void WriteStartElement(string localName, string ns) {
            WriteStartElement(null, localName, ns);
        }

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteStartElement1"]/*' />
        /// <devdoc>
        ///    <para>Writes out the specified start tag and
        ///       associates it with the given namespace and prefix.</para>
        /// </devdoc>
        public abstract void WriteStartElement(string prefix, string localName, string ns);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteStartElement2"]/*' />
        /// <devdoc>
        ///    <para>Writes out a start tag with the specified name.</para>
        /// </devdoc>
        public void WriteStartElement(string localName) {
            WriteStartElement(null, localName, null);
        }


        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteEndElement"]/*' />
        /// <devdoc>
        ///    <para>Closes one element and pops the corresponding namespace scope.</para>
        /// </devdoc>
        public abstract void WriteEndElement();
        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteFullEndElement"]/*' />
        /// <devdoc>
        ///    <para>Closes one element and pops the
        ///       corresponding namespace scope.</para>
        /// </devdoc>
        public abstract void WriteFullEndElement();

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteAttributeString"]/*' />
        /// <devdoc>
        ///    <para>Writes out the attribute with the specified LocalName, value, and NamespaceURI.</para>
        /// </devdoc>
        public void WriteAttributeString(string localName, string ns, string value) {
            WriteStartAttribute(null, localName, ns);
            WriteString(value);
            WriteEndAttribute();
        }

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteAttributeString1"]/*' />
        /// <devdoc>
        ///    <para>Writes out the attribute with the specified LocalName and value.</para>
        /// </devdoc>
        public void WriteAttributeString(string localName, string value) {
            WriteStartAttribute(null, localName, null);
            WriteString(value);
            WriteEndAttribute();
        }

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteAttributeString2"]/*' />
        /// <devdoc>
        ///    <para>Writes out the attribute with the specified
        ///       prefix, LocalName, NamespaceURI and value.</para>
        /// </devdoc>
        public void WriteAttributeString(string prefix, string localName, string ns, string value) {
            WriteStartAttribute(prefix, localName, ns);
            WriteString(value);
            WriteEndAttribute();
        }

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteStartAttribute"]/*' />
        /// <devdoc>
        ///    <para>Writes the start of an attribute.</para>
        /// </devdoc>
        public void WriteStartAttribute(string localName, string ns) {
            WriteStartAttribute(null, localName, ns);
        }

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteStartAttribute1"]/*' />
        /// <devdoc>
        ///    <para>Writes the start of an attribute.</para>
        /// </devdoc>
        public abstract void WriteStartAttribute(string prefix, string localName, string ns);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteEndAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Closes
        ///       the previous WriteStartAttribute call.
        ///    </para>
        /// </devdoc>
        public abstract void WriteEndAttribute();


        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteCData"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes out a &lt;![CDATA[...]]&gt; block containing
        ///       the specified text.
        ///    </para>
        /// </devdoc>
        public abstract void WriteCData(string text);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteComment"]/*' />
        /// <devdoc>
        ///    <para>Writes out a comment &lt;!--...--&gt; containing
        ///       the specified text.</para>
        /// </devdoc>
        public abstract void WriteComment(string text);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteProcessingInstruction"]/*' />
        /// <devdoc>
        ///    <para>Writes out a processing instruction with a space between
        ///       the name and text as follows: &lt;?name text?&gt;.</para>
        /// </devdoc>
        public abstract void WriteProcessingInstruction(string name, string text);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteEntityRef"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes out an entity reference as follows: "&amp;"+name+";".
        ///    </para>
        /// </devdoc>
        public abstract void WriteEntityRef(string name);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteCharEntity"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Forces the
        ///       generation of a character entity for the specified Unicode character value.
        ///    </para>
        /// </devdoc>
        public abstract void WriteCharEntity(char ch);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteWhitespace"]/*' />
        /// <devdoc>
        ///    Writes out the given whitespace.
        /// </devdoc>
        public abstract void WriteWhitespace(string ws);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes out the specified text content.
        ///    </para>
        /// </devdoc>
        public abstract void WriteString(string text);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteSurrogateCharEntity"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Write out the surrogate paris
        ///    </para>
        /// </devdoc>
        public abstract void WriteSurrogateCharEntity(char lowChar, char highChar);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteChars"]/*' />
        /// <devdoc>
        ///    <para>Writes text a buffer at a time.</para>
        /// </devdoc>
        public abstract void WriteChars(Char[] buffer, int index, int count);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteRaw"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes raw markup manually from a character buffer.
        ///    </para>
        /// </devdoc>
        public abstract void WriteRaw(Char[] buffer, int index, int count);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteRaw1"]/*' />
        /// <devdoc>
        ///    <para>Writes raw markup manually from a string.</para>
        /// </devdoc>
        public abstract void WriteRaw(String data);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteBase64"]/*' />
        /// <devdoc>
        ///    <para>Encodes the specified binary bytes as base64 and writes out
        ///       the resulting text.</para>
        /// </devdoc>
        public abstract void WriteBase64(byte[] buffer, int index, int count);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteBinHex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Encodes the specified binary bytes as binhex and writes out
        ///       the resulting text.
        ///    </para>
        /// </devdoc>
        public abstract void WriteBinHex(byte[] buffer, int index, int count);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteState"]/*' />
        /// <devdoc>
        /// <para>Gets the state of the stream.</para>
        /// </devdoc>
        public abstract WriteState WriteState { get;}

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.Close"]/*' />
        /// <devdoc>
        ///    <para>Close this stream and the underlying stream.</para>
        /// </devdoc>
        public abstract void Close();

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.Flush"]/*' />
        /// <devdoc>
        ///    <para>Flush whatever is in the buffer to the underlying streams and flush the
        ///       underlying stream.</para>
        /// </devdoc>
        public abstract void Flush();

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.LookupPrefix"]/*' />
        /// <devdoc>
        ///    <para>Returns the closest prefix defined in the current
        ///       namespace scope for the specified namespace URI.</para>
        /// </devdoc>
        public abstract string LookupPrefix(string ns);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.XmlSpace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an XmlSpace representing the current xml:space scope.
        ///    </para>
        /// </devdoc>
        public abstract XmlSpace XmlSpace { get;}

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.XmlLang"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the current xml:lang scope.
        ///    </para>
        /// </devdoc>
        public abstract string XmlLang { get;}

        // Scalar Value Methods

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteNmToken"]/*' />
        /// <devdoc>
        ///    <para>Writes out the specified name, ensuring it is a valid NmToken
        ///       according to the XML specification (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name).</para>
        /// </devdoc>
        public abstract void WriteNmToken(string name);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteName"]/*' />
        /// <devdoc>
        ///    <para>Writes out the specified name, ensuring it is a valid Name
        ///       according to the XML specification
        ///       (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name).</para>
        /// </devdoc>
        public abstract void WriteName(string name);

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteQualifiedName"]/*' />
        /// <devdoc>
        ///    <para>Writes out the specified namespace-qualified name by looking up the prefix
        ///       that is in scope for the given namespace.</para>
        /// </devdoc>
        public abstract void WriteQualifiedName(string localName, string ns);


        // XmlReader Helper Methods

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteAttributes"]/*' />
        /// <devdoc>
        ///    <para>Writes out all the attributes found at the current
        ///       position in the specified XmlReader.</para>
        /// </devdoc>
        public virtual void WriteAttributes(XmlReader reader, bool defattr) {

            if (null==reader) {
                throw new ArgumentNullException("reader");
            }

            if (reader.NodeType == XmlNodeType.Element || reader.NodeType == XmlNodeType.XmlDeclaration) {
                if (reader.MoveToFirstAttribute()) {
                    WriteAttributes(reader, defattr);
                    reader.MoveToElement();
                }
            }
            else if (reader.NodeType != XmlNodeType.Attribute) {
               throw new XmlException(Res.Xml_InvalidPosition, string.Empty);
            }
            else {
                do {
                    if (defattr || ! reader.IsDefault) {
                        WriteStartAttribute(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                        while (reader.ReadAttributeValue()) {
                            if (reader.NodeType == XmlNodeType.EntityReference) {
                                WriteEntityRef(reader.Name);
                            }
                            else {
                                WriteString(reader.Value);
                            }
                        }
                        WriteEndAttribute();
                    }
                }
                while (reader.MoveToNextAttribute());
            }
        }

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteNode"]/*' />
        /// <devdoc>
        ///    <para>Copies everything from the given reader to the writer,
        ///       moving the XmlReader to the end of the current element.</para>
        /// </devdoc>
        public virtual void WriteNode(XmlReader reader, bool defattr) {

            if (null==reader) {
                throw new ArgumentNullException("reader");
            }

            int d = reader.NodeType == XmlNodeType.None ? -1 : reader.Depth;
            do {
                switch (reader.NodeType) {
                    case XmlNodeType.Element:
                        WriteStartElement(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                        WriteAttributes(reader, defattr);
                        if (reader.IsEmptyElement) {
                            WriteEndElement();
                        }
                        break;
                    case XmlNodeType.Text:
                        WriteString(reader.Value);
                        break;
                    case XmlNodeType.Whitespace:
                    case XmlNodeType.SignificantWhitespace:
                        WriteWhitespace(reader.Value);
                        break;
                    case XmlNodeType.CDATA:
                        WriteCData(reader.Value);
                        break;
                    case XmlNodeType.EntityReference:
                        WriteEntityRef(reader.Name);
                        break;
                    case XmlNodeType.XmlDeclaration:
                    case XmlNodeType.ProcessingInstruction:
                        WriteProcessingInstruction(reader.Name, reader.Value);
                        break;
                    case XmlNodeType.DocumentType:
                        WriteDocType(reader.Name, reader.GetAttribute("PUBLIC"), reader.GetAttribute("SYSTEM"), reader.Value);
                        break;

                    case XmlNodeType.Comment:
                        WriteComment(reader.Value);
                        break;
                    case XmlNodeType.EndElement:
                        WriteFullEndElement();
                        break;
                }
            } while (reader.Read() && (d < reader.Depth || (d == reader.Depth && reader.NodeType == XmlNodeType.EndElement)));
        }


        // Element Helper Methods
        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteElementString"]/*' />
        /// <devdoc>
        ///    <para>Writes out an element with the specified name containing an string value.</para>
        /// </devdoc>
        public void WriteElementString(String localName, String value) {
            WriteElementString(localName,null,value);
        }

        /// <include file='doc\XmlWriter.uex' path='docs/doc[@for="XmlWriter.WriteElementString1"]/*' />
        /// <devdoc>
        ///    <para>Writes out an attribute with the specified name, namespace URI, and string value.</para>
        /// </devdoc>
        public void WriteElementString(String localName, String ns, String value) {
            WriteStartElement(localName, ns);
            if (null != value && String.Empty != value) {
                WriteString(value);
            }
            WriteEndElement();
        }

    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\bitset.cs ===
//------------------------------------------------------------------------------
// <copyright file="BitSet.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System;
    using System.Diagnostics;

    internal sealed class BitSet {
        private const int BITS_PER_UNIT = 5;
        private const int MASK = (1 << BITS_PER_UNIT) - 1;

        private int         _count;
        private int         _length;
        private UInt32[]    _bits;

        private BitSet() {}

        internal BitSet(int nBits) {
            _count = nBits;
            _length = Subscript(nBits + MASK);
            _bits = new UInt32[_length];
        }

        internal int Count {
            get { return _count; }
        }

        internal void Set(int bit) {
            int nBitSlot = Subscript(bit);
            EnsureLength(nBitSlot + 1);
            _bits[nBitSlot] |= (UInt32)(1 << (bit & MASK));
        }


        internal bool Get(int bit) {
            bool fResult = false;
            int nBitSlot = Subscript(bit);
            if (nBitSlot < _length) {
                fResult = ((_bits[nBitSlot] & (1 << (bit & MASK))) != 0);
            }
            return fResult;
        }

        internal void And(BitSet set) {
            /*
             * Need to synchronize  both this and set->
             * This might lead to deadlock if one thread grabs them in one order
             * while another thread grabs them the other order.
             * Use a trick from Doug Lea's book on concurrency,
             * somewhat complicated because BitSet overrides hashCode().
             */
            if (this == set) {
                return;
            }

            int bitsLength = _length;
            int setLength = set._length;
            int n = (bitsLength > setLength) ? setLength : bitsLength;
            for (int i = n ; i-- > 0 ;) {
                _bits[i] &= set._bits[i];
            }
            for (; n < bitsLength ; n++) {
                _bits[n] = 0;
            }
        }


        internal void Or(BitSet set) {
            if (this == set) {
                return;
            }

            int setLength = set._length;
            EnsureLength(setLength);
            for (int i = setLength; i-- > 0 ;) {
                _bits[i] |= set._bits[i];
            }
        }

        public override int GetHashCode() {
            int h = 1234;
            for (int i = _length; --i >= 0;) {
                h ^= (int)_bits[i] * (i + 1);
            }
            return(int)((h >> 32) ^ h);
        }


        public override bool Equals(Object obj) {
            // assume the same type
            if (obj != null) {
                if (this == obj) {
                    return true;
                }
                BitSet set = (BitSet) obj;

                int bitsLength = _length;
                int setLength = set._length;
                int n = (bitsLength > setLength) ? setLength : bitsLength;
                for (int i = n ; i-- > 0 ;) {
                    if (_bits[i] != set._bits[i]) {
                        return false;
                    }
                }
                if (bitsLength > n) {
                    for (int i = bitsLength ; i-- > n ;) {
                        if (_bits[i] != 0) {
                            return false;
                        }
                    }
                }
                else {
                    for (int i = setLength ; i-- > n ;) {
                        if (set._bits[i] != 0) {
                            return false;
                        }
                    }
                }
                return true;
            }
            return false;
        }

        internal BitSet Clone() {
            BitSet newset = new BitSet();
            newset._length = _length;
            newset._count = _count;
            newset._bits = (UInt32[])_bits.Clone();
            return newset;
        }

        //
        // check whether this bitset has all the bits set if the bits are also set in the passed in bitset
        //
        internal bool HasAllBits(BitSet other) {
            Debug.Assert(this != (object)other && other != null, "wrong parameter");
            Debug.Assert(_length == other._length, "not the same length.");
            for (int i = 0; i < _length; i++) {
                if ((other._bits[i] & (_bits[i] ^ other._bits[i])) != 0) {
                    return false;
                }
            }
            return true;
        }

        internal bool IsEmpty {
            get {
                UInt32 k = 0;
                for (int i = 0; i < _length; i++) {
                    k |= _bits[i];
                }
                return k == 0;
            }
        }

        private int Subscript(int bitIndex) {
            return bitIndex >> BITS_PER_UNIT;
        }

        private void EnsureLength(int nRequiredLength) {
            /* Doesn't need to be synchronized because it's an internal method. */
            if (nRequiredLength > _length) {
                /* Ask for larger of doubled size or required size */
                int request = 2 * _length;
                if (request < nRequiredLength)
                    request = nRequiredLength;
                UInt32[] newBits = new UInt32[request];
                Array.Copy(_bits, newBits, _length);
                _bits = newBits;
                _length = request;
            }
        }

    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\xmltoken.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlToken.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
namespace System.Xml {


/*
 * The XmlToken class enumerates all the xml tokens that the XmlScanner
 * recognizes.
 */
    internal sealed class XmlToken {
        public const int     NONE        = 0;
        public const int     EOF         = 1;
        public const int     TAG         = 2; // <[^?!-]
        public const int     TAGEND      = 3; // >
        public const int     EMPTYTAGEND = 4; // />
        public const int     ENDTAG      = 5; // </
        public const int     EQUALS      = 6; // =
        public const int     WHITESPACE  = 7; // whitespace
        public const int     QUOTE       = 8; // the " or ' character.
        public const int     ENDQUOTE    = 9;// the corresponding closing quote.
        public const int     TEXT        = 10;// text content or attribute value
        public const int     NAME        = 11;// name of tag or attribute
        public const int     COMMENT     = 12;// <!--
        public const int     ENDCOMMENT  = 13;// -->
        public const int     PI          = 14;// <?
        public const int     ENDPI       = 15;// ?>
        public const int     DECL        = 16;// <!
        public const int     ENTITYREF   = 17;// &xxx;
        public const int     NUMENTREF   = 18;// &#123;
        public const int     HEXENTREF   = 19;// &#x4E5;
        public const int     SEMICOLON   = 20;// ;
        public const int     XMLNS       = 21;// namespace support
        public const int     DOCTYPE     = 22;// DOCTYPE
        public const int     ELEMENT     = 23;// ELEMENT
        public const int     ATTLIST     = 24;// ATTLIST
        public const int     ENTITYDECL  = 25;// ENTITY
        public const int     NOTATION    = 26;// NOTATION
        public const int     CONDSTART   = 27;// CONDITIONALDECL START
        public const int     PUBLIC      = 28;// PUBLIC
        public const int     SYSTEM      = 29;// SYSTEM
        public const int     NDATA       = 30;// NDATA

        public const int     ANY         = 31;// ANY
        public const int     EMPTY       = 32;// EMPTY
        public const int     PCDATA      = 33;// PCDATA
        public const int     FIXED       = 34;// FIXED
        public const int     REQUIRED    = 35;// REQUIRED
        public const int     IMPLIED     = 36;// IMPLIED
        public const int     CDATA       = 37;// CDATA
        public const int     ID          = 38;// ID
        public const int     IDREF       = 39;// IDREF
        public const int     IDREFS      = 40;// IDREFS
        public const int     ENTITY      = 41;// ENTITY
        public const int     ENTITIES    = 42;// ENTITIES
        public const int     NMTOKEN     = 43;// NMTOKEN
        public const int     NMTOKENS    = 44;// NMTOKENS
        public const int     LSQB        = 45;// [
        public const int     RSQB        = 46;// ]
        public const int     QMARK       = 47;// ?
        public const int     PLUS        = 48;// +
        public const int     ASTERISK    = 49;// *
        public const int     COMMA       = 50;// ,
        public const int     OR          = 51;// |
        public const int     LPAREN      = 52;// (
        public const int     RPAREN      = 53;// )
        public const int     CDATAEND    = 54;// ]]>
        public const int     HASH        = 55;// #
        public const int     PERCENT     = 56;// %

        public const int     PENTITYREF  = 57;// %xxx;

        public const int     IGNORE      = 58;// IGNORE
        public const int     INCLUDE     = 59;// INCLUDE

        public const int     TAGWHITESPACE = 60;// TAGWHITESPACE

        public const int     LAST        = 61;

        private static String[] m_sTokenNames = new String[]
        {"NONE", "EOF", "TAG", "TAGEND", "EMPTYTAGEND", "ENDTAG", "EQUALS", "WHITESPACE", "QUOTE", "ENDQUOTE",
            "TEXT", "NAME", "COMMENT", "ENDCOMMENT", "PI", "ENDPI", "DECL", "ENTITYREF", "NUMENTREF", "HEXENTREF",
            "SEMICOLON", "XMLNS", "DOCTYPE", "ELEMENT", "ATTLIST", "ENTITY", "NOTATION", "<![", "PUBLIC", "SYSTEM",
            "NDATA", "ANY", "EMPTY", "PCDATA", "FIXED", "REQUIRED", "IMPLIED", "CDATA", "ID", "IDREF",
            "IDREFS", "ENTITY", "ENTITIES", "NMTOKEN", "NMTOKENS", "[", "]", "?", "+", "*",
            ",", "|", "(", ")", "]]>", "#", "%", "PENTITYREF", "IGNORE", "INCLUDE",
            "TAGWHITESPACE"
        };

        /*
         * Return the internal name of the token.
         */
        public static String ToString(int token) {
            if (token >= 0 && token < LAST)
                return m_sTokenNames[token];
            return "UNKNOWN("+token.ToString()+")";
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\compiledidentityconstraint.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompiledIdentityConstraint.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System.Text;
    using System.Collections;
    using System.Diagnostics;
    using System.Xml.XPath;

    internal class CompiledIdentityConstraint {
        internal XmlQualifiedName name = XmlQualifiedName.Empty;    
        private ConstraintRole role;
        private Asttree selector;
        private Asttree[] fields;
        internal XmlQualifiedName refer = XmlQualifiedName.Empty;

        public enum ConstraintRole {
            Unique,
            Key,
            Keyref
        }

        public ConstraintRole Role {
            get { return this.role; }
        }

        public Asttree Selector {
            get { return this.selector; }
        }

        public Asttree[] Fields {
            get { return this.fields; }
        }

        public static readonly CompiledIdentityConstraint Empty = new CompiledIdentityConstraint();

        private CompiledIdentityConstraint() {}

        public CompiledIdentityConstraint(XmlSchemaIdentityConstraint constraint, XmlNamespaceManager nsmgr) {
            this.name = constraint.QualifiedName;

            //public Asttree (string xPath, bool isField, XmlNamespaceManager nsmgr)
            try {
                this.selector = new Asttree(constraint.Selector.XPath, false, nsmgr);
            }
            catch (XmlSchemaException e) {
                e.SetSource(constraint.Selector);
                throw e;
            }
            XmlSchemaObjectCollection fields = constraint.Fields;
            Debug.Assert(fields.Count > 0);
            this.fields = new Asttree[fields.Count];
            for(int idxField = 0; idxField < fields.Count; idxField ++) {
                try {
                    this.fields[idxField] = new Asttree(((XmlSchemaXPath)fields[idxField]).XPath, true, nsmgr);
                }
                catch (XmlSchemaException e) {
                    e.SetSource(constraint.Fields[idxField]);
                    throw e;
                }
            }
            if (constraint is XmlSchemaUnique) {
                this.role = ConstraintRole.Unique;
            } 
            else if (constraint is XmlSchemaKey) {
                this.role = ConstraintRole.Key;
            } 
            else {             // XmlSchemaKeyref
                this.role = ConstraintRole.Keyref;
                this.refer = ((XmlSchemaKeyref)constraint).Refer; 
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\datatypeimplementation.cs ===
//------------------------------------------------------------------------------
// <copyright file="DatatypeImplementation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


namespace System.Xml.Schema {

    using System;
    using System.IO;
    using System.Collections;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Globalization;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Xml;
    using System.Xml.Serialization;
    
    internal enum XmlSchemaDatatypeVariety {
        Atomic,
        List,
        Union
    }

    internal abstract class DatatypeImplementation : XmlSchemaDatatype {

        internal enum XmlSchemaWhiteSpace {
            Preserve,
            Replace,
            Collapse,
        }

        [Flags]
        internal enum RestrictionFlags {
            Length              = 0x0001,
            MinLength           = 0x0002,
            MaxLength           = 0x0004,
            Pattern             = 0x0008,
            Enumeration         = 0x0010,
            WhiteSpace          = 0x0020,
            MaxInclusive        = 0x0040,
            MaxExclusive        = 0x0080,
            MinInclusive        = 0x0100,
            MinExclusive        = 0x0200,
            TotalDigits         = 0x0400,
            FractionDigits      = 0x0800,
        }

        protected class RestrictionFacets {
            public int Length;
            public int MinLength;
            public int MaxLength;
            public ArrayList Patterns;
            public ArrayList Enumeration;
            public XmlSchemaWhiteSpace WhiteSpace;
            public object MaxInclusive;
            public object MaxExclusive;
            public object MinInclusive;
            public object MinExclusive;
            public int TotalDigits;
            public int FractionDigits;
            public RestrictionFlags Flags = 0;
            public RestrictionFlags FixedFlags = 0;
        }

        private Type valueType;
        private XmlSchemaDatatypeVariety variety = XmlSchemaDatatypeVariety.Atomic;
        private RestrictionFacets restriction = null;
        private int minListSize = 0;
        private DatatypeImplementation baseType = null;
        private DatatypeImplementation memberType = null;

        internal new static DatatypeImplementation AnyType { get { return c_anyType; } }

        internal new static DatatypeImplementation AnySimpleType { get { return c_anySimpleType; } }

        internal new static DatatypeImplementation FromXmlTokenizedType(XmlTokenizedType token) {
            return c_tokenizedTypes[(int)token];
        }

        internal new static DatatypeImplementation FromXmlTokenizedTypeXsd(XmlTokenizedType token) {
            return c_tokenizedTypesXsd[(int)token];
        }

        internal new static DatatypeImplementation FromXdrName(string name) {
            int i = Array.BinarySearch(c_XdrTypes, name, InvariantComparer.Default);
            return i < 0 ? null : (DatatypeImplementation)c_XdrTypes[i];
        }

        internal new static DatatypeImplementation FromTypeName(string name) {
            int i = Array.BinarySearch(c_XsdTypes, name, InvariantComparer.Default);
            return i < 0 ? null : (DatatypeImplementation)c_XsdTypes[i];
        }

        internal new DatatypeImplementation DeriveByRestriction(XmlSchemaObjectCollection facets, XmlNameTable nameTable) {
            DatatypeImplementation dt = (DatatypeImplementation)MemberwiseClone();
            dt.restriction = ConstructRestriction(facets, nameTable);
            dt.baseType = this;
            return dt;
        }

        internal new DatatypeImplementation DeriveByList() {
            return DeriveByList(0);
        }

        internal DatatypeImplementation DeriveByList(int minSize) {
            if (variety == XmlSchemaDatatypeVariety.List) {
                throw new XmlSchemaException(Res.Sch_ListFromNonatomic);
            }
            else if (variety == XmlSchemaDatatypeVariety.Union && !((Datatype_union)this).HasAtomicMembers()) {
                throw new XmlSchemaException(Res.Sch_ListFromNonatomic);
            }

            DatatypeImplementation dt = (DatatypeImplementation)MemberwiseClone();
            dt.valueType = ListValueType;
            dt.variety = XmlSchemaDatatypeVariety.List;
            dt.minListSize = minSize;
            dt.restriction = null;
            dt.baseType = this;
            dt.memberType = this;
            return dt;
        }

        internal new static DatatypeImplementation DeriveByUnion(XmlSchemaDatatype[] types) {
            foreach(DatatypeImplementation dt1 in types) {
                if (dt1.variety == XmlSchemaDatatypeVariety.Union) {
                    throw new XmlSchemaException(Res.Sch_UnionFromUnion);
                }
            }
            DatatypeImplementation dt = new Datatype_union(types);
            dt.variety = XmlSchemaDatatypeVariety.Union;
            return dt;
        }

        internal new virtual void VerifySchemaValid(XmlSchema schema, XmlSchemaObject caller) {/*noop*/}

        internal new bool IsDerivedFrom(XmlSchemaDatatype dtype) {
            if (variety == XmlSchemaDatatypeVariety.Union) {
                return ((Datatype_union)this).IsDerivedFromUnion(dtype);
            }
            else if (((DatatypeImplementation)dtype).baseType == null) {
                Type derivedType = this.GetType();
                Type baseType = dtype.GetType();
                return baseType == derivedType || derivedType.IsSubclassOf(baseType);
            }
            else {
                for(DatatypeImplementation dt = this; dt != null; dt = dt.baseType) {
                    if (dt == dtype) {
                        return true;
                    }
                }
            }
            return false;
        }

        static readonly char[] whitespace = new char[] {' ', '\t', '\n', '\r'};
        public override object ParseValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\tSchemaDatatype.ParseValue(\"{0}\")", s));
            try {
                // before parsing
                if (variety == XmlSchemaDatatypeVariety.List || IsWhitespaceCollapseFixed) {
                    s = s.Trim();
                }
                else if (variety == XmlSchemaDatatypeVariety.Atomic && restriction != null && (restriction.Flags & RestrictionFlags.WhiteSpace) != 0) {
                    if (restriction.WhiteSpace == XmlSchemaWhiteSpace.Replace) {
                        s = XmlComplianceUtil.CDataAttributeValueNormalization(s);
                    }
                    else if (restriction.WhiteSpace == XmlSchemaWhiteSpace.Collapse) {
                        s = XmlComplianceUtil.NotCDataAttributeValueNormalization(s);
                    }
                }

                if (restriction != null && (restriction.Flags & RestrictionFlags.Pattern) != 0) {
                    foreach(Regex regex in restriction.Patterns) {
                        if (!regex.IsMatch(s)) {
                            throw new XmlSchemaException(Res.Sch_PatternConstraintFailed);
                        }

                    }
                }
                if (variety == XmlSchemaDatatypeVariety.Atomic) {
                    object value = ParseAtomicValue(s, nameTable, nsmgr);
                    if (restriction != null) {
                        ConstrainAtomicValue(restriction, value);
                    }
                    return value;
                }
                else if (variety == XmlSchemaDatatypeVariety.List) {
                    // Parse string
                    ArrayList values = new ArrayList();
                    foreach (string s1 in s.Split(whitespace)) {
                        if (s1 != string.Empty) {
                            values.Add(ParseAtomicValue(s1, nameTable, nsmgr));
                        }
                    }
                    if (values.Count < minListSize) {
                        throw new XmlSchemaException(Res.Sch_EmptyAttributeValue);
                    }

                    if (restriction != null) {
                        ConstrainList(restriction, values);
                    }
                    if (memberType.restriction != null) {
                        foreach(object value in values) {
                            ConstrainAtomicValue(memberType.restriction, value);
                        }
                    }
                    object array = values.ToArray(AtomicValueType);
                    Debug.Assert(array.GetType() == ListValueType);
                    return array;
                }
                else {  // variety == XmlSchemaDatatypeVariety.Union
                    Debug.Assert(this is Datatype_union);
                    DatatypeImplementation dtCorrect;
                    object value = ((Datatype_union)this).ParseUnion(s, nameTable, nsmgr, out dtCorrect);
                    if (restriction != null && (restriction.Flags & RestrictionFlags.Enumeration) != 0) {
                        if(!dtCorrect.MatchEnumeration(value, restriction.Enumeration)) {
                            throw new XmlSchemaException(Res.Sch_EnumerationConstraintFailed);
                        }
                    }
                    return value;
                }
            }
            catch (XmlSchemaException e) {
                throw e;
            }
            catch (Exception) {
                throw new XmlSchemaException(Res.Sch_InvalidValue, s);
            }
        }

        internal new bool IsEqual(object o1, object o2) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\tSchemaDatatype.IsEqual({0}, {1})", o1, o2));
            return Compare(o1, o2) == 0;
        }

        public override XmlTokenizedType TokenizedType { get { return XmlTokenizedType.None;}}

        public override Type ValueType { get { return valueType; }}

        internal new XmlSchemaDatatypeVariety Variety { get { return variety;}}

        protected RestrictionFacets Restriction { get { return restriction; }}

        protected DatatypeImplementation Base { get { return baseType; }}

        protected abstract Type AtomicValueType { get; }

        protected abstract Type ListValueType { get; }

        protected abstract RestrictionFlags ValidRestrictionFlags { get; }

        protected abstract bool IsWhitespaceCollapseFixed { get; }

        protected abstract int LengthOf(object value);

        protected abstract int Compare(object value1, object value2);

        protected abstract object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr);

        protected DatatypeImplementation() {
            valueType = AtomicValueType;
        }

        // all our types
        static private readonly DatatypeImplementation c_anyType             = new Datatype_anyType();
        static private readonly DatatypeImplementation c_anySimpleType       = new Datatype_anySimpleType();
        static private readonly DatatypeImplementation c_anyURI              = new Datatype_anyURI();
        static private readonly DatatypeImplementation c_base64Binary        = new Datatype_base64Binary();
        static private readonly DatatypeImplementation c_boolean             = new Datatype_boolean();
        static private readonly DatatypeImplementation c_byte                = new Datatype_byte();
        static private readonly DatatypeImplementation c_char                = new Datatype_char(); // XDR
        static private readonly DatatypeImplementation c_date                = new Datatype_date();
        static private readonly DatatypeImplementation c_dateTime            = new Datatype_dateTime();
        static private readonly DatatypeImplementation c_dateTimeNoTz        = new Datatype_dateTimeNoTimeZone(); // XDR
        static private readonly DatatypeImplementation c_dateTimeTz          = new Datatype_dateTimeTimeZone(); // XDR
        static private readonly DatatypeImplementation c_day                 = new Datatype_day();
        static private readonly DatatypeImplementation c_decimal             = new Datatype_decimal();
        static private readonly DatatypeImplementation c_double              = new Datatype_double();
        static private readonly DatatypeImplementation c_doubleXdr           = new Datatype_doubleXdr();     // XDR
        static private readonly DatatypeImplementation c_duration            = new Datatype_duration();
        static private readonly DatatypeImplementation c_ENTITY              = new Datatype_ENTITY();
        static private readonly DatatypeImplementation c_ENTITIES            = c_ENTITY.DeriveByList(1);
        static private readonly DatatypeImplementation c_ENUMERATION         = new Datatype_ENUMERATION(); // XDR
        static private readonly DatatypeImplementation c_fixed               = new Datatype_fixed();
        static private readonly DatatypeImplementation c_float               = new Datatype_float();
        static private readonly DatatypeImplementation c_floatXdr            = new Datatype_floatXdr(); // XDR
        static private readonly DatatypeImplementation c_hexBinary           = new Datatype_hexBinary();
        static private readonly DatatypeImplementation c_ID                  = new Datatype_ID();
        static private readonly DatatypeImplementation c_IDREF               = new Datatype_IDREF();
        static private readonly DatatypeImplementation c_IDREFS              = c_IDREF.DeriveByList(1);
        static private readonly DatatypeImplementation c_int                 = new Datatype_int();
        static private readonly DatatypeImplementation c_integer             = new Datatype_integer();
        static private readonly DatatypeImplementation c_language            = new Datatype_language();
        static private readonly DatatypeImplementation c_long                = new Datatype_long();
        static private readonly DatatypeImplementation c_month               = new Datatype_month();
        static private readonly DatatypeImplementation c_monthDay            = new Datatype_monthDay();
        static private readonly DatatypeImplementation c_Name                = new Datatype_Name();
        static private readonly DatatypeImplementation c_NCName              = new Datatype_NCName();
        static private readonly DatatypeImplementation c_negativeInteger     = new Datatype_negativeInteger();
        static private readonly DatatypeImplementation c_NMTOKEN             = new Datatype_NMTOKEN();
        static private readonly DatatypeImplementation c_NMTOKENS            = c_NMTOKEN.DeriveByList(1);
        static private readonly DatatypeImplementation c_nonNegativeInteger  = new Datatype_nonNegativeInteger();
        static private readonly DatatypeImplementation c_nonPositiveInteger  = new Datatype_nonPositiveInteger();
        static private readonly DatatypeImplementation c_normalizedString    = new Datatype_normalizedString();
        static private readonly DatatypeImplementation c_NOTATION            = new Datatype_NOTATION();
        static private readonly DatatypeImplementation c_positiveInteger     = new Datatype_positiveInteger();
        static private readonly DatatypeImplementation c_QName               = new Datatype_QName();
        static private readonly DatatypeImplementation c_QNameXdr            = new Datatype_QNameXdr(); //XDR
        static private readonly DatatypeImplementation c_short               = new Datatype_short();
        static private readonly DatatypeImplementation c_string              = new Datatype_string();
        static private readonly DatatypeImplementation c_time                = new Datatype_time();
        static private readonly DatatypeImplementation c_timeNoTz            = new Datatype_timeNoTimeZone(); // XDR
        static private readonly DatatypeImplementation c_timeTz              = new Datatype_timeTimeZone(); // XDR
        static private readonly DatatypeImplementation c_token               = new Datatype_token();
        static private readonly DatatypeImplementation c_unsignedByte        = new Datatype_unsignedByte();
        static private readonly DatatypeImplementation c_unsignedInt         = new Datatype_unsignedInt();
        static private readonly DatatypeImplementation c_unsignedLong        = new Datatype_unsignedLong();
        static private readonly DatatypeImplementation c_unsignedShort       = new Datatype_unsignedShort();
        static private readonly DatatypeImplementation c_uuid                = new Datatype_uuid(); // XDR
        static private readonly DatatypeImplementation c_year                = new Datatype_year();
        static private readonly DatatypeImplementation c_yearMonth           = new Datatype_yearMonth();

        private class SchemaDatatypeMap : IComparable {
            string name;
            DatatypeImplementation type;
            internal SchemaDatatypeMap(string name, DatatypeImplementation type) {
                this.name = name;
                this.type = type;
            }
            public static explicit operator DatatypeImplementation(SchemaDatatypeMap sdm) { return sdm.type; }
            public int CompareTo(object obj) { return string.Compare(name, (string)obj, false, CultureInfo.InvariantCulture); }
        }


        private static readonly DatatypeImplementation[] c_tokenizedTypes = {
            c_string,               // CDATA
            c_ID,                   // ID
            c_IDREF,                // IDREF
            c_IDREFS,               // IDREFS
            c_ENTITY,               // ENTITY
            c_ENTITIES,             // ENTITIES
            c_NMTOKEN,              // NMTOKEN
            c_NMTOKENS,             // NMTOKENS
            c_NOTATION,             // NOTATION
            c_ENUMERATION,          // ENUMERATION
            c_QNameXdr,             // QName
            c_NCName,               // NCName
            null
        };

        private static readonly DatatypeImplementation[] c_tokenizedTypesXsd = {
            c_string,               // CDATA
            c_ID,                   // ID
            c_IDREF,                // IDREF
            c_IDREFS,               // IDREFS
            c_ENTITY,               // ENTITY
            c_ENTITIES,             // ENTITIES
            c_NMTOKEN,              // NMTOKEN
            c_NMTOKENS,             // NMTOKENS
            c_NOTATION,             // NOTATION
            c_ENUMERATION,          // ENUMERATION
            c_QName,                // QName
            c_NCName,               // NCName
            null
        };

        private static readonly SchemaDatatypeMap[] c_XdrTypes = {
            new SchemaDatatypeMap("bin.base64",          c_base64Binary),
            new SchemaDatatypeMap("bin.hex",             c_hexBinary),
            new SchemaDatatypeMap("boolean",             c_boolean),
            new SchemaDatatypeMap("char",                c_char),
            new SchemaDatatypeMap("date",                c_date),
            new SchemaDatatypeMap("dateTime",            c_dateTimeNoTz),
            new SchemaDatatypeMap("dateTime.tz",         c_dateTimeTz),
            new SchemaDatatypeMap("decimal",             c_decimal),
            new SchemaDatatypeMap("entities",            c_ENTITIES),
            new SchemaDatatypeMap("entity",              c_ENTITY),
            new SchemaDatatypeMap("enumeration",         c_ENUMERATION),
            new SchemaDatatypeMap("fixed.14.4",          c_fixed),
            new SchemaDatatypeMap("float",               c_doubleXdr),
            new SchemaDatatypeMap("float.ieee.754.32",   c_floatXdr),
            new SchemaDatatypeMap("float.ieee.754.64",   c_doubleXdr),
            new SchemaDatatypeMap("i1",                  c_byte),
            new SchemaDatatypeMap("i2",                  c_short),
            new SchemaDatatypeMap("i4",                  c_int),
            new SchemaDatatypeMap("i8",                  c_long),
            new SchemaDatatypeMap("id",                  c_ID),
            new SchemaDatatypeMap("idref",               c_IDREF),
            new SchemaDatatypeMap("idrefs",              c_IDREFS),
            new SchemaDatatypeMap("int",                 c_int),
            new SchemaDatatypeMap("nmtoken",             c_NMTOKEN),
            new SchemaDatatypeMap("nmtokens",            c_NMTOKENS),
            new SchemaDatatypeMap("notation",            c_NOTATION),
            new SchemaDatatypeMap("number",              c_doubleXdr),
            new SchemaDatatypeMap("r4",                  c_floatXdr),
            new SchemaDatatypeMap("r8",                  c_doubleXdr),
            new SchemaDatatypeMap("string",              c_string),
            new SchemaDatatypeMap("time",                c_timeNoTz),
            new SchemaDatatypeMap("time.tz",             c_timeTz),
            new SchemaDatatypeMap("ui1",                 c_unsignedByte),
            new SchemaDatatypeMap("ui2",                 c_unsignedShort),
            new SchemaDatatypeMap("ui4",                 c_unsignedInt),
            new SchemaDatatypeMap("ui8",                 c_unsignedLong),
            new SchemaDatatypeMap("uri",                 c_anyURI),
            new SchemaDatatypeMap("uuid",                c_uuid)
        };

        private static readonly SchemaDatatypeMap[] c_XsdTypes = {
            new SchemaDatatypeMap("anyType",            c_anyType),
            new SchemaDatatypeMap("anySimpleType",      c_anySimpleType),
            new SchemaDatatypeMap("anyURI",             c_anyURI),
            new SchemaDatatypeMap("base64Binary",       c_base64Binary),
            new SchemaDatatypeMap("boolean",            c_boolean),
            new SchemaDatatypeMap("byte",               c_byte),
            new SchemaDatatypeMap("date",               c_date),
            new SchemaDatatypeMap("dateTime",           c_dateTime),
            new SchemaDatatypeMap("decimal",            c_decimal),
            new SchemaDatatypeMap("double",             c_double),
            new SchemaDatatypeMap("duration",           c_duration),
            new SchemaDatatypeMap("ENTITIES",           c_ENTITIES),
            new SchemaDatatypeMap("ENTITY",             c_ENTITY),
            new SchemaDatatypeMap("float",              c_float),
            new SchemaDatatypeMap("gDay",               c_day),
            new SchemaDatatypeMap("gMonth",             c_month),
            new SchemaDatatypeMap("gMonthDay",          c_monthDay),
            new SchemaDatatypeMap("gYear",              c_year),
            new SchemaDatatypeMap("gYearMonth",         c_yearMonth),
            new SchemaDatatypeMap("hexBinary",          c_hexBinary),
            new SchemaDatatypeMap("ID",                 c_ID),
            new SchemaDatatypeMap("IDREF",              c_IDREF),
            new SchemaDatatypeMap("IDREFS",             c_IDREFS),
            new SchemaDatatypeMap("int",                c_int),
            new SchemaDatatypeMap("integer",            c_integer),
            new SchemaDatatypeMap("language",           c_language),
            new SchemaDatatypeMap("long",               c_long),
            new SchemaDatatypeMap("Name",               c_Name),
            new SchemaDatatypeMap("NCName",             c_NCName),
            new SchemaDatatypeMap("negativeInteger",    c_negativeInteger),
            new SchemaDatatypeMap("NMTOKEN",            c_NMTOKEN),
            new SchemaDatatypeMap("NMTOKENS",           c_NMTOKENS),
            new SchemaDatatypeMap("nonNegativeInteger", c_nonNegativeInteger),
            new SchemaDatatypeMap("nonPositiveInteger", c_nonPositiveInteger),
            new SchemaDatatypeMap("normalizedString",   c_normalizedString),
            new SchemaDatatypeMap("NOTATION",           c_NOTATION),
            new SchemaDatatypeMap("positiveInteger",    c_positiveInteger),
            new SchemaDatatypeMap("QName",              c_QName),
            new SchemaDatatypeMap("short",              c_short),
            new SchemaDatatypeMap("string",             c_string),
            new SchemaDatatypeMap("time",               c_time),
            new SchemaDatatypeMap("token",              c_token),
            new SchemaDatatypeMap("unsignedByte",       c_unsignedByte),
            new SchemaDatatypeMap("unsignedInt",        c_unsignedInt),
            new SchemaDatatypeMap("unsignedLong",       c_unsignedLong),
            new SchemaDatatypeMap("unsignedShort",      c_unsignedShort),
        };

        private RestrictionFacets ConstructRestriction(XmlSchemaObjectCollection facets, XmlNameTable nameTable) {
            RestrictionFacets restriction = new RestrictionFacets();
            RestrictionFlags thisFlags = this.restriction != null ? this.restriction.Flags : 0;
            RestrictionFlags fixedFlags = this.restriction != null ? this.restriction.FixedFlags : 0;
            RestrictionFlags validRestrictionFlags = ValidRestrictionFlags;
            if (variety == XmlSchemaDatatypeVariety.List) {
                validRestrictionFlags = RestrictionFlags.Length|RestrictionFlags.MinLength|RestrictionFlags.MaxLength|RestrictionFlags.Enumeration|RestrictionFlags.WhiteSpace;
                if (minListSize == 0) {
                    validRestrictionFlags |= RestrictionFlags.Pattern;
                }
            }
            StringBuilder regStr = new StringBuilder();
            XmlSchemaFacet pattern_facet = null;
            bool firstP = true;

            foreach (XmlSchemaFacet facet in facets) {
                if (facet.Value == null) {
                    throw new XmlSchemaException(Res.Sch_InvalidFacet, facet);
                }
                XmlNamespaceManager nsmgr = new SchemaNamespaceManager(facet);
                if (facet is XmlSchemaLengthFacet) {
                    CheckFixedFlag(facet, fixedFlags, RestrictionFlags.Length);
                    CheckProhibitedFlag(facet, validRestrictionFlags,  RestrictionFlags.Length, Res.Sch_LengthFacetProhibited);
                    CheckDupFlag(facet, restriction, RestrictionFlags.Length, Res.Sch_DupLengthFacet);
                    try {
                        restriction.Length = (int)(decimal)c_nonNegativeInteger.ParseAtomicValue(facet.Value, null, null);
                    }
                    catch (XmlSchemaException xse) {
                        if (xse.SourceSchemaObject == null) {
                            xse.SetSource(facet);
                        }
                        throw xse;
                    }
                    catch (Exception e) {
                        throw new XmlSchemaException(Res.Sch_LengthFacetInvalid, e.Message, facet);
                    }
                    if ((thisFlags & RestrictionFlags.Length) != 0) {
                        if (this.restriction.Length < restriction.Length) {
                            throw new XmlSchemaException(Res.Sch_LengthGtBaseLength, facet);
                        }
                    }
                    SetFlag(restriction, facet, RestrictionFlags.Length);
                }
                else if (facet is XmlSchemaMinLengthFacet) {
                    CheckFixedFlag(facet, fixedFlags, RestrictionFlags.MinLength);
                    CheckProhibitedFlag(facet, validRestrictionFlags,  RestrictionFlags.MinLength, Res.Sch_MinLengthFacetProhibited);
                    CheckDupFlag(facet, restriction, RestrictionFlags.MinLength, Res.Sch_DupMinLengthFacet);
                    try {
                        restriction.MinLength = (int)(decimal)c_nonNegativeInteger.ParseAtomicValue(facet.Value, null, null);
                    }
                    catch (XmlSchemaException xse) {
                        if (xse.SourceSchemaObject == null) {
                            xse.SetSource(facet);
                        }
                        throw xse;
                    }
                    catch (Exception e) {
                        throw new XmlSchemaException(Res.Sch_MinLengthFacetInvalid, e.Message, facet);
                    }
                    if ((thisFlags & RestrictionFlags.MinLength) != 0) {
                        if (this.restriction.MinLength > restriction.MinLength) {
                            throw new XmlSchemaException(Res.Sch_MinLengthGtBaseMinLength, facet);
                        }
                    }
                    SetFlag(restriction, facet, RestrictionFlags.MinLength);
                }
                else if (facet is XmlSchemaMaxLengthFacet) {
                    CheckFixedFlag(facet, fixedFlags, RestrictionFlags.MaxLength);
                    CheckProhibitedFlag(facet, validRestrictionFlags,  RestrictionFlags.MaxLength, Res.Sch_MaxLengthFacetProhibited);
                    CheckDupFlag(facet, restriction, RestrictionFlags.MaxLength, Res.Sch_DupMaxLengthFacet);
                    try {
                        restriction.MaxLength = (int)(decimal)c_nonNegativeInteger.ParseAtomicValue(facet.Value, null, null);
                    }
                    catch (XmlSchemaException xse) {
                        if (xse.SourceSchemaObject == null) {
                            xse.SetSource(facet);
                        }
                        throw xse;
                    }
                    catch (Exception e) {
                        throw new XmlSchemaException(Res.Sch_MaxLengthFacetInvalid, e.Message, facet);
                    }
                    if ((thisFlags & RestrictionFlags.MaxLength) != 0) {
                        if (this.restriction.MaxLength < restriction.MaxLength) {
                            throw new XmlSchemaException(Res.Sch_MaxLengthGtBaseMaxLength, facet);
                        }
                    }
                    SetFlag(restriction, facet, RestrictionFlags.MaxLength);
                }
                else if (facet is XmlSchemaPatternFacet) {
                    CheckProhibitedFlag(facet, validRestrictionFlags,  RestrictionFlags.Pattern, Res.Sch_PatternFacetProhibited);
                    if(firstP == true) {
                        regStr.Append("(");
                        regStr.Append(facet.Value);
                        pattern_facet = new XmlSchemaPatternFacet();
                        pattern_facet = facet;
                        firstP = false;
                    }
                    else {
                        regStr.Append(")|(");
                        regStr.Append(facet.Value);
                    }
                    SetFlag(restriction, facet, RestrictionFlags.Pattern);
                }
                else if (facet is XmlSchemaEnumerationFacet) {
                    CheckProhibitedFlag(facet, validRestrictionFlags,  RestrictionFlags.Enumeration, Res.Sch_EnumerationFacetProhibited);
                    if (restriction.Enumeration == null) {
                        restriction.Enumeration = new ArrayList();
                    }
                    try {
                        //restriction.Enumeration.Add(ParseAtomicValue(facet.Value, nameTable, nsmgr));
                        restriction.Enumeration.Add(ParseValue(facet.Value, nameTable, nsmgr));
                    }
                    catch (XmlSchemaException xse) {
                        if (xse.SourceSchemaObject == null) {
                            xse.SetSource(facet);
                        }
                        throw xse;
                    }
                    catch (Exception e) {
                        throw new XmlSchemaException(Res.Sch_EnumerationFacetInvalid, e.Message, facet);
                    }
                    SetFlag(restriction, facet, RestrictionFlags.Enumeration);
                }
                else if (facet is XmlSchemaWhiteSpaceFacet) {
                    CheckFixedFlag(facet, fixedFlags, RestrictionFlags.WhiteSpace);
                    CheckProhibitedFlag(facet, validRestrictionFlags,  RestrictionFlags.WhiteSpace, Res.Sch_WhiteSpaceFacetProhibited);
                    CheckDupFlag(facet, restriction, RestrictionFlags.WhiteSpace, Res.Sch_DupWhiteSpaceFacet);
                    if (facet.Value == "preserve") {
                        restriction.WhiteSpace = XmlSchemaWhiteSpace.Preserve;
                    }
                    else if (facet.Value == "replace") {
                        restriction.WhiteSpace = XmlSchemaWhiteSpace.Replace;
                    }
                    else if (facet.Value == "collapse") {
                        restriction.WhiteSpace = XmlSchemaWhiteSpace.Collapse;
                    }
                    else {
                        throw new XmlSchemaException(Res.Sch_InvalidWhiteSpace, facet.Value, facet);
                    }
                    if (IsWhitespaceCollapseFixed && (restriction.WhiteSpace != XmlSchemaWhiteSpace.Collapse)) {
                        throw new XmlSchemaException(Res.Sch_InvalidWhiteSpace, facet.Value, facet);
                    }
                    if ((thisFlags & RestrictionFlags.WhiteSpace) != 0) {
                        if (
                            this.restriction.WhiteSpace == XmlSchemaWhiteSpace.Collapse &&
                            (restriction.WhiteSpace == XmlSchemaWhiteSpace.Replace || restriction.WhiteSpace == XmlSchemaWhiteSpace.Preserve)
                        ) {
                            throw new XmlSchemaException(Res.Sch_WhiteSpaceRestriction1, facet);
                        }
                        if (
                            this.restriction.WhiteSpace == XmlSchemaWhiteSpace.Replace &&
                            restriction.WhiteSpace == XmlSchemaWhiteSpace.Preserve
                        ) {
                            throw new XmlSchemaException(Res.Sch_WhiteSpaceRestriction2, facet);
                        }
                    }
                    SetFlag(restriction, facet, RestrictionFlags.WhiteSpace);
                }
                else if (facet is XmlSchemaMaxInclusiveFacet) {
                    CheckFixedFlag(facet, fixedFlags, RestrictionFlags.Length);
                    CheckProhibitedFlag(facet, validRestrictionFlags,  RestrictionFlags.MaxInclusive, Res.Sch_MaxInclusiveFacetProhibited);
                    CheckDupFlag(facet, restriction, RestrictionFlags.MaxInclusive, Res.Sch_DupMaxInclusiveFacet);
                    try {
                        restriction.MaxInclusive = ParseAtomicValue(facet.Value, nameTable, nsmgr);
                    }
                    catch (XmlSchemaException xse) {
                        if (xse.SourceSchemaObject == null) {
                            xse.SetSource(facet);
                        }
                        throw xse;
                    }
                    catch (Exception e) {
                        throw new XmlSchemaException(Res.Sch_MaxInclusiveFacetInvalid, e.Message, facet);
                    }
                    CheckValue(restriction.MaxInclusive, facet, thisFlags);
                    SetFlag(restriction, facet, RestrictionFlags.MaxInclusive);
                }
                else if (facet is XmlSchemaMaxExclusiveFacet) {
                    CheckFixedFlag(facet, fixedFlags, RestrictionFlags.MaxExclusive);
                    CheckProhibitedFlag(facet, validRestrictionFlags,  RestrictionFlags.MaxExclusive, Res.Sch_MaxExclusiveFacetProhibited);
                    CheckDupFlag(facet, restriction, RestrictionFlags.MaxExclusive, Res.Sch_DupMaxExclusiveFacet);
                    try {
                        restriction.MaxExclusive = ParseAtomicValue(facet.Value, nameTable, nsmgr);
                    }
                    catch (XmlSchemaException xse) {
                        if (xse.SourceSchemaObject == null) {
                            xse.SetSource(facet);
                        }
                        throw xse;
                    }
                    catch (Exception e) {
                        throw new XmlSchemaException(Res.Sch_MaxExclusiveFacetInvalid, e.Message, facet);
                    }
                    CheckValue(restriction.MaxExclusive, facet, thisFlags);
                    SetFlag(restriction, facet, RestrictionFlags.MaxExclusive);
                }
                else if (facet is XmlSchemaMinInclusiveFacet) {
                    CheckFixedFlag(facet, fixedFlags, RestrictionFlags.MinInclusive);
                    CheckProhibitedFlag(facet, validRestrictionFlags,  RestrictionFlags.MinInclusive, Res.Sch_MinInclusiveFacetProhibited);
                    CheckDupFlag(facet, restriction, RestrictionFlags.MinInclusive, Res.Sch_DupMinInclusiveFacet);
                    try {
                        restriction.MinInclusive = ParseAtomicValue(facet.Value, nameTable, nsmgr);
                    }
                    catch (XmlSchemaException xse) {
                        if (xse.SourceSchemaObject == null) {
                            xse.SetSource(facet);
                        }
                        throw xse;
                    }
                    catch (Exception e) {
                        throw new XmlSchemaException(Res.Sch_MinInclusiveFacetInvalid, e.Message, facet);
                    }
                    CheckValue(restriction.MinInclusive, facet, thisFlags);
                    SetFlag(restriction, facet, RestrictionFlags.MinInclusive);
                }
                else if (facet is XmlSchemaMinExclusiveFacet) {
                    CheckFixedFlag(facet, fixedFlags, RestrictionFlags.MinExclusive);
                    CheckProhibitedFlag(facet, validRestrictionFlags,  RestrictionFlags.MinExclusive, Res.Sch_MinExclusiveFacetProhibited);
                    CheckDupFlag(facet, restriction, RestrictionFlags.MinExclusive, Res.Sch_DupMinExclusiveFacet);
                    try {
                        restriction.MinExclusive = ParseAtomicValue(facet.Value, nameTable, nsmgr);
                    }
                    catch (XmlSchemaException xse) {
                        if (xse.SourceSchemaObject == null) {
                            xse.SetSource(facet);
                        }
                        throw xse;
                    }
                    catch (Exception e) {
                        throw new XmlSchemaException(Res.Sch_MinExclusiveFacetInvalid, e.Message, facet);
                    }
                    CheckValue(restriction.MinExclusive, facet, thisFlags);
                    SetFlag(restriction, facet, RestrictionFlags.MinExclusive);
                }
                else if (facet is XmlSchemaTotalDigitsFacet) {
                    CheckFixedFlag(facet, fixedFlags, RestrictionFlags.TotalDigits);
                    CheckProhibitedFlag(facet, validRestrictionFlags,  RestrictionFlags.TotalDigits, Res.Sch_TotalDigitsFacetProhibited);
                    CheckDupFlag(facet, restriction, RestrictionFlags.TotalDigits, Res.Sch_DupTotalDigitsFacet);
                    try {
                        restriction.TotalDigits = (int)(decimal)c_positiveInteger.ParseAtomicValue(facet.Value, null, null);
                    }
                    catch (XmlSchemaException xse) {
                        if (xse.SourceSchemaObject == null) {
                            xse.SetSource(facet);
                        }
                        throw xse;
                    }
                    catch (Exception e) {
                        throw new XmlSchemaException(Res.Sch_TotalDigitsFacetInvalid, e.Message, facet);
                    }
                    if ((thisFlags & RestrictionFlags.TotalDigits) != 0) {
                        if(restriction.TotalDigits > this.restriction.TotalDigits) {
                            throw new XmlSchemaException(Res.Sch_TotalDigitsMismatch);
                        }
                    }
                    SetFlag(restriction, facet, RestrictionFlags.TotalDigits);
                }
                else if (facet is XmlSchemaFractionDigitsFacet) {
                    CheckFixedFlag(facet, fixedFlags, RestrictionFlags.FractionDigits);
                    CheckProhibitedFlag(facet, validRestrictionFlags,  RestrictionFlags.FractionDigits, Res.Sch_FractionDigitsFacetProhibited);
                    CheckDupFlag(facet, restriction, RestrictionFlags.FractionDigits, Res.Sch_DupFractionDigitsFacet);
                    try {
                        restriction.FractionDigits = (int)(decimal)c_nonNegativeInteger.ParseAtomicValue(facet.Value, null, null);
                        if ((restriction.FractionDigits != 0) && (this.GetType() != typeof(Datatype_decimal))) {
                            throw new XmlSchemaException(Res.Sch_FractionDigitsNotOnDecimal, facet);
                        }
                    }
                    catch (XmlSchemaException xse) {
                        if (xse.SourceSchemaObject == null) {
                            xse.SetSource(facet);
                        }
                        throw xse;
                    }
                    catch (Exception e) {
                        throw new XmlSchemaException(Res.Sch_FractionDigitsFacetInvalid, e.Message, facet);
                    }
                    SetFlag(restriction, facet, RestrictionFlags.FractionDigits);
                }
                else {
                    throw new XmlSchemaException(Res.Sch_UnknownFacet, facet);
                }

            }

            //If facet is XMLSchemaPattern, then the String built inside the loop
            //needs to be converted to a RegEx

            if(firstP == false) {
                if (restriction.Patterns == null) {
                    restriction.Patterns = new ArrayList();
                }
                try {
                    regStr.Append(")");
                    string tempStr = regStr.ToString();
                    if(tempStr.IndexOf("|") != -1) {
                        regStr.Insert(0,"(");
                        regStr.Append(")");
                    }
                   restriction.Patterns.Add(new Regex(Preprocess(regStr.ToString()), RegexOptions.None));

                }catch (Exception e) {
                    throw new XmlSchemaException(Res.Sch_PatternFacetInvalid, e.Message, pattern_facet);
                }
            }

            //Moved here so that they are not allowed on the same type but allowed on derived types.
            if (
                (restriction.Flags & RestrictionFlags.MaxInclusive) != 0 &&
                (restriction.Flags & RestrictionFlags.MaxExclusive) != 0
            ) {
                throw new XmlSchemaException(Res.Sch_MaxInclusiveExclusive);
            }
            if (
                (restriction.Flags & RestrictionFlags.MinInclusive) != 0 &&
                (restriction.Flags & RestrictionFlags.MinExclusive) != 0
            ) {
                throw new XmlSchemaException(Res.Sch_MinInclusiveExclusive);
            }

            // Copy from the base
            if (
                (restriction.Flags & RestrictionFlags.Length) == 0 &&
                (thisFlags & RestrictionFlags.Length) != 0
            ) {
                restriction.Length = this.restriction.Length;
                SetFlag(restriction, fixedFlags, RestrictionFlags.Length);
            }
            if (
                (restriction.Flags & RestrictionFlags.MinLength) == 0 &&
                (thisFlags & RestrictionFlags.MinLength) != 0
            ) {
                restriction.MinLength = this.restriction.MinLength;
                SetFlag(restriction, fixedFlags, RestrictionFlags.MinLength);
            }
            if (
                (restriction.Flags & RestrictionFlags.MaxLength) == 0 &&
                (thisFlags & RestrictionFlags.MaxLength) != 0
            ) {
                restriction.MaxLength = this.restriction.MaxLength;
                SetFlag(restriction, fixedFlags, RestrictionFlags.MaxLength);
            }
            if ((thisFlags & RestrictionFlags.Pattern) != 0) {
                if (restriction.Patterns == null) {
                    restriction.Patterns = this.restriction.Patterns;
                }
                else {
                    restriction.Patterns.AddRange(this.restriction.Patterns);
                }
                SetFlag(restriction, fixedFlags, RestrictionFlags.Pattern);
            }


            if ((thisFlags & RestrictionFlags.Enumeration) != 0) {
                if (restriction.Enumeration == null) {
                    restriction.Enumeration = this.restriction.Enumeration;
                }
                SetFlag(restriction, fixedFlags, RestrictionFlags.Enumeration);
            }

            if (
                (restriction.Flags & RestrictionFlags.WhiteSpace) == 0 &&
                (thisFlags & RestrictionFlags.WhiteSpace) != 0
            ) {
                restriction.WhiteSpace = this.restriction.WhiteSpace;
                SetFlag(restriction, fixedFlags, RestrictionFlags.WhiteSpace);
            }
            if (
                (restriction.Flags & RestrictionFlags.MaxInclusive) == 0 &&
                (thisFlags & RestrictionFlags.MaxInclusive) != 0
            ) {
                restriction.MaxInclusive = this.restriction.MaxInclusive;
                SetFlag(restriction, fixedFlags, RestrictionFlags.MaxInclusive);
            }
            if (
                (restriction.Flags & RestrictionFlags.MaxExclusive) == 0 &&
                (thisFlags & RestrictionFlags.MaxExclusive) != 0
            ) {
                restriction.MaxExclusive = this.restriction.MaxExclusive;
                SetFlag(restriction, fixedFlags, RestrictionFlags.MaxExclusive);
            }
            if (
                (restriction.Flags & RestrictionFlags.MinInclusive) == 0 &&
                (thisFlags & RestrictionFlags.MinInclusive) != 0
            ) {
                restriction.MinInclusive = this.restriction.MinInclusive;
                SetFlag(restriction, fixedFlags, RestrictionFlags.MinInclusive);
            }
            if (
                (restriction.Flags & RestrictionFlags.MinExclusive) == 0 &&
                (thisFlags & RestrictionFlags.MinExclusive) != 0
            ) {
                restriction.MinExclusive = this.restriction.MinExclusive;
                SetFlag(restriction, fixedFlags, RestrictionFlags.MinExclusive);
            }
            if (
                (restriction.Flags & RestrictionFlags.TotalDigits) == 0 &&
                (thisFlags & RestrictionFlags.TotalDigits) != 0
            ) {
                restriction.TotalDigits = this.restriction.TotalDigits;
                SetFlag(restriction, fixedFlags, RestrictionFlags.TotalDigits);
            }
            if (
                (restriction.Flags & RestrictionFlags.FractionDigits) == 0 &&
                (thisFlags & RestrictionFlags.FractionDigits) != 0
            ) {
                restriction.FractionDigits = this.restriction.FractionDigits;
                SetFlag(restriction, fixedFlags, RestrictionFlags.FractionDigits);
            }

            // Check combinations
            if (
                (restriction.Flags & RestrictionFlags.Length) != 0 &&
                (restriction.Flags & (RestrictionFlags.MinLength|RestrictionFlags.MaxLength)) != 0
            ) {
                throw new XmlSchemaException(Res.Sch_LengthAndMinMax);
            }
            if (
                (restriction.Flags & RestrictionFlags.MinLength) != 0 &&
                (restriction.Flags & RestrictionFlags.MaxLength) != 0
            ) {
                if (restriction.MinLength > restriction.MaxLength) {
                    throw new XmlSchemaException(Res.Sch_MinLengthGtMaxLength);
                }
            }
            

            if (
                (restriction.Flags & RestrictionFlags.MinInclusive) != 0 &&
                (restriction.Flags & RestrictionFlags.MaxInclusive) != 0
            ) {
                if (Compare(restriction.MinInclusive, restriction.MaxInclusive) > 0) {
                    throw new XmlSchemaException(Res.Sch_MinInclusiveGtMaxInclusive);
                }
            }
            if (
                (restriction.Flags & RestrictionFlags.MinInclusive) != 0 &&
                (restriction.Flags & RestrictionFlags.MaxExclusive) != 0
            ) {
                if (Compare(restriction.MinInclusive, restriction.MaxExclusive) > 0) {
                    throw new XmlSchemaException(Res.Sch_MinInclusiveGtMaxExclusive);
                }
            }
            if (
                (restriction.Flags & RestrictionFlags.MinExclusive) != 0 &&
                (restriction.Flags & RestrictionFlags.MaxExclusive) != 0
            ) {
                if (Compare(restriction.MinExclusive, restriction.MaxExclusive) > 0) {
                    throw new XmlSchemaException(Res.Sch_MinExclusiveGtMaxExclusive);
                }
            }
            if (
                (restriction.Flags & RestrictionFlags.MinExclusive) != 0 &&
                (restriction.Flags & RestrictionFlags.MaxInclusive) != 0
            ) {
                if (Compare(restriction.MinExclusive, restriction.MaxInclusive) > 0) {
                    throw new XmlSchemaException(Res.Sch_MinExclusiveGtMaxInclusive);
                }
            }
            if ((restriction.Flags & (RestrictionFlags.TotalDigits|RestrictionFlags.FractionDigits)) == (RestrictionFlags.TotalDigits|RestrictionFlags.FractionDigits)) {
                if (restriction.FractionDigits > restriction.TotalDigits) {
                    throw new XmlSchemaException(Res.Sch_FractionDigitsGtTotalDigits);
                }
            }
            return restriction;
        }

        private void CheckFixedFlag(XmlSchemaFacet facet, RestrictionFlags fixedFlags, RestrictionFlags flag) {
            if ((fixedFlags & flag) != 0) {
                throw new XmlSchemaException(Res.Sch_FacetBaseFixed, facet);
            }
        }

        private void CheckProhibitedFlag(XmlSchemaFacet facet, RestrictionFlags validRestrictionFlags, RestrictionFlags flag, string errorCode) {
            if ((validRestrictionFlags & flag) == 0) {
                if(!valueType.Name.Equals("String[]"))
                    throw new XmlSchemaException(errorCode, valueType.Name, facet);
                else
                    throw new XmlSchemaException(errorCode, "IDREFS, NMTOKENS, ENTITIES", facet);
            }
        }

        private void CheckDupFlag(XmlSchemaFacet facet, RestrictionFacets restriction, RestrictionFlags flag, string errorCode) {
            if ((restriction.Flags & flag) != 0) {
                throw new XmlSchemaException(errorCode, facet);
            }
        }

        private void SetFlag(RestrictionFacets restriction, XmlSchemaFacet facet, RestrictionFlags flag) {
            restriction.Flags |= flag;
            if (facet.IsFixed) {
                restriction.FixedFlags |= flag;
            }
        }

        private void SetFlag(RestrictionFacets restriction, RestrictionFlags fixedFlags, RestrictionFlags flag) {
            restriction.Flags |= flag;
            if ((fixedFlags & flag) != 0) {
                restriction.FixedFlags |= flag;
            }
        }

        private void CheckValue(object value, XmlSchemaFacet facet, RestrictionFlags thisFlags) {

            if ((thisFlags & RestrictionFlags.MaxInclusive) != 0) {
                if (Compare(value, this.restriction.MaxExclusive) >= 0) {
                    throw new XmlSchemaException(Res.Sch_MaxIncExlMismatch);
                }
                if (Compare(value, this.restriction.MaxInclusive) > 0) {
                    throw new XmlSchemaException(Res.Sch_MaxInclusiveMismatch);
                }
            }
            if ((thisFlags & RestrictionFlags.MaxExclusive) != 0) {
                if (Compare(value, this.restriction.MaxInclusive) > 0) {
                    throw new XmlSchemaException(Res.Sch_MaxExlIncMismatch);
                }
                if (Compare(value, this.restriction.MaxExclusive) > 0) {
                    throw new XmlSchemaException(Res.Sch_MaxExclusiveMismatch);
                }
            }
            if ((thisFlags & RestrictionFlags.MinInclusive) != 0) {
                if (Compare(value, this.restriction.MinExclusive) <= 0) {
                    throw new XmlSchemaException(Res.Sch_MinIncExlMismatch);
                }

                if (Compare(value, this.restriction.MinInclusive) < 0) {
                    throw new XmlSchemaException(Res.Sch_MinInclusiveMismatch);
                }
            }
            if ((thisFlags & RestrictionFlags.MinExclusive) != 0) {
                if (Compare(value, this.restriction.MinInclusive) < 0) {
                    throw new XmlSchemaException(Res.Sch_MinExlIncMismatch);
                }

                if (Compare(value, this.restriction.MinExclusive) < 0) {
                    throw new XmlSchemaException(Res.Sch_MinExclusiveMismatch);
                }
            }
        }


        private void ConstrainAtomicValue(RestrictionFacets restriction, object value) {
            RestrictionFlags flags = restriction.Flags;
            if ((flags & (RestrictionFlags.Length|RestrictionFlags.MinLength|RestrictionFlags.MaxLength)) != 0) {
                int length = LengthOf(value);
                if ((flags & RestrictionFlags.Length) != 0) {
                    if (restriction.Length != length) {
                        throw new XmlSchemaException(Res.Sch_LengthConstraintFailed);
                    }
                }

                if ((flags & RestrictionFlags.MinLength) != 0) {
                    if (length < restriction.MinLength) {
                        throw new XmlSchemaException(Res.Sch_MinLengthConstraintFailed);
                    }
                }

                if ((flags & RestrictionFlags.MaxLength) != 0) {
                    if (restriction.MaxLength < length) {
                        throw new XmlSchemaException(Res.Sch_MaxLengthConstraintFailed);
                    }
                }
            }

            if ((flags & RestrictionFlags.MaxInclusive) != 0) {
                if (Compare(value, restriction.MaxInclusive) > 0) {
                    throw new XmlSchemaException(Res.Sch_MaxInclusiveConstraintFailed);
                }
            }

            if ((flags & RestrictionFlags.MaxExclusive) != 0) {
                if (Compare(value, restriction.MaxExclusive) >= 0) {
                    throw new XmlSchemaException(Res.Sch_MaxExclusiveConstraintFailed);
                }
            }

            if ((flags & RestrictionFlags.MinInclusive) != 0) {
                if (Compare(value, restriction.MinInclusive) < 0) {
                    throw new XmlSchemaException(Res.Sch_MinInclusiveConstraintFailed);
                }
            }

            if ((flags & RestrictionFlags.MinExclusive) != 0) {
                if (Compare(value, restriction.MinExclusive) <= 0) {
                    throw new XmlSchemaException(Res.Sch_MinExclusiveConstraintFailed);
                }
            }

            if ((flags & RestrictionFlags.MinExclusive) != 0) {
                if (Compare(value, restriction.MinExclusive) <= 0) {
                    throw new XmlSchemaException(Res.Sch_MinExclusiveConstraintFailed);
                }
            }

            if ((flags & RestrictionFlags.Enumeration) != 0) {
                if(!MatchEnumeration(value, restriction.Enumeration)) {
                    throw new XmlSchemaException(Res.Sch_EnumerationConstraintFailed);
                }
            }
        }

        private void ConstrainList(RestrictionFacets restriction, ArrayList values) {
            RestrictionFlags flags = restriction.Flags;
            if ((flags & (RestrictionFlags.Length|RestrictionFlags.MinLength|RestrictionFlags.MaxLength)) != 0) {
                int length = values.Count;
                if ((flags & RestrictionFlags.Length) != 0) {
                    if (restriction.Length != length) {
                        throw new XmlSchemaException(Res.Sch_LengthConstraintFailed);
                    }
                }

                if ((flags & RestrictionFlags.MinLength) != 0) {
                    if (length < restriction.MinLength) {
                        throw new XmlSchemaException(Res.Sch_MinLengthConstraintFailed);
                    }
                }

                if ((flags & RestrictionFlags.MaxLength) != 0) {
                    if (restriction.MaxLength < length) {
                        throw new XmlSchemaException(Res.Sch_MaxLengthConstraintFailed);
                    }
                }
            }
            if ((flags & RestrictionFlags.Enumeration) != 0) {
                bool valid = false;
                foreach(Array correctArray in restriction.Enumeration) {
                      if(MatchEnumerationList(values, correctArray)) {
                           valid = true;
                           break;
                        }
                }
                if(!valid) {
                     throw new XmlSchemaException(Res.Sch_EnumerationConstraintFailed);
                }
            }
        }

        private bool MatchEnumerationList(ArrayList values, Array correctArray) {
            int i = correctArray.GetLowerBound(0);
            if(values.Count != correctArray.GetUpperBound(0) + 1) {
                return false;
            }
            foreach(object value in values) {
                while(i <= correctArray.GetUpperBound(0)) {
                    if (Compare(value, correctArray.GetValue(i)) != 0) {
                        return false;
                    } else {
                        break;
                    }
                }
                i++;
            }
            return true;
        }

        private bool MatchEnumeration(object value, ArrayList enumeration) {
            foreach(object correctValue in enumeration) {
                if (Compare(value, correctValue) == 0) {
                    return true;
                }
            }
            return false;
        }

        private struct Map {
            internal Map(char m, string r) {
                match = m;
                replacement = r;
            }
            internal char match;
            internal string replacement;
        };

        private static readonly Map[] c_map = {
            new Map('c', "\\p{_xmlC}"),
            new Map('C', "\\P{_xmlC}"),
            new Map('d', "\\p{_xmlD}"),
            new Map('D', "\\P{_xmlD}"),
            new Map('i', "\\p{_xmlI}"),
            new Map('I', "\\P{_xmlI}"),
            new Map('w', "\\p{_xmlW}"),
            new Map('W', "\\P{_xmlW}"),
        };

        private static string Preprocess(string pattern) {
            StringBuilder bufBld = new StringBuilder();
            bufBld.Append("^");

            char[] source = pattern.ToCharArray();
            int length = pattern.Length;
            int copyPosition = 0;
            for (int position = 0; position < length - 2; position ++) {
                if (source[position] == '\\') {
                    if (source[position + 1] == '\\') {
                        position ++; // skip it
                    }
                    else {
                        char ch = source[position + 1];
                        for (int i = 0; i < c_map.Length; i++) {
                            if (c_map[i].match == ch) {
                                if (copyPosition < position) {
                                    bufBld.Append(source, copyPosition, position - copyPosition);
                                }
                                bufBld.Append(c_map[i].replacement);
                                position ++;
                                copyPosition = position + 1;
                                break;
                            }
                        }
                    }
                }
            }
            if (copyPosition < length) {
                bufBld.Append(source, copyPosition, length - copyPosition);
            }

            bufBld.Append("$");
            return bufBld.ToString();
        }

        internal int Compare(byte[] value1, byte[] value2) {
            int length = value1.Length;
            if (length != value2.Length) {
                return -1;
            }
            for (int i = 0; i < length; i ++) {
                if (value1[i] != value2[i]) {
                    return -1;
                }
            }
            return 0;
        }
    }

    internal class Datatype_union : DatatypeImplementation {
        static readonly Type atomicValueType = typeof(object);
        static readonly Type listValueType = typeof(object[]);
        XmlSchemaDatatype[] types;

        internal Datatype_union(XmlSchemaDatatype[] types) {
            this.types = types;
        }

        internal object ParseUnion(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr, out DatatypeImplementation dtCorrect) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tSchemaDatatype_union.ParseValue(\"{0}\")", s));
            foreach(DatatypeImplementation dt in types) {
                try {
                    dtCorrect = dt;
                    return dtCorrect.ParseValue(s, nameTable, nsmgr);
                }
                catch(Exception){}
            }
            throw new XmlSchemaException(Res.Sch_UnionFailed);
        }

        protected override int LengthOf(object value) { throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation)); }

        protected override int Compare(object value1, object value2) { throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation)); }

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            DatatypeImplementation dtCorrect;
            return ParseUnion(s, nameTable, nsmgr, out dtCorrect);
        }

        protected override Type AtomicValueType { get { return atomicValueType; }}
        protected override Type ListValueType { get { return listValueType; }}

        protected override RestrictionFlags ValidRestrictionFlags {
            get {
                return RestrictionFlags.Pattern|
                       RestrictionFlags.Enumeration;
            }
        }

        protected override bool IsWhitespaceCollapseFixed { get { return false; } }

        internal bool IsDerivedFromUnion(XmlSchemaDatatype dtype) {
            foreach(XmlSchemaDatatype dt in types) {
                if (dt.IsDerivedFrom(dtype)) {
                    return true;
                }
            }
            return false;
        }

        internal bool HasAtomicMembers() {
            foreach(DatatypeImplementation dt in types) {
                if (dt.Variety == XmlSchemaDatatypeVariety.List) {
                    return false;
                }
            }
            return true;
        }
    }

    // Primitive datatypes
    internal class Datatype_anyType : DatatypeImplementation {
        static readonly Type atomicValueType = typeof(string);
        static readonly Type listValueType = typeof(string[]);

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        public override XmlTokenizedType TokenizedType { get { return XmlTokenizedType.None;}}

        protected override RestrictionFlags ValidRestrictionFlags { get { return 0;}}

        protected override bool IsWhitespaceCollapseFixed { get { return true; } }

        protected override int LengthOf(object value) {
            return value.ToString().Length;
        }

        protected override int Compare(object value1, object value2) {
            // this should be culture sensitive - comparing values
            return String.Compare(value1.ToString(), value2.ToString(), false, CultureInfo.CurrentCulture);
        }

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_string.ParseAtomicValue(\"{0}\")", s));
            return s;
        }
    }

    internal class Datatype_anySimpleType : Datatype_anyType {
    }

    /*
      <xs:simpleType name="string" id="string">
        <xs:annotation>
          <xs:appinfo>
            <hfp:hasFacet name="length"/>
            <hfp:hasFacet name="minLength"/>
            <hfp:hasFacet name="maxLength"/>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasProperty name="ordered" value="false"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality" value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
          <xs:documentation
                    source="http://www.w3.org/TR/xmlschema-2/#string"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="preserve" id="string.preserve"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_string : Datatype_anyType {
        public override XmlTokenizedType TokenizedType { get { return XmlTokenizedType.CDATA;}}

        protected override RestrictionFlags ValidRestrictionFlags {
            get {
                return RestrictionFlags.Length|
                       RestrictionFlags.MinLength|
                       RestrictionFlags.MaxLength|
                       RestrictionFlags.Pattern|
                       RestrictionFlags.Enumeration|
                       RestrictionFlags.WhiteSpace;
            }
        }
        protected override bool IsWhitespaceCollapseFixed { get { return false; } }
    }

    /*
      <xs:simpleType name="boolean" id="boolean">
        <xs:annotation>
          <xs:appinfo>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasProperty name="ordered" value="false"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality" value="finite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#boolean"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="collapse" fixed="true"
            id="boolean.whiteSpace"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_boolean : Datatype_anyType {
        static readonly Type atomicValueType = typeof(bool);
        static readonly Type listValueType = typeof(bool[]);

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override RestrictionFlags ValidRestrictionFlags {
            get {
                return RestrictionFlags.Pattern|
                       RestrictionFlags.WhiteSpace;
            }
        }

        protected override int LengthOf(object value) { throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation)); }

        protected override int Compare(object value1, object value2) {
            return ((bool)value1).CompareTo(value2);
        }

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_boolean.ParseAtomicValue(\"{0}\")", s));
            return XmlConvert.ToBoolean(s);
        }
    }

    /*
      <xs:simpleType name="float" id="float">
        <xs:annotation>
          <xs:appinfo>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasFacet name="maxInclusive"/>
            <hfp:hasFacet name="maxExclusive"/>
            <hfp:hasFacet name="minInclusive"/>
            <hfp:hasFacet name="minExclusive"/>
            <hfp:hasProperty name="ordered" value="total"/>
            <hfp:hasProperty name="bounded" value="true"/>
            <hfp:hasProperty name="cardinality" value="finite"/>
            <hfp:hasProperty name="numeric" value="true"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#float"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="collapse" fixed="true"
            id="float.whiteSpace"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_float : Datatype_anyType {
        static readonly Type atomicValueType = typeof(float);
        static readonly Type listValueType = typeof(float[]);

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override RestrictionFlags ValidRestrictionFlags {
            get {
                return RestrictionFlags.Pattern|
                       RestrictionFlags.Enumeration|
                       RestrictionFlags.WhiteSpace|
                       RestrictionFlags.MinExclusive|
                       RestrictionFlags.MinInclusive|
                       RestrictionFlags.MaxExclusive|
                       RestrictionFlags.MaxInclusive;
            }
        }

        protected override int LengthOf(object value) { throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation)); }

        protected override int Compare(object value1, object value2) {
            return ((float)value1).CompareTo(value2);
        }

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_float.ParseAtomicValue(\"{0}\")", s));
            return XmlConvert.ToSingle(s);
        }
    }

    /*
      <xs:simpleType name="double" id="double">
        <xs:annotation>
          <xs:appinfo>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasFacet name="maxInclusive"/>
            <hfp:hasFacet name="maxExclusive"/>
            <hfp:hasFacet name="minInclusive"/>
            <hfp:hasFacet name="minExclusive"/>
            <hfp:hasProperty name="ordered" value="total"/>
            <hfp:hasProperty name="bounded" value="true"/>
            <hfp:hasProperty name="cardinality" value="finite"/>
            <hfp:hasProperty name="numeric" value="true"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#double"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="collapse"  fixed="true"
            id="double.whiteSpace"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_double : Datatype_anyType {
        static readonly Type atomicValueType = typeof(double);
        static readonly Type listValueType = typeof(double[]);

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override RestrictionFlags ValidRestrictionFlags {
            get {
                return RestrictionFlags.Pattern|
                       RestrictionFlags.Enumeration|
                       RestrictionFlags.WhiteSpace|
                       RestrictionFlags.MinExclusive|
                       RestrictionFlags.MinInclusive|
                       RestrictionFlags.MaxExclusive|
                       RestrictionFlags.MaxInclusive;
            }
        }

        protected override int LengthOf(object value) { throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation)); }

        protected override int Compare(object value1, object value2) {
            return ((double)value1).CompareTo(value2);
        }

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_double.ParseAtomicValue(\"{0}\")", s));
            return XmlConvert.ToDouble(s);
        }
    }

    /*
      <xs:simpleType name="decimal" id="decimal">
        <xs:annotation>
          <xs:appinfo>
            <hfp:hasFacet name="totalDigits"/>
            <hfp:hasFacet name="fractionDigits"/>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="maxInclusive"/>
            <hfp:hasFacet name="maxExclusive"/>
            <hfp:hasFacet name="minInclusive"/>
            <hfp:hasFacet name="minExclusive"/>
            <hfp:hasProperty name="ordered" value="total"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality"
                    value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="true"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#decimal"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="collapse"  fixed="true"
            id="decimal.whiteSpace"/>
        </xs:restriction>
       </xs:simpleType>
    */
    internal class Datatype_decimal : Datatype_anyType {
        static readonly Type atomicValueType = typeof(decimal);
        static readonly Type listValueType = typeof(decimal[]);

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override RestrictionFlags ValidRestrictionFlags {
            get {
                return RestrictionFlags.TotalDigits|
                       RestrictionFlags.FractionDigits|
                       RestrictionFlags.Pattern|
                       RestrictionFlags.Enumeration|
                       RestrictionFlags.WhiteSpace|
                       RestrictionFlags.MinExclusive|
                       RestrictionFlags.MinInclusive|
                       RestrictionFlags.MaxExclusive|
                       RestrictionFlags.MaxInclusive;
            }
        }

        protected override int LengthOf(object value) { throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation)); }

        protected override int Compare(object value1, object value2) {
            return ((decimal)value1).CompareTo(value2);
        }

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_decimal.ParseAtomicValue(\"{0}\")", s));
            CheckTotalDigits(s);
            CheckFractionDigits(s);
            return XmlConvert.ToDecimal(s);
        }

        static readonly char[] signs = new char[] {'+', '-'};
        protected void CheckTotalDigits(string s) {
            if (Restriction != null && (Restriction.Flags & RestrictionFlags.TotalDigits) != 0) {
                CheckTotalDigits(s, Restriction.TotalDigits);
            }
        }
        protected void CheckTotalDigits(string s, int totalDigits) {
            long length = s.Length;
            if (s.IndexOfAny(signs) != -1) {
                length --;
            }
            if (s.IndexOf('.') != -1) {
                length --;
            }
            if (length > totalDigits) {
                throw new XmlSchemaException(Res.Sch_TotalDigitsConstraintFailed);
            }
        }

        protected void CheckFractionDigits(string s) {
            if (Restriction != null && (Restriction.Flags & RestrictionFlags.FractionDigits) != 0) {
                CheckFractionDigits(s, Restriction.FractionDigits);
            }
        }

        protected void CheckFractionDigits(string s, int fractionDigits) {
            int fraction = s.IndexOf('.');
            if (fraction != -1 && s.Length - fraction - 1 > fractionDigits) {
                throw new XmlSchemaException(Res.Sch_FractionDigitsConstraintFailed);
            }
        }
    }

    /*
       <xs:simpleType name="duration" id="duration">
        <xs:annotation>
          <xs:appinfo>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasFacet name="maxInclusive"/>
            <hfp:hasFacet name="maxExclusive"/>
            <hfp:hasFacet name="minInclusive"/>
            <hfp:hasFacet name="minExclusive"/>
            <hfp:hasProperty name="ordered" value="partial"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality"
                    value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#duration"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="collapse"  fixed="true"
            id="duration.whiteSpace"/>
        </xs:restriction>
       </xs:simpleType>
    */
    internal class Datatype_duration : Datatype_anyType {
        static readonly Type atomicValueType = typeof(TimeSpan);
        static readonly Type listValueType = typeof(TimeSpan[]);

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override RestrictionFlags ValidRestrictionFlags {
            get {
                return RestrictionFlags.Pattern|
                       RestrictionFlags.Enumeration|
                       RestrictionFlags.WhiteSpace|
                       RestrictionFlags.MinExclusive|
                       RestrictionFlags.MinInclusive|
                       RestrictionFlags.MaxExclusive|
                       RestrictionFlags.MaxInclusive;
            }
        }

        protected override int LengthOf(object value) { throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation)); }

        protected override int Compare(object value1, object value2) {
            return ((TimeSpan)value1).CompareTo(value2);
        }

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_timeDuration.ParseAtomicValue(\"{0}\")", s));
            if (s == null || s == string.Empty) {
                throw new XmlSchemaException(Res.Sch_EmptyAttributeValue);
            }
            return XmlConvert.ToTimeSpan(s);
        }
    }

    internal class Datatype_dateTimeBase : Datatype_anyType {
        static readonly Type atomicValueType = typeof(DateTime);
        static readonly Type listValueType = typeof(DateTime[]);

        internal Datatype_dateTimeBase(string[] formats) {
            this.formats = formats;
        }

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override RestrictionFlags ValidRestrictionFlags {
            get {
                return RestrictionFlags.Pattern|
                       RestrictionFlags.Enumeration|
                       RestrictionFlags.WhiteSpace|
                       RestrictionFlags.MinExclusive|
                       RestrictionFlags.MinInclusive|
                       RestrictionFlags.MaxExclusive|
                       RestrictionFlags.MaxInclusive;
            }
        }

        protected override int LengthOf(object value) { throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation)); }

        protected override int Compare(object value1, object value2) {
            return ((DateTime)value1).CompareTo(value2);
        }

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_dateTimeBase.ParseAtomicValue(\"{0}\")", s));
            return XmlConvert.ToDateTime(s, formats);
        }

        private string[] formats = null;
    }

    internal class Datatype_dateTimeNoTimeZone : Datatype_dateTimeBase {
        internal Datatype_dateTimeNoTimeZone() : base(new string[] {
            "yyyy-MM-dd",
            "yyyy-MM-ddZ",
            "yyyy-MM-ddzzzzzz",
            "yyyy-MM-ddTHH:mm:ss",
            "yyyy-MM-ddTHH:mm:ss.f",
            "yyyy-MM-ddTHH:mm:ss.ff",
            "yyyy-MM-ddTHH:mm:ss.fff",
            "yyyy-MM-ddTHH:mm:ss.ffff",
            "yyyy-MM-ddTHH:mm:ss.fffff",
            "yyyy-MM-ddTHH:mm:ss.ffffff",
            "yyyy-MM-ddTHH:mm:ss.fffffff",
        }) {}
    }

    internal class Datatype_dateTimeTimeZone : Datatype_dateTimeBase {
        internal Datatype_dateTimeTimeZone() : base(new string[] {
            "yyyy-MM-dd",
            "yyyy-MM-ddZ",
            "yyyy-MM-ddzzzzzz",
            "yyyy-MM-ddTHH:mm:ss",
            "yyyy-MM-ddTHH:mm:ss.f",
            "yyyy-MM-ddTHH:mm:ss.ff",
            "yyyy-MM-ddTHH:mm:ss.fff",
            "yyyy-MM-ddTHH:mm:ss.ffff",
            "yyyy-MM-ddTHH:mm:ss.fffff",
            "yyyy-MM-ddTHH:mm:ss.ffffff",
            "yyyy-MM-ddTHH:mm:ss.fffffff",
            "yyyy-MM-ddTHH:mm:sszzzzzz",
            "yyyy-MM-ddTHH:mm:ss.fzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.ffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.fffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.ffffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.fffffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.ffffffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.fffffffzzzzzz",
        }) {}
    }

    /*
      <xs:simpleType name="dateTime" id="dateTime">
       <xs:annotation>
        <xs:appinfo>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasFacet name="maxInclusive"/>
            <hfp:hasFacet name="maxExclusive"/>
            <hfp:hasFacet name="minInclusive"/>
            <hfp:hasFacet name="minExclusive"/>
            <hfp:hasProperty name="ordered" value="partial"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality"
                    value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#dateTime"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="collapse"  fixed="true"
            id="dateTime.whiteSpace"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_dateTime : Datatype_dateTimeBase {
        internal Datatype_dateTime() : base(new string[] {
            "yyyy-MM-ddTHH:mm:ss",
            "yyyy-MM-ddTHH:mm:ss.f",
            "yyyy-MM-ddTHH:mm:ss.ff",
            "yyyy-MM-ddTHH:mm:ss.fff",
            "yyyy-MM-ddTHH:mm:ss.ffff",
            "yyyy-MM-ddTHH:mm:ss.fffff",
            "yyyy-MM-ddTHH:mm:ss.ffffff",
            "yyyy-MM-ddTHH:mm:ss.fffffff",
            "yyyy-MM-ddTHH:mm:ssZ",
            "yyyy-MM-ddTHH:mm:ss.fZ",
            "yyyy-MM-ddTHH:mm:ss.ffZ",
            "yyyy-MM-ddTHH:mm:ss.fffZ",
            "yyyy-MM-ddTHH:mm:ss.ffffZ",
            "yyyy-MM-ddTHH:mm:ss.fffffZ",
            "yyyy-MM-ddTHH:mm:ss.ffffffZ",
            "yyyy-MM-ddTHH:mm:ss.fffffffZ",
            "yyyy-MM-ddTHH:mm:sszzzzzz",
            "yyyy-MM-ddTHH:mm:ss.fzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.ffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.fffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.ffffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.fffffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.ffffffzzzzzz",
            "yyyy-MM-ddTHH:mm:ss.fffffffzzzzzz",
        }) {}
    }

    internal class Datatype_timeNoTimeZone : Datatype_dateTimeBase {
        internal Datatype_timeNoTimeZone() : base(new string[] {
            "HH:mm:ss",
            "HH:mm:ss.f",
            "HH:mm:ss.ff",
            "HH:mm:ss.fff",
            "HH:mm:ss.ffff",
            "HH:mm:ss.fffff",
            "HH:mm:ss.ffffff",
            "HH:mm:ss.fffffff",
        }) {}
    }

    internal class Datatype_timeTimeZone : Datatype_dateTimeBase {
        internal Datatype_timeTimeZone() : base(new string[] {
            "HH:mm:ss",
            "HH:mm:ss.f",
            "HH:mm:ss.ff",
            "HH:mm:ss.fff",
            "HH:mm:ss.ffff",
            "HH:mm:ss.fffff",
            "HH:mm:ss.ffffff",
            "HH:mm:ss.fffffff",
            "HH:mm:sszzzzzz",
            "HH:mm:ss.fzzzzzz",
            "HH:mm:ss.ffzzzzzz",
            "HH:mm:ss.fffzzzzzz",
            "HH:mm:ss.ffffzzzzzz",
            "HH:mm:ss.fffffzzzzzz",
            "HH:mm:ss.ffffffzzzzzz",
            "HH:mm:ss.fffffffzzzzzz",
        }) {}
    }

    /*
      <xs:simpleType name="time" id="time">
        <xs:annotation>
        <xs:appinfo>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasFacet name="maxInclusive"/>
            <hfp:hasFacet name="maxExclusive"/>
            <hfp:hasFacet name="minInclusive"/>
            <hfp:hasFacet name="minExclusive"/>
            <hfp:hasProperty name="ordered" value="partial"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality"
                    value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#time"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="collapse"  fixed="true"
            id="time.whiteSpace"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_time : Datatype_dateTimeBase {
        internal Datatype_time() : base(new string[] {
            "HH:mm:ss",
            "HH:mm:ss.f",
            "HH:mm:ss.ff",
            "HH:mm:ss.fff",
            "HH:mm:ss.ffff",
            "HH:mm:ss.fffff",
            "HH:mm:ss.ffffff",
            "HH:mm:ss.fffffff",
            "HH:mm:ssZ",
            "HH:mm:ss.fZ",
            "HH:mm:ss.ffZ",
            "HH:mm:ss.fffZ",
            "HH:mm:ss.ffffZ",
            "HH:mm:ss.fffffZ",
            "HH:mm:ss.ffffffZ",
            "HH:mm:ss.fffffffZ",
            "HH:mm:sszzzzzz",
            "HH:mm:ss.fzzzzzz",
            "HH:mm:ss.ffzzzzzz",
            "HH:mm:ss.fffzzzzzz",
            "HH:mm:ss.ffffzzzzzz",
            "HH:mm:ss.fffffzzzzzz",
            "HH:mm:ss.ffffffzzzzzz",
            "HH:mm:ss.fffffffzzzzzz",
        }) {}
    }

    /*
      <xs:simpleType name="date" id="date">
       <xs:annotation>
        <xs:appinfo>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasFacet name="maxInclusive"/>
            <hfp:hasFacet name="maxExclusive"/>
            <hfp:hasFacet name="minInclusive"/>
            <hfp:hasFacet name="minExclusive"/>
            <hfp:hasProperty name="ordered" value="partial"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality"
                    value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#date"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="collapse"  fixed="true"
            id="date.whiteSpace"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_date : Datatype_dateTimeBase {
        internal Datatype_date() : base(new string[] {
            "yyyy-MM-dd",
            "yyyy-MM-ddZ",
            "yyyy-MM-ddzzzzzz",
        }) {}
    }

    /*
      <xs:simpleType name="gYearMonth" id="gYearMonth">
       <xs:annotation>
        <xs:appinfo>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasFacet name="maxInclusive"/>
            <hfp:hasFacet name="maxExclusive"/>
            <hfp:hasFacet name="minInclusive"/>
            <hfp:hasFacet name="minExclusive"/>
            <hfp:hasProperty name="ordered" value="partial"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality"
                    value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#gYearMonth"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="collapse"  fixed="true"
            id="gYearMonth.whiteSpace"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_yearMonth : Datatype_dateTimeBase {
        internal Datatype_yearMonth() : base(new string[] {
            "yyyy-MM",
            "yyyy-MMZ",
            "yyyy-MMzzzzzz",
        }) {}
    }


    /*
      <xs:simpleType name="gYear" id="gYear">
        <xs:annotation>
        <xs:appinfo>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasFacet name="maxInclusive"/>
            <hfp:hasFacet name="maxExclusive"/>
            <hfp:hasFacet name="minInclusive"/>
            <hfp:hasFacet name="minExclusive"/>
            <hfp:hasProperty name="ordered" value="partial"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality"
                    value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#gYear"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="collapse"  fixed="true"
            id="gYear.whiteSpace"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_year : Datatype_dateTimeBase {
        internal Datatype_year() : base(new string[] {
            "yyyy",
            "yyyyZ",
            "yyyyzzzzzz",
        }) {}
    }

    /*
     <xs:simpleType name="gMonthDay" id="gMonthDay">
        <xs:annotation>
          <xs:appinfo>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasFacet name="maxInclusive"/>
            <hfp:hasFacet name="maxExclusive"/>
            <hfp:hasFacet name="minInclusive"/>
            <hfp:hasFacet name="minExclusive"/>
            <hfp:hasProperty name="ordered" value="partial"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality"
                    value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
           <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#gMonthDay"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
             <xs:whiteSpace value="collapse" fixed="true"
                    id="gMonthDay.whiteSpace"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_monthDay : Datatype_dateTimeBase {
        internal Datatype_monthDay() : base(new string[] {
            "--MM-dd",
            "--MM-ddZ",
            "--MM-ddzzzzzz"
        }) {}
    }

    /*
      <xs:simpleType name="gDay" id="gDay">
        <xs:annotation>
          <xs:appinfo>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasFacet name="maxInclusive"/>
            <hfp:hasFacet name="maxExclusive"/>
            <hfp:hasFacet name="minInclusive"/>
            <hfp:hasFacet name="minExclusive"/>
            <hfp:hasProperty name="ordered" value="partial"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality"
                    value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#gDay"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
             <xs:whiteSpace value="collapse"  fixed="true"
                    id="gDay.whiteSpace"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_day : Datatype_dateTimeBase {
        internal Datatype_day() : base(new string[] {
            "---dd",
            "---ddZ",
            "---ddzzzzzz"
        }) {}
    }


    /*
     <xs:simpleType name="gMonth" id="gMonth">
        <xs:annotation>
      <xs:appinfo>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasFacet name="maxInclusive"/>
            <hfp:hasFacet name="maxExclusive"/>
            <hfp:hasFacet name="minInclusive"/>
            <hfp:hasFacet name="minExclusive"/>
            <hfp:hasProperty name="ordered" value="partial"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality"
                    value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#gMonth"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
             <xs:whiteSpace value="collapse"  fixed="true"
                    id="gMonth.whiteSpace"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_month : Datatype_dateTimeBase {
        internal Datatype_month() : base(new string[] {
            "--MM--",
            "--MM--Z",
            "--MM--zzzzzz"
        }) {}
    }

    /*
       <xs:simpleType name="hexBinary" id="hexBinary">
        <xs:annotation>
          <xs:appinfo>
            <hfp:hasFacet name="length"/>
            <hfp:hasFacet name="minLength"/>
            <hfp:hasFacet name="maxLength"/>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasProperty name="ordered" value="false"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality"
                    value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#binary"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="collapse" fixed="true"
            id="hexBinary.whiteSpace"/>
        </xs:restriction>
       </xs:simpleType>
    */
    internal class Datatype_hexBinary : Datatype_anyType {
        static readonly Type atomicValueType = typeof(byte[]);
        static readonly Type listValueType = typeof(byte[][]);

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override RestrictionFlags ValidRestrictionFlags {
            get {
                return RestrictionFlags.Length|
                       RestrictionFlags.MinLength|
                       RestrictionFlags.MaxLength|
                       RestrictionFlags.Pattern|
                       RestrictionFlags.Enumeration|
                       RestrictionFlags.WhiteSpace;
            }
        }

        protected override int LengthOf(object value) {
            return ((byte[])value).Length;
        }

        protected override int Compare(object value1, object value2) {
            return Compare((byte[])value1, (byte[])value2);
        }

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, "\t\t\tDatatype_binary.ParseAtomicValue");
            return XmlConvert.FromBinHexString(s);
        }
    }


    /*
     <xs:simpleType name="base64Binary" id="base64Binary">
        <xs:annotation>
          <xs:appinfo>
            <hfp:hasFacet name="length"/>
            <hfp:hasFacet name="minLength"/>
            <hfp:hasFacet name="maxLength"/>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasProperty name="ordered" value="false"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality"
                    value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
          <xs:documentation
                    source="http://www.w3.org/TR/xmlschema-2/#base64Binary"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="collapse" fixed="true"
            id="base64Binary.whiteSpace"/>
        </xs:restriction>
       </xs:simpleType>
    */
    internal class Datatype_base64Binary : Datatype_anyType {
        static readonly Type atomicValueType = typeof(byte[]);
        static readonly Type listValueType = typeof(byte[][]);

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override RestrictionFlags ValidRestrictionFlags {
            get {
                return RestrictionFlags.Length|
                       RestrictionFlags.MinLength|
                       RestrictionFlags.MaxLength|
                       RestrictionFlags.Pattern|
                       RestrictionFlags.Enumeration|
                       RestrictionFlags.WhiteSpace;
            }
        }

        protected override int LengthOf(object value) {
            return ((byte[])value).Length;
        }

        protected override int Compare(object value1, object value2) {
            return Compare((byte[])value1, (byte[])value2);
        }

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, "\t\t\tDatatype_binary.ParseAtomicValue");
            return Convert.FromBase64String(s);
        }
    }

    /*
       <xs:simpleType name="anyURI" id="anyURI">
        <xs:annotation>
          <xs:appinfo>
            <hfp:hasFacet name="length"/>
            <hfp:hasFacet name="minLength"/>
            <hfp:hasFacet name="maxLength"/>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasProperty name="ordered" value="false"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality"
                    value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#anyURI"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="collapse"  fixed="true"
            id="anyURI.whiteSpace"/>
        </xs:restriction>
       </xs:simpleType>
    */
    internal class Datatype_anyURI : Datatype_anyType {
        static readonly Type atomicValueType = typeof(Uri);
        static readonly Type listValueType = typeof(Uri[]);

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override RestrictionFlags ValidRestrictionFlags {
            get {
                return RestrictionFlags.Length|
                       RestrictionFlags.MinLength|
                       RestrictionFlags.MaxLength|
                       RestrictionFlags.Pattern|
                       RestrictionFlags.Enumeration|
                       RestrictionFlags.WhiteSpace;
            }
        }

        protected override int LengthOf(object value) { return value.ToString().Length; }

        protected override int Compare(object value1, object value2) {
            return ((XmlSchemaUri)value1).Equals((XmlSchemaUri)value2) ? 0 : -1;
        }

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_anyURI.ParseAtomicValue(\"{0}\")", s));
            return XmlConvert.ToUri(s);
        }
    }
    
    
    /*
      <xs:simpleType name="QName" id="QName">
        <xs:annotation>
            <xs:appinfo>
            <hfp:hasFacet name="length"/>
            <hfp:hasFacet name="minLength"/>
            <hfp:hasFacet name="maxLength"/>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasProperty name="ordered" value="false"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality"
                    value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#QName"/>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="collapse"  fixed="true"
            id="QName.whiteSpace"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_QName : Datatype_anyType {
        static readonly Type atomicValueType = typeof(XmlQualifiedName);
        static readonly Type listValueType = typeof(XmlQualifiedName[]);

        public override XmlTokenizedType TokenizedType { get { return XmlTokenizedType.QName;}}

        protected override RestrictionFlags ValidRestrictionFlags {
            get {
                return RestrictionFlags.Length|
                       RestrictionFlags.MinLength|
                       RestrictionFlags.MaxLength|
                       RestrictionFlags.Pattern|
                       RestrictionFlags.Enumeration|
                       RestrictionFlags.WhiteSpace;
            }
        }

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_QName.ParseAtomicValue(\"{0}\")", s));
            if (s == null || s == string.Empty) {
                throw new XmlSchemaException(Res.Sch_EmptyAttributeValue);
            }
            if (nsmgr == null) {
                throw new ArgumentNullException("nsmgr");
            }
            string prefix;
            return XmlQualifiedName.Parse(s, nameTable, nsmgr, out prefix);
        }

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}
    }

    /*
      <xs:simpleType name="normalizedString" id="normalizedString">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#normalizedString"/>
        </xs:annotation>
        <xs:restriction base="xs:string">
          <xs:whiteSpace value="replace"
            id="normalizedString.whiteSpace"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_normalizedString : Datatype_string {
        static readonly char[] crt = new char[] {'\n', '\r', '\t'};
        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            if (s.IndexOfAny(crt) != -1) {
                throw new XmlSchemaException(Res.Sch_NotNormalizedString, s);
            }
            return s;
        }
    }

    /*
      <xs:simpleType name="token" id="token">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#token"/>
        </xs:annotation>
        <xs:restriction base="xs:normalizedString">
          <xs:whiteSpace value="collapse" id="token.whiteSpace"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_token : Datatype_normalizedString {
        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            return XmlConvert.VerifyTOKEN(s);
        }
    }

    /*
      <xs:simpleType name="language" id="language">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#language"/>
        </xs:annotation>
        <xs:restriction base="xs:token">
          <xs:pattern
            value="([a-zA-Z]{2}|[iI]-[a-zA-Z]+|[xX]-[a-zA-Z]{1,8})(-[a-zA-Z]{1,8})*"
                    id="language.pattern">
            <xs:annotation>
              <xs:documentation
                    source="http://www.w3.org/TR/REC-xml#NT-LanguageID">
                pattern specifies the content of section 2.12 of XML 1.0e2
                and RFC 1766
              </xs:documentation>
            </xs:annotation>
          </xs:pattern>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_language : Datatype_token {
        static Regex languagePattern = new Regex("^([a-zA-Z]{2}|[iI]-[a-zA-Z]+|[xX]-[a-zA-Z]{1,8})(-[a-zA-Z]{1,8})*$", RegexOptions.None);
        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_language.ParseAtomicValue(\"{0}\")", s));
            if (s == null || s == string.Empty) {
                throw new XmlSchemaException(Res.Sch_EmptyAttributeValue);
            }
            if (!languagePattern.IsMatch(s)) {
                throw new XmlSchemaException(Res.Sch_InvalidLanguageId, s);
            }
            return s;
        }
    }

    /*
      <xs:simpleType name="NMTOKEN" id="NMTOKEN">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#NMTOKEN"/>
        </xs:annotation>
        <xs:restriction base="xs:token">
          <xs:pattern value="\c+" id="NMTOKEN.pattern">
            <xs:annotation>
              <xs:documentation
                    source="http://www.w3.org/TR/REC-xml#NT-Nmtoken">
                pattern matches production 7 from the XML spec
              </xs:documentation>
            </xs:annotation>
          </xs:pattern>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_NMTOKEN : Datatype_token {
        public override XmlTokenizedType TokenizedType { get { return XmlTokenizedType.NMTOKEN;}}

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_NMTOKEN.ParseAtomicValue(\"{0}\")", s));
            if (s == null || s == string.Empty) {
                throw new XmlSchemaException(Res.Sch_EmptyAttributeValue);
            }
            return nameTable.Add(XmlConvert.VerifyNMTOKEN(s));
        }
    }

    /*
      <xs:simpleType name="Name" id="Name">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#Name"/>
        </xs:annotation>
        <xs:restriction base="xs:token">
          <xs:pattern value="\i\c*" id="Name.pattern">
            <xs:annotation>
              <xs:documentation
                            source="http://www.w3.org/TR/REC-xml#NT-Name">
                pattern matches production 5 from the XML spec
              </xs:documentation>
            </xs:annotation>
          </xs:pattern>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_Name : Datatype_token {
        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_Name.ParseAtomicValue(\"{0}\")", s));
            if (s == null || s == string.Empty) {
                throw new XmlSchemaException(Res.Sch_EmptyAttributeValue);
            }
            return XmlConvert.VerifyName(s);
        }
    }

    /*
      <xs:simpleType name="NCName" id="NCName">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#NCName"/>
        </xs:annotation>
        <xs:restriction base="xs:Name">
          <xs:pattern value="[\i-[:]][\c-[:]]*" id="NCName.pattern">
            <xs:annotation>
              <xs:documentation
                    source="http://www.w3.org/TR/REC-xml-names/#NT-NCName">
                pattern matches production 4 from the Namespaces in XML spec
              </xs:documentation>
            </xs:annotation>
          </xs:pattern>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_NCName : Datatype_Name {
        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_NCName().ParseAtomicValue(\"{0}\")", s));
            if (s == null || s == string.Empty) {
                throw new XmlSchemaException(Res.Sch_EmptyAttributeValue);
            }

            return nameTable.Add(XmlConvert.VerifyNCName(s));
        }
    }

    /*
       <xs:simpleType name="ID" id="ID">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#ID"/>
        </xs:annotation>
        <xs:restriction base="xs:NCName"/>
       </xs:simpleType>
    */
    internal class Datatype_ID : Datatype_NCName {
        public override XmlTokenizedType TokenizedType { get { return XmlTokenizedType.ID;}}
    }

    /*
       <xs:simpleType name="IDREF" id="IDREF">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#IDREF"/>
        </xs:annotation>
        <xs:restriction base="xs:NCName"/>
       </xs:simpleType>
    */
    internal class Datatype_IDREF : Datatype_NCName {
        public override XmlTokenizedType TokenizedType { get { return XmlTokenizedType.IDREF;}}
    }

    /*
       <xs:simpleType name="ENTITY" id="ENTITY">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#ENTITY"/>
        </xs:annotation>
        <xs:restriction base="xs:NCName"/>
       </xs:simpleType>
    */
    internal class Datatype_ENTITY : Datatype_anyType {
        public override XmlTokenizedType TokenizedType { get { return XmlTokenizedType.ENTITY;}}
    }

    /*
       <xs:simpleType name="NOTATION" id="NOTATION">
        <xs:annotation>
            <xs:appinfo>
            <hfp:hasFacet name="length"/>
            <hfp:hasFacet name="minLength"/>
            <hfp:hasFacet name="maxLength"/>
            <hfp:hasFacet name="pattern"/>
            <hfp:hasFacet name="enumeration"/>
            <hfp:hasFacet name="whiteSpace"/>
            <hfp:hasProperty name="ordered" value="false"/>
            <hfp:hasProperty name="bounded" value="false"/>
            <hfp:hasProperty name="cardinality"
                    value="countably infinite"/>
            <hfp:hasProperty name="numeric" value="false"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#NOTATION"/>
          <xs:documentation>
            NOTATION cannot be used directly in a schema; rather a type
            must be derived from it by specifying at least one enumeration
            facet whose value is the name of a NOTATION declared in the
            schema.
          </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:anySimpleType">
          <xs:whiteSpace value="collapse"  fixed="true"
            id="NOTATION.whiteSpace"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_NOTATION : Datatype_QName {
        internal override void VerifySchemaValid(XmlSchema schema, XmlSchemaObject caller) {
            /*
            if (!(caller is XmlSchemaAttribute)) {
                throw new XmlSchemaException(Res.Sch_NotationNotAttr, caller);
            }
            */
            // Only datatypes that are derived from NOTATION by specifying a value for enumeration can be used in a schema.
            // Furthermore, the value of all enumeration facets must match the name of a notation declared in the current schema.                    //
            for(Datatype_NOTATION dt = this; dt != null; dt = (Datatype_NOTATION)dt.Base) {
                if (dt.Restriction != null && (dt.Restriction.Flags & RestrictionFlags.Enumeration) != 0) {
                    foreach(XmlQualifiedName notation in dt.Restriction.Enumeration) {
                        if (!schema.Notations.Contains(notation)) {
                            throw new XmlSchemaException(Res.Sch_NotationRequired, caller);
                        }
                    }
                    return;
                }
            }
            throw new XmlSchemaException(Res.Sch_NotationRequired, caller);
        }
        public override XmlTokenizedType TokenizedType { get { return XmlTokenizedType.NOTATION;}}
    }

    /*
      <xs:simpleType name="integer" id="integer">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#integer"/>
        </xs:annotation>
        <xs:restriction base="xs:decimal">
          <xs:fractionDigits value="0" fixed="true" id="integer.fractionDigits"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_integer : Datatype_decimal {
        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_integer.ParseAtomicValue(\"{0}\")", s));
            CheckTotalDigits(s);
            return XmlConvert.ToInteger(s);
        }
    }

    /*
      <xs:simpleType name="negativeInteger" id="negativeInteger">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#negativeInteger"/>
        </xs:annotation>
        <xs:restriction base="xs:nonPositiveInteger">
          <xs:maxInclusive value="-1" id="negativeInteger.maxInclusive"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_nonPositiveInteger : Datatype_integer {
        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_integer.ParseAtomicValue(\"{0}\")", s));
            CheckTotalDigits(s);
            decimal value = XmlConvert.ToInteger(s);
            if (decimal.Zero < value ) {
                throw new XmlSchemaException(Res.Sch_InvalidValue, s);
            }
            return value;
        }
    }


    /*
      <xs:simpleType name="negativeInteger" id="negativeInteger">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#negativeInteger"/>
        </xs:annotation>
        <xs:restriction base="xs:nonPositiveInteger">
          <xs:maxInclusive value="-1" id="negativeInteger.maxInclusive"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_negativeInteger : Datatype_nonPositiveInteger {
        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_integer.ParseAtomicValue(\"{0}\")", s));
            CheckTotalDigits(s);
            decimal value = XmlConvert.ToInteger(s);
            if (decimal.MinusOne < value ) {
                throw new XmlSchemaException(Res.Sch_InvalidValue, s);
            }
            return value;
        }
    }


    /*
      <xs:simpleType name="long" id="long">
        <xs:annotation>
          <xs:appinfo>
            <hfp:hasProperty name="bounded" value="true"/>
            <hfp:hasProperty name="cardinality" value="finite"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#long"/>
        </xs:annotation>
        <xs:restriction base="xs:integer">
          <xs:minInclusive value="-9223372036854775808" id="long.minInclusive"/>
          <xs:maxInclusive value="9223372036854775807" id="long.maxInclusive"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_long : Datatype_integer {
        static readonly Type atomicValueType = typeof(long);
        static readonly Type listValueType = typeof(long[]);

        protected override int Compare(object value1, object value2) {
            return ((long)value1).CompareTo(value2);
        }

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_long.ParseAtomicValue(\"{0}\")", s));
            CheckTotalDigits(s);
            return XmlConvert.ToInt64(s);
        }
    }

    /*
      <xs:simpleType name="int" id="int">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#int"/>
        </xs:annotation>
        <xs:restriction base="xs:long">
          <xs:minInclusive value="-2147483648" id="int.minInclusive"/>
          <xs:maxInclusive value="2147483647" id="int.maxInclusive"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_int : Datatype_long {
        static readonly Type atomicValueType = typeof(int);
        static readonly Type listValueType = typeof(int[]);

        protected override int Compare(object value1, object value2) {
            return ((int)value1).CompareTo(value2);
        }

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_int.ParseAtomicValue(\"{0}\")", s));
            CheckTotalDigits(s);
            return XmlConvert.ToInt32(s);
        }
    }


    /*
      <xs:simpleType name="short" id="short">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#short"/>
        </xs:annotation>
        <xs:restriction base="xs:int">
          <xs:minInclusive value="-32768" id="short.minInclusive"/>
          <xs:maxInclusive value="32767" id="short.maxInclusive"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_short : Datatype_int {
        static readonly Type atomicValueType = typeof(short);
        static readonly Type listValueType = typeof(short[]);

        protected override int Compare(object value1, object value2) {
            return ((short)value1).CompareTo(value2);
        }

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_short.ParseAtomicValue(\"{0}\")", s));
            CheckTotalDigits(s);
            return XmlConvert.ToInt16(s);
        }
    }

    /*
      <xs:simpleType name="byte" id="byte">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#byte"/>
        </xs:annotation>
        <xs:restriction base="xs:short">
          <xs:minInclusive value="-128" id="byte.minInclusive"/>
          <xs:maxInclusive value="127" id="byte.maxInclusive"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_byte : Datatype_short {
        static readonly Type atomicValueType = typeof(sbyte);
        static readonly Type listValueType = typeof(sbyte[]);

        protected override int Compare(object value1, object value2) {
            return ((sbyte)value1).CompareTo(value2);
        }

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_byte.ParseAtomicValue(\"{0}\")", s));
            CheckTotalDigits(s);
            return XmlConvert.ToSByte(s);
        }
    }

    /*
      <xs:simpleType name="nonNegativeInteger" id="nonNegativeInteger">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#nonNegativeInteger"/>
        </xs:annotation>
        <xs:restriction base="xs:integer">
          <xs:minInclusive value="0" id="nonNegativeInteger.minInclusive"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_nonNegativeInteger : Datatype_integer {
        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_integer.ParseAtomicValue(\"{0}\")", s));
            CheckTotalDigits(s);
            decimal value = XmlConvert.ToInteger(s);
            if (value < decimal.Zero) {
                throw new XmlSchemaException(Res.Sch_InvalidValue, s);
            }
            return value;
        }
    }

    /*
      <xs:simpleType name="unsignedLong" id="unsignedLong">
        <xs:annotation>
          <xs:appinfo>
            <hfp:hasProperty name="bounded" value="true"/>
            <hfp:hasProperty name="cardinality" value="finite"/>
          </xs:appinfo>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#unsignedLong"/>
        </xs:annotation>
        <xs:restriction base="xs:nonNegativeInteger">
          <xs:maxInclusive value="18446744073709551615"
            id="unsignedLong.maxInclusive"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_unsignedLong : Datatype_nonNegativeInteger {
        static readonly Type atomicValueType = typeof(ulong);
        static readonly Type listValueType = typeof(ulong[]);

        protected override int Compare(object value1, object value2) {
            return ((ulong)value1).CompareTo(value2);
        }

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_unsignedLong.ParseAtomicValue(\"{0}\")", s));
            CheckTotalDigits(s);
            return XmlConvert.ToUInt64(s);
        }
    }

    /*
      <xs:simpleType name="unsignedInt" id="unsignedInt">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#unsignedInt"/>
        </xs:annotation>
        <xs:restriction base="xs:unsignedLong">
          <xs:maxInclusive value="4294967295"
            id="unsignedInt.maxInclusive"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_unsignedInt : Datatype_unsignedLong {
        static readonly Type atomicValueType = typeof(uint);
        static readonly Type listValueType = typeof(uint[]);

        protected override int Compare(object value1, object value2) {
            return ((uint)value1).CompareTo(value2);
        }

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_unsignedInt.ParseAtomicValue(\"{0}\")", s));
            CheckTotalDigits(s);
            return XmlConvert.ToUInt32(s);
        }
    }

    /*
      <xs:simpleType name="unsignedShort" id="unsignedShort">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#unsignedShort"/>
        </xs:annotation>
        <xs:restriction base="xs:unsignedInt">
          <xs:maxInclusive value="65535"
            id="unsignedShort.maxInclusive"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_unsignedShort : Datatype_unsignedInt {
        static readonly Type atomicValueType = typeof(ushort);
        static readonly Type listValueType = typeof(ushort[]);

        protected override int Compare(object value1, object value2) {
            return ((ushort)value1).CompareTo(value2);
        }

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_unsignedShort.ParseAtomicValue(\"{0}\")", s));
            CheckTotalDigits(s);
            return XmlConvert.ToUInt16(s);
        }
    }

    /*
      <xs:simpleType name="unsignedByte" id="unsignedBtype">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#unsignedByte"/>
        </xs:annotation>
        <xs:restriction base="xs:unsignedShort">
          <xs:maxInclusive value="255" id="unsignedByte.maxInclusive"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_unsignedByte : Datatype_unsignedShort {
        static readonly Type atomicValueType = typeof(byte);
        static readonly Type listValueType = typeof(byte[]);

        protected override int Compare(object value1, object value2) {
            return ((byte)value1).CompareTo(value2);
        }

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_unsignedByte.ParseAtomicValue(\"{0}\")", s));
            CheckTotalDigits(s);
            return XmlConvert.ToByte(s);
        }
    }

    /*
      <xs:simpleType name="positiveInteger" id="positiveInteger">
        <xs:annotation>
          <xs:documentation
            source="http://www.w3.org/TR/xmlschema-2/#positiveInteger"/>
        </xs:annotation>
        <xs:restriction base="xs:nonNegativeInteger">
          <xs:minInclusive value="1" id="positiveInteger.minInclusive"/>
        </xs:restriction>
      </xs:simpleType>
    */
    internal class Datatype_positiveInteger : Datatype_nonNegativeInteger {
        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_integer.ParseAtomicValue(\"{0}\")", s));
            CheckTotalDigits(s);
            decimal value = XmlConvert.ToInteger(s);
            if (value < decimal.One) {
                throw new XmlSchemaException(Res.Sch_InvalidValue, s);
            }
            return value;
        }
    }

    /*
        XDR
    */
    internal class Datatype_doubleXdr : Datatype_double {
        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_double.ParseAtomicValue(\"{0}\")", s));
            double value = XmlConvert.ToDouble(s);
            if (double.IsInfinity(value) || double.IsNaN(value)) {
                throw new XmlSchemaException(Res.Sch_InvalidValue, s);
            }
            return value;
        }
    }

    internal class Datatype_floatXdr : Datatype_float {
        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_float.ParseAtomicValue(\"{0}\")", s));
            float value = XmlConvert.ToSingle(s);
            if (float.IsInfinity(value) || float.IsNaN(value)) {
                throw new XmlSchemaException(Res.Sch_InvalidValue, s);
            }
            return value;
        }
    }

    internal class Datatype_QNameXdr : Datatype_anyType {
        static readonly Type atomicValueType = typeof(XmlQualifiedName);
        static readonly Type listValueType = typeof(XmlQualifiedName[]);

        public override XmlTokenizedType TokenizedType { get { return XmlTokenizedType.QName;}}

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            if (s == null || s == string.Empty) {
                throw new XmlSchemaException(Res.Sch_EmptyAttributeValue);
            }
            if (nsmgr == null) {
                throw new ArgumentNullException("nsmgr");
            }
            string prefix;
            return XmlQualifiedName.Parse(s.Trim(), nameTable, nsmgr, out prefix);
        }

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}
    }

    internal class Datatype_ENUMERATION : Datatype_NMTOKEN {
        public override XmlTokenizedType TokenizedType { get { return XmlTokenizedType.ENUMERATION;}}
    }

    internal class Datatype_char : Datatype_anyType {
        static readonly Type atomicValueType = typeof(char);
        static readonly Type listValueType = typeof(char[]);

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override RestrictionFlags ValidRestrictionFlags { get { return 0; }} //XDR only

        protected override int LengthOf(object value) { throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation)); }

        protected override int Compare(object value1, object value2) {
            // this should be culture sensitive - comparing values
            return ((char)value1).CompareTo(value2);
        }

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_char.ParseAtomicValue(\"{0}\")", s));
            return XmlConvert.ToChar(s);
        }
    }

    internal class Datatype_fixed : Datatype_decimal {
        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\Datatype_fixed.ParseAtomicValue(\"{0}\")", s));
            CheckTotalDigits(s, 14 + 4);
            CheckFractionDigits(s, 4);
            return XmlConvert.ToDecimal(s);
        }
    }

    internal class Datatype_uuid : Datatype_anyType {
        static readonly Type atomicValueType = typeof(Guid);
        static readonly Type listValueType = typeof(Guid[]);

        protected override Type AtomicValueType { get { return atomicValueType; }}

        protected override Type ListValueType { get { return listValueType; }}

        protected override RestrictionFlags ValidRestrictionFlags { get { return 0; }}

        protected override int LengthOf(object value) { throw new InvalidOperationException(Res.GetString(Res.Xml_InvalidOperation)); }

        protected override int Compare(object value1, object value2) {
            return ((Guid)value1).Equals(value2) ? 0 : -1;
        }

        protected override object ParseAtomicValue(string s, XmlNameTable nameTable, XmlNamespaceManager nsmgr) {
            //Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, string.Format("\t\t\tDatatype_uuid.ParseAtomicValue(\"{0}\")", s));
            return XmlConvert.ToGuid(s);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\constraintstruct.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConstraintStruct.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Xml.Schema {
    using System;
    using System.Text;
    using System.Collections;
    using System.Diagnostics;
    using System.Xml.XPath;

    internal sealed class ConstraintStruct {
        // for each constraint
        internal CompiledIdentityConstraint constraint;     // pointer to constraint
        internal SelectorActiveAxis axisSelector;
        internal ArrayList  axisFields;                     // Add tableDim * LocatedActiveAxis in a loop
        internal Hashtable  qualifiedTable;                  // Checking confliction
        internal ArrayList  keyrefTables;                    // several keyref tables having connections to this one is possible
        private int tableDim;                               // dimension of table = numbers of fields;

        internal int TableDim {
            get { return this.tableDim; }
        }

        internal ConstraintStruct (CompiledIdentityConstraint constraint) {
            this.constraint = constraint;
            this.tableDim = constraint.Fields.Length;
            this.axisFields = new ArrayList();              // empty fields
            this.axisSelector = new SelectorActiveAxis (constraint.Selector, this);
            this.qualifiedTable = new Hashtable();
        
        }

    } 

    // ActiveAxis plus the location plus the state of matching in the constraint table : only for field
    internal class LocatedActiveAxis : ActiveAxis {
        private int         column;                     // the column in the table (the field sequence)
        internal bool       isMatched;                  // if it's matched, then fill value in the validator later
        internal KeySequence Ks;                        // associated with a keysequence it will fills in

        internal int Column {
            get { return this.column; }
        }

        internal LocatedActiveAxis (Asttree astfield, KeySequence ks, int column) : base (astfield) {
            this.Ks = ks;
            this.column = column;
            this.isMatched = false;
        }

        internal void Reactivate(KeySequence ks) {
            Reactivate();
            this.Ks = ks;
        }
        
    }

    // exist for optimization purpose
    // ActiveAxis plus
    // 1. overload endelement function from parent to return result
    // 2. combine locatedactiveaxis and keysequence more closely
    // 3. enable locatedactiveaxis reusing (the most important optimization point)
    // 4. enable ks adding to hashtable right after moving out selector node (to enable 3)
    // 5. will modify locatedactiveaxis class accordingly
    // 6. taking care of updating ConstraintStruct.axisFields
    // 7. remove constraintTable from ConstraintStruct
    // 8. still need centralized locatedactiveaxis for movetoattribute purpose
    internal class SelectorActiveAxis : ActiveAxis {
        private ConstraintStruct cs;            // pointer of constraintstruct, to enable 6
        private ArrayList KSs;                  // stack of KSStruct, will not become less 
        private int KSpointer = 0;              // indicate current stack top (next available element);
        
        public bool EmptyStack {
            get { return KSpointer == 0; }
        }
        
        public int lastDepth {
            get { return (KSpointer == 0) ? -1 : ((KSStruct) KSs[KSpointer - 1]).depth; } 
        }
        
        public SelectorActiveAxis(Asttree axisTree, ConstraintStruct cs) : base(axisTree) {
            this.KSs = new ArrayList();
            this.cs = cs;
        }
        
        public override bool EndElement(string localname, string URN) {
            base.EndElement(localname, URN);
//          Console.WriteLine ("KSpointer = {0}; current depth = {1}; last depth = {2}", KSpointer, this.CurrentDepth, lastDepth);
            if (KSpointer > 0 && this.CurrentDepth == lastDepth) {
                return true;
                // next step PopPS, and insert into hash
            }
            return false;
        }
        
        // update constraintStruct.axisFields as well, if it's new LocatedActiveAxis
        public int PushKS (int errline, int errcol) {
            // new KeySequence each time
            KeySequence ks = new KeySequence(cs.TableDim, errline, errcol);

            // needs to clear KSStruct before using
            KSStruct kss;
            if (KSpointer < KSs.Count) {
                // reuse, clear up KSs.KSpointer
                kss = (KSStruct) KSs[KSpointer];
                kss.ks = ks;
                // reactivate LocatedActiveAxis
                for (int i = 0; i < cs.TableDim; i ++) {
                    kss.fields[i].Reactivate(ks);               // reassociate key sequence
                }
            }
            else { // "==", new
                kss = new KSStruct(ks, cs.TableDim);
                for (int i = 0; i < cs.TableDim; i ++) {
                    kss.fields[i] = new LocatedActiveAxis (cs.constraint.Fields[i], ks, i);
                    cs.axisFields.Add (kss.fields[i]);          // new, add to axisFields
                }
                KSs.Add(kss);
            }
            
            kss.depth = this.CurrentDepth - 1;
            
            return (KSpointer ++);
        }
    
        public KeySequence PopKS () {
            return ((KSStruct)KSs[-- KSpointer]).ks;
        }
        
    }
    
    internal class KSStruct {
        public int depth;                       // depth of selector when it matches
        public KeySequence ks;                  // ks of selector when it matches and assigned -- needs to new each time
        public LocatedActiveAxis[] fields;      // array of fields activeaxis when it matches and assigned
        
        public KSStruct(KeySequence ks, int dim) {
            this.ks = ks;
            this.fields = new LocatedActiveAxis[dim];
        }
    }
    
    internal class TypedObject {

        private class DecimalStruct {
            bool isDecimal = false;         // rare case it will be used...
            decimal[] dvalue;               // to accelerate equals operation.  array <-> list

            public bool IsDecimal {
                get { return this.isDecimal; }
                set { this.isDecimal = value; }
            }

            public int Dim {
                get { return this.dvalue.Length; }
            }

            public decimal[] Dvalue {
                get { return this.dvalue; }
                set { this.dvalue = value; }
            }
            public DecimalStruct () {
                this.dvalue = new decimal[1];
            }
            //list
            public DecimalStruct (int dim) {
                this.dvalue = new decimal[dim];
            }
        }

        DecimalStruct dstruct = null; 
        object ovalue;
        string svalue;      // only for output
        XmlSchemaDatatype xsdtype;
        int dim = 1; 
        bool isList = false;

        public int Dim {
            get { return this.dim; }
        }

        public bool IsList {
            get { return this.isList; }
        }

        public bool IsDecimal {
            get { 
                Debug.Assert (this.dstruct != null);
                return this.dstruct.IsDecimal; 
            }
        }
        public decimal[] Dvalue {
            get {
                Debug.Assert (this.dstruct != null);
                return this.dstruct.Dvalue; 
            }
        }
        
        public object Value {
            get {return ovalue; }
            set {ovalue = value; }
        }

        public XmlSchemaDatatype Type {
            get {return xsdtype; }
            set {xsdtype = value; }
        }

        public TypedObject (object obj, string svalue, XmlSchemaDatatype xsdtype) {
            this.ovalue = obj;
            this.svalue = svalue;
            this.xsdtype = xsdtype;
            if (xsdtype.Variety == XmlSchemaDatatypeVariety.List) {
                this.isList = true;
                this.dim = ((Array)obj).Length;
            }
        }

        public override string ToString() {
            // only for exception
            return this.svalue;
        }

        public void SetDecimal () {

            if (this.dstruct != null) {
                return; 
            }

            //list
            // can't use switch-case for type
            // from derived to base for safe, does it really affect?
            if (this.isList) {
                this.dstruct = new DecimalStruct(this.dim);
                // Debug.Assert(!this.IsDecimal);
                if ((xsdtype is Datatype_byte) || (xsdtype is Datatype_unsignedByte)
                    ||(xsdtype is Datatype_short) ||(xsdtype is Datatype_unsignedShort)
                    ||(xsdtype is Datatype_int) ||(xsdtype is Datatype_unsignedInt)
                    ||(xsdtype is Datatype_long) ||(xsdtype is Datatype_unsignedLong)
                    ||(xsdtype is Datatype_decimal) || (xsdtype is Datatype_integer) 
                     ||(xsdtype is Datatype_positiveInteger) || (xsdtype is Datatype_nonNegativeInteger) 
                     ||(xsdtype is Datatype_negativeInteger) ||(xsdtype is Datatype_nonPositiveInteger)) {
                    for (int i = 0; i < this.dim; i ++) {
                        this.dstruct.Dvalue[i] = Convert.ToDecimal (((Array) this.ovalue).GetValue(i));
                    }
                    this.dstruct.IsDecimal = true;
                }
            }
            else {  //not list
                this.dstruct = new DecimalStruct();
                if ((xsdtype is Datatype_byte) || (xsdtype is Datatype_unsignedByte)
                    ||(xsdtype is Datatype_short) ||(xsdtype is Datatype_unsignedShort)
                    ||(xsdtype is Datatype_int) ||(xsdtype is Datatype_unsignedInt)
                    ||(xsdtype is Datatype_long) ||(xsdtype is Datatype_unsignedLong)
                    ||(xsdtype is Datatype_decimal) || (xsdtype is Datatype_integer) 
                     ||(xsdtype is Datatype_positiveInteger) || (xsdtype is Datatype_nonNegativeInteger) 
                     ||(xsdtype is Datatype_negativeInteger) ||(xsdtype is Datatype_nonPositiveInteger)) {
                   //possibility of list of length 1.
                    this.dstruct.Dvalue[0] = Convert.ToDecimal (this.ovalue);
                    this.dstruct.IsDecimal = true;
                }
            }
        }

        private bool ListDValueEquals (TypedObject other) {
            for (int i = 0; i < this.Dim; i ++) {
                if (this.Dvalue[i] != other.Dvalue[i]) {
                    return false;
                }                
            }
            return true;
        }

        public bool Equals (TypedObject other) {
            // ? one is list with one member, another is not list -- still might be equal
            if (this.Dim != other.Dim) {
                return false;
            }

            if (this.Type != other.Type) {              
                bool thisfromother = this.Type.IsDerivedFrom (other.Type); 
                bool otherfromthis = other.Type.IsDerivedFrom (this.Type);

                if (! (thisfromother || otherfromthis)) {       // second normal case
                    return false;
                }

                if (thisfromother) {
                    // can't use cast and other.Type.IsEqual (value1, value2)
                    other.SetDecimal();
                    if (other.IsDecimal) {
                        this.SetDecimal();
               return this.ListDValueEquals(other);                    
              }
                    // deal else (not decimal) in the end 
                }
                else {
                    this.SetDecimal();
                    if (this.IsDecimal) {
                        other.SetDecimal();
                        return this.ListDValueEquals(other);
                    }
                    // deal else (not decimal) in the end 
                }
            }

            // not-Decimal derivation or type equal
            if ((! this.IsList) && (! other.IsList)) {      // normal case
                return this.Value.Equals (other.Value);
            }
            else if ((this.IsList) && (other.IsList)){      // second normal case
                for (int i = 0; i < this.Dim; i ++) {
                    if (! ((Array)this.Value).GetValue(i).Equals(((Array)other.Value).GetValue(i))) {
                        return false;
                    }
                }
                return true;
            }
            else if (((this.IsList) && (((Array)this.Value).GetValue(0).Equals(other.Value)))
                || ((other.IsList) && (((Array)other.Value).GetValue(0).Equals(this.Value)))) { // any possibility?
                return true;
            }

            return false;
        }
    }

    internal class KeySequence {
        TypedObject[] ks;
        int dim;
        int hashcode = -1;
        int posline, poscol;            // for error reporting

        internal KeySequence (int dim, int line, int col) {
            Debug.Assert(dim > 0);
            this.dim = dim;
            this.ks = new TypedObject[dim];
            this.posline = line;
            this.poscol = col;
        }

        public int PosLine {
            get { return this.posline; }
        }

        public int PosCol {
            get { return this.poscol; }
        }

        public KeySequence(TypedObject[] ks) {
            this.ks = ks;
            this.dim = ks.Length;
            this.posline = this.poscol = 0;
        }

        public object this[int index] {
            get {
                object result = ks[index];
                return result;
            }
            set {
                ks[index] = (TypedObject) value;
            } 
        }

        // return true if no null field
        internal bool IsQualified() {
            foreach (TypedObject tobj in this.ks) {
                if ((tobj == null) || (tobj.Value == null)) return false;
            }
            return true;
        }

        // it's not directly suit for hashtable, because it's always calculating address
        public override int GetHashCode() {
            if (hashcode != -1) {
                return hashcode;
            }
            hashcode = 0;  // indicate it's changed. even the calculated hashcode below is 0
            for (int i = 0; i < this.ks.Length; i ++) {
                // extract its primitive value to calculate hashcode
                // decimal is handled differently to enable among different CLR types
                this.ks[i].SetDecimal();
                if (this.ks[i].IsDecimal) {
                    for (int j = 0 ; j < this.ks[i].Dim ; j ++) {
                        hashcode += this.ks[i].Dvalue[j].GetHashCode();
                    }
                }
                else if (this.ks[i].Value is Array) {
                    for (int j = 0 ; j < ((Array) this.ks[i].Value).Length ; j ++) {
                        hashcode += ((Array) this.ks[i].Value).GetValue(j).GetHashCode();
                    }
                }
                else {
                    hashcode += this.ks[i].Value.GetHashCode();
                }
            }
            return hashcode;
        }

        // considering about derived type
        public override bool Equals(object other) {
            // each key sequence member can have different type
            KeySequence keySequence = (KeySequence)other;
            for (int i = 0; i < this.ks.Length; i ++) {
                if (! this.ks[i].Equals (keySequence.ks[i])) {
                    return false;
                }
            }
            return true;
        }

        public override string ToString() {
            StringBuilder sb = new StringBuilder();
            sb.Append(this.ks[0].ToString());
            for (int i = 1; i < this.ks.Length; i ++) {
                sb.Append(" ");
                sb.Append(this.ks[i].ToString());
            }
            return sb.ToString();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xml\system\newxml\schema\compiledcontentmodel.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompiledContentModel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Xml.Schema {

    using System;
    using System.Collections;
    using System.Text;
    using System.ComponentModel;

#if DEBUG
    using System.Diagnostics;
#endif


    /*
     * This class represents the content model definition for a given XML element.
     * The content model is defined in the element declaration in the SchemaInfo;
     * for example, (a,(b|c)*,d).
     * The content model is stored in an expression tree of <code>ContentNode</code> objects
     * for use by the XML parser during validation.
     */

    internal sealed class CompiledContentModel {
        internal enum Type {
            Any,
            ElementOnly,
            Empty,
            Mixed,
            Text
        };

        private ArrayList   terminalNodes;    // terminal nodes
        private Hashtable   symbolTable;      // unique terminal names
        private ArrayList   symbols;          // symbol array

        private bool        isOpen;
        private Hashtable   nodeTable;
        internal ContentNode contentNode;          // content model points to syntax tree
        private ArrayList   dtrans;           // transition table
        private CompiledContentModel.Type contentType;             // content type
        private bool        isPartial;          // whether the closure applies to partial
                                               // or the whole node that is on top of the stack
        private Stack       stack;            // parsing context
        private SchemaNames    schemaNames;
        private TerminalNode endNode;
        private bool        abnormalContent;             // true: has wildcard or range
        private BitSet      allElementsSet = null;
        private bool        isAllEmptiable;
        private bool        isCompiled = false;

        internal CompiledContentModel( SchemaNames names ) {
            schemaNames = names;
            endNode = null;
        }

        internal bool IsOpen {
            get { return isOpen;}
            set { isOpen = value;}
        }

        internal CompiledContentModel.Type ContentType {
            get { return contentType; }
            set { contentType = value; }
        }

        private bool IsAllElements {
            get { return allElementsSet != null; }
        }

        internal bool IsEmptiable {
            get {
                switch (contentType) {
                    case CompiledContentModel.Type.Empty:
                    case CompiledContentModel.Type.Any:
                        return true;
                    case CompiledContentModel.Type.Mixed:
                    case CompiledContentModel.Type.ElementOnly:
                        if (IsAllElements) {
                            return isAllEmptiable || allElementsSet.IsEmpty;
                        }
                        else {
                            return contentNode == null || ((InternalNode)contentNode).LeftNode.Nullable();                
                        }
                    default:
                    case CompiledContentModel.Type.Text:
                        return false;
                }
            }
        }

        internal bool IsCompiled {
            get { return isCompiled;}
            set { isCompiled = value;}
        }

        //
        // methods for building a new content model
        //

        internal void    Start() {
            terminalNodes = new ArrayList(16);
            symbolTable = new Hashtable();
            symbols = new ArrayList(16);
            stack = new Stack(16);
        }

        internal void    Finish(ValidationEventHandler eventHandler, bool compile) {
            stack = null;
            IsCompiled = !abnormalContent && compile;
            if (contentNode == null)
                return;

#if DEBUG
            StringBuilder bb = new StringBuilder();
            contentNode.Dump(bb);
            Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, "\t\t\tContent: (" + bb.ToString() + ")");
#endif

            // add end node
            endNode = NewTerminalNode(XmlQualifiedName.Empty);
            contentNode = new InternalNode(contentNode, endNode, ContentNode.Type.Sequence);
            ((InternalNode)contentNode).LeftNode.ParentNode = contentNode;
            endNode.ParentNode = contentNode;

            if (!IsCompiled) {
                CheckXsdDeterministic(eventHandler);
                return;
            }

            if (nodeTable == null)
                nodeTable = new Hashtable();

            // calculate followpos
            int terminals = terminalNodes.Count;
            BitSet[] followpos = new BitSet[terminals];
            for (int i = 0; i < terminals; i++) {
                followpos[i] = new BitSet(terminals);
            }
            contentNode.CalcFollowpos(followpos);

            // state table
            ArrayList Dstates = new ArrayList(16);
            // transition table
            dtrans = new ArrayList(16);
            // lists unmarked states
            ArrayList unmarked = new ArrayList(16);
            // state lookup table
            Hashtable statetable = new Hashtable();

            BitSet empty = new BitSet(terminals);
            statetable.Add(empty, -1);

            // start with firstpos at the root
            BitSet set = contentNode.Firstpos(terminals);
            statetable.Add(set, Dstates.Count);
            unmarked.Add(set);
            Dstates.Add(set);

            int[] a = new int[symbols.Count + 1];
            dtrans.Add(a);
            if (set.Get(endNode.Pos)) {
                a[symbols.Count] = 1;   // accepting
            }

            // current state processed
            int state = 0;

            // check all unmarked states
            while (unmarked.Count > 0) {
                int[] t = (int[])dtrans[state];

                set = (BitSet)unmarked[0];
                CheckDeterministic(set, terminals, eventHandler);
                unmarked.RemoveAt(0);

                // check all input symbols
                for (int sym = 0; sym < symbols.Count; sym++) {
                    XmlQualifiedName n = (XmlQualifiedName)symbols[sym];
                    BitSet newset = new BitSet(terminals);

                    // if symbol is in the set add followpos to new set
                    for (int i = 0; i < terminals; i++) {
                        if (set.Get(i) && n.Equals(((TerminalNode)terminalNodes[i]).Name)) {
                            newset.Or(followpos[i]);
                        }
                    }

                    Object lookup = statetable[newset];
                    // this state will transition to
                    int transitionTo;
                    // if new set is not in states add it
                    if (lookup == null) {
                        transitionTo = Dstates.Count;
                        statetable.Add(newset, transitionTo);
                        unmarked.Add(newset);
                        Dstates.Add(newset);
                        a = new int[symbols.Count + 1];
                        dtrans.Add(a);
                        if (newset.Get(endNode.Pos)) {
                            a[symbols.Count] = 1;   // accepting
                        }
                    }
                    else {
                        transitionTo = (int)lookup;
                    }
                    // set the transition for the symbol
                    t[sym] = transitionTo;
                }
                state++;
            }

            nodeTable = null;
        }

        private void CheckDeterministic(BitSet set, int t, ValidationEventHandler eventHandler) {
            nodeTable.Clear();
            for (int i = 0; i < t; i++) {
                if (set.Get(i)) {
                    XmlQualifiedName n = ((TerminalNode)terminalNodes[i]).Name;
                    if (!n.IsEmpty) {
                        if (nodeTable[n] == null) {
                            nodeTable.Add(n, n);
                        }
                        else {
                            if (eventHandler != null) {
                                eventHandler(this, new ValidationEventArgs(new XmlSchemaException(Res.Sch_NonDeterministic,n.ToString())));
                            }
                            else {
                                throw new XmlSchemaException(Res.Sch_NonDeterministic,n.ToString());
                            }
                        }
                    }
                }
            }
        }

        internal void    OpenGroup() {
            stack.Push(null);
        }

        internal void    CloseGroup() {
            ContentNode n = (ContentNode)stack.Pop();
            if (n == null) {
                return;
            }
            if (stack.Count == 0) {
                if (n.NodeType == ContentNode.Type.Terminal) {
                    TerminalNode t = (TerminalNode)n;
                    if (t.Name == schemaNames.QnPCData) {
                        // we had a lone (#PCDATA) which needs to be
                        // wrapped in a STAR node.
                        ContentNode n1 = new InternalNode(n, null, ContentNode.Type.Star);
                        n.ParentNode = n1;
                        n = n1;
                    }
                }
                contentNode = n;
                isPartial = false;
            }
            else {
                // some collapsing to do...
                InternalNode inNode = (InternalNode)stack.Pop();
                if (inNode != null) {
                    inNode.RightNode = n;
                    n.ParentNode = inNode;
                    n = inNode;
                    isPartial = true;
                }
                else {
                    isPartial = false;
                }

                stack.Push(n);
            }
        }

        internal void AddTerminal(XmlQualifiedName qname, String prefix, ValidationEventHandler eventHandler) {
            if (schemaNames.QnPCData.Equals(qname)) {
                nodeTable = new Hashtable();
            }
            else if (nodeTable != null) {
                if (nodeTable.ContainsKey(qname)) {
                    if (eventHandler != null) {
                        eventHandler(
                            this,
                            new ValidationEventArgs(
                                new XmlSchemaException(Res.Sch_DupElement, qname.ToString())
                            )
                        );
                    }
                    //notice: should not return here!
                }
                else {
                    nodeTable.Add(qname, qname);
                }
            }

            ContentNode n = NewTerminalNode(qname);
            if (stack.Count > 0) {
                InternalNode inNode = (InternalNode)stack.Pop();
                if (inNode != null) {
                    inNode.RightNode = n;
                    n.ParentNode = inNode;
                    n = inNode;
                }
            }
            stack.Push( n );
            isPartial = true;
        }

        internal void    AddAny(XmlSchemaAny any) {
            ContentNode n = new AnyNode(any);
            if (stack.Count > 0) {
                InternalNode inNode = (InternalNode)stack.Pop();
                if (inNode != null) {
                    inNode.RightNode = n;
                    n.ParentNode = inNode;
                    n = inNode;
                }
            }
            stack.Push( n );
            isPartial = true;
            abnormalContent = true;
        }

        internal void StartAllElements(int count) {
            allElementsSet = new BitSet(count);
        }

        internal bool AddAllElement(XmlQualifiedName qname, bool required) {
            if (symbolTable[qname] == null) {
                int i = symbolTable.Count;
                if (required) {
                    allElementsSet.Set(i);
                }
                symbolTable.Add(qname, i);
                symbols.Add(qname);
                return true;
            }
            else {
                return false;
            }
        }

        internal void    AddChoice() {
            ContentNode n = (ContentNode)stack.Pop();
            ContentNode inNode = new InternalNode(n, null, ContentNode.Type.Choice);
            n.ParentNode = inNode;
            stack.Push(inNode);
        }

        internal void    AddSequence() {
            ContentNode n = (ContentNode)stack.Pop();
            ContentNode inNode = new InternalNode(n, null, ContentNode.Type.Sequence);
            n.ParentNode = inNode;
            stack.Push(inNode);
        }

        internal void    Star() {
            Closure(ContentNode.Type.Star);
        }

        internal void    Plus() {
            Closure(ContentNode.Type.Plus);
        }

        internal void    QuestionMark() {
            if (IsAllElements) {
                isAllEmptiable = true;
            }
            else {
                Closure(ContentNode.Type.Qmark);
            }
        }

        internal void    Closure(ContentNode.Type type) {
            ContentNode n;

            if (stack.Count > 0) {
                InternalNode n1;
                n = (ContentNode)stack.Pop();
                if (isPartial &&
                    n.NodeType != ContentNode.Type.Terminal &&
                    n.NodeType != ContentNode.Type.Any) {
                    // need to reach in and wrap _pRight hand side of element.
                    // and n remains the same.
                    InternalNode inNode = (InternalNode)n;
                    n1 = new InternalNode(inNode.RightNode, null, type);
                    n1.ParentNode = n;
                    if (inNode.RightNode != null)
                        inNode.RightNode.ParentNode = n1;
                    inNode.RightNode = n1;
                }
                else {
                    // wrap terminal or any node
                    n1 = new InternalNode(n, null, type);
                    n.ParentNode = n1;
                    n = n1;
                }
                stack.Push(n);
            }
            else {
                // wrap whole content
                n = new InternalNode(contentNode, null, type);
                contentNode.ParentNode = n;
                contentNode = n;
            }
        }

        internal void     MinMax(decimal min, decimal max) {
            ContentNode n;

            if (stack.Count > 0) {
                InternalNode n1;
                n = (ContentNode)stack.Pop();
                if (isPartial &&
                    n.NodeType != ContentNode.Type.Terminal &&
                    n.NodeType != ContentNode.Type.Any) {
                    // need to reach in and wrap _pRight hand side of element.
                    // and n remains the same.
                    InternalNode inNode = (InternalNode)n;
                    n1 = new MinMaxNode(inNode.RightNode, min, max);
                    n1.ParentNode = n;
                    if (inNode.RightNode != null)
                        inNode.RightNode.ParentNode = n1;
                    inNode.RightNode = n1;
                }
                else {
                    // wrap terminal or any node
                    n1 = new MinMaxNode(n, min, max);
                    n.ParentNode = n1;
                    n = n1;
                }
                stack.Push(n);
            }
            else {
                // wrap whole content
                n = new MinMaxNode(contentNode, min, max);
                contentNode.ParentNode = n;
                contentNode = n;
            }

            abnormalContent = true;
        }

        internal bool HasMatched(ValidationState context) {
            if (IsAllElements) {
                if(isAllEmptiable && context.AllElementsSet.IsEmpty) {
                    return true;
                }
                else {
                    return context.AllElementsSet.HasAllBits(this.allElementsSet);
                }
            }

            if (!IsCompiled) {
                // MIXED or ELEMENT
                int NodeMatched = context.HasNodeMatched;
                InternalNode inNode = (InternalNode)context.CurrentNode;
                if (inNode == contentNode) {
                    return NodeMatched == 1 || inNode.LeftNode.Nullable();
                }
                while (inNode != contentNode) {
                    switch (inNode.NodeType) {
                        case ContentNode.Type.Sequence:
                            if (( (NodeMatched == 0) && (!inNode.LeftNode.Nullable() || !inNode.RightNode.Nullable()) ) ||
                                ( (NodeMatched == 1) && !inNode.RightNode.Nullable() )) {
                                return false;
                            }
                            break;

                        case ContentNode.Type.Choice:
                            if ((NodeMatched == 0) && !inNode.LeftNode.Nullable() && !inNode.LeftNode.Nullable())
                                return false;
                            break;

                        case ContentNode.Type.Plus:
                            if ((NodeMatched == 0) && !inNode.LeftNode.Nullable())
                                return false;
                            break;

                        case ContentNode.Type.MinMax: {
                                int min;
                                MinMaxValues mm = (MinMaxValues)context.MinMaxValues[inNode];
                                if (mm == null)
                                    min = ((MinMaxNode)inNode).Min;
                                else
                                    min = mm.Min;
                                if ((min > 0) && !inNode.LeftNode.Nullable())
                                    return false;
                                break;
                            }

                        case ContentNode.Type.Star:
                        case ContentNode.Type.Qmark:
                        default:
                            break;

                    } // switch

                    NodeMatched = (((InternalNode)inNode.ParentNode).LeftNode == inNode) ? 1 : 2;
                    inNode = (InternalNode)inNode.ParentNode;
                }

                return(NodeMatched == 1);
            }
            else {
                return context.HasMatched;
            }
        }

        internal void InitContent(ValidationState context) {
            if (IsAllElements) {
                context.AllElementsSet = new BitSet(this.allElementsSet.Count);
                return;
            }

            if (!IsCompiled) {
                context.CurrentNode = contentNode;
                context.MinMaxValues = null;
                context.HasNodeMatched = 0;
                context.HasMatched = (contentType != CompiledContentModel.Type.Mixed) && (contentType != CompiledContentModel.Type.ElementOnly);
            }
            else {
                context.State = 0;
                if (dtrans != null && dtrans.Count > 0) {
                    context.HasMatched = ((int[])dtrans[0])[symbols.Count] > 0;
                }
                else {
                    context.HasMatched = true;
                }
            }
        }

        internal void CheckContent(ValidationState context, XmlQualifiedName qname, ref XmlSchemaContentProcessing processContents) {
#if DEBUG
            Debug.WriteLineIf(CompModSwitches.XmlSchema.TraceVerbose, String.Format("\t\t\tSchemaContentModel.CheckContent({0}) in \"{1}\"", "\"" + qname.ToString() + "\"", context.Name));
#endif
            XmlQualifiedName n = qname.IsEmpty ? (schemaNames == null ? XmlQualifiedName.Empty : schemaNames.QnPCData) : qname;
            Object lookup;

            if (context.IsNill) {
                throw new XmlSchemaException(Res.Sch_ContentInNill, context.Name.ToString());
            }

            switch(contentType) {
                case CompiledContentModel.Type.Any:
                    context.HasMatched = true;
                    return;

                case CompiledContentModel.Type.Empty:
                    goto error;
                
                case CompiledContentModel.Type.Text:
                    if(qname.IsEmpty) 
                        return;
                    else
                        goto error;

                case CompiledContentModel.Type.Mixed:
                    if (qname.IsEmpty)
                        return;
                    break;

                case CompiledContentModel.Type.ElementOnly:
                    if (qname.IsEmpty)
                        goto error;
                    break;

                default:
                    break;
            }
    
            if (IsAllElements) {
                lookup = symbolTable[n];
                if (lookup != null) {
                    int index = (int)lookup;
                    if (context.AllElementsSet.Get(index)) {
                        throw new XmlSchemaException(Res.Sch_AllElement, qname.Name);
                    }
                    else {
                        context.AllElementsSet.Set(index);
                    }
                }
                else {
                    goto error;
                }
                return;
            }
            if (!IsCompiled) {
                CheckXsdContent(context, qname, ref processContents);
                return;
            }

            lookup = symbolTable[n];

            if (lookup != null) {
                int sym = (int)lookup;
                if (sym != -1 && dtrans != null) {
                    int state = ((int[])dtrans[context.State])[sym];
                    if (state != -1) {
                        context.State = state;
                        context.HasMatched = ((int[])dtrans[context.State])[symbols.Count] > 0;
                        return;
                    }
                }
            }

            if (IsOpen && context.HasMatched) {
                // XDR allows any well-formed contents after matched.
                return;
            }

            //
            // report error
            //
            context.NeedValidateChildren = false;

            error:
        
            ArrayList v = null;
            if (dtrans != null) {
                v = ExpectedElements(context.State, context.AllElementsSet);
            }
            if (v == null || v.Count == 0) {
                if (!(qname.IsEmpty)) {
                    throw new XmlSchemaException(Res.Sch_InvalidElementContent, new string[] { context.Name.ToString(), n.ToString() });
                }
                else {
                    if (n.Name.Equals("#PCDATA")) {
                        if(contentType == CompiledContentModel.Type.Empty)
                            throw new XmlSchemaException(Res.Sch_InvalidTextWhiteSpace);
                        else
                            throw new XmlSchemaException(Res.Sch_InvalidTextInElement,context.Name.ToString());
                    }
                    else {
                        throw new XmlSchemaException(Res.Sch_InvalidContent, context.Name.ToString());    
                    }
                }
            }
            else {
                StringBuilder builder = new StringBuilder();
                for (int i = 0; i < v.Count; ++i) {
                    builder.Append(v[i].ToString());
                    if (i+1 < v.Count)
                        builder.Append(" ");
                }
                if (qname.IsEmpty) {
                    if (n.Name.Equals("#PCDATA")) 
                        throw new XmlSchemaException(Res.Sch_InvalidTextInElementExpecting, new string[] { context.Name.ToString(), builder.ToString() } );
                    else
                        throw new XmlSchemaException(Res.Sch_InvalidContentExpecting, new string[] { context.Name.ToString(), builder.ToString() } );
                }
                else {
                    throw new XmlSchemaException(Res.Sch_InvalidElementContentExpecting, new string[] { context.Name.ToString(), n.ToString(), builder.ToString() });
                }
            }
        }

        private void CheckXsdContent(ValidationState context, XmlQualifiedName qname, ref XmlSchemaContentProcessing processContents) {
            ContentNode cnode = context.CurrentNode;
            Object lookup = symbolTable[qname];
            int terminals = symbols.Count;
            MinMaxNode ln;
            InternalNode inNode;
            MinMaxValues mm;
            int NodeMatched = context.HasNodeMatched;

            while (true) {
                switch (cnode.NodeType) {
                    case ContentNode.Type.Any:
                    case ContentNod