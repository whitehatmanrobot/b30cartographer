e = PKCS_7_ASN_ENCODING;
    //csmp.pSigningCert = NULL;
    csmp.HashAlgorithm = DigestAlgorithm;
    //csmp.cMsgCert = 0;
    //csmp.rgpMsgCert = NULL;
    //csmp.cMsgCrl = 0;
    //csmp.rgpMsgCrl = NULL;

    hr = pkcsBuildCRLChain(
		    pCAContext,
		    pbCertLeaf,
		    cbCertLeaf,
		    fIncludeCRLs,
		    &csmp.cMsgCert,
		    NULL,
		    &csmp.rgpMsgCert,
		    &csmp.cMsgCrl,
		    NULL,
		    &csmp.rgpMsgCrl);
    _JumpIfError(hr, error, "pkcsBuildCRLChain");

    if (!myCryptSignMessage(
			&csmp,
			pbToBeSigned,
			cbToBeSigned,
			CERTLIB_USE_COTASKMEMALLOC,
			ppbCertChain,
			pcbCertChain))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptSignMessage");
    }
    hr = S_OK;

error:
    pkcsFreeCRLChain(
		csmp.cMsgCert,
		NULL,
		csmp.rgpMsgCert,
		csmp.cMsgCrl,
		NULL,
		csmp.rgpMsgCrl);
    return(hr);
}


HRESULT
PKCSGetCACert(
    IN LONG PropId,	// CR_PROP_*
    IN DWORD iCert,
    OUT BYTE **ppbCACert,
    OUT DWORD *pcbCACert)
{
    HRESULT hr;
    DWORD State;
    CERT_CONTEXT const *pcc = NULL;
    CACROSSCTX *pCACross;

    switch (PropId)
    {
	case CR_PROP_CAFORWARDCROSSCERT:
	case CR_PROP_CABACKWARDCROSSCERT:
	    hr = pkcsMapCrossCertIndex(
			    CR_PROP_CAFORWARDCROSSCERT == PropId,
			    iCert,
			    &iCert,
			    &State);
	    _JumpIfError(hr, error, "pkcsMapCrossCertIndex");

	    // Now we know iCert is a valid Cross Cert Index:

	    pCACross = CR_PROP_CAFORWARDCROSSCERT == PropId?
			    g_aCACrossForward : g_aCACrossBackward;
	    if (NULL != pCACross)
	    {
		pcc = pCACross[iCert].pccCACross;
	    }
	    break;

	case CR_PROP_CASIGCERT:
	    hr = PKCSMapCertIndex(iCert, &iCert, &State);
	    _JumpIfError(hr, error, "PKCSMapCertIndex");

	    // Now we know iCert is a valid Cert Index:

	    pcc = g_aCAContext[iCert].pccCA;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropId");

	    break;
    }
    if (NULL == pcc)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "invalid cert");
    }
    *pcbCACert = pcc->cbCertEncoded;
    *ppbCACert = pcc->pbCertEncoded;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
PKCSGetCAChain(
    IN DWORD iCert,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbCAChain, // CoTaskMem*
    OUT DWORD *pcbCAChain)
{
    HRESULT hr;
    DWORD State;
    CACTX *pCAContext;

    hr = PKCSMapCertIndex(iCert, &iCert, &State);
    _JumpIfError(hr, error, "PKCSMapCertIndex");

    // Now we know iCert is a valid Cert Index:

    pCAContext = &g_aCAContext[iCert];
    if (NULL == pCAContext->pccCA)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "invalid cert");
    }
    hr = pkcsEncodeCertChain(
			pCAContext,
			NULL,				  // pbCertLeaf
			0,				  // cbCertLeaf
			pCAContext->pccCA->pbCertEncoded, // pbToBeSigned
			pCAContext->pccCA->cbCertEncoded, // cbToBeSigned
			fIncludeCRLs,
			ppbCAChain,			  // CoTaskMem*
			pcbCAChain);
    _JumpIfError(hr, error, "PKCSEncodeCertChain");

error:
    return(hr);
}


HRESULT
pkcsAcquireKey(
    OPTIONAL IN WCHAR const *pwszKeyContainer,
    OUT HCRYPTPROV *phProv)
{
    HRESULT hr;

    *phProv = NULL;
    if (!CryptAcquireContext(
			phProv,
			pwszKeyContainer,
			g_pwszXchgProvName,
			g_dwXchgProvType,
			g_CryptSilent |
			    (g_fXchgMachineKeyset? CRYPT_MACHINE_KEYSET : 0)))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
pkcsSyncRegTimePeriod(
    IN WCHAR const *pwszRegPeriodCount,
    IN WCHAR const *pwszRegPeriodString,
    IN OUT enum ENUM_PERIOD *penumCAXchgValidityPeriod,
    IN OUT LONG *plCAXchgValidityPeriodCount,
    IN FILETIME const *pft)
{
    HRESULT hr;
    DWORD cPeriodUnits;
    PERIODUNITS *rgPeriodUnits = NULL;

    hr = caTranslateFileTimePeriodToPeriodUnits(
					pft,
					FALSE,	// fExact
					&cPeriodUnits,
					&rgPeriodUnits);
    _JumpIfError(hr, error, "caTranslateFileTimePeriodToPeriodUnits");

    CSASSERT(0 < cPeriodUnits);

    if (rgPeriodUnits[0].lCount != *plCAXchgValidityPeriodCount ||
	rgPeriodUnits[0].enumPeriod != *penumCAXchgValidityPeriod)
    {
	WCHAR const *pwszPeriodString;

	*plCAXchgValidityPeriodCount = rgPeriodUnits[0].lCount;
	*penumCAXchgValidityPeriod = rgPeriodUnits[0].enumPeriod;

	hr = myTranslateUnlocalizedPeriodString(
				    rgPeriodUnits[0].enumPeriod,
				    &pwszPeriodString);
	_JumpIfError(hr, error, "myTranslateUnlocalizedPeriodString");

	// CA xchg cert period string

	hr = mySetCertRegStrValue(
			    g_wszSanitizedName,
			    NULL,
			    NULL,
			    pwszRegPeriodString,
			    pwszPeriodString);
	_JumpIfErrorStr(hr, error, "mySetCertRegStrValue", pwszRegPeriodString);

	// CA xchg cert period count

	hr = mySetCertRegDWValue(
			    g_wszSanitizedName,
			    NULL,
			    NULL,
			    pwszRegPeriodCount,
			    *plCAXchgValidityPeriodCount);
	_JumpIfErrorStr(hr, error, "mySetCertRegDWValue", pwszRegPeriodCount);
    }
    hr = S_OK;

error:
    if (NULL != rgPeriodUnits)
    {
	LocalFree(rgPeriodUnits);
    }
    return(hr);
}


// Set validity & overlap periods from template; update registry if it differs.
// enum ENUM_PERIOD g_enumCAXchgValidityPeriod
// LONG g_lCAXchgValidityPeriodCount
//
// enum ENUM_PERIOD g_enumCAXchgOverlapPeriod
// LONG g_lCAXchgOverlapPeriodCount

HRESULT
PKCSUpdateXchgValidityPeriods(
    OPTIONAL IN HCERTTYPE hCertType)
{
    HRESULT hr;
    HCERTTYPE hCertTypeT = NULL;
    FILETIME ftExpiration;
    FILETIME ftOverlap;

    if (NULL == hCertType)
    {
	hr = CAFindCertTypeByName(
		    wszCERTTYPE_CA_EXCHANGE,
		    NULL,
		    CT_FIND_LOCAL_SYSTEM |
			CT_ENUM_MACHINE_TYPES |
			CT_ENUM_USER_TYPES |
			CT_FLAG_NO_CACHE_LOOKUP,
		    &hCertTypeT);
	_JumpIfErrorStr(hr, error, "CAFindCertTypeByName", wszCERTTYPE_CA_EXCHANGE);

	hCertType = hCertTypeT;
    }
    hr = CAGetCertTypeExpiration(
			hCertType,
			&ftExpiration,
			&ftOverlap);
    _JumpIfError(hr, error, "CAGetCertTypeExpiration");

    hr = pkcsSyncRegTimePeriod(
			g_wszRegCAXchgValidityPeriodCount,
			g_wszRegCAXchgValidityPeriodString,
			&g_enumCAXchgValidityPeriod,
			&g_lCAXchgValidityPeriodCount,
			&ftExpiration);
    _JumpIfError(hr, error, "pkcsSyncRegTimePeriod");

    hr = pkcsSyncRegTimePeriod(
			g_wszRegCAXchgOverlapPeriodCount,
			g_wszRegCAXchgOverlapPeriodString,
			&g_enumCAXchgOverlapPeriod,
			&g_lCAXchgOverlapPeriodCount,
			&ftOverlap);
    _JumpIfError(hr, error, "pkcsSyncRegTimePeriod");

error:
    if (NULL != hCertTypeT)
    {
	CACloseCertType(hCertTypeT);
    }
    return(hr);
}


VOID
pkcsReleaseCAXchgContext(
    IN OUT CAXCHGCTX *pCAXchgContext)
{
    if (NULL != pCAXchgContext->hProvCA)
    {
	CryptReleaseContext(pCAXchgContext->hProvCA, 0);
	pCAXchgContext->hProvCA = NULL;
    }
    if (NULL != pCAXchgContext->pccCAXchg)
    {
	CertFreeCertificateContext(pCAXchgContext->pccCAXchg);
	pCAXchgContext->pccCAXchg = NULL;
    }
    if (NULL != pCAXchgContext->pwszKeyContainerName)
    {
	LocalFree(pCAXchgContext->pwszKeyContainerName);
	pCAXchgContext->pwszKeyContainerName = NULL;
    }
}


VOID
pkcsReleaseCAXchgContextArray()
{
    DWORD i;

    if (NULL != g_aCAXchgContext)
    {
	for (i = 0; i < g_cCAXchgCerts; i++)
	{
	    pkcsReleaseCAXchgContext(&g_aCAXchgContext[i]);
	}
	LocalFree(g_aCAXchgContext);
	g_aCAXchgContext = NULL;
    }
    g_cCAXchgCerts = 0;
    g_pCAContextCurrent = NULL;
}


HRESULT
pkcsLoadCAXchgContext(
    IN DWORD iHash)
{
    HRESULT hr;
    CAXCHGCTX *pCAXchgContext;
    DWORD dwRequestFlags;
    DWORD NameId;
    HCRYPTPROV hProv = NULL;
    WCHAR *pwszKeyContainer = NULL;
    BYTE *pbHash = NULL;
    DWORD cbHash;
    BYTE *pbCert = NULL;
    DWORD cbCert;
    DWORD cb;
    BSTR strHash = NULL;
    ICertDBRow *prow = NULL;
    DWORD dwRequestId;
    CERT_CONTEXT const *pcc = NULL;
    BOOL fDeleteKey = FALSE;
    DWORD i;

    hr = myGetCARegHash(
		g_wszSanitizedName,
		CSRH_CAXCHGCERT,
		iHash,
		&pbHash,
		&cbHash);
    _JumpIfError2(hr, error, "myGetCARegHash", S_FALSE);

    hr = MultiByteIntegerToBstr(TRUE, cbHash, pbHash, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    DBGPRINT((
	DBG_SS_CERTSRV,
	"Reloading Xchg CAContext[%u]:\n    %ws\n",
	iHash,
	strHash));

    hr = g_pCertDB->OpenRow(
		    PROPOPEN_READONLY | PROPOPEN_CERTHASH | PROPTABLE_REQCERT,
		    0,
		    strHash,
		    &prow);
    _JumpIfError(hr, error, "OpenRow(xchg cert)");

    prow->GetRowId(&dwRequestId);

    hr = pkcsFormXchgKeyContainerName(dwRequestId, &pwszKeyContainer);
    _JumpIfError(hr, error, "pkcsFormXchgKeyContainerName");

    cb = sizeof(dwRequestFlags);
    hr = prow->GetProperty(
		    g_wszPropRequestFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    &cb,
		    (BYTE *) &dwRequestFlags);
    _JumpIfError(hr, error, "GetProperty(RequestFlags)");

    if (0 == (CR_FLG_CAXCHGCERT & dwRequestFlags))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Not a CA Xchg cert");
    }

    cb = sizeof(NameId);
    hr = prow->GetProperty(
		    g_wszPropCertificateIssuerNameID,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    NULL,
		    &cb,
		    (BYTE *) &NameId);
    _JumpIfError(hr, error, "GetProperty");

    hr = PKCSGetProperty(
		prow,
		g_wszPropRawCertificate,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		&cbCert,
		(BYTE **) &pbCert);
    _JumpIfError(hr, error, "PKCSGetProperty(xchg cert)");

    pcc = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    for (i = 0; ; i++)
    {
	hr = pkcsAcquireKey(pwszKeyContainer, &hProv);
	_PrintIfErrorStr(hr, "pkcsAcquireKey", g_pwszXchgProvName);

	if (S_OK == hr)
	{
	    hr = myValidateKeyForEncrypting(
				    hProv,
				    &pcc->pCertInfo->SubjectPublicKeyInfo,
				    CALG_3DES);
	    _PrintIfErrorStr(hr, "myValidateKeyForEncrypting", g_pwszXchgProvName);
	}
	if (S_OK == hr)
	{
	    break;
	}
	LogEventHResult(
		    NULL == g_pwszXchgProvName?
			EVENTLOG_ERROR_TYPE :
			EVENTLOG_WARNING_TYPE,
		    NULL == g_pwszXchgProvName?
			MSG_E_BAD_DEFAULT_CA_XCHG_CSP :
			MSG_E_BAD_REGISTRY_CA_XCHG_CSP,
		    hr);
	if (0 != i || NULL == g_pwszXchgProvName)
	{
	    fDeleteKey = TRUE;
	    _JumpError(hr, error, "pkcsAcquireKey/myValidateKeyForEncrypting");
	}
	pkcsLoadCAXchgCSPInfo(TRUE);	// switch to default CSP
    }
    if (0 != i)
    {
	hr = LogEvent(
		    EVENTLOG_WARNING_TYPE,
		    MSG_E_USE_DEFAULT_CA_XCHG_CSP,
		    0,			// cpwsz
		    NULL);		// apwsz
	_PrintIfError(hr, "LogEvent");
    }

    hr = pkcsVerifyCertContext(NULL, FALSE, pcc);
    if (S_OK != hr)
    {
	fDeleteKey = TRUE;
	_JumpErrorStr(hr, error, "pkcsVerifyCertContext", L"CAXchg cert invalid");
    }

    pCAXchgContext = &g_aCAXchgContext[g_cCAXchgCerts];
    ZeroMemory(pCAXchgContext, sizeof(*pCAXchgContext));

    pCAXchgContext->ReqId = dwRequestId;

    pCAXchgContext->pccCAXchg = pcc;
    pcc = NULL;

    pCAXchgContext->hProvCA = hProv;
    hProv = NULL;

    pCAXchgContext->pwszKeyContainerName = pwszKeyContainer;
    pwszKeyContainer = NULL;

    pCAXchgContext->iCertSig = CANAMEIDTOICERT(NameId);
    g_cCAXchgCerts++;
    hr = S_OK;

error:
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    if (fDeleteKey)
    {
	pkcsDeleteKey(pwszKeyContainer);
    }
    if (NULL != prow)
    {
	prow->Release();
    }
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != pwszKeyContainer)
    {
	LocalFree(pwszKeyContainer);
    }
    if (NULL != pbHash)
    {
	LocalFree(pbHash);
    }
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    return(hr);
}


HRESULT
pkcsLoadCAXchgContextArray(
    OUT BOOL *pfIncompleteLoad)
{
    HRESULT hr;
    DWORD cCAXchgCerts;
    DWORD iHash;
    DWORD i;

    // get provider name, etc.

    pkcsLoadCAXchgCSPInfo(FALSE);

    // find & load CA Xchg certs, etc.

    *pfIncompleteLoad = TRUE;
    hr = myGetCARegHashCount(
			g_wszSanitizedName,
			CSRH_CAXCHGCERT,
			&cCAXchgCerts);
    if (S_OK == hr && 0 == cCAXchgCerts)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    _JumpIfError(hr, error, "myGetCARegHashCount");

    g_aCAXchgContext = (CAXCHGCTX *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cCAXchgCerts * sizeof(g_aCAXchgContext[0]));
    if (NULL == g_aCAXchgContext)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    for (iHash = 0; iHash < cCAXchgCerts; iHash++)
    {
	hr = pkcsLoadCAXchgContext(iHash);
	_PrintIfError(hr, "pkcsLoadCAXchgContext");
    }
    if (0 == g_cCAXchgCerts)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "g_cCAXchgCerts");
    }
    g_pCAXchgContextCurrent = &g_aCAXchgContext[0];
    for (i = 1; i < g_cCAXchgCerts; i++)
    {
	if (0 < CompareFileTime(
		    &g_aCAXchgContext[i].pccCAXchg->pCertInfo->NotAfter,
		    &g_pCAXchgContextCurrent->pccCAXchg->pCertInfo->NotAfter))
	{
	    g_pCAXchgContextCurrent = &g_aCAXchgContext[i];
	}
    }
    if (cCAXchgCerts == g_cCAXchgCerts)
    {
	*pfIncompleteLoad = FALSE;
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	if (NULL != g_aCAXchgContext)
	{
	    LocalFree(g_aCAXchgContext);
	    g_aCAXchgContext = NULL;
	}
	g_cCAXchgCerts = 0;
	g_pCAXchgContextCurrent = NULL;
    }
    return(hr);
}


HRESULT
pkcsUpdateCAXchgStoreAndRegistry(
    IN BOOL fUpdateRegistry)
{
    HRESULT hr;
    DWORD i;
    DWORD iHash;
    CAXCHGCTX *pCAXchgContext;
    HCERTSTORE hStore = NULL;
    CERT_KEY_CONTEXT ckc;
    CERT_CONTEXT const *pccStore = NULL;

    hStore = CertOpenStore(
		       CERT_STORE_PROV_MEMORY,
		       X509_ASN_ENCODING,
		       NULL,			// hProv
		       0,			// dwFlags
		       NULL);			// pvPara
    if (NULL == hStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertOpenStore");
    }
    if (fUpdateRegistry)
    {
	hr = myDeleteCertRegValue(
			    g_wszSanitizedName,
			    NULL,
			    NULL,
			    g_wszRegCAXchgCertHash);
	_PrintIfError(hr, "myDeleteCertRegValue");
    }

    ZeroMemory(&ckc, sizeof(ckc));
    ckc.cbSize = sizeof(ckc);
    ckc.dwKeySpec = AT_KEYEXCHANGE;

    iHash = 0;
    for (i = 0; i < g_cCAXchgCerts; i++)
    {
	pCAXchgContext = &g_aCAXchgContext[i];
	if (CTXF_EXPIRED & pCAXchgContext->Flags)
	{
	    continue;
	}

	// Add as encoded blob to avoid all properties, key prov info, etc.

	if (!CertAddEncodedCertificateToStore(
			hStore,
			X509_ASN_ENCODING,
			pCAXchgContext->pccCAXchg->pbCertEncoded,
			pCAXchgContext->pccCAXchg->cbCertEncoded,
			CERT_STORE_ADD_REPLACE_EXISTING,
			&pccStore))			// ppCertContext
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertAddEncodedCertificateToStore");
	}
	ckc.hCryptProv = pCAXchgContext->hProvCA;
	if (!CertSetCertificateContextProperty(
					pccStore,
					CERT_KEY_CONTEXT_PROP_ID,
					CERT_STORE_NO_CRYPT_RELEASE_FLAG,
					&ckc))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertSetCertificateContextProperty");
	}
	CertFreeCertificateContext(pccStore);
	pccStore = NULL;

	DBGPRINT((
            DBG_SS_CERTSRV,
	    "Add to CA Xchg memory store: '%ws'\n",
	    pCAXchgContext->pwszKeyContainerName));

	if (fUpdateRegistry)
	{
	    hr = mySetCARegHash(
			    g_wszSanitizedName,
			    CSRH_CAXCHGCERT,
			    iHash,
			    pCAXchgContext->pccCAXchg);
	    if (S_OK != hr)
	    {
		_PrintError(hr, "mySetCARegHash");
		continue;
	    }
	}
	iHash++;
    }
    if (NULL != g_hStoreCAXchg)
    {
	CertCloseStore(g_hStoreCAXchg, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    g_hStoreCAXchg = hStore;
    hStore = NULL;
    hr = S_OK;

error:
    if (NULL != pccStore)
    {
	CertFreeCertificateContext(pccStore);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
PKCSIsRevoked(
    IN DWORD RequestId,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OUT LONG *pRevocationReason,
    OUT LONG *pDisposition)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    BYTE *pbHash = NULL;
    DWORD cbHash;
    BSTR strHash = NULL;
    DWORD Disposition;
    DWORD cbProp;
    FILETIME ftRevoked;
    FILETIME ftCurrent;

    *pRevocationReason = CRL_REASON_UNSPECIFIED;
    *pDisposition = CA_DISP_INVALID;

    hr = g_pCertDB->OpenRow(
			PROPOPEN_READONLY | PROPTABLE_REQCERT,
			RequestId,
			pwszSerialNumber,
			&prow);
    _PrintIfErrorStr2(hr, "OpenRow", pwszSerialNumber, CERTSRV_E_PROPERTY_EMPTY);

    if (CERTSRV_E_PROPERTY_EMPTY == hr && NULL != pwszSerialNumber)
    {
	_PrintErrorStr2(
		hr,
		"OpenRow(serial)",
		pwszSerialNumber,
		CERTSRV_E_PROPERTY_EMPTY);

	hr = WszToMultiByteInteger(TRUE, pwszSerialNumber, &cbHash, &pbHash);
	_JumpIfError(hr, error, "WszToMultiByteInteger");

	hr = MultiByteIntegerToBstr(TRUE, cbHash, pbHash, &strHash);
	_JumpIfError(hr, error, "MultiByteIntegerToBstr");

	hr = g_pCertDB->OpenRow(
			PROPOPEN_READONLY |
			    PROPOPEN_CERTHASH |
			    PROPTABLE_REQCERT,
			RequestId,
			strHash,
			&prow);
	_PrintIfErrorStr2(hr, "OpenRow", strHash, CERTSRV_E_PROPERTY_EMPTY);
    }
    if (S_OK != hr)
    {
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK; // disposition indicates cert is invalid
	}
	goto error;
    }

    cbProp = sizeof(Disposition);
    hr = prow->GetProperty(
		    g_wszPropRequestDisposition,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    &cbProp,
		    (BYTE *) &Disposition);
    _JumpIfError(hr, error, "GetProperty(Disposition)");

    if (DB_DISP_ISSUED == Disposition ||
	(DB_DISP_CA_CERT == Disposition && IsRootCA(g_CAType)))
    {
	*pDisposition = CA_DISP_VALID;
	goto error;
    }

    if (DB_DISP_REVOKED != Disposition)
    {
	goto error;
    }

    cbProp = sizeof(ftRevoked);
    hr = prow->GetProperty(
		    g_wszPropRequestRevokedEffectiveWhen,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    &cbProp,
		    (BYTE *) &ftRevoked);

    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	*pDisposition = CA_DISP_VALID;
	hr = S_OK;
	goto error;
    }
    _JumpIfError(hr, error, "GetProperty(RevokedEffectiveWhen)");

    GetSystemTimeAsFileTime(&ftCurrent);
    if (0 < CompareFileTime(&ftRevoked, &ftCurrent))
    {
	*pDisposition = CA_DISP_VALID;
	goto error;
    }

    cbProp = sizeof(*pRevocationReason);
    hr = prow->GetProperty(
		   g_wszPropRequestRevokedReason,
		   PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		   NULL,
		   &cbProp,
		   (BYTE *) pRevocationReason);
    _JumpIfError(hr, error, "GetProperty(RevokedReason)");

    *pDisposition = CA_DISP_REVOKED;

error:
    if (NULL != pbHash)
    {
	LocalFree(pbHash);
    }
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    if (NULL != prow)
    {
	prow->Release();
    }
    return(hr);
}


HRESULT
PKCSGetCAXchgCert(
    IN DWORD iCert,
    IN WCHAR const *pwszUserName,
    OUT DWORD *piCertSig,
    OUT BYTE **ppbCACert,
    OUT DWORD *pcbCACert)
{
    HRESULT hr;
    BOOL fNewCert = FALSE;
    BOOL fIncompleteLoad = FALSE;
    FILETIME ft;
    BOOL fCritSecEntered = FALSE;

    *ppbCACert = NULL;
    if (MAXDWORD != iCert && 0 != iCert)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad Xchg CertIndex");
    }
    EnterCriticalSection(&g_critsecCAXchg);
    fCritSecEntered = TRUE;

    hr = S_OK;
    __try
    {
	if (NULL == g_pCAXchgContextCurrent ||
	    NULL == g_pCAXchgContextCurrent->pccCAXchg)
	{
	    hr = pkcsLoadCAXchgContextArray(&fIncompleteLoad);
	    _PrintIfError(hr, "pkcsLoadCAXchgContextArray");

	    if (S_OK != hr)
	    {
		fNewCert = TRUE;
	    }
	}
	if (NULL != g_pCAXchgContextCurrent &&
	    NULL != g_pCAXchgContextCurrent->pccCAXchg)
	{
	    CERT_INFO const *pCertInfo = g_pCAXchgContextCurrent->pccCAXchg->pCertInfo;
	    
	    GetSystemTimeAsFileTime(&ft);

	    if (0 < CompareFileTime(&ft, &pCertInfo->NotAfter))
	    {
		g_pCAXchgContextCurrent->Flags |= CTXF_EXPIRED;
		hr = CERT_E_EXPIRED;
		_PrintError(hr, "CA Xchg certificate is expired -- delete key");

		pkcsDeleteKey(g_pCAXchgContextCurrent->pwszKeyContainerName);
		fNewCert = TRUE;
	    }
	    else
	    if (0 > CompareFileTime(&ft, &pCertInfo->NotBefore))
	    {
		hr = CERT_E_EXPIRED;
		_PrintError(hr, "CA Xchg certificate not yet valid");
		fNewCert = TRUE;
	    }
	    else
	    {
		myMakeExprDateTime(
			    &ft,
			    g_lCAXchgOverlapPeriodCount,
			    g_enumCAXchgOverlapPeriod);

		if (0 < CompareFileTime(&ft, &pCertInfo->NotAfter))
		{
		    hr = CERT_E_EXPIRED;
		    _PrintError(hr, "CA Xchg certificate expires too soon");
		    fNewCert = TRUE;
		}
		else
		{
		    hr = pkcsVerifyCertIssuer(
				    g_pCAXchgContextCurrent->pccCAXchg,
				    g_pCAContextCurrent);
		    if (S_OK != hr)
		    {
			_PrintError(hr, "CA Xchg cert not issued by current CA");
			fNewCert = TRUE;
		    }
		    else
		    {
			LONG RevocationReason;
			LONG Disposition;

			hr = PKCSIsRevoked(
				    g_pCAXchgContextCurrent->ReqId,
				    NULL,		// pwszSerialNumber
				    &RevocationReason,
				    &Disposition);
			if (S_OK != hr)
			{
			    _PrintError(hr, "PKCSIsRevoked");
			    fNewCert = TRUE;
			}
			else
			if (CA_DISP_VALID != Disposition)
			{
			    hr = CRYPT_E_REVOKED;
			    _PrintError(hr, "revoked or bad CA Xchg certificate");
			    fNewCert = TRUE;
			}
		    }
		}
	    }
	}
	if (fNewCert)
	{
	    hr = pkcsCreateNewCAXchgCert(pwszUserName);
	    _LeaveIfError(hr, "pkcsCreateNewCAXchgCert");
	}
	hr = pkcsUpdateCAXchgStoreAndRegistry(fNewCert || fIncompleteLoad);
	_LeaveIfError(hr, "pkcsUpdateCAXchgStoreAndRegistry");

	// It's safe to return the cert blob memory pointer because the CA
	// Exchange cert contexts aren't released until shutdown.

	*piCertSig = g_pCAXchgContextCurrent->iCertSig;
	*pcbCACert = g_pCAXchgContextCurrent->pccCAXchg->cbCertEncoded;
	*ppbCACert = g_pCAXchgContextCurrent->pccCAXchg->pbCertEncoded;
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&g_critsecCAXchg);
    }
    return(hr);
}


HRESULT
PKCSGetCAXchgChain(
    IN DWORD iCert,
    IN WCHAR const *pwszUserName,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbCAChain, // CoTaskMem*
    OUT DWORD *pcbCAChain)
{
    HRESULT hr;
    BYTE *pbCACert;
    DWORD cbCACert;
    CACTX *pCAContext;

    hr = PKCSGetCAXchgCert(iCert, pwszUserName, &iCert, &pbCACert, &cbCACert);
    _JumpIfError(hr, error, "PKCSGetCAXchgCert");

    // iCert now indexes the signature cert that signed the current Xchg cert

    pCAContext = &g_aCAContext[iCert];
    if (NULL == pCAContext->pccCA)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "invalid cert");
    }
    hr = pkcsEncodeCertChain(
			pCAContext,
			pbCACert,	// pbCertLeaf
			cbCACert,	// cbCertLeaf
			pbCACert,	// pbToBeSigned
			cbCACert,	// cbToBeSigned
			fIncludeCRLs,
			ppbCAChain,	// CoTaskMem*
			pcbCAChain);
    _JumpIfError(hr, error, "PKCSEncodeCertChain");

error:
    return(hr);
}


VOID
PKCSTerminate(VOID)
{
    pkcsReleaseCAContextArray();
    pkcsReleaseCAXchgContextArray();
    if (NULL != g_hStoreCAXchg)
    {
	CertCloseStore(g_hStoreCAXchg, CERT_CLOSE_STORE_CHECK_FLAG);
	g_hStoreCAXchg = NULL;
    }
    pkcsLoadCAXchgCSPInfo(TRUE);
    pkcsReleaseKRACertArray();

    pkcsFreeTemplates(&g_paRevURL, &g_caRevURL);
    pkcsFreeTemplates(&g_paCACertURL, &g_caCACertURL);
    if (NULL != g_pwszKRAPublishURL)
    {
	LocalFree(g_pwszKRAPublishURL);
	g_pwszKRAPublishURL = NULL;
    }
    if (NULL != g_pwszAIACrossCertPublishURL)
    {
	LocalFree(g_pwszAIACrossCertPublishURL);
	g_pwszAIACrossCertPublishURL = NULL;
    }
    if (NULL != g_pwszRootTrustCrossCertPublishURL)
    {
	LocalFree(g_pwszRootTrustCrossCertPublishURL);
	g_pwszRootTrustCrossCertPublishURL = NULL;
    }
    if (NULL != g_strDomainDN)
    {
	SysFreeString(g_strDomainDN);
	g_strDomainDN = NULL;
    }
    if (NULL != g_strConfigDN)
    {
	SysFreeString(g_strConfigDN);
	g_strConfigDN = NULL;
    }
    if (g_fcritsecCAXchg)
    {
	DeleteCriticalSection(&g_critsecCAXchg);
	g_fcritsecCAXchg = FALSE;
    }
}


// PKCSCreateCertificate -- Create certificate & build PKCS 7 or Full Response.
//
// If pResult->pctbCert is non-NULL and pResult->pctbCert->pb is NULL:
// CR_IN_NEW:
//	Build, store and return cert
//	Use current CA Context
//	Build and return PKCS 7 or Full Response
//
// If pResult->pctbCert is non-NULL and pResult->pctbCert->pb is non-NULL:
// CR_IN_RETRIEVEPENDING:
//	Use passed cert
//	Find matching CA Context
//	Build and return PKCS 7 or Full Response
//
// If pResult->pctbCert is NULL:
// CR_IN_RESUBMIT:
//	Build and store cert -- don't return cert
//	Use current CA Context
//	Don't build or return PKCS 7 or Full Response


HRESULT
PKCSCreateCertificate(
    IN ICertDBRow *prow,
    IN DWORD Disposition,
    IN BOOL fIncludeCRLs,
    IN BOOL fCrossCert,
    OPTIONAL IN CACTX *pCAContext,	// signing CACTX
    OUT BOOL *pfErrorLogged,
    OPTIONAL OUT CACTX **ppCAContext,
    OPTIONAL OUT WCHAR **ppwszDispositionCreateCert,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)	// CoTaskMem*
{
    HRESULT hr;
    BYTE *pbCert = NULL;
    DWORD cbCert;
    BYTE *pbCertChain = NULL;
    DWORD cbCertChain;
    BOOL fCreated = FALSE;
    CERT_CONTEXT const *pcc = NULL;

    *pfErrorLogged = FALSE;
    if (NULL != ppCAContext)
    {
	*ppCAContext = NULL;
    }
    if (NULL != ppwszDispositionCreateCert)
    {
	*ppwszDispositionCreateCert = NULL;
    }
    CSASSERT(NULL == pResult->pctbCertChain || NULL == pResult->pctbCertChain->pb);
    CSASSERT(NULL == pResult->pctbFullResponse || NULL == pResult->pctbFullResponse->pb);

    cbCertChain = 0;
    if (NULL != pResult->pctbCert && NULL != pResult->pctbCert->pb)
    {
	CSASSERT(NULL == pCAContext);
	CSASSERT(NULL == ppwszDispositionCreateCert);
	pbCert = pResult->pctbCert->pb;
	cbCert = pResult->pctbCert->cb;

	pcc = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
	if (NULL == pcc)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertCreateCertificateContext");
	}
	pCAContext = NULL;
	if (DB_DISP_CA_CERT != Disposition &&
	    DB_DISP_CA_CERT_CHAIN != Disposition)
	{
	    hr = PKCSVerifyIssuedCertificate(pcc, &pCAContext);
	    _JumpIfError(hr, error, "PKCSVerifyIssuedCertificate");
	}
    }
    else
    {
	CSASSERT(NULL != ppwszDispositionCreateCert);
	if (NULL == pCAContext)
	{
	    pCAContext = g_pCAContextCurrent;
	}
	cbCert = 0;
	hr = pkcsEncodeSubjectCert(
			    prow,
			    pCAContext,
			    fCrossCert,
			    &pbCert,	// CoTaskMem*
			    &cbCert,
			    pfErrorLogged,
			    ppwszDispositionCreateCert);
	if (S_OK == hr ||
	    ((CRLF_SAVE_FAILED_CERTS & g_dwCRLFlags) &&
	     NULL != pbCert &&
	     0 != cbCert))
	{
	    HRESULT hr2;

	    hr2 = prow->SetProperty(
		    g_wszPropRawCertificate,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    cbCert,
		    pbCert);
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	    _JumpIfError(hr2, error, "SetProperty");
	}
	_JumpIfError(hr, error, "pkcsEncodeSubjectCert");

	fCreated = TRUE;
    }

    if (NULL != pResult->pctbCertChain)
    {
	hr = pkcsEncodeCertChain(
			    pCAContext,
			    pbCert,		// pbCertLeaf
			    cbCert,		// cbCertLeaf
			    pbCert,		// pbToBeSigned
			    cbCert,		// cbToBeSigned
			    fIncludeCRLs,
			    &pbCertChain,	// CoTaskMem*
			    &cbCertChain);
	_JumpIfError(hr, error, "pkcsEncodeCertChain");
    }
    if (fCreated && NULL != pResult->pctbCert)
    {
	pResult->pctbCert->pb = pbCert;
	pResult->pctbCert->cb = cbCert;
	pbCert = NULL;
    }
    if (NULL != pResult->pctbCertChain)
    {
	pResult->pctbCertChain->pb = pbCertChain;
	pResult->pctbCertChain->cb = cbCertChain;
	pbCertChain = NULL;
    }
    if (NULL != ppCAContext)
    {
	*ppCAContext = pCAContext;
    }
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (fCreated && NULL != pbCert)
    {
	CoTaskMemFree(pbCert);
    }
    if (fCreated && NULL != pbCertChain)
    {
	CoTaskMemFree(pbCertChain);
    }
    CSASSERT(
	NULL == pResult->pctbCertChain ||
	((S_OK == hr) ^ (NULL == pResult->pctbCertChain->pb)));
    return(hr);
}


HRESULT
PKCSGetKRACert(
    IN DWORD iCert,
    OUT BYTE **ppbCert,
    OUT DWORD *pcbCert)
{
    HRESULT hr = S_OK;

    if (MAXDWORD == iCert)
    {
        iCert = g_cKRACerts - 1;
    }
    if (iCert >= g_cKRACerts || NULL == g_aKRAContext)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "bad CertIndex");
    }

    *pcbCert = g_aKRAContext[iCert].pccKRA->cbCertEncoded;
    *ppbCert = g_aKRAContext[iCert].pccKRA->pbCertEncoded;

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\request.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        request.h
//
// Contents:    Implementation of DCOM object for RPC services
//
// History:     July-97       xtan created
//
//---------------------------------------------------------------------------

// class definition
// Request Interface
class CCertRequestD : public ICertRequestD2
{
public:
    // IUnknown

    virtual STDMETHODIMP QueryInterface(const IID& iid, void** ppv);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // ICertRequestD

    virtual STDMETHODIMP Request(
	IN     DWORD                dwFlags,
	IN     wchar_t const       *pwszAuthority,
	IN OUT DWORD               *pdwRequestId,
	OUT    DWORD               *pdwDisposition,
	IN     wchar_t const       *pwszAttributes,
	IN     CERTTRANSBLOB const *pctbRequest,
	OUT    CERTTRANSBLOB       *pctbCertChain,
	OUT    CERTTRANSBLOB       *pctbEncodedCert,
	OUT    CERTTRANSBLOB       *pctbDispositionMessage);

    virtual STDMETHODIMP GetCACert(
	IN  DWORD          Flags,
	IN  wchar_t const *pwszAuthority,
	OUT CERTTRANSBLOB *pctbOut);

    virtual STDMETHODIMP Ping(	// test function
			wchar_t const *pwszAuthority);

    // ICertRequestD2

    virtual STDMETHODIMP Request2( 
	IN     wchar_t const       *pwszAuthority,
	IN     DWORD                dwFlags,
	IN     wchar_t const       *pwszSerialNumber,
	IN OUT DWORD               *pdwRequestId,
	OUT    DWORD               *pdwDisposition,
	IN     wchar_t const       *pwszAttributes,
	IN     CERTTRANSBLOB const *pctbRequest,
	OUT    CERTTRANSBLOB       *pctbFullResponse,
	OUT    CERTTRANSBLOB       *pctbEncodedCert,
	OUT    CERTTRANSBLOB       *pctbDispositionMessage);

    virtual STDMETHODIMP GetCAProperty(
	IN  wchar_t const *pwszAuthority,
	IN  LONG           PropId,	// CR_PROP_*
	IN  LONG           PropIndex,
	IN  LONG           PropType,	// PROPTYPE_*
	OUT CERTTRANSBLOB *pctbPropertyValue);

    virtual STDMETHODIMP GetCAPropertyInfo(
	IN  wchar_t const *pwszAuthority,
	OUT LONG          *pcProperty,
	OUT CERTTRANSBLOB *pctbPropInfo);

    virtual STDMETHODIMP Ping2( 
	IN     wchar_t const *pwszAuthority);
    
    // CCertRequestD

    // Constructor
    CCertRequestD();

    // Destructor
    ~CCertRequestD();

private:
    // this is a test function
    HRESULT _Ping(
        IN wchar_t const *pwszAuthority);

    HRESULT _Request( 
	IN          WCHAR const            *pwszAuthority,
	IN          DWORD                   dwFlags,
	OPTIONAL IN WCHAR const            *pwszSerialNumber,
	IN          DWORD                   dwRequestId,
	OPTIONAL IN WCHAR const            *pwszAttributes,
	OPTIONAL IN CERTTRANSBLOB const    *pctbRequest,
	OUT         CERTSRV_RESULT_CONTEXT *pResult);

private:
    // Reference count
    long m_cRef;
};


// Class of Request factory
class CRequestFactory : public IClassFactory
{
public:
    // IUnknown
    virtual STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // Interface IClassFactory
    virtual STDMETHODIMP CreateInstance(
				    IUnknown *pUnknownOuter,
				    const IID& iid,
				    void **ppv);

    virtual STDMETHODIMP LockServer(BOOL bLock);

    // Constructor
    CRequestFactory() : m_cRef(1) { }

    // Destructor
    ~CRequestFactory() { }

public:
    static HRESULT CanUnloadNow();
    static HRESULT StartFactory();
    static void    StopFactory();

private:
    long m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\elog.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        elog.cpp
//
// Contents:    Event log helper functions
//
// History:     02-Jan-97       terences created
//
//---------------------------------------------------------------------------


HRESULT
LogEvent(
    IN DWORD dwEventType,
    IN DWORD dwIdEvent,
    IN WORD cStrings,
    IN WCHAR const * const *apwszStrings);

HRESULT
LogEventHResult(
    IN DWORD dwEventType,
    IN DWORD dwIdEvent,
    IN HRESULT hr);

HRESULT
LogEventString(
    IN DWORD dwEventType,
    IN DWORD dwIdEvent,
    IN WCHAR const *pwszString);

HRESULT
LogEventStringHResult(
    IN DWORD dwEventType,
    IN DWORD dwIdEvent,
    IN WCHAR const *pwszString,
    IN HRESULT hr);

HRESULT
LogEventStringArrayHResult(
    IN DWORD dwEventType,
    IN DWORD dwIdEvent,
    IN DWORD cStrings,
    IN WCHAR const * const *apwszStrings,
    IN HRESULT hrEvent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\resource.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        resource.h
//
// Contents:    Cert Server resource definitions
//
//---------------------------------------------------------------------------

#define IDS_DENIEDBY			 1
#define IDS_POLICYDENIED		 2
#define IDS_ISSUED			 3
#define IDS_UNDERSUBMISSION		 4
#define IDS_REVOKEDBY			 5
#define IDS_PRINTFCERTREQUESTDISPOSITION 6
#define IDS_USAGE 			 7
#define IDS_CERTCONSTRUCTIONERROR	 8
#define IDS_RESUBMITTEDBY		 9
#define IDS_USAGE_FULL			 10
#define IDS_USAGE_COMTEST		 11
#define IDS_UNKNOWNSUBJECT		 12
#define IDS_UNREVOKEDBY			 13
#define IDS_REQUESTEDBY			 14
#define IDS_INTERMEDIATECASTORE		 15
#define IDS_PUBLISHERROR		 16
#define IDS_PUBLISHEDBY			 17
#define IDS_REQUESTPARSEERROR		 18
#define IDS_YES				 19
#define IDS_NO				 20
#define IDS_ALLOW			 21
#define IDS_DENY			 22
#define IDS_CAADMIN			 23
#define IDS_OFFICER			 24
#define IDS_READ			 25
#define IDS_ENROLL			 26
#define IDS_INVALIDISSUANCEPOLICIES	 27
#define IDS_INVALIDAPPLICATIONPOLICIES	 28
#define IDS_REQUESTSIGERROR		 29
#define IDS_KEYARCHIVALERROR		 30
#define IDS_ARCHIVESIGNINGKEYERROR	 31

#define IDI_APP                          201

// Marshalling uses AT LEAST WM_USER+0

#define WM_STARTSERVER		WM_USER+20
#define WM_STOPSERVER		WM_USER+21
#define WM_SUSPENDSERVER	WM_USER+22
#define WM_RESTARTSERVER	WM_USER+23
#define WM_SYNC_CLOSING_THREADS WM_USER+24
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\resstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------

    RESSTR(IDS_DENIEDBY),
    RESSTR(IDS_POLICYDENIED),
    RESSTR(IDS_ISSUED),
    RESSTR(IDS_UNDERSUBMISSION),
    RESSTR(IDS_REVOKEDBY),
    RESSTR(IDS_PRINTFCERTREQUESTDISPOSITION),
    RESSTR(IDS_USAGE),
    RESSTR(IDS_CERTCONSTRUCTIONERROR),
    RESSTR(IDS_RESUBMITTEDBY),
    RESSTR(IDS_USAGE_FULL),
    RESSTR(IDS_USAGE_COMTEST),
    RESSTR(IDS_UNKNOWNSUBJECT),
    RESSTR(IDS_UNREVOKEDBY),
    RESSTR(IDS_REQUESTEDBY),
    RESSTR(IDS_INTERMEDIATECASTORE),
    RESSTR(IDS_PUBLISHERROR),
    RESSTR(IDS_PUBLISHEDBY),
    RESSTR(IDS_REQUESTPARSEERROR),
    RESSTR(IDS_YES),
    RESSTR(IDS_NO),
    RESSTR(IDS_ALLOW),
    RESSTR(IDS_DENY),
    RESSTR(IDS_CAADMIN),
    RESSTR(IDS_OFFICER),
    RESSTR(IDS_READ),
    RESSTR(IDS_ENROLL),
    RESSTR(IDS_INVALIDISSUANCEPOLICIES),
    RESSTR(IDS_INVALIDAPPLICATIONPOLICIES),
    RESSTR(IDS_REQUESTSIGERROR),
    RESSTR(IDS_KEYARCHIVALERROR),
    RESSTR(IDS_ARCHIVESIGNINGKEYERROR),
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\request.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        request.cpp
//
// Contents:    Implementation of DCOM object for RPC services
//
// History:     July-97       xtan created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>
#include <accctrl.h>

#include "cscom.h"
#include "csprop.h"
#include "certsrvd.h"
#include "request.h"
#include "certacl.h"
#include "tmpllist.h"

#define __dwFILE__	__dwFILE_CERTSRV_REQUEST_CPP__

extern HINSTANCE g_hInstApp;
extern const GUID *g_guidAdmin[1];
extern const GUID *g_guidsReadAdminOfficer[3];

// Global variables
long g_cRequestComponents = 0;     // Count of active components
long g_cRequestServerLocks = 0;    // Count of locks
DWORD g_dwRequestRegister = 0;
IClassFactory* g_pIRequestFactory = NULL;
// Sequence# incremented every time the CA template list is changed.
// Policy module detects any changes to this number and refreshes its
// template data from DS.
long g_cTemplateUpdateSequenceNum = 0; 

#ifdef DBG_CERTSRV_DEBUG_PRINT
DWORD s_ssRequest = DBG_SS_CERTSRVI;
#endif

using namespace CertSrv;


HRESULT RequestAccessCheck(
    OPTIONAL OUT BOOL *pfInRequesterGroup = NULL,
    OPTIONAL OUT HANDLE *phToken = NULL)
{
    HRESULT hr = S_OK;
    CAuditEvent audit(0, g_dwAuditFilter);
    BOOL fInRequesterGroup = FALSE;

    hr = audit.AccessCheck(
			CA_ACCESS_ENROLL,
			audit.m_gcNoAuditSuccess |
            audit.m_gcNoAuditFailure,
            NULL,
            phToken);

    if(S_OK==hr)
    {
        fInRequesterGroup = TRUE;
    } 

    if(pfInRequesterGroup)
        *pfInRequesterGroup = fInRequesterGroup;

    if(E_ACCESSDENIED==hr)
    {
        // When this flag is set, ICertReq calls should immediately return
        // if access is denied. If not set, we ignore access denied error
        // but pass down the result to the policy module through fInRequesterGroup
        if (IF_LOCKICERTREQUEST & g_InterfaceFlags)
        {
            hr = CERTSRV_E_ENROLL_DENIED;
        }
        else
        {
            hr = S_OK;
        }
    }

    _JumpIfError(hr, error, "CAuditEvent::AccessCheck");

error:
    return hr;
}


VOID
ReleaseResult(
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    if (NULL != pResult->pbSenderNonce)
    {
	LocalFree(pResult->pbSenderNonce);
    }
    if (NULL != pResult->pbKeyHashIn)
    {
	LocalFree(pResult->pbKeyHashIn);
    }
    if (NULL != pResult->pbKeyHashOut)
    {
	LocalFree(pResult->pbKeyHashOut);
    }
    if (NULL != pResult->pbArchivedKey)
    {
	LocalFree(pResult->pbArchivedKey);
    }
    if (NULL != pResult->pwszKRAHashes)
    {
	LocalFree(pResult->pwszKRAHashes);
    }
    if (NULL != pResult->strRenewalCertHash)
    {
	SysFreeString(pResult->strRenewalCertHash);
    }
    if (NULL != pResult->pwszExtendedErrorInfo)
    {
	LocalFree(pResult->pwszExtendedErrorInfo);
    }
}


STDMETHODIMP
CCertRequestD::Request(
    /* [in] */ DWORD dwFlags,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [ref][out][in] */ DWORD __RPC_FAR *pdwRequestId,
    /* [out] */ DWORD __RPC_FAR *pdwDisposition,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAttributes,
    /* [ref][in] */ CERTTRANSBLOB const __RPC_FAR *pctbRequest,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbCertChain,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbEncodedCert,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbDispositionMessage)
{
    HRESULT hr;
    WCHAR const *pwszSerialNumber = NULL;
    CERTSRV_RESULT_CONTEXT Result;

    ZeroMemory(&Result, sizeof(Result));
    if (NULL != pctbRequest && NULL == pctbRequest->pb)
    {
	// RetrievePending by SerialNumber in pwszAttributes

	pwszSerialNumber = pwszAttributes;
	pwszAttributes = NULL;
    }
    Result.pdwRequestId = pdwRequestId;
    Result.pdwDisposition = pdwDisposition;
    Result.pctbDispositionMessage = pctbDispositionMessage;
    Result.pctbCert = pctbEncodedCert;
    Result.pctbCertChain = pctbCertChain;

    hr = _Request(
		pwszAuthority,
		dwFlags,
		pwszSerialNumber,
		*pdwRequestId,
		pwszAttributes,
		pctbRequest,
		&Result);
    _JumpIfError(hr, error, "Request");

error:
    ReleaseResult(&Result);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertRequestD::Request2(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ DWORD dwFlags,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszSerialNumber,
    /* [ref][out][in] */ DWORD __RPC_FAR *pdwRequestId,
    /* [out] */ DWORD __RPC_FAR *pdwDisposition,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAttributes,
    /* [ref][in] */ const CERTTRANSBLOB __RPC_FAR *pctbRequest,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbFullResponse,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbEncodedCert,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbDispositionMessage)
{
    HRESULT hr;
    CERTSRV_RESULT_CONTEXT Result;

    ZeroMemory(&Result, sizeof(Result));
    Result.pdwRequestId = pdwRequestId;
    Result.pdwDisposition = pdwDisposition;
    Result.pctbDispositionMessage = pctbDispositionMessage;
    Result.pctbCert = pctbEncodedCert;
    if (CR_IN_FULLRESPONSE & dwFlags)
    {
	Result.pctbFullResponse = pctbFullResponse;
    }
    else
    {
	Result.pctbCertChain = pctbFullResponse;
    }

    hr = _Request(
		pwszAuthority,
		dwFlags,
		pwszSerialNumber,
		*pdwRequestId,
		pwszAttributes,
		pctbRequest,
		&Result);
    _JumpIfError(hr, error, "Request2");

error:
    ReleaseResult(&Result);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


VOID
requestRegisterMemFreeBlob(
    OPTIONAL CERTTRANSBLOB const *pctb)
{
    if (NULL != pctb && NULL != pctb->pb)
    {
	myRegisterMemFree(pctb->pb, CSM_MIDLUSERALLOC);
    }
}


HRESULT
CCertRequestD::_Request(
    IN WCHAR const *pwszAuthority,
    IN DWORD dwFlags,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN DWORD dwRequestId,
    OPTIONAL IN WCHAR const *pwszAttributes,
    OPTIONAL IN CERTTRANSBLOB const *pctbRequest,
    OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    DWORD OpRequest;
    WCHAR *pwszUserName = NULL;
    DWORD dwComContextIndex = MAXDWORD;
    CERTSRV_COM_CONTEXT ComContext;
    DWORD State = 0;
    BOOL fInRequestGroup;

    DBGPRINT((
        s_ssRequest,
        "CCertRequestD::Request2(tid=%d)\n",
        GetCurrentThreadId()));

    ZeroMemory(&ComContext, sizeof(ComContext));
    //ComContext.pwszUserDN = NULL;
    //ComContext.hAccessToken = NULL;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    hr = RegisterComContext(&ComContext, &dwComContextIndex);
    _JumpIfError(hr, error, "RegsiterComContext");

    __try
    {
        hr = RequestAccessCheck(&fInRequestGroup, &ComContext.hAccessToken);
        _LeaveIfError(hr, "RequestAccessCheck");

	ComContext.dwFlags |= CCCF_INREQUESTGROUPSET;
	if (fInRequestGroup)
	{
	    ComContext.dwFlags |= CCCF_INREQUESTGROUP;
	}

        // Set up default output parameters:
        
        *pResult->pdwRequestId = 0;
        *pResult->pdwDisposition = CR_DISP_ERROR;
        
        OpRequest = CR_IN_RETRIEVE;
        if (NULL != pctbRequest->pb)
        {
            OpRequest = CR_IN_NEW;
        }
       
        hr = GetClientUserName(
			NULL,
			&pwszUserName,
			CR_IN_NEW == OpRequest && IsEnterpriseCA(g_CAType)?
			    &ComContext.pwszUserDN : NULL);
        _LeaveIfError(hr, "GetClientUserName");

        hr = CoreProcessRequest(
			OpRequest | (dwFlags & ~CR_IN_COREMASK),
			pwszUserName,
			pctbRequest->cb,	// cbRequest
			pctbRequest->pb,	// pbRequest
			pwszAttributes,
			pwszSerialNumber,
			dwComContextIndex,
			dwRequestId,
			pResult);	// Allocates returned memory
        if (S_OK != hr)
        {
            hr = myHError(hr);
            _LeaveError(hr, "CoreProcessRequest");
        }
        
        requestRegisterMemFreeBlob(pResult->pctbDispositionMessage);
        requestRegisterMemFreeBlob(pResult->pctbCert);
        requestRegisterMemFreeBlob(pResult->pctbCertChain);
        requestRegisterMemFreeBlob(pResult->pctbFullResponse);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    // CloseHandle can throw an exception

    if (NULL != ComContext.hAccessToken)
    {
        __try
        {
            CloseHandle(ComContext.hAccessToken);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
            _PrintError(hr, "Exception");
        }
    }
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    ReleaseComContext(&ComContext);
    if (MAXDWORD != dwComContextIndex)
    {
	UnregisterComContext(&ComContext, dwComContextIndex);
    }
    CertSrvExitServer(
		State,
		(S_OK == hr &&
		 NULL != pResult->pdwDisposition &&
		 FAILED(*pResult->pdwDisposition))?
		     *pResult->pdwDisposition : hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


#define MAX_VERSION_RESOURCE_SIZE 64

HRESULT
GetVersionString(
    IN DWORD type,
    OUT WCHAR *pwszVersion)
{
    HRESULT hr;

    typedef struct _MY_RESOURCE_DATA
    {
        USHORT TotalSize;
        USHORT DataSize;
        USHORT Type;
        WCHAR Name[16];                     // L"VS_VERSION_INFO" + unicode nul
        VS_FIXEDFILEINFO FixedFileInfo;
    } MY_RESOURCE_DATA;

    MY_RESOURCE_DATA *pResource;
    HRSRC hrsc;
    HGLOBAL hg;

    // FindResource: don't need to free hrsc
    hrsc = FindResource(g_hInstApp, MAKEINTRESOURCE(1), RT_VERSION);
    if (NULL == hrsc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "FindResource");
    }

    // LoadResource: don't need to free HGLOBAL
    hg = LoadResource(g_hInstApp, hrsc); 
    if (NULL == hg)
    {
	hr = myHLastError();
	_JumpError(hr, error, "LoadResource");
    }

    // LockResource: don't need to free pResource
    pResource = (MY_RESOURCE_DATA *) LockResource(hg);
    if (NULL == pResource)
    {
	hr = myHLastError();
	if (S_OK == hr)		// LockResource isn't doc'd to use SetLastError
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}
	_JumpError(hr, error, "LockResource");
    }

    if (0 != LSTRCMPIS(pResource->Name, L"VS_VERSION_INFO"))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	goto error;
    }
   
    if (CR_PROP_FILEVERSION == type)
    {
	wsprintf(
	    pwszVersion,
	    L"%d.%d:%d.%d",
	    HIWORD(pResource->FixedFileInfo.dwFileVersionMS),
	    LOWORD(pResource->FixedFileInfo.dwFileVersionMS),
	    HIWORD(pResource->FixedFileInfo.dwFileVersionLS),
	    LOWORD(pResource->FixedFileInfo.dwFileVersionLS));
    }
    else
    {
	wsprintf(
	    pwszVersion,
	    L"%d.%d:%d.%d",
	    HIWORD(pResource->FixedFileInfo.dwProductVersionMS),
	    LOWORD(pResource->FixedFileInfo.dwProductVersionMS),
	    HIWORD(pResource->FixedFileInfo.dwProductVersionLS),
	    LOWORD(pResource->FixedFileInfo.dwProductVersionLS));
    }
    hr = S_OK;

error:
    return(hr);
}


// for ICertRequest2::GetCAProperty & ICertAdmin2::GetCAProperty

LONG g_CAPropIdMax = 0;

CAPROP g_aCAProp[] = {
    { CR_PROP_FILEVERSION,	 PROPTYPE_STRING, },
    { CR_PROP_PRODUCTVERSION,	 PROPTYPE_STRING, },
    { CR_PROP_EXITCOUNT,	 PROPTYPE_LONG, },
    { CR_PROP_EXITDESCRIPTION,	 PROPTYPE_STRING | PROPFLAGS_INDEXED, },
    { CR_PROP_POLICYDESCRIPTION, PROPTYPE_STRING, },
    { CR_PROP_CANAME,		 PROPTYPE_STRING, },
    { CR_PROP_SANITIZEDCANAME,	 PROPTYPE_STRING, },
    { CR_PROP_SHAREDFOLDER,	 PROPTYPE_STRING, },
    { CR_PROP_PARENTCA,		 PROPTYPE_STRING, FALSE, },

    { CR_PROP_CATYPE,		 PROPTYPE_LONG, },
    { CR_PROP_CASIGCERTCOUNT,	 PROPTYPE_LONG, },
    { CR_PROP_CASIGCERT,	 PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_CASIGCERTCHAIN,	 PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_CAXCHGCERTCOUNT,	 PROPTYPE_LONG, },
    { CR_PROP_CAXCHGCERT,	 PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_CAXCHGCERTCHAIN,	 PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_BASECRL,		 PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_DELTACRL,		 PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_CACERTSTATE,	 PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { CR_PROP_CRLSTATE,		 PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { CR_PROP_CAPROPIDMAX,	 PROPTYPE_LONG, },
    { CR_PROP_DNSNAME,		 PROPTYPE_STRING, },
//    { CR_PROP_ROLESEPARATIONENABLED,    PROPTYPE_LONG, },
    { CR_PROP_KRACERTUSEDCOUNT,	 PROPTYPE_LONG, },
    { CR_PROP_KRACERTCOUNT,	 PROPTYPE_LONG, },
    { CR_PROP_KRACERT,	 	 PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_KRACERTSTATE,	 PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { CR_PROP_ADVANCEDSERVER,PROPTYPE_LONG, },
    { CR_PROP_TEMPLATES,     PROPTYPE_STRING, },
    { CR_PROP_BASECRLPUBLISHSTATUS, PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { CR_PROP_DELTACRLPUBLISHSTATUS, PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { CR_PROP_CASIGCERTCRLCHAIN, PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_CAXCHGCERTCRLCHAIN,PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_CACERTSTATUSCODE,  PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { CR_PROP_CAFORWARDCROSSCERT, PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_CABACKWARDCROSSCERT, PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_CAFORWARDCROSSCERTSTATE, PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { CR_PROP_CABACKWARDCROSSCERTSTATE, PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { CR_PROP_CACERTVERSION,	 PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { CR_PROP_SANITIZEDCASHORTNAME, PROPTYPE_STRING, },
};


// Map old ICertRequest::GetCACertificate calls to ICertRequest2::GetCAProperty

typedef struct _GETCERTMAP {
    DWORD dwGetCert;
    LONG  lPropId;
    LONG  lPropType;
} GETCERTMAP;

GETCERTMAP g_aCAPropMap[] = {
  { GETCERT_FILEVERSION,        CR_PROP_FILEVERSION,	   PROPTYPE_STRING, },
  { GETCERT_PRODUCTVERSION,     CR_PROP_PRODUCTVERSION,    PROPTYPE_STRING, },
  { GETCERT_EXITVERSIONBYINDEX, CR_PROP_EXITDESCRIPTION,   PROPTYPE_STRING, },
  { GETCERT_POLICYVERSION,      CR_PROP_POLICYDESCRIPTION, PROPTYPE_STRING, },
  { GETCERT_CANAME,             CR_PROP_CANAME,		   PROPTYPE_STRING, },
  { GETCERT_SANITIZEDCANAME,    CR_PROP_SANITIZEDCANAME,   PROPTYPE_STRING, },
  { GETCERT_SHAREDFOLDER,       CR_PROP_SHAREDFOLDER,	   PROPTYPE_STRING, },
  { GETCERT_PARENTCONFIG,       CR_PROP_PARENTCA,	   PROPTYPE_STRING, },
  { GETCERT_CAINFO,             CR_PROP_CATYPE,		   PROPTYPE_LONG, },
  { GETCERT_CACERTBYINDEX,      CR_PROP_CASIGCERT,	   PROPTYPE_BINARY, },
  { GETCERT_CRLBYINDEX,         CR_PROP_BASECRL,	   PROPTYPE_BINARY, },
  { GETCERT_CACERTSTATEBYINDEX, CR_PROP_CACERTSTATE,	   PROPTYPE_LONG, },
  { GETCERT_CRLSTATEBYINDEX,    CR_PROP_CRLSTATE,	   PROPTYPE_LONG, },
};

// Handled via code hacks:
//{ GETCERT_CASIGCERT,          CR_PROP_CASIGCERTCRLCHAIN, PROPTYPE_BINARY, },
//{ GETCERT_CASIGCERT,          CR_PROP_CASIGCERTCHAIN,    PROPTYPE_BINARY, },
//{ GETCERT_CASIGCERT,          CR_PROP_CASIGCERT,         PROPTYPE_BINARY, },
//{ GETCERT_CAXCHGCERT,         CR_PROP_CAXCHGCERT,        PROPTYPE_BINARY, },
//{ GETCERT_CAXCHGCERT,         CR_PROP_CAXCHGCERTCRLCHAIN,PROPTYPE_BINARY, },
//{ GETCERT_CAXCHGCERT,         CR_PROP_CAXCHGCERTCHAIN,   PROPTYPE_BINARY, },
//{ GETCERT_CURRENTCRL,         CR_PROP_BASECRL,           PROPTYPE_BINARY, },
//{ GETCERT_CATYPE,             CR_PROP_CATYPE,            PROPTYPE_LONG, },


HRESULT
RequestInitCAPropertyInfo(VOID)
{
    HRESULT hr;
    CAPROP *pcap;

    g_CAPropIdMax = 0;
    for (pcap = g_aCAProp; pcap < &g_aCAProp[ARRAYSIZE(g_aCAProp)]; pcap++)
    {
	hr = myCAPropGetDisplayName(pcap->lPropId, &pcap->pwszDisplayName);
	if (S_OK != hr)
	{
	    DBGPRINT((
		DBG_SS_CERTSRVI,
		"myCAPropGetDisplayName(%u)\n",
		pcap->lPropId));
	    _PrintError(hr, "myCAPropGetDisplayName");
	}

	if (g_CAPropIdMax < pcap->lPropId)
	{
	    g_CAPropIdMax = pcap->lPropId;
	}
    }
    return(S_OK);
}


HRESULT
RequestGetCAPropertyInfo(
    OUT LONG          *pcProperty,
    OUT CERTTRANSBLOB *pctbPropInfo)
{
    HRESULT hr;
    LONG i;
    DWORD cb;
    DWORD cbT;
    CATRANSPROP *rgcatp = NULL;
    CATRANSPROP *pcatp;
    CATRANSPROP *pcatpEnd;
    CAPROP *pcap;

    pctbPropInfo->pb = NULL;
    pctbPropInfo->cb = 0;

    hr = S_OK;
    __try
    {
	cb = ARRAYSIZE(g_aCAProp) * sizeof(CATRANSPROP);
	for (i = 0; i < ARRAYSIZE(g_aCAProp); i++)
	{
	    if (NULL != g_aCAProp[i].pwszDisplayName)
	    {
		cbT = (wcslen(g_aCAProp[i].pwszDisplayName) + 1) * sizeof(WCHAR);
		cb += DWORDROUND(cbT);
	    }
	}

	rgcatp = (CATRANSPROP *) CoTaskMemAlloc(cb);
	if (NULL == rgcatp)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "CoTaskMemAlloc rgcatp");
	}

	cb = ARRAYSIZE(g_aCAProp) * sizeof(CATRANSPROP);
	pcatpEnd = &rgcatp[ARRAYSIZE(g_aCAProp)];
	pcap = g_aCAProp;
	for (pcatp = rgcatp; pcatp < pcatpEnd; pcap++, pcatp++)
	{
	    pcatp->lPropId = pcap->lPropId;
	    pcatp->lPropFlags = pcap->lPropFlags;
	    pcatp->obwszDisplayName = 0;
	    DBGPRINT((
		    DBG_SS_CERTSRVI,
		    "RequestGetCAPropertyInfo: ielt=%d idx=%x t=%x \"%ws\"\n",
		    pcatp - rgcatp,
		    pcap->lPropId,
		    pcap->lPropFlags,
		    pcap->pwszDisplayName));

	    if (NULL != pcap->pwszDisplayName)
	    {
		cbT = (wcslen(pcap->pwszDisplayName) + 1) * sizeof(WCHAR);
		CopyMemory(Add2Ptr(rgcatp, cb), pcap->pwszDisplayName, cbT);

		pcatp->obwszDisplayName = cb;
		cb += DWORDROUND(cbT);
	    }
	}

	pctbPropInfo->cb = cb;
	pctbPropInfo->pb = (BYTE *) rgcatp;
	rgcatp = NULL;
	*pcProperty = ARRAYSIZE(g_aCAProp);

	myRegisterMemFree(pctbPropInfo->pb, CSM_MIDLUSERALLOC);
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

//error:
    if (NULL != rgcatp)
    {
	CoTaskMemFree(rgcatp);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
ValidatePropertyParameters(
    LONG PropId,
    LONG PropIndex,
    LONG PropType)
{
    HRESULT hr;
    CAPROP const *pcap;

    hr = E_INVALIDARG;
    for (pcap = g_aCAProp; ; pcap++)
    {
	if (pcap >= &g_aCAProp[ARRAYSIZE(g_aCAProp)])
	{
	    _JumpError(hr, error, "invalid propid");
	}
        if (PropId == pcap->lPropId)
        {
            if ((PropType != (PROPTYPE_MASK & pcap->lPropFlags)) ||
                (0 == (PROPFLAGS_INDEXED & pcap->lPropFlags) && 
                 0 != PropIndex))
            {
	        _JumpError(hr, error, "invalid type/index");
            }
            break;
	}
    }
    hr = S_OK;

error:
    DBGPRINT((
	S_OK != hr? DBG_SS_ERROR : DBG_SS_CERTSRVI,
	"ValidatePropertyParameters(PropId=%x, PropIndex=%x, PropType=%x) -> %x\n",
	PropId,
	PropIndex,
	PropType,
	hr));
    return(hr);
}


// Returns a string containing the list of templates supported
// by this CA, one pair of name and string OID for each template,
// separated by new lines:
//
//     "name1\nOID1\nname2\OID2...\nnameN\nOIDN\0"
//
// If the template doesn't have an OID (Win2k domain) there will
// be an empty string in its place

HRESULT 
GetCATemplates(
    BYTE*& rpb,
    DWORD& rcb)
{
    HRESULT hr = S_OK;
    HCAINFO hCAInfo = NULL;
    HCERTTYPE hCrtCertType = NULL;
    HCERTTYPE hPrevCertType = NULL;
    LPWSTR* pwszCertTypeCN = NULL;
    LPWSTR* pwszCertTypeOID = NULL;
    CTemplateList CATemplateList;

    rpb = NULL;
    rcb = 0;

    hr = CAFindByName(
        g_pwszSanitizedDSName,
        NULL,
        CA_FIND_LOCAL_SYSTEM,
        &hCAInfo);
    _JumpIfError(hr, error, "CAFindByName");

    hr = CAEnumCertTypesForCA(
        hCAInfo, 
        CT_ENUM_MACHINE_TYPES |
        CT_ENUM_USER_TYPES |
        CT_FIND_LOCAL_SYSTEM |
        CT_FLAG_NO_CACHE_LOOKUP,
        &hCrtCertType);
    _JumpIfError(hr, error, "CAEnumCertTypesForCA");

    while(hCrtCertType)
    {
        hr = CAGetCertTypeProperty(
                            hCrtCertType,
                            CERTTYPE_PROP_CN,
                            &pwszCertTypeCN);
        _JumpIfError(hr, error, "CAGetCertTypeProperty CERTTYPE_PROP_CN");

        hr = CAGetCertTypeProperty(
                            hCrtCertType,
                            CERTTYPE_PROP_OID,
                            &pwszCertTypeOID);
        // ignore errors, V1 templates don't have OIDs

        hr = CATemplateList.AddTemplateInfo(
            *pwszCertTypeCN,
            pwszCertTypeOID?*pwszCertTypeOID:NULL);
        _JumpIfError(hr, error, "CTemplateList::AddTemplate");

        if(pwszCertTypeCN)
        {
            CAFreeCertTypeProperty(hCrtCertType, pwszCertTypeCN);
            pwszCertTypeCN = NULL;
        }
        if(pwszCertTypeOID)
        {
            CAFreeCertTypeProperty(hCrtCertType, pwszCertTypeOID);
            pwszCertTypeOID = NULL;
        }
        
        hPrevCertType = hCrtCertType;

        hr = CAEnumNextCertType(hCrtCertType, &hCrtCertType);
        _JumpIfError(hr, error, "CAEnumNextCertType");

        CACloseCertType(hPrevCertType);
    }

    hCrtCertType = NULL;

    hr = CATemplateList.Marshal(rpb, rcb);
    _JumpIfError(hr, error, "CTemplateList::Marshal");


error:

    if(pwszCertTypeCN)
    {
        CSASSERT(hCrtCertType);
        CAFreeCertTypeProperty(hCrtCertType, pwszCertTypeCN);
    }
    if(pwszCertTypeOID)
    {
        CSASSERT(hCrtCertType);
        CAFreeCertTypeProperty(hCrtCertType, pwszCertTypeOID);
    }
    if(hCrtCertType)
    {
        CACloseCertType(hCrtCertType);   
    }
    if(hCAInfo)
    {
        CACloseCA(hCAInfo);
    }

    return hr;
}


HRESULT 
SetCATemplates(
    const BYTE* pb,
    DWORD cb)
{
    HRESULT hr = S_OK;
    HCAINFO hCAInfo = NULL;
    CTemplateList CATemplateList;
    CTemplateListEnum CATemplateListEnum(CATemplateList);
    CTemplateInfo *pTemplateInfo;
    DWORD cTempl;
    DWORD nTemplates;
    LPCWSTR *ppTemplateList = NULL;
    HCERTTYPE hCertType = NULL;
    bool fRefreshTemplateCache = true;

    hr = CATemplateList.Unmarshal(pb, cb);
    _JumpIfError(hr, error, "CTemplateList::Unmarshal");
    
    hr = CAFindByName(
        g_pwszSanitizedDSName,
        NULL,
        CA_FIND_LOCAL_SYSTEM,
        &hCAInfo);
    _JumpIfError(hr, error, "CAFindByName");

    nTemplates = CATemplateList.GetCount();

    ppTemplateList = (LPCWSTR*)LocalAlloc(
        LMEM_FIXED|LMEM_ZEROINIT, 
        sizeof(LPWSTR)* (nTemplates+1) );
    _JumpIfAllocFailed(ppTemplateList, error);

    CATemplateListEnum.Reset();

    for(pTemplateInfo=CATemplateListEnum.Next(), cTempl=0; 
        pTemplateInfo; 
        pTemplateInfo=CATemplateListEnum.Next(), cTempl++)
    {
        
        ppTemplateList[cTempl] = pTemplateInfo->GetName();

        // check if this is a valid template

        hr = CAFindCertTypeByName(
            pTemplateInfo->GetName(),
            NULL,
            CT_FIND_LOCAL_SYSTEM |
            CT_ENUM_MACHINE_TYPES |
            CT_ENUM_USER_TYPES |
            (fRefreshTemplateCache?CT_FLAG_NO_CACHE_LOOKUP:0),
            &hCertType);
        
        fRefreshTemplateCache = false;
        
        if(HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
        {
            // try with the OID

            hr = CAFindCertTypeByName(
                pTemplateInfo->GetOID(),
                NULL,
                CT_FIND_LOCAL_SYSTEM |
                CT_ENUM_MACHINE_TYPES |
                CT_ENUM_USER_TYPES |
                CT_FIND_BY_OID,
                &hCertType);

            if(HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
            {
                hr = CERTSRV_E_UNKNOWN_CERT_TYPE;
                _JumpErrorStr(hr, error, "CAFindCertTypeByOID", 
                    pTemplateInfo->GetOID());
            }
            _JumpIfErrorStr(hr, error, "CAFindCertTypeByName", pTemplateInfo->GetOID());
        }

        _JumpIfErrorStr(hr, error, "CAFindCertTypeByName", pTemplateInfo->GetName());

        CACloseCertType(hCertType);
        hCertType = NULL;
        hr = S_OK;
    }

    ppTemplateList[nTemplates] = NULL;

    hr = CASetCAProperty(hCAInfo, CA_PROP_CERT_TYPES, 
        const_cast<LPWSTR*>(ppTemplateList));
    _JumpIfError(hr, error, "CASetCAProperty(CA_PROP_CERT_TYPES)");

    hr = CAUpdateCA(hCAInfo);
    _JumpIfError(hr, error, "CAUpdateCA");

    // Increment sequence number so that policy module can detect
    // there was a template change
    InterlockedIncrement(&g_cTemplateUpdateSequenceNum);

error:

    LOCAL_FREE(ppTemplateList);
    if(hCAInfo)
    {
        CACloseCA(hCAInfo);
    }

    return hr;
}


STDMETHODIMP
RequestGetCAPropertySub(
    IN  LONG           PropId,		// CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,	// PROPTYPE_*
    OUT CERTTRANSBLOB *pctbOut)
{
    HRESULT hr = S_OK;
    BYTE *pbReturn;
    BYTE *pbAlloc = NULL;
    WCHAR wszVersion[MAX_VERSION_RESOURCE_SIZE];
    BYTE *pb = NULL;
    WCHAR const *pwsz = NULL;
    WCHAR *pwszSharedFolder = NULL;
    CAINFO CAInfo;
    DWORD iCertSig;
    CRL_CONTEXT const *pCRL = NULL;
    WCHAR *pwszUserName = NULL;
    HCERTSTORE hKRAStore = NULL;
    CERT_CONTEXT const *pCertContext = NULL;
    HRESULT hrCAStatusCode;

    hr = ValidatePropertyParameters(PropId, PropIndex, PropType);
    _JumpIfError(hr, error, "Invalid prop params");

    switch (PropId)
    {
	case CR_PROP_FILEVERSION:
	case CR_PROP_PRODUCTVERSION:
	    hr = GetVersionString(PropId, wszVersion);
	    _JumpIfError(hr, error, "GetVersionString");

	    pwsz = wszVersion;
	    break;

	case CR_PROP_EXITDESCRIPTION:
	case CR_PROP_POLICYDESCRIPTION:
	    pwsz = CR_PROP_EXITDESCRIPTION == PropId?
		ExitGetDescription(PropIndex) :
		g_strPolicyDescription;
	    if (NULL == pwsz)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "No description");
	    }
	    break;

	case CR_PROP_CANAME:
	    pwsz = g_wszCommonName;
	    break;

	case CR_PROP_SANITIZEDCANAME:
	    pwsz = g_wszSanitizedName;
	    break;

	case CR_PROP_SANITIZEDCASHORTNAME:
	    pwsz = g_pwszSanitizedDSName;
	    break;

	case CR_PROP_SHAREDFOLDER:
	    hr = myGetCertRegStrValue(
		    NULL,
		    NULL,
		    NULL,
		    wszREGDIRECTORY,
		    &pwszSharedFolder);
	    _JumpIfError(hr, error, "myGetCertRegStrValue");

	    if (NULL == pwszSharedFolder)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "No shared folder");
	    }
	    pwsz = pwszSharedFolder;
	    break;

	case CR_PROP_PARENTCA:
	    if (L'\0' == g_wszParentConfig[0])
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "No parent");
	    }
	    pwsz = g_wszParentConfig;
	    break;

	case CR_PROP_CATYPE:
	case CR_PROP_CASIGCERTCOUNT:
	case CR_PROP_CAXCHGCERTCOUNT:
	case CR_PROP_EXITCOUNT:
	case CR_PROP_CAPROPIDMAX:
	case CR_PROP_ROLESEPARATIONENABLED:
	case CR_PROP_KRACERTUSEDCOUNT:
	case CR_PROP_KRACERTCOUNT:
	case CR_PROP_ADVANCEDSERVER:
	    ZeroMemory(&CAInfo, sizeof(CAInfo));
	    CAInfo.cbSize = sizeof(CAInfo);
	    CAInfo.CAType = g_CAType;
	    CAInfo.cCASignatureCerts = g_cCACerts;
	    CAInfo.cCAExchangeCerts = 1;	// current Xchg cert only
	    CAInfo.cExitModules = g_cExitMod;
	    CAInfo.lPropIdMax = g_CAPropIdMax;
	    CAInfo.lRoleSeparationEnabled = CAuditEvent::RoleSeparationIsEnabled();
	    CAInfo.fAdvancedServer = g_fAdvancedServer;

	    hr = myGetCertRegDWValue(
		    g_wszSanitizedName,
		    NULL,
		    NULL,
		    wszREGKRACERTCOUNT,
		    &CAInfo.cKRACertUsedCount);
	    _JumpIfError(hr, error, "myGetCertRegDWValue wszREGKRACERTCOUNT");
        
	    hr = myGetCARegHashCount(
		g_wszSanitizedName,
		CSRH_CAKRACERT,
		&CAInfo.cKRACertCount);
	    _JumpIfError(hr, error, "myGetCertRegStrValue wszREGKRACERTCOUNT");

	    pctbOut->cb = sizeof(CAInfo);
	    pb = (BYTE *) &CAInfo;
	    break;

	case CR_PROP_CASIGCERT:
	case CR_PROP_CAFORWARDCROSSCERT:
	case CR_PROP_CABACKWARDCROSSCERT:
	    hr = PKCSGetCACert(PropId, PropIndex, &pb, &pctbOut->cb);
	    _JumpIfError(hr, error, "PKCSGetCACert");

	    break;

	case CR_PROP_CASIGCERTCHAIN:
	case CR_PROP_CASIGCERTCRLCHAIN:
	    hr = PKCSGetCAChain(
			    PropIndex,
			    CR_PROP_CASIGCERTCRLCHAIN == PropId,
			    &pbAlloc,
			    &pctbOut->cb);
	    _JumpIfError(hr, error, "PKCSGetCAChain");

	    pb = pbAlloc;	// must be freed
	    break;

	case CR_PROP_CAXCHGCERT:
	    hr = GetClientUserName(NULL, &pwszUserName, NULL);
	    _JumpIfError(hr, error, "GetClientUserName");

	    hr = PKCSGetCAXchgCert(
			    PropIndex,
			    pwszUserName,
			    &iCertSig,
			    &pb,
			    &pctbOut->cb);
	    _JumpIfError(hr, error, "PKCSGetCAXchgCert");

	    break;

	case CR_PROP_CAXCHGCERTCHAIN:
	case CR_PROP_CAXCHGCERTCRLCHAIN:
	    hr = GetClientUserName(NULL, &pwszUserName, NULL);
	    _JumpIfError(hr, error, "GetClientUserName");

	    hr = PKCSGetCAXchgChain(
			    PropIndex,
			    pwszUserName,
			    CR_PROP_CAXCHGCERTCRLCHAIN == PropId,
			    &pbAlloc,
			    &pctbOut->cb);
	    _JumpIfError(hr, error, "PKCSGetCAXchgChain");

	    pb = pbAlloc;	// must be freed
	    break;

	case CR_PROP_BASECRL:
	case CR_PROP_DELTACRL:
	    hr = CRLGetCRL(
		    PropIndex,
		    CR_PROP_DELTACRL == PropId,
		    &pCRL,
		    NULL);
	    _JumpIfError(hr, error, "CRLGetCRL");

	    pctbOut->cb = pCRL->cbCrlEncoded;
	    pb = (BYTE *) pCRL->pbCrlEncoded;
	    break;

	case CR_PROP_CACERTSTATUSCODE:
	    hr = PKCSGetCACertStatusCode(PropIndex, &hrCAStatusCode);
	    pctbOut->cb = sizeof(hrCAStatusCode);
	    pb = (BYTE *) &hrCAStatusCode;
	    break;

	case CR_PROP_CACERTSTATE:
	case CR_PROP_CRLSTATE:
	case CR_PROP_CAFORWARDCROSSCERTSTATE:
	case CR_PROP_CABACKWARDCROSSCERTSTATE:
	    pctbOut->cb = g_cCACerts;
	    pbAlloc = (BYTE *) CoTaskMemAlloc(pctbOut->cb);
	    if (NULL == pbAlloc)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "no memory");
	    }
	    pb = pbAlloc;	// must be freed

	    hr = PKCSGetCAState(PropId, pb);
	    _JumpIfError(hr, error, "PKCSGetCAState");
	    break;

	case CR_PROP_CACERTVERSION:
	    pctbOut->cb = sizeof(DWORD) * g_cCACerts;
	    pbAlloc = (BYTE *) CoTaskMemAlloc(pctbOut->cb);
	    if (NULL == pbAlloc)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "no memory");
	    }
	    pb = pbAlloc;	// must be freed

	    hr = PKCSGetCAVersion((DWORD *) pb);
	    _JumpIfError(hr, error, "PKCSGetCAState");
	    break;

	case CR_PROP_KRACERTSTATE:
	    hr = myGetCARegHashCount(
		    g_wszSanitizedName,
		    CSRH_CAKRACERT,
		    &pctbOut->cb);
	    _JumpIfError(hr, error, "myGetCARegHashCount CSRH_CAKRACERT");

	    pbAlloc = (BYTE *) CoTaskMemAlloc(pctbOut->cb);
	    if (NULL == pbAlloc)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "no memory");
	    }
	    pb = pbAlloc;	// must be freed
	    hr = PKCSGetKRAState(pctbOut->cb, pb);
	    _JumpIfError(hr, error, "PKCSGetKRAState");

	    break;

	case CR_PROP_DNSNAME:
	    pwsz = g_pwszServerName;
	    break;

	case CR_PROP_KRACERT:
	    hKRAStore = CertOpenStore(
				CERT_STORE_PROV_SYSTEM_W,
				X509_ASN_ENCODING,
				NULL,                   // hProv
				CERT_SYSTEM_STORE_LOCAL_MACHINE |
				    CERT_STORE_READONLY_FLAG,
				wszKRA_CERTSTORE);

	    hr = myFindCACertByHashIndex(
		    hKRAStore,
		    g_wszSanitizedName,
		    CSRH_CAKRACERT,
		    PropIndex,
		    NULL,
		    &pCertContext);
	    _JumpIfError(hr, error, "myFindCACertByHashIndex");

	    pb = pCertContext->pbCertEncoded;
	    pctbOut->cb = pCertContext->cbCertEncoded;
	    break;

	case CR_PROP_TEMPLATES:
	    hr = GetCATemplates(pbAlloc, pctbOut->cb);
	    _JumpIfError(hr, error, "GetCATemplates");

	    break;

	case CR_PROP_BASECRLPUBLISHSTATUS:
	case CR_PROP_DELTACRLPUBLISHSTATUS:
    
	    pctbOut->cb = sizeof(DWORD);
	    pbAlloc = (BYTE *) CoTaskMemAlloc(pctbOut->cb);
	    _JumpIfAllocFailed(pbAlloc, error);

	    pb = pbAlloc;	// must be freed

	    hr = CRLGetCRL(
		    PropIndex,
		    CR_PROP_DELTACRLPUBLISHSTATUS == PropId, // fDelta
		    NULL,
		    (DWORD *) pbAlloc);
	    _JumpIfError(hr, error, "CRLGetCRL");

	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Bad PropId");
    }

    // not yet populated?

    if (NULL == pb && NULL != pwsz)
    {
	pctbOut->cb = (wcslen(pwsz) + 1) * sizeof(WCHAR);
	pb = (BYTE *) pwsz;
    }
    if (NULL != pbAlloc)
    {
	pctbOut->pb = pbAlloc;
	pbAlloc = NULL;
    }
    else
    {
        if (NULL == pb)
        {
            hr = E_POINTER;
            _JumpError(hr, error, "pb NULL");
        }

	pbReturn = (BYTE *) CoTaskMemAlloc(pctbOut->cb);
	if (NULL == pbReturn)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "no memory");
	}
	CopyMemory(pbReturn, pb, pctbOut->cb);
	pctbOut->pb = pbReturn;
    }

error:
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (NULL != pCRL)
    {
        CertFreeCRLContext(pCRL);
    }
    if (NULL != pbAlloc)
    {
	CoTaskMemFree(pbAlloc);
    }
    if (NULL != pwszSharedFolder)
    {
        LocalFree(pwszSharedFolder);
    }
    if (NULL != hKRAStore)
    {
        CertCloseStore(hKRAStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
RequestGetCAProperty(
    IN  LONG           PropId,          // CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,        // PROPTYPE_*
    OUT CERTTRANSBLOB *pctbPropertyValue)
{
    HRESULT hr;

    pctbPropertyValue->pb = NULL;
    pctbPropertyValue->cb = 0;

    hr = RequestGetCAPropertySub(
                            PropId,
                            PropIndex,
                            PropType,
                            pctbPropertyValue);
    _JumpIfError(hr, error, "RequestGetCAPropertySub");

    myRegisterMemFree(pctbPropertyValue->pb, CSM_COTASKALLOC);

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
RequestSetCAPropertySub(
    IN  LONG           PropId,		// CR_PROP_*
    IN  LONG           PropIndex,
    IN  CERTTRANSBLOB *pctbIn)
{
    HRESULT hr = S_OK;
    LONG lVal = 0;
    const CERT_CONTEXT *pCertContext = NULL;
    HCERTSTORE hKRAStore = NULL;

    switch(PropId)
    {
	case CR_PROP_ROLESEPARATIONENABLED:
        {
	    lVal = *(LONG *) pctbIn->pb;
	    CAuditEvent SaveFlagObj; // used just for saving the flag
	    SaveFlagObj.RoleSeparationEnable(lVal? true : false);
	    hr = SaveFlagObj.RoleSeparationFlagSave(g_wszSanitizedName);
	    _JumpIfError(hr, error, "failed to save ");
        }
        break;

    case CR_PROP_KRACERTUSEDCOUNT:
        CSASSERT(sizeof(DWORD)==pctbIn->cb);
        hr = mySetCertRegDWValue(
                g_wszSanitizedName,
                NULL,
                NULL,
                wszREGKRACERTCOUNT,
                *(DWORD*)pctbIn->pb);
        _JumpIfError(hr, error, "mySetCertRegDWValue ");
        break;

    case CR_PROP_KRACERTCOUNT:
        // New hash count; calling this should follow a sequence of 
        // SetCAProperty(CR_PROP_KRACERT) and should be called only if 
        // new hash count is smaller than current count. If PropIndex>=current count
        // this fails with E_INVALIDARG;
        CSASSERT(sizeof(DWORD)==pctbIn->cb);
        hr = myShrinkCARegHash(
                g_wszSanitizedName,
                CSRH_CAKRACERT,
                *(DWORD*)pctbIn->pb);
        _JumpIfError(hr, error, "myShrinkCARegHash");
        break;

    case CR_PROP_KRACERT:
        pCertContext = CertCreateCertificateContext(
            X509_ASN_ENCODING,
            pctbIn->pb,
            pctbIn->cb);

        if(!pCertContext)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CertCreateCertificateContext");
        }

        // add certificate to KRA store
        hKRAStore = CertOpenStore(
                           CERT_STORE_PROV_SYSTEM_W,
                           X509_ASN_ENCODING,
                           NULL,                   // hProv
                           CERT_SYSTEM_STORE_LOCAL_MACHINE,
                           wszKRA_CERTSTORE);
        if (NULL == hKRAStore)
        {
           hr = myHLastError();
           _JumpError(hr, error, "CertOpenStore");
        }

        if (!CertAddCertificateContextToStore(
                    hKRAStore,
                    pCertContext,
                    CERT_STORE_ADD_NEW,
                    NULL))
        {
            hr = myHLastError();
            if (HRESULT_FROM_WIN32(CRYPT_E_EXISTS) != hr)
            {
                _JumpError(hr, error, "CertAddCertificateContextToStore");
            }
            //the cert exists, ignore error
            hr = S_OK;
        }

        // persist the hash        
        hr = mySetCARegHash(
                g_wszSanitizedName,
                CSRH_CAKRACERT,
                PropIndex,
                pCertContext);
        _JumpIfError(hr, error, "mySetCARegHash");
        break;

    case CR_PROP_TEMPLATES:
        hr = SetCATemplates(
            pctbIn->pb,
            pctbIn->cb);
        _JumpIfError(hr, error, "GetCATemplates");
        break;
        
    default:
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Bad PropId");
    }

error:
    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }
    return hr;
}


#pragma warning(push)
#pragma warning(disable: 4509) // nonstandard extension used: uses SEH and has destructor
STDMETHODIMP
RequestSetCAProperty(
    IN  wchar_t const *pwszAuthority,
    IN  LONG           PropId,          // CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,        // PROPTYPE_*
    IN  CERTTRANSBLOB *pctbPropertyValue)
{
    HRESULT hr;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SETCAPROPERTY, g_dwAuditFilter);
    DWORD State = 0;
    VARIANT varPropertyValue;

    VariantInit(&varPropertyValue);

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
        hr = ValidatePropertyParameters(
                PropId,
                PropIndex,
                PropType);
        _LeaveIfError(hr, "Invalid prop params");

        hr = CheckAuthorityName(pwszAuthority);
        _LeaveIfError(hr, "No authority name");

        // Ignore role separation if setting the role separation flag.
        // This allows an admin to turn the flag off even with role separation
        // enabled so he won't lock himself out.
        if(CR_PROP_ROLESEPARATIONENABLED==PropId)
        {
            audit.EventRoleSeparationEnable(false);
        }

        hr = audit.AddData((DWORD)PropId); // %1 property ID
        _JumpIfError(hr, error, "CAuditEvent::AddData");

        hr = audit.AddData((DWORD)PropIndex); // %2 index
        _JumpIfError(hr, error, "CAuditEvent::AddData");

        hr = audit.AddData((DWORD)PropType); // %3 type
        _JumpIfError(hr, error, "CAuditEvent::AddData");

        hr = myUnmarshalVariant(
            PropType,
            pctbPropertyValue->cb,
            pctbPropertyValue->pb,
            &varPropertyValue);
        // binary type or could not unmarshal, dump as a blob
        if(PROPTYPE_BINARY==PropType || S_OK != hr)
        {
            hr = audit.AddData(pctbPropertyValue->pb, pctbPropertyValue->cb); // %4 value
            _JumpIfError(hr, error, "CAuditEvent::AddData");
        }
        else
        {
            hr = audit.AddData(&varPropertyValue, false); // %4 value
            _JumpIfError(hr, error, "CAuditEvent::AddData");
        }

        hr = audit.AccessCheck(
		    CA_ACCESS_ADMIN,
		    audit.m_gcAuditSuccessOrFailure);
        _LeaveIfError(hr, "CAuditEvent::AccessCheck");

        hr = RequestSetCAPropertySub(
                                PropId,
                                PropIndex,
                                pctbPropertyValue);
        _LeaveIfError(hr, "RequestSetCAPropertySub");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    VariantClear(&varPropertyValue);
    return(hr);
}
#pragma warning(pop)


STDMETHODIMP
CCertRequestD::GetCACert(
    /* [in] */ DWORD Flags,
    /* [unique][size_is][in] */ USHORT const __RPC_FAR *pwszAuthority,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbOut)
{
    HRESULT hr = S_OK;
    DWORD type = GETCERT_VERSIONMASK & Flags;
    LONG PropIndex;
    LONG PropId;
    LONG PropType;
    GETCERTMAP const *pmap;
    DWORD State = 0;

    DBGPRINT((
	    s_ssRequest,
	    "CCertRequestD::GetCACert(tid=%d, Flags=0x%x)\n",
	    GetCurrentThreadId(),
	    Flags));

    hr = CertSrvEnterServer(&State);    
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    // allow empty name only if the client attempts retrieving the name
    if(hr == E_INVALIDARG &&
       (GETCERT_CANAME ==  type ||
        GETCERT_SANITIZEDCANAME == type))
    {
        hr = S_OK;
    }
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	hr = RequestAccessCheck();
	_LeaveIfError(hr, "RequestAccessCheck");

	type = GETCERT_VERSIONMASK & Flags;

	PropIndex = 0;

	// NOTE: all of these should return only a single entry -- 
	// multiple entries will be batched up by the caller 
	// (eg multiple CAs on a machine)

	DBGCODE(WCHAR wszArg[8 + cwcDWORDSPRINTF]); // For a nice debug print:

	PropId = 0;
	PropType = PROPTYPE_BINARY;
	switch (type)
	{
	    case GETCERT_CASIGCERT:
		DBGCODE(wcscpy(wszArg, L"Cert"));
		PropId = CR_PROP_CASIGCERT;
		PropIndex = -1;	// return latest Cert
		break;

	    case GETCERT_CAXCHGCERT:
		DBGCODE(wcscpy(wszArg, L"XchgCert"));
		PropId = CR_PROP_CAXCHGCERT;
		PropIndex = -1;	// return latest Xchg Cert
		break;

	    case GETCERT_CURRENTCRL:
		DBGCODE(wcscpy(wszArg, L"CRL"));
		PropId = CR_PROP_BASECRL;
		PropIndex = -1;	// return latest CRL
		break;

	    default:
	    {
		DBGCODE(wszArg[0] = ((char *) &type)[3]);
		DBGCODE(wszArg[1] = ((char *) &type)[2]);
		DBGCODE(wszArg[2] = ((char *) &type)[1]);
		DBGCODE(wszArg[3] = ((char *) &type)[0]);
		DBGCODE(wszArg[4] = L'\0');

		switch (GETCERT_BYINDEXMASK & Flags)
		{
		    case GETCERT_CACERTSTATEBYINDEX:
		    case GETCERT_CRLSTATEBYINDEX:
			if (0 != (GETCERT_INDEXVALUEMASK & Flags))
			{
			    hr = E_INVALIDARG;
			    _LeaveError(hr, "Invalid State Index");
			}
			// FALLTHROUGH

		    case GETCERT_EXITVERSIONBYINDEX:
		    case GETCERT_CACERTBYINDEX:
		    case GETCERT_CRLBYINDEX:
			PropIndex = GETCERT_INDEXVALUEMASK & Flags;
			type = GETCERT_BYINDEXMASK & Flags;
			DBGCODE(swprintf(&wszArg[2], L".%u", PropIndex));
		    break;
		}
		break;
	    }
	}
	DBGPRINT((
		s_ssRequest,
		"CCertRequestD::GetCACert(\"%ws\"%ws)\n",
		wszArg,
		(GETCERT_CHAIN & Flags)? L"+Chain" : L""));

	for (
	    pmap = g_aCAPropMap;
	    pmap < &g_aCAPropMap[ARRAYSIZE(g_aCAPropMap)];
	    pmap++)
	{
	    if (type == pmap->dwGetCert)
	    {
		PropId = pmap->lPropId;
		PropType = pmap->lPropType;
		break;
	    }
	}
	if (CR_PROP_CASIGCERT == PropId)
	{
	    if (GETCERT_CHAIN & Flags)
	    {
		PropId = CR_PROP_CASIGCERTCHAIN;
		if (GETCERT_CRLS & Flags)
		{
		    PropId = CR_PROP_CASIGCERTCRLCHAIN;
		}
	    }
	}
	else if (CR_PROP_CAXCHGCERT == PropId)
	{
	    if (GETCERT_CHAIN & Flags)
	    {
		PropId = CR_PROP_CAXCHGCERTCHAIN;
		if (GETCERT_CRLS & Flags)
		{
		    PropId = CR_PROP_CAXCHGCERTCRLCHAIN;
		}
	    }
	}
	else if ((GETCERT_CHAIN | GETCERT_CRLS) & Flags)
	{
	    hr = E_INVALIDARG;
	    _LeaveError(hr, "Chain/CRLS Flag");
	}

	if (0 == PropId)
	{
	    BYTE *pb;
	    
	    switch (type)
	    {
		case GETCERT_CATYPE:
		    pctbOut->cb = sizeof(g_CAType);
		    pb = (BYTE *) &g_CAType;
		    break;

		default:
		    hr = E_INVALIDARG;
		    _LeaveError(hr, "Invalid GetCert Flags");
	    }
	    pctbOut->pb = (BYTE *) CoTaskMemAlloc(pctbOut->cb);
	    if (NULL == pctbOut->pb)
	    {
		hr = E_OUTOFMEMORY;
		_LeaveError(hr, "no memory");
	    }
	    CopyMemory(pctbOut->pb, pb, pctbOut->cb);
	}
	else
	{
	    hr = RequestGetCAPropertySub(
				    PropId,
				    PropIndex,
				    PropType,
				    pctbOut);
	    _LeaveIfError(hr, "RequestGetCAPropertySub");
	}
	myRegisterMemFree(pctbOut->pb, CSM_COTASKALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertRequestD::GetCAProperty(
    IN  wchar_t const *pwszAuthority,
    IN  LONG           PropId,		// CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,	// PROPTYPE_*
    OUT CERTTRANSBLOB *pctbPropertyValue)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssRequest,
	"CCertRequestD::GetCAProperty(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    if (NULL == pwszAuthority ||
        ((L'\0' != *pwszAuthority ||
        (CR_PROP_CANAME != PropId &&
         CR_PROP_DNSNAME != PropId &&
         CR_PROP_SANITIZEDCANAME != PropId)) &&
         0 != mylstrcmpiL(pwszAuthority, g_wszCommonName) &&
         0 != mylstrcmpiL(pwszAuthority, g_wszSanitizedName) &&
         0 != mylstrcmpiL(pwszAuthority, g_pwszSanitizedDSName)))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "bad authority name");
    }

    __try
    {
        hr = RequestAccessCheck();
        _LeaveIfError(hr, "RequestAccessCheck");

        hr = RequestGetCAProperty(
                PropId,
                PropIndex,
                PropType,
                pctbPropertyValue);
        _LeaveIfError(hr,  "RequestGetCAProperty");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertRequestD::GetCAPropertyInfo(
    IN  wchar_t const *pwszAuthority,
    OUT LONG          *pcProperty,
    OUT CERTTRANSBLOB *pctbPropInfo)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssRequest,
	"CCertRequestD::GetCAPropertyInfo(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
        hr = RequestAccessCheck();
        _LeaveIfError(hr, "RequestAccessCheck");

        hr = RequestGetCAPropertyInfo(
                pcProperty,
                pctbPropInfo);
        _JumpIfError(hr, error, "RequestGetCAPropertyInfo");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
CCertRequestD::_Ping(
    IN WCHAR const *pwszAuthority)
{
    HRESULT hr;
    DWORD State = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
    hr = CheckAuthorityName(pwszAuthority, true); // allow empty name
    _JumpIfError(hr, error, "No authority name");

    hr = RequestAccessCheck();
    _LeaveIfError(hr, "RequestAccessCheck");
    
#if 1
    wprintf(L".");	// may fault if I/O buffer is odd aligned
    fprintf(stdout, ".");
    wprintf(L".\n");	// may fault if I/O buffer is odd aligned
#endif

    hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertRequestD::Ping(
    IN WCHAR const *pwszAuthority)
{
    HRESULT hr;
    
    DBGPRINT((
	s_ssRequest,
	"CCertRequestD::Ping(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = _Ping(pwszAuthority);
    _JumpIfError(hr, error, "_Ping");

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertRequestD::Ping2(
    IN WCHAR const *pwszAuthority)
{
    HRESULT hr;
    
    DBGPRINT((
	s_ssRequest,
	"CCertRequestD::Ping2(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = _Ping(pwszAuthority);
    _JumpIfError(hr, error, "_Ping");

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// Constructor
CCertRequestD::CCertRequestD() : m_cRef(1)
{
    InterlockedIncrement(&g_cRequestComponents);
}


// Destructor
CCertRequestD::~CCertRequestD()
{
    InterlockedDecrement(&g_cRequestComponents);
    if (m_cRef != 0)
    {
	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "CCertRequestD has %d instances left over\n",
	    m_cRef));
    }
}


// IUnknown implementation
STDMETHODIMP
CCertRequestD::QueryInterface(const IID& iid, void** ppv)
{
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<ICertRequestD *>(this);
    }
    else if (iid == IID_ICertRequestD)
    {
	*ppv = static_cast<ICertRequestD *>(this);
    }
    else if (iid == IID_ICertRequestD2)
    {
	*ppv = static_cast<ICertRequestD2 *>(this);
    }
    else
    {
	*ppv = NULL;
	return(E_NOINTERFACE);
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    return(S_OK);
}


ULONG STDMETHODCALLTYPE
CCertRequestD::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CCertRequestD::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}


// Class factory IUnknown implementation
STDMETHODIMP
CRequestFactory::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
	*ppv = static_cast<IClassFactory*>(this);
    }
    else
    {
	*ppv = NULL;
	return(E_NOINTERFACE);
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    return(S_OK);
}


ULONG STDMETHODCALLTYPE
CRequestFactory::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CRequestFactory::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
	return(0);
    }
    return(cRef);
}


// IClassFactory implementation
STDMETHODIMP
CRequestFactory::CreateInstance(
    IUnknown *pUnknownOuter,
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    CCertRequestD *pA;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
	hr = CLASS_E_NOAGGREGATION;
	_JumpError(hr, error, "pUnknownOuter");
    }

    // Create component.

    pA = new CCertRequestD;
    if (pA == NULL)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "out of memory");
    }

    // Get the requested interface.

    hr = pA->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)

    pA->Release();

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// LockServer
STDMETHODIMP
CRequestFactory::LockServer(
    BOOL bLock)
{
    if (bLock)
    {
	InterlockedIncrement(&g_cRequestServerLocks);
    }
    else
    {
	InterlockedDecrement(&g_cRequestServerLocks);
    }
    return(S_OK);
}


STDMETHODIMP
CRequestFactory::CanUnloadNow()
{
    if (g_cRequestComponents || g_cRequestServerLocks)
    {
        return(S_FALSE);
    }
    return(S_OK);
}


STDMETHODIMP
CRequestFactory::StartFactory()
{
    HRESULT hr;

    g_pIRequestFactory = new CRequestFactory();
    if (NULL == g_pIRequestFactory)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "alloc CRequestFactory");
    }

    hr = CoRegisterClassObject(
                      CLSID_CCertRequestD,
                      static_cast<IUnknown *>(g_pIRequestFactory),
                      CLSCTX_LOCAL_SERVER,
                      REGCLS_MULTIPLEUSE,
                      &g_dwRequestRegister);
    _JumpIfError(hr, error, "CoRegisterClassObject");

error:
    if (S_OK != hr)
    {
        // does deletion
	CRequestFactory::StopFactory();
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


VOID
CRequestFactory::StopFactory()
{
    HRESULT hr;
    
    if (0 != g_dwRequestRegister)
    {
        hr = CoRevokeClassObject(g_dwRequestRegister);
	_PrintIfError(hr, "CoRevokeClassObject");
        g_dwRequestRegister = 0;
    }
    if (NULL != g_pIRequestFactory)
    {
        g_pIRequestFactory->Release();
        g_pIRequestFactory = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\rpc.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        rpc.cpp
//
// Contents:    Cert Server RPC
//
// History:     03-Sep-96       larrys created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>
#include <accctrl.h>

#include "certrpc.h"
#include "certacl.h"
#include "cscom.h"
#include "resource.h"

#define __dwFILE__	__dwFILE_CERTSRV_RPC_CPP__


RPC_BINDING_VECTOR *pvBindings  = NULL;

char *pszProtSeqNp = "ncacn_np";

char *pszProtSeqTcp = "ncacn_ip_tcp";


typedef struct _CS_RPC_ATHN_LIST
{
    DWORD dwAuthnLevel;
    DWORD dwPrinceNameService;
    DWORD dwAuthnService;
} CS_RPC_ATHN_LIST ;

CS_RPC_ATHN_LIST  g_acsAthnList[] =
{
    { RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, RPC_C_AUTHN_GSS_NEGOTIATE, RPC_C_AUTHN_GSS_NEGOTIATE },
    { RPC_C_AUTHN_LEVEL_NONE, RPC_C_AUTHN_NONE, RPC_C_AUTHN_NONE }
};

DWORD g_ccsAthnList = sizeof(g_acsAthnList)/sizeof(g_acsAthnList[0]);


HRESULT
RPCInit(VOID)
{
    char *pszEndpoint = "\\pipe\\cert";

    LPSTR pszPrincName = NULL;
    HRESULT hr;
    DWORD i;

    if (RPC_S_OK == RpcNetworkIsProtseqValidA((unsigned char *) pszProtSeqNp))
    {
        hr = RpcServerUseProtseqEpA(
                            (unsigned char *) pszProtSeqNp,
                            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                            (unsigned char *) pszEndpoint,
                            NULL);
        _JumpIfError(hr, error, "RpcServerUseProtseqEpA");
    }

    if (RPC_S_OK == RpcNetworkIsProtseqValidA((unsigned char *) pszProtSeqTcp))
    {

        hr = RpcServerUseProtseqA(
                            (unsigned char *) pszProtSeqTcp,
                            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                            NULL);
	if ((HRESULT) ERROR_OUTOFMEMORY == hr)
	{
	    OSVERSIONINFO ovi;

	    ovi.dwOSVersionInfoSize = sizeof(ovi);
	    if (GetVersionEx(&ovi) &&
		VER_PLATFORM_WIN32_NT == ovi.dwPlatformId &&
		4 >= ovi.dwMajorVersion)
	    {
		hr = S_OK;			// Ignore IP failure
	    }
	}
        _JumpIfError(hr, error, "RpcServerUseProtseqA");
    }

    hr = RpcServerInqBindings(&pvBindings);
    _JumpIfError(hr, error, "RpcServerInqBindings");

    hr = RpcServerRegisterIf(s_ICertPassage_v0_0_s_ifspec, NULL, NULL);
    _JumpIfError(hr, error, "RpcServerRegisterIf");

    // Register Authentication Services

    for (i = 0; i < g_ccsAthnList; i++)
    {

        pszPrincName = NULL;
        if (g_acsAthnList[i].dwPrinceNameService != RPC_C_AUTHN_NONE)
        {
            hr  = RpcServerInqDefaultPrincNameA(
					g_acsAthnList[i].dwPrinceNameService,
					(BYTE **) &pszPrincName);
            if (hr != RPC_S_OK)
            {
                continue;
            }
        }



        hr = RpcServerRegisterAuthInfoA(
				    (BYTE *) pszPrincName,
				    g_acsAthnList[i].dwAuthnService,
				    0,
				    0);
        if(hr == RPC_S_UNKNOWN_AUTHN_SERVICE)
        {
            continue;
        }
        if(hr != RPC_S_OK)
        {
            break;
        }
    }

    if (hr != RPC_S_UNKNOWN_AUTHN_SERVICE)
    {
        _JumpIfError(hr, error, "RpcServerRegisterAuthInfoA");
    }


    hr = RpcEpRegister(s_ICertPassage_v0_0_s_ifspec, pvBindings, NULL, NULL);
    _JumpIfError(hr, error, "RpcEpRegister");

    // Listen, but don't wait...

    hr = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, TRUE);
    if ((HRESULT) RPC_S_ALREADY_LISTENING == hr)
    {
	hr = S_OK;
    }
    _JumpIfError(hr, error, "RpcServerListen");

error:
    if (NULL != pszPrincName)
    {
        RpcStringFreeA((BYTE **) &pszPrincName);
    }
    return(hr);
}


HRESULT
RPCTeardown(VOID)
{ 
    HRESULT hr;
    
    // tear down, don't wait for calls to complete

    hr = RpcServerUnregisterIf(s_ICertPassage_v0_0_s_ifspec, NULL, FALSE);  
    _JumpIfError(hr, error, "RpcServerUnregisterIf");

    // We have no good way of knowing if all RPC requests are done, so let it
    // leak on shutdown.
    // RPC_STATUS RPC_ENTRY RpcMgmtWaitServerListen(VOID); ??

    hr = S_OK;

error:
    return(hr);
}


HRESULT
SetTransBlobString(
    CERTTRANSBLOB const *pctb,
    WCHAR const **ppwsz)
{
    HRESULT hr;

    if (NULL != pctb->pb && 0 != pctb->cb)
    {
	*ppwsz = (WCHAR const *) pctb->pb;

	// use lstrlen here for protection against non-zero terminated bufs!
	// lstrlen will catch AV's and return error

	if ((lstrlen(*ppwsz) + 1) * sizeof(WCHAR) != pctb->cb)
	{
	    hr = E_INVALIDARG;
	    _JumpIfError(hr, error, "Bad TransBlob string");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


/* server prototype */
DWORD
s_CertServerRequest(
    /* [in] */ handle_t h,
    /* [in] */ DWORD dwFlags,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [ref][out][in] */ DWORD __RPC_FAR *pdwRequestId,
    /* [out] */ DWORD __RPC_FAR *pdwDisposition,
    /* [ref][in] */ CERTTRANSBLOB const __RPC_FAR *pctbAttribs,
    /* [ref][in] */ CERTTRANSBLOB const __RPC_FAR *pctbRequest,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbCertChain,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbEncodedCert,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbDispositionMessage)
{
    HRESULT hr = S_OK;
    DWORD OpRequest;
    WCHAR const *pwszAttributes = NULL;
    WCHAR const *pwszSerialNumber = NULL;
    CERTTRANSBLOB ctbEmpty = { 0, NULL };
    CERTTRANSBLOB const *pctbSerial = &ctbEmpty;
    WCHAR *pwszUserName = NULL;
    DWORD dwComContextIndex = MAXDWORD;
    CERTSRV_COM_CONTEXT ComContext;
    CERTSRV_RESULT_CONTEXT ResultContext;
    DWORD State = 0;

    ZeroMemory(&ComContext, sizeof(ComContext));
    ZeroMemory(&ResultContext, sizeof(ResultContext));

    DBGPRINT((
	    DBG_SS_CERTSRV,
	    "s_CertServerRequest(tid=%d)\n",
	    GetCurrentThreadId()));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    hr = RegisterComContext(&ComContext, &dwComContextIndex);
    _JumpIfError(hr, error, "RegisterComContext");

    OpRequest = CR_IN_RETRIEVE;
    if (NULL != pctbRequest->pb)
    {
	*pdwRequestId = 0;
	OpRequest = CR_IN_NEW;
    }
    else
    {
	// RetrievePending by SerialNumber in pctbAttribs

	pctbSerial = pctbAttribs;
	pctbAttribs = &ctbEmpty;
    }
    *pdwDisposition = CR_DISP_ERROR;

    __try
    {
	BOOL fInRequestGroup;

        hr = CheckCertSrvAccess(
			    pwszAuthority,
			    h,
			    CA_ACCESS_ENROLL,
			    &fInRequestGroup,
			    &ComContext.hAccessToken);
	_LeaveIfError(hr, "CheckCertSrvAccess");

	ComContext.dwFlags |= CCCF_INREQUESTGROUPSET;
	if (fInRequestGroup)
	{
	    ComContext.dwFlags |= CCCF_INREQUESTGROUP;
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }
    _JumpIfError(hr, error, "CheckCertSrvAccess");

    hr = SetTransBlobString(pctbAttribs, &pwszAttributes);
    _JumpIfError(hr, error, "SetTransBlobString");

    hr = SetTransBlobString(pctbSerial, &pwszSerialNumber);
    _JumpIfError(hr, error, "SetTransBlobString");

    ResultContext.pdwRequestId = pdwRequestId;
    ResultContext.pdwDisposition = pdwDisposition;
    ResultContext.pctbDispositionMessage = pctbDispositionMessage;
    ResultContext.pctbCert = pctbEncodedCert;
    if (CR_IN_FULLRESPONSE & dwFlags)
    {
	ResultContext.pctbFullResponse = pctbCertChain;
    }
    else
    {
	ResultContext.pctbCertChain = pctbCertChain;
    }

    __try
    {
	hr = GetClientUserName(
			h,
			&pwszUserName,
			CR_IN_NEW == OpRequest && IsEnterpriseCA(g_CAType)?
			    &ComContext.pwszUserDN : NULL);
	_LeaveIfError(hr, "GetClientUserName");

	hr = CoreProcessRequest(
			OpRequest | (dwFlags & CR_IN_FORMATMASK),
			pwszUserName,
			pctbRequest->cb,	// cbRequest
			pctbRequest->pb,	// pbRequest
			pwszAttributes,
			pwszSerialNumber,
			dwComContextIndex,
			*pdwRequestId,
			&ResultContext);	// Allocates returned memory
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "CoreProcessRequest");

    // Post-processing
    pctbDispositionMessage->cb = 0;
    if (NULL != pctbDispositionMessage->pb)
    {
        pctbDispositionMessage->cb =
           (wcslen((WCHAR *) pctbDispositionMessage->pb) + 1) * sizeof(WCHAR);
    }

error:
    ReleaseResult(&ResultContext);
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (NULL != ComContext.hAccessToken)
    {
	HRESULT hr2 = S_OK;

        // closehandle can throw
        __try
        {
            CloseHandle(ComContext.hAccessToken);
        }
        __except(hr2 = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
	    _PrintError(hr2, "Exception");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
        }
    }
    ReleaseComContext(&ComContext);
    if (MAXDWORD != dwComContextIndex)
    {
	UnregisterComContext(&ComContext, dwComContextIndex);
    }
    CertSrvExitServer(
		State,
		(S_OK == hr &&
		 NULL != pdwDisposition &&
		 FAILED(*pdwDisposition))?
		     *pdwDisposition : hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


//+--------------------------------------------------------------------------
// MIDL_user_allocate -- Allocates memory for RPC operations.
//
// Parameters:
// cb - # of bytes to allocate
//
// Returns:
// Memory allocated, or NULL if not enough memory.
//---------------------------------------------------------------------------

void __RPC_FAR * __RPC_USER
MIDL_user_allocate(
    IN size_t cb)
{
    void *pv;
    
    if (cb > g_cbMaxIncomingAllocSize)
    {
	_PrintError(MEM_E_INVALID_SIZE, "g_cbMaxIncomingAllocSize");
	SetLastError((DWORD) MEM_E_INVALID_SIZE);
	pv = NULL;
    }
    else
    {
	pv = CoTaskMemAlloc(cb);
    }
    return(pv);
}


//+--------------------------------------------------------------------------
// MIDL_user_free -- Free memory allocated via MIDL_user_allocate.
//
// Parameters:
// pvBuffer - The buffer to free.
//
// Returns:
// None.
//---------------------------------------------------------------------------

void __RPC_USER
MIDL_user_free(
    IN void __RPC_FAR *pb)
{
    CoTaskMemFree(pb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certview\attrib.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        attrib.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <certdb.h>
#include "csdisp.h"
#include "column.h"
#include "attrib.h"
#include "ext.h"
#include "row.h"
#include "view.h"

#define __dwFILE__	__dwFILE_CERTVIEW_ATTRIB_CPP__


#if DBG_CERTSRV
LONG g_cCertViewAttribute;
LONG g_cCertViewAttributeTotal;
#endif

CEnumCERTVIEWATTRIBUTE::CEnumCERTVIEWATTRIBUTE()
{
    DBGCODE(InterlockedIncrement(&g_cCertViewAttribute));
    DBGCODE(InterlockedIncrement(&g_cCertViewAttributeTotal));
    m_pvw = NULL;
    m_aelt = NULL;
    m_cRef = 1;
}


CEnumCERTVIEWATTRIBUTE::~CEnumCERTVIEWATTRIBUTE()
{
    DBGCODE(InterlockedDecrement(&g_cCertViewAttribute));

#if DBG_CERTSRV
    if (m_cRef > 1)
    {
	DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "%hs has %d instances left over\n",
	    "CEnumCERTVIEWATTRIBUTE",
	    m_cRef));
    }
#endif

    if (NULL != m_aelt)
    {
	LocalFree(m_aelt);
	m_aelt = NULL;
    }
    if (NULL != m_pvw)
    {
	m_pvw->Release();
	m_pvw = NULL;
    }
}


HRESULT
CEnumCERTVIEWATTRIBUTE::Open(
    IN LONG RowId,
    IN LONG Flags,
    IN ICertView *pvw)
{
    HRESULT hr;

    if (NULL == pvw)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    m_RowId = RowId;
    m_Flags = Flags;
    m_pvw = pvw;
    m_pvw->AddRef();

    if (0 != Flags)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Flags");
    }
    hr = Reset();
    _JumpIfError2(hr, error, "Reset", S_FALSE);

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTVIEWATTRIBUTE::Next(
    /* [out, retval] */ LONG *pIndex)
{
    HRESULT hr;
    DWORD celt;
    CERTTRANSBLOB ctbAttributes;

    ctbAttributes.pb = NULL;
    if (NULL == pIndex)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pIndex = -1;
    if (m_ieltCurrent + 1 >= m_celtCurrent && !m_fNoMore)
    {
	hr = ((CCertView *) m_pvw)->EnumAttributesOrExtensions(
					    m_RowId,
					    CDBENUM_ATTRIBUTES,
					    NULL == m_aelt?
						NULL :
						m_aelt[m_ieltCurrent].pwszName,
					    CEXT_CHUNK,
					    &celt,
					    &ctbAttributes);
	if (S_FALSE == hr)
	{
	    m_fNoMore = TRUE;
	}
	else
	{
	    _JumpIfError(hr, error, "EnumAttributesOrExtensions");
	}
	hr = _SaveAttributes(celt, &ctbAttributes);
	_JumpIfError(hr, error, "_SaveAttributes");

	m_ieltCurrent = -1;
	m_celtCurrent = celt;
    }
    if (m_ieltCurrent + 1 >= m_celtCurrent)
    {
	hr = S_FALSE;
	goto error;
    }
    m_ielt++;
    m_ieltCurrent++;
    *pIndex = m_ielt;
    m_fNoCurrentRecord = FALSE;
    hr = S_OK;

error:
    if (NULL != ctbAttributes.pb)
    {
	CoTaskMemFree(ctbAttributes.pb);
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWATTRIBUTE::Next"));
}


HRESULT
CEnumCERTVIEWATTRIBUTE::_SaveAttributes(
    IN DWORD celt,
    IN CERTTRANSBLOB const *pctbAttributes)
{
    HRESULT hr;
    DWORD cbNew;
    CERTDBATTRIBUTE *peltNew = NULL;
    CERTDBATTRIBUTE *pelt;
    CERTTRANSDBATTRIBUTE *ptelt;
    CERTTRANSDBATTRIBUTE *pteltEnd;
    BYTE *pbNext;
    BYTE *pbEnd;

    if (NULL == pctbAttributes)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    cbNew = pctbAttributes->cb + celt * (sizeof(*pelt) - sizeof(*ptelt));
    peltNew = (CERTDBATTRIBUTE *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cbNew);
    if (NULL == peltNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pteltEnd = &((CERTTRANSDBATTRIBUTE *) pctbAttributes->pb)[celt];
    if ((BYTE *) pteltEnd > &pctbAttributes->pb[pctbAttributes->cb])
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "bad marshalled data");
    }
    pelt = peltNew;
    pbNext = (BYTE *) &peltNew[celt];
    pbEnd = (BYTE *) Add2Ptr(peltNew, cbNew);
    for (ptelt = (CERTTRANSDBATTRIBUTE *) pctbAttributes->pb;
	 ptelt < pteltEnd;
	 ptelt++, pelt++)
    {
	hr = CopyMarshalledString(
			    pctbAttributes, 
			    ptelt->obwszName,
			    pbEnd,
			    &pbNext,
			    &pelt->pwszName);
	_JumpIfError(hr, error, "CopyMarshalledString");

	hr = CopyMarshalledString(
			    pctbAttributes, 
			    ptelt->obwszValue,
			    pbEnd,
			    &pbNext,
			    &pelt->pwszValue);
	_JumpIfError(hr, error, "CopyMarshalledString");
    }
    CSASSERT(pbNext == (BYTE *) Add2Ptr(peltNew, cbNew));

    if (NULL != m_aelt)
    {
	LocalFree(m_aelt);
    }
    m_aelt = peltNew;
    peltNew = NULL;
    hr = S_OK;

error:
    if (NULL != peltNew)
    {
	LocalFree(peltNew);
    }
    return(hr);
}


HRESULT
CEnumCERTVIEWATTRIBUTE::_FindAttribute(
    OUT CERTDBATTRIBUTE const **ppcda)
{
    HRESULT hr;

    if (NULL == ppcda)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_aelt)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_aelt");
    }
    if (m_fNoCurrentRecord ||
	m_ieltCurrent < 0 ||
	m_ieltCurrent >= m_celtCurrent)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "m_fNoCurrentRecord || m_ieltCurrent");
    }
    *ppcda = &m_aelt[m_ieltCurrent];
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTVIEWATTRIBUTE::GetName(
    /* [out, retval] */ BSTR *pstrOut)
{
    HRESULT hr;
    CERTDBATTRIBUTE const *pcda;

    if (NULL == pstrOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _FindAttribute(&pcda);
    _JumpIfError(hr, error, "_FindAttribute");

    if (!ConvertWszToBstr(pstrOut, pcda->pwszName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWATTRIBUTE::GetName"));
}


STDMETHODIMP
CEnumCERTVIEWATTRIBUTE::GetValue(
    /* [out, retval] */ BSTR *pstrOut)
{
    HRESULT hr;
    CERTDBATTRIBUTE const *pcda;

    if (NULL == pstrOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _FindAttribute(&pcda);
    _JumpIfError(hr, error, "_FindAttribute");

    if (L'\0' == *pcda->pwszValue)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "NULL value");
    }
    if (!ConvertWszToBstr(pstrOut, pcda->pwszValue, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWATTRIBUTE::GetValue"));
}


STDMETHODIMP
CEnumCERTVIEWATTRIBUTE::Skip(
    /* [in] */ LONG celt)
{
    HRESULT hr;
    LONG ieltnew = m_ielt + celt;

    if (-1 > ieltnew)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Skip back to before start");
    }
    m_ielt = ieltnew;
    m_ieltCurrent += celt;
    m_fNoCurrentRecord = TRUE;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWATTRIBUTE::Skip"));
}


STDMETHODIMP
CEnumCERTVIEWATTRIBUTE::Reset(VOID)
{
    HRESULT hr;
    DWORD celt;
    CERTTRANSBLOB ctbAttributes;

    ctbAttributes.pb = NULL;
    m_fNoMore = FALSE;

    hr = ((CCertView *) m_pvw)->EnumAttributesOrExtensions(
					m_RowId,
					CDBENUM_ATTRIBUTES,
					NULL,
					CEXT_CHUNK,
					&celt,
					&ctbAttributes);
    if (S_FALSE == hr)
    {
	m_fNoMore = TRUE;
    }
    else
    {
	_JumpIfError(hr, error, "EnumAttributesOrExtensions");
    }

    hr = _SaveAttributes(celt, &ctbAttributes);
    _JumpIfError(hr, error, "_SaveAttributes");

    m_ielt = -1;
    m_ieltCurrent = -1;
    m_celtCurrent = celt;
    m_fNoCurrentRecord = TRUE;

error:
    if (NULL != ctbAttributes.pb)
    {
	CoTaskMemFree(ctbAttributes.pb);
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWATTRIBUTE::Reset"));
}


STDMETHODIMP
CEnumCERTVIEWATTRIBUTE::Clone(
    /* [out] */ IEnumCERTVIEWATTRIBUTE **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWATTRIBUTE *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    penum = new CEnumCERTVIEWATTRIBUTE;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWATTRIBUTE");
    }

    hr = ((CEnumCERTVIEWATTRIBUTE *) penum)->Open(m_RowId, m_Flags, m_pvw);
    _JumpIfError(hr, error, "Open");

    if (-1 != m_ielt)
    {
	hr = penum->Skip(m_ielt);
	_JumpIfError(hr, error, "Skip");

	if (!m_fNoCurrentRecord)
	{
	    LONG Index;

	    hr = penum->Next(&Index);
	    _JumpIfError(hr, error, "Next");

	    CSASSERT(Index == m_ielt);
	}
    }
    *ppenum = penum;
    penum = NULL;
    hr = S_OK;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWATTRIBUTE::Clone"));
}


HRESULT
CEnumCERTVIEWATTRIBUTE::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTVIEW L".CEnumCERTVIEWATTRIBUTE",
			    &IID_IEnumCERTVIEWATTRIBUTE);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}


#if 1
// IUnknown implementation
STDMETHODIMP
CEnumCERTVIEWATTRIBUTE::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<IEnumCERTVIEWATTRIBUTE *>(this);
    }
    else if (iid == IID_IDispatch)
    {
	*ppv = static_cast<IEnumCERTVIEWATTRIBUTE *>(this);
    }
    else if (iid == IID_IEnumCERTVIEWATTRIBUTE)
    {
	*ppv = static_cast<IEnumCERTVIEWATTRIBUTE *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWATTRIBUTE::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWATTRIBUTE::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\service.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        service.cpp
//
// Contents:    Cert Server service processing
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "resource.h"

#define __dwFILE__	__dwFILE_CERTSRV_SERVICE_CPP__


SERVICE_STATUS           g_ssStatus;
SERVICE_STATUS_HANDLE    g_sshStatusHandle;
HANDLE                   g_hServiceStoppingEvent = NULL;
HANDLE                   g_hServiceStoppedEvent = NULL;
DWORD                    g_dwCurrentServiceState = SERVICE_STOPPED;


BOOL
ServiceReportStatusToSCMgrEx(
    IN DWORD dwCurrentState,
    IN DWORD dwWin32ExitCode,
    IN DWORD dwCheckPoint,
    IN DWORD dwWaitHint, 
    IN BOOL  fInitialized)
{
    BOOL fResult;
    HRESULT hr;

    // dwWin32ExitCode can only be set to a Win32 error code (not an HRESULT).

    g_ssStatus.dwServiceSpecificExitCode = myHError(dwWin32ExitCode);
    g_ssStatus.dwWin32ExitCode = HRESULT_CODE(dwWin32ExitCode);
    if ((ULONG) HRESULT_FROM_WIN32(g_ssStatus.dwWin32ExitCode) ==
	g_ssStatus.dwServiceSpecificExitCode)
    {
	// If dwWin32ExitCode is a Win32 error, clear dwServiceSpecificExitCode

	g_ssStatus.dwServiceSpecificExitCode = S_OK;
    }
    else
    {
	// Else dwServiceSpecificExitCode is an HRESULT that cannot be
	// translated to a Win32 error, set dwWin32ExitCode to indicate so.

	g_ssStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
    }

    // save this as global state for interrogation
    g_dwCurrentServiceState = dwCurrentState;

    g_ssStatus.dwControlsAccepted = (SERVICE_START_PENDING == dwCurrentState) ? 0 : SERVICE_ACCEPT_STOP;

    // don't say we'll accept PAUSE until we're really going
    if (fInitialized)
        g_ssStatus.dwControlsAccepted |= SERVICE_ACCEPT_PAUSE_CONTINUE;

    g_ssStatus.dwCurrentState = dwCurrentState;
    g_ssStatus.dwCheckPoint = dwCheckPoint;
    g_ssStatus.dwWaitHint = dwWaitHint;

    fResult = SetServiceStatus(g_sshStatusHandle, &g_ssStatus);
    if (!fResult)
    {
	hr = GetLastError();
        _JumpError(hr, error, "SetServiceStatus");
    }
    DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "ServiceReportStatusToSCMgr(state=%x, err=%x(%d), hr=%x(%d), ckpt=%x, wait=%x)\n",
	    dwCurrentState,
	    g_ssStatus.dwWin32ExitCode,
	    g_ssStatus.dwWin32ExitCode,
	    g_ssStatus.dwServiceSpecificExitCode,
	    g_ssStatus.dwServiceSpecificExitCode,
	    dwCheckPoint,
	    dwWaitHint));

error:
    return(fResult);
}


BOOL
ServiceReportStatusToSCMgr(
    IN DWORD dwCurrentState,
    IN DWORD dwWin32ExitCode,
    IN DWORD dwCheckPoint,
    IN DWORD dwWaitHint)
{
    // most callers don't care about initialized/uninitialized distinction
    return ServiceReportStatusToSCMgrEx(
              dwCurrentState,
              dwWin32ExitCode,
              dwCheckPoint,
              dwWaitHint,
              TRUE);
}


VOID
serviceControlHandler(
    IN DWORD dwCtrlCode)
{
    switch (dwCtrlCode)
    {
        case SERVICE_CONTROL_PAUSE:
            if (SERVICE_RUNNING == g_ssStatus.dwCurrentState)
            {
                g_dwCurrentServiceState = SERVICE_PAUSED;
            }
            break;

        case SERVICE_CONTROL_CONTINUE:
            if (SERVICE_PAUSED == g_ssStatus.dwCurrentState)
            {
                g_dwCurrentServiceState = SERVICE_RUNNING;
            }
            break;

        case SERVICE_CONTROL_STOP:
	{
            HRESULT hr;
	    DWORD State = 0;
	    
	    // put us in "stop pending" mode
            g_dwCurrentServiceState = SERVICE_STOP_PENDING;

            // post STOP message to msgloop and bail
            // message loop handles all other shutdown work
            // WM_STOPSERVER signals events that trigger thread synchronization, etc.
	    hr = CertSrvLockServer(&State);
	    _PrintIfError(hr, "CertSrvLockServer");

            PostMessage(g_hwndMain, WM_STOPSERVER, 0, 0);  

            break;
	}

        case SERVICE_CONTROL_INTERROGATE:
            break;
    }
    ServiceReportStatusToSCMgr(g_dwCurrentServiceState, NO_ERROR, 0, 0);
}


//+--------------------------------------------------------------------------
// Service Main
// Anatomy for start/stop cert Service
//
// How we go here:
// wWinMain created a thread which called StartServiceCtrlDispatcher, then went
// into a message loop. StartServiceCtrlDispatcher calls us through the SCM and
// blocks until we return. We hang here until we're completely done.
//
// Service Start
// Create the service start thread. When it is done with init, the thread will
// exit. We hang on the thread, pinging the SCM with START_PENDING and watch
// for the thread exit code. When we see it, we know if the start was a
// success or not. If success, then hang on "stop initiated" event. If
// failure, report failure to SCM and exit service main.
//
// Service Stop
// Events that we need for stop synchronization were created during startup.
// When we get notified fo "stop initiated" event, we begin pinging SCM
// with "STOP_PENDING". When we get "stop complete" event, we are done and need
// to exit service main. The message loop thread is still active -- we'll tell
// it we're shutting down -- it will detect when the StartServiceCtrlDispatcher
// thread it created exits.
//+--------------------------------------------------------------------------

VOID
ServiceMain(
    IN DWORD, // dwArgc
    IN LPWSTR * /* lpszArgv */ )
{
    HRESULT hr = S_OK;
    int iStartPendingCtr;
    DWORD dwThreadId, dwWaitObj;
    HANDLE hServiceThread = NULL;

    __try
    {
        g_ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
        g_ssStatus.dwServiceSpecificExitCode = 0;
        g_sshStatusHandle = RegisterServiceCtrlHandler(
					      g_wszCertSrvServiceName,
					      serviceControlHandler);
        if (NULL == g_sshStatusHandle)
        {
    	    hr = myHLastError();
            _LeaveError(hr, "RegisterServiceCtrlHandler");
        }

        if (0 != g_dwDelay2)
        {
	        DBGPRINT((
		        DBG_SS_CERTSRV,
		        "ServiceMain: sleeping %u seconds\n",
		        g_dwDelay2));

            iStartPendingCtr = 0;
            for (;;)
            {
                ServiceReportStatusToSCMgr(
			    SERVICE_START_PENDING,
			    hr,
			    iStartPendingCtr++,
			    2000);
                Sleep(1000);    // sleep 1 sec

                if (iStartPendingCtr >= (int)g_dwDelay2)
                    break;
            }
        }

        // NOTE: strange event
        // We're starting yet another thread, calling CertSrvStartServerThread.
        // Here, CertSrvStartServerThread actually blocks on server initialization
        hServiceThread = CreateThread(
				    NULL,
				    0,
				    CertSrvStartServerThread,
				    0,
				    0,
				    &dwThreadId);
        if (NULL == hServiceThread)
        {
            hr = myHLastError();
            _LeaveError(hr, "CreateThread");
        }

        // don't wait on startup thread to return, report "started" but give initialization hint
        ServiceReportStatusToSCMgrEx(SERVICE_RUNNING, hr, 0, 0, FALSE /*fInitialized*/);

        // wait on the startup thread to terminate before we continue
        dwWaitObj = WaitForSingleObject(hServiceThread, INFINITE);
        if (dwWaitObj != WAIT_OBJECT_0)
        {
            hr = myHLastError();
            _LeaveError(hr, "WaitForSingleObject");
        }

        if (!GetExitCodeThread(hServiceThread, (DWORD *) &hr))
        {
            hr = HRESULT_FROM_WIN32(ERROR_SERVICE_NO_THREAD);
            _LeaveError(hr, "GetExitCodeThread");
        }
        _LeaveIfError(hr, "CertSrvStartServer");        // error during CertSrvStartServerThread gets reported here

        // now give trigger "we're really ready!"
        ServiceReportStatusToSCMgrEx(SERVICE_RUNNING, hr, 0, 0, TRUE/*fInitialized*/);

        /////////////////////////////////////////////////////////////
        // Work to be done during certsrv operation: CRL
         CertSrvBlockThreadUntilStop();
        /////////////////////////////////////////////////////////////

        iStartPendingCtr = 0;
        for (;;)
        {
            // wait for 1 sec, ping Service ctl
            if (WAIT_OBJECT_0 == WaitForSingleObject(g_hServiceStoppedEvent, 1000))
                break;

            ServiceReportStatusToSCMgr(
                SERVICE_STOP_PENDING,
                S_OK,
                iStartPendingCtr++,
                2000);
        }

        DBGPRINT((DBG_SS_CERTSRV, "ServiceMain: Service reported stopped\n"));
        hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

//error:
    __try
    {
        ServiceReportStatusToSCMgr(SERVICE_STOPPED, hr, 0, 0);
        
        if (NULL != hServiceThread)
        {
            CloseHandle(hServiceThread);
        }
        
        DBGPRINT((DBG_SS_CERTSRV, "ServiceMain: Exit: %x\n", hr));
        
        // pass return code to msg loop, tell it to watch for
        // StartServiceCtrlDispatcher to exit
        
        if (!PostMessage(g_hwndMain, WM_SYNC_CLOSING_THREADS, 0, hr))
        {
            hr = myHLastError();
            _PrintIfError(hr, "PostMessage WM_SYNC_CLOSING_THREADS");
        }
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    	_PrintError(hr, "Exception");
    }
}


HRESULT
ServiceQueryInteractiveFlag(
    OUT BOOL *pfSilent)
{
    HRESULT hr;
    SC_HANDLE hSCManager = NULL;
    SC_HANDLE hSCCertsvc = NULL;
    QUERY_SERVICE_CONFIG *pServiceConfig = NULL;
    DWORD cb;

    *pfSilent = FALSE;
    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (NULL == hSCManager)
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenSCManager");
    }
    hSCCertsvc = OpenService(hSCManager, wszSERVICE_NAME, SERVICE_QUERY_CONFIG);
    if (NULL == hSCCertsvc)
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenService");
    }

    if (!QueryServiceConfig(hSCCertsvc, NULL, 0, &cb))
    {
        hr = myHLastError();
	if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
	{
	    _JumpError(hr, error, "QueryServiceConfig");
	}
    }
    pServiceConfig = (QUERY_SERVICE_CONFIG *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == pServiceConfig)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (!QueryServiceConfig(hSCCertsvc, pServiceConfig, cb, &cb))
    {
        hr = myHLastError();
        _JumpError(hr, error, "QueryServiceConfig");
    }

    if (0 == (SERVICE_INTERACTIVE_PROCESS & pServiceConfig->dwServiceType))
    {
	*pfSilent = TRUE;
    }
    hr = S_OK;

error:
    if (NULL != pServiceConfig)
    {
        LocalFree(pServiceConfig);
    }
    if (NULL != hSCCertsvc)
    {
        CloseServiceHandle(hSCCertsvc);
    }
    if (NULL != hSCManager)
    {
        CloseServiceHandle(hSCManager);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certview\attrib.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        attrib.h
//
// Contents:    CertView implementation
//
//---------------------------------------------------------------------------

#define wszCLASS_EnumCERTVIEWATTRIBUTE TEXT("xxxxxxxxxxxx")

class CEnumCERTVIEWATTRIBUTE:
    public IDispatchImpl<
		IEnumCERTVIEWATTRIBUTE,
		&IID_IEnumCERTVIEWATTRIBUTE,
		&LIBID_CERTADMINLib>,
    public ISupportErrorInfoImpl<&IID_IEnumCERTVIEWATTRIBUTE>,
    public CComObjectRoot
    //public CComObject<IEnumCERTVIEWATTRIBUTE>
    // Not externally createable:
    // public CComCoClass<CEnumCERTVIEWATTRIBUTE, &CLSID_CEnumCERTVIEWATTRIBUTE>
{
public:
    CEnumCERTVIEWATTRIBUTE();
    ~CEnumCERTVIEWATTRIBUTE();

BEGIN_COM_MAP(CEnumCERTVIEWATTRIBUTE)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IEnumCERTVIEWATTRIBUTE)
END_COM_MAP_X()
DECLARE_NOT_AGGREGATABLE(CEnumCERTVIEWATTRIBUTE)
// Remove the comment from the line above if you don't want your object to
// support aggregation.  The default is to support it

#if 0 // Not externally createable:
DECLARE_REGISTRY(
    CEnumCERTVIEWATTRIBUTE,
    wszCLASS_EnumCERTVIEWATTRIBUTE TEXT(".1"),
    wszCLASS_EnumCERTVIEWATTRIBUTE,
    1, //IDS_ENUMCERTVIEWATTRIBUTE_DESC,
    THREADFLAGS_BOTH)
#endif

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumCERTVIEWATTRIBUTE
    STDMETHOD(Next)(
	/* [out, retval] */ LONG *pIndex);
    
    STDMETHOD(GetName)(
	/* [out, retval] */ BSTR *pstrOut);

    STDMETHOD(GetValue)(
	/* [out, retval] */ BSTR *pstrOut);

    STDMETHOD(Skip)(
	/* [in] */ LONG celt);
    
    STDMETHOD(Reset)(VOID);
    
    STDMETHOD(Clone)(
	/* [out] */ IEnumCERTVIEWATTRIBUTE **ppenum);

    // CEnumCERTVIEWATTRIBUTE
    HRESULT Open(
	IN LONG RowId,
	IN LONG Flags,
	IN ICertView *pvw);
	
private:
    HRESULT _FindAttribute(
	OUT CERTDBATTRIBUTE const **ppcde);

    HRESULT _SaveAttributes(
	IN DWORD celt,
	IN CERTTRANSBLOB const *pctbAttributes);

    HRESULT _SetErrorInfo(
	IN HRESULT hrError,
	IN WCHAR const *pwszDescription);
	
    LONG             m_RowId;
    LONG             m_Flags;
    ICertView       *m_pvw;
    LONG             m_ielt;
    LONG             m_ieltCurrent;
    LONG             m_celtCurrent;
    CERTDBATTRIBUTE *m_aelt;
    BOOL             m_fNoMore;
    BOOL             m_fNoCurrentRecord;

    // Reference count
    long             m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certview\csview.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csview.h
//
// Contents:    CertView includes
//
//---------------------------------------------------------------------------

#include <certdb.h>

#include "view.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certview\column.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        column.cpp
//
// Contents:    Cert Server Data Base interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csdisp.h"
#include "csprop.h"
#include "column.h"
#include "view.h"

#define __dwFILE__	__dwFILE_CERTVIEW_COLUMN_CPP__


#if DBG_CERTSRV
LONG g_cCertViewColumn;
LONG g_cCertViewColumnTotal;
#endif


CEnumCERTVIEWCOLUMN::CEnumCERTVIEWCOLUMN()
{
    DBGCODE(InterlockedIncrement(&g_cCertViewColumn));
    DBGCODE(InterlockedIncrement(&g_cCertViewColumnTotal));
    m_pvw = NULL;
    m_prow = NULL;
    m_cRef = 1;
}


CEnumCERTVIEWCOLUMN::~CEnumCERTVIEWCOLUMN()
{
    DBGCODE(InterlockedDecrement(&g_cCertViewColumn));

#if DBG_CERTSRV
    if (m_cRef > 1)
    {
	DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "%hs has %d instances left over\n",
	    "CEnumCERTVIEWCOLUMN",
	    m_cRef));
    }
#endif

    if (NULL != m_pvw)
    {
	m_pvw->Release();
    }
    if (NULL != m_prow)
    {
	LocalFree(m_prow);
    }
}


HRESULT
CEnumCERTVIEWCOLUMN::Open(
    IN LONG Flags,
    IN LONG iRow,
    IN ICertView *pvw,
    OPTIONAL IN CERTTRANSDBRESULTROW const *prow)
{
    HRESULT hr;

    if (NULL == pvw)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    CSASSERT(0 == (CVRC_TABLE_MASK & CVRC_COLUMN_MASK));

    hr = E_INVALIDARG;
    if (~(CVRC_TABLE_MASK | CVRC_COLUMN_MASK) & Flags)
    {
	_JumpError(hr, error, "Flags");
    }
    switch (CVRC_COLUMN_MASK & Flags)
    {
	case CVRC_COLUMN_SCHEMA:
	case CVRC_COLUMN_RESULT:
	case CVRC_COLUMN_VALUE:
	    break;

	default:
	    _JumpError(hr, error, "Flags column");
    }
    switch (CVRC_TABLE_MASK & Flags)
    {
	case CVRC_TABLE_REQCERT:
	case CVRC_TABLE_EXTENSIONS:
	case CVRC_TABLE_ATTRIBUTES:
	case CVRC_TABLE_CRL:
	    break;

	default:
	    _JumpError(hr, error, "Flags table");
    }

    m_Flags = Flags;
    m_iRow = iRow;
    m_pvw = pvw;
    m_pvw->AddRef();

    DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "CEnumCERTVIEWCOLUMN::Open(cvrcTable=%x, cvrcColumn=%x)\n",
	    CVRC_TABLE_MASK & Flags,
	    CVRC_COLUMN_MASK & Flags));

    if (NULL != prow)
    {
	m_prow = (CERTTRANSDBRESULTROW *) LocalAlloc(LMEM_FIXED, prow->cbrow);
	if (NULL == m_prow)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(m_prow, prow, prow->cbrow);
    }

    hr = m_pvw->GetColumnCount(m_Flags, &m_celt);
    _JumpIfError(hr, error, "GetColumnCount");

    Reset();

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::Next(
    /* [out, retval] */ LONG *pIndex)
{
    HRESULT hr;

    if (NULL == pIndex)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (-1 > m_ielt || m_ielt >= m_celt - 1)
    {
	*pIndex = -1;
	hr = S_FALSE;
	goto error;
    }
    m_ielt++;

    hr = ((CCertView *) m_pvw)->FindColumn(
				    m_Flags,
				    m_ielt,
				    &m_pcol,
				    &m_pwszDisplayName);
    _JumpIfError(hr, error, "FindColumn");

    *pIndex = m_ielt;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::Next"));
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::GetName(
    /* [out, retval] */ BSTR *pstrOut)
{
    HRESULT hr;

    if (NULL == pstrOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pcol)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_pcol NULL");
    }
    if (!ConvertWszToBstr(pstrOut, m_pcol->pwszName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::GetName"));
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::GetDisplayName(
    /* [out, retval] */ BSTR *pstrOut)
{
    HRESULT hr;

    if (NULL == pstrOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pwszDisplayName)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_pwszDisplayName NULL");
    }

    if (!ConvertWszToBstr(pstrOut, m_pwszDisplayName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::GetDisplayName"));
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::GetType(
    /* [out, retval] */ LONG *pType)
{
    HRESULT hr;

    if (NULL == pType)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pcol)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_pcol NULL");
    }
    *pType = PROPTYPE_MASK & m_pcol->Type;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::GetType"));
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::IsIndexed(
    /* [out, retval] */ LONG *pIndexed)
{
    HRESULT hr;

    if (NULL == pIndexed)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pcol)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_pcol NULL");
    }
    *pIndexed = (PROPFLAGS_INDEXED & m_pcol->Type)? TRUE : FALSE;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::IsIndexed"));
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::GetMaxLength(
    /* [out, retval] */ LONG *pMaxLength)
{
    HRESULT hr;

    if (NULL == pMaxLength)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pcol)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_pcol NULL");
    }
    *pMaxLength = m_pcol->cbMax;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::GetMaxLength"));
}


DWORD
AsnPropId(
    IN LONG Flags,
    IN WCHAR const *pwszName)
{
    DWORD PropId = CR_PROP_NONE;
    
    switch (CVRC_TABLE_MASK & Flags)
    {
	case CVRC_TABLE_CRL:
	    if (0 == LSTRCMPIS(pwszName, wszPROPCRLRAWCRL))
	    {
		PropId = CR_PROP_BASECRL;
	    }
	    break;

	case CVRC_TABLE_REQCERT:
	    if (0 == LSTRCMPIS(pwszName, wszPROPREQUESTRAWREQUEST))
	    {
		PropId = MAXDWORD;
	    }
	    break;
    }
    return(PropId);
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::GetValue(
    /* [in] */          LONG Flags,
    /* [out, retval] */ VARIANT *pvarValue)
{
    HRESULT hr = E_UNEXPECTED;
    BYTE const *pbValue;
    CERTTRANSDBRESULTCOLUMN const *pColResult;

    if (NULL == pvarValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    VariantInit(pvarValue);
    if (CVRC_COLUMN_VALUE != (CVRC_COLUMN_MASK & m_Flags))
    {
	_JumpError(hr, error, "No Value");
    }
    if (NULL == m_pcol)
    {
	_JumpError(hr, error, "m_pcol NULL");
    }

    pColResult = &((CERTTRANSDBRESULTCOLUMN const *) (m_prow + 1))[m_ielt];

    CSASSERT(m_pcol->Type == pColResult->Type);

    if (0 == pColResult->obValue)
    {
	hr = S_OK;		// leave VariantClear()'s VT_EMPTY tag
	goto error;
    }

    pbValue = (BYTE const *) Add2ConstPtr(m_prow, pColResult->obValue);

    hr = myUnmarshalFormattedVariant(
			Flags,
			AsnPropId(m_Flags, m_pcol->pwszName),
			m_pcol->Type,
			pColResult->cbValue,
			pbValue,
			pvarValue);
    _JumpIfError(hr, error, "myUnmarshalFormattedVariant");

error:
    if (S_OK != hr)
    {
	VariantClear(pvarValue);
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::GetValue"));
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::Skip(
    /* [in] */ LONG celt)
{
    HRESULT hr;
    LONG ieltnew = m_ielt + celt;

    if (-1 > ieltnew)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Skip back to before start");
    }
    m_ielt = ieltnew;
    m_pcol = NULL;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::Skip"));
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::Reset(VOID)
{
    m_ielt = -1;
    m_pcol = NULL;
    return(S_OK);
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::Clone(
    /* [out] */ IEnumCERTVIEWCOLUMN **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWCOLUMN *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    penum = new CEnumCERTVIEWCOLUMN;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWCOLUMN");
    }

    hr = ((CEnumCERTVIEWCOLUMN *) penum)->Open(
				    m_Flags,
				    -1,
				    m_pvw,
				    m_prow);
    _JumpIfError(hr, error, "Open");

    if (-1 != m_ielt)
    {
	hr = penum->Skip(m_ielt);
	_JumpIfError(hr, error, "Skip");

	if (NULL != m_pcol)
	{
	    LONG Index;

	    hr = penum->Next(&Index);
	    _JumpIfError(hr, error, "Next");

	    CSASSERT(Index == m_ielt);
	}
    }
    *ppenum = penum;
    penum = NULL;
    hr = S_OK;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::Clone"));
}


HRESULT
CEnumCERTVIEWCOLUMN::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTVIEW L".CEnumCERTVIEWCOLUMN",
			    &IID_IEnumCERTVIEWCOLUMN);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}


#if 1
// IUnknown implementation
STDMETHODIMP
CEnumCERTVIEWCOLUMN::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;

    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<IEnumCERTVIEWCOLUMN *>(this);
    }
    else if (iid == IID_IDispatch)
    {
	*ppv = static_cast<IEnumCERTVIEWCOLUMN *>(this);
    }
    else if (iid == IID_ISupportErrorInfo)
    {
	*ppv = static_cast<IEnumCERTVIEWCOLUMN *>(this);
    }
    else if (iid == IID_IEnumCERTVIEWCOLUMN)
    {
	*ppv = static_cast<IEnumCERTVIEWCOLUMN *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWCOLUMN::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWCOLUMN::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certview\column.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        column.h
//
// Contents:    CertView implementation
//
//---------------------------------------------------------------------------


// CEnumCERTVIEWCOLUMN::Open Flags:
// CVRC_COLUMN_*	// enumerate schema, result columns or values
// CVRC_TABLE_*		// specifies the DB table to enumerate


class CEnumCERTVIEWCOLUMN: 
    public IDispatchImpl<
		IEnumCERTVIEWCOLUMN,
		&IID_IEnumCERTVIEWCOLUMN,
		&LIBID_CERTADMINLib>,
    public ISupportErrorInfoImpl<&IID_IEnumCERTVIEWCOLUMN>,
    public CComObjectRoot
    // Not externally createable:
    //public CComCoClass<CEnumCERTVIEWCOLUMN, &CLSID_CEnumCERTVIEWCOLUMN>
{
public:
    CEnumCERTVIEWCOLUMN();
    ~CEnumCERTVIEWCOLUMN();

BEGIN_COM_MAP(CEnumCERTVIEWCOLUMN)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IEnumCERTVIEWCOLUMN)
END_COM_MAP_X()

DECLARE_NOT_AGGREGATABLE(CEnumCERTVIEWCOLUMN)
// Remove the comment from the line above if you don't want your object to
// support aggregation.  The default is to support it

#if 0 // Not externally createable:
DECLARE_REGISTRY(
    CEnumCERTVIEWCOLUMN,
    wszCLASS_EnumCERTVIEWCOLUMN TEXT(".1"),
    wszCLASS_EnumCERTVIEWCOLUMN,
    IDS_ENUMCERTVIEWCOLUMN_DESC,
    THREADFLAGS_BOTH)
#endif

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumCERTVIEWCOLUMN
    STDMETHOD(Next)(
	/* [out, retval] */ LONG *pIndex);
    
    STDMETHOD(GetName)(
	/* [out, retval] */ BSTR *pstrOut);

    STDMETHOD(GetDisplayName)(
	/* [out, retval] */ BSTR *pstrOut);

    STDMETHOD(GetType)(
	/* [out, retval] */ LONG *pType);

    STDMETHOD(IsIndexed)(
	/* [out, retval] */ LONG *pIndexed);

    STDMETHOD(GetMaxLength)(
	/* [out, retval] */ LONG *pMaxLength);
    
    STDMETHOD(GetValue)(
	/* [in] */          LONG Flags,
	/* [out, retval] */ VARIANT *pvarValue);
    
    STDMETHOD(Skip)(
	/* [in] */ LONG celt);
    
    STDMETHOD(Reset)(VOID);
    
    STDMETHOD(Clone)(
	/* [out] */ IEnumCERTVIEWCOLUMN **ppenum);

    // CEnumCERTVIEWCOLUMN
    HRESULT Open(
	IN LONG Flags,
	IN LONG iRow,
	IN ICertView *pvw,
	OPTIONAL IN CERTTRANSDBRESULTROW const *prow);
	
private:
    HRESULT _SetErrorInfo(
	IN HRESULT hrError,
	IN WCHAR const *pwszDescription);

    ICertView            *m_pvw;
    CERTTRANSDBRESULTROW *m_prow;
    LONG                  m_iRow;
    LONG                  m_ielt;
    LONG                  m_celt;
    LONG                  m_Flags;
    CERTDBCOLUMN const   *m_pcol;
    WCHAR const          *m_pwszDisplayName;

    // Reference count
    long                  m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certview\csviewm.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certviewm.h
//
// Contents:    CertView object map entries
//
//---------------------------------------------------------------------------

    OBJECT_ENTRY(CLSID_CCertView, CCertView)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certview\certview.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certview.cpp
//
// Contents:    CertView database implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <certdb.h>
#include "view.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertView, CCertView)
END_OBJECT_MAP()

HINSTANCE g_hInstance;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD dwReason,
    IN LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    g_hInstance = hInstance;
	    _Module.Init(ObjectMap, hInstance);
	    DisableThreadLibraryCalls(hInstance);
	    break;

	case DLL_PROCESS_DETACH:
	    _Module.Term();
        break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return(_Module.GetClassObject(rclsid, riid, ppv));
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certview\ext.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        ext.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <certdb.h>
#include "csdisp.h"

#include "column.h"
#include "attrib.h"
#include "ext.h"
#include "row.h"
#include "view.h"

#define __dwFILE__	__dwFILE_CERTVIEW_EXT_CPP__


#if DBG_CERTSRV
LONG g_cCertViewExtension;
LONG g_cCertViewExtensionTotal;
#endif

CEnumCERTVIEWEXTENSION::CEnumCERTVIEWEXTENSION()
{
    DBGCODE(InterlockedIncrement(&g_cCertViewExtension));
    DBGCODE(InterlockedIncrement(&g_cCertViewExtensionTotal));
    m_pvw = NULL;
    m_aelt = NULL;
    m_cRef = 1;
}


CEnumCERTVIEWEXTENSION::~CEnumCERTVIEWEXTENSION()
{
    DBGCODE(InterlockedDecrement(&g_cCertViewExtension));

#if DBG_CERTSRV
    if (m_cRef > 1)
    {
	DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "%hs has %d instances left over\n",
	    "CEnumCERTVIEWEXTENSION",
	    m_cRef));
    }
#endif

    if (NULL != m_aelt)
    {
	LocalFree(m_aelt);
	m_aelt = NULL;
    }
    if (NULL != m_pvw)
    {
	m_pvw->Release();
	m_pvw = NULL;
    }
}


HRESULT
CEnumCERTVIEWEXTENSION::Open(
    IN LONG RowId,
    IN LONG Flags,
    IN ICertView *pvw)
{
    HRESULT hr;

    if (NULL == pvw)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    m_RowId = RowId;
    m_Flags = Flags;
    m_pvw = pvw;
    m_pvw->AddRef();

    if (0 != Flags)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Flags");
    }
    hr = Reset();
    _JumpIfError2(hr, error, "Reset", S_FALSE);

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTVIEWEXTENSION::Next(
    /* [out, retval] */ LONG *pIndex)
{
    HRESULT hr;
    DWORD celt;
    CERTTRANSBLOB ctbExtensions;

    ctbExtensions.pb = NULL;
    if (NULL == pIndex)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pIndex = -1;
    if (m_ieltCurrent + 1 >= m_celtCurrent && !m_fNoMore)
    {
	hr = ((CCertView *) m_pvw)->EnumAttributesOrExtensions(
					    m_RowId,
					    CDBENUM_EXTENSIONS,
					    NULL == m_aelt?
						NULL :
						m_aelt[m_ieltCurrent].pwszName,
					    CEXT_CHUNK,
					    &celt,
					    &ctbExtensions);
	if (S_FALSE == hr)
	{
	    m_fNoMore = TRUE;
	}
	else
	{
	    _JumpIfError(hr, error, "EnumAttributesOrExtensions");
	}
	hr = _SaveExtensions(celt, &ctbExtensions);
	_JumpIfError(hr, error, "_SaveExtensions");

	m_ieltCurrent = -1;
	m_celtCurrent = celt;
    }
    if (m_ieltCurrent + 1 >= m_celtCurrent)
    {
	hr = S_FALSE;
	goto error;
    }
    m_ielt++;
    m_ieltCurrent++;
    *pIndex = m_ielt;
    m_fNoCurrentRecord = FALSE;
    hr = S_OK;

error:
    if (NULL != ctbExtensions.pb)
    {
	CoTaskMemFree(ctbExtensions.pb);
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWEXTENSION::Next"));
}


HRESULT
CopyMarshalledString(
    IN CERTTRANSBLOB const *pctb,
    IN ULONG obwsz,
    IN BYTE *pbEnd,
    IN BYTE **ppbNext,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;

    *ppwszOut = NULL;
    if (0 != obwsz)
    {
	WCHAR *pwsz;
	WCHAR *pwszEnd;
	WCHAR *pwszT;
	DWORD cb;

	pwsz = (WCHAR *) Add2Ptr(pctb->pb, obwsz);
	pwszEnd = &((WCHAR *) pctb->pb)[pctb->cb / sizeof(WCHAR)];
	for (pwszT = pwsz; ; pwszT++)
	{
	    if (pwszT >= pwszEnd)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "bad marshalled data");
	    }
	    if (L'\0' == *pwszT)
	    {
		break;
	    }
	}
	cb = (SAFE_SUBTRACT_POINTERS(pwszT, pwsz) + 1) * sizeof(WCHAR);
	if (&(*ppbNext)[DWORDROUND(cb)] > pbEnd)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    _JumpError(hr, error, "bad marshalled data");
	}
	CopyMemory(*ppbNext, pwsz, cb);

	*ppwszOut = (WCHAR *) *ppbNext;
	*ppbNext += DWORDROUND(cb);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CopyMarshalledBlob(
    IN CERTTRANSBLOB const *pctb,
    IN DWORD cbValue,
    IN ULONG obValue,
    IN BYTE *pbEnd,
    IN BYTE **ppbNext,
    OUT DWORD *pcbOut,
    OUT BYTE **ppbOut)
{
    HRESULT hr;

    *pcbOut = 0;
    *ppbOut = NULL;
    if (0 != obValue)
    {
	BYTE *pb;

	pb = (BYTE *) Add2Ptr(pctb->pb, obValue);
	if (&pb[cbValue] > &pctb->pb[pctb->cb])
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "bad marshalled data");
	}
	if (&(*ppbNext)[DWORDROUND(cbValue)] > pbEnd)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    _JumpError(hr, error, "bad marshalled data");
	}
	CopyMemory(*ppbNext, pb, cbValue);

	*pcbOut = cbValue;
	*ppbOut = *ppbNext;
	*ppbNext += DWORDROUND(cbValue);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CEnumCERTVIEWEXTENSION::_SaveExtensions(
    IN DWORD celt,
    IN CERTTRANSBLOB const *pctbExtensions)
{
    HRESULT hr;
    DWORD cbNew;
    CERTDBEXTENSION *peltNew = NULL;
    CERTDBEXTENSION *pelt;
    CERTTRANSDBEXTENSION *ptelt;
    CERTTRANSDBEXTENSION *pteltEnd;
    BYTE *pbNext;
    BYTE *pbEnd;

    if (NULL == pctbExtensions)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    cbNew = pctbExtensions->cb + celt * (sizeof(*pelt) - sizeof(*ptelt));
    peltNew = (CERTDBEXTENSION *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cbNew);
    if (NULL == peltNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pteltEnd = &((CERTTRANSDBEXTENSION *) pctbExtensions->pb)[celt];
    if ((BYTE *) pteltEnd > &pctbExtensions->pb[pctbExtensions->cb])
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "bad marshalled data");
    }
    pelt = peltNew;
    pbNext = (BYTE *) &peltNew[celt];
    pbEnd = (BYTE *) Add2Ptr(peltNew, cbNew);
    for (ptelt = (CERTTRANSDBEXTENSION *) pctbExtensions->pb;
	 ptelt < pteltEnd;
	 ptelt++, pelt++)
    {
	pelt->ExtFlags = ptelt->ExtFlags;

	hr = CopyMarshalledString(
			    pctbExtensions, 
			    ptelt->obwszName,
			    pbEnd,
			    &pbNext,
			    &pelt->pwszName);
	_JumpIfError(hr, error, "CopyMarshalledString");

	hr = CopyMarshalledBlob(
			    pctbExtensions, 
			    ptelt->cbValue,
			    ptelt->obValue,
			    pbEnd,
			    &pbNext,
			    &pelt->cbValue,
			    &pelt->pbValue);
	_JumpIfError(hr, error, "CopyMarshalledBlob");
    }
    CSASSERT(pbNext == pbEnd);

    if (NULL != m_aelt)
    {
	LocalFree(m_aelt);
    }
    m_aelt = peltNew;
    peltNew = NULL;
    hr = S_OK;

error:
    if (NULL != peltNew)
    {
	LocalFree(peltNew);
    }
    return(hr);
}


HRESULT
CEnumCERTVIEWEXTENSION::_FindExtension(
    OUT CERTDBEXTENSION const **ppcde)
{
    HRESULT hr;

    if (NULL == ppcde)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_aelt)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_aelt");
    }
    if (m_fNoCurrentRecord ||
	m_ieltCurrent < 0 ||
	m_ieltCurrent >= m_celtCurrent)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "m_fNoCurrentRecord || m_ieltCurrent");
    }
    *ppcde = &m_aelt[m_ieltCurrent];
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTVIEWEXTENSION::GetName(
    /* [out, retval] */ BSTR *pstrOut)
{
    HRESULT hr;
    CERTDBEXTENSION const *pcde;

    if (NULL == pstrOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _FindExtension(&pcde);
    _JumpIfError(hr, error, "_FindExtension");

    if (!ConvertWszToBstr(pstrOut, pcde->pwszName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWEXTENSION::GetName"));
}


STDMETHODIMP
CEnumCERTVIEWEXTENSION::GetFlags(
    /* [out, retval] */ LONG *pFlags)
{
    HRESULT hr;
    CERTDBEXTENSION const *pcde;

    if (NULL == pFlags)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _FindExtension(&pcde);
    _JumpIfError(hr, error, "_FindExtension");

    *pFlags = pcde->ExtFlags;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWEXTENSION::GetFlags"));
}


STDMETHODIMP
CEnumCERTVIEWEXTENSION::GetValue(
    /* [in] */          LONG Type,
    /* [in] */          LONG Flags,
    /* [out, retval] */ VARIANT *pvarValue)
{
    HRESULT hr;
    CERTDBEXTENSION const *pcde;
    BYTE *pballoc = NULL;
    BYTE *pbValue;
    DWORD cbValue;

    if (NULL == pvarValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    VariantInit(pvarValue);
    pvarValue->bstrVal = NULL;

    CSASSERT(CV_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER);
    CSASSERT(CV_OUT_BASE64 == CRYPT_STRING_BASE64);
    CSASSERT(CV_OUT_BINARY == CRYPT_STRING_BINARY);
    CSASSERT(CV_OUT_BASE64REQUESTHEADER == CRYPT_STRING_BASE64REQUESTHEADER);
    CSASSERT(CV_OUT_HEX == CRYPT_STRING_HEX);
    CSASSERT(CV_OUT_HEXADDR == CRYPT_STRING_HEXADDR);
    CSASSERT(CV_OUT_BASE64X509CRLHEADER == CRYPT_STRING_BASE64X509CRLHEADER);
    CSASSERT(CV_OUT_HEXASCII == CRYPT_STRING_HEXASCII);
    CSASSERT(CV_OUT_HEXASCIIADDR == CRYPT_STRING_HEXASCIIADDR);

    switch (Flags)
    {
	case CV_OUT_BASE64HEADER:
	case CV_OUT_BASE64:
	case CV_OUT_BINARY:
	case CV_OUT_BASE64REQUESTHEADER:
	case CV_OUT_HEX:
	case CV_OUT_HEXASCII:
	case CV_OUT_BASE64X509CRLHEADER:
	case CV_OUT_HEXADDR:
	case CV_OUT_HEXASCIIADDR:
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Flags");
    }


    hr = _FindExtension(&pcde);
    _JumpIfError(hr, error, "_FindExtension");

    if (0 == pcde->cbValue || NULL == pcde->pbValue)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "NULL value");
    }
    if (PROPTYPE_BINARY == (PROPTYPE_MASK & Type))
    {
	pbValue = pcde->pbValue;
	cbValue = pcde->cbValue;
    }
    else
    {
	hr = myDecodeExtension(
			Type,
			pcde->pbValue,
			pcde->cbValue,
			&pballoc,
			&cbValue);
	_JumpIfError(hr, error, "myDecodeExtension");

	pbValue = pballoc;
    }
    if (CV_OUT_BINARY == Flags)
    {
	switch (PROPTYPE_MASK & Type)
	{
	    case PROPTYPE_LONG:
		CSASSERT(sizeof(LONG) == cbValue);
		pvarValue->lVal = *(LONG *) pbValue;
		pvarValue->vt = VT_I4;
		break;

	    case PROPTYPE_DATE:
		CSASSERT(sizeof(FILETIME) == cbValue);

		hr = myFileTimeToDate(
				(FILETIME const *) pbValue,
				&pvarValue->date);
		_JumpIfError(hr, error, "myFileTimeToDate");

		pvarValue->vt = VT_DATE;
		break;

	    case PROPTYPE_STRING:
	    case PROPTYPE_BINARY:
		if (!ConvertWszToBstr(
				&pvarValue->bstrVal,
				(WCHAR const *) pbValue,
				cbValue))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ConvertWszToBstr");
		}
		pvarValue->vt = VT_BSTR;
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Type");

	}
    }
    else
    {
	hr = EncodeCertString(
			pbValue,
			cbValue,
			Flags,
			&pvarValue->bstrVal);
	_JumpIfError(hr, error, "EncodeCertString");

	pvarValue->vt = VT_BSTR;
    }

error:
    if (NULL != pballoc)
    {
	LocalFree(pballoc);
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWEXTENSION::GetValue"));
}


STDMETHODIMP
CEnumCERTVIEWEXTENSION::Skip(
    /* [in] */ LONG celt)
{
    HRESULT hr;
    LONG ieltnew = m_ielt + celt;

    if (-1 > ieltnew)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Skip back to before start");
    }
    m_ielt = ieltnew;
    m_ieltCurrent += celt;
    m_fNoCurrentRecord = TRUE;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWEXTENSION::Skip"));
}


STDMETHODIMP
CEnumCERTVIEWEXTENSION::Reset(VOID)
{
    HRESULT hr;
    DWORD celt;
    CERTTRANSBLOB ctbExtensions;

    ctbExtensions.pb = NULL;
    m_fNoMore = FALSE;

    hr = ((CCertView *) m_pvw)->EnumAttributesOrExtensions(
					m_RowId,
					CDBENUM_EXTENSIONS,
					NULL,
					CEXT_CHUNK,
					&celt,
					&ctbExtensions);
    if (S_FALSE == hr)
    {
	m_fNoMore = TRUE;
    }
    else
    {
	_JumpIfError(hr, error, "EnumAttributesOrExtensions");
    }

    hr = _SaveExtensions(celt, &ctbExtensions);
    _JumpIfError(hr, error, "_SaveExtensions");

    m_ielt = -1;
    m_ieltCurrent = -1;
    m_celtCurrent = celt;
    m_fNoCurrentRecord = TRUE;

error:
    if (NULL != ctbExtensions.pb)
    {
	CoTaskMemFree(ctbExtensions.pb);
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWEXTENSION::Reset"));
}


STDMETHODIMP
CEnumCERTVIEWEXTENSION::Clone(
    /* [out] */ IEnumCERTVIEWEXTENSION **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWEXTENSION *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    penum = new CEnumCERTVIEWEXTENSION;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWEXTENSION");
    }

    hr = ((CEnumCERTVIEWEXTENSION *) penum)->Open(m_RowId, m_Flags, m_pvw);
    _JumpIfError(hr, error, "Open");

    if (-1 != m_ielt)
    {
	hr = penum->Skip(m_ielt);
	_JumpIfError(hr, error, "Skip");

	if (!m_fNoCurrentRecord)
	{
	    LONG Index;

	    hr = penum->Next(&Index);
	    _JumpIfError(hr, error, "Next");

	    CSASSERT(Index == m_ielt);
	}
    }
    *ppenum = penum;
    penum = NULL;
    hr = S_OK;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWEXTENSION::Clone"));
}


HRESULT
CEnumCERTVIEWEXTENSION::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTVIEW L".CEnumCERTVIEWEXTENSION",
			    &IID_IEnumCERTVIEWEXTENSION);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}


#if 1
// IUnknown implementation
STDMETHODIMP
CEnumCERTVIEWEXTENSION::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<IEnumCERTVIEWEXTENSION *>(this);
    }
    else if (iid == IID_IDispatch)
    {
	*ppv = static_cast<IEnumCERTVIEWEXTENSION *>(this);
    }
    else if (iid == IID_IEnumCERTVIEWEXTENSION)
    {
	*ppv = static_cast<IEnumCERTVIEWEXTENSION *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWEXTENSION::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWEXTENSION::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certview\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#define __DIR__		"certview"

#include <windows.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <certsrv.h>
#include "certlib.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certview\row.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        row.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <certdb.h>
#include "csdisp.h"
#include "column.h"
#include "attrib.h"
#include "ext.h"
#include "row.h"
#include "view.h"

#define __dwFILE__	__dwFILE_CERTVIEW_ROW_CPP__


#if DBG_CERTSRV
LONG g_cCertViewRow;
LONG g_cCertViewRowTotal;
#endif


#define CB_TARGETBUFFERSIZE	(128 * 1024)	// remote buffer size target
#define CROW_VIEWCHUNKMIN	35


CEnumCERTVIEWROW::CEnumCERTVIEWROW()
{
    DBGCODE(InterlockedIncrement(&g_cCertViewRow));
    DBGCODE(InterlockedIncrement(&g_cCertViewRowTotal));
    m_pvw = NULL;
    m_arowCache = NULL;
    m_prowCacheCurrent = NULL;
    m_cRef = 1;
    m_ieltMax = -1;
}


CEnumCERTVIEWROW::~CEnumCERTVIEWROW()
{
    DBGCODE(InterlockedDecrement(&g_cCertViewRow));

#if DBG_CERTSRV
    if (m_cRef > 1)
    {
	DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "%hs has %d instances left over\n",
	    "CEnumCERTVIEWROW",
	    m_cRef));
    }
#endif

    if (NULL != m_arowCache)
    {
	CoTaskMemFree((VOID *) m_arowCache);
	m_arowCache = NULL;
    }
    if (NULL != m_pvw)
    {
	m_pvw->Release();
    }
}


HRESULT
CEnumCERTVIEWROW::Open(
    IN ICertView *pvw)
{
    HRESULT hr;

    if (NULL == pvw)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = ((CCertView *) pvw)->GetTable(&m_cvrcTable);
    _JumpIfError(hr, error, "GetTable");

    DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "CEnumCERTVIEWROW::Open(cvrcTable=%x)\n",
	    m_cvrcTable));

    m_pvw = pvw;
    m_pvw->AddRef();
    m_fNoMoreData = FALSE;
    m_cskip = 0;
    m_ielt = 0;
    m_ieltCacheNext = 1;
    m_crowChunk = 0;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CEnumCERTVIEWROW::_FindCachedRow(
    IN LONG ielt,
    OUT CERTTRANSDBRESULTROW const **ppRow)
{
    HRESULT hr;
    CERTTRANSDBRESULTROW const *prow;
    ULONG i;

    CSASSERT(NULL != ppRow);
    *ppRow = NULL;

    // If the server threw in an extra CERTTRANSDBRESULTROW structure containing
    // the maximum element count, save the maximum count for later use.

    prow = m_arowCache;
    if (NULL != prow && m_fNoMoreData)
    {
	for (i = 0; i < m_celtCache; i++)
	{
	    prow = (CERTTRANSDBRESULTROW const *) Add2ConstPtr(prow, prow->cbrow);
	}
	if (&prow[1] <=
	    (CERTTRANSDBRESULTROW const *) Add2ConstPtr(m_arowCache, m_cbCache) &&
	    prow->rowid == ~prow->ccol)
	{
	    DBGPRINT((
		    DBG_SS_CERTVIEWI,
		    "_FindCachedRow: ieltMax = %d -> %d\n",
		    m_ieltMax,
		    prow->rowid));
	    CSASSERT(-1 == m_ieltMax || (LONG) prow->rowid == m_ieltMax);
	    m_ieltMax = prow->rowid;
	}
    }

    prow = m_arowCache;
    if (NULL == prow || ielt < m_ieltCacheFirst || ielt >= m_ieltCacheNext)
    {
	hr = S_FALSE;		// requested row is not in the cached rowset
	goto error;
    }
    for (ielt -= m_ieltCacheFirst; 0 < ielt; ielt--)
    {
	prow = (CERTTRANSDBRESULTROW const *) Add2ConstPtr(prow, prow->cbrow);
    }
    *ppRow = prow;
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTVIEWROW::GetMaxIndex(
    /* [out, retval] */ LONG *pIndex)
{
    HRESULT hr;

    if (NULL == pIndex)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (-1 == m_ieltMax)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_ieltMax not set");
    }
    *pIndex = m_ieltMax;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::GetMaxIndex"));
}


STDMETHODIMP
CEnumCERTVIEWROW::Next(
    /* [out, retval] */ LONG *pIndex)
{
    HRESULT hr;
    LONG ielt;
    LONG cbrowResultNominal;

    DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "Trace: hr = pRow->Next(&lNext);\t_PrintIfError(hr, \"Next\");\n"));
    if (NULL == pIndex)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pIndex = -1;
    m_prowCacheCurrent = NULL;

    ielt = m_ielt + m_cskip + 1;

    hr = _FindCachedRow(ielt, &m_prowCacheCurrent);
    if (S_FALSE != hr)
    {
	_JumpIfError(hr, error, "_FindCachedRow");
    }
    else
    {
	if (m_fNoMoreData)
	{
	    hr = S_FALSE;
	    _JumpError2(hr, error, "NoMoreData", S_FALSE);
	}
	if (NULL != m_arowCache)
	{
	    CoTaskMemFree((VOID *) m_arowCache);
	    m_arowCache = NULL;
	}
	if (0 == m_crowChunk)	// First call
	{
	    hr = ((CCertView *) m_pvw)->SetViewColumns(&cbrowResultNominal);
	    _JumpIfError(hr, error, "SetViewColumns");

	    m_crowChunk = CB_TARGETBUFFERSIZE / cbrowResultNominal;

	    DBGPRINT((
		DBG_SS_CERTVIEWI,
		"ViewRow::Next: cbrowNominal=%d crowChunk=%d\n",
		cbrowResultNominal,
		m_crowChunk));

	    if (CROW_VIEWCHUNKMIN > m_crowChunk)
	    {
		m_crowChunk = CROW_VIEWCHUNKMIN;
	    }
	}
	hr = ((CCertView *) m_pvw)->EnumView(
					ielt - m_ieltCacheNext,
					m_crowChunk,
					&m_celtCache,
					&m_ieltCacheNext,
					&m_cbCache,
					&m_arowCache);
	if (S_FALSE == hr)
	{
	    m_fNoMoreData = TRUE;
	}
	else
	{
	    _JumpIfError(hr, error, "EnumView");
	}
	m_ieltCacheFirst = m_ieltCacheNext - m_celtCache;

        // workaround for bug 339811 causes this to fail
	//CSASSERT(ielt == m_ieltCacheFirst);

	hr = _FindCachedRow(ielt, &m_prowCacheCurrent);
	_JumpIfError2(hr, error, "_FindCachedRow", S_FALSE);
    }
    m_cskip = 0;
    m_ielt = ielt;

    *pIndex = m_ielt;
    DBGPRINT((
	DBG_SS_CERTVIEWI,
	"ViewRow::Next: cskip=%d, ccache=%u:%u-%u, ielt=%u, ieltMax=%d, RowId=%u\n",
	m_cskip,
	m_celtCache,
	m_ieltCacheFirst,
	m_ieltCacheNext,
	m_ielt,
	m_ieltMax,
	m_prowCacheCurrent->rowid));

error:
    if (S_OK != hr)
    {
	DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "ViewRow::Next: cskip=%d, ccache=%u:%u-%u, ielt=%u, ieltMax=%d, *pIndex=%d, hr=%x\n",
	    m_cskip,
	    m_celtCache,
	    m_ieltCacheFirst,
	    m_ieltCacheNext,
	    m_ielt,
	    m_ieltMax,
	    NULL != pIndex? *pIndex : -1,
	    hr));
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::Next"));
}


STDMETHODIMP
CEnumCERTVIEWROW::EnumCertViewColumn(
    /* [out] */ IEnumCERTVIEWCOLUMN **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWCOLUMN *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;
    if (NULL == m_prowCacheCurrent)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_prowCacheCurrent");
    }

    penum = new CEnumCERTVIEWCOLUMN;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWCOLUMN");
    }

    hr = ((CEnumCERTVIEWCOLUMN *) penum)->Open(
					    CVRC_COLUMN_VALUE,
					    m_ielt,
					    m_pvw,
					    m_prowCacheCurrent);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;
    penum = NULL;
    hr = S_OK;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::EnumCertViewColumn"));
}


STDMETHODIMP
CEnumCERTVIEWROW::EnumCertViewAttribute(
    /* [in] */          LONG Flags,
    /* [out, retval] */ IEnumCERTVIEWATTRIBUTE **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWATTRIBUTE *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    if (NULL == m_prowCacheCurrent)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_prowCacheCurrent");
    }
    if (CVRC_TABLE_REQCERT != m_cvrcTable)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "table has no attributes");
    }

    penum = new CEnumCERTVIEWATTRIBUTE;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWATTRIBUTE");
    }

    hr = ((CEnumCERTVIEWATTRIBUTE *) penum)->Open(
					    m_prowCacheCurrent->rowid,
					    Flags,
					    m_pvw);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;
    penum = NULL;
    hr = S_OK;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::EnumCertViewAttribute"));
}


STDMETHODIMP
CEnumCERTVIEWROW::EnumCertViewExtension(
    /* [in] */          LONG Flags,
    /* [out, retval] */ IEnumCERTVIEWEXTENSION **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWEXTENSION *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    if (NULL == m_prowCacheCurrent)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_prowCacheCurrent");
    }
    if (CVRC_TABLE_REQCERT != m_cvrcTable)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "table has no extensions");
    }

    penum = new CEnumCERTVIEWEXTENSION;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWEXTENSION");
    }

    hr = ((CEnumCERTVIEWEXTENSION *) penum)->Open(
					    m_prowCacheCurrent->rowid,
					    Flags,
					    m_pvw);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;
    penum = NULL;
    hr = S_OK;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::EnumCertViewExtension"));
}


STDMETHODIMP
CEnumCERTVIEWROW::Skip(
    /* [in] */ LONG celt)
{
    HRESULT hr;
    LONG cskipnew;
    
    cskipnew = m_cskip + celt;

    DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "Trace: hr = pRow->Skip(%d);\t_PrintIfError(hr, \"Skip(%d)\");\n",
	    celt,
	    celt));
    DBGPRINT((
	DBG_SS_CERTVIEWI,
	"ViewRow::Skip(%d) ielt=%d: %d --> %d, skip=%d --> %d\n",
	celt,
	m_ielt,
	m_ielt + m_cskip,
	m_ielt + cskipnew,
	m_cskip,
	cskipnew));

    CSASSERT(0 <= m_ielt);
    if (0 > celt)
    {
	if (-1 > m_ielt + cskipnew)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Skip back to before start");
	}
	m_fNoMoreData = FALSE;
    }

    m_prowCacheCurrent = NULL;
    m_cskip = cskipnew;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::Skip"));
}


STDMETHODIMP
CEnumCERTVIEWROW::Reset(VOID)
{
    HRESULT hr;

    // Trailing // and no newline comment out Skip() call we trigger:

    DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "Trace: hr = pRow->Reset();\t_PrintIfError(hr, \"Reset\");\n// "));

    hr = Skip(-(m_ielt + m_cskip));
    _JumpIfError(hr, error, "Skip");

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::Reset"));
}


STDMETHODIMP
CEnumCERTVIEWROW::Clone(
    /* [out] */ IEnumCERTVIEWROW **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWROW *penum = NULL;
    LONG ielt;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = m_pvw->OpenView(&penum);
    _JumpIfError(hr, error, "OpenView");

    ielt = m_ielt + m_cskip;
    if (-1 != ielt)
    {
	if (NULL == m_prowCacheCurrent)
	{
	    hr = penum->Skip(ielt);
	    _JumpIfError(hr, error, "Skip");
	}
	else
	{
	    LONG Index;

	    hr = penum->Skip(ielt - 1);
	    _JumpIfError(hr, error, "Skip");

	    hr = penum->Next(&Index);
	    _JumpIfError(hr, error, "Next");

	    CSASSERT(Index == ielt);
	}
    }

error:
    if (NULL != ppenum)
    {
	*ppenum = penum;
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::Clone"));
}


HRESULT
CEnumCERTVIEWROW::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTVIEW L".CEnumCERTVIEWROW",
			    &IID_IEnumCERTVIEWROW);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}


// IUnknown implementation
STDMETHODIMP
CEnumCERTVIEWROW::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<IEnumCERTVIEWROW *>(this);
    }
    else if (iid == IID_IDispatch)
    {
	*ppv = static_cast<IEnumCERTVIEWROW *>(this);
    }
    else if (iid == IID_IEnumCERTVIEWROW)
    {
	*ppv = static_cast<IEnumCERTVIEWROW *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWROW::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWROW::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certview\ext.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        ext.h
//
// Contents:    CertView implementation
//
//---------------------------------------------------------------------------

#define CEXT_CHUNK	20

class CEnumCERTVIEWEXTENSION:
    public IDispatchImpl<
		IEnumCERTVIEWEXTENSION,
		&IID_IEnumCERTVIEWEXTENSION,
		&LIBID_CERTADMINLib>,
    public ISupportErrorInfoImpl<&IID_IEnumCERTVIEWEXTENSION>,
    public CComObjectRoot
    // Not externally createable:
    //public CComCoClass<CEnumCERTVIEWEXTENSION, &CLSID_CEnumCERTVIEWEXTENSION>
{
public:
    CEnumCERTVIEWEXTENSION();
    ~CEnumCERTVIEWEXTENSION();

BEGIN_COM_MAP(CEnumCERTVIEWEXTENSION)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IEnumCERTVIEWEXTENSION)
END_COM_MAP_X()

DECLARE_NOT_AGGREGATABLE(CEnumCERTVIEWEXTENSION)
// Remove the comment from the line above if you don't want your object to
// support aggregation.  The default is to support it

#if 0 // Not externally createable:
DECLARE_REGISTRY(
    CEnumCERTVIEWEXTENSION,
    wszCLASS_EnumCERTVIEWEXTENSION TEXT(".1"),
    wszCLASS_EnumCERTVIEWEXTENSION,
    IDS_ENUMCERTVIEWEXTENSION_DESC,
    THREADFLAGS_BOTH)
#endif

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumCERTVIEWEXTENSION
    STDMETHOD(Next)(
	/* [out, retval] */ LONG *pIndex);
    
    STDMETHOD(GetName)(
	/* [out, retval] */ BSTR *pstrOut);

    STDMETHOD(GetFlags)(
	/* [out, retval] */ LONG *pFlags);

    STDMETHOD(GetValue)(
	/* [in] */          LONG Type,
	/* [in] */          LONG Flags,
	/* [out, retval] */ VARIANT *pvarValue);

    STDMETHOD(Skip)(
	/* [in] */ LONG celt);
    
    STDMETHOD(Reset)(VOID);
    
    STDMETHOD(Clone)(
	/* [out] */ IEnumCERTVIEWEXTENSION **ppenum);

    // CEnumCERTVIEWEXTENSION
    HRESULT Open(
	IN LONG RowId,
	IN LONG Flags,
	IN ICertView *pvw);

private:
    HRESULT _FindExtension(
	OUT CERTDBEXTENSION const **ppcde);

    HRESULT _SaveExtensions(
	IN DWORD celt,
	IN CERTTRANSBLOB const *pctbExtensions);

    HRESULT _SetErrorInfo(
	IN HRESULT hrError,
	IN WCHAR const *pwszDescription);
	
    LONG             m_RowId;
    LONG             m_Flags;
    ICertView       *m_pvw;
    LONG             m_ielt;
    LONG             m_ieltCurrent;
    LONG             m_celtCurrent;
    CERTDBEXTENSION *m_aelt;
    BOOL             m_fNoMore;
    BOOL             m_fNoCurrentRecord;

    // Reference count
    long             m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certview\row.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        row.h
//
// Contents:    CertView implementation
//
//---------------------------------------------------------------------------

class CEnumCERTVIEWROW:
    public IDispatchImpl<
		IEnumCERTVIEWROW,
		&IID_IEnumCERTVIEWROW,
		&LIBID_CERTADMINLib>,
    public ISupportErrorInfoImpl<&IID_IEnumCERTVIEWROW>,
    public CComObjectRoot
    // Not externally createable:
    //public CComCoClass<CEnumCERTVIEWROW, &CLSID_CEnumCERTVIEWROW>
{
public:
    CEnumCERTVIEWROW();
    ~CEnumCERTVIEWROW();

BEGIN_COM_MAP(CEnumCERTVIEWROW)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IEnumCERTVIEWROW)
END_COM_MAP_X()

DECLARE_NOT_AGGREGATABLE(CEnumCERTVIEWROW)
// Remove the comment from the line above if you don't want your object to
// support aggregation.  The default is to support it

#if 0 // Not externally createable:
DECLARE_REGISTRY(
    CEnumCERTVIEWROW,
    wszCLASS_EnumCERTVIEWROW TEXT(".1"),
    wszCLASS_EnumCERTVIEWROW,
    IDS_ENUMCERTVIEWROW_DESC,
    THREADFLAGS_BOTH)
#endif

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumCERTVIEWROW
    STDMETHOD(Next)(
	/* [out, retval] */ LONG *pIndex);
    
    STDMETHOD(EnumCertViewColumn)(
	/* [out] */ IEnumCERTVIEWCOLUMN **ppenum);

    STDMETHOD(EnumCertViewAttribute)(
	/* [in] */          LONG Flags,
	/* [out, retval] */ IEnumCERTVIEWATTRIBUTE **ppenum);
    
    STDMETHOD(EnumCertViewExtension)(
	/* [in] */          LONG Flags,
	/* [out, retval] */ IEnumCERTVIEWEXTENSION **ppenum);

    STDMETHOD(Skip)(
	/* [in] */ LONG celt);
    
    STDMETHOD(Reset)(VOID);
    
    STDMETHOD(Clone)(
	/* [out] */ IEnumCERTVIEWROW **ppenum);

    STDMETHOD(GetMaxIndex)(
	/* [out, retval] */ LONG *pIndex);

    // CEnumCERTVIEWROW
    HRESULT Open(
	IN ICertView *pvw);
	
private:
    HRESULT _FindCachedRow(
	IN LONG ielt,
	OUT CERTTRANSDBRESULTROW const **ppRow);

    HRESULT _SetErrorInfo(
	IN HRESULT hrError,
	IN WCHAR const *pwszDescription);

    ICertView                  *m_pvw;

    BOOL                        m_fNoMoreData;
    LONG                        m_cvrcTable;
    LONG                        m_cskip;
    LONG                        m_ielt;		    // index into full rowset
    LONG		        m_crowChunk;	    // Row Chunk Size

    CERTTRANSDBRESULTROW const *m_arowCache;
    ULONG                       m_celtCache;	    // cached rowset count
    LONG                        m_ieltCacheFirst;   // cached rowset first index
    LONG                        m_ieltCacheNext;    // cached rowset last idx+1

    LONG                        m_ieltMax;	    // max valid index
    LONG                        m_cbCache;
    CERTTRANSDBRESULTROW const *m_prowCacheCurrent; // current cached row

    // Reference count
    long                        m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certview\view.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        view.h
//
// Contents:    Declaration of CCertView
//
//---------------------------------------------------------------------------

#include "certsrvd.h"
#include "cscomres.h"


HRESULT
CopyMarshalledString(
    IN CERTTRANSBLOB const *pctb,
    IN ULONG obwsz,
    IN BYTE *pbEnd,
    IN BYTE **ppbNext,
    OUT WCHAR **ppwszOut);


#define ICVTABLE_REQCERT	0
#define ICVTABLE_EXTENSION	1
#define ICVTABLE_ATTRIBUTE	2
#define ICVTABLE_CRL		3
#define ICVTABLE_MAX		4

/////////////////////////////////////////////////////////////////////////////
// CCertView

class ATL_NO_VTABLE CCertView:
    public IDispatchImpl<ICertView2, &IID_ICertView2, &LIBID_CERTADMINLib>,
    public ISupportErrorInfoImpl<&IID_ICertView2>,
    public CComObjectRoot,
    public CComCoClass<CCertView, &CLSID_CCertView>
{
public:
    CCertView();
    ~CCertView();

BEGIN_COM_MAP(CCertView)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertView)
    COM_INTERFACE_ENTRY(ICertView2)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertView)
// Remove the comment from the line above if you don't want your object to
// support aggregation.  The default is to support it

#if 1
DECLARE_REGISTRY(
    CCertView,
    wszCLASS_CERTVIEW TEXT(".1"),
    wszCLASS_CERTVIEW,
    IDS_CERTVIEW_DESC,
    THREADFLAGS_BOTH)
#endif

// ICertView
    STDMETHOD(OpenConnection)(
	/* [in] */ BSTR const strConfig);

    STDMETHOD(EnumCertViewColumn)(
	/* [in] */ LONG fResultColumn,		// CVRC_COLUMN_*
	/* [out, retval] */ IEnumCERTVIEWCOLUMN **ppenum);

    STDMETHOD(GetColumnCount)(
	/* [in] */ LONG fResultColumn,		// CVRC_COLUMN_*
	/* [out, retval] */ LONG __RPC_FAR *pcColumn);

    STDMETHOD(GetColumnIndex)(
	/* [in] */ LONG fResultColumn,		// CVRC_COLUMN_*
	/* [in] */ BSTR const strColumnName,
	/* [out, retval] */ LONG *pColumnIndex);

    STDMETHOD(SetResultColumnCount)(
	/* [in] */ LONG cColumn);

    STDMETHOD(SetResultColumn)(
	/* [in] */ LONG ColumnIndex);

    STDMETHOD(SetRestriction)(
	/* [in] */ LONG ColumnIndex,
	/* [in] */ LONG SeekOperator,
	/* [in] */ LONG SortOrder,
	/* [in] */ VARIANT __RPC_FAR const *pvarValue);

    STDMETHOD(OpenView)(
	/* [out] */ IEnumCERTVIEWROW **ppenum);

// ICertView2
    STDMETHOD(SetTable)(
	/* [in] */ LONG Table);			// CVRC_TABLE_*

// CCertView
    HRESULT GetTable(
	OUT LONG *pcvrcTable);

    HRESULT FindColumn(
	IN LONG Flags,				// CVRC_TABLE_* | CVRC_COLUMN_*
	IN LONG ColumnIndex,
	OUT CERTDBCOLUMN const **ppColumn,
	OPTIONAL OUT WCHAR const **ppwszDisplayName);

    HRESULT SetViewColumns(
	OUT LONG *pcbrowResultNominal);

    HRESULT EnumView(
	IN  LONG                         cskip,
	IN  ULONG                        celt,
	OUT ULONG                       *pceltFetched,
	OUT LONG                        *pieltNext,
	OUT LONG		        *pcbResultRows,
	OUT CERTTRANSDBRESULTROW const **ppResultRows);

    HRESULT EnumAttributesOrExtensions(
	IN DWORD RowId,
	IN DWORD Flags,
	OPTIONAL IN WCHAR const *pwszLast,
	IN DWORD celt,
	OUT DWORD *pceltFetched,
	CERTTRANSBLOB *pctbOut);

// Internal Functions
private:
    VOID _Cleanup();

    HRESULT _VerifyServerVersion(
	IN DWORD RequiredVersion);

    HRESULT _SaveColumnInfo(
	IN LONG icvTable,
	IN DWORD celt,
	IN CERTTRANSBLOB const *pctbColumn);

    HRESULT _LoadSchema(
	IN LONG icvTable,
	IN LONG cvrcTable);

    HRESULT _ValidateFlags(
	IN BOOL fSchemaOnly,
	IN DWORD Flags);

    HRESULT _SetTable(
	IN LONG Table);			// CVRC_TABLE_* or CV_COLUMN_*_DEFAULT

    HRESULT _SetErrorInfo(
	IN HRESULT hrError,
	IN WCHAR const *pwszDescription);

    WCHAR           *m_pwszServerName;
    DWORD	     m_dwServerVersion;
    ICertAdminD2    *m_pICertAdminD;

    CERTDBCOLUMN   **m_aaaColumn[ICVTABLE_MAX];
    DWORD            m_acaColumn[ICVTABLE_MAX];
    LONG             m_acColumn[ICVTABLE_MAX];

    CERTVIEWRESTRICTION *m_aRestriction;
    LONG             m_cRestriction;
    BOOL             m_fTableSet;
    LONG             m_icvTable;	// ICVTABLE_*
    LONG             m_cvrcTable;	// CVRC_TABLE_*

    BOOL             m_fAddOk;
    LONG             m_cColumnResultMax;
    LONG             m_cColumnResult;
    LONG             m_cbcolResultNominalTotal;

    LONG            *m_aColumnResult;   // Exposed 0-based Column Index array
    DWORD           *m_aDBColumnResult; // Server DB Column Index array

    WCHAR           *m_pwszAuthority;
    BOOL             m_fOpenConnection;
    BOOL             m_fOpenView;
    BOOL             m_fServerOpenView;
    LONG             m_ielt;
    WCHAR const	   **m_aapwszColumnDisplayName[ICVTABLE_MAX];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certview\view.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        view.cpp
//
// Contents:    CertView implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "csprop.h"
#include "csdisp.h"
#include "column.h"
#include "row.h"
#include "view.h"

#define __dwFILE__	__dwFILE_CERTVIEW_VIEW_CPP__


WCHAR const g_wszRequestDot[] = wszPROPREQUESTDOT;

#if DBG_CERTSRV
LONG g_cCertView;
LONG g_cCertViewTotal;
#endif


#define CV_COLUMN_CHUNK		66



//+--------------------------------------------------------------------------
// _cbcolNominal -- Return nominal size for DB column data, based on type.
//
// Assume string binary columns are less than full:
//+--------------------------------------------------------------------------

__inline LONG
_cbcolNominal(
    IN LONG Type,
    IN LONG cbMax)
{
    LONG divisor = 1;

    switch (PROPTYPE_MASK & Type)
    {
	case PROPTYPE_STRING: divisor = 2; break;	// one-half full?
	case PROPTYPE_BINARY: divisor = 4; break;	// one-quarter full?
    }
    return(cbMax / divisor);
}


//+--------------------------------------------------------------------------
// CCertView::CCertView -- constructor
//+--------------------------------------------------------------------------

CCertView::CCertView()
{
    DBGCODE(InterlockedIncrement(&g_cCertView));
    DBGCODE(InterlockedIncrement(&g_cCertViewTotal));
    ZeroMemory(&m_aaaColumn, sizeof(m_aaaColumn));
    m_fOpenConnection = FALSE;
    m_dwServerVersion = 0;
    m_pICertAdminD = NULL;
    m_aColumnResult = NULL;
    m_aDBColumnResult = NULL;
    m_pwszAuthority = NULL;
    m_fAddOk = FALSE;
    m_fOpenView = FALSE;
    m_fServerOpenView = FALSE;
    m_aRestriction = NULL;
    m_fTableSet = FALSE;
    m_icvTable = ICVTABLE_REQCERT;
    m_cvrcTable = CVRC_TABLE_REQCERT;
    m_pwszServerName = NULL;
    ZeroMemory(&m_aapwszColumnDisplayName, sizeof(m_aapwszColumnDisplayName));
}


//+--------------------------------------------------------------------------
// CCertView::~CCertView -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertView::~CCertView()
{
    DBGCODE(InterlockedDecrement(&g_cCertView));

#if DBG_CERTSRV
    if (m_dwRef > 1)
    {
	DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "%hs has %d instances left over\n",
	    "CCertView",
	    m_dwRef));
    }
#endif

    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertView::_Cleanup
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertView::_Cleanup()
{
    LONG i;

    myCloseDComConnection((IUnknown **) &m_pICertAdminD, &m_pwszServerName);
    m_dwServerVersion = 0;
    m_fOpenConnection = FALSE;

    if (NULL != m_aColumnResult)
    {
	LocalFree(m_aColumnResult);
	m_aColumnResult = NULL;
    }
    if (NULL != m_aDBColumnResult)
    {
	LocalFree(m_aDBColumnResult);
	m_aDBColumnResult = NULL;
    }
    for (i = 0; i < ICVTABLE_MAX; i++)
    {
	if (NULL != m_aaaColumn[i])
	{
	    CERTDBCOLUMN **ppcol;

	    for (
		ppcol = m_aaaColumn[i];
		ppcol < &m_aaaColumn[i][m_acaColumn[i]];
		ppcol++)
	    {
		if (NULL != *ppcol)
		{
		    LocalFree(*ppcol);
		}
	    }
	    LocalFree(m_aaaColumn[i]);
	    m_aaaColumn[i] = NULL;
	}
    }
    if (NULL != m_aRestriction)
    {
	for (i = 0; i < m_cRestriction; i++)
	{
	    if (NULL != m_aRestriction[i].pbValue)
	    {
		LocalFree(m_aRestriction[i].pbValue);
	    }
	}
	LocalFree(m_aRestriction);
	m_aRestriction = NULL;
    }
    if (NULL != m_pwszAuthority)
    {
	LocalFree(m_pwszAuthority);
	m_pwszAuthority = NULL;
    }
    for (i = 0; i < ICVTABLE_MAX; i++)
    {
	if (NULL != m_aapwszColumnDisplayName[i])
	{
	    LocalFree(m_aapwszColumnDisplayName[i]);
	    m_aapwszColumnDisplayName[i] = NULL;
	}
    }
}


HRESULT
CCertView::_ValidateFlags(
    IN BOOL fSchemaOnly,
    IN DWORD Flags)
{
    HRESULT hr = E_INVALIDARG;

    if (~CVRC_COLUMN_MASK & Flags)
    {
	_JumpError(hr, error, "invalid bits");
    }
    switch (CVRC_COLUMN_MASK & Flags)
    {
	case CVRC_COLUMN_RESULT:
	case CVRC_COLUMN_VALUE:
	    if (fSchemaOnly)
	    {
		_JumpError(hr, error, "RESULT/VALUE");
	    }
	    break;

	case CVRC_COLUMN_SCHEMA:
	    break;

	default:
	    _JumpError(hr, error, "bad column");
    }
    if (!m_fOpenConnection ||
	(CVRC_COLUMN_SCHEMA != (CVRC_COLUMN_MASK & Flags) &&
	 !m_fOpenView))
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "Unexpected");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertView::_SetTable(
    IN LONG ColumnIndex)	// CVRC_TABLE_* or CV_COLUMN_*_DEFAULT
{
    HRESULT hr;
    LONG cvrcTable;
    LONG icvTable;
    
    if (0 > ColumnIndex)
    {
	switch (ColumnIndex)
	{
	    case CV_COLUMN_LOG_DEFAULT:
	    case CV_COLUMN_LOG_FAILED_DEFAULT:
	    case CV_COLUMN_LOG_REVOKED_DEFAULT:
	    case CV_COLUMN_QUEUE_DEFAULT:
		icvTable = ICVTABLE_REQCERT;
		cvrcTable = CVRC_TABLE_REQCERT;
		break;

	    case CV_COLUMN_EXTENSION_DEFAULT:
		icvTable = ICVTABLE_EXTENSION;
		cvrcTable = CVRC_TABLE_EXTENSIONS;
		break;

	    case CV_COLUMN_ATTRIBUTE_DEFAULT:
		icvTable = ICVTABLE_ATTRIBUTE;
		cvrcTable = CVRC_TABLE_ATTRIBUTES;
		break;

	    case CV_COLUMN_CRL_DEFAULT:
		icvTable = ICVTABLE_CRL;
		cvrcTable = CVRC_TABLE_CRL;
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "bad negative ColumnIndex");
	}
    }
    else
    {
	if (~CVRC_TABLE_MASK & ColumnIndex)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "invalid bits");
	}
	switch (ColumnIndex)
	{
	    case CVRC_TABLE_REQCERT:
		icvTable = ICVTABLE_REQCERT;
		break;

	    case CVRC_TABLE_EXTENSIONS:
		icvTable = ICVTABLE_EXTENSION;
		break;

	    case CVRC_TABLE_ATTRIBUTES:
		icvTable = ICVTABLE_ATTRIBUTE;
		break;

	    case CVRC_TABLE_CRL:
		icvTable = ICVTABLE_CRL;
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "bad table");
	}
	cvrcTable = CVRC_TABLE_MASK & ColumnIndex;
    }
    if (m_fTableSet)
    {
	if (icvTable != m_icvTable || cvrcTable != m_cvrcTable)
	{
	    DBGPRINT((
		DBG_SS_CERTVIEW,
		"_SetTable: cvrcTable=%x <- %x\n",
		m_cvrcTable,
		cvrcTable));
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "mixed tables");
	}
    }
    else
    {
	m_icvTable = icvTable;
	m_cvrcTable = cvrcTable;
	m_fTableSet = TRUE;
	DBGPRINT((DBG_SS_CERTVIEWI, "_SetTable(cvrcTable=%x)\n", m_cvrcTable));
    }
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CCertView::SetTable(
    /* [in] */ LONG Table)			// CVRC_TABLE_*
{
    HRESULT hr;
    
    hr = _VerifyServerVersion(2);
    _JumpIfError(hr, error, "_VerifyServerVersion");

    if (0 > Table)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Table");
    }
    if (m_fTableSet)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "Already set");
    }
    hr = _SetTable(Table);
    _JumpIfError(hr, error, "_SetTable");

error:
    return(hr);
}


HRESULT
CCertView::GetTable(
    OUT LONG *pcvrcTable)
{
    HRESULT hr;
    
    if (NULL == pcvrcTable)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pcvrcTable = m_cvrcTable;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertView::FindColumn(
    IN LONG Flags,				// CVRC_COLUMN_*
    IN LONG ColumnIndex,
    OUT CERTDBCOLUMN const **ppColumn,		 // localized for server
    OPTIONAL OUT WCHAR const **ppwszDisplayName) // localized for client
{
    HRESULT hr;
    DWORD i;
    DBGCODE(LONG ColumnIndexArg = ColumnIndex);

    if (NULL == ppColumn)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppColumn = NULL;

    hr = _ValidateFlags(FALSE, Flags);
    _JumpIfError(hr, error, "_ValidateFlags");

    hr = E_INVALIDARG;
    if (CVRC_COLUMN_SCHEMA != (CVRC_COLUMN_MASK & Flags))
    {
	if (m_cColumnResult <= ColumnIndex)
	{
	    DBGPRINT((
		DBG_SS_CERTVIEW,
		"FindColumn(Flags=%x, ColumnIndex=%x, m_cColumnResult=%x)\n",
		Flags,
		ColumnIndex,
		m_cColumnResult));
	    _JumpError(hr, error, "Result ColumnIndex");
	}
	ColumnIndex = m_aColumnResult[ColumnIndex];
    }
    if (ColumnIndex >= m_acColumn[m_icvTable])
    {
	_JumpError(hr, error, "ColumnIndex");
    }
    i = ColumnIndex / CV_COLUMN_CHUNK;
    if (i >= m_acaColumn[m_icvTable])
    {
	_JumpError(hr, error, "ColumnIndex2");
    }

    *ppColumn = &m_aaaColumn[m_icvTable][i][ColumnIndex % CV_COLUMN_CHUNK];

    CSASSERT(NULL != m_aapwszColumnDisplayName[m_icvTable]);
    CSASSERT(NULL != m_aapwszColumnDisplayName[m_icvTable][ColumnIndex]);
    if (NULL != ppwszDisplayName)
    {
	*ppwszDisplayName = m_aapwszColumnDisplayName[m_icvTable][ColumnIndex];
    }
    DBGPRINT((
	DBG_SS_CERTVIEWI,
	"FindColumn(Flags=%x, ColumnIndex=%x->%x) --> Type=%x Index=%x %ws/%ws\n",
	Flags,
	ColumnIndexArg,
	ColumnIndex,
	(*ppColumn)->Type,
	(*ppColumn)->Index,
	(*ppColumn)->pwszName,
	m_aapwszColumnDisplayName[m_icvTable][ColumnIndex]));
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertView::_SaveColumnInfo(
    IN LONG icvTable,
    IN DWORD celt,
    IN CERTTRANSBLOB const *pctbColumn)
{
    HRESULT hr;
    DWORD cbNew;
    CERTDBCOLUMN *peltNew = NULL;
    CERTDBCOLUMN *pelt;
    CERTTRANSDBCOLUMN *ptelt;
    CERTTRANSDBCOLUMN *pteltEnd;
    BYTE *pbNext;
    BYTE *pbEnd;
    CERTDBCOLUMN **ppColumn;

    if (NULL == pctbColumn)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    cbNew = pctbColumn->cb + celt * (sizeof(*pelt) - sizeof(*ptelt));
    peltNew = (CERTDBCOLUMN *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cbNew);
    if (NULL == peltNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pteltEnd = &((CERTTRANSDBCOLUMN *) pctbColumn->pb)[celt];
    if ((BYTE *) pteltEnd > &pctbColumn->pb[pctbColumn->cb])
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "bad marshalled data");
    }
    pelt = peltNew;
    pbNext = (BYTE *) &peltNew[celt];
    pbEnd = (BYTE *) Add2Ptr(peltNew, cbNew);
    for (ptelt = (CERTTRANSDBCOLUMN *) pctbColumn->pb;
	 ptelt < pteltEnd;
	 ptelt++, pelt++)
    {
	pelt->Type = ptelt->Type;
	pelt->Index = ptelt->Index;
	pelt->cbMax = ptelt->cbMax;

	hr = CopyMarshalledString(
			    pctbColumn, 
			    ptelt->obwszName,
			    pbEnd,
			    &pbNext,
			    &pelt->pwszName);
	_JumpIfError(hr, error, "CopyMarshalledString");

	hr = CopyMarshalledString(
			    pctbColumn, 
			    ptelt->obwszDisplayName,
			    pbEnd,
			    &pbNext,
			    &pelt->pwszDisplayName);
	_JumpIfError(hr, error, "CopyMarshalledString");

    }
    CSASSERT(pbNext == pbEnd);

    ppColumn = (CERTDBCOLUMN **) LocalAlloc(
		    LMEM_FIXED,
		    (m_acaColumn[icvTable] + 1) * sizeof(m_aaaColumn[0]));
    if (NULL == ppColumn)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc ppColumn");
    }
    if (NULL != m_aaaColumn[icvTable])
    {
	CopyMemory(
	    ppColumn,
	    m_aaaColumn[icvTable],
	    m_acaColumn[icvTable] * sizeof(m_aaaColumn[0]));
	LocalFree(m_aaaColumn[icvTable]);
    }
    m_aaaColumn[icvTable] = ppColumn;

    m_aaaColumn[icvTable][m_acaColumn[icvTable]] = peltNew;
    peltNew = NULL;

    m_acaColumn[icvTable]++;
    m_acColumn[icvTable] += celt;
    hr = S_OK;

error:
    if (NULL != peltNew)
    {
	LocalFree(peltNew);
    }
    return(hr);
}


HRESULT
CCertView::_LoadSchema(
    IN LONG icvTable,
    IN LONG cvrcTable)
{
    HRESULT hr;
    DWORD icol;
    DWORD ccol;
    CERTTRANSBLOB ctbColumn;

    ctbColumn.pb = NULL;
    icol = 0;

    CSASSERT(icvTable < ICVTABLE_MAX);

    do
    {
	ccol = CV_COLUMN_CHUNK;
	ctbColumn.cb = 0;
	hr = S_OK;
	__try
	{
	    if (CVRC_TABLE_REQCERT == cvrcTable)
	    {
		hr = m_pICertAdminD->EnumViewColumn(
					m_pwszAuthority,
					icol,
					ccol,
					&ccol,
					&ctbColumn);
	    }
	    else
	    {
		CSASSERT(S_OK == _VerifyServerVersion(2));
		hr = m_pICertAdminD->EnumViewColumnTable(
					m_pwszAuthority,
					cvrcTable,
					icol,
					ccol,
					&ccol,
					&ctbColumn);
	    }
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	if (S_FALSE != hr)
	{
	    _JumpIfError(
		    hr,
		    error,
		    CVRC_TABLE_REQCERT == cvrcTable?
			"EnumViewColumn" : "EnumViewColumnTable");
	}

	myRegisterMemAlloc(ctbColumn.pb, ctbColumn.cb, CSM_MIDLUSERALLOC);

	hr = _SaveColumnInfo(icvTable, ccol, &ctbColumn);
	_JumpIfError(hr, error, "_SaveColumnInfo");

	CoTaskMemFree(ctbColumn.pb);
	ctbColumn.pb = NULL;

	icol += ccol;

    } while (CV_COLUMN_CHUNK == ccol);

    m_aapwszColumnDisplayName[icvTable] = (WCHAR const **) LocalAlloc(
	LMEM_FIXED | LMEM_ZEROINIT,
	m_acColumn[icvTable] * sizeof(m_aapwszColumnDisplayName[icvTable][0]));
    if (NULL == m_aapwszColumnDisplayName[icvTable])
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    for (icol = 0; icol < (DWORD) m_acColumn[icvTable]; icol++)
    {
	CERTDBCOLUMN const *pColumn;

	CSASSERT(icol / CV_COLUMN_CHUNK < m_acaColumn[icvTable]);
	pColumn = &m_aaaColumn[icvTable][icol / CV_COLUMN_CHUNK][icol % CV_COLUMN_CHUNK];

	hr = myGetColumnDisplayName(
			    pColumn->pwszName,
			    &m_aapwszColumnDisplayName[icvTable][icol]);

	if (E_INVALIDARG == hr)
	{
	    _PrintErrorStr(hr, "myGetColumnDisplayName", pColumn->pwszName);
	    m_aapwszColumnDisplayName[icvTable][icol] = pColumn->pwszName;
	    hr = S_OK;
	}
	_JumpIfError(hr, error, "myGetColumnDisplayName");
    }
    hr = S_OK;

error:
    if (NULL != ctbColumn.pb)
    {
	CoTaskMemFree(ctbColumn.pb);
    }
    return(hr);
}


STDMETHODIMP
CCertView::OpenConnection(
    /* [in] */ BSTR const strConfig)
{
    HRESULT hr;
    DWORD i;
    WCHAR const *pwszAuthority;
    BOOL fTeardownOnError = FALSE;

    static LONG s_aTable[ICVTABLE_MAX] =
    {
	CVRC_TABLE_REQCERT,	// ICVTABLE_REQCERT
	CVRC_TABLE_EXTENSIONS,	// ICVTABLE_EXTENSION
	CVRC_TABLE_ATTRIBUTES,	// ICVTABLE_ATTRIBUTE
	CVRC_TABLE_CRL,		// ICVTABLE_CRL
    };

    if (NULL == strConfig)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (m_fOpenConnection)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "Connected");
    }
    fTeardownOnError = TRUE;

    m_dwServerVersion = 0;
    hr = myOpenAdminDComConnection(
			strConfig,
			&pwszAuthority,
			&m_pwszServerName,
			&m_dwServerVersion,
			&m_pICertAdminD);
    _JumpIfError(hr, error, "myOpenAdminDComConnection");

    CSASSERT (0 != m_dwServerVersion);

    hr = myDupString(pwszAuthority, &m_pwszAuthority);
    _JumpIfError(hr, error, "myDupString");

    ZeroMemory(&m_acaColumn, sizeof(m_acaColumn));
    ZeroMemory(&m_acColumn, sizeof(m_acColumn));

    m_cRestriction = 0;
    m_aRestriction = (CERTVIEWRESTRICTION *) LocalAlloc(LMEM_FIXED, 0);
    if (NULL == m_aRestriction)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    m_fOpenConnection = TRUE;

    for (i = 0; i < ICVTABLE_MAX; i++)
    {
	if (m_dwServerVersion >= 2 || ICVTABLE_REQCERT == i)
	{
	    hr = _LoadSchema(i, s_aTable[i]);
	    _JumpIfError(hr, error, "_LoadSchema");
	}
    }
    hr = S_OK;

error:
    if (S_OK != hr && fTeardownOnError)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertView::OpenConnection"));
}


//+--------------------------------------------------------------------------
// CCertView::_VerifyServerVersion -- verify server version
//
//+--------------------------------------------------------------------------

HRESULT
CCertView::_VerifyServerVersion(
    IN DWORD RequiredVersion)
{
    HRESULT hr;
    
    if (!m_fOpenConnection)
    {
	hr = HRESULT_FROM_WIN32(ERROR_ONLY_IF_CONNECTED);
	_JumpError(hr, error, "Not connected");
    }
    if (m_dwServerVersion < RequiredVersion)
    {
	hr = RPC_E_VERSION_MISMATCH;
	_JumpError(hr, error, "old server");
    }
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CCertView::EnumCertViewColumn(
    /* [in] */ LONG fResultColumn,		// CVRC_COLUMN_*
    /* [out, retval] */ IEnumCERTVIEWCOLUMN **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWCOLUMN *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    penum = new CEnumCERTVIEWCOLUMN;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWCOLUMN");
    }

    hr = ((CEnumCERTVIEWCOLUMN *) penum)->Open(fResultColumn, -1, this, NULL);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;
    penum = NULL;
    hr = S_OK;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CCertView::EnumCertViewColumn"));
}


STDMETHODIMP
CCertView::GetColumnCount(
    /* [in] */ LONG fResultColumn,		// CVRC_COLUMN_*
    /* [out, retval] */ LONG __RPC_FAR *pcColumn)
{
    HRESULT hr;

    if (NULL == pcColumn)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _ValidateFlags(FALSE, fResultColumn);
    _JumpIfError(hr, error, "_ValidateFlags");

    *pcColumn = CVRC_COLUMN_SCHEMA != (CVRC_COLUMN_MASK & fResultColumn)?
			m_cColumnResult : m_acColumn[m_icvTable];

error:
    return(_SetErrorInfo(hr, L"CCertView::GetColumnCount"));
}


STDMETHODIMP
CCertView::GetColumnIndex(
    /* [in] */ LONG fResultColumn,		// CVRC_COLUMN_*
    /* [in] */ BSTR const strColumnName,
    /* [out, retval] */ LONG *pColumnIndex)
{
    HRESULT hr;
    CERTDBCOLUMN const *pColumn;
    WCHAR const *pwsz;
    WCHAR *pwszAlloc = NULL;
    WCHAR const *pwszDisplayName;
    LONG icol;
    LONG i;

    if (NULL == strColumnName || NULL == pColumnIndex)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    pwsz = strColumnName;

    hr = _ValidateFlags(FALSE, fResultColumn);
    _JumpIfError(hr, error, "_ValidateFlags");

    // First pass:  i == 0 -- compare against unlocalized column name
    // Second pass: i == 1 -- compare against localized column name
    // Third pass:  i == 2 -- compare Request.pwsz against unlocalized colname

    for (i = 0; ; i++)
    {
	if (1 < i)
	{
	    if (ICVTABLE_REQCERT != m_icvTable || NULL != wcschr(pwsz, L'.'))
	    {
		hr = E_INVALIDARG;
		_JumpErrorStr(hr, error, "Bad Column Name", strColumnName);
	    }
	    pwszAlloc = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					wcslen(pwsz) * sizeof(WCHAR) +
					    sizeof(g_wszRequestDot));
	    if (NULL == pwszAlloc)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    wcscpy(pwszAlloc, g_wszRequestDot);
	    wcscat(pwszAlloc, pwsz);
	    pwsz = pwszAlloc;
	}
	for (icol = 0; icol < m_acColumn[m_icvTable]; icol++)
	{
	    hr = FindColumn(fResultColumn, icol, &pColumn, &pwszDisplayName);
	    _JumpIfErrorStr(hr, error, "FindColumn", strColumnName);

	    CSASSERT(NULL != pColumn);
	    CSASSERT(NULL != pColumn->pwszName);
	    CSASSERT(NULL != pColumn->pwszDisplayName);	// localized for server
	    CSASSERT(NULL != pwszDisplayName);		// localized for client

	    if (0 == mylstrcmpiL(
			    pwsz,
			    1 == i? pwszDisplayName : pColumn->pwszName))
	    {
		break;
	    }
	}
	if (icol < m_acColumn[m_icvTable])
	{
	    break;
	}
    }

    *pColumnIndex = icol;
    hr = S_OK;

error:
    if (NULL != pwszAlloc)
    {
	LocalFree(pwszAlloc);
    }
    return(_SetErrorInfo(hr, L"CCertView::GetColumnIndex"));
}


STDMETHODIMP
CCertView::SetResultColumnCount(
    /* [in] */ LONG cResultColumn)
{
    HRESULT hr;
    CERTTRANSBLOB ctbColumnDefault;

    ctbColumnDefault.pb = NULL;
    hr = E_UNEXPECTED;
    if (!m_fOpenConnection)
    {
	_JumpError(hr, error, "No Connection");
    }
    if (NULL != m_aColumnResult)
    {
	_JumpError(hr, error, "2nd call");
    }
    if (!m_fTableSet)
    {
	hr = _SetTable(CVRC_TABLE_REQCERT);
	_JumpIfError(hr, error, "_SetTable");
    }

    m_cbcolResultNominalTotal = 0;
    m_fAddOk = TRUE;
    if (0 > cResultColumn)
    {
	DWORD cColumnDefault = 0;

	m_fAddOk = FALSE;
	ctbColumnDefault.cb = 0;
	__try
	{
	    hr = m_pICertAdminD->GetViewDefaultColumnSet(
				    m_pwszAuthority,
				    cResultColumn,
				    &cColumnDefault,
				    &ctbColumnDefault);
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	_JumpIfError(hr, error, "GetViewDefaultColumnSet");

	myRegisterMemAlloc(
		    ctbColumnDefault.pb,
		    ctbColumnDefault.cb,
		    CSM_MIDLUSERALLOC);

	cResultColumn = cColumnDefault;
	CSASSERT(NULL != ctbColumnDefault.pb);
	CSASSERT(cResultColumn * sizeof(DWORD) == ctbColumnDefault.cb);
    }
    else
    {
	cResultColumn &= CVRC_COLUMN_MASK;
    }

    m_aColumnResult = (LONG *) LocalAlloc(
				LMEM_FIXED,
				cResultColumn * sizeof(m_aColumnResult[0]));
    if (NULL == m_aColumnResult)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Result Column array");
    }

    m_aDBColumnResult = (DWORD *) LocalAlloc(
				LMEM_FIXED,
				cResultColumn * sizeof(m_aDBColumnResult[0]));
    if (NULL == m_aDBColumnResult)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Result DB Column array");
    }

    m_cColumnResultMax = cResultColumn;
    m_cColumnResult = 0;

    if (!m_fAddOk)
    {
	LONG i;
	DWORD const *pIndex;

	pIndex = (DWORD const *) ctbColumnDefault.pb;
	for (i = 0; i < cResultColumn; pIndex++, i++)
	{
	    LONG icol;
	    CERTDBCOLUMN const *pColumn;

	    for (icol = 0; icol < m_acColumn[m_icvTable]; icol++)
	    {
		hr = FindColumn(
			    CVRC_COLUMN_SCHEMA,
			    icol,
			    &pColumn,
			    NULL);
		_JumpIfError(hr, error, "FindColumn");

		if (*pIndex == pColumn->Index)
		{
		    m_aDBColumnResult[i] = *pIndex;
		    m_aColumnResult[i] = icol;
		    m_cbcolResultNominalTotal += _cbcolNominal(pColumn->Type, pColumn->cbMax);
		    break;
		}
	    }
	    if (icol >= m_acColumn[m_icvTable])
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "ColumnIndex");
	    }
	}
	m_cColumnResult = cResultColumn;
    }
    hr = S_OK;

error:
    if (NULL != ctbColumnDefault.pb)
    {
	CoTaskMemFree(ctbColumnDefault.pb);
    }
    return(_SetErrorInfo(hr, L"CCertView::SetResultColumnCount"));
}


STDMETHODIMP
CCertView::SetResultColumn(
    /* [in] */ LONG ColumnIndex)
{
    HRESULT hr;
    CERTDBCOLUMN const *pColumn;

    if (m_fOpenView || !m_fAddOk || m_cColumnResultMax <= m_cColumnResult)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "Unexpected");
    }
    if (!m_fTableSet)
    {
	hr = _SetTable(CVRC_TABLE_REQCERT);
	_JumpIfError(hr, error, "_SetTable");
    }

    if (m_acColumn[m_icvTable] <= ColumnIndex)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "ColumnIndex");
    }
    m_aColumnResult[m_cColumnResult] = ColumnIndex;

    hr = FindColumn(
		CVRC_COLUMN_SCHEMA,
		ColumnIndex,
		&pColumn,
		NULL);
    _JumpIfError(hr, error, "FindColumn");

    m_aDBColumnResult[m_cColumnResult] = pColumn->Index;
    m_cbcolResultNominalTotal += _cbcolNominal(pColumn->Type, pColumn->cbMax);

    m_cColumnResult++;

error:
    return(_SetErrorInfo(hr, L"CCertView::SetResultColumn"));
}


STDMETHODIMP
CCertView::SetRestriction(
    /* [in] */ LONG ColumnIndex,
    /* [in] */ LONG SeekOperator,
    /* [in] */ LONG SortOrder,
    /* [in] */ VARIANT __RPC_FAR const *pvarValue)
{
    HRESULT hr;
    CERTDBCOLUMN const *pColumn;
    CERTVIEWRESTRICTION cvr;
    CERTVIEWRESTRICTION *pcvr;

    ZeroMemory(&cvr, sizeof(cvr));

    hr = E_UNEXPECTED;
    if (!m_fOpenConnection)
    {
	_JumpError(hr, error, "No Connection");
    }
    if (!m_fTableSet)
    {
	hr = _SetTable(CVRC_TABLE_REQCERT);
	_JumpIfError(hr, error, "_SetTable");
    }

    if (0 > ColumnIndex)
    {
	cvr.ColumnIndex = ColumnIndex;
	CSASSERT(CVR_SEEK_NONE == cvr.SeekOperator);
	CSASSERT(CVR_SORT_NONE == cvr.SortOrder);
	CSASSERT(NULL == cvr.pbValue);
	CSASSERT(0 == cvr.cbValue);
	hr = S_OK;
    }
    else
    {
	if (NULL == pvarValue)
	{
	    hr = E_POINTER;
	    _JumpError(hr, error, "NULL parm");
	}

	hr = FindColumn(
		    CVRC_COLUMN_SCHEMA,
		    CVRC_COLUMN_MASK & ColumnIndex,
		    &pColumn,
		    NULL);
	_JumpIfError(hr, error, "FindColumn");

	switch (SeekOperator)
	{
	    case CVR_SEEK_EQ:
	    case CVR_SEEK_LT:
	    case CVR_SEEK_LE:
	    case CVR_SEEK_GE:
	    case CVR_SEEK_GT:
            case CVR_SEEK_NONE:
	    //case CVR_SEEK_SET:
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Seek Operator");
	}
	switch (SortOrder)
	{
	    case CVR_SORT_NONE:
	    case CVR_SORT_ASCEND:
	    case CVR_SORT_DESCEND:
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Sort Order");
	}

	hr = myMarshalVariant(
			pvarValue,
			pColumn->Type,
			&cvr.cbValue,
			&cvr.pbValue);
	_JumpIfError(hr, error, "myMarshalVariant");

	cvr.ColumnIndex = pColumn->Index;
	cvr.SeekOperator = SeekOperator;
	cvr.SortOrder = SortOrder;
    }
    pcvr = (CERTVIEWRESTRICTION *) LocalAlloc(
					LMEM_FIXED,
					(m_cRestriction + 1) * sizeof(*pcvr));
    if (NULL == pcvr)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (NULL != m_aRestriction)
    {
	CopyMemory(pcvr, m_aRestriction, m_cRestriction * sizeof(*pcvr));
	LocalFree(m_aRestriction);
    }
    CopyMemory(&pcvr[m_cRestriction], &cvr, sizeof(cvr));
    cvr.pbValue = NULL;

    m_aRestriction = pcvr;
    m_cRestriction++;

error:
    if (NULL != cvr.pbValue)
    {
	LocalFree(cvr.pbValue);
    }
    return(_SetErrorInfo(hr, L"CCertView::SetRestriction"));
}


STDMETHODIMP
CCertView::OpenView(
    /* [out] */ IEnumCERTVIEWROW **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWROW *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    hr = E_UNEXPECTED;
    if (!m_fOpenConnection)
    {
	_JumpError(hr, error, "No Connection");
    }
    if (m_fOpenView)
    {
	_JumpError(hr, error, "2nd call");
    }

    penum = new CEnumCERTVIEWROW;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWROW");
    }

    hr = ((CEnumCERTVIEWROW *) penum)->Open(this);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;
    m_fAddOk = FALSE;
    m_fOpenView = TRUE;
    hr = S_OK;

error:
    if (S_OK != hr && NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CCertView::OpenView"));
}


HRESULT
CCertView::SetViewColumns(
    OUT LONG *pcbrowResultNominal)
{
    HRESULT hr;
    LONG icol;

    if (NULL == pcbrowResultNominal)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (m_fServerOpenView)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "View Already Open");
    }

    if (!m_fTableSet)
    {
	hr = _SetTable(CVRC_TABLE_REQCERT);
	_JumpIfError(hr, error, "_SetTable");
    }

    if (NULL == m_aDBColumnResult)
    {
	hr = SetResultColumnCount(m_acColumn[m_icvTable]);
	_JumpIfError(hr, error, "SetResultColumnCount");

	for (icol = 0; icol < m_acColumn[m_icvTable]; icol++)
	{
	    hr = SetResultColumn(icol);
	    _JumpIfError(hr, error, "SetResultColumn");
	}
    }
    *pcbrowResultNominal =
		sizeof(CERTDBRESULTROW) +
		sizeof(CERTDBRESULTCOLUMN) * m_cColumnResultMax +
		m_cbcolResultNominalTotal;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertView::EnumView(
    IN  LONG                         cskip,
    IN  ULONG                        celt,
    OUT ULONG                       *pceltFetched,
    OUT LONG                        *pieltNext,
    OUT LONG		            *pcbResultRows,
    OUT CERTTRANSDBRESULTROW const **ppResultRows)
{
    HRESULT hr;
    CERTTRANSBLOB ctbResultRows;
    
    if (NULL == ppResultRows ||
        NULL == pceltFetched ||
        NULL == pieltNext ||
        NULL == pcbResultRows)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppResultRows = NULL;

    if (!m_fOpenConnection)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "No Connection");
    }

    DBGPRINT((
	DBG_SS_CERTVIEWI,
	"%hs: ielt=%d cskip=%d celt=%d\n",
	m_fServerOpenView? "EnumView" : "OpenView",
	m_fServerOpenView? m_ielt : 1,
	cskip,
	celt));

    ctbResultRows.pb = NULL;
    ctbResultRows.cb = 0;
    hr = S_OK;
    if (!m_fServerOpenView)
    {
	if (m_cColumnResultMax != m_cColumnResult)
	{
	    hr = E_UNEXPECTED;
	    _JumpError(hr, error, "Missing Result Columns");
	}

	m_ielt = 1;

	__try
	{
	    hr = m_pICertAdminD->OpenView(
				    m_pwszAuthority,
				    m_cRestriction,
				    m_aRestriction,
				    m_cColumnResultMax,
				    m_aDBColumnResult,
				    m_ielt + cskip,
				    celt,
				    pceltFetched,
				    &ctbResultRows);
	    m_fServerOpenView = TRUE;
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	if (S_FALSE != hr)
	{
	    _JumpIfError(hr, error, "OpenView");
	}
    }
    else
    {
	__try
	{
	    hr = m_pICertAdminD->EnumView(
				    m_pwszAuthority,
				    m_ielt + cskip,
				    celt,
				    pceltFetched,
				    &ctbResultRows);
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	if (S_FALSE != hr)
	{
	    _JumpIfError(hr, error, "EnumView");
	}
    }
    myRegisterMemAlloc(ctbResultRows.pb, ctbResultRows.cb, CSM_MIDLUSERALLOC);

    DBGPRINT((
	DBG_SS_CERTVIEWI,
	"%hs: *pceltFetched=%d -> %d  @ielt=%d -> %d\n",
	m_fServerOpenView? "EnumView" : "OpenView",
	celt,
	*pceltFetched,
	m_ielt + cskip,
	m_ielt + cskip + *pceltFetched));

    m_ielt += cskip + *pceltFetched;
    *pieltNext = m_ielt;

    DBGPRINT((
	DBG_SS_CERTVIEWI,
	"EnumView: celtFetched=%d ieltNext=%d cb=%d hr=%x\n",
	*pceltFetched,
	*pieltNext,
	ctbResultRows.cb,
	hr));

    *pcbResultRows = ctbResultRows.cb;
    *ppResultRows = (CERTTRANSDBRESULTROW const *) ctbResultRows.pb;

error:
    return(hr);
}


HRESULT
CCertView::EnumAttributesOrExtensions(
    IN DWORD RowId,
    IN DWORD Flags,
    OPTIONAL IN WCHAR const *pwszLast,
    IN DWORD celt,
    OUT DWORD *pceltFetched,
    CERTTRANSBLOB *pctbOut)
{
    HRESULT hr;

    if (NULL == pceltFetched || NULL == pctbOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (!m_fOpenConnection)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "No Connection");
    }
    hr = S_OK;
    __try
    {
	hr = m_pICertAdminD->EnumAttributesOrExtensions(
						    m_pwszAuthority,
						    RowId,
						    Flags,
						    pwszLast,
						    celt,
						    pceltFetched,
						    pctbOut);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    if (S_FALSE != hr)
    {
	_JumpIfError(hr, error, "EnumAttributesOrExtensions");
    }
    myRegisterMemAlloc(pctbOut->pb, pctbOut->cb, CSM_MIDLUSERALLOC);

error:
    return(hr);
}


HRESULT
CCertView::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTVIEW,
			    &IID_ICertView);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certweb\certsbrt.inc ===
﻿<%' CODEPAGE=65001 'UTF-8%>
<%' certsbrt.asp - (CERT)srv web - (S)cript: determine (BR)owser (T)ype
  ' Copyright (C) Microsoft Corporation, 1998 - 1999

' first, make sure we have the right URL to prevent cookie problems.
	If "/certsrv" <> Left(Request.ServerVariables("URL"), 8) Then
		If 0<>Len(Request.ServerVariables("QUERY_STRING")) Then
			Response.Redirect "/certsrv" & Mid(Request.ServerVariables("URL"), 9) & "?" & Request.ServerVariables("QUERY_STRING")
		Else
			Response.Redirect "/certsrv" & Mid(Request.ServerVariables("URL"), 9)
		End If
		Response.End
	End If

' We know of three browser types
' sBrowser =
'  "IE"   - IE (use XEnroll)                - javascript available - DHTML available
'  "NN"   - Netscape Navigator (use Keygen) - javascript available - no DHTML
'  "Text" - Lynx or other minimal browser   - no javascript        - no DHTML

' Also, we have a flag we can set when we see an old version of IE.
' bRecommendUpgrade =
'  True  - old version of IE
'  False - other unsupported browser
' bNewThanNT4, boolean to determine browser client platform os version

	Dim sBrowser, bRecommendUpgrade, bNewThanNT4
	bNewThanNT4 = False
	sBrowser=Request.ServerVariables("HTTP_USER_AGENT")
	If 0=InStr(sBrowser, "Mozilla") Then
		'Lynx or other minimal browser
		sBrowser="Text"
		bRecommendUpgrade=False
	ElseIf 0=InStr(sBrowser, "MSIE") Then
		'Netscape Navigator
		sBrowser="NN"
		bRecommendUpgrade=False
	ElseIf CInt(Mid(sBrowser, InStr(sBrowser, "MSIE")+5, 1))<4 Then
		'Too Old Internet Explorer
		sBrowser="Text"
		bRecommendUpgrade=True
	ElseIf 0=InStr(sBrowser, "Win") Or (0=InStr(sBrowser, "95") _
			And 0=InStr(sBrowser, "98") And 0=InStr(sBrowser, "2000") _
			And 0=InStr(sBrowser, "NT")) Then
		'unsupported platform Internet Explorer (eg, Mac, Unix, Win16)
		sBrowser="Text"
		bRecommendUpgrade=False
	ElseIf "Alpha"=Request.ServerVariables("HTTP_UA_CPU") Then
		'NT4 IE4 Alpha, we are no longer building XEnroll for this platform
		sBrowser="Text"
		bRecommendUpgrade=False
	Else
		If 0 <> InStr(sBrowser, "Windows NT 5") Then
			bNewThanNT4 = True
		End If
		'New Internet Explorer
		sBrowser="IE"
		bRecommendUpgrade=False
	End If

	Const L_LabelColWidth_Number=100 ' the standard label-column width in pixels
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\default\atl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       atl.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp: source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certwrap\certwrap.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certwrap.cpp
//
//  Contents:   Wrap a command line and expand envronment variables.
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdlib.h>

#include "resource.h"


#define WM_WRAPCOMMAND		WM_USER+0

WCHAR wszAppName[] = L"CertWrap";
HINSTANCE hInstApp;


#define ARRAYLEN(a)	(sizeof(a)/sizeof((a)[0]))

VOID
WrapCommand(
    HWND hWnd,
    WCHAR const *pwszCommand)
{
    WCHAR awc[4096];
    WCHAR awcVar[128];
    WCHAR const *pwszSrc;
    WCHAR *pwszDst;
    WCHAR *pwszVar;
    BOOL fTooLong = FALSE;
    BOOL fVarTooLong = FALSE;
    BOOL fVarNotFound = FALSE;
    DWORD cwc;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    BOOL b;

    pwszSrc = pwszCommand;
    pwszDst = awc;
    while (L'\0' != (*pwszDst = *pwszSrc++))
    {
	if ('%' == *pwszDst)
	{
	    *pwszDst = L'\0';
	    pwszVar = awcVar;

	    while (L'\0' != *pwszSrc)
	    {
		if (L'%' == *pwszSrc)
		{
		    pwszSrc++;
		    break;
		}
		*pwszVar++ = *pwszSrc++;
		if (pwszVar >= &awcVar[ARRAYLEN(awcVar) - 1])
		{
		    fVarTooLong = TRUE;
		    goto error;
		}
	    }
	    *pwszVar = L'\0';

	    cwc = GetEnvironmentVariable(
		    awcVar,
		    pwszDst,
		    (DWORD) (ULONG_PTR) (&awcVar[ARRAYLEN(awcVar)] - pwszDst));
	    if (0 == cwc)
	    {
		fVarNotFound = TRUE;
		goto error;
	    }
	    if ((DWORD) (ULONG_PTR) (&awcVar[ARRAYLEN(awcVar)] - pwszDst) <= cwc)
	    {
		fTooLong = TRUE;
		goto error;
	    }
	    pwszDst += cwc;
	}
	else
	{
	    pwszDst++;
	}
	if (pwszDst >= &awc[ARRAYLEN(awc)])
	{
	    fTooLong = TRUE;
	    goto error;
	}
    }

error:
    if (fVarNotFound)
    {
	MessageBox(
		hWnd,
		L"Environment Variable Not Found",
		awcVar,
		MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
    }
    if (fVarTooLong)
    {
	MessageBox(
		hWnd,
		L"Environment Variable Name Too Long",
		L"CertWrapper",
		MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
    }
    if (fTooLong)
    {
	MessageBox(
		hWnd,
		L"Command Line Too Long",
		L"CertWrapper",
		MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
    }
    MessageBox(hWnd, awc, L"CertWrapper", MB_OK);

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOW;

    b = CreateProcess(
		NULL,
		awc,
		NULL,
		NULL,
		FALSE,
		0,
		NULL,
		NULL,	// lpCurrentDirectory
		&si,
		&pi);
    if (!b)
    {
	DWORD err;
	WCHAR awcErr[MAX_PATH];

	err = GetLastError();
	wsprintf(awcErr, L"CreateProcess failed: %d(%x)", err, err);
	MessageBox(
		hWnd,
		awcErr,
		L"CertWrapper",
		MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
    }
}


//**************************************************************************
// FUNCTION:	MainWndProc(...)
// ARGUMENTS:
//**************************************************************************

LRESULT APIENTRY
MainWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_CREATE:
	    return(0);

        case WM_SIZE:
	    return(0);

        case WM_DESTROY:
	    PostQuitMessage(0);
	    break;

        case WM_WRAPCOMMAND:
	    WrapCommand(hWnd, (WCHAR const *) lParam);
	    PostQuitMessage(0);
	    break;

        default:
	    return(DefWindowProc(hWnd, msg, wParam, lParam));
    }
    return(0);
}


//+------------------------------------------------------------------------
//
//  Function:	WinMain()
//
//  Synopsis:	Entry Point
//
//  Arguments:	[hInstance]	--	Instance handle
//		[hPrevInstance] --	Obsolete
//		[lpCmdLine]	--	App command line
//		[nCmdShow]	--	Starting show state
//-------------------------------------------------------------------------

extern "C" int APIENTRY
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR pwszCmdLine,
    int nCmdShow)
{
    MSG msg;
    WNDCLASS wcApp;
    HWND hWndMain;

    // Save the current instance
    hInstApp = hInstance;

    // Set up the application's window class
    wcApp.style 	= 0;
    wcApp.lpfnWndProc 	= MainWndProc;
    wcApp.cbClsExtra	= 0;
    wcApp.cbWndExtra	= 0;
    wcApp.hInstance	= hInstance;
    wcApp.hIcon		= LoadIcon(NULL, IDI_APPLICATION);
    wcApp.hCursor	= LoadCursor(NULL, IDC_ARROW);
    wcApp.hbrBackground	= (HBRUSH) GetStockObject(WHITE_BRUSH);
    wcApp.lpszMenuName	= NULL;
    wcApp.lpszClassName	= wszAppName;
    if (!RegisterClass(&wcApp))
    {
	return(FALSE);
    }

    // Create Main Window
    hWndMain = CreateWindow(wszAppName,
			    L"CertWrapper Application",
			    WS_OVERLAPPEDWINDOW,
			    CW_USEDEFAULT, CW_USEDEFAULT,
			    CW_USEDEFAULT, CW_USEDEFAULT,
			    NULL,
			    NULL,
			    hInstance,
			    NULL);

    if (NULL == hWndMain)
    {
	return(FALSE);
    }

    // Make window visible
    // ShowWindow(hWndMain,nCmdShow);

    // Update window client area
    UpdateWindow(hWndMain);

    // Send off the message to get things started
    PostMessage(hWndMain, WM_WRAPCOMMAND, 0, (LPARAM) pwszCmdLine);

    // Message Loop
    while (GetMessage(&msg, NULL, 0, 0))
    {
	TranslateMessage(&msg);
	DispatchMessage(&msg);
    }
    return (int)(msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\default\certxds.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certxds.cpp
//
// Contents:    Cert Server Exit Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "exit.h"
#include "module.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertExit, CCertExit)
    OBJECT_ENTRY(CLSID_CCertManageExitModule, CCertManageExitModule)
END_OBJECT_MAP()

HINSTANCE g_hInstance = NULL;


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        _Module.Init(ObjectMap, hInstance);
        g_hInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);
        break;
        
    case DLL_PROCESS_DETACH:
        _Module.Term();
        break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;
    
    hr = _Module.GetClassObject(rclsid, riid, ppv);
    if (S_OK == hr && NULL != *ppv)
    {
	myRegisterMemFree(*ppv, CSM_NEW | CSM_GLOBALDESTRUCTOR);
    }
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certwrap\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//

#define IDI_APP                         201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\default\exit.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.cpp
//
// Contents:    CCertExit implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <ntdsapi.h>
#include <lm.h>
#include <security.h>
#include <dsgetdc.h>
#include <userenv.h>

#include "cainfop.h"
#include "csdisp.h"

#include "cspelog.h"
#include "exitlog.h"
#include "exit.h"

#include "cdosys_i.c"
#include "cdosysstr.h"
#include "cdosys.h"
#include <atlbase.h>
#include <atlimpl.cpp>

#define __dwFILE__	__dwFILE_EXIT_DEFAULT_EXIT_CPP__

// begin_sdksample

#ifndef DBG_CERTSRV
#error -- DBG_CERTSRV not defined!
#endif

#define myEXITEVENTS \
	EXITEVENT_CERTISSUED | \
	EXITEVENT_CERTPENDING | \
	EXITEVENT_CERTDENIED | \
	EXITEVENT_CERTREVOKED | \
	EXITEVENT_CERTRETRIEVEPENDING | \
	EXITEVENT_CRLISSUED | \
	EXITEVENT_SHUTDOWN

extern HINSTANCE g_hInstance;


HRESULT
GetServerCallbackInterface(
    OUT ICertServerExit** ppServer,
    IN LONG Context)
{
    HRESULT hr;

    if (NULL == ppServer)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "Exit:NULL pointer");
    }

    hr = CoCreateInstance(
                    CLSID_CCertServerExit,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
                    IID_ICertServerExit,
                    (VOID **) ppServer);
    _JumpIfError(hr, error, "Exit:CoCreateInstance");

    if (*ppServer == NULL)
    {
        hr = E_UNEXPECTED;
	_JumpError(hr, error, "Exit:NULL *ppServer");
    }

    // only set context if nonzero
    if (0 != Context)
    {
        hr = (*ppServer)->SetContext(Context);
        _JumpIfError(hr, error, "Exit: SetContext");
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExit::~CCertExit -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertExit::~CCertExit()
{
    if (NULL != m_strCAName)
    {
        SysFreeString(m_strCAName);
    }
    if (NULL != m_pwszRegStorageLoc)
    {
        LocalFree(m_pwszRegStorageLoc);
    }
    if (NULL != m_hExitKey)
    {
        RegCloseKey(m_hExitKey);
    }
    if (NULL != m_strDescription)
    {
        SysFreeString(m_strDescription);
    }
}


//+--------------------------------------------------------------------------
// CCertExit::Initialize -- initialize for a CA & return interesting Event Mask
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExit::Initialize(
    /* [in] */ BSTR const strConfig,
    /* [retval][out] */ LONG __RPC_FAR *pEventMask)
{
    HRESULT hr = S_OK;
    DWORD       cbbuf;
    DWORD       dwType;
    ENUM_CATYPES CAType;
    ICertServerExit* pServer = NULL;
    VARIANT varValue;
    WCHAR sz[MAX_PATH];

    VariantInit(&varValue);

#ifdef IDS_MODULE_NAME					// no_sdksample
    if (!LoadString(g_hInstance, IDS_MODULE_NAME, sz, ARRAYSIZE(sz))) // no_sdksample
    {							// no_sdksample
	sz[0] = L'\0';					// no_sdksample
    }							// no_sdksample
#else							// no_sdksample
    CSASSERT(wcslen(wsz_SAMPLE_DESCRIPTION) < ARRAYSIZE(sz));
    wcsncpy(sz, wsz_SAMPLE_DESCRIPTION, ARRAYSIZE(sz));
    sz[ARRAYSIZE(sz) - 1] = L'\0';
#endif							// no_sdksample

    m_strDescription = SysAllocString(sz);
    if (NULL == m_strDescription)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Exit:SysAllocString");
    }

    m_strCAName = SysAllocString(strConfig);
    if (NULL == m_strCAName)
    {
    	hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Exit:SysAllocString");
    }

    *pEventMask = myEXITEVENTS;
    DBGPRINT((DBG_SS_CERTEXIT, "Exit:Initialize(%ws) ==> %x\n", m_strCAName, *pEventMask));

    // get server callbacks

    hr = GetServerCallbackInterface(&pServer, 0);
    _JumpIfError(hr, error, "Exit:GetServerCallbackInterface");

    // get storage location

    hr = exitGetProperty(
		    pServer,
		    FALSE,	// fRequest
		    wszPROPMODULEREGLOC,
		    PROPTYPE_STRING,
		    &varValue);
    _JumpIfErrorStr(hr, error, "Exit:exitGetProperty", wszPROPMODULEREGLOC);
    
    m_pwszRegStorageLoc = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(varValue.bstrVal)+1) *sizeof(WCHAR));
    if (NULL == m_pwszRegStorageLoc)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Exit:LocalAlloc");
    }
    wcscpy(m_pwszRegStorageLoc, varValue.bstrVal);
    VariantClear(&varValue);

    // get CA type
    hr = exitGetProperty(
		    pServer,
		    FALSE,	// fRequest
		    wszPROPCATYPE,
		    PROPTYPE_LONG,
		    &varValue);
    _JumpIfErrorStr(hr, error, "Exit:exitGetProperty", wszPROPCATYPE);

    CAType = (ENUM_CATYPES) varValue.lVal;
    VariantClear(&varValue);

    hr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                m_pwszRegStorageLoc,
                0,              // dwReserved
                KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE,
                &m_hExitKey);

    if (S_OK != hr)
    {
        if ((HRESULT) ERROR_FILE_NOT_FOUND == hr)
        {
            hr = S_OK;
            goto error;
        }
        _JumpError(hr, error, "Exit:RegOpenKeyEx");
    }

    hr = exitGetProperty(
		    pServer,
		    FALSE,	// fRequest
		    wszPROPCERTCOUNT,
		    PROPTYPE_LONG,
		    &varValue);
    _JumpIfErrorStr(hr, error, "Exit:exitGetProperty", wszPROPCERTCOUNT);

    m_cCACert = varValue.lVal;

    cbbuf = sizeof(m_dwExitPublishFlags);
    hr = RegQueryValueEx(
		    m_hExitKey,
		    wszREGCERTPUBLISHFLAGS,
		    NULL,           // lpdwReserved
		    &dwType,
		    (BYTE *) &m_dwExitPublishFlags,
		    &cbbuf);
    if (S_OK != hr)
    {
        m_dwExitPublishFlags = 0;
    }

    // end_sdksample
    if (FIsAdvancedServer()) 
    {
	hr = m_EmailNotifyObj.Init(m_hExitKey, m_strDescription);
	_PrintIfError(hr, "CEmailNotify::Init");
    }
    // begin_sdksample

    hr = S_OK;

error:
    VariantClear(&varValue);
    if (NULL != pServer)
    {
        pServer->Release();
    }
    return(myHError(hr));
}


//+--------------------------------------------------------------------------
// CCertExit::_ExpandEnvironmentVariables -- Expand environment variables
//
//+--------------------------------------------------------------------------

HRESULT
CCertExit::_ExpandEnvironmentVariables(
    IN WCHAR const *pwszIn,
    OUT WCHAR *pwszOut,
    IN DWORD cwcOut)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    WCHAR awcVar[MAX_PATH];
    WCHAR const *pwszSrc;
    WCHAR *pwszDst;
    WCHAR *pwszDstEnd;
    WCHAR *pwszVar;
    DWORD cwc;

    pwszSrc = pwszIn;
    pwszDst = pwszOut;
    pwszDstEnd = &pwszOut[cwcOut];

    while (L'\0' != (*pwszDst = *pwszSrc++))
    {
	if ('%' == *pwszDst)
	{
	    *pwszDst = L'\0';
	    pwszVar = awcVar;

	    while (L'\0' != *pwszSrc)
	    {
		if ('%' == *pwszSrc)
		{
		    pwszSrc++;
		    break;
		}
		*pwszVar++ = *pwszSrc++;
		if (pwszVar >= &awcVar[sizeof(awcVar)/sizeof(awcVar[0]) - 1])
		{
		    _JumpError(hr, error, "Exit:overflow 1");
		}
	    }
	    *pwszVar = L'\0';
	    cwc = GetEnvironmentVariable(awcVar, pwszDst, SAFE_SUBTRACT_POINTERS(pwszDstEnd, pwszDst));
	    if (0 == cwc)
	    {
		hr = myHLastError();
		_JumpError(hr, error, "Exit:GetEnvironmentVariable");
	    }
	    if ((DWORD) (pwszDstEnd - pwszDst) <= cwc)
	    {
		_JumpError(hr, error, "Exit:overflow 2");
	    }
	    pwszDst += cwc;
	}
	else
	{
	    pwszDst++;
	}
	if (pwszDst >= pwszDstEnd)
	{
	    _JumpError(hr, error, "Exit:overflow 3");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
exitGetRequestAttribute(
    IN ICertServerExit *pServer,
    IN WCHAR const *pwszAttributeName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    BSTR strName = NULL;

    *pstrOut = NULL;
    strName = SysAllocString(pwszAttributeName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Exit:SysAllocString");
    }
    hr = pServer->GetRequestAttribute(strName, pstrOut);
    _JumpIfErrorStr2(
		hr,
		error,
		"Exit:GetRequestAttribute",
		pwszAttributeName,
		CERTSRV_E_PROPERTY_EMPTY);

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExit::_WriteCertToFile -- write binary certificate to a file
//
//+--------------------------------------------------------------------------

HRESULT
CCertExit::_WriteCertToFile(
    IN ICertServerExit *pServer,
    IN BYTE const *pbCert,
    IN DWORD cbCert)
{
    HRESULT hr;
    BSTR strCertFile = NULL;
    DWORD cbWritten;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WCHAR wszDir[MAX_PATH];
    WCHAR *pwszPath = NULL;
    WCHAR wszFile[cwcDWORDSPRINTF+5]; //format "requestid.cer"
    VARIANT varRequestID;

    VariantInit(&varRequestID);

    // Old functionality asked requester to pass in a CertFile attribute with
    // the output request file name. After the security review we decided
    // to not allow file name from user but to build it at server. Still, we 
    // don't want to start publishing all certificates, so we'll maintain the
    // CertFile property; if present, we'll just ignore its content, if not 
    // present we won't publish.
    hr = exitGetRequestAttribute(pServer, wszPROPEXITCERTFILE, &strCertFile);
    if (S_OK != hr)
    {
	DBGPRINT((
	    DBG_SS_CERTEXIT,
	    "Exit:exitGetRequestAttribute(%ws): %x%hs\n",
	    wszPROPEXITCERTFILE,
	    hr,
	    CERTSRV_E_PROPERTY_EMPTY == hr? " EMPTY VALUE" : ""));
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	}
	goto error;
    }

    // build file name as "requestid.cer"

    hr = exitGetProperty(
        pServer,
        TRUE,  // fRequest,
        wszPROPREQUESTREQUESTID,
        PROPTYPE_LONG,
        &varRequestID);
    _JumpIfErrorStr(hr, error, "Exit:exitGetProperty", wszPROPREQUESTREQUESTID);

    wsprintf(wszFile, L"%d.cer", V_I4(&varRequestID));
    
    hr = _ExpandEnvironmentVariables(
		    L"%SystemRoot%\\System32\\" wszCERTENROLLSHAREPATH L"\\",
		    wszDir,
		    ARRAYSIZE(wszDir));
    _JumpIfError(hr, error, "_ExpandEnvironmentVariables");

    hr = myBuildPathAndExt(wszDir, wszFile, NULL, &pwszPath);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    // open file & write binary cert out.

    hFile = CreateFile(
		    pwszPath,
		    GENERIC_WRITE,
		    0,			// dwShareMode
		    NULL,		// lpSecurityAttributes
		    CREATE_NEW,
		    FILE_ATTRIBUTE_NORMAL,
		    NULL);		// hTemplateFile
    if (INVALID_HANDLE_VALUE == hFile)
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "Exit:CreateFile", pwszPath);
    }
    if (!WriteFile(hFile, pbCert, cbCert, &cbWritten, NULL))
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "Exit:WriteFile", pwszPath);
    }
    if (cbWritten != cbCert)
    {
	hr = STG_E_WRITEFAULT;
	DBGPRINT((
	    DBG_SS_CERTEXIT,
	    "Exit:WriteFile(%ws): attempted %x, actual %x bytes: %x\n",
	    pwszPath,
	    cbCert,
	    cbWritten,
	    hr));
	goto error;
    }

error:
    // end_sdksample

    VariantClear(&varRequestID);

    if (hr != S_OK)
    {
        LPCWSTR wszStrings[1];

        wszStrings[0] = pwszPath;

        ::LogModuleStatus(
		    g_hInstance,
		    hr,
		    MSG_UNABLE_TO_WRITEFILE,
		    FALSE,		// fPolicy
		    m_strDescription,
		    wszStrings,
		    NULL);
    }

    // begin_sdksample

    if (INVALID_HANDLE_VALUE != hFile)
    {
	CloseHandle(hFile);
    }
    if (NULL != pwszPath)
    {
	LocalFree(pwszPath);
    }
    if (NULL != strCertFile)
    {
	SysFreeString(strCertFile);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExit::_NotifyNewCert -- Notify the exit module of a new certificate
//
//+--------------------------------------------------------------------------

HRESULT
CCertExit::_NotifyNewCert(
    /* [in] */ LONG Context)
{
    HRESULT hr;
    VARIANT varCert;
    ICertServerExit *pServer = NULL;

    VariantInit(&varCert);

    // only call write fxns if server policy allows

    if (m_dwExitPublishFlags & EXITPUB_FILE)
    {
        hr = CoCreateInstance(
		        CLSID_CCertServerExit,
		        NULL,               // pUnkOuter
		        CLSCTX_INPROC_SERVER,
		        IID_ICertServerExit,
		        (VOID **) &pServer);
        _JumpIfError(hr, error, "Exit:CoCreateInstance");

        hr = pServer->SetContext(Context);
        _JumpIfError(hr, error, "Exit:SetContext");

        hr = exitGetProperty(
		        pServer,
		        FALSE,	// fRequest,
		        wszPROPRAWCERTIFICATE,
		        PROPTYPE_BINARY,
		        &varCert);
        _JumpIfErrorStr(
		    hr,
		    error,
		    "Exit:exitGetProperty",
		    wszPROPRAWCERTIFICATE);

        if (VT_BSTR != varCert.vt)
        {
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "Exit:BAD cert var type");
        }

	hr = _WriteCertToFile(
			pServer,
			(BYTE const *) varCert.bstrVal,
			SysStringByteLen(varCert.bstrVal));
	_JumpIfError(hr, error, "_WriteCertToFile");
    }

    hr = S_OK;

error:
    VariantClear(&varCert);
    if (NULL != pServer)
    {
	pServer->Release();
    }
    return(hr);
}

//+--------------------------------------------------------------------------
// CCertExit::_NotifyCRLIssued -- Notify the exit module of a new certificate
//
//+--------------------------------------------------------------------------

HRESULT
CCertExit::_NotifyCRLIssued(
    /* [in] */ LONG Context)
{
    HRESULT hr;
    ICertServerExit *pServer = NULL;
    DWORD i;
    VARIANT varBaseCRL;
    VARIANT varDeltaCRL;
    BOOL fDeltaCRLsDisabled;

    VariantInit(&varBaseCRL);
    VariantInit(&varDeltaCRL);

    hr = CoCreateInstance(
		    CLSID_CCertServerExit,
		    NULL,               // pUnkOuter
		    CLSCTX_INPROC_SERVER,
		    IID_ICertServerExit,
		    (VOID **) &pServer);
    _JumpIfError(hr, error, "Exit:CoCreateInstance");

    hr = pServer->SetContext(Context);
    _JumpIfError(hr, error, "Exit:SetContext");


    hr = exitGetProperty(
		    pServer,
		    FALSE,	// fRequest,
		    wszPROPDELTACRLSDISABLED,
		    PROPTYPE_LONG,
		    &varBaseCRL);
    _JumpIfErrorStr(
		hr,
		error,
		"Exit:exitGetProperty",
		wszPROPDELTACRLSDISABLED);

    fDeltaCRLsDisabled = varBaseCRL.lVal;

    // How many CRLs are there?

    // Loop for each CRL
    for (i = 0; i < m_cCACert; i++)
    {
        // array size for wsprintf("%s.%u")
        #define MAX_CRL_PROP ( \
            max( max( ARRAYSIZE(wszPROPCRLSTATE), \
                      ARRAYSIZE(wszPROPRAWCRL) ), \
                 ARRAYSIZE(wszPROPRAWDELTACRL) ) + 1 + cwcDWORDSPRINTF)

        WCHAR wszCRLPROP[MAX_CRL_PROP];

        // Verify the CRL State says we should update this CRL

        wsprintf(wszCRLPROP, wszPROPCRLSTATE L".%u", i);
        hr = exitGetProperty(
			pServer,
			FALSE,	// fRequest,
			wszCRLPROP,
			PROPTYPE_LONG,
			&varBaseCRL);
        _JumpIfErrorStr(hr, error, "Exit:exitGetProperty", wszCRLPROP);

	if (CA_DISP_VALID != varBaseCRL.lVal)
	{
	    continue;
	}

        // Grab the raw base CRL

        wsprintf(wszCRLPROP, wszPROPRAWCRL L".%u", i);
        hr = exitGetProperty(
			pServer,
			FALSE,	// fRequest,
			wszCRLPROP,
			PROPTYPE_BINARY,
			&varBaseCRL);
        _JumpIfErrorStr(hr, error, "Exit:exitGetProperty", wszCRLPROP);

        // Grab the raw delta CRL (which may not exist)

        wsprintf(wszCRLPROP, wszPROPRAWDELTACRL L".%u", i);
        hr = exitGetProperty(
			pServer,
			FALSE,	// fRequest,
			wszCRLPROP,
			PROPTYPE_BINARY,
			&varDeltaCRL);
        _PrintIfErrorStr2(
		    hr,
		    "Exit:exitGetProperty",
		    wszCRLPROP,
		    fDeltaCRLsDisabled? 
			HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) : S_OK);
	if (S_OK != hr && !fDeltaCRLsDisabled)
	{
	    goto error;
	}

        // Publish the CRL(s) ...
    }

    hr = S_OK;

error:
    if (NULL != pServer)
    {
	pServer->Release();
    }
    VariantClear(&varBaseCRL);
    VariantClear(&varDeltaCRL);
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExit::Notify -- Notify the exit module of an event
//
// Returns S_OK.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExit::Notify(
    /* [in] */ LONG ExitEvent,
    /* [in] */ LONG Context)
{
    char *psz = "UNKNOWN EVENT";
    HRESULT hr = S_OK;

    switch (ExitEvent)
    {
	case EXITEVENT_CERTISSUED:
	    hr = _NotifyNewCert(Context);
	    psz = "certissued";
	    break;

	case EXITEVENT_CERTPENDING:
	    psz = "certpending";
	    break;

	case EXITEVENT_CERTDENIED:
	    psz = "certdenied";
	    break;

	case EXITEVENT_CERTREVOKED:
	    psz = "certrevoked";
	    break;

	case EXITEVENT_CERTRETRIEVEPENDING:
	    psz = "retrievepending";
	    break;

	case EXITEVENT_CRLISSUED:
#if 0 // no_sdksample
	    hr = _NotifyCRLIssued(Context);
#endif // no_sdksample
	    psz = "crlissued";
	    break;

	case EXITEVENT_SHUTDOWN:
	    psz = "shutdown";
	    break;
    }

    // end_sdksample
    {
	HRESULT hr2 = m_EmailNotifyObj.Notify(
					ExitEvent,
					Context,
					m_strDescription);
	if(S_OK != hr2)
	{
	    _PrintError(hr2, "Email notification");
	    if(S_OK == hr)
	        hr = hr2;
	}
    }
    // begin_sdksample

    DBGPRINT((
	DBG_SS_CERTEXIT,
	"Exit:Notify(%hs=%x, ctx=%x) rc=%x\n",
	psz,
	ExitEvent,
	Context,
	hr));
    return(hr);
}


STDMETHODIMP
CCertExit::GetDescription(
    /* [retval][out] */ BSTR *pstrDescription)
{
    HRESULT hr = S_OK;
    WCHAR sz[MAX_PATH];

#ifdef IDS_MODULE_NAME						// no_sdksample
    LoadString(g_hInstance, IDS_MODULE_NAME, sz, ARRAYSIZE(sz));// no_sdksample
#else								// no_sdksample
    CSASSERT(wcslen(wsz_SAMPLE_DESCRIPTION) < ARRAYSIZE(sz));
    wcscpy(sz, wsz_SAMPLE_DESCRIPTION);
#endif								// no_sdksample

    *pstrDescription = SysAllocString(sz);
    if (NULL == *pstrDescription)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Exit:SysAllocString");
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExit::GetManageModule
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExit::GetManageModule(
    /* [out, retval] */ ICertManageModule **ppManageModule)
{
    HRESULT hr;
    
    *ppManageModule = NULL;
    hr = CoCreateInstance(
            CLSID_CCertManageExitModule,
            NULL,               // pUnkOuter
            CLSCTX_INPROC_SERVER,
            IID_ICertManageModule,
            (VOID **) ppManageModule);
    _JumpIfError(hr, error, "CoCreateInstance");

error:
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP
CCertExit::InterfaceSupportsErrorInfo(REFIID riid)
{
    int i;
    static const IID *arr[] =
    {
	&IID_ICertExit,
    };

    for (i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (IsEqualGUID(*arr[i],riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}


HRESULT
exitGetProperty(
    IN ICertServerExit *pServer,
    IN BOOL fRequest,
    IN WCHAR const *pwszPropertyName,
    IN DWORD PropType,
    OUT VARIANT *pvarOut)
{
    HRESULT hr;
    BSTR strName = NULL;

    VariantInit(pvarOut);
    strName = SysAllocString(pwszPropertyName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Exit:SysAllocString");
    }
    if (fRequest)
    {
	hr = pServer->GetRequestProperty(strName, PropType, pvarOut);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "Exit:GetRequestProperty",
		    pwszPropertyName,
		    CERTSRV_E_PROPERTY_EMPTY);
    }
    else
    {
	hr = pServer->GetCertificateProperty(strName, PropType, pvarOut);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "Exit:GetCertificateProperty",
		    pwszPropertyName,
		    CERTSRV_E_PROPERTY_EMPTY);
    }

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}

// end_sdksample


/////////////////////////////////////////////////////////////////////////////
HRESULT
exitGetStringProperty(
    IN ICertServerExit *pServer,
    IN BOOL fRequest,
    IN BOOL fAllowUnknown,
    OPTIONAL IN WCHAR *pwszProp,
    OUT BSTR *pstr)
{
    HRESULT hr;
    VARIANT var;
    WCHAR awc[64];

    VariantInit(&var);
    CSASSERT(NULL == *pstr);
    
    if (NULL == pwszProp)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
    }
    else
    {
	hr = exitGetProperty(
			pServer,
			fRequest,
			pwszProp,
			PROPTYPE_STRING,
			&var);
    }
    if (!fAllowUnknown || CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpIfErrorStr(hr, error, "Exit:GetProperty", pwszProp);

	if (VT_BSTR != var.vt)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpErrorStr(hr, error, "Exit:BAD var type", pwszProp);
	}
	*pstr = var.bstrVal;
	var.vt = VT_EMPTY;
    }
    else
    {
	if (!LoadString(g_hInstance, IDS_MAPI_UNKNOWN, awc, ARRAYSIZE(awc)))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "Exit:LoadString");
	}
	*pstr = SysAllocString(awc);
	if (NULL == *pstr)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Exit:SysAllocString");
	}
    }
    hr = S_OK;

error:
    VariantClear(&var);
    return(hr);
}


HRESULT
LoadAnsiResourceString(
    IN LONG idmsg,
    OUT char **ppszString)
{
    HRESULT hr;
    WCHAR awc[4096];

    if (!LoadString(g_hInstance, idmsg, awc, ARRAYSIZE(awc)))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Exit:LoadString");
    }
    if (!ConvertWszToSz(ppszString, awc, MAXDWORD))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Exit:ConvertWszToSz");
    }
    hr = S_OK;

error:
    return(hr);
}

/////////////////////////////////////////////////////////////////////////////
HRESULT RegGetValue(
    HKEY hkey,
    LPCWSTR pcwszValName,
    VARIANT* pvarValue)
{
    HRESULT hr;
    DWORD dwType;
    DWORD cbVal;
    BYTE* pbVal = NULL;

    hr = myRegQueryValueEx(
        hkey,
        pcwszValName,
        &dwType,
        &pbVal,
        &cbVal);
    _JumpIfError2(hr, error, "myRegQueryValueEx", 
        HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    hr = myRegValueToVariant(
        dwType,
        cbVal,
        pbVal,
        pvarValue);
    _JumpIfError(hr, error, "myRegValueToVariant");

error:
    if(pbVal)
    {
        LocalFree(pbVal);
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT RegSetValue(
    HKEY hkey,
    LPCWSTR pcwszValName,
    VARIANT* pvarValue)
{
    HRESULT hr;
    DWORD dwType;
    DWORD cbVal;
    BYTE* pbVal = NULL;

    hr = myVariantToRegValue(
        pvarValue,
        &dwType,
        &cbVal,
        &pbVal);
    _JumpIfError(hr, error, "myVariantToRegValue");

    hr = RegSetValueEx(
        hkey,
        pcwszValName,
        0,
        dwType,
        pbVal,
        cbVal);
    if (S_OK != hr)
    {
        hr = myHError(hr);
        _JumpErrorStr(hr, error, "RegSetValueEx", pcwszValName);
    }

error:
    if(pbVal)
    {
        LocalFree(pbVal);
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT
GetCertTypeFriendlyName(
    IN LPCWSTR pcwszCertType,
    OUT LPWSTR *ppwszFriendlyName)
{
    HRESULT hr;
    CAutoHCERTTYPE hCertType;
    WCHAR **apwszNames = NULL;

    hr = CAFindCertTypeByName(
            pcwszCertType,
            NULL,		// hCAInfo
            CT_FIND_LOCAL_SYSTEM |
            CT_ENUM_MACHINE_TYPES |
            CT_ENUM_USER_TYPES,		// dwFlags
            &hCertType);
    if(HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
    {
        // try with the OID

        hr = CAFindCertTypeByName(
            pcwszCertType,
            NULL,
            CT_FIND_LOCAL_SYSTEM |
            CT_ENUM_MACHINE_TYPES |
            CT_ENUM_USER_TYPES |
            CT_FIND_BY_OID,
            &hCertType);
    }
    _JumpIfErrorStr(hr, error, "Exit:CAFindCertTypeByName", pcwszCertType);

    hr = CAGetCertTypeProperty(
            hCertType,
            CERTTYPE_PROP_FRIENDLY_NAME,
            &apwszNames);
    _JumpIfError(hr, error, "Exit:CAGetCertTypeProperty");

    if (NULL == apwszNames[0])
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        _JumpError(hr, error, "Exit:NULL friendly name");
    }
    *ppwszFriendlyName = (LPWSTR) LocalAlloc(LMEM_FIXED, 
        sizeof(WCHAR)*(wcslen(apwszNames[0])+1));
    _JumpIfAllocFailed(*ppwszFriendlyName, error);

    wcscpy(*ppwszFriendlyName, apwszNames[0]);

error:
    if (NULL != apwszNames)
    {
        CAFreeCertTypeProperty(hCertType, apwszNames);
    }
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// Email notification support

LPCWSTR CEmailNotify::m_pcwszEventRegKeys[CEmailNotify::m_gcEvents] = 
{
    wszREGEXITISSUEDKEY,
    wszREGEXITPENDINGKEY,
    wszREGEXITDENIEDKEY,
    wszREGEXITREVOKEDKEY,
    wszREGEXITCRLISSUEDKEY,
    wszREGEXITSHUTDOWNKEY,
    wszREGEXITSTARTUPKEY,
};

/////////////////////////////////////////////////////////////////////////////
CEmailNotify::CEmailNotify()
{
    m_hkeySMTP = NULL;
    m_dwEventFilter = 0;
    m_bstrCAMailAddress = NULL;
    m_pICDOConfig = NULL;
    m_fReloadCDOConfig = true;
    VariantInit(&m_varTemplateRestrictions);
}

/////////////////////////////////////////////////////////////////////////////
CEmailNotify::~CEmailNotify()
{
    if (m_pICDOConfig)
    {
        m_pICDOConfig->Release();
    }
    VariantClear(&m_varTemplateRestrictions);
    if(m_bstrCAMailAddress)
    {
        SysFreeString(m_bstrCAMailAddress);
    }
    if(m_hkeySMTP)
    {
        RegCloseKey(m_hkeySMTP);
    }
}

/////////////////////////////////////////////////////////////////////////////
HRESULT
CEmailNotify::Init(
    IN HKEY hkeyExit,
    IN WCHAR const *pwszDescription)
{
    HRESULT hr;
    VARIANT varValue;

    hr = RegOpenKeyEx(
                hkeyExit,
                wszREGEXITSMTPKEY,
                0,              // dwReserved
                KEY_READ | KEY_QUERY_VALUE,
                &m_hkeySMTP);
    if ((HRESULT) ERROR_FILE_NOT_FOUND == hr || S_OK == hr)
    {
        hr = _CreateSMTPRegSettings(hkeyExit);
        _JumpIfError(hr, error, "CreateSMTPRegSettings");
    }
    _JumpIfError(hr, error, "RegOpenKey(SMTP)");

    // load event filter
    hr = RegGetValue(
            m_hkeySMTP,
            wszREGEXITSMTPEVENTFILTER,
            &varValue);
    if(S_OK==hr)
    {
        m_dwEventFilter = V_I4(&varValue);
    }
    else if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
    {
        hr = S_OK;
    }
    _JumpIfErrorStr(hr, error, "RegGetValue", wszREGEXITSMTPEVENTFILTER);

    m_dwEventFilter = V_I4(&varValue);

    if(m_dwEventFilter) // no need to load config if no notification enabled
    {
        // load per event type info from each subkey
        hr = _LoadEventInfoFromRegistry();
        _JumpIfError(hr, error, "_LoadEventInfoFromRegistry");

        // load template restrictions
        hr = _LoadTemplateRestrictionsFromRegistry();
        _JumpIfError(hr, error, "CCertExit::_LoadTemplateRestrictionsFromRegistry");

        hr = _InitCDO();
        _JumpIfError(hr, error, "CEmailNotify::InitCDO");


        // send startup notification mail
        hr = Notify(EXITEVENT_STARTUP, 0, pwszDescription);
        _PrintIfError(hr, "Notify(EXITEVENT_STARTUP)");
    }

    hr = S_OK;

error:

    if (S_OK != hr && m_pICDOConfig)
    {
        m_pICDOConfig->Release();
        m_pICDOConfig = NULL;
    }

    return(hr);
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CEmailNotify::_InitCDO()
{
    HRESULT hr;
    Fields* pFields = NULL;
    IConfiguration *pICDOConfig = NULL;

    // load SMTP fields
    hr = CoCreateInstance(CDO::CLSID_Configuration,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               CDO::IID_IConfiguration,
                               reinterpret_cast<void**>(&pICDOConfig));
    _JumpIfError(hr, error, "CoCreateInstance CDO_IConfiguration");

    hr = pICDOConfig->get_Fields(&pFields);
    _JumpIfError(hr, error, "CDO::IConfig::get_Fields");

    hr = _LoadSMTPFieldsFromRegistry(pFields);
    _JumpIfError(hr, error, "_LoadFieldsFromRegistry");

    hr = _LoadSMTPFieldsFromLSASecret(pFields);
    // don't bail, optional fields
    _PrintIfError(hr, "_LoadFieldsFromLSASecret"); 

    hr = pFields->Update();
    _JumpIfError(hr, error, "config");

    m_rwlockCDOConfig.GetExclusive();

    if(m_pICDOConfig)
    {
        m_pICDOConfig->Release();
    }
    m_pICDOConfig = pICDOConfig;
    pICDOConfig = NULL;

    m_fReloadCDOConfig = false;
    
    m_rwlockCDOConfig.Release();

error:
    if(pFields)
    {
        pFields->Release();
    }
    if(pICDOConfig)
    {
        pICDOConfig->Release();
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
inline bool CEmailNotify::_IsEventEnabled(DWORD dwEvent)
{
    return (dwEvent & m_dwEventFilter)?true:false;
}

/////////////////////////////////////////////////////////////////////////////
//
// Create the following registry structure under exit key
//
//  SMTP
//      EventFilter         DWORD
//      SMTPServer          SZ
//      SMTPAuthenticate    DWORD
//
//      Issued
//          BodyFormat      SZ
//          BodyArg         MULTISZ
//          TitleFormat     SZ
//          TitleArg        MULTISZ
//
//      Pending
//          ...same as Issued
//      Denied
//          ...same as Issued
//      Revoked
//          ...same as Issued
//      CLRIssued
//          ...same as Issued
//      Shutdown
//          ...same as Issued
//
HRESULT CEmailNotify::_CreateSMTPRegSettings(HKEY hkeyExit)
{
    HRESULT hr;
    DWORD dwDisp;
    VARIANT varValue;
    HKEY hkeyEvent = NULL;

    typedef struct tagEventFormat
    {
        LPCWSTR pcwszRegKey;
        int nTitleFormatResourceID;
        int nBodyFormatResourceID;
        LPWSTR pcwszBodyArg;
        DWORD cbBodyArg;
        LPWSTR pcwszTitleArg;
        DWORD cbTitleArg;
    } EventFormat;

    WCHAR wszzTitleArg[] = 
        wszPROPSANITIZEDCANAME
        L"\0";

    WCHAR wszzBodyArgIssued[] = 
        wszPROPCERTIFICATEREQUESTID                             L"\0"
        wszPROPUPN                                              L"\0"
        wszPROPREQUESTDOT wszPROPREQUESTERNAME                  L"\0"
        wszPROPCERTIFICATESERIALNUMBER                          L"\0"
        wszPROPCERTIFICATENOTBEFOREDATE                         L"\0"
        wszPROPCERTIFICATENOTAFTERDATE                          L"\0"
        wszPROPDISTINGUISHEDNAME                                L"\0"
        wszPROPCERTTEMPLATE                                     L"\0"
        wszPROPCERTIFICATEHASH                                  L"\0"
        wszPROPREQUESTDOT wszPROPREQUESTDISPOSITIONMESSAGE      L"\0"
        ;

    WCHAR wszzBodyArgPending[] = 
        wszPROPREQUESTDOT wszPROPREQUESTREQUESTID               L"\0"
        wszPROPUPN                                              L"\0"
        wszPROPREQUESTDOT wszPROPREQUESTERNAME                  L"\0"
        wszPROPREQUESTDOT wszPROPREQUESTSUBMITTEDWHEN           L"\0"
        wszPROPREQUESTDOT wszPROPDISTINGUISHEDNAME              L"\0"
        wszPROPCERTTEMPLATE                                     L"\0"
        wszPROPREQUESTDOT wszPROPREQUESTDISPOSITIONMESSAGE      L"\0"
        ;

    WCHAR wszzBodyArgDenied[] = 
        wszPROPREQUESTDOT wszPROPREQUESTREQUESTID               L"\0"
        wszPROPREQUESTDOT wszPROPREQUESTERNAME                  L"\0"
        wszPROPREQUESTDOT wszPROPREQUESTSUBMITTEDWHEN           L"\0"
        wszPROPREQUESTDOT wszPROPDISTINGUISHEDNAME              L"\0"
        wszPROPREQUESTDOT wszPROPREQUESTDISPOSITIONMESSAGE      L"\0"
        wszPROPREQUESTDOT wszPROPREQUESTSTATUSCODE              L"\0"
        ;

    WCHAR wszzBodyArgRevoked[] =
        wszPROPCERTIFICATEREQUESTID                             L"\0"
        wszPROPREQUESTDOT wszPROPREQUESTREVOKEDWHEN             L"\0"
        wszPROPREQUESTDOT wszPROPREQUESTREVOKEDEFFECTIVEWHEN    L"\0"
        wszPROPREQUESTDOT wszPROPREQUESTREVOKEDREASON           L"\0"
        wszPROPUPN                                              L"\0"
        wszPROPREQUESTDOT wszPROPREQUESTERNAME                  L"\0"
        wszPROPCERTIFICATESERIALNUMBER                          L"\0"
        wszPROPCERTIFICATENOTBEFOREDATE                         L"\0"
        wszPROPCERTIFICATENOTAFTERDATE                          L"\0"
        wszPROPDISTINGUISHEDNAME                                L"\0"
        wszPROPCERTTEMPLATE                                     L"\0"
        wszPROPCERTIFICATEHASH                                  L"\0"
        wszPROPREQUESTDOT wszPROPREQUESTSTATUSCODE              L"\0"
        ;

    WCHAR wszzBodyArgCRLIssued[] = L"\0";
    WCHAR wszzBodyArgShutdown[] = L"\0";
    WCHAR wszzBodyArgStartup[] = L"\0";

    // order in this list must match the order of events in m_pcwszEventRegKeys
    EventFormat FormatList[] = 
    {
        // issued
        {
            wszREGEXITISSUEDKEY,
            IDS_TITLEFORMAT_ISSUED, 
            IDS_BODYFORMAT_ISSUED,
            wszzBodyArgIssued, 
            sizeof(wszzBodyArgIssued),
            wszzTitleArg,
            sizeof(wszzTitleArg),
        },
        // pending
        {
            wszREGEXITPENDINGKEY,
            IDS_TITLEFORMAT_PENDING, 
            IDS_BODYFORMAT_PENDING,
            wszzBodyArgPending, 
            sizeof(wszzBodyArgPending),
            wszzTitleArg,
            sizeof(wszzTitleArg),
        },
        // denied
        {
            wszREGEXITDENIEDKEY,
            IDS_TITLEFORMAT_DENIED,
            IDS_BODYFORMAT_DENIED,
            wszzBodyArgDenied, 
            sizeof(wszzBodyArgDenied),
            wszzTitleArg,
            sizeof(wszzTitleArg),
        },
        // revoked
        {
            wszREGEXITREVOKEDKEY,
            IDS_TITLEFORMAT_REVOKED, 
            IDS_BODYFORMAT_REVOKED,
            wszzBodyArgRevoked, 
            sizeof(wszzBodyArgRevoked),
            wszzTitleArg,
            sizeof(wszzTitleArg),
        },
        // CRL issued
        {
            wszREGEXITCRLISSUEDKEY,
            IDS_TITLEFORMAT_CRLISSUED, 
            IDS_BODYFORMAT_CRLISSUED,
            wszzBodyArgCRLIssued, 
            sizeof(wszzBodyArgCRLIssued),
            wszzTitleArg,
            sizeof(wszzTitleArg),
        },
        // shutdown
        {
            wszREGEXITSHUTDOWNKEY,
            IDS_TITLEFORMAT_SHUTDOWN, 
            IDS_BODYFORMAT_SHUTDOWN,
            wszzBodyArgShutdown, 
            sizeof(wszzBodyArgShutdown),
            wszzTitleArg,
            sizeof(wszzTitleArg),
        },
        // startup
        {
            wszREGEXITSTARTUPKEY,
            IDS_TITLEFORMAT_STARTUP, 
            IDS_BODYFORMAT_STARTUP,
            wszzBodyArgStartup, 
            sizeof(wszzBodyArgStartup),
            wszzTitleArg,
            sizeof(wszzTitleArg),
        },
    };

    if(!m_hkeySMTP)
    {
        hr = RegCreateKeyEx(
            hkeyExit,
            wszREGEXITSMTPKEY,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &m_hkeySMTP,
            &dwDisp);
        _JumpIfErrorStr(hr, error, "RegCreateKeyEx", wszREGEXITSMTPKEY);

        if(REG_CREATED_NEW_KEY==dwDisp)
        {

            V_VT(&varValue) = VT_I4;
            V_I4(&varValue) = 0; // all notifications disabled
            hr = RegSetValue(
                m_hkeySMTP,
                wszREGEXITSMTPEVENTFILTER,
                &varValue);
            _JumpIfErrorStr(hr, error, "RegSetValue", wszREGEXITSMTPEVENTFILTER);

            VariantClear(&varValue);

            V_VT(&varValue) = VT_BSTR;
            V_BSTR(&varValue) = SysAllocString(L"");// just create the value, user
            hr = RegSetValue(                       // needs to set server name    
                m_hkeySMTP,
                wszREGEXITSMTPSERVER,
                &varValue);
            _JumpIfErrorStr(hr, error, "RegSetValue", wszREGEXITSMTPSERVER);

            VariantClear(&varValue);

            V_VT(&varValue) = VT_I4;
            V_I4(&varValue) = cdoAnonymous;
            hr = RegSetValue(
                m_hkeySMTP,
                wszREGEXITSMTPAUTHENTICATE,
                &varValue);
            _JumpIfErrorStr(hr, error, "RegSetValue", wszREGEXITSMTPAUTHENTICATE);

            VariantClear(&varValue);
        }
    }

    for(int i=0; i<ARRAYSIZE(FormatList); i++)
    {
        CAutoLPWSTR pwszBodyFormat;
        CAutoLPWSTR pwszTitleFormat;

        // create key

        hr = RegCreateKeyEx(
            m_hkeySMTP,
            FormatList[i].pcwszRegKey,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hkeyEvent,
            &dwDisp);
        _JumpIfErrorStr(hr, error, "RegCreateKeyEx", wszREGEXITSMTPKEY);

        if(REG_CREATED_NEW_KEY==dwDisp)
        {
            // set body format

            hr = myLoadRCString(
                g_hInstance,
                FormatList[i].nBodyFormatResourceID,
                &pwszBodyFormat);
            _JumpIfError(hr, error, "myLoadRCString body format");

            // Body format is a multi line string, convert it to multisz
            // in place by replacing \n with \0
            // Also if we find consecutive \n's, insert spaces in between
            // so we don't end up with a double \0 which normally marks
            // the end of multisz.
            {
                DWORD cbBodyFormat = sizeof(WCHAR)*(wcslen(pwszBodyFormat)+1);

                CAutoLPWSTR pwszBodyFormatFixed = (LPWSTR)LocalAlloc(
                    LMEM_FIXED|LMEM_ZEROINIT,
                    cbBodyFormat*2); // worst case scenario buffer has only \n's
                _JumpIfAllocFailed(pwszBodyFormatFixed, error);
            
                WCHAR *pchSrc, *pchDest;

                for(cbBodyFormat=2, pchSrc=pwszBodyFormat, pchDest=pwszBodyFormatFixed;
                    *pchSrc;
                    pchSrc++, pchDest++, cbBodyFormat++)
                {
                    if(L'\n' == *pchSrc)
                    {
                        *pchDest = L'\0';

                        if(L'\n' == *(pchSrc+1)) // detected \n\n, insert space in between
                        {
                            *++pchDest = L' ';
                            cbBodyFormat++;
                        }

                    } else
                    {
                        *pchDest = *pchSrc;
                    }
                }

                *pchDest++ = L'\0';
                *pchDest = L'\0';
                cbBodyFormat *= 2;
        
                hr = RegSetValueEx(
                    hkeyEvent,
                    wszREGEXITBODYFORMAT,
                    0,
                    REG_MULTI_SZ,
                    (CONST BYTE*) (LPCWSTR) pwszBodyFormatFixed,
                    cbBodyFormat);
                _JumpIfErrorStr(hr, error, "RegSetValueEx", wszREGEXITBODYFORMAT);
            }

            // set body args

            hr = RegSetValueEx(
                hkeyEvent,
                wszREGEXITBODYARG,
                0,
                REG_MULTI_SZ,
                (CONST BYTE*) FormatList[i].pcwszBodyArg,
                FormatList[i].cbBodyArg);
            _JumpIfErrorStr(hr, error, "RegSetValueEx", wszREGEXITBODYARG);

            // set title format

            hr = myLoadRCString(
                g_hInstance,
                FormatList[i].nTitleFormatResourceID,
                &pwszTitleFormat);
            _JumpIfError(hr, error, "myLoadRCString title format");

            hr = RegSetValueEx(
                hkeyEvent,
                wszREGEXITTITLEFORMAT,
                0,
                REG_SZ,
                (CONST BYTE*) (LPCWSTR) pwszTitleFormat,
                sizeof(WCHAR)*(wcslen(pwszTitleFormat)+1));
            _JumpIfErrorStr(hr, error, "RegSetValueEx", wszREGEXITTITLEFORMAT);

            // set title args

            hr = RegSetValueEx(
                hkeyEvent,
                wszREGEXITTITLEARG,
                0,
                REG_MULTI_SZ,
                (CONST BYTE*) FormatList[i].pcwszTitleArg,
                FormatList[i].cbTitleArg);
            _JumpIfErrorStr(hr, error, "RegSetValueEx", wszREGEXITBODYARG);

            RegCloseKey(hkeyEvent);
            hkeyEvent = NULL;
        }
    }
    hr = S_OK;

error:
    if(hkeyEvent)
    {
        RegCloseKey(hkeyEvent);
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CEmailNotify::_LoadTemplateRestrictionsFromRegistry()
{
    HRESULT hr;

    hr = RegGetValue(
        m_hkeySMTP,
        wszREGEXITSMTPTEMPLATES,
        &m_varTemplateRestrictions);
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
    {
        hr =S_OK;
    }
    _JumpIfErrorStr(hr, error, "RegGetValue", wszREGEXITSMTPTEMPLATES);

error:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
inline bool CEmailNotify::_TemplateRestrictionsEnabled(DWORD dwEvent)
{
    if((dwEvent & EXITEVENT_CRLISSUED) ||
       (dwEvent & EXITEVENT_SHUTDOWN)  ||
       (dwEvent & EXITEVENT_STARTUP)   ||
       VT_EMPTY==V_VT(&m_varTemplateRestrictions))
    {
        return false;
    }
    else
    {
        return true;
    }
}

/////////////////////////////////////////////////////////////////////////////
bool CEmailNotify::_IsRestrictedTemplate(BSTR strTemplate)
{
    // attempt to retrieve the name and OID for this template

    CAutoHCERTTYPE hCertType;
    bool fFoundByName = true;
    CAutoBSTR strAlternateTemplateName;

    if(!strTemplate)
        return true;

    HRESULT hr = CAFindCertTypeByName(
        strTemplate,
        NULL,
        CT_FIND_LOCAL_SYSTEM |
        CT_ENUM_MACHINE_TYPES |
        CT_ENUM_USER_TYPES,
        &hCertType);

    if(HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
    {
        // try with the OID

        hr = CAFindCertTypeByName(
            strTemplate,
            NULL,
            CT_FIND_LOCAL_SYSTEM |
            CT_ENUM_MACHINE_TYPES |
            CT_ENUM_USER_TYPES |
            CT_FIND_BY_OID,
            &hCertType);
        
        fFoundByName = false;
    }

    if(S_OK==hr)
    {
        LPWSTR *ppwszProp = NULL;

        hr = CAGetCertTypeProperty(
            hCertType,
            fFoundByName?CERTTYPE_PROP_OID:CERTTYPE_PROP_CN,
            &ppwszProp);
        if(S_OK==hr)
        {
            if(ppwszProp && ppwszProp[0])
            {
                strAlternateTemplateName = SysAllocString(
                    ppwszProp[0]);
            }

            CAFreeCertTypeProperty(
                hCertType,
                ppwszProp);
        }
    }

    // Must be an array of BSTRs, otherwise loading from registry
    // should have failed
    CSASSERT((VT_ARRAY|VT_BSTR)==V_VT(&m_varTemplateRestrictions));

    BSTR strTempl;
    SafeArrayEnum<BSTR> saenumTemplates(V_ARRAY(&m_varTemplateRestrictions));

    while(S_OK==saenumTemplates.Next(strTempl))
    {
        if((strTemplate && 
            0==mylstrcmpiL(strTempl, strTemplate)) ||
           (strAlternateTemplateName && 
            0==mylstrcmpiL(strTempl, strAlternateTemplateName)))
        {
            // found it, send mail
            return false;
        }
    }

    // template not in the list, don't send mail
    return true;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CEmailNotify::_LoadSMTPFieldsFromRegistry(Fields* pFields)
{
    HRESULT hr;
    DWORD dwType;
    BYTE* pbValue = NULL;
    DWORD cbValue;
    VARIANT varValue;
    DWORD dwIndex;
    LPWSTR  pwszValName = NULL;
    DWORD cbValName;
    DWORD cValues;
    static LPCWSTR pcwszHTTP = L"http://";
    static size_t cHTTP = wcslen(pcwszHTTP);
   
    // load cdoSMTPServer
    hr = RegGetValue(
        m_hkeySMTP,
        wszREGEXITSMTPSERVER,
        &varValue);
    _JumpIfErrorStr(hr, error, "error retrieving SMTP field", wszREGEXITSMTPSERVER);
    if(V_VT(&varValue) != VT_BSTR)
    {
        VariantClear(&varValue);
        hr = HRESULT_FROM_WIN32(ERROR_BADKEY);
        _JumpErrorStr(hr, error, "invalid field", wszREGEXITSMTPSERVER);
    }

    hr = _SetField(
        pFields,
        cdoSMTPServer,
        &varValue);
    _JumpIfErrorStr(hr, error, "_SetField", cdoSMTPServer);

    VariantClear(&varValue);

    // authentication method optional 
    hr = RegGetValue(
        m_hkeySMTP,
        wszREGEXITSMTPAUTHENTICATE,
        &varValue);
    if(S_OK==hr &&
       V_VT(&varValue) != VT_I4)
    {
        hr = HRESULT_FROM_WIN32(ERROR_BADKEY);
        _JumpErrorStr(hr, error, "invalid CC field", wszREGEXITSMTPAUTHENTICATE);
    }

    if(S_OK == hr)
    {
        hr = _SetField(
            pFields,
            cdoSMTPAuthenticate,
            &varValue);
        _JumpIfErrorStr(hr, error, "_SetField", cdoSMTPAuthenticate);

        VariantClear(&varValue);
    }
    else if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
    {
        hr = S_OK;
    }
    else
    {
        _JumpErrorStr(hr, error, "RegGetValue", wszREGEXITSMTPAUTHENTICATE);
    }

    // set other SMTP defaults

    V_VT(&varValue) = VT_I4;
    V_I4(&varValue) = 25; // well known SMTP port

    hr = _SetField(
        pFields,
        cdoSMTPServerPort,
        &varValue);
    _JumpIfErrorStr(hr, error, "_SetField", cdoSMTPAuthenticate);

    V_VT(&varValue) = VT_I4;
    V_I4(&varValue) = cdoSendUsingPort;

    hr = _SetField(
        pFields,
        cdoSendUsingMethod,
        &varValue);
    _JumpIfErrorStr(hr, error, "_SetField", cdoSendUsingMethod);

    // enumerate and set any other CDO fields (only if value name is full HTTP URL)

    hr = RegQueryInfoKey(
        m_hkeySMTP,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        &cValues,
        &cbValName,
        &cbValue,
        NULL,
        NULL);
    _JumpIfErrorStr(hr, error, "RegQueryInfoKey", wszREGEXITSMTPKEY);

    pwszValName = (LPWSTR) LocalAlloc(LMEM_FIXED, ++cbValName*sizeof(WCHAR));
    _JumpIfAllocFailed(pwszValName, error);

    pbValue = (BYTE *) LocalAlloc(LMEM_FIXED, cbValue);
    _JumpIfAllocFailed(pbValue, error);

    for(dwIndex=0;dwIndex<cValues;dwIndex++)
    {
        DWORD cbValueTemp = cbValue;
        DWORD cbValNameTemp = cbValName;

        hr = RegEnumValue(
            m_hkeySMTP, 
            dwIndex, 
            pwszValName, 
            &cbValNameTemp,
            NULL, 
            &dwType,
            pbValue, 
            &cbValueTemp);
        if (hr != S_OK)
        {
            hr = myHError(hr);
            _JumpError(hr, error, "RegEnumValue");
        }

        // ignore if not an HTTP URL
        if(_wcsnicmp(pwszValName, pcwszHTTP, cHTTP))
        {
            continue;
        }

        hr = myRegValueToVariant(
            dwType,
            cbValueTemp,
            pbValue,
            &varValue);
        _JumpIfError(hr, error, "myRegValueToVariant");

        hr = _SetField(
            pFields,
            pwszValName,
            &varValue);
        _JumpIfError(hr, error, "_SetField");

        VariantClear(&varValue);
    }

    hr = S_OK;

error:

    VariantClear(&varValue);

    if(pwszValName)
    {
        LocalFree(pwszValName);
    }

    if(pbValue)
    {
        LocalFree(pbValue);
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CEmailNotify::_SetField(
    Fields* pFields,
    LPCWSTR pcwszFieldSchemaName,
    VARIANT *pvarFieldValue)
{
    HRESULT hr;
    Field*  pfld = NULL;
    VARIANT vtName;

    VariantInit(&vtName);

    V_VT(&vtName) = VT_BSTR;
    V_BSTR(&vtName) = SysAllocString(pcwszFieldSchemaName);
    _JumpIfAllocFailed(V_BSTR(&vtName), error);

    hr = pFields->get_Item(vtName, &pfld);
    _JumpIfErrorStr(hr, error, "CDO::Field::get_Item", pcwszFieldSchemaName);

    hr = pfld->put_Value(*pvarFieldValue);
    _JumpIfErrorStr(hr, error, "CDO::Field::put_Value", pcwszFieldSchemaName);

error:

    VariantClear(&vtName);

    if(pfld)
    {
        pfld->Release();
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CEmailNotify::_LoadSMTPFieldsFromLSASecret(
    Fields* pFields)
{
    HRESULT hr;
    VARIANT var; // don't clear
    LPWSTR pwszProfileName = NULL;
    LPWSTR pwszLogonName = NULL;
    LPWSTR pwszPassword = NULL;
    BSTR bstrLogonName = NULL;
    BSTR bstrPassword = NULL;

	hr = myGetMapiInfo(
			NULL,
			&pwszProfileName, // not used
			&pwszLogonName,
			&pwszPassword);
    if(S_OK == hr)  // if NTLM is used, username & password aren't needed
    {
        bstrLogonName = SysAllocString(pwszLogonName);
        _JumpIfAllocFailed(bstrLogonName, error);

        bstrPassword = SysAllocString(pwszPassword);
        _JumpIfAllocFailed(bstrPassword, error);

        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = bstrLogonName;

        hr = _SetField(
            pFields,
            cdoSendUserName,
            &var);
        _JumpIfError(hr, error, "_SetField");

        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = bstrPassword;

        hr = _SetField(
            pFields,
            cdoSendPassword,
            &var);
        _JumpIfError(hr, error, "_SetField");
    }

    hr = S_OK;

error:
    if (NULL != pwszProfileName)
    {
        LocalFree(pwszProfileName);
    }
    if (NULL != pwszLogonName)
    {
        LocalFree(pwszLogonName);
    }
    if (NULL != pwszPassword)
    {
	myZeroDataString(pwszPassword);	// password data
        LocalFree(pwszPassword);
    }
    if(NULL != bstrLogonName)
    {
        SysFreeString(bstrLogonName);
    }
    if(NULL != bstrPassword)
    {
	myZeroDataString(bstrPassword);	// password data
        SysFreeString(bstrPassword);
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CEmailNotify::_LoadEventInfoFromRegistry()
{
    HRESULT hr;

    CSASSERT(m_hkeySMTP);

    for(int i=0; i<m_gcEvents;i++)
    {
        hr = m_NotifyInfoArray[i].LoadInfoFromRegistry(
            m_hkeySMTP,
            m_pcwszEventRegKeys[i]);
        _JumpIfErrorStr(hr, error, 
            "CNotifyInfo::LoadInfoFromRegistry",
            m_pcwszEventRegKeys[i]);
    }

    hr = S_OK;

error:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CEmailNotify::_GetCAMailAddress(
    ICertServerExit* pServer, 
    BSTR& rbstrAddress)
{
    HRESULT hr;
    VARIANT varMachineDNSName;
    VARIANT varCAName;
    CAutoLPWSTR pwszMailAddr;

    VariantInit(&varCAName);
    VariantInit(&varMachineDNSName);

    if(!m_bstrCAMailAddress)
    {
        //
        // CA_name@machine_dns_name
        //
        hr = exitGetProperty(
			pServer,
			FALSE,	// fRequest
			wszPROPSANITIZEDCANAME, 
			PROPTYPE_STRING, 
			&varCAName);
        _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", 
            wszPROPSANITIZEDCANAME);

        hr = exitGetProperty(
			pServer,
			FALSE,	// fRequest
			wszPROPMACHINEDNSNAME, 
			PROPTYPE_STRING, 
			&varMachineDNSName);
        _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", 
            wszPROPMACHINEDNSNAME);

        pwszMailAddr = (LPWSTR) LocalAlloc(
            LMEM_FIXED,
            sizeof(WCHAR)*(SysStringLen(V_BSTR(&varCAName))+
                           SysStringLen(V_BSTR(&varMachineDNSName))
                           +2));
        _JumpIfAllocFailed(pwszMailAddr, error);

        wcscpy(pwszMailAddr, V_BSTR(&varCAName));
        wcscat(pwszMailAddr, L"@");
        wcscat(pwszMailAddr, V_BSTR(&varMachineDNSName));

        m_bstrCAMailAddress = SysAllocString(pwszMailAddr);
        _JumpIfAllocFailed(m_bstrCAMailAddress, error);
    }

    rbstrAddress = m_bstrCAMailAddress;
    hr = S_OK;

error:
    VariantClear(&varCAName);
    VariantClear(&varMachineDNSName);
    return(hr);
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CEmailNotify::_GetEmailFromCertSubject(
    const VARIANT *pVarCert,
    BSTR *pbstrEmail)
{
    HRESULT hr;
    PCCERT_CONTEXT pcc = NULL;
    CAutoLPWSTR strSubjectEmail;

    pcc = CertCreateCertificateContext(
        X509_ASN_ENCODING,
        (const BYTE *)V_BSTR(pVarCert),
        SysStringByteLen(V_BSTR(pVarCert)));
    if(!pcc)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertCreateCertificateContext");
    }

    hr = myGetCertSubjectField(
        pcc,
        szOID_RSA_emailAddr,
        &strSubjectEmail);
    _JumpIfError(hr, error, "myGetCertSubjectField");

    *pbstrEmail = SysAllocString(strSubjectEmail);
    _JumpIfAllocFailed(*pbstrEmail, error);

error:
    if(pcc)
    {
        CertFreeCertificateContext(pcc);
    }
    return hr;
}


inline DWORD CEmailNotify::_MapEventToOrd(LONG lEvent)
{
    switch (lEvent)
    {   case EXITEVENT_CERTISSUED:  return 0;
        case EXITEVENT_CERTPENDING: return 1;
        case EXITEVENT_CERTDENIED:  return 2;
        case EXITEVENT_CERTREVOKED: return 3;
        // not impl case EXITEVENT_CERTRETRIEVEPENDING: 
        case EXITEVENT_CRLISSUED:   return 4;
        case EXITEVENT_SHUTDOWN:    return 5;
        case EXITEVENT_STARTUP:     return 6;
        default: return MAXDWORD;
    }
}

/////////////////////////////////////////////////////////////////////////////
HRESULT
CEmailNotify::Notify(
    IN DWORD lExitEvent,
    IN LONG lContext,
    IN WCHAR const *pwszDescription)
{
    HRESULT hr;
    ICertServerExit* pServer = NULL;
    IMessage* pMsg = NULL;
    IBodyPart *pBp = NULL;
    CNotifyInfo *pNotifyInfo;
    BSTR bstrCharSet = NULL;
    BSTR bstrSetTo, bstrSetFrom; // no free
    BSTR bstrTo = NULL;
    BSTR bstrTitle = NULL;
    BSTR bstrBody = NULL;
    BSTR bstrTemplate = NULL;
    VARIANT varCert;
    bool fRWLockAcquired = false;
    bool fRetryReloadCDOConfig = false;

    VariantInit(&varCert);
    bstrSetTo = NULL;

    if(_IsEventEnabled(lExitEvent))
    {
        hr = GetServerCallbackInterface(&pServer, lContext);
        _JumpIfError(hr, error, "Exit:GetServerCallbackInterface");

        if(_TemplateRestrictionsEnabled(lExitEvent))
        {
            hr = exitGetStringProperty(
                    pServer, 
                    FALSE, 
                    FALSE, 
                    wszPROPCERTIFICATETEMPLATE, 
                    &bstrTemplate);
            if((S_OK == hr || CERTSRV_E_PROPERTY_EMPTY == hr) &&
                _IsRestrictedTemplate(bstrTemplate))
            {
                // don't send mail for this template
                hr = S_OK;
                goto error;
            }
            _JumpIfErrorStr(hr, error, "exitGetStringProperty", 
                wszPROPCERTIFICATETEMPLATE);
        }
        
        pNotifyInfo = &m_NotifyInfoArray[_MapEventToOrd(lExitEvent)];

        hr = CoCreateInstance(CDO::CLSID_Message,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   CDO::IID_IMessage,
                                   reinterpret_cast<void**>(&pMsg));
        _JumpIfError(hr, error, "CoCreateInstance CDO_IConfiguration");

        ///////////////////////////////////////////////////////////////////////////
        // Set recipient. Override with registry To field if found.

        if(VT_BSTR == V_VT(&pNotifyInfo->m_varTo))
        {
            bstrSetTo = V_BSTR(&pNotifyInfo->m_varTo);
        }
        else
        {
            // Recipient not enforced in the registry, try to find one in the cert.
            // For CRL and shutdown events, no cert is available, so To field is
            // mandatory
            if(lExitEvent&EXITEVENT_CRLISSUED ||
               lExitEvent&EXITEVENT_SHUTDOWN  ||
               lExitEvent&EXITEVENT_STARTUP)
            {
                hr = HRESULT_FROM_WIN32(ERROR_BADKEY);
                _JumpError(hr, error, 
                    "Recipient field is mandatory for CRL or SHUTDOWN events");
            }

            // look for recipient's address in email cert property (retrieved from
            // subject alt name)
            hr = exitGetStringProperty(
                    pServer, 
                    FALSE, 
                    FALSE, 
                    wszPROPEMAIL, 
                    &bstrTo);
        
            // no email in subject alt name, try in subject
            if(CERTSRV_E_PROPERTY_EMPTY == hr)
            {
                hr = exitGetProperty(
				pServer,
				FALSE,	// fRequest
				wszPROPRAWCERTIFICATE,
				PROPTYPE_BINARY,
				&varCert);

                if(S_OK == hr)
                {
                    hr = _GetEmailFromCertSubject(
                        &varCert,
                        &bstrTo);
                }
            }
        
            // no email in subject, send to CC list if any
            if(S_OK != hr && VT_BSTR == V_VT(&pNotifyInfo->m_varCC))
            {
                hr = S_OK;
                bstrSetTo = V_BSTR(&pNotifyInfo->m_varCC);
            }
            _JumpIfError(hr, error, "failed to find a recipient");

            if(bstrTo)
            {
                bstrSetTo = bstrTo;
            }
        }

        hr = pMsg->put_To(bstrSetTo);
        _JumpIfError(hr, error, "put_To");

        ///////////////////////////////////////////////////////////////////////
        // Set sender. If not specified in the registry, build it: 
        // 
        //  CAName@MachineDNSName
        //
        if(VT_BSTR == V_VT(&pNotifyInfo->m_varFrom))
        {
            bstrSetFrom = V_BSTR(&pNotifyInfo->m_varFrom);
        }
        else
        {
            hr = _GetCAMailAddress(pServer, bstrSetFrom);
            _JumpIfError(hr, error, "CEmailNotify::_GetCAMailAddress");
        }
    
        hr = pMsg->put_From(bstrSetFrom);
        _JumpIfError(hr, error, "put_From");

        ///////////////////////////////////////////////////////////////////////////
        // Set CC list, if set in registry
        if(VT_BSTR==V_VT(&pNotifyInfo->m_varCC))
        {
            hr = pMsg->put_CC(V_BSTR(&pNotifyInfo->m_varCC));
            _JumpIfError(hr, error, "put_CC");
        }

        ///////////////////////////////////////////////////////////////////////////
        // Set message body
        hr = pNotifyInfo->BuildMessageBody(pServer, bstrBody);
        _JumpIfError(hr, error, "CNotifyInfo::BuildMessageBody");

        hr = pMsg->put_TextBody(bstrBody);
        _JumpIfError(hr, error, "put_Body");

	///////////////////////////////////////////////////////////////////////
	// Set body part to UTF-8 charset
	hr = pMsg->get_TextBodyPart(&pBp);
	_JumpIfError(hr, error, "get_BodyPart");

	bstrCharSet = SysAllocString(L"utf-8");
	if (NULL == bstrCharSet)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Exit:SysAllocString");
	}
	hr = pBp->put_Charset(bstrCharSet);
	_JumpIfError(hr, error, "put_Charset");

        ///////////////////////////////////////////////////////////////////////////
        // Set message title
        hr = pNotifyInfo->BuildMessageTitle(pServer, bstrTitle);
        _JumpIfError(hr, error, "CNotifyInfo::BuildMessageTitle");
    
        hr = pMsg->put_Subject(bstrTitle);
        _JumpIfError(hr, error, "put_Subject");

        ///////////////////////////////////////////////////////////////////////////
        // Send SMTP message

        DBGPRINT((DBG_SS_CERTEXIT, 
            "---MAIL NOTIFICATION---\nTo: %ws\nFrom: %ws\nCC: %ws\n%ws\n%ws\n---END MAIL NOTIFICATION---\n",
            bstrSetTo,
            bstrSetFrom,
            VT_BSTR==V_VT(&pNotifyInfo->m_varCC)?V_BSTR(&pNotifyInfo->m_varCC):L"",
            bstrTitle,
            bstrBody));

        fRetryReloadCDOConfig = false;
        while(true)
        {
            if(m_fReloadCDOConfig || fRetryReloadCDOConfig)
            {
                hr = _InitCDO();
                _JumpIfError(hr, error, "CEmailNotify::_InitCDO");
            }

            // protect m_pICDOCOnfig from being updated
            m_rwlockCDOConfig.GetShared();
            fRWLockAcquired = true;

            hr = pMsg->putref_Configuration(m_pICDOConfig);
            _JumpIfError(hr, error, "putref_Configuration");

            hr = pMsg->Send();

            fRWLockAcquired = false;
            m_rwlockCDOConfig.Release();

            if(CDO_E_SMTP_SEND_FAILED   == hr ||
               CDO_E_CONNECTION_DROPPED == hr ||
               CDO_E_FAILED_TO_CONNECT  == hr)
            {
                // if this is the first time and it failed due to server connection
                // problems, try again
                if(!fRetryReloadCDOConfig)
                {
                    _PrintError(hr, 
                        "Failed to send mail, reconnecting to server");
                    fRetryReloadCDOConfig = true;
                    continue;
                }
                m_fReloadCDOConfig = true;
            }
            _JumpIfError(hr, error, "Send");

            break;
        }
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	WCHAR awc[cwcDWORDSPRINTF];
        WCHAR *apwsz[2];

	switch (lExitEvent)
	{
	    case EXITEVENT_INVALID:
		apwsz[0] = L"EXITEVENT_INVALID";
		break;

	    case EXITEVENT_CERTISSUED:
		apwsz[0] = L"EXITEVENT_CERTISSUED";
		break;

	    case EXITEVENT_CERTPENDING:
		apwsz[0] = L"EXITEVENT_CERTPENDING";
		break;

	    case EXITEVENT_CERTDENIED:
		apwsz[0] = L"EXITEVENT_CERTDENIED";
		break;

	    case EXITEVENT_CERTREVOKED:
		apwsz[0] = L"EXITEVENT_CERTREVOKED";
		break;

	    case EXITEVENT_CERTRETRIEVEPENDING:
		apwsz[0] = L"EXITEVENT_CERTRETRIEVEPENDING";
		break;

	    case EXITEVENT_CRLISSUED:
		apwsz[0] = L"EXITEVENT_CRLISSUED";
		break;

	    case EXITEVENT_SHUTDOWN:
		apwsz[0] = L"EXITEVENT_SHUTDOWN";
		break;

	    case EXITEVENT_STARTUP:
		apwsz[0] = L"EXITEVENT_STARTUP";
		break;

	    default:
		wsprintf(awc, L"0x%x", lExitEvent);
		apwsz[0] = awc;
		break;
	}

	apwsz[1] = bstrSetTo;
	if (NULL == bstrSetTo)
	{
	    apwsz[1] = wszREGEXITPROPNOTFOUND;
	}
        ::LogModuleStatus(
		    g_hInstance,
		    S_OK,
		    MSG_UNABLE_TO_MAIL_NOTIFICATION,
		    FALSE,		// fPolicy
		    pwszDescription,
		    apwsz,
		    NULL);
    }
    if(fRWLockAcquired)
    {
        m_rwlockCDOConfig.Release();
    }

    if(pServer)
    {
        pServer->Release();
    }
    if(pMsg)
    {
        pMsg->Release();
    }
    if (NULL != pBp)
    {
        pBp->Release();
    }
    if (NULL != bstrCharSet)
    {
	SysFreeString(bstrCharSet);
    }
    if (bstrTo)
    {
        SysFreeString(bstrTo);
    }
    if (bstrBody)
    {
        SysFreeString(bstrBody);
    }
    if (bstrTitle)
    {
        SysFreeString(bstrTitle);
    }
    if (bstrTemplate)
    {
        SysFreeString(bstrTemplate);
    }
    VariantClear(&varCert);
    return hr;
}

LONG CNotifyInfo::FormattedMessageInfo::m_gPropTypes[] = 
{   
    PROPTYPE_LONG,
    PROPTYPE_DATE,
    PROPTYPE_BINARY,
    PROPTYPE_STRING,
};

LPCWSTR CNotifyInfo::FormattedMessageInfo::m_gwszArchivedKeyPresent = L"1";

/////////////////////////////////////////////////////////////////////////////
CNotifyInfo::CNotifyInfo()
{
    VariantInit(&m_varFrom);
    VariantInit(&m_varTo);
    VariantInit(&m_varCC);
}

/////////////////////////////////////////////////////////////////////////////
CNotifyInfo::~CNotifyInfo()
{
    VariantClear(&m_varFrom);
    VariantClear(&m_varTo);
    VariantClear(&m_varCC);
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CNotifyInfo::LoadInfoFromRegistry(
    HKEY hkeySMTP, 
    LPCWSTR pcwszSubkey)
{
    HRESULT hr;
    HKEY hkeyEventInfo = NULL;
    VARIANT varBodyFormatTmp;

    VariantInit(&varBodyFormatTmp);

    hr = RegOpenKeyEx(
                hkeySMTP,
                pcwszSubkey,
                0,              // dwReserved
                KEY_READ | KEY_QUERY_VALUE,
                &hkeyEventInfo);
    _JumpIfErrorStr(hr, error, "RegOpenKey", pcwszSubkey);

    hr = RegGetValue(
        hkeyEventInfo,
        wszREGEXITSMTPFROM,
        &m_varFrom);
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
    {
        hr = S_OK;
    }
    _JumpIfErrorStr(hr, error, "RegGetValue", wszREGEXITSMTPFROM);

    hr = RegGetValue(
        hkeyEventInfo,
        wszREGEXITSMTPTO,
        &m_varTo);
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
    {
        hr =S_OK;
    }
    _JumpIfErrorStr(hr, error, "RegGetValue", wszREGEXITSMTPTO);

    hr = RegGetValue(
        hkeyEventInfo,
        wszREGEXITSMTPCC,
        &m_varCC);
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
    {
        hr =S_OK;
    }
    _JumpIfErrorStr(hr, error, "RegGetValue", wszREGEXITSMTPCC);

    hr = RegGetValue(
        hkeyEventInfo,
        wszREGEXITTITLEFORMAT,
        &m_TitleFormat.m_varFormat);
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr ||
       VT_BSTR != V_VT(&m_TitleFormat.m_varFormat))
    {
        hr =S_OK;
        VariantClear(&m_TitleFormat.m_varFormat);
        V_VT(&m_TitleFormat.m_varFormat) = VT_BSTR;
        V_BSTR(&m_TitleFormat.m_varFormat) = SysAllocString(L"");
        _JumpIfAllocFailed(V_BSTR(&m_TitleFormat.m_varFormat), error);
    }
    _JumpIfErrorStr(hr, error, "RegGetValue", wszREGEXITTITLEFORMAT);

    hr = RegGetValue(
        hkeyEventInfo,
        wszREGEXITTITLEARG,
        &m_TitleFormat.m_varArgs);
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr ||
       (VT_ARRAY|VT_BSTR) != V_VT(&m_TitleFormat.m_varArgs))
    {
        VariantClear(&m_TitleFormat.m_varArgs);
        hr =S_OK;
    }
    _JumpIfErrorStr(hr, error, "RegGetValue", wszREGEXITTITLEARG);

    hr = RegGetValue(
        hkeyEventInfo,
        wszREGEXITBODYFORMAT,
        &varBodyFormatTmp);
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr ||
       ((VT_ARRAY|VT_BSTR) != V_VT(&varBodyFormatTmp)&&
       (VT_BSTR) != V_VT(&varBodyFormatTmp)))
    {
        hr = S_OK;
        V_VT(&m_BodyFormat.m_varFormat) = VT_BSTR;
        V_BSTR(&m_BodyFormat.m_varFormat) = SysAllocString(L"");
        _JumpIfAllocFailed(V_BSTR(&m_BodyFormat.m_varFormat), error);
    }
    else if(S_OK == hr)
    {
        if((VT_ARRAY|VT_BSTR) == V_VT(&varBodyFormatTmp))
        {
            // code down the road expects this to be a BSTR
            // so we concatenate the strings, separated by new lines (\n)
            hr = _ConvertBSTRArrayToBSTR(
                varBodyFormatTmp,
                m_BodyFormat.m_varFormat);
        }
        else // VT_BSTR
        {
            hr = VariantCopy(
                &m_BodyFormat.m_varFormat,
                &varBodyFormatTmp);
        }
    }
    _JumpIfErrorStr(hr, error, "RegGetValue", wszREGEXITBODYFORMAT);

    hr = RegGetValue(
        hkeyEventInfo,
        wszREGEXITBODYARG,
        &m_BodyFormat.m_varArgs);
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
    {
        hr =S_OK;
    }
    _JumpIfErrorStr(hr, error, "RegGetValue", wszREGEXITBODYARG);

    hr = S_OK;

error:

    if (hkeyEventInfo)
    {
        RegCloseKey(hkeyEventInfo);
    }
    VariantClear(&varBodyFormatTmp);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CNotifyInfo::_ConvertBSTRArrayToBSTR(VARIANT& varIn, VARIANT& varOut)
{
    HRESULT hr;
    SafeArrayEnum<BSTR> 
        saenumArgs(V_ARRAY(&varIn));
    BSTR bstrArg; //no free
    DWORD cchBufSize = 1;
    LPWSTR pwszOut = NULL;
    WCHAR *pchCrt;

    for(hr = saenumArgs.Next(bstrArg);
        S_OK==hr;
        hr = saenumArgs.Next(bstrArg))
    {
        cchBufSize += SysStringLen(bstrArg)+wcslen(L"\n");
    }

    pwszOut = (LPWSTR) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, 
        cchBufSize*sizeof(WCHAR));
    _JumpIfAllocFailed(pwszOut, error);

    saenumArgs.Reset();
    pchCrt = pwszOut;

    for(hr = saenumArgs.Next(bstrArg);
        S_OK==hr;
        hr = saenumArgs.Next(bstrArg))
    {
        wcscat(pchCrt, bstrArg);
        wcscat(pchCrt, L"\n");
    }

    V_VT(&varOut) = VT_BSTR;
    V_BSTR(&varOut) = SysAllocString(pwszOut);
    _JumpIfAllocFailed(V_BSTR(&varOut), error);

    hr = S_OK;
error:
    LOCAL_FREE(pwszOut);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CNotifyInfo::BuildMessageTitle(ICertServerExit* pServer, BSTR& rbstrOut)
{
    return m_TitleFormat.BuildFormattedString(
        pServer,
        rbstrOut);
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CNotifyInfo::BuildMessageBody (ICertServerExit* pServer, BSTR& rbstrOut)
{
    return m_BodyFormat.BuildFormattedString(
        pServer,
        rbstrOut);
}


/////////////////////////////////////////////////////////////////////////////
HRESULT
CNotifyInfo::FormattedMessageInfo::_FormatStringFromArgs(
    IN LPWSTR *ppwszArgs,
    OPTIONAL OUT WCHAR *pwszOut,
    IN OUT DWORD *pcwcOut)
{
    HRESULT hr;
    WCHAR const *pwszFmt;
    DWORD cwcOut;
    DWORD cwcBuf;
    WCHAR const *pwszOutOrg = pwszOut;

    cwcBuf = 0;
    if (NULL != pwszOut)
    {
	cwcBuf = *pcwcOut;
    }

    cwcOut = 0;
    pwszFmt = V_BSTR(&m_varFormat);
    if (NULL != pwszFmt)
    {
	while (L'\0' != *pwszFmt)
	{
	    DWORD cwcCopy;
	    DWORD cwcSkip;
	    WCHAR const *pwszT;
	    WCHAR const *pwszArg;

	    cwcSkip = 0;
	    pwszArg = NULL;
	    pwszT = wcschr(pwszFmt, L'%');
	    if (NULL != pwszT)
	    {
		LONG iArg;

		cwcCopy = SAFE_SUBTRACT_POINTERS(pwszT, pwszFmt);
		pwszT++;
		iArg = _wtoi(pwszT);
		if (0 < iArg && m_nArgs >= iArg)
		{
		    pwszArg = ppwszArgs[iArg - 1];
		    cwcSkip++;
		    while (iswdigit(*pwszT))
		    {
			pwszT++;
			cwcSkip++;
		    }
		}
		else
		{
		    cwcCopy++;
		    if (L'%' == *pwszT)
		    {
			cwcSkip++;
		    }
		    else
		    {
			_PrintErrorStr(
				E_INVALIDARG,
				"Exit:Bad Arg specifier",
				&pwszT[-1]);
		    }
		}
	    }
	    else
	    {
		cwcCopy = wcslen(pwszFmt);
	    }
	    if (NULL != pwszOut)
	    {
		if (cwcCopy >= cwcBuf)
		{
		    _PrintErrorStr(
			    HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER),
			    "Exit:overflow",
			    pwszFmt);
		    pwszOut = NULL;
		}
		else
		{
		    CopyMemory(pwszOut, pwszFmt, cwcCopy * sizeof(WCHAR));
		    pwszOut += cwcCopy;
		    cwcBuf -= cwcCopy;
		}
	    }
	    pwszFmt += cwcCopy + cwcSkip;
	    cwcOut += cwcCopy;

	    if (NULL != pwszArg)
	    {
		cwcCopy = wcslen(pwszArg);
		if (NULL != pwszOut)
		{
		    if (cwcCopy >= cwcBuf)
		    {
			pwszOut = NULL;
			_PrintErrorStr(
				HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER),
				"Exit:overflow",
				pwszFmt);
		    }
		    else
		    {
			CopyMemory(pwszOut, pwszArg, cwcCopy * sizeof(WCHAR));
			pwszOut += cwcCopy;
			cwcBuf -= cwcCopy;
		    }
		}
		cwcOut += cwcCopy;
	    }
	}
    }
    if (NULL != pwszOut)
    {
	if (1 > cwcBuf)
	{
	    pwszOut = NULL;
	    _PrintError(
		    HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER),
		    "Exit:overflow end");
	}
	else
	{
	    *pwszOut = L'\0';
	}
    }
    *pcwcOut = cwcOut;
    if (NULL == pwszOut)
    {
	(*pcwcOut)++;
	if (NULL != pwszOutOrg)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	    _JumpError(hr, error, "Exit:pwszOut");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
HRESULT
CNotifyInfo::FormattedMessageInfo::BuildFormattedString(
    ICertServerExit* pServer, 
    BSTR& rbstrOut)
{
    HRESULT hr;
    LPWSTR *ppwszArgs = NULL;
    DWORD cwcOut;

    hr = BuildArgList(pServer, ppwszArgs);
    _JumpIfError(hr, error, "BuildArgList");

    hr = _FormatStringFromArgs(ppwszArgs, NULL, &cwcOut);
    _JumpIfError(hr, error, "_FormatStringFromArgs");

    if (0 < cwcOut)	// count included L'\0' terminator
    {
	cwcOut--;
    }
    rbstrOut = SysAllocStringLen(NULL, cwcOut);
    if (NULL == rbstrOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Exit:LocalAlloc");
    }

    cwcOut++;		// buffer must include L'\0' terminator

    hr = _FormatStringFromArgs(ppwszArgs, rbstrOut, &cwcOut);
    _JumpIfError(hr, error, "_FormatStringFromArgs");

    // count no longer includes L'\0' terminator

    CSASSERT(SysStringLen(rbstrOut) == wcslen(rbstrOut));
    CSASSERT(SysStringLen(rbstrOut) == cwcOut);

error:
    FreeArgList(ppwszArgs);
    if (S_OK != hr)
    {
	if (NULL != rbstrOut)
	{
	    SysFreeString(rbstrOut);
	    rbstrOut = NULL;
	}
    }
    return(hr);
}

/////////////////////////////////////////////////////////////////////////////
void
CNotifyInfo::FormattedMessageInfo::FreeArgList(
    LPWSTR*& rppwszArgs)
{
    if(rppwszArgs)
    {
        for(LONG cArgs = 0;cArgs<m_nArgs;cArgs++)
        {
            if(rppwszArgs[cArgs])
            {
                LocalFree(rppwszArgs[cArgs]);
                rppwszArgs[cArgs] = NULL;
            }

        }
        LocalFree(rppwszArgs);
        rppwszArgs = NULL;
    }
}

HRESULT CNotifyInfo::FormattedMessageInfo::InitializeArgInfo(
    ICertServerExit* pServer)
{
    HRESULT hr;
    SafeArrayEnum<BSTR> 
        saenumArgs(V_ARRAY(&m_varArgs));
    BSTR bstrArg; //no free
    LONG cArgs;
    VARIANT varValue;
    GetCertOrRequestProp pGetPropertyFunc;

    EnterCriticalSection(&m_critsectObjInit);

    if(!m_fInitialized)
    {
        if(VT_EMPTY == V_VT(&m_varArgs))
        {
            m_nArgs = 0;
        }
        else
        {
            m_nArgs = saenumArgs.GetCount();

            CSASSERT(!m_pfArgFromRequestTable);
            m_pfArgFromRequestTable = (bool*)
                LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, 
                sizeof(bool)*m_nArgs);
            _JumpIfAllocFailed(m_pfArgFromRequestTable, error);

            CSASSERT(!m_pArgType);
            m_pArgType = (LONG*)
                LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, 
                sizeof(LONG)*m_nArgs);
            _JumpIfAllocFailed(m_pArgType, error);

            VariantInit(&varValue);

            for(cArgs=0, hr = saenumArgs.Next(bstrArg);
                S_OK==hr;
                cArgs++, hr = saenumArgs.Next(bstrArg))
            {
                BSTR bstrPropertyName = bstrArg;

                VariantInit(&varValue);

                m_pfArgFromRequestTable[cArgs] = 
                    (0 == _wcsnicmp(bstrArg, 
                                    wszPROPREQUESTDOT, 
                                    wcslen(wszPROPREQUESTDOT)));

                if(m_pfArgFromRequestTable[cArgs])
                {
                    // properties from request table start with request.
                    bstrPropertyName  += wcslen(wszPROPREQUESTDOT);
                }

                pGetPropertyFunc = 
                    m_pfArgFromRequestTable[cArgs]?
                    (&(ICertServerExit::GetRequestProperty)):
                    (&(ICertServerExit::GetCertificateProperty));

                // we don't know the type of property yet, figure it out
                // by trying each type
                for(LONG cType = 0; cType<ARRAYSIZE(m_gPropTypes); cType++)
                {
                    hr = (pServer->*pGetPropertyFunc)(
                        bstrPropertyName,
                        m_gPropTypes[cType],
                        &varValue);

                    if(S_OK == hr || 
                       CERTSRV_E_PROPERTY_EMPTY == hr) // found the type
                    {
                        m_pArgType[cArgs] = m_gPropTypes[cType];
                        DBGPRINT((DBG_SS_CERTEXIT, "Property %s has type %d\n",
                            bstrPropertyName,  m_gPropTypes[cType]));
                        break;
                    }
                }

                // if not found, default will be 0 (invalid type)

                VariantClear(&varValue);
            }
        }

        m_fInitialized = true;
    }
    hr = S_OK;

error:
    if(S_OK != hr)
    {
        LOCAL_FREE(m_pfArgFromRequestTable);
        m_pfArgFromRequestTable = NULL;

        LOCAL_FREE(m_pArgType);
        m_pArgType = NULL;
    }

    LeaveCriticalSection(&m_critsectObjInit);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT
CNotifyInfo::FormattedMessageInfo::BuildArgList(
    ICertServerExit* pServer,
    LPWSTR*& rppwszArgs)
{
    HRESULT hr;
    SafeArrayEnum<BSTR> 
        saenumArgs(V_ARRAY(&m_varArgs));
    BSTR bstrArg; //no free
    LONG cArgs;
    VARIANT varValue;
    GetCertOrRequestProp pGetPropertyFunc;

    rppwszArgs = NULL;
    
    // REG_SZ, ie VT_BSTR
    if(VT_BSTR != V_VT(&m_varFormat))
    {
        hr = HRESULT_FROM_WIN32(ERROR_BADKEY);
        _JumpError(hr, error, "invalid message format");
    }

    // REG_MULTISZ, ie VT_ARRAY|VT_BSTR or VT_EMPTY if not found
    if((VT_ARRAY|VT_BSTR) != V_VT(&m_varArgs) &&
        VT_EMPTY != V_VT(&m_varArgs))
    {
        hr = HRESULT_FROM_WIN32(ERROR_BADKEY);
        _JumpError(hr, error, "invalid message arg");
    }

    if(!m_fInitialized)
    {
        hr = InitializeArgInfo(pServer);
        _JumpIfError(hr, error, "FormattedMessageInfo::InitializeArgInfo");
    }

    saenumArgs.Reset();

    if(m_nArgs>0)
    {
        rppwszArgs = (LPWSTR*) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT,
            m_nArgs*sizeof(LPWSTR));
        _JumpIfAllocFailed(rppwszArgs, error);

        for(cArgs=0, hr = saenumArgs.Next(bstrArg);
            S_OK==hr;
            cArgs++, hr = saenumArgs.Next(bstrArg))
        {
            BSTR bstrPropertyName = bstrArg;
            LONG lType = m_pArgType[cArgs];

            VariantInit(&varValue);

            if(m_pfArgFromRequestTable[cArgs])
            {
                // properties from request table start with request.
                bstrPropertyName  += wcslen(wszPROPREQUESTDOT);
            }

            pGetPropertyFunc = 
                m_pfArgFromRequestTable[cArgs]?
                (&(ICertServerExit::GetRequestProperty)):
                (&(ICertServerExit::GetCertificateProperty));

            hr = (pServer->*pGetPropertyFunc)(
                bstrPropertyName, 
                m_pArgType[cArgs],
                &varValue);

            if(S_OK != hr)
            {
                lType = PROPTYPE_STRING;
                V_VT(&varValue) = VT_BSTR;

                V_BSTR(&varValue) = SysAllocString(wszREGEXITPROPNOTFOUND);
                _JumpIfAllocFailed(V_BSTR(&varValue), error);

                hr = S_OK;
            }

            hr = ConvertToString(
                &varValue, 
                lType,
                bstrPropertyName,
                &rppwszArgs[cArgs]);
            if(S_OK != hr)
            {
                rppwszArgs[cArgs] = (LPWSTR) LocalAlloc(LMEM_FIXED, 
                    sizeof(WCHAR)*(wcslen(wszREGEXITPROPNOTFOUND)+1));
                _JumpIfAllocFailed(rppwszArgs[cArgs], error);
                
                wcscpy(rppwszArgs[cArgs], wszREGEXITPROPNOTFOUND);
            }
            VariantClear(&varValue);
        }
    }
    hr = S_OK;

error:
    if(S_OK != hr)
    {
        FreeArgList(rppwszArgs);
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CNotifyInfo::FormattedMessageInfo::ConvertToString(
    VARIANT* pvarValue,
    LONG lType,
    LPCWSTR pcwszPropertyName,
    LPWSTR* ppwszValue)
{
    HRESULT hr = E_FAIL;

    switch(lType)
    {
    case PROPTYPE_LONG:
        if(0 == _wcsicmp(pcwszPropertyName, wszPROPREQUESTSTATUSCODE))
        {
            *ppwszValue = const_cast<WCHAR*>(myGetErrorMessageText(
                V_I4(pvarValue),
                TRUE));

            if(!*ppwszValue)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = S_OK;
            }
        }
        else
        {
            hr = ConvertToStringI2I4(
                V_I4(pvarValue),
                ppwszValue);
        }
        break;
    case PROPTYPE_DATE:
        hr = ConvertToStringDATE(&V_DATE(pvarValue), TRUE, ppwszValue);
        break;
    case PROPTYPE_BINARY:
        if(0 == _wcsicmp(pcwszPropertyName,  wszPROPREQUESTRAWARCHIVEDKEY))
        {
            hr = myDupString(m_gwszArchivedKeyPresent,  ppwszValue);
        }
        else
        {
            hr = myCryptBinaryToString(
                (const BYTE*) V_BSTR(pvarValue),
                SysStringByteLen(V_BSTR(pvarValue)),
                CRYPT_STRING_BASE64,
                ppwszValue);
        }
        break;
    case PROPTYPE_STRING:
        if(0 == _wcsicmp(pcwszPropertyName, wszPROPCERTTEMPLATE))
        {
            hr = GetCertTypeFriendlyName(
                V_BSTR(pvarValue),
                ppwszValue);
        } // fall through
        
        if(S_OK != hr)
        {
            hr = ConvertToStringWSZ(
                V_BSTR(pvarValue),
                ppwszValue);
        }
        break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\default\exit.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.h
//
// Contents:    CCertExit definition
//
//---------------------------------------------------------------------------

#include <certca.h>
//#include <mapi.h>
//#include <mapix.h>
#include "resource.h"       // main symbols
#include "certxds.h"
#include <winldap.h>
#include <cdosys.h>
//#include <cdosysstr.h>
#include "rwlock.h"

using namespace CDO;

HRESULT RegGetValue(
    HKEY hkey,
    LPCWSTR pcwszValName,
    VARIANT* pvarValue);

HRESULT RegSetValue(
    HKEY hkey,
    LPCWSTR pcwszValName,
    VARIANT* pvarValue);

class CEmailNotify;

typedef HRESULT (__stdcall ICertServerExit::* GetCertOrRequestProp)(
    const BSTR strPropertyName,
    LONG PropertyType,
    VARIANT *pvarPropertyValue);

/////////////////////////////////////////////////////////////////////////////
// CNotifyInfo stores info about each type of notification, including
// title and message body formatting and recipient/sender/CC
class CNotifyInfo
{
public:
    CNotifyInfo();
    ~CNotifyInfo();

    HRESULT LoadInfoFromRegistry(
        HKEY hkeySMTP, 
        LPCWSTR pcwszSubkey);

    HRESULT BuildMessageTitle(ICertServerExit* pServer, BSTR& rbstrOut);
    HRESULT BuildMessageBody (ICertServerExit* pServer, BSTR& rbstrOut);
    
    friend class CEmailNotify;

protected:

    class FormattedMessageInfo
    {
    public:
        FormattedMessageInfo()
        {
            m_nArgs = 0;
            VariantInit(&m_varFormat);
            VariantInit(&m_varArgs);
            m_pfArgFromRequestTable = NULL;
            m_pArgType = NULL;
            m_fInitialized = false;
            InitializeCriticalSection(&m_critsectObjInit);
        }
        ~FormattedMessageInfo()
        {
            VariantClear(&m_varFormat);
            VariantClear(&m_varArgs);
            LOCAL_FREE(m_pfArgFromRequestTable);
            LOCAL_FREE(m_pArgType);
            DeleteCriticalSection(&m_critsectObjInit);
        }

        HRESULT InitializeArgInfo(ICertServerExit* pServer);

        HRESULT BuildArgList(
            ICertServerExit* pServer,
            LPWSTR*& rppwszArgs);

        void FreeArgList(
            LPWSTR*& ppwszArgs);

        HRESULT BuildFormattedString(
            ICertServerExit* pServer, 
            BSTR& bstrOut);

        HRESULT ConvertToString(
            VARIANT* pvarValue,
            LONG lType,
            LPCWSTR pcwszPropertyName,
            LPWSTR* ppwszValue);

    private:
	HRESULT _FormatStringFromArgs(
	    IN LPWSTR *ppwszArgs,
	    OPTIONAL OUT WCHAR *pwszOut,
	    IN OUT DWORD *pcwcOut);

    public:
        // "static" info about the message format, initialized once
        LONG m_nArgs;
        VARIANT m_varFormat;
        VARIANT m_varArgs;
        bool* m_pfArgFromRequestTable; // array of m_nArgs to cache if argument
                                       // is request or certificate property
        LONG* m_pArgType; // array of m_nArgs to cache argument type

        bool  m_fInitialized;
        CRITICAL_SECTION m_critsectObjInit;
        
        static LONG m_gPropTypes[4];
        static LPCWSTR m_gwszArchivedKeyPresent;
    };

    HRESULT _ConvertBSTRArrayToBSTR(VARIANT& varIn, VARIANT& varOut);

    FormattedMessageInfo m_BodyFormat;
    FormattedMessageInfo m_TitleFormat;

    VARIANT m_varFrom;
    VARIANT m_varTo;
    VARIANT m_varCC;
};

/////////////////////////////////////////////////////////////////////////////
// CEmailNotify contains all email notification functionality. It is called
// by the main exit class
class CEmailNotify
{
public:
    CEmailNotify();
    ~CEmailNotify();

    HRESULT Init(
		IN HKEY hExitKey,
		IN WCHAR const *pwszDescription);

    HRESULT Notify(
		IN DWORD lExitEvent,
		IN LONG lContext,
		IN WCHAR const *pwszDescription);
protected:

    HRESULT _CreateSMTPRegSettings(HKEY hExitKey);
    HRESULT _LoadEventInfoFromRegistry();
    HRESULT _LoadTemplateRestrictionsFromRegistry();
    HRESULT _LoadSMTPFieldsFromRegistry(Fields* pFields);
    HRESULT _LoadSMTPFieldsFromLSASecret(Fields* pFields);
    HRESULT _GetCAMailAddress(
                ICertServerExit* pServer, 
                BSTR& bstrAddress);
    HRESULT _SetField(
                Fields* pFields, 
                LPCWSTR pcwszFieldSchemaName,
                VARIANT *pvarFieldValue);
    HRESULT _GetEmailFromCertSubject(
                const VARIANT *pVarCert,
                LPWSTR *ppwszEmail);
    bool _IsRestrictedTemplate(BSTR strTemplate);
    inline bool _TemplateRestrictionsEnabled(DWORD dwEvent);
    inline DWORD _MapEventToOrd(LONG lEvent);
    inline bool _IsEventEnabled(DWORD dwEvent);
    HRESULT _InitCDO();

    enum            { m_gcEvents = 7 };
    CNotifyInfo     m_NotifyInfoArray[m_gcEvents];
    HKEY            m_hkeySMTP;
    DWORD           m_dwEventFilter;
    BSTR            m_bstrCAMailAddress;
    IConfiguration  *m_pICDOConfig;
    CReadWriteLock  m_rwlockCDOConfig;
    bool            m_fReloadCDOConfig;
    VARIANT         m_varTemplateRestrictions;

    static LPCWSTR  m_pcwszEventRegKeys[m_gcEvents];
};

// begin_sdksample

HRESULT
GetServerCallbackInterface(
    OUT ICertServerExit** ppServer,
    IN LONG Context);

HRESULT
exitGetProperty(
    IN ICertServerExit *pServer,
    IN BOOL fRequest,
    IN WCHAR const *pwszPropertyName,
    IN DWORD PropType,
    OUT VARIANT *pvarOut);

/////////////////////////////////////////////////////////////////////////////
// certexit

class CCertExit: 
    public CComDualImpl<ICertExit2, &IID_ICertExit2, &LIBID_CERTEXITLib>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CCertExit, &CLSID_CCertExit>
{
public:
    CCertExit() 
    { 
        m_strDescription = NULL;
        m_strCAName = NULL;
        m_pwszRegStorageLoc = NULL;
        m_hExitKey = NULL;
        m_dwExitPublishFlags = 0;
        m_cCACert = 0;
    }
    ~CCertExit();

BEGIN_COM_MAP(CCertExit)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertExit)
    COM_INTERFACE_ENTRY(ICertExit2)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertExit) 

DECLARE_REGISTRY(
    CCertExit,
    wszCLASS_CERTEXIT TEXT(".1"),
    wszCLASS_CERTEXIT,
    IDS_CERTEXIT_DESC,
    THREADFLAGS_BOTH)

    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // ICertExit
public:
    STDMETHOD(Initialize)( 
            /* [in] */ BSTR const strConfig,
            /* [retval][out] */ LONG __RPC_FAR *pEventMask);

    STDMETHOD(Notify)(
            /* [in] */ LONG ExitEvent,
            /* [in] */ LONG Context);

    STDMETHOD(GetDescription)( 
            /* [retval][out] */ BSTR *pstrDescription);

// ICertExit2
public:
    STDMETHOD(GetManageModule)(
		/* [out, retval] */ ICertManageModule **ppManageModule);

private:
    HRESULT _NotifyNewCert(IN LONG Context);

    HRESULT _NotifyCRLIssued(IN LONG Context);

    HRESULT _WriteCertToFile(
	    IN ICertServerExit *pServer,
	    IN BYTE const *pbCert,
	    IN DWORD cbCert);

    HRESULT _ExpandEnvironmentVariables(
	    IN WCHAR const *pwszIn,
	    OUT WCHAR *pwszOut,
	    IN DWORD cwcOut);

    // Member variables & private methods here:
    BSTR           m_strDescription;
    BSTR           m_strCAName;
    LPWSTR         m_pwszRegStorageLoc;
    HKEY           m_hExitKey;
    DWORD          m_dwExitPublishFlags;
    DWORD          m_cCACert;

    // end_sdksample

    CEmailNotify m_EmailNotifyObj; // email notification support
    
    // begin_sdksample
};
// end_sdksample
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\exitsql\atl.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        atl.cpp
//
// Contents:    ActiveX Template Library COM support
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\default\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#define __DIR__		"default"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifndef MAXDWORD
# define MAXDWORD MAXULONG
#endif

#include <windows.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include "tfc.h"
#include <certsrv.h>
#include "certlib.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\default\module.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.h
//
// Contents:    CCertManageExitModule definition
//
//---------------------------------------------------------------------------

#include "certxds.h"
#include "resource.h"       // main symbols


class CCertManageExitModule: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTEXITLib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManageExitModule, &CLSID_CCertManageExitModule>
{
public:
    CCertManageExitModule() {m_hWnd = NULL;}
    ~CCertManageExitModule() {}

BEGIN_COM_MAP(CCertManageExitModule)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManageExitModule) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// UNDONE UNDONE
DECLARE_REGISTRY(
    CCertManageExitModule,
    wszCLASS_CERTMANAGEEXITMODULE TEXT(".1"),
    wszCLASS_CERTMANAGEEXITMODULE,
    IDS_CERTMANAGEEXITMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:
    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);
        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);

    HWND m_hWnd;

private:
    HRESULT GetAdmin(ICertAdmin2 **ppAdmin);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\default\module.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.cpp
//
// Contents:    Cert Server Exit Module implementation
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

#include <commctrl.h>
#include "module.h"
#include "exit.h"
#include "cslistvw.h"


#include <ntverp.h>
#include <common.ver>
#include "csdisp.h"

// helpids
#include "csmmchlp.h"

#define __dwFILE__	__dwFILE_EXIT_DEFAULT_MODULE_CPP__


#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

extern HINSTANCE g_hInstance;

STDMETHODIMP
CCertManageExitModule::GetProperty(
    /* [in] */ const BSTR, // strConfig
    /* [in] */ BSTR, // strStorageLocation
    /* [in] */ BSTR strPropertyName,
    /* [in] */ LONG, // dwFlags
    /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    UINT uiStr = 0;
    HRESULT hr;

    if (NULL == pvarProperty)
    {
        hr = E_POINTER;
        _PrintError(hr, "NULL parm");
        return hr;
    }
    VariantInit(pvarProperty);

    if (NULL == strPropertyName)
    {
        hr = S_FALSE;
        _PrintError(hr, "NULL in parm");
        return hr;
    }

    // load string from resource
    WCHAR szStr[MAX_PATH];
    szStr[0] = L'\0';

    if (0 == mylstrcmpiL(strPropertyName, wszCMM_PROP_FILEVER))
    {
        LPWSTR pwszTmp = NULL;
        if (!ConvertSzToWsz(&pwszTmp, VER_FILEVERSION_STR, -1))
            return myHLastError();
        wcsncpy(szStr, pwszTmp, MAX_PATH);
        LocalFree(pwszTmp);
    }
    else if (0 == mylstrcmpiL(strPropertyName, wszCMM_PROP_PRODUCTVER))
    {
        LPWSTR pwszTmp = NULL;
        if (!ConvertSzToWsz(&pwszTmp, VER_PRODUCTVERSION_STR, -1))
            return myHLastError();
        wcsncpy(szStr, pwszTmp, MAX_PATH);
        LocalFree(pwszTmp);
    }
    else
    {
      if (0 == LSTRCMPIS(strPropertyName, wszCMM_PROP_NAME))
          uiStr = IDS_MODULE_NAME;
      else if (0 == LSTRCMPIS(strPropertyName, wszCMM_PROP_DESCRIPTION))
          uiStr = IDS_MODULE_DESCR;
      else if (0 == LSTRCMPIS(strPropertyName, wszCMM_PROP_COPYRIGHT))
          uiStr = IDS_MODULE_COPYRIGHT;
      else
          return S_FALSE;  
      LoadString(g_hInstance, uiStr, szStr, ARRAYLEN(szStr));
    }

    szStr[MAX_PATH-1] = L'\0';

    pvarProperty->bstrVal = SysAllocString(szStr);
    if (NULL == pvarProperty->bstrVal)
        return E_OUTOFMEMORY;
    myRegisterMemFree(pvarProperty->bstrVal, CSM_SYSALLOC);  // this mem owned by caller


    pvarProperty->vt = VT_BSTR;

    return S_OK;
}
        
STDMETHODIMP 
CCertManageExitModule::SetProperty(
    /* [in] */ const BSTR, // strConfig
    /* [in] */ BSTR, // strStorageLocation
    /* [in] */ BSTR strPropertyName,
    /* [in] */ LONG, // dwFlags
    /* [in] */ VARIANT const __RPC_FAR *pvalProperty)
{
    HRESULT hr;

    if (NULL == strPropertyName)
    {
        hr = S_FALSE;
        _PrintError(hr, "NULL in parm");
        return hr;
    }

    if (NULL == pvalProperty)
    {
        hr = E_POINTER;
        _PrintError(hr, "NULL parm");
        return hr;
    }

     if (0 == LSTRCMPIS(strPropertyName, wszCMM_PROP_DISPLAY_HWND))
     {
         if (pvalProperty->vt != VT_BSTR)
              return E_INVALIDARG;
         
         if (SysStringByteLen(pvalProperty->bstrVal) != sizeof(HWND))
              return E_INVALIDARG;

         // the value is stored as bytes in the bstr itself, not the bstr ptr
         m_hWnd = *(HWND*)pvalProperty->bstrVal;
         return S_OK;
     }
     
     return S_FALSE;
}

INT_PTR CALLBACK WizPage2DlgProc(
  HWND hwnd,  
  UINT uMsg,     
  WPARAM  wParam,
  LPARAM  lParam);

struct EXIT_CONFIGSTRUCT
{
    EXIT_CONFIGSTRUCT() :
        pstrConfig(NULL),
        CAType(ENUM_UNKNOWN_CA),
        pCertAdmin(NULL),
        fUseDS(FALSE),
        Flags(),
        dwPageModified(0) {}
    ~EXIT_CONFIGSTRUCT()
    { 
        if(pCertAdmin)
        {
            pCertAdmin->Release();
            pCertAdmin = NULL;
        }
    }
    const BSTR*  pstrConfig;
    CString      strSanitizedConfig;
    ENUM_CATYPES CAType;
    BOOL         fUseDS;
    ICertAdmin2  *pCertAdmin;
    LONG         Flags;

    DWORD        dwPageModified;
};
typedef EXIT_CONFIGSTRUCT *PEXIT_CONFIGSTRUCT;
        

void MessageBoxWarnReboot(HWND hwndDlg)
{
    WCHAR szText[MAX_PATH], szTitle[MAX_PATH];

    LoadString(g_hInstance, IDS_MODULE_NAME, szTitle, ARRAYLEN(szTitle));
    LoadString(g_hInstance, IDS_WARNING_REBOOT, szText, ARRAYLEN(szText));
    MessageBox(hwndDlg, szText, szTitle, MB_OK|MB_ICONINFORMATION);
}

void MessageBoxNoSave(HWND hwndDlg)
{
    WCHAR szText[MAX_PATH], szTitle[MAX_PATH];

    LoadString(g_hInstance, IDS_MODULE_NAME, szTitle, ARRAYLEN(szTitle));
    LoadString(g_hInstance, IDS_WARNING_NOSAVE, szText, ARRAYLEN(szText));
    MessageBox(hwndDlg, szText, szTitle, MB_OK|MB_ICONINFORMATION);
}

// dwPageModified
#define PAGE1 (0x1)
#define PAGE2 (0x2)
        
STDMETHODIMP
CCertManageExitModule::Configure( 
    /* [in] */ const BSTR strConfig,
    /* [in] */ BSTR, // strStorageLocation
    /* [in] */ LONG dwFlags)
{
    HRESULT hr;
    EXIT_CONFIGSTRUCT sConfig;
    VARIANT varValue;
    VariantInit(&varValue);
    ICertServerExit *pServer = NULL;
    BOOL fLocal;
    LPWSTR szMachine = NULL;
    CAutoLPWSTR autoszMachine, autoszCAName, autoszSanitizedCAName;

    hr = myIsConfigLocal(strConfig, &szMachine, &fLocal);
    _JumpIfError(hr, Ret, "myIsConfigLocal");

    // use callbacks for info
    hr = GetServerCallbackInterface(&pServer, 0);    // no context: 0
    _JumpIfError(hr, Ret, "GetServerCallbackInterface");

    // we need to find out who we're running under
    hr = exitGetProperty(
		    pServer,
		    FALSE,
		    wszPROPCATYPE,
		    PROPTYPE_LONG,
		    &varValue);
    _JumpIfError(hr, Ret, "exitGetCertificateProperty: wszPROPCATYPE");

    hr = GetAdmin(&sConfig.pCertAdmin);
    _JumpIfError(hr, Ret, "GetAdmin");

    sConfig.CAType = (ENUM_CATYPES)varValue.lVal;
    VariantClear(&varValue);

    hr = exitGetProperty(
		    pServer,
		    FALSE,
		    wszPROPUSEDS,
		    PROPTYPE_LONG,
		    &varValue);
    _JumpIfError(hr, Ret, "exitGetCertificateProperty: wszPROPUSEDS");

    sConfig.fUseDS = (BOOL)varValue.lVal;
    VariantClear(&varValue);

    sConfig.pstrConfig = &strConfig;
    sConfig.Flags = dwFlags;

    hr = mySplitConfigString(
        *sConfig.pstrConfig,
        &autoszMachine,
        &autoszCAName);
    _JumpIfErrorStr(hr, Ret, "mySanitizeName", *sConfig.pstrConfig);

    hr = mySanitizeName(autoszCAName, &autoszSanitizedCAName);
    _JumpIfErrorStr(hr, Ret, "mySanitizeName", autoszCAName);
    
    sConfig.strSanitizedConfig = autoszMachine;
    sConfig.strSanitizedConfig += L"\\";
    sConfig.strSanitizedConfig += autoszSanitizedCAName;

    PROPSHEETPAGE page[1];
    ZeroMemory(&page[0], sizeof(PROPSHEETPAGE));
    page[0].dwSize = sizeof(PROPSHEETPAGE);
    page[0].dwFlags = PSP_DEFAULT;
    page[0].hInstance = g_hInstance;
    page[0].lParam = (LPARAM)&sConfig;
    page[0].pszTemplate = MAKEINTRESOURCE(IDD_EXITPG2);
    page[0].pfnDlgProc = WizPage2DlgProc;


    PROPSHEETHEADER sSheet;
    ZeroMemory(&sSheet, sizeof(PROPSHEETHEADER));
    sSheet.dwSize = sizeof(PROPSHEETHEADER);
    sSheet.dwFlags = PSH_PROPSHEETPAGE | PSH_PROPTITLE;
    sSheet.hwndParent = m_hWnd;
    sSheet.pszCaption = MAKEINTRESOURCE(IDS_MODULE_NAME);
    sSheet.nPages = ARRAYLEN(page);
    sSheet.ppsp = page;

    
    // finally, invoke the modal sheet
    INT_PTR iRet;
    iRet = ::PropertySheet(&sSheet);

Ret:
    if (szMachine)
        LocalFree(szMachine);

    if (pServer)
        pServer->Release();

    return S_OK;
}


void mySetModified(HWND hwndPage, EXIT_CONFIGSTRUCT* psConfig)
{
    if (psConfig->dwPageModified != 0)
    {
        PropSheet_Changed( ::GetParent(hwndPage), hwndPage); 
    }
    else
    {
        PropSheet_UnChanged( ::GetParent(hwndPage), hwndPage); 
    }
}


INT_PTR CALLBACK WizPage2DlgProc(
  HWND hwndDlg,  
  UINT uMsg,     
  WPARAM wParam,
  LPARAM lParam)
{
    EXIT_CONFIGSTRUCT* psConfig;
    BOOL fReturn = FALSE;
    HRESULT hr;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            PROPSHEETPAGE* ps = (PROPSHEETPAGE *) lParam;
            psConfig = (EXIT_CONFIGSTRUCT*)ps->lParam;

            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM)psConfig);

            DWORD dwPublish;
            CAutoBSTR bstrConfig, bstrSubkey, bstrValue;

            bstrConfig = SysAllocString(psConfig->strSanitizedConfig.GetBuffer());
            if(NULL == (BSTR)bstrConfig)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            bstrSubkey = SysAllocString(
                                wszREGKEYEXITMODULES 
                                L"\\" 
                                wszMICROSOFTCERTMODULE_PREFIX 
                                wszCERTEXITMODULE_POSTFIX);
            if(NULL == (BSTR)bstrSubkey)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            bstrValue = SysAllocString(wszREGCERTPUBLISHFLAGS);
            if(NULL == (BSTR)bstrValue)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            VARIANT var;
            VariantInit(&var);
            hr = psConfig->pCertAdmin->GetConfigEntry(
                    bstrConfig,
                    bstrSubkey,
                    bstrValue,
                    &var);
            if(S_OK!=hr)
                break;

            dwPublish = V_I4(&var);

            // if disposition includes Issue
            if (dwPublish & EXITPUB_FILE)
            {
                SendMessage(GetDlgItem(hwndDlg, IDC_CHECK_FILE), BM_SETCHECK, TRUE, BST_CHECKED);
            }

            if (CMM_READONLY & psConfig->Flags)
            {
                DBGPRINT((DBG_SS_CERTPOL, "Read-only mode\n"));
                EnableWindow(GetDlgItem(hwndDlg, IDC_CHECK_FILE), FALSE);
            }

            psConfig->dwPageModified &= ~PAGE2; // we're virgin
            mySetModified(hwndDlg, psConfig);

            // no other work to be done
            fReturn = TRUE;
            break;
        }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_EXITPG2);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_EXITPG2);
        break;
    }
    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam) -> code)
        {
        case PSN_APPLY:
            {
                // grab our LParam
                psConfig = (EXIT_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                if (psConfig->dwPageModified & PAGE2)
                {
                    DWORD dwCheckState, dwRequestDisposition=0;
                    dwCheckState = (DWORD)SendMessage(GetDlgItem(hwndDlg, IDC_CHECK_FILE), BM_GETCHECK, 0, 0);
                    if (dwCheckState == BST_CHECKED)
                        dwRequestDisposition |= EXITPUB_FILE;

                    CAutoBSTR bstrConfig, bstrSubkey, bstrValue;

                    bstrConfig = SysAllocString(psConfig->strSanitizedConfig.GetBuffer());
                    if(NULL == (BSTR)bstrConfig)
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                    bstrSubkey = SysAllocString(
                                        wszREGKEYEXITMODULES 
                                        L"\\" 
                                        wszMICROSOFTCERTMODULE_PREFIX 
                                        wszCERTEXITMODULE_POSTFIX);
                    if(NULL == (BSTR)bstrSubkey)
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                    bstrValue = SysAllocString(wszREGCERTPUBLISHFLAGS);
                    if(NULL == (BSTR)bstrValue)
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                    VARIANT var;
                    VariantInit(&var);
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = dwRequestDisposition;

                    hr = psConfig->pCertAdmin->SetConfigEntry(
                            bstrConfig,
                            bstrSubkey,
                            bstrValue,
                            &var);
                    if(S_OK!=hr)
                    {
                        MessageBoxNoSave(hwndDlg);
                    }
                    else
                    {
                        MessageBoxWarnReboot(NULL);
                        psConfig->dwPageModified &= ~PAGE2;
                    }
                }
            }
            break;
        case PSN_RESET:
            {
                // grab our LParam
                psConfig = (EXIT_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                psConfig->dwPageModified &= ~PAGE2;
                mySetModified(hwndDlg, psConfig);
            }
            break;
        default:
            break;
        }
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CHECK_FILE:
            {
                // grab our LParam
                psConfig = (EXIT_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                if (BN_CLICKED == HIWORD(wParam))
                {
                    psConfig->dwPageModified |= PAGE2;
                    mySetModified(hwndDlg, psConfig);
                }
            }
            break;
        default:
            break;
        }
    default:
        break;
    }

    return fReturn;
}

HRESULT CCertManageExitModule::GetAdmin(ICertAdmin2 **ppAdmin)
{
    HRESULT hr = S_OK, hr1;
    BOOL fCoInit = FALSE;

    hr1 = CoInitialize(NULL);
    if ((S_OK == hr1) || (S_FALSE == hr1))
        fCoInit = TRUE;

    // create interface, pass back
    hr = CoCreateInstance(
			CLSID_CCertAdmin,
			NULL,		// pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertAdmin2,
			(void **) ppAdmin);
    _PrintIfError(hr, "CoCreateInstance");

    if (fCoInit)
        CoUninitialize();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certweb\certsrck.inc ===
﻿<%' CODEPAGE=65001 'UTF-8%>
<%' certsrck.inc - (CERT)srv web - (S)cript: (R)equest-(C)ooc(K)ie management
  ' Copyright (C) Microsoft Corporation, 1998 - 1999 %>
<%
	' Format of our cookie:
	' '[' <ReqID> ',' <TargetStoreFlags> ',' <SaveCert> ',' <FriendlyType> ']'...
	Const FIELD_REQID=0
	Const FIELD_TARGETSTOREFLAGS=1
	Const FIELD_SAVECERT=2
	Const FIELD_FRIENDLYTYPE=3
	Const NUM_FIELDS=4
	Const REQUEST_COOKIE_NAME="Requests"
	Dim nReqId

	' Look up the requests in the cookie, and return an array of 'request' arrays
	' The returned requests are all encoded using Server.HTMLEncode. Thus, the
	' text may have been altered for browser display against CSS attacks.
	Function GetRequests(bEncodeRequests)

		' Get the cookie
		Dim sRequests
		sRequests=Request.Cookies(REQUEST_COOKIE_NAME)

		' If the cookie was never set, return an empty array
		If ""=sRequests Then
			GetRequests=Null
			Exit Function
		End If

        ' If we requested that the requests be encoded, do so now:
        If True=bEncodeRequests Then
            sRequests = Server.HTMLEncode(sRequests)
        End If    

		Dim nRequests
		Dim rgRequests()
		nRequests=0

		' Loop through all the requests in the string
		Dim nSplitIndex
		Do
			' Find the next request
			nSplitIndex=InStr(sRequests,"]")
			If 0=nSplitIndex Then
				Exit Do
			End If

			' Split this Request off the string
			Dim sElem
			sElem=Mid(sRequests, 2, nSplitIndex-2)
            sRequests=Mid(sRequests, nSplitIndex+1)
            
			' Spit this request apart
			Dim rgElem
			rgElem=Split(sElem, ",")

			' Safety check
			If NUM_FIELDS-1<>UBound(rgElem) Then
				' Cookie is corrupt
				nRequests=0
				Exit Do
			End If

			' Add this array to our array of requests
			ReDim Preserve rgRequests(nRequests)
			rgRequests(nRequests)=rgElem
			nRequests=nRequests+1

			' safety check for testing
			'If nRequests>25 Then
			'	Err.Raise 6
			'End If

		Loop ' End string-parsing loop
	
		' if there was an error parsing the cookie, just assume it was empty.
		If 0=nRequests Then
			GetRequests=Null
		Else
			GetRequests=rgRequests
		End If

	End Function 

	' Combine a requests-array into a single string and set it as a cookie
	Sub PutRequests(rgRequests)
		Dim sCookie, sRequests, nIndex
		sRequests=""

		' check for the empty list
		If IsNull(rgRequests) Then
			' the list is empty
			'   do nothing
			sRequests="-" ' Lynx won't set an empty cookie, so set an invalid one
		Else
			' the list is not empty
			' build a string for each request and concatenate to make cookie
			For nIndex=0 To UBound(rgRequests)
				sRequests=sRequests & "[" & _
					rgRequests(nIndex)(FIELD_REQID) & "," & _
					rgRequests(nIndex)(FIELD_TARGETSTOREFLAGS) & "," & _
					rgRequests(nIndex)(FIELD_SAVECERT) & "," & _
					rgRequests(nIndex)(FIELD_FRIENDLYTYPE) & "]"
			Next
		End If

		' Set the cookie
		Response.Cookies(REQUEST_COOKIE_NAME)=sRequests

		' Set the expiration date
		Response.Cookies(REQUEST_COOKIE_NAME).Expires=Now+nPendingTimeoutDays

		' Set the path
		Response.Cookies(REQUEST_COOKIE_NAME).Path="/certsrv"

	End Sub

	' Remove a given request from the requests cookie
	Sub RemoveReq(nReqID)
		' get the array of requests
		Dim rgRequests
		rgRequests=GetRequests(False)

		' if the cookie is empty, just ignore
		If IsNull(rgRequests) Then
			Exit Sub
		End If

		' find the request
		Dim nIndex
		Dim nFoundIndex
		nFoundIndex=-1
		For nIndex=0 To UBound(rgRequests)
			If nReqID=rgRequests(nIndex)(FIELD_REQID) Then
				nFoundIndex=nIndex
				Exit For
			End If
		Next

		If -1=nFoundIndex Then
			' request not found, probably a reload and it was deleted already
			'   do nothing
		Else
			' remove the request:
			If 0=UBound(rgRequests) Then
				' this is the last request
				' removing it leaves an empty list
				rgRequests=Null
			Else
				' Not the last request, so shuffle down
				' (this is not the most efficient, but it keeps the requests in order)
				For nIndex=nFoundIndex To UBound(rgRequests)-1
					rgRequests(nIndex)=rgRequests(nIndex+1)
				Next

				' shrink the array
				ReDim Preserve rgRequests(UBound(rgRequests)-1)
			End If

			' set the cookie
			PutRequests rgRequests
		End If
	End Sub

	' Add the current request to the request cookie
	Sub AddRequest
		' build a request object for this request
		Dim rgNewReq(3) 'NUM_FIELDS-1
		nReqId=ICertRequest.GetRequestId()
		rgNewReq(FIELD_REQID)=nReqId
		rgNewReq(FIELD_TARGETSTOREFLAGS)=Request.Form("TargetStoreFlags")
		rgNewReq(FIELD_SAVECERT)=Request.Form("SaveCert")
		rgNewReq(FIELD_FRIENDLYTYPE)=Request.Form("FriendlyType")

		' prevent special split characters from being placed in the string
		' by converting them to spaces
		rgNewReq(FIELD_FRIENDLYTYPE)=Replace(rgNewReq(FIELD_FRIENDLYTYPE), ",", " ")
		rgNewReq(FIELD_FRIENDLYTYPE)=Replace(rgNewReq(FIELD_FRIENDLYTYPE), "]", " ")

		' add it to the list
		Dim rgRequests
		rgRequests=GetRequests(False)
		If IsNull(rgRequests) Then 
			' cookie has never been set
			ReDim rgRequests(0)
		Else
			' save old requests in cookie
			ReDim Preserve rgRequests(UBound(rgRequests)+1)
		End If
		rgRequests(UBound(rgRequests))=rgNewReq
		PutRequests rgRequests
	End Sub
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\default\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certexit.rc
//
#define IDS_CERTEXIT_DESC               1
#define IDS_CERTMANAGEEXITMODULE_DESC   2
#define IDS_NO_CONFIGURABLE_DATA        3
#define IDS_MAPI_SUBJECT        	4
#define IDS_MAPI_UNKNOWN        	5

#define IDC_CHECK1                      201
#define IDC_CHECK_FILE                  201
#define IDC_BUTTON1                     202
#define IDC_REMOVE_CRL                  202
#define IDC_BUTTON2                     203
#define IDC_ADD_CRL                     203
#define IDC_EDIT1                       204
#define IDC_LIST1                       204
#define IDC_EDITURL                     204
#define IDD_EXITPG2                     609

#define IDS_MODULE_NAME                 611
#define IDS_MODULE_DESCR                612
#define IDS_MODULE_COPYRIGHT            613
#define IDS_WARNING_REBOOT              616
#define IDS_INVALID_PREFIX              617
#define IDS_WARNING_NOSAVE              618
#define IDS_INVALID_TOKEN               619
#define IDS_INVALID_ENCODING            620


#define IDC_CRL_LIST                    737
#define IDB_CHECKLIST                   738
#define IDC_STATIC                      -1

#define IDS_TITLEFORMAT_ISSUED          1100
#define IDS_BODYFORMAT_ISSUED           1101
#define IDS_TITLEFORMAT_PENDING         1102
#define IDS_BODYFORMAT_PENDING          1103
#define IDS_TITLEFORMAT_DENIED          1104
#define IDS_BODYFORMAT_DENIED           1105
#define IDS_TITLEFORMAT_REVOKED         1106
#define IDS_BODYFORMAT_REVOKED          1107
#define IDS_TITLEFORMAT_CRLISSUED       1108
#define IDS_BODYFORMAT_CRLISSUED        1109
#define IDS_TITLEFORMAT_SHUTDOWN        1110
#define IDS_BODYFORMAT_SHUTDOWN         1111
#define IDS_TITLEFORMAT_STARTUP         1112
#define IDS_BODYFORMAT_STARTUP          1113
#define IDS_TITLEFORMAT_RETRIEVEPENDING	1114
#define IDS_BODYFORMAT_RETRIEVEPENDING	1115


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\exitsql\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\$(TARGETNAME).res:	$(O)\$(TARGETNAME).tlb

SOURCE_DIR=..\..\celib

$(NTTARGETFILE0):	$(SOURCE_DIR)\$(@F)
    copy $(SOURCE_DIR)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\exitsql\exit.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.h
//
// Contents:    CCertExitSQLSample definition
//
//---------------------------------------------------------------------------

#include "exitsql.h"
#include "resource.h"       // main symbols

#include <sql.h>
#include <sqlext.h>
#include <sqltypes.h>

#define wszREG_EXITSQL_DSN L"DatabaseDSN"
#define wszREG_EXITSQL_USER L"DatabaseUser"
#define wszREG_EXITSQL_PASSWORD L"DatabasePassword"

HRESULT
GetServerCallbackInterface(
    OUT ICertServerExit** ppServer,
    IN LONG Context);

/////////////////////////////////////////////////////////////////////////////
// certexit

class CCertExitSQLSample: 
    public CComDualImpl<ICertExit, &IID_ICertExit, &LIBID_CERTEXITSAMPLELib>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CCertExitSQLSample, &CLSID_CCertExitSQLSample>
{
public:
    CCertExitSQLSample() 
    { 
	m_henv = SQL_NULL_HENV;
	m_hdbc1 = SQL_NULL_HDBC;   

        m_strCAName = NULL;
    }
    ~CCertExitSQLSample();

BEGIN_COM_MAP(CCertExitSQLSample)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertExit)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertExitSQLSample) 

DECLARE_REGISTRY(
    CCertExitSQLSample,
    wszCLASS_CERTEXITSAMPLE TEXT(".1"),
    wszCLASS_CERTEXITSAMPLE,
    IDS_CERTEXIT_DESC,
    THREADFLAGS_BOTH)

    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // ICertExit
public:
    STDMETHOD(Initialize)( 
            /* [in] */ BSTR const strConfig,
            /* [retval][out] */ LONG __RPC_FAR *pEventMask);

    STDMETHOD(Notify)(
            /* [in] */ LONG ExitEvent,
            /* [in] */ LONG Context);

    STDMETHOD(GetDescription)( 
            /* [retval][out] */ BSTR *pstrDescription);

private:
    HRESULT _NotifyNewCert(IN LONG Context);

	HRESULT ExitModSetODBCProperty(
	IN DWORD dwReqId,
	IN LPWSTR pszCAName,
	IN LPWSTR pszRequester,
	IN LPWSTR pszCertType,
	IN FILETIME* pftBefore,
	IN FILETIME* pftAfter);


    // Member variables & private methods here:
    BSTR           m_strCAName;

	SQLHENV        m_henv;
	SQLHDBC        m_hdbc1;     
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\exitsql\exitsql.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exitsql.cpp
//
// Contents:    Cert Server Exit Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "celib.h"
#include "exit.h"
#include "module.h"

CComModule _Module;
HINSTANCE g_hInstance;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertExitSQLSample, CCertExitSQLSample)
    OBJECT_ENTRY(CLSID_CCertManageExitModuleSQLSample, CCertManageExitModuleSQLSample)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    g_hInstance = hInstance;
	    _Module.Init(ObjectMap, hInstance);
	    DisableThreadLibraryCalls(hInstance);
	    break;

        case DLL_PROCESS_DETACH:
	    _Module.Term();
            break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return(_Module.GetClassObject(rclsid, riid, ppv));
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\exitsql\module.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.cpp
//
// Contents:    Cert Server Exit Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>

#include "celib.h"
#include "module.h"
#include "exit.h"

extern HINSTANCE g_hInstance;
INT_PTR CALLBACK ExitSQLDlgProc(
  HWND hwndDlg,  
  UINT uMsg,     
  WPARAM wParam,
  LPARAM lParam);



HRESULT
GetMachineFromConfig(
    IN WCHAR const *pwszConfig,
    OUT WCHAR **ppwszMachine)
{
    HRESULT hr;
    WCHAR *pwszMachine = NULL;
    WCHAR const *pwsz;
    DWORD cwc;


    if (NULL != ppwszMachine)
    {
		*ppwszMachine = NULL;
    }
	
    while (L'\\' == *pwszConfig)
    {
		pwszConfig++;
    }
    pwsz = wcschr(pwszConfig, L'\\');

    if (NULL != pwsz)
    {
		cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszConfig);
    }
    else
    {
		cwc = wcslen(pwszConfig);
    }
    pwszMachine = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszMachine)
    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszMachine, pwszConfig, cwc * sizeof(WCHAR));
    pwszMachine[cwc] = L'\0';
	
    if (NULL != ppwszMachine)
    {
		*ppwszMachine = pwszMachine;
		pwszMachine = NULL;
    }
    hr = S_OK;
	
error:
    if (NULL != pwszMachine)
    {
		LocalFree(pwszMachine);
    }
    return(hr);
}


STDMETHODIMP
CCertManageExitModuleSQLSample::GetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    LPWSTR szStr = NULL;

    if (pvarProperty == NULL)
        return E_POINTER;

    VariantInit(pvarProperty);

    if (strPropertyName == NULL)
        return S_FALSE;

    if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_NAME))
        szStr = wsz_SAMPLE_NAME;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_DESCRIPTION))
        szStr = wsz_SAMPLE_DESCRIPTION;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_COPYRIGHT))
        szStr = wsz_SAMPLE_COPYRIGHT;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_FILEVER))
        szStr = wsz_SAMPLE_FILEVER;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_PRODUCTVER))
        szStr = wsz_SAMPLE_PRODUCTVER;
    else
        return S_FALSE;  

    pvarProperty->bstrVal = SysAllocString(szStr);
    if (NULL == pvarProperty->bstrVal)
        return E_OUTOFMEMORY;

    pvarProperty->vt = VT_BSTR;

    return S_OK;
}


        
STDMETHODIMP 
CCertManageExitModuleSQLSample::SetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty)
{
     if (0 == lstrcmpi(strPropertyName, wszCMM_PROP_DISPLAY_HWND))
     {
         if (pvarProperty->vt != VT_BSTR)
              return E_INVALIDARG;
         
         if (SysStringByteLen(pvarProperty->bstrVal) != sizeof(HWND))
              return E_INVALIDARG;

         // the value is stored as bytes in the bstr itself, not the bstr ptr
         m_hWnd = *(HWND*)pvarProperty->bstrVal;
         return S_OK;
     }

     return S_FALSE;
}
        

typedef struct _EXITSQL_CONFIGSTRUCT
{
    HKEY         hkeyStorageLocation;
    LONG         Flags;

    BOOL	 fPageModified;
} EXITSQL_CONFIGSTRUCT, *PEXITSQL_CONFIGSTRUCT;


STDMETHODIMP
CCertManageExitModuleSQLSample::Configure( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG Flags)
{
    HRESULT hr;
    LPWSTR szMachine = NULL;
    HKEY hkeyHKLM = NULL;
    DWORD dwDisposition;

    EXITSQL_CONFIGSTRUCT sConfig;
    ZeroMemory(&sConfig, sizeof(EXITSQL_CONFIGSTRUCT));

    hr = GetMachineFromConfig(strConfig, &szMachine);
    _JumpIfError(hr, Ret, "GetMachineFromConfig");


	// UNDONE: only do this if remote
	hr = RegConnectRegistry(
			szMachine,
			HKEY_LOCAL_MACHINE,
			&hkeyHKLM);
        _JumpIfError(hr, Ret, "RegConnectRegistry");

    // open storage location: write perms if possible
    hr = RegCreateKeyEx(
        hkeyHKLM,
        strStorageLocation,
        0,
        NULL,
        0,
        KEY_READ | KEY_WRITE,
        NULL,
        &sConfig.hkeyStorageLocation,
        &dwDisposition);
    if (hr != S_OK)
    {
        hr = RegOpenKeyEx(
            hkeyHKLM,
            strStorageLocation,
            0,
            KEY_READ,       // fallback: read-only
            &sConfig.hkeyStorageLocation);
        if (hr != ERROR_SUCCESS)
            goto Ret;
    }

    sConfig.Flags = Flags;

    PROPSHEETPAGE page;
    ZeroMemory(&page, sizeof(PROPSHEETPAGE));
    page.dwSize = sizeof(PROPSHEETPAGE);
    page.dwFlags = PSP_DEFAULT;
    page.hInstance = g_hInstance;
    page.lParam = (LPARAM)&sConfig;
    

    page.pszTemplate = MAKEINTRESOURCE(IDD_EXITSQL_PROPERTIES);
    page.pfnDlgProc = ExitSQLDlgProc;


    PROPSHEETHEADER sSheet;
    ZeroMemory(&sSheet, sizeof(PROPSHEETHEADER));
    sSheet.dwSize = sizeof(PROPSHEETHEADER);
    sSheet.dwFlags = PSH_PROPSHEETPAGE | PSH_PROPTITLE;
    sSheet.hwndParent = m_hWnd;
    sSheet.hInstance = g_hInstance;
    sSheet.pszCaption = L"";
    sSheet.nPages = 1;
    sSheet.ppsp = &page;

    
    // finally, invoke the modal sheet
    INT_PTR iRet;
    iRet = ::PropertySheet(&sSheet);

    if ((iRet > 0) && (sConfig.fPageModified))   // successful modification
    {
		MessageBoxW(NULL, L"This action requires the Certificate Service to be restarted before taking effect.", L"Applying ExitSQL Settings", MB_OK|MB_ICONINFORMATION);
    }

Ret:
    if (sConfig.hkeyStorageLocation)
        RegCloseKey(sConfig.hkeyStorageLocation);

    if (szMachine)
        LocalFree(szMachine);

    if (hkeyHKLM)
        RegCloseKey(hkeyHKLM);

    return S_OK;
}



INT_PTR CALLBACK ExitSQLDlgProc(
  HWND hwndDlg,  
  UINT uMsg,     
  WPARAM wParam,
  LPARAM lParam)
{
    EXITSQL_CONFIGSTRUCT* psConfig;
    BOOL fReturn = FALSE;
    HRESULT hr;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
			PROPSHEETPAGE* ps = (PROPSHEETPAGE *) lParam;
            psConfig = (EXITSQL_CONFIGSTRUCT*)ps->lParam;

            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM)psConfig);

            BYTE pbTmp[MAX_PATH*sizeof(WCHAR)];
            DWORD cbTmp = MAX_PATH*sizeof(WCHAR);
			DWORD dwType;

			// dsn
            hr = RegQueryValueEx(
                psConfig->hkeyStorageLocation,
                wszREG_EXITSQL_DSN,
                0,
                &dwType,
                pbTmp,
                &cbTmp);
            if ((hr != ERROR_SUCCESS) || (dwType != REG_SZ))
                break;

			SetDlgItemText(hwndDlg, IDC_EDIT_DSN, (LPWSTR)pbTmp);
			((WCHAR*)pbTmp)[0] = L'\0';
			cbTmp = MAX_PATH*sizeof(WCHAR);

			// username
            hr = RegQueryValueEx(
                psConfig->hkeyStorageLocation,
                wszREG_EXITSQL_USER,
                0,
                &dwType,
                pbTmp,
                &cbTmp);
            if ((hr != ERROR_SUCCESS) || (dwType != REG_SZ))
                break;

			SetDlgItemText(hwndDlg, IDC_EDIT_USER, (LPWSTR)pbTmp);
			((WCHAR*)pbTmp)[0] = L'\0';
			cbTmp = MAX_PATH*sizeof(WCHAR);

			// password
            hr = RegQueryValueEx(
                psConfig->hkeyStorageLocation,
                wszREG_EXITSQL_PASSWORD,
                0,
                &dwType,
                pbTmp,
                &cbTmp);
            if ((hr != ERROR_SUCCESS) || (dwType != REG_SZ))
                break;

			SetDlgItemText(hwndDlg, IDC_EDIT_PASSWORD, (LPWSTR)pbTmp);
			((WCHAR*)pbTmp)[0] = L'\0';
			cbTmp = MAX_PATH*sizeof(WCHAR);

			psConfig->fPageModified = FALSE;

            // no other work to be done
            fReturn = TRUE;
            break;
        }

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_EDIT_DSN:
        case IDC_EDIT_USER:
        case IDC_EDIT_PASSWORD:
         if (HIWORD(wParam) == EN_CHANGE)
 {
                // grab our LParam
                psConfig = (EXITSQL_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

              psConfig->fPageModified = TRUE;
}
        break;
        default:
        break;
        } 
         break;
    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam) -> code)
        {
        case PSN_APPLY:
            {
				hr = S_OK;

                // grab our LParam
                psConfig = (EXITSQL_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

				WCHAR szTmp[MAX_PATH];
				GetDlgItemText(hwndDlg, IDC_EDIT_DSN, szTmp, sizeof(szTmp));

					hr = RegSetValueEx(
						psConfig->hkeyStorageLocation,
						wszREG_EXITSQL_DSN,
						0,
						REG_SZ,
						(PBYTE)&szTmp,
						(wcslen(szTmp)+1) * sizeof(WCHAR) );
					if (hr != ERROR_SUCCESS)
						goto savefailure;




				GetDlgItemText(hwndDlg, IDC_EDIT_USER, szTmp, sizeof(szTmp));

					hr = RegSetValueEx(
						psConfig->hkeyStorageLocation,
						wszREG_EXITSQL_USER,
						0,
						REG_SZ,
						(PBYTE)&szTmp,
						(wcslen(szTmp)+1) * sizeof(WCHAR) );
					if (hr != ERROR_SUCCESS)
						goto savefailure;



				GetDlgItemText(hwndDlg, IDC_EDIT_PASSWORD, szTmp, sizeof(szTmp));

					hr = RegSetValueEx(
						psConfig->hkeyStorageLocation,
						wszREG_EXITSQL_PASSWORD,
						0,
						REG_SZ,
						(PBYTE)&szTmp,
						(wcslen(szTmp)+1) * sizeof(WCHAR) );
					if (hr != ERROR_SUCCESS)
						goto savefailure;


savefailure:
                if (hr != ERROR_SUCCESS)
                {
					MessageBoxW(NULL, L"The settings could not be saved.", L"Applying ExitSQL Settings", MB_OK|MB_ICONINFORMATION);
                       psConfig->fPageModified = FALSE;
                }

            }
            break;
        default:
            break;
        }
        break;
    default:
        break;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certweb\certrqtp.inc ===
﻿<%' CODEPAGE=65001 'UTF-8%>
<%' certrqtp.inc - (CERT)srv web - (R)e(Q)uest, available (T)y(P)es
  ' Copyright (C) Microsoft Corporation, 1998 - 1999 %>
<%
	' NOTE: certdat.inc must be included first!
	Dim nAvailReqTypes 
	Dim rgAvailReqTypes(1,5)
	Dim sUserAgent
	Const FIELD_OID=0
	Const FIELD_TEMPLATE=0
	Const FIELD_FRIENDLYNAME=1
	Const FIELD_CSPLIST=2
	Const FIELD_CSPLIST2=3
	Const FIELD_EXPORTABLE=4
	
	' Strings for localization
	Const L_WebBrowserCert_Text="Web Browser Certificate"
	Const L_EmailProtectionCert_Text="E-Mail Protection Certificate"
	Const L_UserTemplateCert_Text="User Certificate" 'Note: should match localized name of 'User' template and certrqma.asp's localized string L_TemplateCert_Text

	If "StandAlone"=sServerType Then
		'
		' Request types for stand alone
		'
		rgAvailReqTypes(0,FIELD_OID)="1.3.6.1.5.5.7.3.2"
		rgAvailReqTypes(0,FIELD_FRIENDLYNAME)=L_WebBrowserCert_Text
		rgAvailReqTypes(0,FIELD_CSPLIST)=""

		rgAvailReqTypes(1,FIELD_OID)="1.3.6.1.5.5.7.3.4"
		rgAvailReqTypes(1,FIELD_FRIENDLYNAME)=L_EmailProtectionCert_Text
		rgAvailReqTypes(1,FIELD_CSPLIST)=""

		nAvailReqTypes=2

	Else
		'
		' Request types for enterprise
		'
		rgAvailReqTypes(0,FIELD_TEMPLATE)="User"
		rgAvailReqTypes(0,FIELD_FRIENDLYNAME)=L_UserTemplateCert_Text
		rgAvailReqTypes(0,FIELD_CSPLIST)="Microsoft Enhanced Cryptographic Provider v1.0?Microsoft Base Cryptographic Provider v1.0"
		rgAvailReqTypes(0,FIELD_CSPLIST2)="Microsoft Base Cryptographic Provider v1.0?Microsoft Enhanced Cryptographic Provider v1.0"
		rgAvailReqTypes(0,FIELD_EXPORTABLE)="True"
		nAvailReqTypes=1

	End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\exitsql\module.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.h
//
// Contents:    CCertManageExitModuleSQLSample definition
//
//---------------------------------------------------------------------------

#include "exitsql.h"
#include "resource.h"       // main symbols


class CCertManageExitModuleSQLSample: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTEXITSAMPLELib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManageExitModuleSQLSample, &CLSID_CCertManageExitModuleSQLSample>
{
public:
    CCertManageExitModuleSQLSample() { m_hWnd = NULL; }
    ~CCertManageExitModuleSQLSample() {}

BEGIN_COM_MAP(CCertManageExitModuleSQLSample)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManageExitModuleSQLSample) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// UNDONE UNDONE
DECLARE_REGISTRY(
    CCertManageExitModuleSQLSample,
    wszCLASS_CERTMANAGESAMPLE TEXT(".1"),
    wszCLASS_CERTMANAGESAMPLE,
    IDS_CERTMANAGEEXITMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:
    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);
        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);

public:
    HWND m_hWnd;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\sample\atl.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        atl.cpp
//
// Contents:    ActiveX Template Library COM support
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\exitsql\exit.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.cpp
//
// Contents:    CCertExitSQLSample implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include "celib.h"
#include "exit.h"
#include "module.h"


BOOL fDebug = DBG_CERTSRV;

#ifndef DBG_CERTSRV
#error -- DBG_CERTSRV not defined!
#endif

#define ceEXITEVENTS \
	EXITEVENT_CERTISSUED | \
	EXITEVENT_CERTREVOKED

#define CERTTYPE_ATTR_NAME TEXT("CertificateTemplate")

extern HINSTANCE g_hInstance;


// worker
HRESULT
GetServerCallbackInterface(
    OUT ICertServerExit** ppServer,
    IN LONG Context)
{
    HRESULT hr;

    if (NULL == ppServer)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "Exit:NULL pointer");
    }

    hr = CoCreateInstance(
                    CLSID_CCertServerExit,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
                    IID_ICertServerExit,
                    (VOID **) ppServer);
    _JumpIfError(hr, error, "Exit:CoCreateInstance");

    if (*ppServer == NULL)
    {
        hr = E_UNEXPECTED;
	_JumpError(hr, error, "Exit:NULL *ppServer");
    }

    // only set context if nonzero
    if (0 != Context)
    {
        hr = (*ppServer)->SetContext(Context);
        _JumpIfError(hr, error, "Exit: SetContext");
    }

error:
    return hr;
}


//+--------------------------------------------------------------------------
// CCertExitSQLSample::~CCertExitSQLSample -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertExitSQLSample::~CCertExitSQLSample()
{
	if (SQL_NULL_HDBC != m_hdbc1)
	{
		SQLDisconnect(m_hdbc1);
		SQLFreeHandle(SQL_HANDLE_DBC, m_hdbc1);
	}

    if (SQL_NULL_HENV != m_henv)
	    SQLFreeHandle(SQL_HANDLE_ENV, m_henv);

    if (NULL != m_strCAName)
    {
        SysFreeString(m_strCAName);
    }
}


//+--------------------------------------------------------------------------
// CCertExitSQLSample::Initialize -- initialize for a CA & return interesting Event Mask
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExitSQLSample::Initialize(
    /* [in] */ BSTR const strConfig,
    /* [retval][out] */ LONG __RPC_FAR *pEventMask)
{
    HRESULT hr = S_OK;
    DWORD       dwType;
    
	WCHAR rgchDsn[MAX_PATH];
	WCHAR rgchUser[MAX_PATH];
	WCHAR rgchPwd[MAX_PATH];
	DWORD cbTmp;
    ICertServerExit *pServer = NULL;

	SQLRETURN		retcode = SQL_SUCCESS;

	DWORD dwDisposition;
	HKEY hkeyStorageLocation = NULL;

	VARIANT varValue;
	VariantInit(&varValue);

    m_strCAName = SysAllocString(strConfig);
    if (NULL == m_strCAName)
    {
    	hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Exit:SysAllocString");
    }

	hr = GetServerCallbackInterface(&pServer, 0);
    _JumpIfError(hr, error, "GetServerCallbackInterface");

    hr = pServer->GetCertificateProperty(
			       wszPROPMODULEREGLOC,
			       PROPTYPE_STRING,
			       &varValue);
	_JumpIfError(hr, error, "GetCertificateProperty");

    hr = RegCreateKeyEx(
		    HKEY_LOCAL_MACHINE,
		    varValue.bstrVal,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_READ,
		    NULL,
		    &hkeyStorageLocation,
		    &dwDisposition);
    _JumpIfError(hr, error, "RegCreateKeyEx");

	cbTmp = sizeof(rgchDsn)*sizeof(WCHAR);

    // dsn
    hr = RegQueryValueEx(
        hkeyStorageLocation,
        wszREG_EXITSQL_DSN,
        0,
        &dwType,
        (PBYTE)rgchDsn,
        &cbTmp);
	if (dwType != REG_SZ) 
		hr = HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
	_JumpIfError(hr, error, "RegQueryValueEx DSN");

	cbTmp = sizeof(rgchUser)*sizeof(WCHAR);

	// username
    hr = RegQueryValueEx(
        hkeyStorageLocation,
        wszREG_EXITSQL_USER,
        0,
        &dwType,
        (PBYTE)rgchUser,
        &cbTmp);
	if (dwType != REG_SZ)
		hr = HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
	_JumpIfError(hr, error, "RegQueryValueEx User");

	cbTmp = sizeof(rgchPwd)*sizeof(WCHAR);

	// password
    hr = RegQueryValueEx(
        hkeyStorageLocation,
        wszREG_EXITSQL_PASSWORD,
        0,
        &dwType,
        (PBYTE)rgchPwd,
        &cbTmp);
	if (dwType != REG_SZ)
		hr = HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
	_JumpIfError(hr, error, "RegQueryValueEx Pwd");


    // Allocate the ODBC Environment and save handle.
    retcode = SQLAllocHandle (SQL_HANDLE_ENV, SQL_NULL_HANDLE, &m_henv);
	if (!SQL_SUCCEEDED(retcode))
		_JumpError(retcode, error, "SQLAllocHandle");

    // Let ODBC know this is an ODBC 3.0 application.
    retcode = SQLSetEnvAttr(m_henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER) SQL_OV_ODBC3, SQL_IS_INTEGER);
	if (!SQL_SUCCEEDED(retcode))
		_JumpError(retcode, error, "SQLSetEnvAttr");

    // Allocate an ODBC connection and connect.
	retcode = SQLAllocHandle(SQL_HANDLE_DBC, m_henv, &m_hdbc1);
	if (!SQL_SUCCEEDED(retcode))
		_JumpError(retcode, error, "SQLAllocHandle");
	
    retcode = SQLConnect(m_hdbc1, rgchDsn, SQL_NTS, rgchUser, SQL_NTS, rgchPwd, SQL_NTS);
	if (!SQL_SUCCEEDED(retcode))
		_JumpError(retcode, error, "SQLConnect");



    *pEventMask = ceEXITEVENTS;
    DBGPRINT((fDebug, "Exit:Initialize(%ws) ==> %x\n", m_strCAName, *pEventMask));

    hr = S_OK;

error:
	if (pServer)
		pServer->Release();

	if (hkeyStorageLocation)
		RegCloseKey(hkeyStorageLocation);

	if (!SQL_SUCCEEDED(retcode))
        hr = ERROR_BAD_QUERY_SYNTAX;

    return(ceHError(hr));
}




//+--------------------------------------------------------------------------
// CCertExitSQLSample::_NotifyNewCert -- Notify the exit module of a new certificate
//
//+--------------------------------------------------------------------------

HRESULT
CCertExitSQLSample::_NotifyNewCert(
    /* [in] */ LONG Context)
{
    HRESULT hr;
    VARIANT varValue;
    ICertServerExit *pServer = NULL;
	SYSTEMTIME stBefore, stAfter;
	FILETIME ftBefore, ftAfter;

	// properties
	LONG lRequestID;
    BSTR bstrCertType = NULL;
	BSTR bstrRequester = NULL;
	DATE dateBefore;
	DATE dateAfter;

    VariantInit(&varValue);


	hr = GetServerCallbackInterface(&pServer, Context);
    _JumpIfError(hr, error, "GetServerCallbackInterface");

	// ReqID
    hr = pServer->GetRequestProperty(
			       wszPROPREQUESTREQUESTID,
			       PROPTYPE_LONG,
			       &varValue);
    _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszPROPREQUESTREQUESTID);

	if (VT_I4 != varValue.vt)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "Exit:BAD cert var type");
	}
	lRequestID = varValue.lVal;
	VariantClear(&varValue);

	// Requester Name
    hr = pServer->GetRequestProperty(
			       wszPROPREQUESTERNAME,
			       PROPTYPE_STRING,
			       &varValue);
    _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszPROPREQUESTREQUESTID);

    if (VT_BSTR != varValue.vt)
    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "Exit:BAD cert var type");
    }
	bstrRequester = varValue.bstrVal;
	VariantInit(&varValue);	// don't init, bstrRequester nows owns memory

	// not before
    hr = pServer->GetCertificateProperty(
			       wszPROPCERTIFICATENOTBEFOREDATE,
			       PROPTYPE_DATE,
			       &varValue);
    _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszPROPREQUESTREQUESTID);

    if (VT_DATE != varValue.vt)
    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "Exit:BAD cert var type");
    }
	dateBefore = varValue.date;
	VariantClear(&varValue);	



	// not after
    hr = pServer->GetCertificateProperty(
			       wszPROPCERTIFICATENOTAFTERDATE,
			       PROPTYPE_DATE,
			       &varValue);
    _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszPROPREQUESTREQUESTID);

    if (VT_DATE != varValue.vt)
    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "Exit:BAD cert var type");
    }
	dateAfter = varValue.date;
	VariantClear(&varValue);	




	// cert template name
	hr = pServer->GetRequestAttribute(CERTTYPE_ATTR_NAME, &bstrCertType);
	_PrintIfError2(hr, "Exit:GetRequestAttribute", hr);


	// now prettify
	hr = ceDateToFileTime(&dateBefore, &ftBefore);
	_JumpIfError(hr, error, "ceDateToFileTime");

	hr = ceDateToFileTime(&dateAfter, &ftAfter);
	_JumpIfError(hr, error, "ceDateToFileTime");


	hr = ExitModSetODBCProperty(
		lRequestID,
		m_strCAName,
		bstrRequester,
		bstrCertType,
		&ftBefore,
		&ftAfter);
	DBGPRINT((fDebug, "ESQL: Logged request %d to SQL database\n", lRequestID));

error:
    if (NULL != bstrCertType)
	{
		SysFreeString(bstrCertType);
	}

	if (NULL != bstrRequester)
	{
		SysFreeString(bstrCertType);
	}

    VariantClear(&varValue);
    if (NULL != pServer)
    {
	pServer->Release();
    }
    return(hr);
}



//+--------------------------------------------------------------------------
// CCertExitSQLSample::Notify -- Notify the exit module of an event
//
// Returns S_OK.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExitSQLSample::Notify(
    /* [in] */ LONG ExitEvent,
    /* [in] */ LONG Context)
{
    char *psz = "UNKNOWN EVENT";
    HRESULT hr = S_OK;

    switch (ExitEvent)
    {
	case EXITEVENT_CERTISSUED:
	    hr = _NotifyNewCert(Context);
	    psz = "certissued";
	    break;

	case EXITEVENT_CERTPENDING:
	    psz = "certpending";
	    break;

	case EXITEVENT_CERTDENIED:
	    psz = "certdenied";
	    break;

	case EXITEVENT_CERTREVOKED:
	    psz = "certrevoked";
	    break;

	case EXITEVENT_CERTRETRIEVEPENDING:
	    psz = "retrievepending";
	    break;

	case EXITEVENT_CRLISSUED:
	    psz = "crlissued";
	    break;

	case EXITEVENT_SHUTDOWN:
	    psz = "shutdown";
	    break;
    }

    DBGPRINT((
	fDebug,
	"Exit:Notify(%hs=%x, ctx=%u) rc=%x\n",
	psz,
	ExitEvent,
	Context,
	hr));
    return(hr);
}


STDMETHODIMP
CCertExitSQLSample::GetDescription(
    /* [retval][out] */ BSTR *pstrDescription)
{
    HRESULT hr = S_OK;
    WCHAR sz[MAX_PATH];

    assert(wcslen(wsz_SAMPLE_DESCRIPTION) < ARRAYSIZE(sz));
    wcscpy(sz, wsz_SAMPLE_DESCRIPTION);

    *pstrDescription = SysAllocString(sz);
    if (NULL == *pstrDescription)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Exit:SysAllocString");
    }

error:
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP
CCertExitSQLSample::InterfaceSupportsErrorInfo(REFIID riid)
{
    int i;
    static const IID *arr[] =
    {
	&IID_ICertExit,
    };

    for (i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (IsEqualGUID(*arr[i],riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}

HRESULT
CCertExitSQLSample::ExitModSetODBCProperty(
	IN DWORD dwReqId,
	IN LPWSTR pszCAName,
	IN LPWSTR pszRequester,
	IN LPWSTR pszCertType,
	IN FILETIME* pftBefore,
	IN FILETIME* pftAfter)
{
	SQLRETURN retcode;
	HRESULT hr = S_OK;

	SQLHSTMT        hstmt1 = SQL_NULL_HSTMT;
	SQLWCHAR* pszStatement = NULL;

	SYSTEMTIME stTmp;
	SQL_TIMESTAMP_STRUCT   dateValidFrom, dateValidTo;
	SQLINTEGER        cValidFrom=sizeof(dateValidFrom), cValidTo =sizeof(dateValidTo);

	static WCHAR szSQLInsertStmt[] = L"INSERT INTO OutstandingCertificates (CAName, RequestID,  RequesterName, CertType, validFrom, validTo) VALUES (\'%ws\', %d, \'%ws\', \'%ws\', ?, ?)";

	// temporarily fix NULL to ""
	if (NULL == pszCAName)
		pszCAName = L"";
	if (NULL == pszRequester)
		pszRequester = L"";
	if (NULL == pszCertType)
		pszCertType = L"";


    // Allocate a statement handle.
	retcode = SQLAllocHandle(SQL_HANDLE_STMT, m_hdbc1, &hstmt1);
	if (!SQL_SUCCEEDED(retcode))
		goto error;


	// Bind the parameter.
	retcode = SQLBindParameter(hstmt1, 1, SQL_PARAM_INPUT, SQL_C_TYPE_TIMESTAMP, SQL_TYPE_TIMESTAMP, 0, 0,
					  &dateValidFrom, 0, &cValidFrom);
	if (!SQL_SUCCEEDED(retcode))
		goto error;

	retcode = SQLBindParameter(hstmt1, 2, SQL_PARAM_INPUT, SQL_C_TYPE_TIMESTAMP, SQL_TYPE_TIMESTAMP, 0, 0,
					  &dateValidTo, 0, &cValidTo);
	if (!SQL_SUCCEEDED(retcode))
		goto error;


	// Place the valid from date in the dsOpenDate structure.
	if (!FileTimeToSystemTime(pftBefore, &stTmp))
	{
		hr = GetLastError();
		hr = HRESULT_FROM_WIN32(hr);
		_JumpError(hr, error, "FileTimeToSystemTime");
	}

	dateValidFrom.year = stTmp.wYear;
	dateValidFrom.month = stTmp.wMonth;
	dateValidFrom.day = stTmp.wDay;
    dateValidFrom.hour = stTmp.wHour;
    dateValidFrom.minute = stTmp.wMinute;
    dateValidFrom.second = stTmp.wSecond;

	// Place the valid to date in the dsOpenDate structure.
	if (!FileTimeToSystemTime(pftAfter, &stTmp))
	{
		hr = GetLastError();
		hr = HRESULT_FROM_WIN32(hr);
		_JumpError(hr, error, "FileTimeToSystemTime");
	}

	dateValidTo.year = stTmp.wYear;
	dateValidTo.month = stTmp.wMonth;
	dateValidTo.day = stTmp.wDay;
    dateValidTo.hour = stTmp.wHour;
    dateValidTo.minute = stTmp.wMinute;
    dateValidTo.second = stTmp.wSecond;


	// Build INSERT statement.
	pszStatement = (SQLWCHAR*) LocalAlloc(LMEM_FIXED, (sizeof(szSQLInsertStmt)+wcslen(pszCAName)+wcslen(pszRequester)+wcslen(pszCertType)+15 +1) *2);
	if (NULL == pszStatement)
	{
		hr = E_OUTOFMEMORY;
		goto error;
	}
	
	wsprintf(pszStatement, szSQLInsertStmt, pszCAName, dwReqId, pszRequester, pszCertType);
	//OutputDebugStringW(pszStatement);
	
    // Execute an SQL statement directly on the statement handle.
    // Uses a default result set because no cursor attributes are set.
	retcode = SQLExecDirect(hstmt1, pszStatement, SQL_NTS);
	if (!SQL_SUCCEEDED(retcode))
		goto error;


error:
    /* Clean up. */
	if (NULL != pszStatement)
		LocalFree(pszStatement);

    if (SQL_NULL_HSTMT != hstmt1)
		SQLFreeHandle(SQL_HANDLE_STMT, hstmt1);

	if (!SQL_SUCCEEDED(retcode))
		hr = ERROR_BAD_QUERY_SYNTAX;

	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\sample\exit.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.h
//
// Contents:    CCertExitSample definition
//
//---------------------------------------------------------------------------

#include "certxsam.h"
#include "resource.h"       // main symbols


HRESULT
GetServerCallbackInterface(
    OUT ICertServerExit** ppServer,
    IN LONG Context);

HRESULT
exitGetProperty(
    IN ICertServerExit *pServer,
    IN BOOL fRequest,
    IN WCHAR const *pwszPropertyName,
    IN DWORD PropType,
    OUT VARIANT *pvarOut);

/////////////////////////////////////////////////////////////////////////////
// certexit

class CCertExitSample: 
    public CComDualImpl<ICertExit2, &IID_ICertExit2, &LIBID_CERTEXITSAMPLELib>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CCertExitSample, &CLSID_CCertExitSample>
{
public:
    CCertExitSample() 
    { 
        m_strDescription = NULL;
        m_strCAName = NULL;
        m_pwszRegStorageLoc = NULL;
        m_hExitKey = NULL;
        m_dwExitPublishFlags = 0;
        m_cCACert = 0;
    }
    ~CCertExitSample();

BEGIN_COM_MAP(CCertExitSample)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertExit)
    COM_INTERFACE_ENTRY(ICertExit2)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertExitSample) 

DECLARE_REGISTRY(
    CCertExitSample,
    wszCLASS_CERTEXITSAMPLE TEXT(".1"),
    wszCLASS_CERTEXITSAMPLE,
    IDS_CERTEXIT_DESC,
    THREADFLAGS_BOTH)

    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // ICertExit
public:
    STDMETHOD(Initialize)( 
            /* [in] */ BSTR const strConfig,
            /* [retval][out] */ LONG __RPC_FAR *pEventMask);

    STDMETHOD(Notify)(
            /* [in] */ LONG ExitEvent,
            /* [in] */ LONG Context);

    STDMETHOD(GetDescription)( 
            /* [retval][out] */ BSTR *pstrDescription);

// ICertExit2
public:
    STDMETHOD(GetManageModule)(
		/* [out, retval] */ ICertManageModule **ppManageModule);

private:
    HRESULT _NotifyNewCert(IN LONG Context);

    HRESULT _NotifyCRLIssued(IN LONG Context);

    HRESULT _WriteCertToFile(
	    IN ICertServerExit *pServer,
	    IN BYTE const *pbCert,
	    IN DWORD cbCert);

    HRESULT _ExpandEnvironmentVariables(
	    IN WCHAR const *pwszIn,
	    OUT WCHAR *pwszOut,
	    IN DWORD cwcOut);

    // Member variables & private methods here:
    BSTR           m_strDescription;
    BSTR           m_strCAName;
    LPWSTR         m_pwszRegStorageLoc;
    HKEY           m_hExitKey;
    DWORD          m_dwExitPublishFlags;
    DWORD          m_cCACert;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\exitsql\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#include <windows.h>

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <certsrv.h>

#define wszCLASS_CERTEXITSAMPLEPREFIX TEXT("CertAuthority_ExitSQL_Sample")

#define wszCLASS_CERTEXITSAMPLE wszCLASS_CERTEXITSAMPLEPREFIX wszCERTEXITMODULE_POSTFIX
#define wszCLASS_CERTMANAGESAMPLE wszCLASS_CERTEXITSAMPLEPREFIX wszCERTMANAGEEXIT_POSTFIX

#define wsz_SAMPLE_NAME           L"ODBC logging Exit Module"
#define wsz_SAMPLE_DESCRIPTION    L"Logs issuance events to an ODBC source"
#define wsz_SAMPLE_COPYRIGHT      L"2000 Microsoft Corp"
#define wsz_SAMPLE_FILEVER        L"1.0"
#define wsz_SAMPLE_PRODUCTVER     L"5.01"


#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\exitsql\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by exitsql.rc
//
#define IDS_CERTEXIT_DESC               1
#define IDS_CERTMANAGEEXITMODULE_DESC   2
#define IDS_MODULE_NAME                 3
#define IDC_EDIT_DSN                    201
#define IDC_EDIT_USER                   202
#define IDC_EDIT_PASSWORD               203
#define IDD_EXITSQL_PROPERTIES          614

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         202
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\sample\exit.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.cpp
//
// Contents:    CCertExitSample implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include "celib.h"
#include "exit.h"
#include "module.h"

BOOL fDebug = DBG_CERTSRV;

#ifndef DBG_CERTSRV
#error -- DBG_CERTSRV not defined!
#endif

#define ceEXITEVENTS \
	(EXITEVENT_CERTDENIED | \
	 EXITEVENT_CERTISSUED | \
	 EXITEVENT_CERTPENDING | \
	 EXITEVENT_CERTRETRIEVEPENDING | \
	 EXITEVENT_CERTREVOKED | \
	 EXITEVENT_CRLISSUED | \
	 EXITEVENT_SHUTDOWN)


extern HINSTANCE g_hInstance;


HRESULT
GetServerCallbackInterface(
    OUT ICertServerExit** ppServer,
    IN LONG Context)
{
    HRESULT hr;

    if (NULL == ppServer)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "Exit:NULL pointer");
    }

    hr = CoCreateInstance(
                    CLSID_CCertServerExit,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
                    IID_ICertServerExit,
                    (VOID **) ppServer);
    _JumpIfError(hr, error, "Exit:CoCreateInstance");

    if (*ppServer == NULL)
    {
        hr = E_UNEXPECTED;
	_JumpError(hr, error, "Exit:NULL *ppServer");
    }

    // only set context if nonzero
    if (0 != Context)
    {
        hr = (*ppServer)->SetContext(Context);
        _JumpIfError(hr, error, "Exit: SetContext");
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExitSample::~CCertExitSample -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertExitSample::~CCertExitSample()
{
    if (NULL != m_strCAName)
    {
        SysFreeString(m_strCAName);
    }
    if (NULL != m_pwszRegStorageLoc)
    {
        LocalFree(m_pwszRegStorageLoc);
    }
    if (NULL != m_hExitKey)
    {
        RegCloseKey(m_hExitKey);
    }
    if (NULL != m_strDescription)
    {
        SysFreeString(m_strDescription);
    }
}


//+--------------------------------------------------------------------------
// CCertExitSample::Initialize -- initialize for a CA & return interesting Event Mask
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExitSample::Initialize(
    /* [in] */ BSTR const strConfig,
    /* [retval][out] */ LONG __RPC_FAR *pEventMask)
{
    HRESULT hr = S_OK;
    DWORD cbbuf;
    DWORD dwType;
    ENUM_CATYPES CAType;
    ICertServerExit *pServer = NULL;
    VARIANT varValue;
    WCHAR sz[MAX_PATH];

    VariantInit(&varValue);

    assert(wcslen(wsz_SAMPLE_DESCRIPTION) < ARRAYSIZE(sz));
    wcsncpy(sz, wsz_SAMPLE_DESCRIPTION, ARRAYSIZE(sz));
    sz[ARRAYSIZE(sz) - 1] = L'\0';

    m_strDescription = SysAllocString(sz);
    if (NULL == m_strDescription)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Exit:SysAllocString");
    }

    m_strCAName = SysAllocString(strConfig);
    if (NULL == m_strCAName)
    {
    	hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Exit:SysAllocString");
    }

    *pEventMask = ceEXITEVENTS;
    DBGPRINT((fDebug, "Exit:Initialize(%ws) ==> %x\n", m_strCAName, *pEventMask));

    // get server callbacks

    hr = GetServerCallbackInterface(&pServer, 0);
    _JumpIfError(hr, error, "Exit:GetServerCallbackInterface");

    // get storage location

    hr = exitGetProperty(
		    pServer,
		    FALSE,	// fRequest
		    wszPROPMODULEREGLOC,
		    PROPTYPE_STRING,
		    &varValue);
    _JumpIfErrorStr(hr, error, "Exit:exitGetProperty", wszPROPMODULEREGLOC);
    
    m_pwszRegStorageLoc = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(varValue.bstrVal)+1) *sizeof(WCHAR));
    if (NULL == m_pwszRegStorageLoc)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Exit:LocalAlloc");
    }
    wcscpy(m_pwszRegStorageLoc, varValue.bstrVal);
    VariantClear(&varValue);

    // get CA type
    hr = exitGetProperty(
		    pServer,
		    FALSE,	// fRequest
		    wszPROPCATYPE,
		    PROPTYPE_LONG,
		    &varValue);
    _JumpIfErrorStr(hr, error, "Exit:exitGetProperty", wszPROPCATYPE);

    CAType = (ENUM_CATYPES) varValue.lVal;
    VariantClear(&varValue);

    hr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                m_pwszRegStorageLoc,
                0,              // dwReserved
                KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE,
                &m_hExitKey);

    if (S_OK != hr)
    {
        if ((HRESULT) ERROR_FILE_NOT_FOUND == hr)
        {
            hr = S_OK;
            goto error;
        }
        _JumpError(hr, error, "Exit:RegOpenKeyEx");
    }

    hr = exitGetProperty(
		    pServer,
		    FALSE,	// fRequest
		    wszPROPCERTCOUNT,
		    PROPTYPE_LONG,
		    &varValue);
    _JumpIfErrorStr(hr, error, "Exit:exitGetProperty", wszPROPCERTCOUNT);

    m_cCACert = varValue.lVal;

    cbbuf = sizeof(m_dwExitPublishFlags);
    hr = RegQueryValueEx(
		    m_hExitKey,
		    wszREGCERTPUBLISHFLAGS,
		    NULL,           // lpdwReserved
		    &dwType,
		    (BYTE *) &m_dwExitPublishFlags,
		    &cbbuf);
    if (S_OK != hr)
    {
        m_dwExitPublishFlags = 0;
    }

    hr = S_OK;

error:
    VariantClear(&varValue);
    if (NULL != pServer)
    {
        pServer->Release();
    }
    return(ceHError(hr));
}


//+--------------------------------------------------------------------------
// CCertExitSample::_ExpandEnvironmentVariables -- Expand environment variables
//
//+--------------------------------------------------------------------------

HRESULT
CCertExitSample::_ExpandEnvironmentVariables(
    IN WCHAR const *pwszIn,
    OUT WCHAR *pwszOut,
    IN DWORD cwcOut)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    WCHAR awcVar[MAX_PATH];
    WCHAR const *pwszSrc;
    WCHAR *pwszDst;
    WCHAR *pwszDstEnd;
    WCHAR *pwszVar;
    DWORD cwc;

    pwszSrc = pwszIn;
    pwszDst = pwszOut;
    pwszDstEnd = &pwszOut[cwcOut];

    while (L'\0' != (*pwszDst = *pwszSrc++))
    {
	if ('%' == *pwszDst)
	{
	    *pwszDst = L'\0';
	    pwszVar = awcVar;

	    while (L'\0' != *pwszSrc)
	    {
		if ('%' == *pwszSrc)
		{
		    pwszSrc++;
		    break;
		}
		*pwszVar++ = *pwszSrc++;
		if (pwszVar >= &awcVar[sizeof(awcVar)/sizeof(awcVar[0]) - 1])
		{
		    _JumpError(hr, error, "Exit:overflow 1");
		}
	    }
	    *pwszVar = L'\0';
	    cwc = GetEnvironmentVariable(awcVar, pwszDst, SAFE_SUBTRACT_POINTERS(pwszDstEnd, pwszDst));
	    if (0 == cwc)
	    {
		hr = ceHLastError();
		_JumpError(hr, error, "Exit:GetEnvironmentVariable");
	    }
	    if ((DWORD) (pwszDstEnd - pwszDst) <= cwc)
	    {
		_JumpError(hr, error, "Exit:overflow 2");
	    }
	    pwszDst += cwc;
	}
	else
	{
	    pwszDst++;
	}
	if (pwszDst >= pwszDstEnd)
	{
	    _JumpError(hr, error, "Exit:overflow 3");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
exitGetRequestAttribute(
    IN ICertServerExit *pServer,
    IN WCHAR const *pwszAttributeName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    BSTR strName = NULL;

    *pstrOut = NULL;
    strName = SysAllocString(pwszAttributeName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Exit:SysAllocString");
    }
    hr = pServer->GetRequestAttribute(strName, pstrOut);
    _JumpIfErrorStr2(
		hr,
		error,
		"Exit:GetRequestAttribute",
		pwszAttributeName,
		CERTSRV_E_PROPERTY_EMPTY);

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExitSample::_WriteCertToFile -- write binary certificate to a file
//
//+--------------------------------------------------------------------------

HRESULT
CCertExitSample::_WriteCertToFile(
    IN ICertServerExit *pServer,
    IN BYTE const *pbCert,
    IN DWORD cbCert)
{
    HRESULT hr;
    BSTR strCertFile = NULL;
    DWORD cbWritten;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WCHAR wszDir[MAX_PATH];
    WCHAR *pwszPath = NULL;
    WCHAR wszFile[cwcDWORDSPRINTF+5]; //format "requestid.cer"
    VARIANT varRequestID;

    VariantInit(&varRequestID);


    hr = exitGetRequestAttribute(pServer, wszPROPEXITCERTFILE, &strCertFile);
    if (S_OK != hr)
    {
	DBGPRINT((
	    fDebug,
	    "Exit:exitGetRequestAttribute(%ws): %x%hs\n",
	    wszPROPEXITCERTFILE,
	    hr,
	    CERTSRV_E_PROPERTY_EMPTY == hr? " EMPTY VALUE" : ""));
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	}
	goto error;
    }

    // build file name as "requestid.cer"

    hr = exitGetProperty(
        pServer,
        TRUE,  // fRequest,
        wszPROPREQUESTREQUESTID,
        PROPTYPE_LONG,
        &varRequestID);
    _JumpIfErrorStr(hr, error, "Exit:exitGetProperty", wszPROPREQUESTREQUESTID);

    wsprintf(wszFile, L"%d.cer", V_I4(&varRequestID));
    
    hr = _ExpandEnvironmentVariables(
		    L"%SystemRoot%\\System32\\" wszCERTENROLLSHAREPATH L"\\",
		    wszDir,
		    ARRAYSIZE(wszDir));
    _JumpIfError(hr, error, "_ExpandEnvironmentVariables");

    hr = ceBuildPathAndExt(wszDir, wszFile, NULL, &pwszPath);
    _JumpIfError(hr, error, "ceBuildPathAndExt");

    // open file & write binary cert out.

    hFile = CreateFile(
		    pwszPath,
		    GENERIC_WRITE,
		    0,			// dwShareMode
		    NULL,		// lpSecurityAttributes
		    CREATE_NEW,
		    FILE_ATTRIBUTE_NORMAL,
		    NULL);		// hTemplateFile
    if (INVALID_HANDLE_VALUE == hFile)
    {
	hr = ceHLastError();
	_JumpErrorStr(hr, error, "Exit:CreateFile", pwszPath);
    }
    if (!WriteFile(hFile, pbCert, cbCert, &cbWritten, NULL))
    {
	hr = ceHLastError();
	_JumpErrorStr(hr, error, "Exit:WriteFile", pwszPath);
    }
    if (cbWritten != cbCert)
    {
	hr = STG_E_WRITEFAULT;
	DBGPRINT((
	    fDebug,
	    "Exit:WriteFile(%ws): attempted %x, actual %x bytes: %x\n",
	    pwszPath,
	    cbCert,
	    cbWritten,
	    hr));
	goto error;
    }

error:

    if (INVALID_HANDLE_VALUE != hFile)
    {
	CloseHandle(hFile);
    }
    if (NULL != pwszPath)
    {
	LocalFree(pwszPath);
    }
    if (NULL != strCertFile)
    {
	SysFreeString(strCertFile);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExitSample::_NotifyNewCert -- Notify the exit module of a new certificate
//
//+--------------------------------------------------------------------------

HRESULT
CCertExitSample::_NotifyNewCert(
    /* [in] */ LONG Context)
{
    HRESULT hr;
    VARIANT varCert;
    ICertServerExit *pServer = NULL;

    VariantInit(&varCert);

    // only call write fxns if server policy allows

    if (m_dwExitPublishFlags & EXITPUB_FILE)
    {
        hr = CoCreateInstance(
		        CLSID_CCertServerExit,
		        NULL,               // pUnkOuter
		        CLSCTX_INPROC_SERVER,
		        IID_ICertServerExit,
		        (VOID **) &pServer);
        _JumpIfError(hr, error, "Exit:CoCreateInstance");

        hr = pServer->SetContext(Context);
        _JumpIfError(hr, error, "Exit:SetContext");

        hr = exitGetProperty(
		        pServer,
		        FALSE,	// fRequest,
		        wszPROPRAWCERTIFICATE,
		        PROPTYPE_BINARY,
		        &varCert);
        _JumpIfErrorStr(
		    hr,
		    error,
		    "Exit:exitGetProperty",
		    wszPROPRAWCERTIFICATE);

        if (VT_BSTR != varCert.vt)
        {
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "Exit:BAD cert var type");
        }

	hr = _WriteCertToFile(
			pServer,
			(BYTE const *) varCert.bstrVal,
			SysStringByteLen(varCert.bstrVal));
	_JumpIfError(hr, error, "_WriteCertToFile");
    }

    hr = S_OK;

error:
    VariantClear(&varCert);
    if (NULL != pServer)
    {
	pServer->Release();
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExitSample::_NotifyCRLIssued -- Notify the exit module of a new certificate
//
//+--------------------------------------------------------------------------

HRESULT
CCertExitSample::_NotifyCRLIssued(
    /* [in] */ LONG Context)
{
    HRESULT hr;
    ICertServerExit *pServer = NULL;
    DWORD i;
    VARIANT varBaseCRL;
    VARIANT varDeltaCRL;
    BOOL fDeltaCRLsDisabled;

    VariantInit(&varBaseCRL);
    VariantInit(&varDeltaCRL);

    hr = CoCreateInstance(
		    CLSID_CCertServerExit,
		    NULL,               // pUnkOuter
		    CLSCTX_INPROC_SERVER,
		    IID_ICertServerExit,
		    (VOID **) &pServer);
    _JumpIfError(hr, error, "Exit:CoCreateInstance");

    hr = pServer->SetContext(Context);
    _JumpIfError(hr, error, "Exit:SetContext");


    hr = exitGetProperty(
		    pServer,
		    FALSE,	// fRequest,
		    wszPROPDELTACRLSDISABLED,
		    PROPTYPE_LONG,
		    &varBaseCRL);
    _JumpIfErrorStr(
		hr,
		error,
		"Exit:exitGetProperty",
		wszPROPDELTACRLSDISABLED);

    fDeltaCRLsDisabled = varBaseCRL.lVal;

    // How many CRLs are there?

    // Loop for each CRL
    for (i = 0; i < m_cCACert; i++)
    {
        // array size for wsprintf("%s.%u")
        #define MAX_CRL_PROP \
            (max( \
		max(ARRAYSIZE(wszPROPCRLSTATE), ARRAYSIZE(wszPROPRAWCRL)), \
                ARRAYSIZE(wszPROPRAWDELTACRL)) + \
	     1 + cwcDWORDSPRINTF)

        WCHAR wszCRLPROP[MAX_CRL_PROP];

        // Verify the CRL State says we should update this CRL

        wsprintf(wszCRLPROP, wszPROPCRLSTATE L".%u", i);
        hr = exitGetProperty(
			pServer,
			FALSE,	// fRequest,
			wszCRLPROP,
			PROPTYPE_LONG,
			&varBaseCRL);
        _JumpIfErrorStr(hr, error, "Exit:exitGetProperty", wszCRLPROP);

	if (CA_DISP_VALID != varBaseCRL.lVal)
	{
	    continue;
	}

        // Grab the raw base CRL

        wsprintf(wszCRLPROP, wszPROPRAWCRL L".%u", i);
        hr = exitGetProperty(
			pServer,
			FALSE,	// fRequest,
			wszCRLPROP,
			PROPTYPE_BINARY,
			&varBaseCRL);
        _JumpIfErrorStr(hr, error, "Exit:exitGetProperty", wszCRLPROP);

        // Grab the raw delta CRL (which may not exist)

        wsprintf(wszCRLPROP, wszPROPRAWDELTACRL L".%u", i);
        hr = exitGetProperty(
			pServer,
			FALSE,	// fRequest,
			wszCRLPROP,
			PROPTYPE_BINARY,
			&varDeltaCRL);
        _PrintIfErrorStr2(
		    hr,
		    "Exit:exitGetProperty",
		    wszCRLPROP,
		    fDeltaCRLsDisabled? 
			HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) : S_OK);
	if (S_OK != hr && !fDeltaCRLsDisabled)
	{
	    goto error;
	}

        // Publish the CRL(s) ...
    }

    hr = S_OK;

error:
    if (NULL != pServer)
    {
	pServer->Release();
    }
    VariantClear(&varBaseCRL);
    VariantClear(&varDeltaCRL);
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExitSample::Notify -- Notify the exit module of an event
//
// Returns S_OK.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExitSample::Notify(
    /* [in] */ LONG ExitEvent,
    /* [in] */ LONG Context)
{
    char *psz = "UNKNOWN EVENT";
    HRESULT hr = S_OK;

    switch (ExitEvent)
    {
	case EXITEVENT_CERTISSUED:
	    hr = _NotifyNewCert(Context);
	    psz = "certissued";
	    break;

	case EXITEVENT_CERTPENDING:
	    psz = "certpending";
	    break;

	case EXITEVENT_CERTDENIED:
	    psz = "certdenied";
	    break;

	case EXITEVENT_CERTREVOKED:
	    psz = "certrevoked";
	    break;

	case EXITEVENT_CERTRETRIEVEPENDING:
	    psz = "retrievepending";
	    break;

	case EXITEVENT_CRLISSUED:
	    hr = _NotifyCRLIssued(Context);
	    psz = "crlissued";
	    break;

	case EXITEVENT_SHUTDOWN:
	    psz = "shutdown";
	    break;
    }


    DBGPRINT((
	fDebug,
	"Exit:Notify(%hs=%x, ctx=%x) rc=%x\n",
	psz,
	ExitEvent,
	Context,
	hr));
    return(hr);
}


STDMETHODIMP
CCertExitSample::GetDescription(
    /* [retval][out] */ BSTR *pstrDescription)
{
    HRESULT hr = S_OK;
    WCHAR sz[MAX_PATH];

    assert(wcslen(wsz_SAMPLE_DESCRIPTION) < ARRAYSIZE(sz));
    wcscpy(sz, wsz_SAMPLE_DESCRIPTION);

    *pstrDescription = SysAllocString(sz);
    if (NULL == *pstrDescription)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Exit:SysAllocString");
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExitSample::GetManageModule
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExitSample::GetManageModule(
    /* [out, retval] */ ICertManageModule **ppManageModule)
{
    HRESULT hr;
    
    *ppManageModule = NULL;
    hr = CoCreateInstance(
            CLSID_CCertManageExitModuleSample,
            NULL,               // pUnkOuter
            CLSCTX_INPROC_SERVER,
            IID_ICertManageModule,
            (VOID **) ppManageModule);
    _JumpIfError(hr, error, "CoCreateInstance");

error:
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP
CCertExitSample::InterfaceSupportsErrorInfo(REFIID riid)
{
    int i;
    static const IID *arr[] =
    {
	&IID_ICertExit,
    };

    for (i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (IsEqualGUID(*arr[i],riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}


HRESULT
exitGetProperty(
    IN ICertServerExit *pServer,
    IN BOOL fRequest,
    IN WCHAR const *pwszPropertyName,
    IN DWORD PropType,
    OUT VARIANT *pvarOut)
{
    HRESULT hr;
    BSTR strName = NULL;

    VariantInit(pvarOut);
    strName = SysAllocString(pwszPropertyName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Exit:SysAllocString");
    }
    if (fRequest)
    {
	hr = pServer->GetRequestProperty(strName, PropType, pvarOut);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "Exit:GetRequestProperty",
		    pwszPropertyName,
		    CERTSRV_E_PROPERTY_EMPTY);
    }
    else
    {
	hr = pServer->GetCertificateProperty(strName, PropType, pvarOut);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "Exit:GetCertificateProperty",
		    pwszPropertyName,
		    CERTSRV_E_PROPERTY_EMPTY);
    }

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\sample\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\$(TARGETNAME).res:	$(O)\$(TARGETNAME).tlb

SOURCE_DIR=..\..\celib

$(NTTARGETFILE0):	$(SOURCE_DIR)\$(@F)
    copy $(SOURCE_DIR)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\sample\certxsam.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certxsam.cpp
//
// Contents:    Cert Server Exit Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "celib.h"
#include "exit.h"
#include "module.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertExitSample, CCertExitSample)
    OBJECT_ENTRY(CLSID_CCertManageExitModuleSample, CCertManageExitModuleSample)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    _Module.Init(ObjectMap, hInstance);
	    DisableThreadLibraryCalls(hInstance);
	    break;

        case DLL_PROCESS_DETACH:
	    _Module.Term();
            break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return(_Module.GetClassObject(rclsid, riid, ppv));
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\sample\exit0.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.h
//
// Contents:    CCertExitSample definition
//
//---------------------------------------------------------------------------

#include "certxsam.h"
#include "resource.h"       // main symbols
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\sample\exit0.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.cpp
//
// Contents:    CCertExitSample implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include "celib.h"
#include "exit.h"
#include "module.h"

BOOL fDebug = DBG_CERTSRV;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\sample\module.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.h
//
// Contents:    CCertManageExitModuleSample definition
//
//---------------------------------------------------------------------------

#include "certxsam.h"
#include "resource.h"       // main symbols


class CCertManageExitModuleSample: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTEXITSAMPLELib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManageExitModuleSample, &CLSID_CCertManageExitModuleSample>
{
public:
    CCertManageExitModuleSample() {}
    ~CCertManageExitModuleSample() {}

BEGIN_COM_MAP(CCertManageExitModuleSample)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManageExitModuleSample) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// UNDONE UNDONE
DECLARE_REGISTRY(
    CCertManageExitModuleSample,
    wszCLASS_CERTMANAGEEXITMODULESAMPLE TEXT(".1"),
    wszCLASS_CERTMANAGEEXITMODULESAMPLE,
    IDS_CERTMANAGEEXITMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:
    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);
        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\sample\module.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.cpp
//
// Contents:    Cert Server Exit Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "celib.h"
#include "module.h"
#include "exit.h"


STDMETHODIMP
CCertManageExitModuleSample::GetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    LPWSTR szStr = NULL;

    if (pvarProperty == NULL)
        return E_POINTER;

    VariantInit(pvarProperty);

    if (strPropertyName == NULL)
        return S_FALSE;

    if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_NAME))
        szStr = wsz_SAMPLE_NAME;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_DESCRIPTION))
        szStr = wsz_SAMPLE_DESCRIPTION;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_COPYRIGHT))
        szStr = wsz_SAMPLE_COPYRIGHT;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_FILEVER))
        szStr = wsz_SAMPLE_FILEVER;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_PRODUCTVER))
        szStr = wsz_SAMPLE_PRODUCTVER;
    else
        return S_FALSE;  

    pvarProperty->bstrVal = SysAllocString(szStr);
    if (NULL == pvarProperty->bstrVal)
        return E_OUTOFMEMORY;

    pvarProperty->vt = VT_BSTR;

    return S_OK;
}
        
STDMETHODIMP 
CCertManageExitModuleSample::SetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty)
{
     // no settable properties supported
     return S_FALSE;
}
        
STDMETHODIMP
CCertManageExitModuleSample::Configure( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG Flags)
{
    MessageBox(NULL, L"No Configurable Options", NULL, MB_OK|MB_ICONINFORMATION);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\sample\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certexit.rc
//
#define IDS_CERTEXIT_DESC	1
#define IDS_CERTMANAGEEXITMODULE_DESC 2


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\exit\sample\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#include <windows.h>

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <certsrv.h>

// include this here so managemodule and exitmodule get to see it

#define wszCLASS_CERTEXITSAMPLEPREFIX TEXT("CertAuthority_Sample")

#define wszCLASS_CERTEXITSAMPLE wszCLASS_CERTEXITSAMPLEPREFIX wszCERTEXITMODULE_POSTFIX
#define wszCLASS_CERTMANAGEEXITMODULESAMPLE wszCLASS_CERTEXITSAMPLEPREFIX wszCERTMANAGEEXIT_POSTFIX

#define wsz_SAMPLE_NAME           L"Sample/Test Exit Module"
#define wsz_SAMPLE_DESCRIPTION    L"Sample Exit Module"
#define wsz_SAMPLE_COPYRIGHT      L"(c)1999 Microsoft"
#define wsz_SAMPLE_FILEVER        L"v 1.0"
#define wsz_SAMPLE_PRODUCTVER     L"v 5.00"


#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\genreq\certgen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certgen.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <conio.h>

#include "encode.h"
#include "rsa.h"
#include "md5.h"
#include <wincrypt.h>
#include <certsrv.h>
#include <certca.h>
#include <csdisp.h>
#include "csprop.h"

#define MSTOSEC(ms)	(((ms) + 1000 - 1)/1000)

DWORD g_crdnMax;


HCRYPTPROV g_hMe = NULL;

WCHAR g_wszTestKey[] = L"CertGen_TestKey";


static unsigned char MD5_PRELUDE[] = {
    0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86,
    0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05, 0x05, 0x00,
    0x04, 0x10
};

BYTE            g_CAPIPrivateKey[1000];
DWORD           g_cbPrivateKey;
//LPBSAFE_PRV_KEY g_pRSAPrivateKey;
DWORD           g_cbRSAPrivateKey;
LPBSAFE_PUB_KEY g_pRSAPublicKey;
DWORD           g_cbRSAPublicKey;

WCHAR *g_pwszConfig = NULL;

typedef struct {
    DWORD       magic;                  // Should always be RSA2
    DWORD       bitlen;                 // bit size of key
    DWORD       pubexp;                 // public exponent
} EXPORT_PRV_KEY;

BOOL g_fRPC = FALSE;
BOOL g_fRenewal = FALSE;
BOOL g_fSave = FALSE;
BOOL g_fPrintProperties = FALSE;
BOOL g_fDebug = FALSE;
BOOL g_fIgnoreAccessDenied = FALSE;
BOOL g_fTime = FALSE;
BOOL g_fIgnoreError = FALSE;
BOOL g_fAllowDups = FALSE;
BOOL g_fShowTime = FALSE;
BOOL g_fEnterpriseCA = FALSE;

LONG g_IntervalCount;
DWORD g_MaximumCount = MAXDWORD;
DWORD g_DispatchFlags = DISPSETUP_COMFIRST;

BOOL IsCharPrintableString(TCHAR chChar);

WCHAR wszUsage[] =
    TEXT("Usage: CertGen [options]\n")
    TEXT("Options are:\n")
    TEXT("  -a                     - ignore denied requests\n")
    TEXT("  -c #                   - generate # certs\n")
    TEXT("  -config server\\CAName - specify CA config string\n")
    TEXT("  -d                     - debug\n")
    TEXT("  -e                     - Enterprise CA\n")
    TEXT("  -i                     - don't stop on request errors\n")
    TEXT("  -m                     - print start/end time\n")
    TEXT("  -p                     - print properties from cert created\n")
    TEXT("  -r                     - put request/cert/chain info into test.req/test.crt/testchain.crt\n")
    TEXT("  -renewal               - generate renewal requests\n")
    TEXT("  -rpc                   - use RPC to connect to server\n")
    TEXT("  -t #                   - print time statistics every # certs\n")
    TEXT("  -z                     - allow duplicate subject name components\n")
;


HRESULT
SeedRNG(void)
{
    HRESULT hr;
    unsigned int seed;

    if (!CryptGenRandom(g_hMe, sizeof(seed), (BYTE *) &seed))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGenRandom");
    }
    srand(seed);
    hr = S_OK;

error:
    return(hr);

}


HRESULT
GenerateString(
    DWORD cnt,
    BYTE *pbStr)
{
    HRESULT hr;
    DWORD i;
    BYTE *pb;

    hr = SeedRNG();
    _JumpIfError(hr, error, "SeedRNG");

    pb = pbStr;
    for (i = 0; i < cnt; i++)
    {
        do
        {
            *pb = rand() % 0x7f;
        } while (!IsCharPrintableString(*pb));
        pb++;
    }
    *pb = '\0';

    // Turn leading and trailing Blanks into '.' characters?
    if (g_fAllowDups && 0 < cnt)
    {
	if (' ' == *pbStr)
	{
	    *pbStr = '.';
	}
	pb--;
	if (' ' == *pb)
	{
	    *pb = '.';
	}
    }

error:
    return(hr);

}


void
FreeLocalMemory(
    NAMETABLE *pNameTable)
{
    NAMEENTRY *pNameEntry = NULL;
    DWORD i;

    pNameEntry = pNameTable->pNameEntry;
    for (i = 0; i < pNameTable->cnt; i++)
    {
        if (NULL != pNameEntry->pbData)
	{
	    LocalFree(pNameEntry->pbData);
	}
	pNameEntry++;
    }
    LocalFree(pNameTable->pNameEntry);
}


HRESULT
GenerateNameTable(
    NAMETABLE *pNameTable)
{
    HRESULT hr;
    NAMEENTRY *pNameEntryAlloc = NULL;
    NAMEENTRY *pNameEntry;
    DWORD cbString;
    BYTE *pbString;
    DWORD i;
    DWORD j;
    DWORD cRetry;

    hr = SeedRNG();
    _JumpIfError(hr, error, "SeedRNG");

    pNameTable->cnt = rand() % g_crdnMax;	// 0 is Ok

    if (1 < g_fPrintProperties)
    {
	wprintf(L"NumEntries = %u\n", pNameTable->cnt);
    }
    for (i = 0; i < g_crdnSubject; i++)
    {
	g_ardnSubject[i].cbRemain = g_ardnSubject[i].cbMaxConcatenated;
    }

    pNameEntryAlloc = (NAMEENTRY *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    pNameTable->cnt * sizeof(NAMEENTRY));

    if (NULL == pNameEntryAlloc)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pNameTable->pNameEntry = pNameEntryAlloc;

    for (i = 0; i < pNameTable->cnt; i++)
    {
	RDNENTRY *prdne = NULL;

	pNameEntry = &pNameTable->pNameEntry[i];

        for (cRetry = 0; !g_fAllowDups || cRetry < 2 * pNameTable->cnt; cRetry++)
        {
	    pNameEntry->iRDN = rand() % g_crdnSubject;
	    prdne = &g_ardnSubject[pNameEntry->iRDN];

            if (g_fAllowDups)
	    {
		if (2 > prdne->cbRemain)
		{
		    continue;		// Skip if less than 2 characters left
		}
	    }
	    else
            {            
                for (j = 0; j < i; j++)
                {
                    if (pNameEntry->iRDN == pNameTable->pNameEntry[j].iRDN)
                    {
                       break;
                    }
                }
		if (j < i)
		{
		    continue;		// Skip if a disallowed duplicate
		}
            }
	    break;
        }
	if (g_fAllowDups && cRetry >= 2 * pNameTable->cnt)
	{
	    if (1 < g_fPrintProperties)
	    {
		wprintf(L"Reducing NumEntries = %u --> %i\n", pNameTable->cnt, i);
	    }
	    pNameTable->cnt = i;	// too many retries -- reduce count & quit
	    break;
	}
        
        if (NULL == prdne)
        {
            hr = E_UNEXPECTED;
            _JumpError(hr, error, "prdne NULL");
        }

        pNameEntry->pszObjId = prdne->pszObjId;
        pNameEntry->BerTag = prdne->BerTag;

	assert(2 <= prdne->cbRemain);
	do
	{
            cbString = rand() % min(prdne->cbMaxString, prdne->cbRemain);
	} while (0 == cbString);

	// Reduce remaining count by length of string plus separator: "\n"

	if (1 < g_fPrintProperties)
	{
	    wprintf(
		L"  RDN(%u): %hs=%u/%u/%u/",
		i,
		prdne->pszShortName,
		cbString,
		prdne->cbMaxString,
		prdne->cbRemain);
	}
	prdne->cbRemain -= cbString;
	if (0 < prdne->cbRemain)
	{
	    prdne->cbRemain--;
	}

	// Limit each string to (prdne->cbMaxString + 1) chars, including
	// trailing '\0':

	assert(cbString <= prdne->cbMaxString); // leave room for '\0' in DB

	pbString = (BYTE *) LocalAlloc(LMEM_FIXED, cbString + 1);
	if (NULL == pbString)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	hr = GenerateString(cbString, pbString);
	_JumpIfError(hr, error, "GenerateString");

	if (1 < g_fPrintProperties)
	{
	    wprintf(L"%u: \"%hs\"\n", prdne->cbRemain, pbString);
	}
	pNameEntry->cbData = cbString;
	pNameEntry->pbData = pbString;
    }
    pNameEntryAlloc = NULL;

error:
    if (NULL != pNameEntryAlloc)
    {
	FreeLocalMemory(pNameTable);
    }
    return(hr);
}


HRESULT
GenerateTestNameTable(
    NAMETABLE *pNameTable)
{
    HRESULT hr;
    NAMEENTRY *pNameEntryAlloc = NULL;
    NAMEENTRY *pNameEntry;
    DWORD cbString;
    BYTE *pbString;
    DWORD i;
    DWORD j;
    char szTest[2];

    pNameEntryAlloc = (NAMEENTRY *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    sizeof(NAMEENTRY) * g_crdnSubject);

    if (NULL == pNameEntryAlloc)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pNameTable->cnt = g_crdnSubject;
    pNameTable->pNameEntry = pNameEntryAlloc;

    szTest[0] = 'a';
    szTest[1] = '\0';

    for (i = 0; i < g_crdnSubject; i++)
    {
	pNameEntry = &pNameTable->pNameEntry[i];
        pNameEntry->pszObjId = g_ardnSubject[i].pszObjId;
        pNameEntry->BerTag = g_ardnSubject[i].BerTag;

        pbString = (BYTE *) LocalAlloc(LMEM_FIXED, sizeof(szTest));
        if (NULL == pbString)
        {
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
        }
        CopyMemory(pbString, szTest, sizeof(szTest));
        pNameEntry->cbData = sizeof(szTest) - 1;
        pNameEntry->pbData = pbString;
	if ('z' == szTest[0])
	{
	    szTest[0] = 'a';
	}
	else
	{
	    szTest[0]++;
	}
    }
    pNameEntryAlloc = NULL;
    hr = S_OK;

error:
    if (NULL != pNameEntryAlloc)
    {
	FreeLocalMemory(pNameTable);
    }
    return(hr);
}


BOOL
PreparePrivateKeyForImport(
    IN BYTE *pbBlob,
    IN DWORD cbBlob,
    OUT BSAFE_PRV_KEY *pPriKey,
    IN OUT DWORD *pcbPriKey,
    OUT BSAFE_PUB_KEY *pPubKey,
    IN OUT DWORD *pcbPubKey)
{
    EXPORT_PRV_KEY *pExportKey = (EXPORT_PRV_KEY *) pbBlob;
    DWORD cbHalfModLen;
    DWORD cbPub;
    DWORD cbPri;
    BYTE *pbIn;
    BYTE *pbOut;

    if (RSA2 != pExportKey->magic)
    {
        return(FALSE);
    }
    cbHalfModLen = pExportKey->bitlen / 16;

    cbPub = sizeof(BSAFE_PUB_KEY) + (cbHalfModLen + sizeof(DWORD)) * 2;
    cbPri = sizeof(BSAFE_PRV_KEY) + (cbHalfModLen + sizeof(DWORD)) * 10;
    if (NULL == pPriKey || NULL == pPubKey)
    {
        *pcbPubKey = cbPub;
        *pcbPriKey = cbPri;
        return(TRUE);
    }

    if (*pcbPubKey < cbPub || *pcbPriKey < cbPri)
    {
        *pcbPubKey = cbPub;
        *pcbPriKey = cbPri;
        return(FALSE);
    }
    else
    {
        // form the public key
        ZeroMemory(pPubKey, *pcbPubKey);
        pPubKey->magic = RSA1;
        pPubKey->keylen = (cbHalfModLen + sizeof(DWORD)) * 2;
        pPubKey->bitlen = pExportKey->bitlen;
        pPubKey->datalen = cbHalfModLen * 2 - 1;
        pPubKey->pubexp = pExportKey->pubexp;

        pbIn = pbBlob + sizeof(EXPORT_PRV_KEY);
        pbOut = (BYTE *) pPubKey + sizeof(BSAFE_PUB_KEY);

        CopyMemory(pbOut, pbIn, cbHalfModLen * 2);

        // form the private key
        ZeroMemory(pPriKey, *pcbPriKey);
        pPriKey->magic = pExportKey->magic;
        pPriKey->keylen = (cbHalfModLen + sizeof(DWORD)) * 2;
        pPriKey->bitlen = pExportKey->bitlen;
        pPriKey->datalen = cbHalfModLen * 2 - 1;
        pPriKey->pubexp = pExportKey->pubexp;

        pbOut = (BYTE *) pPriKey + sizeof(BSAFE_PRV_KEY);

        CopyMemory(pbOut, pbIn, cbHalfModLen * 2);

        pbOut += (cbHalfModLen + sizeof(DWORD)) * 2;
        pbIn += cbHalfModLen * 2;
        CopyMemory(pbOut, pbIn, cbHalfModLen);

        pbOut += cbHalfModLen + sizeof(DWORD);
        pbIn += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);

        pbOut += cbHalfModLen + sizeof(DWORD);
        pbIn += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);

        pbOut += cbHalfModLen + sizeof(DWORD);
        pbIn += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);

        pbOut += cbHalfModLen + sizeof(DWORD);
        pbIn += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);

        pbOut += cbHalfModLen + sizeof(DWORD);
        pbIn += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen * 2);
    }
    *pcbPubKey = cbPub;
    *pcbPriKey = cbPri;
    return(TRUE);
}


HRESULT
GetPrivateKeyStuff(
    PctPrivateKey **ppKey)
{
    HRESULT hr;
    BYTE *pbData;
    PctPrivateKey *pKey = NULL;
    HCRYPTKEY hKey = NULL;

    if (!CryptAcquireContext(
			&g_hMe,
			g_wszTestKey,
			MS_DEF_PROV,
			PROV_RSA_FULL,
			CRYPT_DELETEKEYSET))
    {
	hr = myHLastError();
	_PrintError(hr, "CryptAcquireContext");
    }

    if (!CryptAcquireContext(
			&g_hMe,
			g_wszTestKey,
			MS_DEF_PROV,
			PROV_RSA_FULL,
			CRYPT_NEWKEYSET))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }

    if (!CryptGetUserKey(g_hMe, AT_SIGNATURE, &hKey))
    {
	hr = myHLastError();
	_PrintError2(hr, "CryptGetUserKey", hr);

        if (!CryptGenKey(g_hMe, AT_SIGNATURE, CRYPT_EXPORTABLE, &hKey))
        {
            hr = myHLastError();
	    _JumpError(hr, error, "CryptGenKey");
        }
    }

    g_cbPrivateKey = sizeof(g_CAPIPrivateKey);

    if (!CryptExportKey(
		    hKey,
		    0,
		    PRIVATEKEYBLOB,
		    0L,
		    &g_CAPIPrivateKey[0],
		    &g_cbPrivateKey))
    {
        hr = myHLastError();
	_JumpError(hr, error, "CryptExportKey");
    }

    pbData = &g_CAPIPrivateKey[sizeof(BLOBHEADER)];

    if (!PreparePrivateKeyForImport(
				pbData,
				g_cbPrivateKey - sizeof(BLOBHEADER),
				NULL,
				&g_cbRSAPrivateKey,
				NULL,
				&g_cbRSAPublicKey))
    {
        hr = NTE_BAD_KEY;
	_JumpError(hr, error, "PreparePrivateKeyForImport");
    }

    pKey = (PctPrivateKey *) LocalAlloc(
				LMEM_FIXED,
				g_cbRSAPrivateKey + sizeof(PctPrivateKey));

    g_pRSAPublicKey = (BSAFE_PUB_KEY *) LocalAlloc(
					    LMEM_FIXED,
					    g_cbRSAPublicKey);

    if (pKey == NULL || g_pRSAPublicKey == NULL)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pKey->cbKey = g_cbRSAPrivateKey;
    if (!PreparePrivateKeyForImport(
				pbData,
				g_cbPrivateKey - sizeof(BLOBHEADER),
				(BSAFE_PRV_KEY *) pKey->pKey,
				&g_cbRSAPrivateKey,
				g_pRSAPublicKey,
				&g_cbRSAPublicKey))
    {
        hr = NTE_BAD_KEY;
	_JumpError(hr, error, "PreparePrivateKeyForImport");
    }
    hr = S_OK;

error:
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    *ppKey = pKey;
    return(hr);
}


VOID
ReverseMemCopy(
    OUT BYTE *pbDest,
    IN BYTE const *pbSource,
    IN DWORD cb)
{
    BYTE *pb;

    pb = pbDest + cb - 1;
    do
    {
        *pb-- = *pbSource++;
    } while (pb >= pbDest);
}


BOOL WINAPI
SigRSAMD5Sign(
    IN BYTE *pbData,
    IN DWORD cbData,
    OUT BYTE *pbSigned,
    OUT DWORD *pcbSigned,
    IN PctPrivateKey const *pKey)
{
    MD5_CTX DigCtx;
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *) pKey->pKey;
    BYTE LocalBuffer[300];
    BYTE LocalOutput[300];
    DWORD cb;

    //DumpHex(pbData, cbData);
    if (pk->datalen > sizeof(LocalBuffer)) 
    {
        return(FALSE);
    }

    // Generate the checksum
    MD5Init(&DigCtx);
    MD5Update(&DigCtx, pbData, cbData);
    MD5Final(&DigCtx);

    FillMemory(LocalBuffer, pk->keylen, 0);

    ReverseMemCopy(LocalBuffer, DigCtx.digest, 16);
    ReverseMemCopy(LocalBuffer + 16, MD5_PRELUDE, sizeof(MD5_PRELUDE));
    cb = sizeof(MD5_PRELUDE) + 16;
    LocalBuffer[cb++] = 0;
    while (cb < pk->datalen - 1)
    {
        LocalBuffer[cb++] = 0xff;
    }

    // Make into pkcs block type 1
    LocalBuffer[pk->datalen - 1] = 1;

    *pcbSigned = pk->datalen + 1;

    if (!BSafeDecPrivate(pk, LocalBuffer, LocalOutput))
    {
        return(FALSE);
    }
    ReverseMemCopy(pbSigned, LocalOutput,  *pcbSigned);
    //DumpHex(pbSigned, *pcbSigned);
    return(TRUE);
}


long
EncodeSubjectPubKeyInfo(
    IN PctPrivateKey const *pKey,
    OUT BYTE *pbBuffer)
{
    BYTE *pbEncoded;
    LONG cbResult;
    LONG cbResultHeader;
    LONG PkResult;
    LONG PkResultHeader;
    BYTE *pbSave;
    BYTE *pbBitString;
    BYTE *pbBitStringBase;
    BYTE *pbTop;
    DWORD EstimatedLength;
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *) pKey->pKey;

    // Encode public key now...

    EstimatedLength = pk->datalen + 32;

    pbEncoded = pbBuffer;

    cbResultHeader = EncodeHeader(pbEncoded, EstimatedLength);
    pbEncoded += cbResultHeader;

    pbTop = pbEncoded;

    cbResult = EncodeAlgorithm(pbEncoded, ALGTYPE_KEYEXCH_RSA_MD5);
    if (0 > cbResult)
    {
        return(-1);
    }
    pbEncoded += cbResult;

    // now, serialize the rsa key data:

    pbBitString = (BYTE *) LocalAlloc(LMEM_FIXED, EstimatedLength);
    if (NULL == pbBitString)
    {
        return(-1);
    }
    pbBitStringBase = pbBitString;

    // Encode the Sequence header, public key base and exponent as integers

    PkResultHeader = EncodeHeader(pbBitString, EstimatedLength);
    pbBitString += PkResultHeader;

    pbSave = pbBitString;

    PkResult = EncodeInteger(pbBitString, (BYTE *) (pk + 1), pk->keylen);
    pbBitString += PkResult;

    PkResult = EncodeInteger(pbBitString, (BYTE *) &pk->pubexp, sizeof(DWORD));
    pbBitString += PkResult;

    // Rewrite the bitstring header with an accurate length.

    PkResult = EncodeHeader(
			pbBitStringBase,
			SAFE_SUBTRACT_POINTERS(pbBitString, pbSave));

    // Encode the public key sequence as a raw bitstring, and free the memory.

    cbResult = EncodeBitString(
			pbEncoded,
			pbBitStringBase,
			SAFE_SUBTRACT_POINTERS(pbBitString, pbBitStringBase));
    pbEncoded += cbResult;

    LocalFree(pbBitStringBase);

    // Rewrite the header with an accurate length.

    cbResult = EncodeHeader(pbBuffer, SAFE_SUBTRACT_POINTERS(pbEncoded, pbTop));

    return(cbResult + SAFE_SUBTRACT_POINTERS(pbEncoded, pbTop));
}


#if 0
a0 <len>		BER_OPTIONAL | 0 -- Request Attributes
    30 <len>		BER_SEQUENCE
	06 <len>	BER_OBJECT_ID -- szOID_CERT_EXTENSIONS
	31 <len>	BER_SET
	    30 <len>	BER_SEQUENCE
		30 <len>	BER_SEQUENCE	(extension[0])
		    06 <len> BER_OBJECT_ID
		    01 <len> BER_BOOL (Optional)
		    04 <len> BER_OCTET_STRING

		30 <len>	BER_SEQUENCE	(extension[1])
		    06 <len> BER_OBJECT_ID
		    04 <len> BER_OCTET_STRING

		30 <len>	BER_SEQUENCE	(extension[2])
		    06 <len> BER_OBJECT_ID
		    04 <len> BER_OCTET_STRING
#endif


long
AllocEncodeUnicodeString(
    IN WCHAR const *pwszCertType,
    OUT BYTE **ppbOut)
{
    BYTE *pb = NULL;
    LONG cb;

    cb = EncodeUnicodeString(NULL, pwszCertType);
    pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == pb)
    {
	cb = -1;
	goto error;
    }
    *ppbOut = pb;
    EncodeUnicodeString(pb, pwszCertType);

error:
    return(cb);
}


long
AllocEncodeExtensionArray(
    IN DWORD cExt,
    IN CERT_EXTENSION const *aExt,
    OUT BYTE **ppbExtensions)
{
    BYTE *pb;
    DWORD i;
    LONG cb;
    LONG cbExtTotal;
    LONG acbLen[3];
    LONG *acbExt = NULL;

    *ppbExtensions = NULL;

    acbExt = (LONG *) LocalAlloc(LMEM_FIXED, cExt * sizeof(acbExt[0]));
    if (NULL == acbExt)
    {
	cbExtTotal = -1;
	_JumpError(-1, error, "LocalAlloc");
    }

    // Construct size from the bottom up.

    cbExtTotal = 0;
    for (i = 0; i < cExt; i++)
    {
	// BER_OBJECT_ID: Extension OID

	cb = EncodeObjId(NULL, aExt[i].pszObjId);
	if (-1 == cb)
	{
	    _JumpError(-1, error, "EncodeObjId");
	}
	acbExt[i] = cb;

	if (aExt[i].fCritical)
	{
	    // BER_BOOL: fCritical

	    acbExt[i] += 1 + EncodeLength(NULL, 1);
	    acbExt[i]++;			// boolean value
	}

	// BER_OCTET_STRING: Extension octet string value
	
	acbExt[i] += 1 + EncodeLength(NULL, aExt[i].Value.cbData);
	acbExt[i] += aExt[i].Value.cbData;	// octet string

	// BER_SEQUENCE: Extension Sequence

	cbExtTotal += 1 + EncodeLength(NULL, acbExt[i]);
	cbExtTotal += acbExt[i];
    }

    // BER_SEQUENCE: Extension Array Sequence

    acbLen[2] = cbExtTotal;
    cbExtTotal += 1 + EncodeLength(NULL, cbExtTotal);

    // BER_SET: Attribute Value

    acbLen[1] = cbExtTotal;
    cbExtTotal += 1 + EncodeLength(NULL, cbExtTotal);

    // BER_OBJECT_ID: Attribute OID

    cb = EncodeObjId(NULL, szOID_CERT_EXTENSIONS);
    if (-1 == cb)
    {
	_JumpError(-1, error, "EncodeObjId");
    }
    cbExtTotal += cb;

    // BER_SEQUENCE: Attribute Array Sequence

    acbLen[0] = cbExtTotal;
    cbExtTotal += 1 + EncodeLength(NULL, cbExtTotal);

    // Allocate memory and encode the extensions

    pb = (BYTE *) LocalAlloc(LMEM_FIXED, cbExtTotal);
    if (NULL == pb)
    {
	cbExtTotal = -1;
	_JumpError(-1, error, "LocalAlloc");
    }
    *ppbExtensions = pb;

    *pb++ = BER_SEQUENCE;		// Attribute Array Sequence
    pb += EncodeLength(pb, acbLen[0]);

    pb += EncodeObjId(pb, szOID_CERT_EXTENSIONS);

    *pb++ = BER_SET;			// Attribute Value
    pb += EncodeLength(pb, acbLen[1]);

    *pb++ = BER_SEQUENCE;		// Extension Array Sequence
    pb += EncodeLength(pb, acbLen[2]);

    CSASSERT(*ppbExtensions + cbExtTotal >= pb);

    for (i = 0; i < cExt; i++)
    {
	CSASSERT(*ppbExtensions + cbExtTotal > pb);

	*pb++ = BER_SEQUENCE;		// Extension Sequence
	pb += EncodeLength(pb, acbExt[i]);

	// BER_OBJECT_ID: Extension OID

	pb += EncodeObjId(pb, aExt[i].pszObjId);

	if (aExt[i].fCritical)
	{
	    *pb++ = BER_BOOL;		// fCritical
	    pb += EncodeLength(pb, 1);
	    *pb++ = 0xff;
	}

	*pb++ = BER_OCTET_STRING;	// Extension octet string value
	pb += EncodeLength(pb, aExt[i].Value.cbData);

	CopyMemory(pb, aExt[i].Value.pbData, aExt[i].Value.cbData);
	pb += aExt[i].Value.cbData;
    }
    CSASSERT(*ppbExtensions + cbExtTotal == pb);

error:
    if (NULL != acbExt)
    {
	LocalFree(acbExt);
    }
    return(cbExtTotal);
}


long
EncodeExtensions(
    IN WCHAR const *pwszCertType,
    OUT BYTE **ppbExtensions)
{
    LONG cbExt;
    BYTE *pbExt = NULL;
    CERT_EXTENSION aExt[1];
    DWORD cExt = 0;
    DWORD i;

    // Allocate memory and construct the CertType extension:

    aExt[cExt].pszObjId = szOID_ENROLL_CERTTYPE_EXTENSION;
    aExt[cExt].fCritical = FALSE;
    aExt[cExt].Value.cbData = AllocEncodeUnicodeString(
						pwszCertType,
						&aExt[cExt].Value.pbData);
    //DumpHex(aExt[cExt].Value.pbData, aExt[cExt].Value.cbData);
    cExt++;


    cbExt = AllocEncodeExtensionArray(cExt, aExt, ppbExtensions);
    if (-1 == cbExt)
    {
	_JumpError(-1, error, "AllocEncodeExtensionArray");
    }

error:
    for (i = 0; i < cExt; i++)
    {
	if (NULL != aExt[i].Value.pbData)
	{
	    LocalFree(aExt[i].Value.pbData);
	}
    }
    return(cbExt);
}


HRESULT
EncodeRequest(
    IN PctPrivateKey const *pKey,
    IN NAMETABLE const *pNameTable,
    OUT BYTE **ppbRequest,
    OUT DWORD *pcbRequest)
{
    HRESULT hr;
    BYTE *pbRequest0Alloc = NULL;
    BYTE *pbRequest1Alloc = NULL;
    BYTE *pbSigAlloc = NULL;

    BYTE *pbRequest0;

    BYTE *pbSave;
    BYTE *pbEncoded;

    BYTE *pbExt;
    LONG cbExt;

    LONG cbResult;
    LONG cbEncoded;
    BYTE bZero;
    LONG cbDN;
    DWORD cbRequest0;
    DWORD cbRequest1;
    LONG cbLenRequest;
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *) pKey->pKey;

    cbExt = EncodeExtensions(L"User", &pbExt);
    if (-1 == cbExt)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "EncodeExtensions");
    }
    //DumpHex(pbExt, cbExt);

    cbDN = EncodeDN(NULL, pNameTable);
    if (-1 == cbDN)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "EncodeDN");
    }
    cbRequest0 = pk->datalen + 32 + cbDN + 16 + cbExt + 3;
    pbRequest0Alloc = (BYTE *) LocalAlloc(LMEM_FIXED, cbRequest0);
    if (NULL == pbRequest0Alloc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pbRequest0 = pbRequest0Alloc;
    pbEncoded = pbRequest0;

    // Encode BER_SEQUENCE: Version+Subject+Key+Attributes Sequence

    cbLenRequest = EncodeHeader(pbEncoded, cbRequest0);
    pbEncoded += cbLenRequest;

    pbSave = pbEncoded;		// Save pointer past sequence length

    // Encode integer 0: Version 1 PKCS10

    bZero = (BYTE) CERT_REQUEST_V1;
    pbEncoded += EncodeInteger(pbEncoded, &bZero, sizeof(bZero));

    // Encode sequence of names

    cbResult = EncodeDN(pbEncoded, pNameTable);
    if (0 > cbResult)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "EncodeDN");
    }
    pbEncoded += cbResult;

    cbResult = EncodeSubjectPubKeyInfo(pKey, pbEncoded);
    if (0 > cbResult)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "EncodeSubjectPubKeyInfo");
    }
    pbEncoded += cbResult;

    // Encode attributes:
    // BER_OPTIONAL | 0: Attribute Field

    cbResult = EncodeAttributeHeader(pbEncoded, cbExt);
    pbEncoded += cbResult;
    CopyMemory(pbEncoded, pbExt, cbExt);
    pbEncoded += cbExt;

    // Encode BER_SEQUENCE: Version+Subject+Key+Attributes Sequence (again)

    cbEncoded = SAFE_SUBTRACT_POINTERS(pbEncoded, pbSave);
    cbResult = EncodeHeader(pbRequest0, cbEncoded);

    // If the header sequence length takes up less space than we anticipated,
    // add the difference to the base pointer and encode the header again,
    // right before the encoded data.

    if (cbResult != cbLenRequest)
    {
        CSASSERT(cbResult < cbLenRequest);
	pbRequest0 += cbLenRequest - cbResult;

	// Encode BER_SEQUENCE: Version+Subject+Key+Attributes Sequence (again)

	cbResult = EncodeHeader(pbRequest0, cbEncoded);
    }

    cbRequest0 = cbResult + SAFE_SUBTRACT_POINTERS(pbEncoded, pbSave);
    //DumpHex(pbRequest0, cbRequest0);

    // How much space do we need?

    cbRequest1 = cbRequest0 + pk->datalen + 32;
    pbRequest1Alloc = (BYTE *) LocalAlloc(LMEM_FIXED, cbRequest1);
    if (NULL == pbRequest1Alloc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pbEncoded = pbRequest1Alloc;

    // Encode BER_SEQUENCE: outer Request Sequence

    cbLenRequest = EncodeHeader(pbEncoded, cbRequest1);
    pbEncoded += cbLenRequest;

    pbSave = pbEncoded;		// Save pointer past outer sequence length

    CopyMemory(pbEncoded, pbRequest0, cbRequest0);

    pbEncoded += cbRequest0;

    cbResult = EncodeAlgorithm(pbEncoded, ALGTYPE_SIG_RSA_MD5);
    pbEncoded += cbResult;

    //DumpHex(pbRequest1Alloc, cbRequest1);

    cbResult = pk->datalen + 16;
    pbSigAlloc = (BYTE *) LocalAlloc(LMEM_FIXED, cbResult);
    if (NULL == pbSigAlloc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!SigRSAMD5Sign(
	    pbRequest0,
	    cbRequest0,
	    pbSigAlloc,
	    (DWORD *) &cbResult,
	    pKey))
    {
	hr = E_FAIL;
	_JumpError(hr, error, "SigRSAMD5Sign");
    }

    pbEncoded += EncodeBitString(pbEncoded, pbSigAlloc, cbResult);

    cbEncoded = SAFE_SUBTRACT_POINTERS(pbEncoded, pbSave);
    cbResult = EncodeHeader(pbRequest1Alloc, cbEncoded);
    cbRequest1 = cbResult + cbEncoded;

    if (cbResult != cbLenRequest)
    {
        if (cbResult > cbLenRequest)
        {
	    // The chunk has actually grown from the estimate.

            BYTE *pbT;
	    
            pbT = (BYTE *) LocalAlloc(LMEM_FIXED, cbRequest1);
            if (NULL == pbT)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }

	    EncodeHeader(pbT, cbEncoded);
	    CopyMemory(
		    pbT + cbResult,
		    pbSave,
		    cbEncoded);

	    LocalFree(pbRequest1Alloc);
	    pbRequest1Alloc = pbT;
        }
        else
        {
	    cbResult = EncodeHeader(pbRequest1Alloc, cbEncoded);
            MoveMemory(
		pbRequest1Alloc + cbResult,
		pbRequest1Alloc + cbLenRequest,
		cbEncoded);
        }
    }
    *ppbRequest = pbRequest1Alloc;
    *pcbRequest = cbRequest1;
    pbRequest1Alloc = NULL;
    //DumpHex(*ppbRequest, *pcbRequest);
    hr = S_OK;

error:
    if (NULL != pbSigAlloc)
    {
	LocalFree(pbSigAlloc);
    }
    if (NULL != pbRequest1Alloc)
    {
	LocalFree(pbRequest1Alloc);
    }
    if (NULL != pbRequest0Alloc)
    {
	LocalFree(pbRequest0Alloc);
    }
    if (NULL != pbExt)
    {
	LocalFree(pbExt);
    }
    return(hr);
}


HRESULT
GetAndCompareProperty(
    CERT_NAME_INFO *pNameInfo,
    char const *pszObjId,
    char const *pszValue,
    BYTE **pbProp,
    DWORD *pcbProp,
    BOOL *pfMatch)
{
    HRESULT hr;
    CERT_RDN_ATTR *prdnaT;
    CERT_RDN *prdn;
    CERT_RDN *prdnEnd;

    *pfMatch = FALSE;
    prdnaT = NULL;
    for (
	prdn = pNameInfo->rgRDN, prdnEnd = &prdn[pNameInfo->cRDN];
	prdn < prdnEnd;
	prdn++)
    {
	CERT_RDN_ATTR *prdna;
	CERT_RDN_ATTR *prdnaEnd;

	for (
	    prdna = prdn->rgRDNAttr, prdnaEnd = &prdna[prdn->cRDNAttr];
	    prdna < prdnaEnd;
	    prdna++)
	{
	    if (0 == strcmp(prdna->pszObjId, pszObjId))
	    {
		prdnaT = prdna;

		if (prdnaT->Value.cbData == strlen(pszValue) &&
		    0 == memcmp(pszValue, prdnaT->Value.pbData, prdnaT->Value.cbData))
		{
		    *pfMatch = TRUE;
		}
		else if (g_fAllowDups)
		{
		    continue;
		}
		prdn = prdnEnd;	// exit outer for loop, too.
		break;
	    }
	}
    }
    if (NULL == prdnaT)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError2(hr, error, "Missing Property", CERTSRV_E_PROPERTY_EMPTY);
    }
    *pbProp = prdnaT->Value.pbData;
    *pcbProp = prdnaT->Value.cbData;
    hr = S_OK;

error:
    return(hr);

}


HRESULT
CheckProperties(
    DWORD ReqId,
    NAMETABLE *pNameTable,
    DWORD CertNumber,
    CERT_NAME_INFO *pNameInfo)
{
    HRESULT hr;
    BYTE *pbProp;
    DWORD cbProp;
    DWORD i;
    DWORD dwCount = 0;
    BOOL fMatch;

    if (g_fPrintProperties)
    {
        wprintf(
	    L"Properties for Certificate %u, RequestId %u:\n",
	    CertNumber,
	    ReqId);
    }

    for (i = 0; i < pNameTable->cnt; i++)
    {
	NAMEENTRY *pNameEntry;
	RDNENTRY *prdn;

	pNameEntry = &pNameTable->pNameEntry[i];
	prdn = &g_ardnSubject[pNameEntry->iRDN];

        hr = GetAndCompareProperty(
		    pNameInfo,
		    prdn->pszObjId,
		    (char const *) pNameEntry->pbData,
		    &pbProp,
		    &cbProp,
		    &fMatch);

        if (CERTSRV_E_PROPERTY_EMPTY == hr)
        {
	    //_PrintError(hr, "GetAndCompareProperty");
	    pbProp = NULL;
            hr = S_OK;
        }
	_JumpIfError(hr, error, "GetAndCompareProperty");

        if (NULL != pbProp && !fMatch && !g_fEnterpriseCA)
        {
	    wprintf(
		L"Property doesn't match: Expected %hs=\"%hs\", pbProp = \"%hs\"\n",
		prdn->pszShortName,
		pNameEntry->pbData,
		pbProp);

            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "GetAndCompareProperty: no match");
        }

        if (g_fPrintProperties)
        {
	    DWORD ccol;

#define CCOL_OID 10
	    ccol = strlen(prdn->pszObjId) + 1;
	    if (ccol < CCOL_OID)
	    {
		ccol = CCOL_OID - ccol;
	    }
	    else
	    {
		ccol = 0;
	    }
            wprintf(
		L"  %u: %hs: %*s%hs=%hs%hs%hs\n",
		i,
		prdn->pszObjId,
		ccol,
		"",
		prdn->pszShortName,
		NULL == pbProp? "" : "\"",
		NULL == pbProp? " -- MISSING --" : (char const *) pbProp,
		NULL == pbProp? "" : "\"");
        }
    }
    if (g_fPrintProperties)
    {
        wprintf(L"\n");
    }
    hr = S_OK;

error:
    return(hr);

}


HRESULT
EncodeRenewal(
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    OUT BYTE **ppbRenewal,
    OUT DWORD *pcbRenewal)
{
    HRESULT hr;

    *ppbRenewal = (BYTE *) LocalAlloc(LMEM_FIXED, cbRequest);
    if (NULL == *ppbRenewal)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*ppbRenewal, pbRequest, cbRequest);
    *pcbRenewal = cbRequest;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
SubmitRequest(
    OPTIONAL IN DISPATCHINTERFACE *pdiRequest,
    IN DWORD Flags,
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszConfig,
    OUT DWORD *pRequestIdOut,
    OUT DWORD *pDisposition,
    OUT HRESULT *phrLastStatus,
    OUT WCHAR **ppwszDisposition,
    OUT BYTE **ppbCert,
    OUT DWORD *pcbCert)
{
    HRESULT hr;
    WCHAR *pwszRequest = NULL;
    BSTR strCert = NULL;
    BSTR strCertChain = NULL;
    BSTR strDisposition = NULL;
    BYTE *pbCert = NULL;
    DWORD cbCert;
    BYTE const *pbChain;
    DWORD cbChain;
    CERTSERVERENROLL *pcsEnroll = NULL;
    WCHAR *pwszServer = NULL;
    WCHAR *pwszAuthority = NULL;
    WCHAR *pwszDisposition;

    *phrLastStatus = S_OK;
    *ppwszDisposition = NULL;
    *ppbCert = NULL;
    *pRequestIdOut = 0;

    if (NULL == pdiRequest)
    {
	hr = mySplitConfigString(pwszConfig, &pwszServer, &pwszAuthority);
	_JumpIfError(hr, error, "mySplitConfigString");

	// CertServerSubmitRequest can only handle binary requests;
	// pass the request in binary form, and pass Flags to so indicate.

	hr = CertServerSubmitRequest(
				CR_IN_BINARY | Flags,
				pbRequest,
				cbRequest,
				pwszAttributes,
				pwszServer,
				pwszAuthority,
				&pcsEnroll);
	_JumpIfError(hr, error, "CertServerSubmitRequest");

	*phrLastStatus = pcsEnroll->hrLastStatus;
	_PrintIfError2(
		*phrLastStatus,
		"pcsEnroll->hrLastStatus Real Status",
		HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

	pwszDisposition = pcsEnroll->pwszDispositionMessage;
	*pDisposition = pcsEnroll->Disposition;
	*pRequestIdOut = pcsEnroll->RequestId;
    }
    else
    {
	hr = myCryptBinaryToString(
			    pbRequest,
			    cbRequest,
			    CRYPT_STRING_BASE64REQUESTHEADER,
			    &pwszRequest);
	_JumpIfError(hr, error, "myCryptBinaryToString");

	if (g_fRPC)
	{
	    Flags |= CR_IN_RPC;
	}
	hr = Request_Submit(
			pdiRequest,
			CR_IN_BASE64HEADER | Flags,
			pwszRequest,
			sizeof(WCHAR) * wcslen(pwszRequest),
			pwszAttributes,
			pwszConfig,
			(LONG *) pDisposition);
	if (S_OK != hr)
	{
	    _PrintError2(
		    hr,
		    "Request_Submit",
		    HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

	    // Collect the RequestId for potential error reporting:
	    Request_GetRequestId(pdiRequest, (LONG *) pRequestIdOut);

	    hr = Request_GetLastStatus(pdiRequest, phrLastStatus);
	    _JumpIfError(hr, error, "Request_GetLastStatus");

	    if (FAILED(*phrLastStatus))
	    {
		hr = *phrLastStatus;
	    }
	    _JumpError2(
		    hr,
		    error,
		    "Request_GetLastStatus Real Status",
		    HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	}
	hr = Request_GetLastStatus(pdiRequest, phrLastStatus);
	_JumpIfError(hr, error, "Request_GetLastStatus");

	_PrintIfError(*phrLastStatus, "Request_GetLastStatus Real Status");

	hr = Request_GetDispositionMessage(pdiRequest, &strDisposition);
	_JumpIfError(hr, error, "Request_GetDispositionMessage");

	hr = Request_GetRequestId(pdiRequest, (LONG *) pRequestIdOut);
	_JumpIfError(hr, error, "Request_GetrequestId");

	pwszDisposition = strDisposition;
    }

    if (CR_DISP_ISSUED == *pDisposition)
    {
	if (NULL == pdiRequest)
	{
	    cbCert = pcsEnroll->cbCert;
	    pbCert = (BYTE *) LocalAlloc(LMEM_FIXED, cbCert);
	    if (NULL == pbCert)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    CopyMemory(pbCert, pcsEnroll->pbCert, cbCert);
	}
	else
	{
	    hr = Request_GetCertificate(
				    pdiRequest,
				    CR_OUT_BASE64HEADER,
				    &strCert);
	    _JumpIfError(hr, error, "Request_GetCertificate");

	    hr = myCryptStringToBinary(
				strCert,
				wcslen(strCert),
				CRYPT_STRING_BASE64HEADER,
				&pbCert,
				&cbCert,
				NULL,
				NULL);
	    _JumpIfError(hr, error, "myCryptStringToBinary");
	}

	if (g_fSave)
	{
	    hr = EncodeToFileW(
			L"test.crt",
			pbCert,
			cbCert,
			DECF_FORCEOVERWRITE | CRYPT_STRING_BINARY);
	    _JumpIfError(hr, error, "EncodeToFileW");

	    if (NULL == pdiRequest)
	    {
		pbChain = pcsEnroll->pbCertChain;
		cbChain = pcsEnroll->cbCertChain;
	    }
	    else
	    {
		hr = Request_GetCertificate(
					pdiRequest,
					CR_OUT_BINARY | CR_OUT_CHAIN,
					&strCertChain);
		_JumpIfError(hr, error, "Request_GetCertificate");

		pbChain = (BYTE const *) strCertChain;
		cbChain = SysStringByteLen(strCertChain);
	    }
	    hr = EncodeToFileW(
			L"testchain.crt",
			pbChain,
			cbChain,
			DECF_FORCEOVERWRITE | CRYPT_STRING_BINARY);
	    _JumpIfError(hr, error, "EncodeToFileW");
	}
    }

    if (NULL != pwszDisposition)
    {
	*ppwszDisposition = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				(wcslen(pwszDisposition) + 1) * sizeof(WCHAR));
	if (NULL == *ppwszDisposition)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(*ppwszDisposition, pwszDisposition);
    }
    *pcbCert = cbCert;
    *ppbCert = pbCert;
    pbCert = NULL;
    hr = S_OK;

error:
    if (NULL != pwszServer)
    {
	LocalFree(pwszServer);
    }
    if (NULL != pwszAuthority)
    {
	LocalFree(pwszAuthority);
    }
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    if (NULL != pcsEnroll)
    {
	CertServerFreeMemory(pcsEnroll);
    }
    if (NULL != strCertChain)
    {
	SysFreeString(strCertChain);
    }
    if (NULL != strCert)
    {
	SysFreeString(strCert);
    }
    if (NULL != strDisposition)
    {
	SysFreeString(strDisposition);
    }
    if (NULL != pwszRequest)
    {
	LocalFree(pwszRequest);
    }
    return(hr);
}


HRESULT
TestOneRequest(
    IN PctPrivateKey const *pKey,
    OPTIONAL IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszConfig,
    IN DWORD CertNumber,
    OUT DWORD *pRequestId,
    OUT DWORD *pTimeOneRequest)
{
    HRESULT hr;
    HRESULT hrLastStatus;
    NAMETABLE NameTable;
    BOOL fTableAllocated;
    BYTE *pbRequest;
    DWORD cbRequest;
    BYTE *pbCert;
    DWORD cbCert;
    CERT_CONTEXT const *pCertContext;
    DWORD RequestIdOut = 0;
    DWORD Disposition;
    WCHAR *pwszDisposition = NULL;
    CERT_NAME_INFO *pNameInfo;
    DWORD cbNameInfo;
    CERT_INFO const *pCertInfo;
    LONG Flags;
    WCHAR wszAttributes[MAX_PATH];

    fTableAllocated = FALSE;
    pbRequest = NULL;
    pbCert = NULL;
    pCertContext = NULL;
    pNameInfo = NULL;

    if (g_fDebug)
    {
	hr = GenerateTestNameTable(&NameTable);
	_JumpIfError(hr, error, "GenerateTestNameTable");
    }
    else
    {
	hr = GenerateNameTable(&NameTable);
	_JumpIfError(hr, error, "GenerateNameTable");
    }

    fTableAllocated = TRUE;

    hr = EncodeRequest(pKey, &NameTable, &pbRequest, &cbRequest);
    _JumpIfError(hr, error, "EncodeRequest");

    Flags = CR_IN_PKCS10;

    if (g_fRenewal)
    {
	BYTE *pbTmp;

	hr = EncodeRenewal(pbRequest, cbRequest, &pbTmp, &cbRequest);
	_JumpIfError(hr, error, "EncodeRenewal");

	LocalFree(pbRequest);
	pbRequest = pbTmp;
	Flags = CR_IN_PKCS7;
    }

    if (g_fSave)
    {
	hr = EncodeToFileW(
		    L"test.req",
		    pbRequest,
		    cbRequest,
		    DECF_FORCEOVERWRITE | CRYPT_STRING_BINARY);
	_JumpIfError(hr, error, "EncodeToFileW");
    }

    *pTimeOneRequest = 0 - GetTickCount();

    wsprintf(
	wszAttributes,
	L"\n"
	    L" attrib 1 end : value 1 end \t\r\n"
	    L"\tattrib 2 end:value_2_end\n"
	    L" \tattrib3:value-3-end\r\n"
	    L"Version:3\n"
	    L"RequestType:CertGen\n"
	    L"CertGenSequence:%u\n",
	CertNumber);

    hr = SubmitRequest(
		    pdiRequest,
		    Flags,
		    pbRequest,
		    cbRequest,
		    wszAttributes,
		    pwszConfig,
		    &RequestIdOut,
		    &Disposition,
		    &hrLastStatus,
		    &pwszDisposition,
		    &pbCert,
		    &cbCert);

    *pTimeOneRequest += GetTickCount();

    if (S_OK != hr)
    {
	_JumpError2(
		hr,
		error,
		"SubmitRequest",
		HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
    }
    if (CR_DISP_ISSUED != Disposition)
    {
	hr = hrLastStatus;
	if (S_OK == hr)
	{
	    hr = E_FAIL;
	}
	wprintf(
	    L"SubmitRequest disposition=%x (%ws)\n",
	    Disposition,
	    NULL == pwszDisposition? L"???" : pwszDisposition);
	{
	    WCHAR const *pwszMsg = myGetErrorMessageText(hr, TRUE);

	    if (NULL != pwszMsg)
	    {
		wprintf(L"%ws\n", pwszMsg);
		LocalFree(const_cast<WCHAR *>(pwszMsg));
	    }
	}
	if (g_fIgnoreError)
	{
	    hr = S_OK;
	}
	if (CR_DISP_DENIED == Disposition && g_fIgnoreAccessDenied)
	{
	    hr = S_OK;
	}
	_JumpError(hr, error, "Cert not issued!");
    }

    pCertContext = CertCreateCertificateContext(
					    X509_ASN_ENCODING,
					    pbCert,
					    cbCert);
    if (NULL == pCertContext)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    pCertInfo = pCertContext->pCertInfo;

    if (!myDecodeName(
		    X509_ASN_ENCODING,
		    X509_NAME,
		    pCertInfo->Subject.pbData,
		    pCertInfo->Subject.cbData,
		    CERTLIB_USE_LOCALALLOC,
		    &pNameInfo,
		    &cbNameInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }

    hr = CheckProperties(RequestIdOut, &NameTable, CertNumber, pNameInfo);
    _JumpIfError(hr, error, "CheckProperties");

error:
    *pRequestId = RequestIdOut;
    if (NULL != pwszDisposition)
    {
	LocalFree(pwszDisposition);
    }
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    if (NULL != pCertContext)
    {
	CertFreeCertificateContext(pCertContext);
    }
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    if (NULL != pbRequest)
    {
	LocalFree(pbRequest);
    }
    if (fTableAllocated)
    {
	FreeLocalMemory(&NameTable);
    }
    return(hr);
}


HRESULT
TestMain()
{
    HRESULT hr;
    PctPrivateKey *pKey = NULL;
    DWORD TimeStartTest;
    DWORD TimeStartLastN;
    DWORD TimeRequestTotal = 0;
    DWORD TimeRequestLastN = 0;
    DWORD TimeElapsedTotal;
    DWORD TotalCount = 0;
    DISPATCHINTERFACE diRequest;
    DISPATCHINTERFACE *pdiRequest = NULL;
    BOOL fCoInit = FALSE;
    DWORD RequestId = 0;
    WCHAR const *pwszConfig;
    BSTR strConfig = NULL;

    g_crdnMax = g_crdnSubject;
    hr = GetPrivateKeyStuff(&pKey);
    _JumpIfError(hr, error, "GetPrivateKeyStuff");

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    if (1 >= g_fRPC)
    {
	hr = Request_Init(g_DispatchFlags, &diRequest);
	_JumpIfError(hr, error, "Request_Init");

	pdiRequest = &diRequest;
    }
    pwszConfig = g_pwszConfig;
    if (NULL == pwszConfig)
    {
	hr = ConfigGetConfig(g_DispatchFlags, CC_LOCALACTIVECONFIG, &strConfig);
	_JumpIfError(hr, error, "ConfigGetConfig");

	pwszConfig = strConfig;
    }
    if (NULL != pdiRequest)
    {
	ENUM_CATYPES CAType;
	
	hr = Request2_GetCAProperty(
			pdiRequest,
			pwszConfig,
			CR_PROP_CATYPE,
			0,			// Index
			PROPTYPE_LONG,
			CV_OUT_BINARY,
			(VOID *) &CAType);
	_JumpIfError(hr, error, "Request2_GetCAProperty");

	if (IsEnterpriseCA(CAType))
	{
	    g_fEnterpriseCA = TRUE;
	}
    }


    TimeStartLastN = TimeStartTest = GetTickCount();
    while (TotalCount < g_MaximumCount)
    {
	DWORD TimeOneRequest;
	DWORD TimeRequestEnd;
	DWORD TimeElapsedLastN;

	hr = TestOneRequest(
			pKey,
			pdiRequest,
			pwszConfig,
			TotalCount + 1,
			&RequestId,
			&TimeOneRequest);
	if (S_OK != hr)
	{
	    WCHAR const *pwszMsg;

	    pwszMsg = myGetErrorMessageText(hr, TRUE);

	    CONSOLEPRINT3((
		DBG_SS_CERTREQ,
		"RequestId %u: %hs%ws\n",
		RequestId,
		HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr && g_fIgnoreError?
		    "Ignoring error: " : "",
		NULL != pwszMsg? pwszMsg : L"Message retrieval Error"));
	    if (NULL != pwszMsg)
	    {
		LocalFree(const_cast<WCHAR *>(pwszMsg));
	    }
	}
	if (HRESULT_FROM_WIN32(ERROR_INVALID_DATA) != hr || !g_fIgnoreError)
	{
	    _JumpIfError(hr, error, "TestOneRequest");
	}

	TimeRequestEnd = GetTickCount();

	TimeRequestTotal += TimeOneRequest;
	TimeRequestLastN += TimeOneRequest;
	TimeElapsedTotal = TimeRequestEnd - TimeStartTest;
	TimeElapsedLastN = TimeRequestEnd - TimeStartLastN;

        TotalCount++;

	if (g_fTime)
	{
	    if (0 == g_IntervalCount || 0 == (TotalCount % g_IntervalCount))
	    {
		DWORD count;
		
		count = g_IntervalCount;
		if (0 == count)
		{
		    count = TotalCount;
		}

		TimeElapsedLastN = TimeRequestEnd - TimeStartLastN;

		wprintf(
		    L"RequestId %u: %u/%u Certs in %u/%u seconds (ave=%u/%u ms)\n",
		    RequestId,
		    count,
		    TotalCount,
		    MSTOSEC(TimeElapsedLastN),
		    MSTOSEC(TimeElapsedTotal),
		    TimeElapsedLastN/count,
		    TimeElapsedTotal/TotalCount);
		if (0 != g_IntervalCount)
		{
		    TimeRequestLastN = 0;
		    TimeStartLastN = GetTickCount();
		}
	    }
	}
    }

error:
    if (NULL != pKey)
    {
	LocalFree(pKey);
    }
    if (NULL != g_pRSAPublicKey)
    {
	LocalFree(g_pRSAPublicKey);
    }
    if (NULL != pdiRequest)
    {
	Request_Release(pdiRequest);
    }
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (fCoInit)
    {
	CoUninitialize();
    }

    if (0 != TotalCount)
    {
	wprintf(
	    L"\n%u Total Certificates in %u/%u seconds (request/elapsed time)\n",
	    TotalCount,
	    MSTOSEC(TimeRequestTotal),
	    MSTOSEC(TimeElapsedTotal));
	wprintf(
	    L"Certificates required average of %u/%u milliseconds "
		L"(request/elapsed time)\n",
	    TimeRequestTotal/TotalCount,
	    TimeElapsedTotal/TotalCount);
    }
    return(hr);
}


void
Usage(TCHAR *pwszError)
{
    wprintf(L"%ws\n", pwszError);
    wprintf(L"%ws\n", wszUsage);
    exit(1);
}


extern "C" int __cdecl
wmain(int argc, WCHAR *argv[])
{
    HRESULT hr;

    while (1 < argc && myIsSwitchChar(argv[1][0]))
    {
	WCHAR *pwsz = argv[1];

	while (NULL != pwsz && *++pwsz != '\0')
	{
	    switch (*pwsz)
	    {
		case 'a':
		case 'A':
		    g_fIgnoreAccessDenied++;
		    break;

		case 'c':
		case 'C':
		    if (0 == LSTRCMPIS(pwsz, L"config"))
		    {
			if (1 >= argc)
			{
			    Usage(TEXT("Missing -config argument"));
			}
			g_pwszConfig = argv[2];
		    }
		    else
		    {
			if (2 >= argc || !iswdigit(argv[2][0]) || '\0' != pwsz[1])
			{
			    Usage(TEXT("Missing numeric -c argument"));
			}
			g_MaximumCount = _wtoi(argv[2]);
		    }
		    argc--;
		    argv++;
		    pwsz = NULL;
		    break;

		case 'd':
		case 'D':
		    g_fDebug++;
		    break;

		case 'e':
		case 'E':
		    g_fEnterpriseCA++;
		    break;

		case 'i':
		case 'I':
		    g_fIgnoreError++;
		    break;

		case 'm':
		case 'M':
		    g_fShowTime++;
		    break;

		case 'p':
		case 'P':
		    g_fPrintProperties++;
		    break;

		case 'r':
		case 'R':
		    if (0 == LSTRCMPIS(pwsz, L"renewal"))
		    {
			g_fRenewal++;
			pwsz = NULL;
		    }
		    else
		    if (0 == LSTRCMPIS(pwsz, L"rpc"))
		    {
			g_fRPC++;
			if (0 == lstrcmp(pwsz, L"RPC"))
			{
			    g_fRPC++;
			}
			pwsz = NULL;
		    }
		    else
		    {
			g_fSave++;
		    }
		    break;

		case 't':
		case 'T':
		    g_fTime++;
		    g_IntervalCount = 10;
		    if (2 < argc && iswdigit(argv[2][0]))
		    {
			if ('\0' != pwsz[1])
			{
			    Usage(TEXT("Missing numeric -t argument"));
			}
			g_IntervalCount = _wtoi(argv[2]);
			argc--;
			argv++;
			pwsz = NULL;
		    }
		    break;

		case 'z':
		case 'Z':
		    g_fAllowDups++;
		    g_crdnMax *= 5;
		    break;

		case 'h':
		case 'H':
		default:
		    Usage(TEXT("CertGen Usage"));
	    }
	}
	argc--;
	argv++;
    }
    if (argc != 1)
    {
	Usage(TEXT("Extra arguments"));
    }

    if (g_fShowTime)
    {
        SYSTEMTIME st;
        GetSystemTime(&st);
        wprintf(L"Start time: %2i:%2i:%2i:%i\n", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
    }

    hr = TestMain();

    if (g_fShowTime)
    {
        SYSTEMTIME st;

        GetSystemTime(&st);
        wprintf(L"End time: %2i:%2i:%2i:%i\n", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

        wprintf(L"type any key to finish->");
        _getch();
        wprintf(L"\n");
    }
    myRegisterMemDump();
    return((int) hr);
}


// We need this to include RSA library
extern "C" BOOL
GenRandom(ULONG huid, BYTE *pbBuffer, size_t dwLength)
{
    wprintf(L"Error GenRandom called\n");
    ExitProcess(0);
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\genreq\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//

#define IDI_APP                         201
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\genreq\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#define __DIR__		"genreq"

#include <stdlib.h>
#include <assert.h>
#include <ctype.h>
#include <windows.h>

#define DBG_CERTSRV_DEBUG_PRINT
#include "certlib.h"	            // debug allocator

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\genreq\enc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       enc.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "encode.h"


OIDTRANSLATE const *
LookupOidTranslate(
    IN CHAR const *pszObjId)
{
    DWORD i;
    OIDTRANSLATE const *pOid = NULL;

    for (i = 0; i < g_cOidTranslate; i++)
    {
	if (0 == strcmp(pszObjId, g_aOidTranslate[i].pszObjId))
	{
	    pOid = &g_aOidTranslate[i];
	    break;
	}
    }
    CSASSERT(NULL != pOid);
    return(pOid);
}


long
EncodeObjId(
    OPTIONAL OUT BYTE *pbEncoded,
    IN CHAR const *pszObjId)
{
    OIDTRANSLATE const *pOid;
    long cbLength;

    pOid = LookupOidTranslate(pszObjId);

    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_OBJECT_ID;
    }
    cbLength = EncodeLength(pbEncoded, pOid->cbOIDEncoded);

    if (NULL != pbEncoded)
    {
        CopyMemory(
		pbEncoded + cbLength,
		pOid->abOIDEncoded,
		pOid->cbOIDEncoded);
    }
    return(1 + cbLength + pOid->cbOIDEncoded);
}


//+*************************************************************************
// EncodeLength ASN1 encodes a length field.  The parameter
// dwLen is the length to be encoded, it is a DWORD and    
// therefore may be no larger than 2^32.  The pbEncoded    
// parameter is the encoded result, and memory must be     
// allocated for it by the caller.  The pbEncoded parameter
// indicates if the result is to be written to the pbEncoded
// parameter.  The function cannot fail and returns the    
// number of total bytes in the encoded length.            
// encoded length.                                         
//**************************************************************************

// Notes:	Encodes 0x0000 to 0x007f as <lobyte>
//		Encodes 0x0080 to 0x00ff as <81>, <lobyte>
//		Encodes 0x0100 to 0xffff as <82>, <hibyte>, <lobyte>

long
EncodeLength(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen)
{
    // length is between 2^8 and 2^16 - 1

    if (dwLen > 0xff)
    {
	if (NULL != pbEncoded)
        {
            pbEncoded[0] = 0x82;
            pbEncoded[1] = (BYTE) (dwLen >> 8);
            pbEncoded[2] = (BYTE) dwLen;
        }
        return(3);
    }

    // length is between 2^7 and 2^8 - 1

    if (dwLen > 0x7f)
    {
	if (NULL != pbEncoded)
        {
            pbEncoded[0] = 0x81;
            pbEncoded[1] = (BYTE) dwLen;
        }
        return(2);
    }

    // length is between 0 and 2^7 - 1

    if (NULL != pbEncoded)
    {
	pbEncoded[0] = (BYTE) dwLen;
    }
    return(1);
}


long
EncodeNull(
    OPTIONAL OUT BYTE *pbEncoded)
{
    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_NULL;
        *pbEncoded = 0;
    }
    return(2);
}


//+*************************************************************************
// EncodeAlgid ASN1 encodes an algorithm identifier. The   
// parameter Algid is the algorithm identifier as an ALG_ID
// type.  pbEncoded is the parameter used to pass back the 
// encoded result, and memory must be allocated for it by  
// the caller.  The pbEncoded parameter indicates if the   
// result is to be written to the pbEncoded parameter      
// The function returns a -1 if it fails and otherwise     
// returns the number of total bytes in the encoded        
// algorithm identifier.                                   
//**************************************************************************

long
EncodeAlgid(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD Algid)
{
    DWORD i;
    LONG cb = -1;

    // determine the algorithm id which is to be encoded and
    // copy the appropriate encoded algid into the destination

    for (i = 0; i < g_cAlgIdTranslate; i++)
    {
        if (Algid == g_aAlgIdTranslate[i].AlgId)
        {
	    cb = EncodeObjId(pbEncoded, g_aAlgIdTranslate[i].pszObjId);
	    break;
        }
    }
    return(cb);
}


long
EncodeAlgorithm(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD AlgId)
{
    BYTE abTemp[32];
    long cbResult;
    BYTE *pb;

    pb = abTemp;

    // Take a guess at the total length:

    pb += EncodeHeader(pb, sizeof(abTemp));

    cbResult = EncodeAlgid(pb, AlgId);
    if (cbResult == -1)
    {
	return(-1);
    }
    pb += cbResult;

    cbResult += EncodeNull(pb);

    // Fix up the total length:

    cbResult += EncodeHeader(abTemp, cbResult);

    if (NULL != pbEncoded)
    {
        CopyMemory(pbEncoded, abTemp, cbResult);
    }
    return(cbResult);

}


//+*************************************************************************
// EncodeInteger ASN1 encodes an integer.  The pbInt parameter 
// is the integer as an array of bytes, and dwLen is the number
// of bytes in the array.  The least significant byte of the   
// integer is the zeroth byte of the array.  The encoded result
// is passed back in the pbEncoded parameter.  The pbEncoded   
// indicates if the result is to be written to the pbEncoded   
// parameter. The function cannot fail and returns the number  
// of total bytes in the encoded integer.                      
// This implementation will only deal with positive integers.  
//**************************************************************************

long
EncodeInteger(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbInt,
    IN DWORD dwLen)
{
    DWORD iInt;
    long j;			// Must be signed!
    LONG cbResult;
    LONG cbLength;

    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_INTEGER;
    }
    cbResult = 1;

    // find the most significant non-zero byte

    for (iInt = dwLen - 1; pbInt[iInt] == 0; iInt--)
    {
	if (iInt == 0)	// if the integer value is 0
	{
	    if (NULL != pbEncoded)
	    {
		*pbEncoded++ = 0x01;
		*pbEncoded++ = 0x00;
	    }
	    return(cbResult + 2);
	}
    }

    // if the most significant bit of the most significant byte is set then add
    // a 0 byte to the beginning.

    if (pbInt[iInt] > 0x7f)
    {
	// encode the length

	cbLength = EncodeLength(pbEncoded, iInt + 2);

	// set the first byte of the integer to 0 and increment pointer

	if (NULL != pbEncoded)
	{
	    pbEncoded += cbLength;
	    *pbEncoded++ = 0;
	}
	cbResult++;
    }
    else
    {
	// encode the length

	cbLength = EncodeLength(pbEncoded, iInt + 1);
	if (NULL != pbEncoded)
	{
	    pbEncoded += cbLength;
	}
    }
    cbResult += cbLength;

    // copy the integer bytes into the encoded buffer

    if (NULL != pbEncoded)
    {
	// copy the integer bytes into the encoded buffer

	for (j = iInt; j >= 0; j--)
	{
	    *pbEncoded++ = pbInt[j];
	}
    }
    cbResult += iInt + 1;
    return(cbResult);
}


long
EncodeUnicodeString(
    OPTIONAL OUT BYTE *pbEncoded,
    IN WCHAR const *pwsz)
{
    long cbLength;
    long cbData = wcslen(pwsz) * sizeof(WCHAR);

    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_UNICODE_STRING;
    }
    cbLength = EncodeLength(pbEncoded, cbData);

    if (NULL != pbEncoded)
    {
        pbEncoded += cbLength;
	for ( ; L'\0' != *pwsz; pwsz++)
	{
	    *pbEncoded++ = (BYTE) (*pwsz >> 8);
	    *pbEncoded++ = (BYTE) *pwsz;
	}
    }
    return(1 + cbLength + cbData);
}


//+*************************************************************************
// EncodeIA5String ASN1 encodes a character string.  The pbStr    
// parameter is the string as an array of characters, and dwLen
// is the number of characters in the array.  The encoded result
// is passed back in the pbEncoded parameter.  The pbEncoded   
// indicates if the result is to be written to the pbEncoded   
// parameter. The function cannot fail and returns the number  
// of total bytes in the encoded string.                       
//**************************************************************************

long
EncodeIA5String(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbStr,
    IN DWORD dwLen)
{
    long cbLength;

    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_IA5_STRING;
    }
    cbLength = EncodeLength(pbEncoded, dwLen);

    if (NULL != pbEncoded)
    {
        CopyMemory(pbEncoded + cbLength, pbStr, dwLen);
    }
    return(1 + cbLength + dwLen);
}


//+*************************************************************************
// EncodeOctetString ASN1 encodes a string of hex valued       
// characters. The pbStr parameter is an array of characters,  
// and dwLen is the number of characters in the array.  The    
// encoded result is passed back in the pbEncoded parameter. The
// pbEncoded parameter indicates if the result is to be written
// to the pbEncoded parameter. The function cannot fail and    
// returns the number of total bytes in the encoded octet string
//**************************************************************************

long
EncodeOctetString(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbStr,
    IN DWORD dwLen)
{
    long cbLength;

    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_OCTET_STRING;
    }
    cbLength = EncodeLength(pbEncoded, dwLen);

    if (NULL != pbEncoded)
    {
        CopyMemory(pbEncoded + cbLength, pbStr, dwLen);
    }
    return(1 + cbLength + dwLen);
}


//+*************************************************************************
// EncodeBitString ASN1 encodes a string of bit characters. The
// pbStr parameter is an array of characters (bits), and dwLen 
// is the number of characters in the array.  The encoded result
// is passed back in the pbEncoded parameter.  The pbEncoded   
// indicates if the result is to be written to the pbEncoded   
// parameter. The function cannot fail and returns the number  
// of total bytes in the encoded string.  This function uses   
// the DER.                                                    
//**************************************************************************

long
EncodeBitString(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbStr,
    IN DWORD dwLen)
{
    long cbLength;

    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_BIT_STRING;
    }
    cbLength = EncodeLength(pbEncoded, dwLen + 1);

    if (NULL != pbEncoded)
    {
	pbEncoded += cbLength;

        // the next byte tells how many unused bits there are in the last byte,
        // but this will always be zero in this implementation (DER)

        *pbEncoded++ = 0;
        CopyMemory(pbEncoded, pbStr, dwLen);
    }
    return(1 + cbLength + 1 + dwLen);
}


//+---------------------------------------------------------------------------
//
//  Function:   EncodeFileTime
//
//  Synopsis:   Encodes a FILETIME to a ASN.1 format time string.
//
//  Arguments:  [pbEncoded] --
//              [Time]      --
//              [UTC]       -- Indicate Time is UTC (true) or local (false)
//              [WriteFlag] --
//
//  History:    8-10-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
long
EncodeFileTime(
    OPTIONAL OUT BYTE *pbEncoded,
    IN FILETIME Time,
    IN BOOL UTC)
{
    if (NULL != pbEncoded)
    {
	SYSTEMTIME st;
	FILETIME ft;
	int count;

	if (UTC)
	{
	    ft = Time;
	}
	else
	{
	    LocalFileTimeToFileTime(&Time, &ft);
	}

	FileTimeToSystemTime(&ft, &st);

	*pbEncoded++ = BER_UTC_TIME;

	count = EncodeLength(pbEncoded, 13);

	// NOTE ON Y2K COMPLIANCE: This is test tool.  WE WILL NOT FIX THIS
	// CODE!  It is only used to encode current dates, anyway,

	pbEncoded++;
	st.wYear %= 100;

	*pbEncoded++ = (BYTE) ((st.wYear / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wYear % 10) + '0');

	*pbEncoded++ = (BYTE) ((st.wMonth / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wMonth % 10) + '0');

	*pbEncoded++ = (BYTE) ((st.wDay / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wDay % 10) + '0');

	*pbEncoded++ = (BYTE) ((st.wHour / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wHour % 10) + '0');

	*pbEncoded++ = (BYTE) ((st.wMinute / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wMinute % 10) + '0');

	*pbEncoded++ = (BYTE) ((st.wSecond / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wSecond % 10) + '0');

	*pbEncoded = 'Z';
    }

    // Tag(1) + Len(1) + Year(2) + Month(2) + Day(2) +
    // Hour(2) + Min(2) + Sec(2) + 'Z'(1) --> 15

    return(15);
}


//+*************************************************************************
// EncodeHeader ASN1 encodes a header for a sequence type. The 
// dwLen is the length of the encoded information in the       
// sequence.  The pbEncoded indicates if the result is to be   
// written to the pbEncoded parameter.  The function cannot    
// fail and returns the number of total bytes in the encoded   
// header.                                                     
//**************************************************************************

// Notes:	Encodes header as <BER_SEQUENCE>, <length>

long
EncodeHeader(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen)
{
    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_SEQUENCE;
    }
    return(1 + EncodeLength(pbEncoded, dwLen));
}


//+*************************************************************************
// EncodeSetOfHeader ASN1 encodes a header for a set of type.  
// The dwLen is the length of the encoded information in the   
// set of.  The pbEncoded indicates if the result is to be     
// written to the pbEncoded parameter.  The function cannot    
// fail and returns the number of total bytes in the encoded   
// header.                                                     
//**************************************************************************

// Notes:	Encodes header as <SET_OF_TAG>, <length>

long
EncodeSetOfHeader(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen)
{
    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_SET_RAW;
    }
    return(1 + EncodeLength(pbEncoded, dwLen));
}


// Notes:	Encodes header as <BER_OPTIONAL | 0>, <length>

long
EncodeAttributeHeader(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen)
{
    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_OPTIONAL | 0;
    }
    return(1 + EncodeLength(pbEncoded, dwLen));
}


// Notes:	Encodes header as <BER_SET>, <length>

long
EncodeSetHeader(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen)
{
    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_SET;
    }
    return(1 + EncodeLength(pbEncoded, dwLen));
}


//+*************************************************************************
// EncodeName ASN1 encodes a Name type. The pbName parameter is
// the name and dwLen is the length of the name in bytes.      
// The pbEncoded indicates if the result is to be written to   
// the pbEncoded parameter.  The function cannot fail and      
// returns the number of total bytes in the encoded name.
//**************************************************************************

long
EncodeName(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbName,
    IN DWORD dwLen)
{
    BYTE Type[MAXOBJIDLEN];
    long TypeLen;
    BYTE Value[MAXNAMEVALUELEN+MINHEADERLEN];
    long ValueLen;
    BYTE Attribute[MAXNAMELEN];
    long AttributeLen;
    BYTE SetHdr[MINHEADERLEN];
    long HdrLen;
    long NameLen;

    // encode the name value
    ValueLen = EncodeIA5String(Value, pbName, dwLen);

    // encode the attribute type, this is an object identifier and here it
    // is a fake encoding
    Type[0] = 0x06;
    Type[1] = 0x01;
    Type[2] = 0x00;

    TypeLen = 3;

    // encode the header for the attribute
    AttributeLen = EncodeHeader(Attribute, ValueLen + TypeLen);

    // copy the attribute type and value into the attribute

    CopyMemory(Attribute + AttributeLen, Type, TypeLen);
    AttributeLen += TypeLen;

    CopyMemory(Attribute + AttributeLen, Value, ValueLen);
    AttributeLen += ValueLen;

    // encode set of header

    HdrLen = EncodeSetOfHeader(SetHdr, AttributeLen);

    // encode Name header

    NameLen = EncodeHeader(pbEncoded, HdrLen + AttributeLen);
    if (NULL != pbEncoded)
    {
	CopyMemory(pbEncoded + NameLen, SetHdr, HdrLen);
    }

    NameLen += HdrLen;
    if (NULL != pbEncoded)
    {
	CopyMemory(pbEncoded + NameLen, Attribute, AttributeLen);
    }

    return(NameLen + AttributeLen);
}


long
EncodeRDN(
    OPTIONAL OUT BYTE *pbEncoded,
    IN NAMEENTRY const *pNameEntry)
{
    LONG cbResult;
    LONG Length;
    DWORD cbOIDandData;
    DWORD cbSequence;
    OIDTRANSLATE const *pOidName;

    // Compute the size of the encoded OID and RDN string, with BER encoding
    // tags and lengths.
   
    pOidName = LookupOidTranslate(pNameEntry->pszObjId);
    cbOIDandData =
	    1 +
	    EncodeLength(NULL, pOidName->cbOIDEncoded) +
	    pOidName->cbOIDEncoded +
	    1 +
	    EncodeLength(NULL, pNameEntry->cbData) +
	    pNameEntry->cbData;

    cbSequence = 1 + EncodeLength(NULL, cbOIDandData) + cbOIDandData;

    Length = EncodeSetHeader(pbEncoded, cbSequence);
    if (NULL != pbEncoded)
    {
	pbEncoded += Length;
    }

    cbResult = EncodeHeader(pbEncoded, cbOIDandData);
    if (NULL != pbEncoded)
    {
	pbEncoded += cbResult;
        *pbEncoded++ = BER_OBJECT_ID;
    }
    Length += cbResult + 1;

    cbResult = EncodeLength(pbEncoded, pOidName->cbOIDEncoded);
    if (NULL != pbEncoded)
    {
	pbEncoded += cbResult;
	CopyMemory(pbEncoded, pOidName->abOIDEncoded, pOidName->cbOIDEncoded);
	pbEncoded += pOidName->cbOIDEncoded;

	*pbEncoded++ = pNameEntry->BerTag;
    }
    Length += cbResult + pOidName->cbOIDEncoded + 1;

    cbResult = EncodeLength(pbEncoded, pNameEntry->cbData);
    Length += cbResult;

    if (NULL != pbEncoded)
    {
        CopyMemory(pbEncoded + cbResult, pNameEntry->pbData, pNameEntry->cbData);
    }
    return(Length + pNameEntry->cbData);
}


long
EncodeDN(
    OPTIONAL OUT BYTE *pbEncoded,
    IN NAMETABLE const *pNameTable)
{
    CHAR *pszNext;
    CHAR *pszRDN;
    long Result;
    long Length;
    long SaveResult;
    NAMEENTRY const *pNameEntry;
    DWORD i;

    SaveResult = 0;		 // force one full iteration
    pNameEntry = pNameTable->pNameEntry;
    Length = 0;
    for (i = 0; i < pNameTable->cnt; i++)
    {
        Length += 9 + pNameEntry->cbData;
	pNameEntry++;
    }

    while (TRUE)
    {
	BYTE *pb;

	pb = pbEncoded;

	Result = EncodeHeader(pb, Length);
	if (SaveResult == Result)
	{
	    break;
	}
	if (NULL != pb)
	{
	    pb += Result;
	}
	SaveResult = Result;

	Length = 0;
        pNameEntry = pNameTable->pNameEntry;
	for (i = 0; i < pNameTable->cnt; i++)
        {
	    Result = EncodeRDN(pb, pNameEntry);

	    if (Result < 0)
	    {
		Length = 0;
		goto error;	// return(-1)
	    }
	    if (NULL != pb)
	    {
		pb += Result;
	    }
	    Length += Result;
            pNameEntry++;
	}
    }
error:
    return(Result + Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\genreq\table.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       table.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "encode.h"


#define iso_member	0x2a			// iso(1) memberbody(2)
#define us		0x86, 0x48		// us(840)
#define rsadsi		0x86, 0xf7, 0x0d	// rsadsi(113549)
#define pkcs		0x01			// pkcs(1)

#define rsa_dsi			iso_member, us, rsadsi
#define rsa_dsi_len		6

#define pkcs_1			iso_member, us, rsadsi, pkcs
#define pkcs_len		7

#define prefix311		0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37
#define prefix311Length		7

#define prefix19200300		0x09, 0x92, 0x26, 0x89, 0x93, 0xf2, 0x2c
#define prefix19200300Length	7


#define joint_iso_ccitt_ds	0x55
#define attributetype		0x04

#define attributeType		joint_iso_ccitt_ds, attributetype
#define attributeLength		3


const ALGIDTRANSLATE g_aAlgIdTranslate[] =
{
    {
	ALGTYPE_SIG_RSA_MD5,
	szOID_RSA_MD5RSA,		// "1.2.840.113549.1.1.4"
    },
    {
	ALGTYPE_KEYEXCH_RSA_MD5,
	szOID_RSA_RSA,			// "1.2.840.113549.1.1.1"
    },
    {
	ALGTYPE_CIPHER_RC4_MD5,
	szOID_RSA_RC4,			// "1.2.840.113549.3.4"
    }
};

const DWORD g_cAlgIdTranslate = ARRAYSIZE(g_aAlgIdTranslate);


const OIDTRANSLATE g_aOidTranslate[] =
{
    // Subject RDN OIDs:

    {
	szOID_COUNTRY_NAME,		// "2.5.4.6"
	{ attributeType, 6 },		// 0x55, 0x04, 0x06
	attributeLength,
    },
    {
	szOID_ORGANIZATION_NAME,	// "2.5.4.10"
	{ attributeType, 10 },		// 0x55, 0x04, 0x0a
	attributeLength,
    },
    {
	szOID_ORGANIZATIONAL_UNIT_NAME,	// "2.5.4.11"
	{ attributeType, 11 },		// 0x55, 0x04, 0x0b
	attributeLength,
    },
    {
	szOID_COMMON_NAME,		// "2.5.4.3"
	{ attributeType, 3 },		// 0x55, 0x04, 0x03
	attributeLength,
    },
    {
	szOID_LOCALITY_NAME,		// "2.5.4.7"
	{ attributeType, 7 },		// 0x55, 0x04, 0x07
	attributeLength,
    },
    {
	szOID_STATE_OR_PROVINCE_NAME,	// "2.5.4.8"
	{ attributeType, 8 },		// 0x55, 0x04, 0x08
	attributeLength,
    },
    {
	szOID_TITLE,			// "2.5.4.12"
	{ attributeType, 12 },		// 0x55, 0x04, 0x0c
	attributeLength,
    },
    {
	szOID_GIVEN_NAME,		// "2.5.4.42"
	{ attributeType, 42 },		// 0x55, 0x04, 0x02a
	attributeLength,
    },
    {
	szOID_INITIALS,			// "2.5.4.43"
	{ attributeType, 43 },		// 0x55, 0x04, 0x2b
	attributeLength,
    },
    {
	szOID_SUR_NAME,			// "2.5.4.4"
	{ attributeType, 4 },		// 0x55, 0x04, 0x04
	attributeLength,
    },
    {
	szOID_DOMAIN_COMPONENT,		// "0.9.2342.19200300.100.1.25"
	{ prefix19200300, 100, 1, 25 },
		// 0x09, 0x92, 0x26, 0x89, 0x93, 0xf2, 0x2c, 0x64, 0x01, 0x19
	prefix19200300Length + 3,
    },
    {
	szOID_RSA_emailAddr,		// "1.2.840.113549.1.9.1"
	{ pkcs_1, 9, 1 },
	pkcs_len + 2,
    },
    {
	szOID_STREET_ADDRESS,		// "2.5.4.9"
	{ attributeType, 9 },		// 0x55, 0x04, 0x09
	attributeLength,
    },
    {
	szOID_RSA_unstructName,		// "1.2.840.113549.1.9.2"
	{ pkcs_1, 9, 2 },
	pkcs_len + 2,
    },
    {
	szOID_RSA_unstructAddr,		// "1.2.840.113549.1.9.8"
	{ pkcs_1, 9, 8 },
	pkcs_len + 2,
    },
    {
	szOID_DEVICE_SERIAL_NUMBER,	// "2.5.4.5"
	{ attributeType, 5 },		// 0x55, 0x04, 0x05
	attributeLength,
    },

    // Non-Subject RDN OIDs:

    {
	szOID_CERT_EXTENSIONS,		// "1.3.6.1.4.1.311.2.1.14"
	{ prefix311, 2, 1, 14 },
	prefix311Length + 3,
    },
    {
	szOID_ENROLL_CERTTYPE_EXTENSION, // "1.3.6.1.4.1.311.20.2"
	{ prefix311, 20, 2 },
	prefix311Length + 2,
    },
    {
	szOID_RSA_MD5RSA,		// "1.2.840.113549.1.1.4"
	{ pkcs_1, 1, 4 },
	pkcs_len + 2
    },
    {
	szOID_RSA_RSA,			// "1.2.840.113549.1.1.1"
	{ pkcs_1, 1, 1 },
	pkcs_len + 2
    },
    {
	szOID_RSA_RC4,			// "1.2.840.113549.3.4"
	{ rsa_dsi, 3, 4 },
	rsa_dsi_len + 2
    },
};

const DWORD g_cOidTranslate = ARRAYSIZE(g_aOidTranslate);


// Limit strings to cch???MAX chars, not including the trailing '\0'

RDNENTRY g_ardnSubject[] =
{
    {
	szOID_COUNTRY_NAME,		// "2.5.4.6"
	"C",
	BER_PRINTABLE_STRING,
	cchCOUNTRYNAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_ORGANIZATION_NAME,	// "2.5.4.10"
	"O",
	BER_PRINTABLE_STRING,
	cchORGANIZATIONNAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_ORGANIZATIONAL_UNIT_NAME,	// "2.5.4.11"
	"OU",
	BER_PRINTABLE_STRING,
	cchORGANIZATIONALUNITNAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_COMMON_NAME,		// "2.5.4.3"
	"CN",
	BER_TELETEX_STRING,
	cchCOMMONNAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_LOCALITY_NAME,		// "2.5.4.7"
	"L",
	BER_PRINTABLE_STRING,
	cchLOCALITYMANAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_STATE_OR_PROVINCE_NAME,	// "2.5.4.8"
	"S",
	BER_PRINTABLE_STRING,
	cchSTATEORPROVINCENAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_TITLE,			// "2.5.4.12"
	"T",
	BER_PRINTABLE_STRING,
	cchTITLEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_GIVEN_NAME,		// "2.5.4.42"
	"G",
	BER_PRINTABLE_STRING,
	cchGIVENNAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_INITIALS,			// "2.5.4.43"
	"I",
	BER_PRINTABLE_STRING,
	cchINITIALSMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_SUR_NAME,			// "2.5.4.4"
	"SN",
	BER_PRINTABLE_STRING,
	cchSURNAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_DOMAIN_COMPONENT,		// "0.9.2342.19200300.100.1.25"
	"DC",
	BER_PRINTABLE_STRING,
	cchDOMAINCOMPONENTMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_RSA_emailAddr,		// "1.2.840.113549.1.9.1"
	"E",
	BER_IA5_STRING,
	cchEMAILMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_STREET_ADDRESS,		// "2.5.4.9"
	"STREET",
	BER_PRINTABLE_STRING,
	cchSTREETADDRESSMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_RSA_unstructName,		// "1.2.840.113549.1.9.2"
	"UnstructuredName",
	BER_PRINTABLE_STRING,
	cchUNSTRUCTUREDNAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_RSA_unstructAddr,		// "1.2.840.113549.1.9.8"
	"UnstructuredAddress",
	BER_PRINTABLE_STRING,
	cchUNSTRUCTUREDADDRESSMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_DEVICE_SERIAL_NUMBER,	// "2.5.4.5"
	"DeviceSerialNumber",
	BER_PRINTABLE_STRING,
	cchDEVICESERIALNUMBERMAX,
	CCH_DBMAXTEXT_RDN,
    },
};

const DWORD g_crdnSubject = ARRAYSIZE(g_ardnSubject);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\genreq\filter.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  Contents:	Functions for scanning strings for impermissible characters
//
//  File:       filter.cpp
//
//  History:	10-14-96	JerryK	Created
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <tchar.h>

//+-------------------------------------------------------------------------
//
//  Function:	IsCharPrintableString()
//
//  Synopsis:   Determine if a character is a valid PrintableString
//	        character in the sense of the X.520 specification with
//		the additional proviso that commas, which are acceptable
//		in the definition, are not accepted here as they eventually
//		create problems with the comma-separated certsrv.txt 
//		that mkroot produces.  (See X.680 pp. 46)
//
//  Effects:    
//
//  Arguments:  [chChar]
//
//  Returns:	TRUE/FALSE
//
//  History:	10-21-96	JerryK	Added
//
//  Notes:	Note the exclusion of commas referred to above and that
//		this deviates slightly from the PrintableString definition.
//
//--------------------------------------------------------------------------
BOOL
IsCharPrintableString(TCHAR chChar)
{
    BOOL	fRetVal=FALSE;

    if(_istascii(chChar))
    {
	if(_istalnum(chChar))
	{
	    fRetVal = TRUE;
	}
	else
	{
	    switch(chChar)
	    {
	        case TEXT(' '):
	        case TEXT('\''):
	        case TEXT('('):
	        case TEXT(')'):
	        case TEXT('+'):
      	        case TEXT('-'):
	        case TEXT('.'):
	        case TEXT('/'):
      	        case TEXT(':'):
	        case TEXT('='):
	        case TEXT('?'):
		    fRetVal = TRUE;	
		    break;
	    }
	}
    }

    return fRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\genreq\sigmsrsa.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1999
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------
* RSA Public Key Cryptosystem, RC4, MD2, MD5 and RSA are trademarks
* of RSA Data Security, Inc.
*----------------------------------------------------------------------------*/

#include <spbase.h>
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <rsa.h>
#include <md2.h>
#include <md5.h>


#ifdef __cplusplus
}
#endif


static unsigned char MD5_PRELUDE[] = {
  0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7,
  0x0d, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10
};

static unsigned char MD2_PRELUDE[] = {
  0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7,
  0x0d, 0x02, 0x02, 0x05, 0x00, 0x04, 0x10
};

static VOID
ReverseMemCopy(
    PUCHAR      Dest,
    PUCHAR      Source,
    ULONG       Size)
{
    PUCHAR  p;

    p = Dest + Size - 1;
    do
    {
        *p-- = *Source++;
    } while (p >= Dest);
}

BOOL
WINAPI
SigRSAMD2Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey);

BOOL
WINAPI
SigRSAMD5Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey);

BOOL
WINAPI SigRSASHAMD5Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey);

BOOL
WINAPI SigRSAMD2Verify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey);

BOOL
WINAPI SigRSAMD5Verify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey);

BOOL
WINAPI SigRSASHAMD5Verify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey);


#define ADVAPI32_PATH TEXT("advapi32.dll")
#define CRYPT_CREATE_HASH_NAME TEXT("CryptCreateHash")
#define CRYPT_HASH_DATA_NAME TEXT("CryptHashData")
#define CRYPT_SIGN_HASH_NAMEA TEXT("CryptSignHashA")
#define CRYPT_SIGN_HASH_NAMEW TEXT("CryptSignHashW")
#define CRYPT_DESTROY_HASH_NAME TEXT("CryptDestroyHash")
#define CRYPT_SET_HASH_PARAM_NAME TEXT("CryptSetHashParam")


typedef BOOL
( WINAPI * CRYPT_CREATE_HASH_FN)(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash);


typedef BOOL
( WINAPI * CRYPT_HASH_DATA_FN)(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags);

typedef BOOL
( WINAPI * CRYPT_DESTROY_HASH_FN) (
    HCRYPTHASH hHash);

typedef BOOL
( WINAPI * CRYPT_SIGN_HASH_FNA)(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

typedef BOOL
( WINAPI * CRYPT_SIGN_HASH_FNW)(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

typedef BOOL
( WINAPI * CRYPT_SET_HASH_PARAM_FN)(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);


HINSTANCE g_hAdvapi32 = NULL;
CRYPT_CREATE_HASH_FN g_CryptCreateHash = NULL;
CRYPT_HASH_DATA_FN   g_CryptHashData = NULL;
CRYPT_DESTROY_HASH_FN g_CryptDestroyHash = NULL;
CRYPT_SIGN_HASH_FNA g_CryptSignHashA = NULL;
CRYPT_SIGN_HASH_FNW g_CryptSignHashW = NULL;
CRYPT_SET_HASH_PARAM_FN g_CryptSetHashParam = NULL;


SignatureSystem sigRSAMD2 = { SP_SIG_RSA_MD2, SigRSAMD2Sign, SigRSAMD2Verify};
SignatureSystem sigRSAMD5 = { SP_SIG_RSA_MD5, SigRSAMD5Sign, SigRSAMD5Verify};
SignatureSystem sigRSASHAMD5 = { SP_SIG_RSA_SHAMD5, SigRSASHAMD5Sign, SigRSASHAMD5Verify};


BOOL
WINAPI capiCryptCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash)
{
    if(!g_hAdvapi32)
    {
        g_hAdvapi32 = LoadLibrary(ADVAPI32_PATH);
        if(!g_hAdvapi32) 
        {
            return FALSE;
        }
    }

    
    if(!g_CryptCreateHash)
    {
        g_CryptCreateHash = (CRYPT_CREATE_HASH_FN)GetProcAddress(g_hAdvapi32, CRYPT_CREATE_HASH_NAME);
        if(!g_CryptCreateHash)
        {
            return FALSE;
        }
    }
    return g_CryptCreateHash(hProv, Algid, hKey, dwFlags, phHash);
}


BOOL
WINAPI capiCryptHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags)
{
    if(!g_hAdvapi32)
    {
        g_hAdvapi32 = LoadLibrary(ADVAPI32_PATH);
        if(!g_hAdvapi32) 
        {
            return FALSE;
        }
    }

    
    if(!g_CryptHashData)
    {
        g_CryptHashData = (CRYPT_HASH_DATA_FN)GetProcAddress(g_hAdvapi32, CRYPT_HASH_DATA_NAME);
        if(!g_CryptHashData)
        {
            return FALSE;
        }
    }
    return g_CryptHashData(hHash, pbData, dwDataLen, dwFlags);
}


BOOL
WINAPI capiCryptDestroyHash(
    HCRYPTHASH hHash)
{
    if(!g_hAdvapi32)
    {
        g_hAdvapi32 = LoadLibrary(ADVAPI32_PATH);
        if(!g_hAdvapi32) 
        {
            return FALSE;
        }
    }

    
    if(!g_CryptDestroyHash)
    {
        g_CryptDestroyHash = (CRYPT_DESTROY_HASH_FN)GetProcAddress(g_hAdvapi32, CRYPT_DESTROY_HASH_NAME);
        if(!g_CryptDestroyHash)
        {
            return FALSE;
        }
    }
    return g_CryptDestroyHash(hHash);
}

BOOL
WINAPI capiCryptSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen)
{
    if(!g_hAdvapi32)
    {
        g_hAdvapi32 = LoadLibrary(ADVAPI32_PATH);
        if(!g_hAdvapi32) 
        {
            return FALSE;
        }
    }

    
    if(!g_CryptSignHashA)
    {
        g_CryptSignHashA = (CRYPT_SIGN_HASH_FNA)GetProcAddress(g_hAdvapi32, CRYPT_SIGN_HASH_NAMEA);
        if(!g_CryptSignHashA)
        {
            return FALSE;
        }
    }
    return g_CryptSignHashA(hHash, dwKeySpec, sDescription, dwFlags, pbSignature, pdwSigLen);
}


BOOL
WINAPI capiCryptSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen)
{
    if(!g_hAdvapi32)
    {
        g_hAdvapi32 = LoadLibrary(ADVAPI32_PATH);
        if(!g_hAdvapi32) 
        {
            return FALSE;
        }
    }

    
    if(!g_CryptSignHashW)
    {
        g_CryptSignHashW = (CRYPT_SIGN_HASH_FNW)GetProcAddress(g_hAdvapi32, CRYPT_SIGN_HASH_NAMEW);
        if(!g_CryptSignHashW)
        {
            return FALSE;
        }
    }
    return g_CryptSignHashW(hHash, dwKeySpec, sDescription, dwFlags, pbSignature, pdwSigLen);
}

BOOL
WINAPI capiCryptSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags)
{
    if(!g_hAdvapi32)
    {
        g_hAdvapi32 = LoadLibrary(ADVAPI32_PATH);
        if(!g_hAdvapi32) 
        {
            return FALSE;
        }
    }

    
    if(!g_CryptSetHashParam)
    {
        g_CryptSetHashParam = (CRYPT_SET_HASH_PARAM_FN)GetProcAddress(g_hAdvapi32, CRYPT_SET_HASH_PARAM_NAME);
        if(!g_CryptSetHashParam)
        {
            return FALSE;
        }
    }
    return g_CryptSetHashParam(hHash, dwParam, pbData, dwFlags);
}

#ifdef UNICODE
#define capiCryptSignHash  capiCryptSignHashW
#else
#define capiCryptSignHash  capiCryptSignHashA
#endif // !UNICODE


BOOL
WINAPI
SigRSAMD5Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey)
{
    MD5_CTX DigCtx;
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *)pKey->pKey;
    UCHAR LocalBuffer[300];
    UCHAR LocalOutput[300];

    unsigned int cbSize;

    if(pk->magic != RSA2 && pKey->cbKey == sizeof(HCRYPTPROV))
    {
        // This isn't a bsafe key, and it's the right size, so it must be a
	// CAPI key.  This a heuristic.

        HCRYPTHASH hHash;
        DWORD cbSigned;
        HCRYPTPROV hProv = *((HCRYPTPROV *)pKey->pKey);

        if(!capiCryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
        {
            return FALSE;
        }
        if(!capiCryptHashData(hHash, pData, cbData, 0))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }
        cbSigned = sizeof(LocalOutput);
       
        if(!capiCryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, LocalOutput, &cbSigned))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }
        capiCryptDestroyHash(hHash);
        ReverseMemCopy(pSigned, LocalOutput, cbSigned);
        *pcbSigned = cbSigned;
        return TRUE;
    }
    else if(pk->magic != RSA2)
    {
        // This isn't a bsafe key or a CAPI key, so it must be a WinSock 2 
        // LSP key.
        SSLSIGNATUREFUNC pSignHook;
        LPVOID pSignArg;

        /* Generate the checksum */
        MD5Init(&DigCtx);
        MD5Update(&DigCtx, pData, cbData);
        MD5Final(&DigCtx);

        // Get the prelude data and the hash value.
        CopyMemory(LocalBuffer, MD5_PRELUDE, sizeof(MD5_PRELUDE));
        CopyMemory(LocalBuffer + sizeof(MD5_PRELUDE), DigCtx.digest, MD5DIGESTLEN);
        
        // Get pointer to callback function.
        pSignHook = ((PSCH_CRED_SECRET_WINSOCK2)pKey->pKey)->pSignatureHookFunc;
        pSignArg  = ((PSCH_CRED_SECRET_WINSOCK2)pKey->pKey)->pSignatureHookArg;

        // Invoke the callback function.
        if(pSignHook)
        {
            if(pSignHook(SSL_SIGN_RSA,
                         pSignArg,
                         LocalBuffer,
                         sizeof(MD5_PRELUDE) + MD5DIGESTLEN,
                         0,
                         pSigned,
                         pcbSigned) != SSL_ERR_OKAY) 
            {
                return FALSE;
            } 
        }
        else
        {
            DebugLog((DEB_ERROR, "Null signature callback function!\n"));
        }

        // Return success.
        return TRUE;
    }

    cbSize = sizeof(MD5_PRELUDE)+16;
    if(pk->datalen > sizeof(LocalBuffer)) 
    {
        return FALSE;
    }

    /* Generate the checksum */
    MD5Init(&DigCtx);
    MD5Update(&DigCtx, pData, cbData);
    MD5Final(&DigCtx);

    FillMemory(LocalBuffer, pk->keylen, 0);

    ReverseMemCopy(LocalBuffer, DigCtx.digest, 16);
    ReverseMemCopy(LocalBuffer+16, MD5_PRELUDE, sizeof(MD5_PRELUDE));
    LocalBuffer[cbSize++]=0;
    while(cbSize < pk->datalen-1) {
        LocalBuffer[cbSize++] = 0xff;
    }

    /* Make into pkcs block type 1 */
    LocalBuffer[pk->datalen-1] = 1;

    *pcbSigned = pk->datalen+1;

    if(!BSafeDecPrivate(pk, LocalBuffer, LocalOutput))
    {
        return FALSE;
    }
    ReverseMemCopy(pSigned, LocalOutput,  *pcbSigned);
    return TRUE;
}

BOOL
WINAPI
SigRSAMD2Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey)
{
    MD2_CTX DigCtx;
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *)pKey->pKey;
    UCHAR LocalBuffer[500];
    UCHAR LocalOutput[500];

    unsigned int cbSize;
    if(pk->magic != RSA2)
    {
        // This is not a bsafe key, so it must be a CAPI
        // key.
        HCRYPTHASH hHash;
        DWORD cbSigned;
        HCRYPTPROV hProv = *((HCRYPTPROV *)pKey->pKey);

        if(!capiCryptCreateHash(hProv, CALG_MD2, 0, 0, &hHash))
        {
            return FALSE;
        }
        if(!capiCryptHashData(hHash, pData, cbData, 0))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }
        cbSigned = sizeof(LocalOutput);
        if(!capiCryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, LocalOutput, &cbSigned))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }
        capiCryptDestroyHash(hHash);
        ReverseMemCopy(pSigned, LocalOutput, cbSigned);
        *pcbSigned = cbSigned;
        return TRUE;
    }


    cbSize = sizeof(MD2_PRELUDE)+16;
    if(pk->datalen > sizeof(LocalBuffer))
    {
        return FALSE;
    }

    //MD2Init(&DigCtx);
    FillMemory( &DigCtx, sizeof( DigCtx ), 0 );

    MD2Update(&DigCtx, pData, cbData);
    MD2Final(&DigCtx);
    FillMemory(LocalBuffer, pk->keylen, 0);
    ReverseMemCopy(LocalBuffer, DigCtx.state, 16);
    ReverseMemCopy(LocalBuffer+16, MD2_PRELUDE, sizeof(MD2_PRELUDE));
    LocalBuffer[cbSize++]=0;
    while(cbSize < pk->datalen-1) {
        LocalBuffer[cbSize++] = 0xff;
    }

    /* Make into pkcs block type 1 */
    LocalBuffer[pk->datalen-1] = 1;

    *pcbSigned = pk->datalen+1;

    if(!BSafeDecPrivate(pk, LocalBuffer, LocalOutput))
    {
        return FALSE;
    }
    ReverseMemCopy(pSigned, LocalOutput,  *pcbSigned);
    return TRUE;
}


BOOL
WINAPI
SigRSAMD5Verify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey)
{
    MD5_CTX DigCtx;
    BSAFE_PUB_KEY *pk = (BSAFE_PUB_KEY *)pKey->pKey;
    UCHAR Buffer[500];
    UCHAR SigBuffer[500];
    DWORD iLoc;

    if(pk->datalen > sizeof(Buffer) || cbSigned != pk->datalen+1) 
    {
        return FALSE;
    }

    MD5Init(&DigCtx);
    MD5Update(&DigCtx, pData, cbData);
    MD5Final(&DigCtx);

    FillMemory(SigBuffer, pk->keylen, 0);
    FillMemory(Buffer, pk->keylen, 0);

    ReverseMemCopy(SigBuffer, pSigned, cbSigned);

    if(!BSafeEncPublic(pk, SigBuffer, Buffer))
    {
        return FALSE;
    }

    ReverseMemCopy(SigBuffer, Buffer, cbSigned);

    /* Make sure pkcs block type 1 */
    if(SigBuffer[0] != 0 || SigBuffer[1] != 1) 
    {
        return FALSE;
    }

    for(iLoc = 2; iLoc < pk->datalen; iLoc++ ){
        if(!SigBuffer[iLoc]) 
        {
            break;
        }
        if(SigBuffer[iLoc] != 0xff) 
        {
            return FALSE;
        }
    }

    if(iLoc == pk->datalen) return FALSE;

    iLoc++; /* skip past separator */


    if(memcmp(&SigBuffer[iLoc], MD5_PRELUDE, sizeof(MD5_PRELUDE))   != 0) 
    {
        return FALSE;
    }

    iLoc += sizeof(MD5_PRELUDE);
    if(memcmp(&SigBuffer[iLoc],  DigCtx.digest, 16) != 0) 
    {
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
SigRSAMD2Verify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey)
{
    MD2_CTX DigCtx;
    BSAFE_PUB_KEY *pk = (BSAFE_PUB_KEY *)pKey->pKey;
    UCHAR Buffer[500];
    UCHAR SigBuffer[500];
    DWORD iLoc;

    if ((pk->datalen > sizeof(Buffer)) ||
        (cbSigned != pk->datalen + 1))
    {
        return FALSE;
    }

    // MD2Init(&DigCtx);

    FillMemory( &DigCtx, sizeof( DigCtx ), 0 );

    MD2Update(&DigCtx, pData, cbData);

    MD2Final(&DigCtx);

    FillMemory(SigBuffer, pk->keylen, 0);
    FillMemory(Buffer, pk->keylen, 0);

    ReverseMemCopy(SigBuffer, pSigned, cbSigned);

    if(!BSafeEncPublic(pk, SigBuffer, Buffer))
    {
        return FALSE;
    }

    ReverseMemCopy(SigBuffer, Buffer, cbSigned);

    /* Make sure pkcs block type 1 */
    if(SigBuffer[0] != 0 || SigBuffer[1] != 1) 
    {
        return FALSE;
    }

    for(iLoc = 2; iLoc < pk->datalen; iLoc++ )
    {
        if(!SigBuffer[iLoc]) 
        {
            break;
        }

        if(SigBuffer[iLoc] != 0xff) 
        {
            return FALSE;
        }
    }

    if(iLoc == pk->datalen) 
    {
        return FALSE;
    }

    iLoc++; /* skip past separator */


    if(memcmp(&SigBuffer[iLoc], MD2_PRELUDE, sizeof(MD2_PRELUDE))   != 0) 
    {
        return FALSE;
    }
    iLoc += sizeof(MD2_PRELUDE);
    if(memcmp(&SigBuffer[iLoc],  DigCtx.state, 16)  != 0) 
    {
        return FALSE;
    }



    return TRUE;
}

BOOL
WINAPI
SigRSASHAMD5Sign(
    PUCHAR          pData,          // pointer to hash value
    DWORD           cbData,         // always 36
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey   *pKey)
{
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *)pKey->pKey;

    if(pk->magic == RSA2)
    {
        // BSAFE key
        UCHAR LocalBuffer[500];
        UCHAR LocalOutput[500];

      pk = (BSAFE_PRV_KEY *)pKey;
      if(pk->keylen > sizeof(LocalBuffer))
        {
            return FALSE;
        }

        FillMemory(LocalBuffer, pk->keylen, 0);
        ReverseMemCopy(LocalBuffer, pData, cbData);

        LocalBuffer[cbData++] = 0;

        while(cbData < pk->datalen-1) {
            LocalBuffer[cbData++] = 0xff;
        }

        /* Make into pkcs block type 1 */
        LocalBuffer[pk->datalen-1] = 1;

        *pcbSigned = pk->datalen+1;

        BSafeDecPrivate(pk, LocalBuffer, LocalOutput);
        ReverseMemCopy(pSigned, LocalOutput,  *pcbSigned);

        return TRUE;
    }
    else
    {
        // capiCryptoAPI key
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        DWORD dwAlgid;
        DWORD i;
        DWORD dwT;

        // get handle to CSP
        hProv = *((HCRYPTPROV *)pKey->pKey);

        // create hash object
        dwAlgid = ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SSL3SHAMD5;
        if(RCRYPT_FAILED(capiCryptCreateHash(hProv, dwAlgid, 0, 0, &hHash)))
        {
            return FALSE;
        }

        // set hash value
        if(RCRYPT_FAILED(capiCryptSetHashParam(hHash, HP_HASHVAL, pData, 0)))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }

        // sign hash
        if(RCRYPT_FAILED(capiCryptSignHash(hHash,
                                       AT_KEYEXCHANGE,
                                       NULL,
                                       0,
                                       pSigned,
                                       pcbSigned)))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }

        // free hash object
        capiCryptDestroyHash(hHash);

        //Convert to Big-endian
        dwT = *pcbSigned;
        for( i = 0 ; i < dwT/2 ; i++)
        {
            BYTE bT = pSigned[i];
            
            pSigned[i] = pSigned[dwT-1-i];
            pSigned[dwT-1-i] = bT;
        }
        return TRUE;
    }
}

BOOL
WINAPI
SigRSASHAMD5Verify(
    PUCHAR          pData,          // pointer to hash value
    DWORD           cbData,         // always 36
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey)
{
    BSAFE_PUB_KEY *pk = (BSAFE_PUB_KEY *)pKey->pKey;
    UCHAR Buffer[500];
    UCHAR SigBuffer[500];
    DWORD iLoc;

    if(pk->keylen > sizeof(Buffer) || cbSigned != pk->datalen + 1)
    {
        return FALSE;
    }

    FillMemory(SigBuffer, pk->keylen, 0);
    FillMemory(Buffer, pk->keylen, 0);

    ReverseMemCopy(SigBuffer, pSigned, cbSigned);

    BSafeEncPublic(pk, SigBuffer, Buffer);

    ReverseMemCopy(SigBuffer, Buffer, cbSigned);

    /* Make sure pkcs block type 1 */
    if(SigBuffer[0] != 0 || SigBuffer[1] != 1) return FALSE;

    for(iLoc = 2; iLoc < pk->datalen; iLoc++ ){
        if(!SigBuffer[iLoc]) break;
        if(SigBuffer[iLoc] != 0xff) return FALSE;
    }

    if(iLoc == pk->datalen) return FALSE;

    iLoc++; /* skip past separator */

    if(memcmp(&SigBuffer[iLoc], pData, cbData) != 0) return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\genreq\encode.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       encode.h
//
//--------------------------------------------------------------------------

#ifndef _ENCODE_H_
#define _ENCODE_H_

#include <wtypes.h>
#include "csber.h"


// definitions of maximum lengths needed for the ASN.1 encoded form of some of
// the common fields in a certificate

#define MAXVALIDITYLEN		0x24
#define MAXKEYINFOLEN		0x40
#define MAXALGIDLEN		0x0a
#define MAXOBJIDLEN		20
#define MAXNAMEVALUELEN		0x40
#define UTCTIMELEN		0x0f
#define MAXPUBKEYDATALEN	0x30
#define VERSIONLEN		0x03
#define MAXENCODEDSIGLEN	0x30
#define MAXHEADERLEN		0x08
#define MINHEADERLEN		0x03
#define MAXTIMELEN		0x20
#define MAXNAMELEN		0x40


// definitions for scrubbing memory

#define ALLBITSOFF		0x00
#define ALLBITSON		0xff

typedef struct _PctPrivateKey {
    DWORD Type;
    DWORD cbKey;
    BYTE  pKey[1];
} PctPrivateKey, *PPctPrivateKey;


typedef struct _OIDTRANSLATE {
    char const *pszObjId;
    BYTE        abOIDEncoded[MAXOBJIDLEN];	// ASN.1 encoded OID
    BYTE	cbOIDEncoded;			// ASN.1 encoded OID length
} OIDTRANSLATE;


typedef struct _ALGIDTRANSLATE {
    DWORD       AlgId;
    char const *pszObjId;
} ALGIDTRANSLATE;


typedef struct _RDNENTRY {
    char const *pszObjId;
    char const *pszShortName;
    BYTE        BerTag;				// ASN.1 type of string
    DWORD       cbMaxString;
    DWORD       cbMaxConcatenated;
    DWORD	cbRemain;
} RDNENTRY;


typedef struct _NAMEENTRY {
    char const *pszObjId;
    BYTE         BerTag;			// ASN.1 type of string
    DWORD	 cbData;
    BYTE	*pbData;
    DWORD	 iRDN;
} NAMEENTRY;

typedef struct _NAMETABLE {
    DWORD        cnt;
    NAMEENTRY   *pNameEntry;
} NAMETABLE;


extern const ALGIDTRANSLATE g_aAlgIdTranslate[];
extern const DWORD g_cAlgIdTranslate;

extern const OIDTRANSLATE g_aOidTranslate[];
extern const DWORD g_cOidTranslate;

extern RDNENTRY g_ardnSubject[];
extern const DWORD g_crdnSubject;


// prototypes for the functions in enc.cpp:

OIDTRANSLATE const *
LookupOidTranslate(
    IN CHAR const *pszObjId);

long
EncodeObjId(
    OPTIONAL OUT BYTE *pbEncoded,
    IN CHAR const *pszObjId);

long
EncodeLength(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen);

long
EncodeAlgid(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD Algid);

long
EncodeInteger(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbInt,
    IN DWORD dwLen);

long
EncodeUnicodeString(
    OPTIONAL OUT BYTE *pbEncoded,
    IN WCHAR const *pwsz);

long
EncodeIA5String(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbStr,
    IN DWORD dwLen);

long
EncodeOctetString(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbStr,
    IN DWORD dwLen);

long
EncodeBitString(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbStr,
    IN DWORD dwLen);

long
EncodeHeader(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen);

long
EncodeSetHeader(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen);

long
EncodeAttributeHeader(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen);

long
EncodeName(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbName,
    IN DWORD dwLen);

long
EncodeAlgorithm(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD AlgId);

#define ALGTYPE_SIG_RSA_MD5	0x01
#define ALGTYPE_KEYEXCH_RSA_MD5	0x02
#define ALGTYPE_CIPHER_RC4_MD5	0x03

long
EncodeDN(
    OPTIONAL OUT BYTE *pbEncoded,
    IN NAMETABLE const *pNameTable);

long
EncodeFileTime(
    OPTIONAL OUT BYTE *pbEncoded,
    IN FILETIME Time,
    IN BOOL UTC);

#endif  // _ENCODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\hdrs\funchdr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       funchdr.cpp
//
//--------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//  
//  Derivation:
//
//  Algorithm:
// 
//  History:
// 
//  Notes:
//
//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\hdrs\classhdr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       classhdr.cpp
//
//--------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Class:
//
//  Purpose:
//
//  History:
//
//  Notes:
//
//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\hdrs\filehdr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       filehdr.cpp
//
//--------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  File:
// 
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\idl\com\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

RPC_SOURCE_DIR=..\rpc\$(O)
DCOM_SOURCE_DIR=..\dcom\$(O)

$(RPC_NTTARGETFILE1):	$(RPC_SOURCE_DIR)\$(@F)
    copy $(RPC_SOURCE_DIR)\$(@F) $@

$(DCOM_NTTARGETFILE1):	$(DCOM_SOURCE_DIR)\$(@F)
    copy $(DCOM_SOURCE_DIR)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\idl\tlb\dummy.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dummy.cpp
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\idl\tlb\certadml\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\certadml.res:    ..\..\com\$(O)\certadm.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\hdrs\methhdr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       methhdr.cpp
//
//--------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//  
//  Derivation:
//
//  Algorithm:
// 
//  History:
// 
//  Notes:
//
//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\idl\tlb\certclil\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\certclil.res:    ..\..\com\$(O)\certcli.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\idl\tlb\certencl\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\certencl.res:    ..\..\com\$(O)\certenc.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\audit.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1999 - 2000
//
// File:        audit.h
//
// Contents:    Cert Server audit classes
//
//---------------------------------------------------------------------------
#ifndef __AUDIT_H__
#define __AUDIT_H__

#include <ntsecapi.h>
#include <authzi.h>

#define AUDIT_FILTER_STARTSTOP      0x00000001
#define AUDIT_FILTER_BACKUPRESTORE  0x00000002
#define AUDIT_FILTER_CERTIFICATE    0x00000004
#define AUDIT_FILTER_CERTREVOCATION 0x00000008
#define AUDIT_FILTER_CASECURITY     0x00000010
#define AUDIT_FILTER_KEYAARCHIVAL   0x00000020
#define AUDIT_FILTER_CACONFIG       0x00000040

#define CA_ACCESS_ALLREADROLES  \
    CA_ACCESS_ADMIN   |         \
    CA_ACCESS_OFFICER |         \
    CA_ACCESS_AUDITOR |         \
    CA_ACCESS_OPERATOR|         \
    CA_ACCESS_READ

namespace CertSrv
{

static const LPCWSTR cAuditString_UnknownDataType = L"?";

// define event

class CAuditEvent
{
public:

    static const DWORD m_gcAuditSuccessOrFailure = 0;
    static const DWORD m_gcNoAuditSuccess = 1;
    static const DWORD m_gcNoAuditFailure = 2;

    CAuditEvent(ULONG ulEventID = 0L, DWORD dwFilter = 0);
    ~CAuditEvent();

    void SetEventID(ULONG ulEventID);

    HRESULT AddData(DWORD dwValue);
    HRESULT AddData(PBYTE pData, DWORD dwDataLen);
    HRESULT AddData(bool fData);
    HRESULT AddData(LPCWSTR pcwszData);
    HRESULT AddData(LPCWSTR *ppcwszData);    
    HRESULT AddData(FILETIME time);
    HRESULT AddData(const VARIANT *pvar, bool fDoublePercentInString);
    HRESULT AddData(ULARGE_INTEGER *puliValue);
    void    DeleteLastData() 
    { delete m_pEventDataList[--m_cEventData]; }

    HRESULT Report(bool fSuccess = true);
    HRESULT SaveFilter(LPCWSTR pcwszSanitizedName);
    HRESULT LoadFilter(LPCWSTR pcwszSanitizedName);
    DWORD   GetFilter() {return m_dwFilter;}
    HRESULT AccessCheck(
        ACCESS_MASK Mask,
        DWORD dwAuditFlags,
        handle_t hRpc = NULL,
        HANDLE *phToken = NULL);
    HRESULT CachedGenerateAudit();
    void FreeCachedHandles();

    HRESULT GetMyRoles(DWORD *pdwRoles);

    bool IsEventEnabled();

    HRESULT Impersonate();
    HRESULT RevertToSelf();
    HANDLE  GetClientToken();

    // role separation 
    void EventRoleSeparationEnable(bool fEnable) 
        {m_fRoleSeparationEnabled = fEnable;};

    static void RoleSeparationEnable(bool fEnable) 
        {m_gfRoleSeparationEnabled = fEnable;};
    static bool RoleSeparationIsEnabled() {return m_gfRoleSeparationEnabled;}
    static HRESULT RoleSeparationFlagSave(LPCWSTR pcwszSanitizedName);
    static HRESULT RoleSeparationFlagLoad(LPCWSTR pcwszSanitizedName);
    static void CleanupAuditEventTypeHandles();

    struct AUDIT_CATEGORIES
    {
        ULONG ulAuditID;
        DWORD dwFilter;
        DWORD dwParamCount;
        bool fRoleSeparationEnabled;
        AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType;
    };

private:

    bool IsEventValid();
    bool IsEventRoleSeparationEnabled();

    CAuditEvent(const CAuditEvent&);
    const CAuditEvent& operator=(const CAuditEvent&);

    struct EventData
    {
        EventData() : m_fDoublePercentsInStrings(false)
        {
            PropVariantInit(&m_vtData);
        };
        ~EventData() 
        {
            PropVariantClear(&m_vtData);
        };
        HRESULT ConvertToString(LPWSTR *pwszData);
        PROPVARIANT m_vtData;
        bool m_fDoublePercentsInStrings; // Insertion strings containing %number get
                                         // displayed incorrectly in the event log.
                                         // If this value is set, we double % chars.

    };// struct EventData

    PROPVARIANT *CreateNewEventData();
    EventData   *CreateNewEventData1();
    HRESULT BuildAuditParamArray(PAUDIT_PARAM& rpParamArray);
    void FreeAuditParamArray(PAUDIT_PARAM pParamArray);
    HRESULT GetPrivilegeRoles(PDWORD pdwRoles);
    HRESULT GetUserPrivilegeRoles(
                LSA_HANDLE lsah,
                PSID_AND_ATTRIBUTES pSA, 
                PDWORD pdwRoles);

    HRESULT BuildPrivilegeSecurityDescriptor(
                DWORD dwRoles);

    DWORD GetBitCount(DWORD dwBits)
    {
        DWORD dwCount = 0;
        for(DWORD dwSize = 0; dwSize<sizeof(DWORD); dwSize++, dwBits>>=1)
        {
            dwCount += dwBits&1;
        }
        return dwCount;
    }

    HRESULT DoublePercentsInString(
        LPCWSTR pcwszIn,
        LPCWSTR *ppcwszOut);

    HRESULT EnforceEncryption(bool fRequestInterface);
    HRESULT EnforceLocalVsRemote(ACCESS_MASK Mask);

    ULONG m_ulEventID;
    enum {m_EventDataMaxSize=10};
    EventData* m_pEventDataList[m_EventDataMaxSize];
    DWORD m_cEventData;
    DWORD m_cRequiredEventData; // expected number of audit parameters
    DWORD m_dwFilter;
    bool m_fRoleSeparationEnabled;

    // free these
    IServerSecurity *m_pISS;
    HANDLE m_hClientToken;
    PSECURITY_DESCRIPTOR m_pCASD;
    AUTHZ_CLIENT_CONTEXT_HANDLE m_ClientContext;
    AUTHZ_ACCESS_CHECK_RESULTS_HANDLE m_AuthzHandle;
    PSECURITY_DESCRIPTOR m_pSDPrivileges;
    PACL m_pDaclPrivileges;

    // no free
    handle_t m_hRpc;
    DWORD m_Error;
    DWORD m_SaclEval;
    ACCESS_MASK m_MaskAllowed;
    AUTHZ_ACCESS_REQUEST m_Request;
    AUTHZ_ACCESS_REPLY m_Reply;
    DWORD m_crtGUID;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE m_hAuditEventType;

    PSID m_pUserSid;

    static AUDIT_CATEGORIES *m_gAuditCategories;
    static DWORD m_gdwAuditCategoriesSize;
    static bool m_gfRoleSeparationEnabled;

    static const DWORD AuditorRoleBit;
    static const DWORD OperatorRoleBit;
    static const DWORD CAAdminRoleBit;
    static const DWORD OfficerRoleBit;
    static const DWORD dwMaskRoles;

}; // class CAuditEvent
} // namespace CertSrv

#endif //__AUDIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\certacl.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certacl.h
//
// Contents:    Cert Server security defines
//
//---------------------------------------------------------------------------

#ifndef __CERTACL_H__
#define __CERTACL_H__
#include <sddl.h>
#include "clibres.h"
#include "certsd.h"

// externs
// externs
extern const GUID GUID_APPRV_REQ;
extern const GUID GUID_REVOKE;
extern const GUID GUID_ENROLL;
extern const GUID GUID_AUTOENROLL;
extern const GUID GUID_READ_DB;
//defines

#define MAX_SID_LEN 256

// !!! The SD strings below need to be in sync with certadm.idl definitions

#define WSZ_CA_ACCESS_ADMIN      L"0x00000001" // CA administrator
#define WSZ_CA_ACCESS_OFFICER    L"0x00000002" // certificate officer
#define WSZ_CA_ACCESS_AUDITOR    L"0x00000004" // auditor
#define WSZ_CA_ACCESS_OPERATOR   L"0x00000008" // backup operator
#define WSZ_CA_ACCESS_MASKROLES  L"0x000000ff" 
#define WSZ_CA_ACCESS_READ       L"0x00000100" // read only access to CA
#define WSZ_CA_ACCESS_ENROLL     L"0x00000200" // enroll access to CA
#define WSZ_CA_ACCESS_MASKALL    L"0x0000ffff"


// Important, keep enroll string GUID in sync with define in acl.cpp
#define WSZ_GUID_ENROLL           L"0e10c968-78fb-11d2-90d4-00c04f79dc55"
#define WSZ_GUID_AUTOENROLL       L"a05b8cc2-17bc-4802-a710-e7c15ab866a2"

// ca access rights define here
// note: need to keep string access and mask in sync!
// WSZ_ACTRL_CERTSRV_MANAGE =      L"CCDCLCSWRPWPDTLOCRSDRCWDWO"
#define WSZ_ACTRL_CERTSRV_MANAGE   SDDL_CREATE_CHILD \
                                   SDDL_DELETE_CHILD \
                                   SDDL_LIST_CHILDREN \
                                   SDDL_SELF_WRITE \
                                   SDDL_READ_PROPERTY \
                                   SDDL_WRITE_PROPERTY \
                                   SDDL_DELETE_TREE \
                                   SDDL_LIST_OBJECT \
                                   SDDL_CONTROL_ACCESS \
                                   SDDL_STANDARD_DELETE \
                                   SDDL_READ_CONTROL \
                                   SDDL_WRITE_DAC \
                                   SDDL_WRITE_OWNER
#define ACTRL_CERTSRV_MANAGE       (ACTRL_DS_READ_PROP | \
                                    ACTRL_DS_WRITE_PROP | \
                                    READ_CONTROL | \
                                    DELETE | \
                                    WRITE_DAC | \
                                    WRITE_OWNER | \
                                    ACTRL_DS_CONTROL_ACCESS | \
                                    ACTRL_DS_CREATE_CHILD | \
                                    ACTRL_DS_DELETE_CHILD | \
                                    ACTRL_DS_LIST | \
                                    ACTRL_DS_SELF | \
                                    ACTRL_DS_DELETE_TREE | \
                                    ACTRL_DS_LIST_OBJECT)


#define WSZ_ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS \
                                   SDDL_CREATE_CHILD \
                                   SDDL_DELETE_CHILD \
                                   SDDL_LIST_CHILDREN \
                                   SDDL_SELF_WRITE \
                                   SDDL_READ_PROPERTY \
                                   SDDL_WRITE_PROPERTY \
                                   SDDL_DELETE_TREE \
                                   SDDL_LIST_OBJECT \
                                   SDDL_STANDARD_DELETE \
                                   SDDL_READ_CONTROL \
                                   SDDL_WRITE_DAC \
                                   SDDL_WRITE_OWNER

#define ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS \
                                   (ACTRL_DS_READ_PROP | \
                                    ACTRL_DS_WRITE_PROP | \
                                    READ_CONTROL | \
                                    DELETE | \
                                    WRITE_DAC | \
                                    WRITE_OWNER | \
                                    ACTRL_DS_CREATE_CHILD | \
                                    ACTRL_DS_DELETE_CHILD | \
                                    ACTRL_DS_LIST | \
                                    ACTRL_DS_SELF | \
                                    ACTRL_DS_DELETE_TREE | \
                                    ACTRL_DS_LIST_OBJECT)


// WSZ_ACTRL_CERTSRV_READ =        L"RPLCLORC"
#define WSZ_ACTRL_CERTSRV_READ     SDDL_READ_PROPERTY \
                                   SDDL_LIST_CHILDREN \
                                   SDDL_LIST_OBJECT \
                                   SDDL_READ_CONTROL
#define ACTRL_CERTSRV_READ         (READ_CONTROL | \
                                    ACTRL_DS_READ_PROP | \
                                    ACTRL_DS_LIST | \
                                    ACTRL_DS_LIST_OBJECT)

// WSZ_ACTRL_CERTSRV_ENROLL =      L"WPRPCR"
#define WSZ_ACTRL_CERTSRV_ENROLL   SDDL_WRITE_PROPERTY \
                                   SDDL_READ_PROPERTY \
                                   SDDL_CONTROL_ACCESS
#define ACTRL_CERTSRV_ENROLL       (ACTRL_DS_READ_PROP | \
                                    ACTRL_DS_WRITE_PROP | \
                                    ACTRL_DS_CONTROL_ACCESS)

#define WSZ_ACTRL_CERTSRV_CAADMIN SDDL_CONTROL_ACCESS
#define WSZ_ACTRL_CERTSRV_OFFICER SDDL_CONTROL_ACCESS
#define WSZ_ACTRL_CERTSRV_CAREAD  SDDL_CONTROL_ACCESS
#define ACTRL_CERTSRV_CAADMIN       ACTRL_DS_CONTROL_ACCESS
#define ACTRL_CERTSRV_OFFICER       ACTRL_DS_CONTROL_ACCESS
#define ACTRL_CERTSRV_CAREAD        ACTRL_DS_CONTROL_ACCESS
            
// define all ca string security here in consistant format

//    SDDL_OWNER L":" SDDL_ENTERPRISE_ADMINS \
//    SDDL_GROUP L":" SDDL_ENTERPRISE_ADMINS \
//    SDDL_DACL  L":" SDDL_PROTECTED SDDL_AUTO_INHERITED \
//    L"(" SDDL_ACCESS_ALLOWED or SDDL_OBJECT_ACCESS_ALLOWED L";" \
//         SDDL_OBJECT_INHERIT SDDL_CONTAINER_INHERIT or list L";" \
//         list of AccessRights L";" \
//         StringGUID L";" \
//         L";" \
//         SDDL_EVERYONE or Sid L")"
//    ...list of ace

#define CERTSRV_STD_ACE(access, sid) \
    L"(" SDDL_ACCESS_ALLOWED L";" \
         SDDL_OBJECT_INHERIT SDDL_CONTAINER_INHERIT L";" \
         access L";;;" sid L")"

#define CERTSRV_INH_ACE(access, sid) \
    L"(" SDDL_ACCESS_ALLOWED L";" \
         SDDL_OBJECT_INHERIT SDDL_CONTAINER_INHERIT SDDL_INHERIT_ONLY L";" \
         access L";;;" sid L")"

#define CERTSRV_OBJ_ACE(access, guid, sid) \
    L"(" SDDL_OBJECT_ACCESS_ALLOWED L";" \
         SDDL_OBJECT_INHERIT SDDL_CONTAINER_INHERIT L";" \
         access L";" \
         guid L";;" sid L")"

#define CERTSRV_OBJ_ACE_DENY(access, guid, sid) \
    L"(" SDDL_OBJECT_ACCESS_DENIED L";" \
         SDDL_OBJECT_INHERIT SDDL_CONTAINER_INHERIT L";" \
         access L";" \
         guid L";;" sid L")"


#define CERTSRV_STD_OG(owner, group) \
    SDDL_OWNER L":" owner SDDL_GROUP L":" group \
    SDDL_DACL  L":" SDDL_AUTO_INHERITED

#define CERTSRV_DACL \
    SDDL_DACL  L":" SDDL_AUTO_INHERITED

#define CERTSRV_DACL_PROTECTED \
    SDDL_DACL  L":" SDDL_AUTO_INHERITED SDDL_PROTECTED

#define CERTSRV_SACL_ACE(account) \
    L"(" SDDL_AUDIT L";" \
       SDDL_AUDIT_SUCCESS SDDL_AUDIT_FAILURE L";" \
       WSZ_CA_ACCESS_MASKALL L";;;" \
       account L")"


#define CERTSRV_SACL_ON \
    SDDL_SACL  L": "    \
    CERTSRV_SACL_ACE(SDDL_EVERYONE) \
    CERTSRV_SACL_ACE(SDDL_ANONYMOUS)

#define CERTSRV_SACL_OFF \
    SDDL_SACL  L":"

#define WSZ_CERTSRV_SID_ANONYMOUS_LOGON L"S-1-5-7"
#define WSZ_CERTSRV_SID_EVERYONE L"S-1-1-0"

// Default Standalone security
// Standalone
// Owner, local administrators
// Group, local administrators
// DACL:
//  enroll  - everyone
//  caadmin - builtin\administrators
//  officer - builtin\administrators
#define WSZ_DEFAULT_CA_STD_SECURITY \
    CERTSRV_STD_OG(SDDL_BUILTIN_ADMINISTRATORS, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_ADMIN,    SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_OFFICER,  SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_ENROLL,   SDDL_EVERYONE) \
    CERTSRV_SACL_ON

// Default Enterprise Security
// Owner, Enterprise Administrators
// Group, Enterprise Administrators
// DACL:
//  enroll  - authenticated users
//  caadmin - builtin\administrators
//          - domain admins
//          - enterprise admins
//  officer - builtin\administrators
//          - domain admins
//          - enterprise admins
#define WSZ_DEFAULT_CA_ENT_SECURITY \
    CERTSRV_STD_OG(SDDL_BUILTIN_ADMINISTRATORS, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_ADMIN,    SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_OFFICER,  SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_ADMIN,    SDDL_DOMAIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_OFFICER,  SDDL_DOMAIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_ADMIN,    SDDL_ENTERPRISE_ADMINS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_OFFICER,  SDDL_ENTERPRISE_ADMINS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_ENROLL,   SDDL_AUTHENTICATED_USERS) \
    CERTSRV_SACL_ON

// Empty CA SD 
#define WSZ_EMPTY_CA_SECURITY \
    CERTSRV_STD_OG(SDDL_BUILTIN_ADMINISTRATORS, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_SACL_ON

// DS Container 
// (CDP/CA container)
// Owner: Enterprise Admins (overidden by installer)
// Group: Enterprise Admins (overidden by installer)
// DACL:
//   Enterprise Admins - Full Control
//   Domain Admins - Full Control
//   Cert Publishers - Full Control
//   Builtin Admins - Full Control
//   Everyone - Read
#define WSZ_DEFAULT_CA_DS_SECURITY \
    CERTSRV_DACL \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_ENTERPRISE_ADMINS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_DOMAIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_CERT_SERV_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_READ,   SDDL_EVERYONE)

// NTAuthCertificates  
//
// Owner: Enterprise Admins (overidden by installer)
// Group: Enterprise Admins (overidden by installer)
// DACL:
//   Enterprise Admins - Full Control
//   Domain Admins - Full Control
//   Builtin Admins - Full Control
//   Everyone - Read
#define WSZ_DEFAULT_NTAUTH_SECURITY \
    CERTSRV_DACL \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_ENTERPRISE_ADMINS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_DOMAIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_READ,   SDDL_EVERYONE)

//  CDP/CA
// Owner: Enterprise Admins (overidden by installer)
// Group: Enterprise Admins (overidden by installer)
// DACL:
//   Enterprise Admins - Full Control
//   Domain Admins - Full Control
//   Cert Publishers - Full Control
//   Builtin Admins- Full Control
//   Authenticated Users - Read
#define WSZ_DEFAULT_CDP_DS_SECURITY \
    CERTSRV_DACL \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_ENTERPRISE_ADMINS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_DOMAIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, L"%ws") \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_READ,   SDDL_EVERYONE)

// Shared Folder related security
// Owner: Local Admin
// DACL:
// Local Admin - Full Control
// LocalSystem - Full Control
// Enterprise Admins - Full Control
// Everyone - Read
#define WSZ_DEFAULT_SF_SECURITY \
    CERTSRV_DACL \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_LOCAL_SYSTEM)

#define WSZ_DEFAULT_SF_USEDS_SECURITY \
    CERTSRV_DACL \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_LOCAL_SYSTEM) \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_ENTERPRISE_ADMINS)

#define WSZ_DEFAULT_SF_EVERYONEREAD_SECURITY \
    WSZ_DEFAULT_SF_SECURITY \
    CERTSRV_STD_ACE(SDDL_GENERIC_READ, SDDL_EVERYONE)

#define WSZ_DEFAULT_SF_USEDS_EVERYONEREAD_SECURITY \
    WSZ_DEFAULT_SF_USEDS_SECURITY \
    CERTSRV_STD_ACE(SDDL_GENERIC_READ, SDDL_EVERYONE)

#define WSZ_DEFAULT_DB_DIR_SECURITY \
    CERTSRV_DACL_PROTECTED \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_LOCAL_SYSTEM) \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_CREATOR_OWNER) \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_BACKUP_OPERATORS)

#define WSZ_DEFAULT_LOG_DIR_SECURITY WSZ_DEFAULT_DB_DIR_SECURITY


// Enroll share security
// Owner: Administrators
// Group: Administrators
// DACL:
//   Everyone: read access
//   local admin: full access
#define WSZ_ACTRL_CERTSRV_SHARE_READ      SDDL_FILE_READ \
                                          SDDL_READ_CONTROL \
                                          SDDL_GENERIC_READ \
                                          SDDL_GENERIC_EXECUTE
#define WSZ_ACTRL_CERTSRV_SHARE_ALL       SDDL_FILE_ALL \
                                          SDDL_CREATE_CHILD \
                                          SDDL_STANDARD_DELETE \
                                          SDDL_READ_CONTROL \
                                          SDDL_WRITE_DAC \
                                          SDDL_WRITE_OWNER \
                                          SDDL_GENERIC_ALL
#define WSZ_DEFAULT_SHARE_SECURITY \
    CERTSRV_DACL \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_SHARE_READ, SDDL_EVERYONE) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_SHARE_ALL,  SDDL_BUILTIN_ADMINISTRATORS)


// Service string below need to be in sync with the following
// definitions from winsvc.h
//#define SERVICE_QUERY_CONFIG           0x0001
//#define SERVICE_CHANGE_CONFIG          0x0002
//#define SERVICE_QUERY_STATUS           0x0004
//#define SERVICE_ENUMERATE_DEPENDENTS   0x0008
//#define SERVICE_START                  0x0010
//#define SERVICE_STOP                   0x0020
//#define SERVICE_PAUSE_CONTINUE         0x0040
//#define SERVICE_INTERROGATE            0x0080
//#define SERVICE_USER_DEFINED_CONTROL   0x0100

// full access to service
// STANDARD_RIGHTS_REQUIRED
// SERVICE_QUERY_CONFIG
// SERVICE_CHANGE_CONFIG
// SERVICE_QUERY_STATUS
// SERVICE_ENUMERATE_DEPENDENTS
// SERVICE_START
// SERVICE_STOP
// SERVICE_PAUSE_CONTINUE
// SERVICE_INTERROGATE
// SERVICE_USER_DEFINED_CONTROL
#define WSZ_SERVICE_ALL_ACCESS L"0x000f01ff"


// Read-only access to service
//  SERVICE_QUERY_CONFIG, 
//  SERVICE_QUERY_STATUS, 
//  SERVICE_ENUMERATE_DEPENDENTS, 
//  SERVICE_INTERROGATE
//  SERVICE_USER_DEFINED_CONTROL

#define WSZ_SERVICE_READ L"0x0000018d"

#define WSZ_SERVICE_START_STOP L"0x00000030"

// Power user and system access
// SERVICE_QUERY_CONFIG
// SERVICE_QUERY_STATUS
// SERVICE_ENUMERATE_DEPENDENTS
// SERVICE_START
// SERVICE_STOP
// SERVICE_PAUSE_CONTINUE
// SERVICE_INTERROGATE
// SERVICE_USER_DEFINED_CONTROL
#define WSZ_SERVICE_POWER_USER L"0x000001fd"

#define CERTSRV_SERVICE_SACL_ON \
    CERTSRV_DACL \
    SDDL_SACL  L": (" SDDL_AUDIT L";" \
                      SDDL_AUDIT_SUCCESS SDDL_AUDIT_FAILURE L";" \
                      WSZ_SERVICE_START_STOP L";;;" \
                      SDDL_EVERYONE L")"

#define CERTSRV_SERVICE_SACL_OFF \
    SDDL_SACL L":"

// Certsrv service default security
#define WSZ_DEFAULT_SERVICE_SECURITY \
    CERTSRV_DACL \
    CERTSRV_STD_ACE(WSZ_SERVICE_READ, SDDL_AUTHENTICATED_USERS) \
    CERTSRV_STD_ACE(WSZ_SERVICE_POWER_USER, SDDL_POWER_USERS) \
    CERTSRV_STD_ACE(WSZ_SERVICE_POWER_USER, SDDL_LOCAL_SYSTEM) \
    CERTSRV_STD_ACE(WSZ_SERVICE_ALL_ACCESS, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_SERVICE_ALL_ACCESS, SDDL_SERVER_OPERATORS)

// DS pKIEnrollmentService default security
#define WSZ_DEFAULT_DSENROLLMENT_SECURITY \
    CERTSRV_DACL \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS, SDDL_ENTERPRISE_ADMINS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS, L"%ws") \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_READ,   SDDL_AUTHENTICATED_USERS)

// Key Conatiner security
// Owner: local admin
// Group: local admin
// DACL:
// Local Admin - Full Control
// LocalSystem - Full Control
#define WSZ_DEFAULT_KEYCONTAINER_SECURITY \
    CERTSRV_DACL \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_LOCAL_SYSTEM)

// upgrade security
// DACL:
// Local Admin - Full Control
// Everyone - read
#define WSZ_DEFAULT_UPGRADE_SECURITY \
    CERTSRV_STD_ACE(SDDL_FILE_READ, SDDL_EVERYONE) \
    CERTSRV_STD_ACE(SDDL_FILE_ALL, SDDL_BUILTIN_ADMINISTRATORS)


// following defines certsrv security editing access

#define GUID_CERTSRV         GUID_NULL
#define ACTRL_CERTSRV_OBJ    ACTRL_DS_CONTROL_ACCESS
#define CS_GEN_SIAE(access, ids) \
            {&GUID_CERTSRV, (access), MAKEINTRESOURCE((ids)), \
             SI_ACCESS_GENERAL}
#define CS_SPE_SIAE(access, ids) \
            {&GUID_CERTSRV, (access), MAKEINTRESOURCE((ids)), \
             SI_ACCESS_SPECIFIC}
#define OBJ_GEN_SIAE(guid, access, ids) \
            {&(guid), (access), MAKEINTRESOURCE((ids)), \
             SI_ACCESS_GENERAL|SI_ACCESS_SPECIFIC}
#define OBJ_SPE_SIAE(guid, ids) \
            {&(guid), ACTRL_CERTSRV_OBJ, MAKEINTRESOURCE((ids)), \
             SI_ACCESS_SPECIFIC}
#define OBJ_SPE_SIAE_OICI(guid, ids) \
            {&(guid), ACTRL_CERTSRV_OBJ, MAKEINTRESOURCE((ids)), \
             SI_ACCESS_SPECIFIC | OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE }

#define CERTSRV_SI_ACCESS_LIST \
    CS_GEN_SIAE(CA_ACCESS_READ,     IDS_ACTRL_CAREAD), \
    CS_GEN_SIAE(CA_ACCESS_OFFICER,  IDS_ACTRL_OFFICER), \
    CS_GEN_SIAE(CA_ACCESS_ADMIN,    IDS_ACTRL_CAADMIN), \
    CS_GEN_SIAE(CA_ACCESS_ENROLL,   IDS_ACTRL_ENROLL), \
// disabled for beta1   CS_GEN_SIAE(CA_ACCESS_AUDITOR,  IDS_ACTRL_AUDITOR), 
// disabled for beta1   CS_GEN_SIAE(CA_ACCESS_OPERATOR,  IDS_ACTRL_OPERATOR), 
HRESULT
myGetSDFromTemplate(
    IN WCHAR const           *pwszStringSD,
    IN OPTIONAL WCHAR const  *pwszReplace,
    OUT PSECURITY_DESCRIPTOR *ppSD);

HRESULT
CertSrvMapAndSetSecurity(
    OPTIONAL IN WCHAR const *pwszSanitizedName, 
    IN WCHAR const *pwszKeyContainerName, 
    IN BOOL         fSetDsSecurity,
    IN SECURITY_INFORMATION si,
    IN PSECURITY_DESCRIPTOR pSD);

HRESULT
mySetKeyContainerSecurity(
    IN HCRYPTPROV hProv);

HRESULT 
myMergeSD(
    IN PSECURITY_DESCRIPTOR   pSDOld,
    IN PSECURITY_DESCRIPTOR   pSDMerge, 
    IN SECURITY_INFORMATION   si,
    OUT PSECURITY_DESCRIPTOR *ppSDNew);

HRESULT
UpdateServiceSacl(bool fTurnOnAuditing);

HRESULT 
SetFolderDacl(LPCWSTR pcwszFolderPath, LPCWSTR pcwszSDDL);

#endif // __CERTLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\certbcli.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certbcli.h
//
// Contents:    Cert Server backup client APIs
//
//---------------------------------------------------------------------------

#ifdef _CERTBCLI_TYPECHECK
#undef __CERTBCLI_H__	// allow redundant include
#endif

#ifndef __CERTBCLI_H__
#define __CERTBCLI_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifdef	MIDL_PASS
#define	RPC_STRING [string]
#else
#define	RPC_STRING
#endif

#define IN
#define OUT
#define OPTIONAL
#define VOID		void

#define CERTBCLI_CALL	__stdcall

#ifndef _CERTBCLI_DEFINED
#define CERTBCLI_API __declspec(dllimport) CERTBCLI_CALL
#else
#define CERTBCLI_API
#endif

#define szBACKUPANNOTATION   "Cert Server Backup Interface"
#define wszBACKUPANNOTATION  TEXT(szBACKUPANNOTATION)

#define szRESTOREANNOTATION  "Cert Server Restore Interface"
#define wszRESTOREANNOTATION TEXT(szRESTOREANNOTATION)


// Type of Backup passed to CertSrvBackupPrepare:
// CSBACKUP_TYPE_FULL: Requesting backup of the complete DB (DB & Log files)
// CSBACKUP_TYPE_LOGS_ONLY: Requesting backup of only the log files
// CSBACKUP_TYPE_INCREMENTAL: Requesting incremental backup

// CertSrvBackupPrepare flags:
#define CSBACKUP_TYPE_FULL		0x00000001
#define CSBACKUP_TYPE_LOGS_ONLY		0x00000002
//#define CSBACKUP_TYPE_INCREMENTAL	0x00000004	// not yet supported
#define CSBACKUP_TYPE_MASK		0x00000003	// valid flags

// Type of Restore passed to CertSrvRestorePrepare:
// CSRESTORE_TYPE_FULL: Requesting restore of the complete DB (DB & Log files)
// CSRESTORE_TYPE_ONLINE: Restoration is done when Cert Server is online.

#define CSRESTORE_TYPE_FULL		0x00000001	// else incremental
#define CSRESTORE_TYPE_ONLINE		0x00000002	// not yet supported
#define CSRESTORE_TYPE_CATCHUP		0x00000004	// not yet supported
#define CSRESTORE_TYPE_MASK		0x00000005	// valid flags


// Setting the current log # to this value would disable incremental backup
#define CSBACKUP_DISABLE_INCREMENTAL  0xffffffff


// BFT is the bit flag used to represent file types (directory/dit/logfile/etc.)
// We keep them as a character so that we can append/prepend them to the actual
// file path. The code in the Backup API's rely on the fact that values 0-256
// in 8 bit ascii map to the values 0-256 in unicode.

typedef WCHAR CSBFT;


// Bit flags:
//  CSBFT_DIRECTORY               - path specified is a directory
//  CSBFT_DATABASE_DIRECTORY      - that file goes into database directory
//  CSBFT_LOG_DIRECTORY           - that the file goes into log directory

#define	CSBFT_DIRECTORY		    0x80
#define CSBFT_DATABASE_DIRECTORY    0x40
#define	CSBFT_LOG_DIRECTORY	    0x20

// Following combinations are defined for easy use of the filetype and the
// directory into into which it goes

#define	CSBFT_LOG		  ((CSBFT) (TEXT('\x01') | CSBFT_LOG_DIRECTORY))
#define	CSBFT_LOG_DIR		  ((CSBFT) (TEXT('\x02') | CSBFT_DIRECTORY))
#define	CSBFT_CHECKPOINT_DIR	  ((CSBFT) (TEXT('\x03') | CSBFT_DIRECTORY))
#define	CSBFT_CERTSERVER_DATABASE ((CSBFT) (TEXT('\x04') | CSBFT_DATABASE_DIRECTORY))
#define	CSBFT_PATCH_FILE	  ((CSBFT) (TEXT('\x05') | CSBFT_LOG_DIRECTORY))
#define	CSBFT_UNKNOWN		  ((CSBFT) (TEXT('\x0f')))


// Backup Context Handle
typedef void *HCSBC;

#ifndef CSEDB_RSTMAP
typedef struct tagCSEDB_RSTMAPW {
    RPC_STRING WCHAR *pwszDatabaseName;
    RPC_STRING WCHAR *pwszNewDatabaseName;
} CSEDB_RSTMAPW;

#define CSEDB_RSTMAP CSEDB_RSTMAPW
#endif // CSEDB_RSTMAP


// For all the functions in this interface that have at least one string
// parameter, provide macros to invoke the appropriate version of the
// corresponding function.

#define CertSrvIsServerOnline		CertSrvIsServerOnlineW
#define CertSrvBackupGetDynamicFileList	CertSrvBackupGetDynamicFileListW
#define CertSrvBackupPrepare		CertSrvBackupPrepareW
#define CertSrvBackupGetDatabaseNames	CertSrvBackupGetDatabaseNamesW
#define CertSrvBackupOpenFile		CertSrvBackupOpenFileW
#define CertSrvBackupGetBackupLogs	CertSrvBackupGetBackupLogsW

#define CertSrvRestoreGetDatabaseLocations CertSrvRestoreGetDatabaseLocationsW
#define CertSrvRestorePrepare		CertSrvRestorePrepareW
#define CertSrvRestoreRegister		CertSrvRestoreRegisterW

#define CertSrvServerControl		CertSrvServerControlW


//+--------------------------------------------------------------------------
// CertSrvIsServerOnline -- check to see if the Cert Server is Online on the
//	given server. This call is guaranteed to return quickly.
//
// Parameters:
//	[in]  pwszServerName - name or config string of the server to check
//	[out] pfServerOnline - pointer to receive the bool result
//		(TRUE if Cert Server is online; FALSE, otherwise)
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//+--------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVISSERVERONLINEW)(
    IN  WCHAR const *pwszServerName,
    OUT BOOL *pfServerOnline);

HRESULT
CERTBCLI_API
CertSrvIsServerOnlineW(
    IN  WCHAR const *pwszServerName,
    OUT BOOL *pfServerOnline);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVISSERVERONLINEW *pfnCertSrvIsServerOnline = CertSrvIsServerOnline;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupGetDynamicFileList -- return the list of dynamic files that
//	need to be backed up in addition to database files.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[out] ppwszzFileList - pointer to receive the pointer to the file list;
//		allocated memory should be freed using CertSrvBackupFree() API
//		by the caller when it is no longer needed; The file list info
//		is an array of null-terminated filenames and the list is
//		terminated by two L'\0's.
//	[out] pcbSize - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPGETDYNAMICFILELISTW)(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbSize);

HRESULT
CERTBCLI_API
CertSrvBackupGetDynamicFileListW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbSize);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPGETDYNAMICFILELISTW *pfnCertSrvBackupGetDynamicFileList = CertSrvBackupGetDynamicFileList;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupPrepare -- prepare the DB for the online backup and return a
//	Backup Context Handle to be used for subsequent calls to backup
//	functions.
//
// Parameters:
//	[in]  pwszServerName - name or config string of the server to check
//	[in]  grbitJet - flag to be passed to jet while backing up dbs
//	[in]  dwBackupFlags - CSBACKUP_TYPE_FULL or CSBACKUP_TYPE_LOGS_ONLY
//	[out] phbc - pointer that will receive the backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPPREPAREW)(
    IN  WCHAR const *pwszServerName,
    IN  ULONG grbitJet,
    IN  ULONG dwBackupFlags,	// CSBACKUP_TYPE_*
    OUT HCSBC *phbc);

HRESULT
CERTBCLI_API
CertSrvBackupPrepareW(
    IN  WCHAR const *pwszServerName,
    IN  ULONG grbitJet,
    IN  ULONG dwBackupFlags,	// CSBACKUP_TYPE_*
    OUT HCSBC *phbc);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPPREPAREW *pfnCertSrvBackupPrepare = CertSrvBackupPrepare;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupGetDatabaseNames -- return the list of data bases that need to
//	be backed up for the given backup context
//
// Parameters:
//	[in]  hbc - backup context handle
//	[out] ppwszzAttachmentInformation - pointer to receive the pointer to
//		the attachment info; allocated memory should be freed using
//		CertSrvBackupFree() API by the caller when it is no longer
//		needed; Attachment info is an array of null-terminated
//		filenames and the list is terminated by two L'\0's.
//	[out] pcbSize - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPGETDATABASENAMESW)(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzAttachmentInformation,
    OUT DWORD *pcbSize);

HRESULT
CERTBCLI_API
CertSrvBackupGetDatabaseNamesW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzAttachmentInformation,
    OUT DWORD *pcbSize);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPGETDATABASENAMESW *pfnCertSrvBackupGetDatabaseNames = CertSrvBackupGetDatabaseNames;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupOpenFile -- open the given attachment for read.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[in]  pwszAttachmentName - name of the attachment to be opened for read
//	[in]  cbReadHintSize - suggested size in bytes that might be used
//		during the subsequent reads on this attachment
//	[out] pliFileSize - pointer to a large integer that would receive the
//		size in bytes of the given attachment
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPOPENFILEW)(
    IN  HCSBC hbc,
    IN  WCHAR const *pwszAttachmentName,
    IN  DWORD cbReadHintSize,
    OUT LARGE_INTEGER *pliFileSize);

HRESULT
CERTBCLI_API
CertSrvBackupOpenFileW(
    IN  HCSBC hbc,
    IN  WCHAR const *pwszAttachmentName,
    IN  DWORD cbReadHintSize,
    OUT LARGE_INTEGER *pliFileSize);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPOPENFILEW *pfnCertSrvBackupOpenFile = CertSrvBackupOpenFile;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupRead -- read the currently open attachment bytes into the given
//	buffer.  The client application is expected to call this function
//	repeatedly until it gets the entire file (the application would have
//	received the file size through the CertSrvBackupOpenFile call before.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[out] pvBuffer - pointer to the buffer that would receive the read data.
//	[in]  cbBuffer - specifies the size of the above buffer
//	[out] pcbRead - pointer to receive the actual number of bytes read.
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPREAD)(
    IN  HCSBC hbc,
    OUT VOID *pvBuffer,
    IN  DWORD cbBuffer,
    OUT DWORD *pcbRead);

HRESULT
CERTBCLI_API
CertSrvBackupRead(
    IN  HCSBC hbc,
    OUT VOID *pvBuffer,
    IN  DWORD cbBuffer,
    OUT DWORD *pcbRead);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPREAD *pfnCertSrvBackupRead = CertSrvBackupRead;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupClose -- called by the application after it completes reading all
//	the data in the currently opened attachement.
//
// Parameters:
//	[in] hbc - backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPCLOSE)(
    IN HCSBC hbc);

HRESULT
CERTBCLI_API
CertSrvBackupClose(
    IN HCSBC hbc);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPCLOSE *pfnCertSrvBackupClose = CertSrvBackupClose;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupGetBackupLogs -- return the list of log files that need to be
//	backed up for the given backup context
//
// Parameters:
//	[in]  hbc - backup context handle
//	[out] pwszzBackupLogFiles - pointer that will receive the pointer to
//		the list of log files; allocated memory should be freed using
//		CertSrvBackupFree() API by the caller when it is no
//		longer needed; Log files are returned in an array of
//		null-terminated filenames and the list is terminated by two
//		L'\0's
//	[out] pcbSize - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPGETBACKUPLOGSW)(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzBackupLogFiles,
    OUT DWORD *pcbSize);

HRESULT
CERTBCLI_API
CertSrvBackupGetBackupLogsW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzBackupLogFiles,
    OUT DWORD *pcbSize);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPGETBACKUPLOGSW *pfnCertSrvBackupGetBackupLogs = CertSrvBackupGetBackupLogs;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupTruncateLogs -- called to truncate the already read backup logs.
//
// Parameters:
//	[in] hbc - backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPTRUNCATELOGS)(
    IN HCSBC hbc);

HRESULT
CERTBCLI_API
CertSrvBackupTruncateLogs(
    IN HCSBC hbc);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPTRUNCATELOGS *pfnCertSrvBackupTruncateLogs = CertSrvBackupTruncateLogs;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupEnd -- called to end the current backup session.
//
// Parameters:
//	[in] hbc - backup context handle of the backup session
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPEND)(
    IN HCSBC hbc);

HRESULT
CERTBCLI_API
CertSrvBackupEnd(
    IN HCSBC hbc);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPEND *pfnCertSrvBackupEnd = CertSrvBackupEnd;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupFree -- free any buffer allocated by certbcli.dll APIs.
//
// Parameters:
//	[in] pv - pointer to the buffer that is to be freed.
//
// Returns:
//	None.
//---------------------------------------------------------------------------

typedef VOID (CERTBCLI_CALL FNCERTSRVBACKUPFREE)(
    IN VOID *pv);

VOID
CERTBCLI_API
CertSrvBackupFree(
    IN VOID *pv);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPFREE *pfnCertSrvBackupFree = CertSrvBackupFree;
#endif


//+--------------------------------------------------------------------------
// CertSrvRestoreGetDatabaseLocations -- called both at backup time as well as
//	at restorate time to get data base locations for different types of
//	files.
//
// Parameters:
//	[in]  hbc - backup context handle which would have been obtained
//		through CertSrvBackupPrepare in the backup case and through
//		CertSrvRestorePrepare in the restore case.
//	[out] ppwszzDatabaseLocationList - pointer that will receive the
//		pointer to the list of database locations; allocated memory
//		should be freed using CertSrvBackupFree() API by the caller
//		when it is no longer needed; locations are returned in an array
//		of null-terminated names and and the list is terminated by
//		two L'\0's.  The first character of each name is the BFT
//		character that indicates the type of the file and the rest of
//		the name tells gives the path into which that particular type
//		of file should be restored.
//	[out] pcbSize - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVRESTOREGETDATABASELOCATIONSW)(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzDatabaseLocationList,
    OUT DWORD *pcbSize);

HRESULT
CERTBCLI_API
CertSrvRestoreGetDatabaseLocationsW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzDatabaseLocationList,
    OUT DWORD *pcbSize);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVRESTOREGETDATABASELOCATIONSW *pfnCertSrvRestoreGetDatabaseLocations = CertSrvRestoreGetDatabaseLocations;
#endif


//+--------------------------------------------------------------------------
// CertSrvRestorePrepare -- indicate beginning of a restore session.
//
// Parameters:
//	[in]  pwszServerName - name or config string of the server into which
//		the restore operation is going to be performed.
//	[in]  dwRestoreFlags -  Or'ed combination of CSRESTORE_TYPE_* flags;
//		0 if no special flags are to be specified
//	[out] phbc - pointer to receive the backup context handle which is to
//		be passed to the subsequent restore APIs
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVRESTOREPREPAREW)(
    IN  WCHAR const *pwszServerName,
    IN  ULONG dwRestoreFlags,
    OUT HCSBC *phbc);

HRESULT
CERTBCLI_API
CertSrvRestorePrepareW(
    IN  WCHAR const *pwszServerName,
    IN  ULONG dwRestoreFlags,		// CSRESTORE_TYPE_*
    OUT HCSBC *phbc);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVRESTOREPREPAREW *pfnCertSrvRestorePrepare = CertSrvRestorePrepare;
#endif


//+--------------------------------------------------------------------------
// CertSrvRestoreRegister -- register a restore operation. It will interlock
//	all subsequent restore operations, and will prevent the restore target
//	from starting until the call to CertSrvRestoreRegisterComplete is made.
//
// Parameters:
//	[in] hbc - backup context handle for the restore session.
//	[in] pwszCheckPointFilePath - path to restore the check point files
//	[in] pwszLogPath - path where the log files are restored
//	[in] rgrstmap - restore map
//	[in] crstmap - tells if there is a new restore map
//	[in] pwszBackupLogPath - path where the backup logs are located
//	[in] genLow - Lowest log# that was restored in this restore session
//	[in] genHigh - Highest log# that was restored in this restore session
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVRESTOREREGISTERW)(
    OPTIONAL IN HCSBC hbc,
    OPTIONAL IN WCHAR const *pwszCheckPointFilePath,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    OPTIONAL IN WCHAR const *pwszBackupLogPath,
    IN ULONG genLow,
    IN ULONG genHigh);

HRESULT
CERTBCLI_API
CertSrvRestoreRegisterW(
    OPTIONAL IN HCSBC hbc,
    OPTIONAL IN WCHAR const *pwszCheckPointFilePath,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    OPTIONAL IN WCHAR const *pwszBackupLogPath,
    IN ULONG genLow,
    IN ULONG genHigh);

HRESULT
CERTBCLI_API
CertSrvRestoreRegisterThroughFile(
    IN HCSBC hbc,
    OPTIONAL IN WCHAR const *pwszCheckPointFilePath,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    OPTIONAL IN WCHAR const *pwszBackupLogPath,
    IN ULONG genLow,
    IN ULONG genHigh);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVRESTOREREGISTERW *pfnCertSrvRestoreRegister = CertSrvRestoreRegister;
#endif


//+--------------------------------------------------------------------------
// CertSrvRestoreRegisterComplete -- indicate that a previously registered
//	restore is complete.
//
// Parameters:
//	[in] hbc - backup context handle
//	[in] hrRestoreState - success code if the restore was successful
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVRESTOREREGISTERCOMPLETE)(
    OPTIONAL IN HCSBC hbc,
    IN HRESULT hrRestoreState);

HRESULT
CERTBCLI_API
CertSrvRestoreRegisterComplete(
    OPTIONAL IN HCSBC hbc,
    IN HRESULT hrRestoreState);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVRESTOREREGISTERCOMPLETE *pfnCertSrvRestoreRegisterComplete = CertSrvRestoreRegisterComplete;
#endif


//+--------------------------------------------------------------------------
// CertSrvRestoreEnd -- end a restore session
//
// Parameters:
//	[in] hbc - backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVRESTOREEND)(
    IN HCSBC hbc);

HRESULT
CERTBCLI_API
CertSrvRestoreEnd(
    IN HCSBC hbc);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVRESTOREEND *pfnCertSrvRestoreEnd = CertSrvRestoreEnd;
#endif


//+--------------------------------------------------------------------------
// CertSrvServerControl -- send a control command to the cert server.
//
// Parameters:
//	[in]  pwszServerName - name or config string of the server to control
//	[in]  dwControlFlags - control command and flags
//	[out] pcbOut - pointer to receive the size of command output data
//	[out] ppbOut - pointer to receive command output data.  Use the
//		CertSrvBackupFree() API to free the buffer.
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

#define CSCONTROL_SHUTDOWN	    0x000000001
#define CSCONTROL_SUSPEND	    0x000000002
#define CSCONTROL_RESTART	    0x000000003

typedef HRESULT (CERTBCLI_CALL FNCERTSRVSERVERCONTROLW)(
    IN WCHAR const *pwszServerName,
    IN DWORD dwControlFlags,
    OPTIONAL OUT DWORD *pcbOut,
    OPTIONAL OUT BYTE **ppbOut);

HRESULT
CERTBCLI_API
CertSrvServerControlW(
    IN WCHAR const *pwszServerName,
    IN DWORD dwControlFlags,
    OPTIONAL OUT DWORD *pcbOut,
    OPTIONAL OUT BYTE **ppbOut);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVSERVERCONTROLW *pfnCertSrvServerControl = CertSrvServerControl;
#endif


#ifdef __cplusplus
}
#endif

#endif // __CERTBCLI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\celib.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       celib.h
//
//  Contents:   helper functions
//
//--------------------------------------------------------------------------

#ifndef __CELIB_H__
#define __CELIB_H__

#include <stdio.h>


#define CENCODEMAX	(64 * 1024)

// Bitmap manipulation routines.  Fetch or set a bit, given a base and index.
#define GETBIT(pb, i)	((pb)[(i) / 8] & (1 << ((i) % 8)))
#define SETBIT(pb, i)	((pb)[(i) / 8] |= (1 << ((i) % 8)))
#define CLEARBIT(pb, i)	((pb)[(i) / 8] &= ~(1 << ((i) % 8)))

#define BITSTOBYTES(b)	((int)(((b) + 7) / 8))

#define ceCASIGN_KEY_USAGE \
	    (CERT_KEY_CERT_SIGN_KEY_USAGE | CERT_DIGITAL_SIGNATURE_KEY_USAGE | \
	     CERT_CRL_SIGN_KEY_USAGE)

// Size of a fixed array:
#define ARRAYSIZE(a)		(sizeof(a)/sizeof((a)[0]))

// wcslen of a static string:
#define WSZARRAYSIZE(a)		((sizeof(a)/sizeof((a)[0])) - 1)

#define wszCERTENROLLSHAREPATH	L"CertSrv\\CertEnroll"

#define cwcHRESULTSTRING	40
#define cwcDWORDSPRINTF		(1 + 10 + 1)	// DWORD "%d" w/sign & '\0'

#define SAFE_SUBTRACT_POINTERS(p1, p2) \
    (assert(sizeof((*p1)) == sizeof(*(p2))), (DWORD)((p1) - (p2)))

#define printf	Use_wprintf_Instead_Of_printf

#define _LeaveError(hr, pszMessage) \
	_LeaveErrorStr2((hr), (pszMessage), NULL, S_OK)

#define _LeaveError2(hr, pszMessage, hr2) \
	_LeaveErrorStr2((hr), (pszMessage), NULL, (hr2))

#define _LeaveErrorStr(hr, pszMessage, pwszData) \
	_LeaveErrorStr2((hr), (pszMessage), (pwszData), S_OK)

#define _LeaveErrorStr2(hr, pszMessage, pwszData, hr2) \
    { \
	ceERRORPRINTLINESTR((pszMessage), (pwszData), (hr)); \
	__leave; \
    }

#define _LeaveIfError(hr, pszMessage) \
	_LeaveIfErrorStr2((hr), (pszMessage), NULL, S_OK)

#define _LeaveIfError2(hr, pszMessage, hr2) \
	_LeaveIfErrorStr2((hr), (pszMessage), NULL, (hr2))

#define _LeaveIfErrorStr(hr, pszMessage, pwszData) \
	_LeaveIfErrorStr2((hr), (pszMessage), (pwszData), S_OK)

#define _LeaveIfErrorStr2(hr, pszMessage, pwszData, hr2) \
    { \
	if (S_OK != (hr)) \
	{ \
	    ceERRORPRINTLINESTR((pszMessage), (pwszData), (hr)); \
	    __leave; \
	} \
    }

#define _PrintErrorStr(hr, pszMessage, pwsz) \
    ceERRORPRINTLINESTR((pszMessage), (pwsz), (hr))

#define _PrintErrorStr2(hr, pszMessage, pwsz, hr2) \
    _PrintErrorStr((hr), (pszMessage), (pwsz))

#define _PrintError2(hr, pszMessage, hr2) \
    _PrintErrorStr((hr), (pszMessage), NULL)

#define _PrintError(hr, pszMessage) \
    _PrintErrorStr((hr), (pszMessage), NULL)


#define _PrintIfErrorStr(hr, pszMessage, pwsz) \
    { \
	if (S_OK != (hr)) \
	{ \
	    ceERRORPRINTLINESTR((pszMessage), (pwsz), (hr)); \
	} \
    }

#define _PrintIfErrorStr2(hr, pszMessage, pwsz, hr2) \
    _PrintIfErrorStr((hr), (pszMessage), (pwsz))

#define _PrintIfError2(hr, pszMessage, hr2) \
    _PrintIfErrorStr((hr), (pszMessage), NULL)

#define _PrintIfError(hr, pszMessage) \
    _PrintIfErrorStr((hr), (pszMessage), NULL)


#define _JumpErrorStr(hr, label, pszMessage, pwsz) \
    _JumpError((hr), label, (pszMessage))

#define _JumpError(hr, label, pszMessage) \
    { \
	ceERRORPRINTLINESTR((pszMessage), NULL, (hr)); \
	goto label; \
    }


#define _JumpIfErrorStr(hr, label, pszMessage, pwsz) \
    { \
	if (S_OK != (hr)) \
	{ \
	    ceERRORPRINTLINESTR((pszMessage), (pwsz), (hr)); \
	    goto label; \
	} \
    }

#define _JumpIfErrorStr2(hr, label, pszMessage, pwsz, hr2) \
    _JumpIfErrorStr((hr), label, (pszMessage), NULL)

#define _JumpIfError2(hr, label, pszMessage, hr2) \
    _JumpIfErrorStr((hr), label, (pszMessage), NULL)

#define _JumpIfError(hr, label, pszMessage) \
    _JumpIfErrorStr((hr), label, (pszMessage), NULL)


#define ceERRORPRINTLINE(pszMessage, hr) \
	    ceErrorPrintLine(__FILE__, __LINE__, (pszMessage), NULL, (hr))

#define ceERRORPRINTLINESTR(pszMessage, pwszData, hr) \
	    ceErrorPrintLine(__FILE__, __LINE__, (pszMessage), (pwszData), (hr))

#define DBGPRINT(a)	ceDbgPrintf a

int WINAPIV ceDbgPrintf(BOOL fDebug, char const *pszfmt, ...);


VOID
ceErrorPrintLine(
    IN char const *pszFile,
    IN DWORD line,
    IN char const *pszMessage,
    IN WCHAR const *pwszData,
    IN HRESULT hr);

HRESULT
ceHLastError(VOID);

HRESULT
ceHError(
    IN HRESULT hr);

#define chLBRACE	'{'
#define chRBRACE	'}'
#define szLBRACE	"{"
#define szRBRACE	"}"
#define wcLBRACE	L'{'
#define wcRBRACE	L'}'
#define wszLBRACE	L"{"
#define wszRBRACE	L"}"

#define chLPAREN	'('
#define chRPAREN	')'
#define szLPAREN	"("
#define szRPAREN	")"
#define wcLPAREN	L'('
#define wcRPAREN	L')'
#define wszLPAREN	L"("
#define wszRPAREN	L")"

// Constants chosen to avoid DWORD overflow:

#define CVT_WEEKS	(7 * CVT_DAYS)
#define CVT_DAYS	(24 * CVT_HOURS)
#define CVT_HOURS	(60 * CVT_MINUTES)
#define CVT_MINUTES	(60 * CVT_SECONDS)
#define CVT_SECONDS	(1)
#define CVT_BASE	(1000 * 1000 * 10)


enum ENUM_PERIOD
{
    ENUM_PERIOD_INVALID = -1,
    ENUM_PERIOD_SECONDS = 0,
    ENUM_PERIOD_MINUTES,
    ENUM_PERIOD_HOURS,
    ENUM_PERIOD_DAYS,
    ENUM_PERIOD_WEEKS,
    ENUM_PERIOD_MONTHS,
    ENUM_PERIOD_YEARS
};


typedef struct _LLFILETIME
{
    union {
	LONGLONG ll;
	FILETIME ft;
    };
} LLFILETIME;


__inline VOID
ceAddToFileTime(
    IN OUT FILETIME *pft,
    IN LONGLONG ll)
{
    LLFILETIME llft;

    llft.ft = *pft;
    llft.ll += ll;
    *pft = llft.ft;
}


__inline LONGLONG
ceSubtractFileTimes(
    IN FILETIME const *pft1,
    IN FILETIME const *pft2)
{
    LLFILETIME llft1;
    LLFILETIME llft2;

    llft1.ft = *pft1;
    llft2.ft = *pft2;
    return(llft1.ll - llft2.ll);
}


HRESULT
ceMakeExprDate(
    IN OUT DATE *pDate,
    IN LONG lDelta,
    IN enum ENUM_PERIOD enumPeriod);

HRESULT
ceTranslatePeriodUnits(
    IN WCHAR const *pwszPeriod,
    IN LONG lCount,
    OUT enum ENUM_PERIOD *penumPeriod,
    OUT LONG *plCount);

WCHAR const *
ceGetOIDNameA(
    IN char const *pszObjId);

WCHAR const *
ceGetOIDName(
    IN WCHAR const *pwszObjId);

BOOL
ceDecodeObject(
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN BOOL fCoTaskMemAlloc,
    OUT VOID **ppvStructInfo,
    OUT DWORD *pcbStructInfo);

BOOL
ceEncodeObject(
    DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN VOID const *pvStructInfo,
    IN DWORD dwFlags,
    IN BOOL fCoTaskMemAlloc,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

WCHAR *
ceDuplicateString(
    IN WCHAR const *pwsz);

HRESULT
ceDupString(
    IN WCHAR const *pwszIn,
    OUT WCHAR **ppwszOut);

BOOL
ceConvertWszToSz(
    OUT char **ppsz,
    IN WCHAR const *pwc,
    IN LONG cb);

BOOL
ceConvertWszToBstr(
    OUT BSTR *pbstr,
    IN WCHAR const *pwc,
    IN LONG cb);

BOOL
ceConvertSzToWsz(
    OUT WCHAR **ppwsz,
    IN char const *pch,
    IN LONG cch);

BOOL
ceConvertSzToBstr(
    OUT BSTR *pbstr,
    IN CHAR const *pch,
    IN LONG cch);

VOID
ceFreeBstr(
    IN OUT BSTR *pstr);

HRESULT
ceDateToFileTime(
    IN DATE const *pDate,
    OUT FILETIME *pft);

HRESULT
ceFileTimeToDate(
    IN FILETIME const *pft,
    OUT DATE *pDate);

HRESULT
ceVerifyObjIdA(
    IN char const *pszObjId);

HRESULT
ceVerifyObjId(
    IN WCHAR const *pwszObjId);

HRESULT
ceVerifyAltNameString(
    IN LONG NameChoice,
    IN BSTR strName);

HRESULT
ceDispatchSetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const *pwszProgId,
    OPTIONAL IN IID const *piid);

VOID
ceInitErrorMessageText(
    IN HMODULE hMod,
    IN DWORD idsUnexpected,
    IN DWORD idsUnknownErrorCode);	// L"Error %ws %ws"

WCHAR const *
ceGetErrorMessageText(
    IN HRESULT hr,
    IN BOOL fHResultString);

WCHAR const *
ceGetErrorMessageTextEx(
    IN HRESULT hr,
    IN BOOL fHResultString,
    IN OPTIONAL WCHAR const * const *papwszInsertionText);

WCHAR const *
ceHResultToString(
    IN OUT WCHAR *awchr,
    IN HRESULT hr);


#define cwcFILENAMESUFFIXMAX		20
#define cwcSUFFIXMAX	(1 + 5 + 1)	// five decimal digits plus parentheses

#define wszFCSAPARM_SERVERDNSNAME		L"%1"
#define wszFCSAPARM_SERVERSHORTNAME		L"%2"
#define wszFCSAPARM_SANITIZEDCANAME		L"%3"
#define wszFCSAPARM_CERTFILENAMESUFFIX		L"%4"
#define wszFCSAPARM_DOMAINDN			L"%5"
#define wszFCSAPARM_CONFIGDN			L"%6"
#define wszFCSAPARM_SANITIZEDCANAMEHASH		L"%7"
#define wszFCSAPARM_CRLFILENAMESUFFIX		L"%8"
#define wszFCSAPARM_CRLDELTAFILENAMESUFFIX	L"%9"
#define wszFCSAPARM_DSCRLATTRIBUTE		L"%10"
#define wszFCSAPARM_DSCACERTATTRIBUTE		L"%11"
#define wszFCSAPARM_DSUSERCERTATTRIBUTE		L"%12"
#define wszFCSAPARM_DSKRACERTATTRIBUTE		L"%13"
#define wszFCSAPARM_DSCROSSCERTPAIRATTRIBUTE	L"%14"


HRESULT
ceFormatCertsrvStringArray(
    IN BOOL fURL,
    IN LPCWSTR pwszServerName_p1_2,
    IN LPCWSTR pwszSanitizedName_p3_7,
    IN DWORD   iCert_p4,
    IN DWORD   iCertTarget_p4,
    IN LPCWSTR pwszDomainDN_p5,
    IN LPCWSTR pwszConfigDN_p6,
    IN DWORD   iCRL_p8,
    IN BOOL    fDeltaCRL_p9,
    IN BOOL    fDSAttrib_p10_11,
    IN DWORD   cStrings,
    IN LPCWSTR *apwszStringsIn,
    OUT LPWSTR *apwszStringsOut);

HRESULT
ceBuildPathAndExt(
    IN WCHAR const *pwszDir,
    IN WCHAR const *pwszFile,
    OPTIONAL IN WCHAR const *pwszExt,
    OUT WCHAR **ppwszPath);

HRESULT
ceInternetCanonicalizeUrl(
    IN WCHAR const *pwszIn,
    OUT WCHAR **ppwszOut);

int 
ceWtoI(
    IN WCHAR const *pwszDigitString,
    OUT BOOL *pfValid);

int
celstrcmpiL(
    IN WCHAR const *pwsz1,
    IN WCHAR const *pwsz2);

HRESULT
ceIsConfigLocal(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR **ppwszMachine,
    OUT BOOL *pfLocal);

#endif // __CELIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\cainfop.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cainfop.h
//
// Contents:    Private definitions for CA Info
//
// History:     12-dec-97  petesk  created
//
//---------------------------------------------------------------------------

#ifndef __CAINFOP_H__

#define __CAINFOP_H__

#include <winldap.h>


#define SYSTEM_CN TEXT("System")
#define PUBLIC_KEY_SERVICES_CN TEXT("Public Key Services")
#define CAS_CN TEXT("CAs") 

VOID CACleanup();

DWORD
DNStoRFC1779Name(
    WCHAR *rfcDomain,
    ULONG *rfcDomainLength,
    LPCWSTR dnsDomain);

DWORD
myGetSidFromDomain(
    IN LPWSTR wszDomain, 
    OUT PSID *ppDomainSid);

DWORD
myGetEnterpriseDnsName(
    OUT LPWSTR *pwszDomain);

BOOL
myNetLogonUser(
    LPTSTR UserName,
    LPTSTR DomainName,
    LPTSTR Password,
    PHANDLE phToken);

#ifndef DNS_MAX_NAME_LENGTH
#define DNS_MAX_NAME_LENGTH 255
#endif

typedef WCHAR *CERTSTR; 

//
// CAGetAuthoritativeDomainDn - retrieve the Domain root DN for this
// domain.  This retrieves config info from the DS for the default domain.
//


HRESULT 
CAGetAuthoritativeDomainDn(
    IN  LDAP*   LdapHandle,
    OUT CERTSTR *DomainDn,
    OUT CERTSTR *ConfigDN);

// 
// CASCreateCADSEntry - This creates a CA entry in the DS for this CA,
// and sets the appropriate entries for name, DN, certificate, dnsname.
// It is for use by setup.
// It creates the CA entry at the location 
// CN=bstrCAName,CN=CAs,CN=PublicKeyServices,CN=System,DC....root dc path...
// 

HRESULT 
CASCreateCADSEntry(
    IN CERTSTR bstrCAName,		// Name of the CA
    IN PCCERT_CONTEXT pCertificate);	// Certificate of the CA

HRESULT
GetCertAuthorityDSLocation(
    IN LDAP *LdapHandle,
    CERTSTR bstrCAName, 
    CERTSTR bstrDomainDN, 
    CERTSTR *bstrDSLocation);


class CCAProperty
{
public:
    CCAProperty(LPCWSTR wszName);


    HRESULT Find(LPCWSTR wszName, CCAProperty **ppCAProp);

static HRESULT Append(CCAProperty **ppCAPropChain, CCAProperty *pNewProp);

static HRESULT DeleteChain(CCAProperty **ppCAProp);


    HRESULT SetValue(LPWSTR * awszProperties);

    HRESULT GetValue(LPWSTR ** pawszProperties);
    HRESULT LoadFromRegValue(HKEY hkReg, LPCWSTR wszValue);
    HRESULT UpdateToRegValue(HKEY hkReg, LPCWSTR wszValue);


protected:


    // Only call via DeleteChain
    ~CCAProperty();
    HRESULT _Cleanup();


    WCHAR ** m_awszValues;
    CERTSTR   m_wszName;

    CCAProperty *m_pNext;

private:
};



HRESULT CertFreeString(CERTSTR cstrString);
CERTSTR CertAllocString(LPCWSTR wszString);
CERTSTR CertAllocStringLen(LPCWSTR wszString, UINT len);
CERTSTR CertAllocStringByteLen(LPCSTR szString, UINT len);
UINT    CertStringLen(CERTSTR cstrString);
UINT    CertStringByteLen(CERTSTR cstrString);


#define RLBF_TRUE			TRUE
#define RLBF_REQUIRE_GC			0x00000002
#define RLBF_ATTEMPT_REDISCOVER		0x00000004
#define RLBF_REQUIRE_SECURE_LDAP	0x00000008
#define RLBF_REQUIRE_LDAP_INTEG		0x00000010


// dwFlags must be BOOL to preserve signature

HRESULT
myRobustLdapBind(
    OUT LDAP **ppldap,
    IN BOOL dwFlags);   // RLBF_* (TRUE --> RLBF_REQUIRE_GC)


// dwFlags1 & dwFlags2 must be BOOL to preserve signature

HRESULT
myRobustLdapBindEx(
    IN BOOL dwFlags1,   // TRUE --> RLBF_REQUIRE_GC
    IN BOOL dwFlags2,	// RLBF_* (TRUE --> RLBF_ATTEMPT_REDISCOVER)
    IN ULONG uVersion,
    OPTIONAL IN WCHAR const *pwszDomainName,
    OUT LDAP **ppldap,
    OPTIONAL OUT WCHAR **ppwszForestDNSName);

HRESULT
CAAccessCheckp(
    HANDLE ClientToken,
    PSECURITY_DESCRIPTOR pSD);

HRESULT
CAAccessCheckpEx(
    IN HANDLE ClientToken,
    IN PSECURITY_DESCRIPTOR pSD,
    IN DWORD dwOption);


#endif // __CAINFOP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\certimp.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    certimp.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "certimp.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/


#include <windef.h>
#include <winbase.h>
#include <lmcons.h>
#define	_INC_WINDOWS
#include <winsock.h>
#include <certbcli.h>

#ifdef MIDL_PASS
#define BOOL DWORD
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\certca.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        certca.h
//
// Contents:    Definition of the CA Info API
//
// History:     12-dec-97       petesk  created
//              28-Jan-2000     xiaohs  updated
//
//---------------------------------------------------------------------------


#ifndef __CERTCA_H__
#define __CERTCA_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C"{
#endif


#include <wincrypt.h>

#if !defined(_CERTCLI_)
#define CERTCLIAPI DECLSPEC_IMPORT
#else
#define CERTCLIAPI
#endif


typedef VOID *  HCAINFO;

typedef VOID *  HCERTTYPE;

typedef VOID *  HCERTTYPEQUERY;

//*****************************************************************************
//
// Flags used by CAFindByName, CAFindByCertType, CAFindByIssuerDN and
// CAEnumFirstCA
//
// See comments on each API for a list of applicable flags
//
//*****************************************************************************
//the wszScope supplied is a domain location in the DNS format
#define CA_FLAG_SCOPE_DNS               0x00000001

// include untrusted CA
#define CA_FIND_INCLUDE_UNTRUSTED       0x00000010

// running as local system.  Used to verify CA certificate chain
#define CA_FIND_LOCAL_SYSTEM            0x00000020

// Include CAs that do not support templates
#define CA_FIND_INCLUDE_NON_TEMPLATE_CA 0x00000040

// The value passed in for scope is the LDAP binding handle to use during finds
#define CA_FLAG_SCOPE_IS_LDAP_HANDLE    0x00000800


//*****************************************************************************
//
// Flags used by CAEnumCertTypesForCA, CAEnumCertTypes,
// CAFindCertTypeByName, CAEnumCertTypesForCAEx, and CAEnumCertTypesEx.
//
// See comments on each API for a list of applicable flags
//
//*****************************************************************************
//  Instead of enumerating the certificate types supported by the CA, enumerate
// ALL certificate types which the CA may choose to support.
#define CA_FLAG_ENUM_ALL_TYPES          0x00000004

// running as local system.  Used to find cached information in the registry.
#define CT_FIND_LOCAL_SYSTEM            CA_FIND_LOCAL_SYSTEM

// Return machine types, as opposed to user types
#define CT_ENUM_MACHINE_TYPES           0x00000040

// Return user types, as opposed to user types
#define CT_ENUM_USER_TYPES              0x00000080

// Find the certificate type by its OID, instead of its name
#define CT_FIND_BY_OID                  0x00000200

// Disable the cache expiration check
#define CT_FLAG_NO_CACHE_LOOKUP         0x00000400

// The value passed in for scope is the LDAP binding handle to use during finds
#define CT_FLAG_SCOPE_IS_LDAP_HANDLE    CA_FLAG_SCOPE_IS_LDAP_HANDLE



//*****************************************************************************
//
// Certification Authority manipulation APIs
//
//*****************************************************************************


// CAFindByName
//
// Given the Name of a CA (CN), find the CA within the given domain and return
// the given phCAInfo structure.
//
// wszCAName    - Common name of the CA
//
// wszScope     - The distinguished name (DN) of the entry at which to start
//		  the search.  Equivalent of the "base" parameter of the
//		  ldap_search_sxxx APIs.
//                NULL if use the current domain.
//                If CA_FLAG_SCOPE_DNS is set, wszScope is in the DNS format.
//                If CA_FLAG_SCOPE_IS_LDAP_HANDLE is set, wszScope is the LDAP
//		  binding handle to use during finds.
//
// dwFlags      - Oring of the following flags:
//                CA_FLAG_SCOPE_DNS
//                CA_FIND_INCLUDE_UNTRUSTED
//                CA_FIND_LOCAL_SYSTEM
//                CA_FIND_INCLUDE_NON_TEMPLATE_CA
//                CA_FLAG_SCOPE_IS_LDAP_HANDLE
//
// phCAInfo     - Handle to the returned CA.
//
// Return:        Returns S_OK if CA was found.
//

CERTCLIAPI
HRESULT
WINAPI
CAFindByName(
    IN  LPCWSTR     wszCAName,
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCAINFO *   phCAInfo
    );

//
// CAFindByCertType
//
// Given the Name of a Cert Type, find all the CAs within the given domain and
// return the given phCAInfo structure.
//
// wszCertType  - Common Name of the cert type
//
// wszScope     - The distinguished name (DN) of the entry at which to start
//		  the search.  Equivalent of the "base" parameter of the
//		  ldap_search_sxxx APIs.
//                NULL if use the current domain.
//                If CA_FLAG_SCOPE_DNS is set, wszScope is in the DNS format.
//                If CA_FLAG_SCOPE_IS_LDAP_HANDLE is set, wszScope is the LDAP
//		  binding handle to use during finds.
//
// dwFlags      - Oring of the following flags:
//                CA_FLAG_SCOPE_DNS
//                CA_FIND_INCLUDE_UNTRUSTED
//                CA_FIND_LOCAL_SYSTEM
//                CA_FIND_INCLUDE_NON_TEMPLATE_CA
//                CA_FLAG_SCOPE_IS_LDAP_HANDLE
//
// phCAInfo     - Handle to enumeration of CAs supporting the specified cert
//		  type.
//
// Return:        Returns S_OK on success.
//                Will return S_OK if none are found.
//                *phCAInfo will contain NULL
//

CERTCLIAPI
HRESULT
WINAPI
CAFindByCertType(
    IN  LPCWSTR     wszCertType,
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCAINFO *   phCAInfo
    );


//
// CAFindByIssuerDN
// Given the DN of a CA, find the CA within the given domain and return the
// given phCAInfo handle.
//
// pIssuerDN    - a cert name blob from the CA's certificate.
//
// wszScope     - The distinguished name (DN) of the entry at which to start
//		  the search.  Equivalent of the "base" parameter of the
//		  ldap_search_sxxx APIs.
//                NULL if use the current domain.
//                If CA_FLAG_SCOPE_DNS is set, wszScope is in the DNS format.
//                If CA_FLAG_SCOPE_IS_LDAP_HANDLE is set, wszScope is the LDAP
//		  binding handle to use during finds.
//
// dwFlags      - Oring of the following flags:
//                CA_FLAG_SCOPE_DNS
//                CA_FIND_INCLUDE_UNTRUSTED
//                CA_FIND_LOCAL_SYSTEM
//                CA_FIND_INCLUDE_NON_TEMPLATE_CA
//                CA_FLAG_SCOPE_IS_LDAP_HANDLE 
//
//
// Return:      Returns S_OK if CA was found.
//


CERTCLIAPI
HRESULT
WINAPI
CAFindByIssuerDN(
    IN  CERT_NAME_BLOB const *  pIssuerDN,
    IN  LPCWSTR                 wszScope,
    IN  DWORD                   dwFlags,
    OUT HCAINFO *               phCAInfo
    );


//
// CAEnumFirstCA
// Enumerate the CAs in a scope
//
// wszScope     - The distinguished name (DN) of the entry at which to start
//		  the search.  Equivalent of the "base" parameter of the
//		  ldap_search_sxxx APIs.
//                NULL if use the current domain. 
//                If CA_FLAG_SCOPE_DNS is set, wszScope is in the DNS format.
//                If CA_FLAG_SCOPE_IS_LDAP_HANDLE is set, wszScope is the LDAP
//		  binding handle to use during finds.
//
// dwFlags      - Oring of the following flags:
//                CA_FLAG_SCOPE_DNS
//                CA_FIND_INCLUDE_UNTRUSTED
//                CA_FIND_LOCAL_SYSTEM
//                CA_FIND_INCLUDE_NON_TEMPLATE_CA
//                CA_FLAG_SCOPE_IS_LDAP_HANDLE 
//
// phCAInfo     - Handle to enumeration of CAs supporting the specified cert
//		  type.
//
//
// Return:        Returns S_OK on success.
//                Will return S_OK if none are found.
//                *phCAInfo will contain NULL
//

CERTCLIAPI
HRESULT
WINAPI
CAEnumFirstCA(
    IN  LPCWSTR          wszScope,
    IN  DWORD            dwFlags,
    OUT HCAINFO *        phCAInfo
    );


//
// CAEnumNextCA
// Find the Next CA in an enumeration.
//
// hPrevCA      - Current CA in an enumeration.
//
// phCAInfo     - next CA in an enumeration.
//
// Return:        Returns S_OK on success.
//                Will return S_OK if none are found.
//                *phCAInfo will contain NULL
//

CERTCLIAPI
HRESULT
WINAPI
CAEnumNextCA(
    IN  HCAINFO          hPrevCA,
    OUT HCAINFO *        phCAInfo
    );

//
// CACreateNewCA
// Create a new CA of given name.
//
// wszCAName    - Common name of the CA
//
// wszScope     - The distinguished name (DN) of the entry at which to create
//		  the CA object.  We will add the "CN=...,..,CN=Services" after
//		  the DN.
//                NULL if use the current domain. 
//                If CA_FLAG_SCOPE_DNS is set, wszScope is in the DNS format.
//
// dwFlags      - Oring of the following flags:
//                CA_FLAG_SCOPE_DNS
//
// phCAInfo     - Handle to the returned CA.
//
// See above for other parameter definitions
//
// Return:        Returns S_OK if CA was created.
//
// NOTE:  Actual updates to the CA object may not occur until CAUpdateCA is
//	  called.  In order to successfully update a created CA, the
//	  Certificate must be set, as well as the Certificate Types property.
//

CERTCLIAPI
HRESULT
WINAPI
CACreateNewCA(
    IN  LPCWSTR     wszCAName,
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCAINFO *   phCAInfo
    );

//
// CAUpdateCA
// Write any changes made to the CA back to the CA object.
//
// hCAInfo      - Handle to an open CA object.
//

CERTCLIAPI
HRESULT
WINAPI
CAUpdateCA(
    IN HCAINFO    hCAInfo
    );

//
// CADeleteCA
// Delete the CA object from the DS.
//
// hCAInfo      - Handle to an open CA object.
//

CERTCLIAPI
HRESULT
WINAPI
CADeleteCA(
    IN HCAINFO    hCAInfo
    );

//
// CACountCAs
// return the number of CAs in this enumeration
//

CERTCLIAPI
DWORD
WINAPI
CACountCAs(
    IN  HCAINFO  hCAInfo
    );

//
// CAGetDN
// returns the DN of the associated DS object
//

CERTCLIAPI
LPCWSTR
WINAPI
CAGetDN(
    IN HCAINFO hCAInfo
    );


//
// CACloseCA
// Close an open CA handle
//
// hCAInfo      - Handle to an open CA object.
//

CERTCLIAPI
HRESULT
WINAPI
CACloseCA(
    IN HCAINFO hCA
    );



//
// CAGetCAProperty - Given a property name, retrieve a
// property from a CAInfo.
//
// hCAInfo              - Handle to an open CA object.
//
// wszPropertyName      - Name of the CA property
//
// pawszPropertyValue   - A pointer into which an array of WCHAR strings is
//			  written, containing the values of the property.  The
//			  last element of the array points to NULL.
//                        If the property is single valued, then the array
//			  returned contains 2 elements, the first pointing to
//			  the value, the second pointing to NULL.  This pointer
//			  must be freed by CAFreeCAProperty.
//
// Returns              - S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCAProperty(
    IN  HCAINFO     hCAInfo,
    IN  LPCWSTR     wszPropertyName,
    OUT LPWSTR **   pawszPropertyValue
    );


//
// CAFreeProperty
// Frees a previously retrieved property value.
//
// hCAInfo              - Handle to an open CA object.
//
// awszPropertyValue    - pointer to the previously retrieved property value.
//

CERTCLIAPI
HRESULT
WINAPI
CAFreeCAProperty(
    IN  HCAINFO     hCAInfo,
    LPWSTR *        awszPropertyValue
    );


//
// CASetCAProperty - Given a property name, set its value.
//
// hCAInfo              - Handle to an open CA object.
//
// wszPropertyName      - Name of the CA property
//
// awszPropertyValue    - An array of values to set for this property.  The
//			  last element of this - array should be NULL.
//                        For single valued properties, the values beyond the
//                        first will be ignored upon update.
//
// Returns              - S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CASetCAProperty(
    IN HCAINFO      hCAInfo,
    IN LPCWSTR      wszPropertyName,
    IN LPWSTR *     awszPropertyValue
    );


//*****************************************************************************
///
// CA Properties
//
//*****************************************************************************

// simple name of the CA
#define CA_PROP_NAME                    L"cn"

// display name of the CA object
#define CA_PROP_DISPLAY_NAME            L"displayName"

// dns name of the machine
#define CA_PROP_DNSNAME                 L"dNSHostName"

// DS Location of CA object (DN)
#define CA_PROP_DSLOCATION              L"distinguishedName"

// Supported cert types
#define CA_PROP_CERT_TYPES              L"certificateTemplates"

// Supported signature algs
#define CA_PROP_SIGNATURE_ALGS          L"signatureAlgorithms"

// DN of the CA's cert
#define CA_PROP_CERT_DN                 L"cACertificateDN"

#define CA_PROP_ENROLLMENT_PROVIDERS    L"enrollmentProviders"

// CA's description
#define CA_PROP_DESCRIPTION		        L"Description"

//
// CAGetCACertificate - Return the current certificate for
// this CA.
//
// hCAInfo      - Handle to an open CA object.
//
// ppCert       - Pointer into which a certificate is written.  This
//		  certificate must be freed via CertFreeCertificateContext.
//                This value will be NULL if no certificate is set for this CA.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCAFlags(
    IN HCAINFO  hCAInfo,
    OUT DWORD  *pdwFlags
    );

//*****************************************************************************
//
// CA Flags
//
//*****************************************************************************

// The CA supports certificate templates
#define CA_FLAG_NO_TEMPLATE_SUPPORT                 0x00000001

// The CA supports NT authentication for requests
#define CA_FLAG_SUPPORTS_NT_AUTHENTICATION          0x00000002

// The cert requests may be pended
#define CA_FLAG_CA_SUPPORTS_MANUAL_AUTHENTICATION   0x00000004

// The cert requests may be pended
#define CA_FLAG_CA_SERVERTYPE_ADVANCED              0x00000008

#define CA_MASK_SETTABLE_FLAGS                      0x0000ffff


//
// CASetCAFlags
// Sets the Flags of a cert type
//
// hCertType    - handle to the CertType
//
// dwFlags      - Flags to be set
//

CERTCLIAPI
HRESULT
WINAPI
CASetCAFlags(
    IN HCAINFO             hCAInfo,
    IN DWORD               dwFlags
    );

CERTCLIAPI
HRESULT
WINAPI
CAGetCACertificate(
    IN  HCAINFO     hCAInfo,
    OUT PCCERT_CONTEXT *ppCert
    );


//
// CASetCACertificate - Set the certificate for a CA this CA.
//
// hCAInfo      - Handle to an open CA object.
//
// pCert        - Pointer to a certificate to set as the CA's certificate.
//

CERTCLIAPI
HRESULT
WINAPI
CASetCACertificate(
    IN  HCAINFO     hCAInfo,
    IN PCCERT_CONTEXT pCert
    );


//
// CAGetCAExpiration
// Get the expirations period for a CA.
//
// hCAInfo              - Handle to an open CA handle.
//
// pdwExpiration        - expiration period in dwUnits time
//
// pdwUnits             - Units identifier
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCAExpiration(
    HCAINFO hCAInfo,
    DWORD * pdwExpiration,
    DWORD * pdwUnits
    );

#define CA_UNITS_DAYS   1
#define CA_UNITS_WEEKS  2
#define CA_UNITS_MONTHS 3
#define CA_UNITS_YEARS  4


//
// CASetCAExpiration
// Set the expirations period for a CA.
//
// hCAInfo              - Handle to an open CA handle.
//
// dwExpiration         - expiration period in dwUnits time
//
// dwUnits              - Units identifier
//

CERTCLIAPI
HRESULT
WINAPI
CASetCAExpiration(
    HCAINFO hCAInfo,
    DWORD dwExpiration,
    DWORD dwUnits
    );

//
// CASetCASecurity
// Set the list of Users, Groups, and Machines allowed to access this CA.
//
// hCAInfo      - Handle to an open CA handle.
//
// pSD          - Security descriptor for this CA
//

CERTCLIAPI
HRESULT
WINAPI
CASetCASecurity(
    IN HCAINFO                 hCAInfo,
    IN PSECURITY_DESCRIPTOR    pSD
    );

//
// CAGetCASecurity
// Get the list of Users, Groups, and Machines allowed to access this CA.
//
// hCAInfo      - Handle to an open CA handle.
//
// ppSD         - Pointer to a location receiving the pointer to the security
//		  descriptor.  Free via LocalFree.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCASecurity(
    IN  HCAINFO                    hCAInfo,
    OUT PSECURITY_DESCRIPTOR *     ppSD
    );

//
// CAAccessCheck
// Determine whether the principal specified by
// ClientToken can get a cert from the CA.
//
// hCAInfo      - Handle to the CA
//
// ClientToken  - Handle to an impersonation token that represents the client
//		  attempting request this cert type.  The handle must have
//		  TOKEN_QUERY access to the token; otherwise, the function
//		  fails with ERROR_ACCESS_DENIED.
//
// Return: S_OK on success
//

CERTCLIAPI
HRESULT
WINAPI
CAAccessCheck(
    IN HCAINFO      hCAInfo,
    IN HANDLE       ClientToken
    );

//
// CAAccessCheckEx
// Determine whether the principal specified by
// ClientToken can get a cert from the CA.
//
// hCAInfo      - Handle to the CA
//
// ClientToken  - Handle to an impersonation token that represents the client
//		  attempting request this cert type.  The handle must have
//		  TOKEN_QUERY access to the token; otherwise, the function
//		  fails with ERROR_ACCESS_DENIED.
//
// dwOption     - Can be one of the following:
//                        CERTTYPE_ACCESS_CHECK_ENROLL

//                  dwOption can be CERTTYPE_ACCESS_CHECK_NO_MAPPING to 
//                  disallow default mapping of client token

//
// Return: S_OK on success
//

CERTCLIAPI
HRESULT
WINAPI
CAAccessCheckEx(
    IN HCAINFO      hCAInfo,
    IN HANDLE       ClientToken,
    IN DWORD        dwOption
    );


//
// CAEnumCertTypesForCA - Given a HCAINFO, retrieve handle to the cert types
// supported or known by this CA.  CAEnumNextCertType can be used to enumerate
// through the cert types.
//
// hCAInfo      - Handle to an open CA handle or NULL if CT_FLAG_ENUM_ALL_TYPES
//		  is set in dwFlags.
//
// dwFlags      - The following flags may be or'd together
//                CA_FLAG_ENUM_ALL_TYPES 
//                CT_FIND_LOCAL_SYSTEM
//                CT_ENUM_MACHINE_TYPES
//                CT_ENUM_USER_TYPES
//                CT_FLAG_NO_CACHE_LOOKUP  
//
// phCertType   - Enumeration of certificate types.
//


CERTCLIAPI
HRESULT
WINAPI
CAEnumCertTypesForCA(
    IN  HCAINFO     hCAInfo,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    );

//
// CAEnumCertTypesForCAEx - Given a HCAINFO, retrieve handle to the cert types
// supported or known by this CA.  CAEnumNextCertTypeEx can be used to enumerate
// through the cert types.  It optional takes a LDAP handle.
//
// hCAInfo      - Handle to an open CA handle or NULL if CT_FLAG_ENUM_ALL_TYPES
//		          is set in dwFlags.
//
// wszScope     - NULL if use the current domain.
//                      If CT_FLAG_SCOPE_IS_LDAP_HANDLE is set, wszScope is the LDAP
//		                binding handle to use during finds.
//
// dwFlags      - The following flags may be or'd together
//                CA_FLAG_ENUM_ALL_TYPES 
//                CT_FIND_LOCAL_SYSTEM
//                CT_ENUM_MACHINE_TYPES
//                CT_ENUM_USER_TYPES
//                CT_FLAG_NO_CACHE_LOOKUP  
//                CT_FLAG_SCOPE_IS_LDAP_HANDLE 
// 
// phCertType   - Enumeration of certificate types.
//


CERTCLIAPI
HRESULT
WINAPI
CAEnumCertTypesForCAEx(
    IN  HCAINFO     hCAInfo,
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    );


//
// CAAddCACertificateType
// Add a certificate type to a CA.  If the cert type has already been added to
// the CA, it will not be added again.
//
// hCAInfo      - Handle to an open CA.
//
// hCertType    - Cert type to add to CA.
//

CERTCLIAPI
HRESULT
WINAPI
CAAddCACertificateType(
    HCAINFO hCAInfo,
    HCERTTYPE hCertType
    );


//
// CADeleteCACertificateType
// Remove a certificate type from a CA.  If the CA does not include this cert
// type, this call does nothing.
//
// hCAInfo      - Handle to an open CA.
//
// hCertType    - Cert type to delete from CA.
//

CERTCLIAPI
HRESULT
WINAPI
CARemoveCACertificateType(
    HCAINFO hCAInfo,
    HCERTTYPE hCertType
    );




//*****************************************************************************
//
// Certificate Type APIs
//
//*****************************************************************************

//
// CAEnumCertTypes - Retrieve a handle to all known cert types
// CAEnumNextCertType can be used to enumerate through the cert types.
//
// dwFlags              - an oring of the following:
//                        CT_FIND_LOCAL_SYSTEM
//                        CT_ENUM_MACHINE_TYPES
//                        CT_ENUM_USER_TYPES
//                        CT_FLAG_NO_CACHE_LOOKUP  
//
// phCertType           - Enumeration of certificate types.
//


CERTCLIAPI
HRESULT
WINAPI
CAEnumCertTypes(
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    );


//
// CAEnumCertTypesEx - Retrieve a handle to all known cert types
// CAEnumNextCertType can be used to enumerate through the cert types.
//
// wszScope            - NULL if use the current domain.
//                        If CT_FLAG_SCOPE_IS_LDAP_HANDLE is set, wszScope is the LDAP
//		                  binding handle to use during finds.
//
// dwFlags              - an oring of the following:
//                        CT_FIND_LOCAL_SYSTEM
//                        CT_ENUM_MACHINE_TYPES
//                        CT_ENUM_USER_TYPES
//                        CT_FLAG_NO_CACHE_LOOKUP
//                        CT_FLAG_SCOPE_IS_LDAP_HANDLE  
//
// phCertType           - Enumeration of certificate types.
//


CERTCLIAPI
HRESULT
WINAPI
CAEnumCertTypesEx(
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    );


//
// CAFindCertTypeByName
// Find a cert type given a Name.
//
// wszCertType  - Name of the cert type if CT_FIND_BY_OID is not set in dwFlags
//                The OID of the cert type if CT_FIND_BY_OID is set in dwFlags
//
// hCAInfo      - NULL unless CT_FLAG_SCOPE_IS_LDAP_HANDLE is set in dwFlags
//
// dwFlags      - an oring of the following
//                CT_FIND_LOCAL_SYSTEM
//                CT_ENUM_MACHINE_TYPES
//                CT_ENUM_USER_TYPES
//                CT_FLAG_NO_CACHE_LOOKUP  
//                CT_FIND_BY_OID
//                CT_FLAG_SCOPE_IS_LDAP_HANDLE -- If this flag is set, hCAInfo
//						  is the LDAP handle to use
//						  during finds.
// phCertType   - Pointer to a cert type in which result is returned.
//

CERTCLIAPI
HRESULT
WINAPI
CAFindCertTypeByName(
    IN  LPCWSTR     wszCertType,
    IN  HCAINFO     hCAInfo,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    );


//*****************************************************************************
//
// Default cert type names
//
//*****************************************************************************

#define wszCERTTYPE_USER                    L"User"
#define wszCERTTYPE_USER_SIGNATURE          L"UserSignature"
#define wszCERTTYPE_SMARTCARD_USER          L"SmartcardUser"
#define wszCERTTYPE_USER_AS                 L"ClientAuth"
#define wszCERTTYPE_USER_SMARTCARD_LOGON    L"SmartcardLogon"
#define wszCERTTYPE_EFS                     L"EFS"
#define wszCERTTYPE_ADMIN                   L"Administrator"
#define wszCERTTYPE_EFS_RECOVERY            L"EFSRecovery"
#define wszCERTTYPE_CODE_SIGNING            L"CodeSigning"
#define wszCERTTYPE_CTL_SIGNING             L"CTLSigning"
#define wszCERTTYPE_ENROLLMENT_AGENT        L"EnrollmentAgent"


#define wszCERTTYPE_MACHINE                 L"Machine"
#define wszCERTTYPE_WORKSTATION             L"Workstation"
#define wszCERTTYPE_DC                      L"DomainController"
#define wszCERTTYPE_RASIASSERVER            L"RASAndIASServer"
#define wszCERTTYPE_WEBSERVER               L"WebServer"
#define wszCERTTYPE_KDC                     L"KDC"
#define wszCERTTYPE_CA                      L"CA"
#define wszCERTTYPE_SUBORDINATE_CA          L"SubCA"
#define wszCERTTYPE_CROSS_CA				L"CrossCA"
#define wszCERTTYPE_KEY_RECOVERY_AGENT      L"KeyRecoveryAgent"
#define wszCERTTYPE_CA_EXCHANGE             L"CAExchange"
#define wszCERTTYPE_DC_AUTH                 L"DomainControllerAuthentication"
#define wszCERTTYPE_DS_EMAIL_REPLICATION    L"DirectoryEmailReplication"


#define wszCERTTYPE_IPSEC_ENDENTITY_ONLINE      L"IPSECEndEntityOnline"
#define wszCERTTYPE_IPSEC_ENDENTITY_OFFLINE     L"IPSECEndEntityOffline"
#define wszCERTTYPE_IPSEC_INTERMEDIATE_ONLINE   L"IPSECIntermediateOnline"
#define wszCERTTYPE_IPSEC_INTERMEDIATE_OFFLINE  L"IPSECIntermediateOffline"

#define wszCERTTYPE_ROUTER_OFFLINE              L"OfflineRouter"
#define wszCERTTYPE_ENROLLMENT_AGENT_OFFLINE    L"EnrollmentAgentOffline"
#define wszCERTTYPE_EXCHANGE_USER               L"ExchangeUser"
#define wszCERTTYPE_EXCHANGE_USER_SIGNATURE     L"ExchangeUserSignature"
#define wszCERTTYPE_MACHINE_ENROLLMENT_AGENT    L"MachineEnrollmentAgent"
#define wszCERTTYPE_CEP_ENCRYPTION              L"CEPEncryption"

//
// CAUpdateCertType
// Write any changes made to the cert type back to the type store
//
CERTCLIAPI
HRESULT
WINAPI
CAUpdateCertType(
    IN HCERTTYPE           hCertType
    );


//
// CADeleteCertType
// Delete a CertType
//
// hCertType    - Cert type to delete.
//
// NOTE:  If this is called for a default cert type, it will revert back to its
// default attributes (if it has been modified)
//
CERTCLIAPI
HRESULT
WINAPI
CADeleteCertType(
    IN HCERTTYPE            hCertType
    );



//
// CACloneCertType
//
// Clone a certificate type.  The returned certificate type is a clone of the 
// input certificate type, with the new cert type name and display name.  By default,
// if the input template is a template for machines, all 
// CT_FLAG_SUBJECT_REQUIRE_XXXX bits in the subject name flag are turned off.  
//                                   
// hCertType        - Cert type to be cloned.
// wszCertType      - Name of the new cert type.
// wszFriendlyName  - Friendly name of the new cert type.  Could be NULL.
// pvldap           - The LDAP handle (LDAP *) to the directory.  Could be NULL.
// dwFlags          - Can be an ORing of the following flags:
//
//                      CT_CLONE_KEEP_AUTOENROLLMENT_SETTING
//                      CT_CLONE_KEEP_SUBJECT_NAME_SETTING
//
CERTCLIAPI
HRESULT
WINAPI
CACloneCertType(
    IN  HCERTTYPE            hCertType,
    IN  LPCWSTR              wszCertType,
    IN  LPCWSTR              wszFriendlyName,
    IN  LPVOID               pvldap,
    IN  DWORD                dwFlags,
    OUT HCERTTYPE *          phCertType
    );


#define  CT_CLONE_KEEP_AUTOENROLLMENT_SETTING       0x01
#define  CT_CLONE_KEEP_SUBJECT_NAME_SETTING         0x02  


//
// CACreateCertType
// Create a new cert type
//
// wszCertType  - Name of the cert type
//
// wszScope     - reserved.  Must set to NULL.
//
// dwFlags      - reserved.  Must set to NULL.
//
// phCertType   - returned cert type
//
CERTCLIAPI
HRESULT
WINAPI
CACreateCertType(
    IN  LPCWSTR             wszCertType,
    IN  LPCWSTR             wszScope,
    IN  DWORD               dwFlags,
    OUT HCERTTYPE *         phCertType
    );


//
// CAEnumNextCertType
// Find the Next Cert Type in an enumeration.
//
// hPrevCertType        - Previous cert type in enumeration
//
// phCertType           - Pointer to a handle into which result is placed.
//			  NULL if there are no more cert types in enumeration.
//

CERTCLIAPI
HRESULT
WINAPI
CAEnumNextCertType(
    IN  HCERTTYPE          hPrevCertType,
    OUT HCERTTYPE *        phCertType
    );


//
// CACountCertTypes
// return the number of cert types in this enumeration
//

CERTCLIAPI
DWORD
WINAPI
CACountCertTypes(
    IN  HCERTTYPE  hCertType
    );


//
// CACloseCertType
// Close an open CertType handle
//

CERTCLIAPI
HRESULT
WINAPI
CACloseCertType(
    IN HCERTTYPE hCertType
    );


//
// CAGetCertTypeProperty
// Retrieve a property from a certificate type.   This function is obsolete.
// Caller should use CAGetCertTypePropertyEx instead
//
// hCertType            - Handle to an open CertType object.
//
// wszPropertyName      - Name of the CertType property.
//
// pawszPropertyValue   - A pointer into which an array of WCHAR strings is
//			  written, containing the values of the property.  The
//			  last element of the array points to NULL.  If the
//			  property is single valued, then the array returned
//			  contains 2 elements, the first pointing to the value,
//			  the second pointing to NULL.  This pointer must be
//                        freed by CAFreeCertTypeProperty.
//
// Returns              - S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    OUT LPWSTR **   pawszPropertyValue);

//
// CAGetCertTypePropertyEx
// Retrieve a property from a certificate type.
//
// hCertType            - Handle to an open CertType object.
//
// wszPropertyName      - Name of the CertType property
//
// pPropertyValue       - Depending on the value of wszPropertyName,
//			  pPropertyValue is either DWORD * or LPWSTR **.  
// 
//                        It is a DWORD * for:
//                          CERTTYPE_PROP_REVISION              
//                          CERTTYPE_PROP_SCHEMA_VERSION		
//                          CERTTYPE_PROP_MINOR_REVISION        
//                          CERTTYPE_PROP_RA_SIGNATURE			
//                          CERTTYPE_PROP_MIN_KEY_SIZE	
//		
//                        It is a LPWSTR ** for:
//                          CERTTYPE_PROP_CN                    
//                          CERTTYPE_PROP_DN                    
//                          CERTTYPE_PROP_FRIENDLY_NAME         
//                          CERTTYPE_PROP_EXTENDED_KEY_USAGE    
//                          CERTTYPE_PROP_CSP_LIST              
//                          CERTTYPE_PROP_CRITICAL_EXTENSIONS   
//                          CERTTYPE_PROP_OID					
//                          CERTTYPE_PROP_SUPERSEDE				
//                          CERTTYPE_PROP_RA_POLICY				
//                          CERTTYPE_PROP_POLICY
//                          CERTTYPE_PROP_DESCRIPTION
//				
//                        A pointer into which an array of WCHAR strings is
//			  written, containing the values of the property.  The
//			  last element of the array points to NULL.  If the
// 			  property is single valued, then the array returned
//			  contains 2 elements, the first pointing to the value,
//			  the second pointing to NULL. This pointer must be
//                        freed by CAFreeCertTypeProperty.
//
// Returns              - S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypePropertyEx(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    OUT LPVOID      pPropertyValue);


//*****************************************************************************
//
// Certificate Type properties
// 
//*****************************************************************************

//*****************************************************************************
//
//  The schema version one properties
//
//*****************************************************************************

// Common name of the certificate type
#define CERTTYPE_PROP_CN                    L"cn"

// The common name of the certificate type.  Same as CERTTYPE_PROP_CN
// This property is not settable.
#define CERTTYPE_PROP_DN                    L"distinguishedName"

// The display name of a cert type
#define CERTTYPE_PROP_FRIENDLY_NAME         L"displayName"

// An array of extended key usage OIDs for a cert type
// NOTE: This property can also be set by setting
// the Extended Key Usage extension.
#define CERTTYPE_PROP_EXTENDED_KEY_USAGE    L"pKIExtendedKeyUsage"

// The list of default CSPs for this cert type
#define CERTTYPE_PROP_CSP_LIST              L"pKIDefaultCSPs"

// The list of critical extensions
#define CERTTYPE_PROP_CRITICAL_EXTENSIONS   L"pKICriticalExtensions"

// The major version of the templates
#define CERTTYPE_PROP_REVISION              L"revision"

// The description of the templates
#define CERTTYPE_PROP_DESCRIPTION           L"templateDescription"

//*****************************************************************************
//
//  The schema version two properties
//
//*****************************************************************************
// The schema version of the templates
// This property is not settable
#define CERTTYPE_PROP_SCHEMA_VERSION	    L"msPKI-Template-Schema-Version"

// The minor version of the templates
#define CERTTYPE_PROP_MINOR_REVISION        L"msPKI-Template-Minor-Revision"

// The number of RA signatures required on a request referencing this template.
#define CERTTYPE_PROP_RA_SIGNATURE	    L"msPKI-RA-Signature"

// The minimal key size required
#define CERTTYPE_PROP_MIN_KEY_SIZE	    L"msPKI-Minimal-Key-Size"

// The OID of this template
#define CERTTYPE_PROP_OID		    L"msPKI-Cert-Template-OID"

// The OID of the template that this template supersedes
#define CERTTYPE_PROP_SUPERSEDE		    L"msPKI-Supersede-Templates"

// The RA issuer policy OIDs required in certs used to sign a request.
// Each signing cert's szOID_CERT_POLICIES extensions must contain at least one
// of the OIDs listed in the msPKI-RA-Policies property.
// Each OID listed must appear in the szOID_CERT_POLICIES extension of at least
// one signing cert.
#define CERTTYPE_PROP_RA_POLICY		    L"msPKI-RA-Policies"

// The RA application policy OIDs required in certs used to sign a request.
// Each signing cert's szOID_APPLICATION_CERT_POLICIES extensions must contain
// all of the OIDs listed in the msPKI-RA-Application-Policies property.
#define CERTTYPE_PROP_RA_APPLICATION_POLICY L"msPKI-RA-Application-Policies"

// The certificate issuer policy OIDs are placed in the szOID_CERT_POLICIES
// extension by the policy module.
#define CERTTYPE_PROP_POLICY		    L"msPKI-Certificate-Policy"

// The certificate application policy OIDs are placed in the
// szOID_APPLICATION_CERT_POLICIES extension by the policy module.
#define CERTTYPE_PROP_APPLICATION_POLICY    L"msPKI-Certificate-Application-Policy"


#define CERTTYPE_SCHEMA_VERSION_1	1	
#define CERTTYPE_SCHEMA_VERSION_2	(CERTTYPE_SCHEMA_VERSION_1 + 1)


//
// CASetCertTypeProperty
// Set a property of a CertType.  This function is obsolete.  
// Use CASetCertTypePropertyEx.
//
// hCertType            - Handle to an open CertType object.
//
// wszPropertyName      - Name of the CertType property
//
// awszPropertyValue    - An array of values to set for this property.  The
//			  last element of this array should be NULL.  For
//			  single valued properties, the values beyond the first
//			  will be ignored upon update.
//
// Returns              - S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CASetCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    IN  LPWSTR *    awszPropertyValue
    );

//
// CASetCertTypePropertyEx
// Set a property of a CertType
//
// hCertType            - Handle to an open CertType object.
//
// wszPropertyName      - Name of the CertType property
//
// pPropertyValue       - Depending on the value of wszPropertyName,
//			  pPropertyValue is either DWORD * or LPWSTR *. 
// 
//                        It is a DWORD * for:
//                          CERTTYPE_PROP_REVISION              
//                          CERTTYPE_PROP_MINOR_REVISION        
//                          CERTTYPE_PROP_RA_SIGNATURE			
//                          CERTTYPE_PROP_MIN_KEY_SIZE	
//
//                        It is a LPWSTR * for:
//                          CERTTYPE_PROP_FRIENDLY_NAME         
//                          CERTTYPE_PROP_EXTENDED_KEY_USAGE    
//                          CERTTYPE_PROP_CSP_LIST              
//                          CERTTYPE_PROP_CRITICAL_EXTENSIONS   
//                          CERTTYPE_PROP_OID					
//                          CERTTYPE_PROP_SUPERSEDE				
//                          CERTTYPE_PROP_RA_POLICY				
//                          CERTTYPE_PROP_POLICY
//				
//                      - An array of values to set for this property.  The
//			  last element of this array should be NULL.  For
//			  single valued properties, the values beyond the first
//			  will be ignored upon update.
//
//      
//                      - CertType of V1 schema can only set V1 properties.
//
// Returns              - S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CASetCertTypePropertyEx(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    IN  LPVOID      pPropertyValue
    );


//
// CAFreeCertTypeProperty
// Frees a previously retrieved property value.
//
// hCertType            - Handle to an open CertType object.
//
// awszPropertyValue     - The values to be freed.
//
CERTCLIAPI
HRESULT
WINAPI
CAFreeCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    IN  LPWSTR *    awszPropertyValue
    );


//
// CAGetCertTypeExtensions
// Retrieves the extensions associated with this CertType.
//
// hCertType            - Handle to an open CertType object.
// ppCertExtensions     - Pointer to a PCERT_EXTENSIONS to receive the result
//			  of this call.  Should be freed via a
//			  CAFreeCertTypeExtensions call.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypeExtensions(
    IN  HCERTTYPE           hCertType,
    OUT PCERT_EXTENSIONS *  ppCertExtensions
    );


//
// CAGetCertTypeExtensionsEx
// Retrieves the extensions associated with this CertType.
//
// hCertType            - Handle to an open CertType object.
// dwFlags              - Indicate which extension to be returned.
//                        Can be an ORing of following flags:
//                          
//                          CT_EXTENSION_TEMPLATE
//                          CT_EXTENSION_KEY_USAGE
//                          CT_EXTENSION_EKU
//                          CT_EXTENSION_BASIC_CONTRAINTS
//                          CT_EXTENSION_APPLICATION_POLICY (Version 2 template only)
//                          CT_EXTENSION_ISSUANCE_POLICY  (Version 2 template only)
//
//                        0 means all avaiable extension for this CertType.
//
// pParam               - Reserved.  Must be NULL.
// ppCertExtensions     - Pointer to a PCERT_EXTENSIONS to receive the result
//			  of this call.  Should be freed via a
//			  CAFreeCertTypeExtensions call.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypeExtensionsEx(
    IN  HCERTTYPE           hCertType,
    IN  DWORD               dwFlags,
    IN  LPVOID              pParam,
    OUT PCERT_EXTENSIONS *  ppCertExtensions
    );


#define     CT_EXTENSION_TEMPLATE               0x01
#define     CT_EXTENSION_KEY_USAGE              0x02
#define     CT_EXTENSION_EKU                    0x04
#define     CT_EXTENSION_BASIC_CONTRAINTS       0x08
#define     CT_EXTENSION_APPLICATION_POLICY     0x10
#define     CT_EXTENSION_ISSUANCE_POLICY        0x20



//
// CAFreeCertTypeExtensions
// Free a PCERT_EXTENSIONS allocated by CAGetCertTypeExtensions
//
CERTCLIAPI
HRESULT
WINAPI
CAFreeCertTypeExtensions(
    IN  HCERTTYPE           hCertType,
    IN  PCERT_EXTENSIONS    pCertExtensions
    );

//
// CASetCertTypeExtension
// Set the value of an extension for this
// cert type.
//
// hCertType            - handle to the CertType
//
// wszExtensionId       - OID for the extension
//
// dwFlags              - Mark the extension critical
//
// pExtension           - pointer to the appropriate extension structure
//
// Supported extensions/structures
//
// szOID_ENHANCED_KEY_USAGE     CERT_ENHKEY_USAGE
// szOID_KEY_USAGE              CRYPT_BIT_BLOB
// szOID_BASIC_CONSTRAINTS2     CERT_BASIC_CONSTRAINTS2_INFO
//
// Returns S_OK if successful.
//

CERTCLIAPI
HRESULT
WINAPI
CASetCertTypeExtension(
    IN HCERTTYPE   hCertType,
    IN LPCWSTR wszExtensionId,
    IN DWORD   dwFlags,
    IN LPVOID pExtension
    );

#define CA_EXT_FLAG_CRITICAL   0x00000001



//
// CAGetCertTypeFlags
// Retrieve cert type flags.  
// This function is obsolete.  Use CAGetCertTypeFlagsEx.
//
// hCertType            - handle to the CertType
//
// pdwFlags             - pointer to DWORD receiving flags
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypeFlags(
    IN  HCERTTYPE           hCertType,
    OUT DWORD *             pdwFlags
    );

//
// CAGetCertTypeFlagsEx
// Retrieve cert type flags
//
// hCertType            - handle to the CertType
//
// dwOption             - Which flag to set
//                        Can be one of the following:
//                        CERTTYPE_ENROLLMENT_FLAG
//                        CERTTYPE_SUBJECT_NAME_FLAG
//                        CERTTYPE_PRIVATE_KEY_FLAG
//                        CERTTYPE_GENERAL_FLAG
//
// pdwFlags             - pointer to DWORD receiving flags
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypeFlagsEx(
    IN  HCERTTYPE           hCertType,
    IN  DWORD               dwOption,
    OUT DWORD *             pdwFlags
    );


//*****************************************************************************
//
// Cert Type Flags
//
// The CertType flags are grouped into 4 categories:
//  1. Enrollment Flags (CERTTYPE_ENROLLMENT_FLAG)     
//	2. Certificate Subject Name Flags (CERTTYPE_SUBJECT_NAME_FLAG)  
//	3. Private Key Flags (CERTTYPE_PRIVATE_KEY_FLAG)    
//	4. General Flags (CERTTYPE_GENERAL_FLAG)        
//*****************************************************************************

//Enrollment Flags
#define CERTTYPE_ENROLLMENT_FLAG            0x01

//Certificate Subject Name Flags
#define CERTTYPE_SUBJECT_NAME_FLAG          0x02

//Private Key Flags
#define CERTTYPE_PRIVATE_KEY_FLAG           0x03

//General Flags
#define CERTTYPE_GENERAL_FLAG               0x04

//*****************************************************************************
//
// Enrollment Flags:
//
//*****************************************************************************
// Include the symmetric algorithms in the requests
#define CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS			0x00000001

// All certificate requests are pended
#define CT_FLAG_PEND_ALL_REQUESTS				0x00000002

// Publish the certificate to the KRA (key recovery agent container) on the DS
#define CT_FLAG_PUBLISH_TO_KRA_CONTAINER			0x00000004
		
// Publish the resultant cert to the userCertificate property in the DS
#define CT_FLAG_PUBLISH_TO_DS					0x00000008

// The autoenrollment will not enroll for new certificate if user has a certificate
// published on the DS with the same template name
#define CT_FLAG_AUTO_ENROLLMENT_CHECK_USER_DS_CERTIFICATE       0x00000010

// This cert is appropriate for auto-enrollment
#define CT_FLAG_AUTO_ENROLLMENT					0x00000020

// A previously issued certificate will valid subsequent enrollment requests
#define CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT         0x00000040

// Domain authentication is not required.  
#define CT_FLAG_DOMAIN_AUTHENTICATION_NOT_REQUIRED              0x00000080

// User interaction is required to enroll
#define CT_FLAG_USER_INTERACTION_REQUIRED                       0x00000100

// Add szOID_CERTTYPE_EXTENSION (template name) extension
// This flag will ONLY be set on V1 certificate templates for W2K CA only.
#define CT_FLAG_ADD_TEMPLATE_NAME		                0x00000200

// Remove invalid (expired or revoked) certificate from personal store
#define CT_FLAG_REMOVE_INVALID_CERTIFICATE_FROM_PERSONAL_STORE  0x00000400

// Allow enroll-on-behalf-of; RA requirements still apply to signers
#define CT_FLAG_ALLOW_ENROLL_ON_BEHALF_OF  			0x00000800


//*****************************************************************************
//
// Certificate Subject Name Flags:
//
//*****************************************************************************

// The enrolling application must supply the subject name.
#define CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT			0x00000001

// The enrolling application must supply the subjectAltName in request
#define CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME		0x00010000

// Subject name should be full DN
#define CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH			0x80000000

// Subject name should be the common name
#define CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME			0x40000000

// Subject name includes the e-mail name
#define CT_FLAG_SUBJECT_REQUIRE_EMAIL				0x20000000

// Subject name includes the DNS name as the common name
#define CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN			0x10000000

// Subject alt name includes DNS name
#define CT_FLAG_SUBJECT_ALT_REQUIRE_DNS				0x08000000

// Subject alt name includes email name
#define CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL			0x04000000

// Subject alt name requires UPN
#define CT_FLAG_SUBJECT_ALT_REQUIRE_UPN				0x02000000

// Subject alt name requires directory GUID
#define CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID		0x01000000

// Subject alt name requires SPN
#define CT_FLAG_SUBJECT_ALT_REQUIRE_SPN                         0x00800000


//
// Obsolete name	
// The following flags are obsolete.  They are used by V1 templates in the
// general flags
//
#define CT_FLAG_IS_SUBJECT_REQ      CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT

// The e-mail name of the principal will be added to the cert
#define CT_FLAG_ADD_EMAIL					0x00000002

// Add the object GUID for this principal
#define CT_FLAG_ADD_OBJ_GUID					0x00000004

// Add DS Name (full DN) to szOID_SUBJECT_ALT_NAME2 (Subj Alt Name 2) extension
// This flag is not SET in any of the V1 templates and is of no interests to
// V2 templates since it is not present on the UI and will never be set.
#define CT_FLAG_ADD_DIRECTORY_PATH				0x00000100


//*****************************************************************************
//
// Private Key Flags:
//
//*****************************************************************************

// Archival of the private key is allowed
#define CT_FLAG_ALLOW_PRIVATE_KEY_ARCHIVAL	0x00000001

#define CT_FLAG_REQUIRE_PRIVATE_KEY_ARCHIVAL	CT_FLAG_ALLOW_PRIVATE_KEY_ARCHIVAL

// Make the key for this cert exportable.
#define CT_FLAG_EXPORTABLE_KEY			0x00000010

// Require the strong key protection UI when a new key is generated
#define CT_FLAG_STRONG_KEY_PROTECTION_REQUIRED					0x00000020

//*****************************************************************************
//
// General Flags
//
//	More flags should start from 0x00000400
//
//*****************************************************************************
// This is a machine cert type
#define CT_FLAG_MACHINE_TYPE                0x00000040

// This is a CA	cert type
#define CT_FLAG_IS_CA                       0x00000080

// This is a cross CA cert type 
#define CT_FLAG_IS_CROSS_CA                 0x00000800

// The type is a default cert type (cannot be set).  This flag will be set on
// all V1 templates.  The templates can not be edited or deleted.
#define CT_FLAG_IS_DEFAULT                  0x00010000

// The type has been modified, if it is default (cannot be set)
#define CT_FLAG_IS_MODIFIED                 0x00020000

// settable flags for general flags
#define CT_MASK_SETTABLE_FLAGS              0x0000ffff

//
// CASetCertTypeFlags
// Sets the General Flags of a cert type.
// This function is obsolete.  Use CASetCertTypeFlagsEx.
//
// hCertType            - handle to the CertType
//
// dwFlags              - Flags to be set
//

CERTCLIAPI
HRESULT
WINAPI
CASetCertTypeFlags(
    IN HCERTTYPE           hCertType,
    IN DWORD               dwFlags
    );

//
// CASetCertTypeFlagsEx
// Sets the Flags of a cert type
//
// hCertType            - handle to the CertType
//
// dwOption             - Which flag to set
//                        Can be one of the following:
//                        CERTTYPE_ENROLLMENT_FLAG
//                        CERTTYPE_SUBJECT_NAME_FLAG
//                        CERTTYPE_PRIVATE_KEY_FLAG
//                        CERTTYPE_GENERAL_FLAG
//
// dwFlags              - Value to be set
//          

CERTCLIAPI
HRESULT
WINAPI
CASetCertTypeFlagsEx(
    IN HCERTTYPE           hCertType,
    IN DWORD               dwOption,
    IN DWORD               dwFlags
    );

//
// CAGetCertTypeKeySpec
// Retrieve the CAPI Key Spec for this cert type
//
// hCertType            - handle to the CertType
//
// pdwKeySpec           - pointer to DWORD receiving key spec
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypeKeySpec(
    IN  HCERTTYPE           hCertType,
    OUT DWORD *             pdwKeySpec
    );

//
// CACertTypeSetKeySpec
// Sets the CAPI1 Key Spec of a cert type
//
// hCertType            - handle to the CertType
//
// dwKeySpec            - KeySpec to be set
//

CERTCLIAPI
HRESULT
WINAPI
CASetCertTypeKeySpec(
    IN HCERTTYPE            hCertType,
    IN DWORD                dwKeySpec
    );

//
// CAGetCertTypeExpiration
// Retrieve the Expiration Info for this cert type
//
// pftExpiration        - pointer to the FILETIME structure receiving
//                        the expiration period for this cert type.
//
// pftOverlap           - pointer to the FILETIME structure receiving the
//			  suggested renewal overlap period for this cert type.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypeExpiration(
    IN  HCERTTYPE           hCertType,
    OUT OPTIONAL FILETIME * pftExpiration,
    OUT OPTIONAL FILETIME * pftOverlap
    );

//
// CASetCertTypeExpiration
// Set the Expiration Info for this cert type
//
// pftExpiration        - pointer to the FILETIME structure containing
//                        the expiration period for this cert type.
//
// pftOverlap           - pointer to the FILETIME structure containing the
//			  suggested renewal overlap period for this cert type.
//

CERTCLIAPI
HRESULT
WINAPI
CASetCertTypeExpiration(
    IN  HCERTTYPE           hCertType,
    IN OPTIONAL FILETIME  * pftExpiration,
    IN OPTIONAL FILETIME  * pftOverlap
    );
//
// CACertTypeSetSecurity
// Set the list of Users, Groups, and Machines allowed
// to access this cert type.
//
// hCertType            - handle to the CertType
//
// pSD                  - Security descriptor for this cert type
//

CERTCLIAPI
HRESULT
WINAPI
CACertTypeSetSecurity(
    IN HCERTTYPE               hCertType,
    IN PSECURITY_DESCRIPTOR    pSD
    );


//
// CACertTypeGetSecurity
// Get the list of Users, Groups, and Machines allowed
// to access this cert type.
//
// hCertType            - handle to the CertType
//
// ppaSidList           - Pointer to a location receiving the pointer to the
//			  security descriptor.  Free via LocalFree.
//

CERTCLIAPI
HRESULT
WINAPI
CACertTypeGetSecurity(
    IN  HCERTTYPE                  hCertType,
    OUT PSECURITY_DESCRIPTOR *     ppSD
    );

//
//
// CACertTypeAccessCheck
// Determine whether the principal specified by
// ClientToken can be issued this cert type.
//
// hCertType            - handle to the CertType
//
// ClientToken          - Handle to an impersonation token that represents the
//			  client attempting to request this cert type.  The
//			  handle must have TOKEN_QUERY access to the token;
//                        otherwise, the call fails with ERROR_ACCESS_DENIED.
//
// Return: S_OK on success
//

CERTCLIAPI
HRESULT
WINAPI
CACertTypeAccessCheck(
    IN HCERTTYPE    hCertType,
    IN HANDLE       ClientToken
    );

//
//
// CACertTypeAccessCheckEx
// Determine whether the principal specified by
// ClientToken can be issued this cert type.
//
// hCertType            - handle to the CertType
//
// ClientToken          - Handle to an impersonation token that represents the
//			  client attempting to request this cert type.  The
//			  handle must have TOKEN_QUERY access to the token;
//                        otherwise, the call fails with ERROR_ACCESS_DENIED.
//
// dwOption             - Can be one of the following:
//                        CERTTYPE_ACCESS_CHECK_ENROLL
//                        CERTTYPE_ACCESS_CHECK_AUTO_ENROLL
//                      
//                      dwOption can be ORed with CERTTYPE_ACCESS_CHECK_NO_MAPPING
//                      to disallow default mapping of client token
//
// Return: S_OK on success
//

CERTCLIAPI
HRESULT
WINAPI
CACertTypeAccessCheckEx(
    IN HCERTTYPE    hCertType,
    IN HANDLE       ClientToken,
    IN DWORD        dwOption
    );


#define CERTTYPE_ACCESS_CHECK_ENROLL        0x01
#define CERTTYPE_ACCESS_CHECK_AUTO_ENROLL   0x02

#define CERTTYPE_ACCESS_CHECK_NO_MAPPING    0x00010000

//
//
// CAInstallDefaultCertType
//
// Install default certificate types on the enterprise.  
//
// dwFlags            - Reserved.  Must be 0 for now
//
//
// Return: S_OK on success
//
CERTCLIAPI
HRESULT
WINAPI
CAInstallDefaultCertType(
    IN DWORD dwFlags
    );


//
//
// CAIsCertTypeCurrent
//
// Check if the certificate type on the DS is up to date 
//
// dwFlags            - Reserved.  Must be 0 for now
// wszCertType        - The name for the certificate type
//
// Return: TRUE if the cert type is update to date
//
CERTCLIAPI
BOOL
WINAPI
CAIsCertTypeCurrent(
    IN DWORD    dwFlags,
    IN LPWSTR   wszCertType   
    );

//*****************************************************************************
//
//  OID management APIs
//
//*****************************************************************************
//
// CAOIDCreateNew
// Create a new OID based on the enterprise base
//
// dwType                - Can be one of the following:
//                        CERT_OID_TYPE_TEMPLATE			
//                        CERT_OID_TYPE_ISSUER_POLICY
//                        CERT_OID_TYPE_APPLICATION_POLICY
//
// dwFlag               - Reserved.  Must be 0.
//
// ppwszOID             - Return the new OID.  Free memory via LocalFree().
//
// Returns S_OK if successful.
//

CERTCLIAPI
HRESULT
WINAPI
CAOIDCreateNew(
    IN	DWORD   dwType,
    IN  DWORD   dwFlag,
    OUT LPWSTR	*ppwszOID);


#define CERT_OID_TYPE_TEMPLATE			0x01
#define CERT_OID_TYPE_ISSUER_POLICY		0x02
#define CERT_OID_TYPE_APPLICATION_POLICY	0x03

//
// CAOIDAdd
// Add an OID to the DS repository
//
// dwType               - Can be one of the following:
//                        CERT_OID_TYPE_TEMPLATE			
//                        CERT_OID_TYPE_ISSUER_POLICY
//                        CERT_OID_TYPE_APPLICATION_POLICY
//
// dwFlag               - Reserved.  Must be 0.
//
// pwszOID              - The OID to add.
//
// Returns S_OK if successful.
// Returns CRYPT_E_EXISTS if the OID alreay exits in the DS repository
//

CERTCLIAPI
HRESULT
WINAPI
CAOIDAdd(
    IN	DWORD       dwType,
    IN  DWORD       dwFlag,
    IN  LPCWSTR	    pwszOID);


//
// CAOIDDelete
// Delete the OID from the DS repository
//
// pwszOID              - The OID to delete.
//
// Returns S_OK if successful.
//

CERTCLIAPI
HRESULT
WINAPI
CAOIDDelete(
    IN LPCWSTR	pwszOID);

//
// CAOIDSetProperty
// Set a property on an OID.  
//
// pwszOID              - The OID whose value is set
// dwProperty           - The property name.  Can be one of the following:
//                        CERT_OID_PROPERTY_DISPLAY_NAME
//                        CERT_OID_PROPERTY_CPS
//
// pPropValue           - The value of the property.
//                        If dwProperty is CERT_OID_PROPERTY_DISPLAY_NAME,
//                        pPropValue is LPWSTR. 
//                        if dwProperty is CERT_OID_PROPERTY_CPS,
//                        pPropValue is LPWSTR.  
//                        NULL will remove the property
//
//
// Returns S_OK if successful.
//

CERTCLIAPI
HRESULT
WINAPI
CAOIDSetProperty(
    IN  LPCWSTR pwszOID,
    IN  DWORD   dwProperty,
    IN  LPVOID  pPropValue);



#define CERT_OID_PROPERTY_DISPLAY_NAME      0x01
#define CERT_OID_PROPERTY_CPS               0x02
#define CERT_OID_PROPERTY_TYPE              0x03

//
// CAOIDGetProperty
// Get a property on an OID.  
//
// pwszOID              - The OID whose value is queried
// dwProperty           - The property name.  Can be one of the following:
//                        CERT_OID_PROPERTY_DISPLAY_NAME
//                        CERT_OID_PROPERTY_CPS
//                        CERT_OID_PROPERTY_TYPE
//
// pPropValue           - The value of the property.
//                        If dwProperty is CERT_OID_PROPERTY_DISPLAY_NAME,
//                        pPropValue is LPWSTR *.  
//                        if dwProperty is CERT_OID_PROPERTY_CPS, pPropValue is
//			  LPWSTR *. 
//
//                        Free the above properties via CAOIDFreeProperty().
//
//                        If dwProperty is CERT_OID_PROPERTY_TYPE, pPropValue
//			  is DWORD *. 
//
// Returns S_OK if successful.
//
CERTCLIAPI
HRESULT
WINAPI
CAOIDGetProperty(
    IN  LPCWSTR pwszOID,
    IN  DWORD   dwProperty,
    OUT LPVOID  pPropValue);


//
// CAOIDFreeProperty
// Free a property returned from CAOIDGetProperty  
//
// pPropValue           - The value of the property.
//
// Returns S_OK if successful.
//

CERTCLIAPI
HRESULT
WINAPI
CAOIDFreeProperty(
    IN LPVOID  pPropValue);

//
// CAOIDGetLdapURL
// 
// Return the LDAP URL for OID repository.  In the format of 
// LDAP:///DN of the Repository/all attributes?one?filter.  The filter
// is determined by dwType.
//
// dwType               - Can be one of the following:
//                        CERT_OID_TYPE_TEMPLATE			
//                        CERT_OID_TYPE_ISSUER_POLICY
//                        CERT_OID_TYPE_APPLICATION_POLICY
//                        CERT_OID_TYPE_ALL
//
// dwFlag               - Reserved.  Must be 0.
//
// ppwszURL             - Return the URL.  Free memory via CAOIDFreeLdapURL.
//
// Returns S_OK if successful.
//
CERTCLIAPI
HRESULT
WINAPI
CAOIDGetLdapURL(
    IN  DWORD   dwType,
    IN  DWORD   dwFlag,
    OUT LPWSTR  *ppwszURL);

#define CERT_OID_TYPE_ALL           0x0

//
// CAOIDFreeLDAPURL
// Free the URL returned from CAOIDGetLdapURL
//
// pwszURL      - The URL returned from CAOIDGetLdapURL
//
// Returns S_OK if successful.
//
CERTCLIAPI
HRESULT
WINAPI
CAOIDFreeLdapURL(
    IN LPCWSTR      pwszURL);


//the LDAP properties for OID class
#define OID_PROP_TYPE                   L"flags"
#define OID_PROP_OID                    L"msPKI-Cert-Template-OID"
#define OID_PROP_DISPLAY_NAME           L"displayName"
#define OID_PROP_CPS                    L"msPKI-OID-CPS"
#define OID_PROP_LOCALIZED_NAME         L"msPKI-OIDLocalizedName"


//*****************************************************************************
//
//  Cert Type Change Query APIS
//
//*****************************************************************************
//
// CACertTypeRegisterQuery
// 
//      Regiser the calling thread to query if any modification has happened
//  to cert type information on the directory
//
//
// dwFlag               - Reserved.  Must be 0.
//
// pvldap               - The LDAP handle to the directory (LDAP *).  Optional input.
//                        If pvldap is not NULL, then the caller has to call
//                        CACertTypeUnregisterQuery before unbind the pldap.
//
// pHCertTypeQuery      - Receive the HCERTTYPEQUERY handle upon success.
//
// Returns S_OK if successful.
//
//
CERTCLIAPI
HRESULT
WINAPI
CACertTypeRegisterQuery(
    IN	DWORD               dwFlag,
    IN  LPVOID              pvldap,
    OUT HCERTTYPEQUERY      *phCertTypeQuery);



//
// CACertTypeQuery
// 
//      Returns a change sequence number which is incremented by 1 whenever
// cert type information on the directory is changed.     
//
// hCertTypeQuery               -  The hCertTypeQuery returned from previous
//                                  CACertTypeRegisterQuery  calls.
//
// *pdwChangeSequence           -  Returns a DWORD, which is incremented by 1 
//                                  whenever any changes has happened to cert type 
//                                  information on the directory since the last 
//                                  call to CACertTypeRegisterQuery or CACertTypeQuery.
//
//
//
// Returns S_OK if successful.
//
//
CERTCLIAPI
HRESULT
WINAPI
CACertTypeQuery(
    IN	HCERTTYPEQUERY  hCertTypeQuery,
    OUT DWORD           *pdwChangeSequence);



//
// CACertTypeUnregisterQuery
// 
//      Unregister the calling thread to query if any modification has happened
//  to cert type information on the directory
//
//
// hCertTypeQuery               -  The hCertTypeQuery returned from previous
//                                  CACertTypeRegisterQuery calls.
//
// Returns S_OK if successful.
//
//
CERTCLIAPI
HRESULT
WINAPI
CACertTypeUnregisterQuery(
    IN	HCERTTYPEQUERY  hCertTypeQuery);


//*****************************************************************************
//
//  Autoenrollment APIs
//
//*****************************************************************************

//
// CACreateLocalAutoEnrollmentObject
// Create an auto-enrollment object on the local machine.
//
// pwszCertType - The name of the certificate type for which to create the
//		  auto-enrollment object
//
// awszCAs      - The list of CAs to add to the auto-enrollment object with the
//		  last entry in the list being NULL.  If the list is NULL or
//		  empty, then it create an auto-enrollment object which
//		  instructs the system to enroll for a cert at any CA
//		  supporting the requested certificate type.
//
// pSignerInfo  - not used, must be NULL.
//
// dwFlags      - can be CERT_SYSTEM_STORE_CURRENT_USER or
//		  CERT_SYSTEM_STORE_LOCAL_MACHINE, indicating auto-enrollment
//		  store in which the auto-enrollment object is created.
//
// Return:      S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CACreateLocalAutoEnrollmentObject(
    IN LPCWSTR                              pwszCertType,
    IN OPTIONAL WCHAR **                    awszCAs,
    IN OPTIONAL PCMSG_SIGNED_ENCODE_INFO    pSignerInfo,
    IN DWORD                                dwFlags);

//
// CADeleteLocalAutoEnrollmentObject
// Delete an auto-enrollment object on the local machine.
//
// pwszCertType - The name of the certificate type for which to delete the
//		  auto-enrollment object
//
// awszCAs      - not used. must be NULL.  All callers to CACreateLocalAutoEnrollmentObject
//                have supplied NULL.
//
// pSignerInfo  - not used, must be NULL.
//
// dwFlags      - can be CERT_SYSTEM_STORE_CURRENT_USER or
//		  CERT_SYSTEM_STORE_LOCAL_MACHINE, indicating auto-enrollment
//		  store in which the auto-enrollment object is deleted.
//
// Return:      S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CADeleteLocalAutoEnrollmentObject(
    IN LPCWSTR                              pwszCertType,
    IN OPTIONAL WCHAR **                    awszCAs,
    IN OPTIONAL PCMSG_SIGNED_ENCODE_INFO    pSignerInfo,
    IN DWORD                                dwFlags);


//
// CACreateAutoEnrollmentObjectEx
// Create an auto-enrollment object in the indicated store.
//
// pwszCertType - The name of the certificate type for which to create the
//		  auto-enrollment object
//
// pwszObjectID - An identifying string for this autoenrollment object.  NULL
//		  may be passed if this object is simply to be identified by
//		  its certificate template.  An autoenrollment object is
//		  identified by a combination of its object id and its cert
//		  type name.
//
// awszCAs      - The list of CAs to add to the auto-enrollment object, with
//		  the last entry in the list being NULL.  If the list is NULL
//		  or empty, then it create an auto-enrollment object which
//		  instructs the system to enroll for a cert at any CA
//		  supporting the requested certificate type.
//
// pSignerInfo  - not used, must be NULL.
//
// StoreProvider - see CertOpenStore
//
// dwFlags      - see CertOpenStore
//
// pvPara       - see CertOpenStore
//
// Return:      S_OK on success.
//
//

CERTCLIAPI
HRESULT
WINAPI
CACreateAutoEnrollmentObjectEx(
    IN LPCWSTR                     pwszCertType,
    IN LPCWSTR                     wszObjectID,
    IN WCHAR **                    awszCAs,
    IN PCMSG_SIGNED_ENCODE_INFO    pSignerInfo,
    IN LPCSTR                      StoreProvider,
    IN DWORD                       dwFlags,
    IN const void *                pvPara);


typedef struct _CERTSERVERENROLL
{
    DWORD   Disposition;
    HRESULT hrLastStatus;
    DWORD   RequestId;
    BYTE   *pbCert;
    DWORD   cbCert;
    BYTE   *pbCertChain;
    DWORD   cbCertChain;
    WCHAR  *pwszDispositionMessage;
} CERTSERVERENROLL;


//*****************************************************************************
//
// Cert Server RPC interfaces:
//
//*****************************************************************************

CERTCLIAPI
HRESULT
WINAPI
CertServerSubmitRequest(
    IN DWORD Flags,
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    OPTIONAL IN WCHAR const *pwszRequestAttributes,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszAuthority,
    OUT CERTSERVERENROLL **ppcsEnroll); // free via CertServerFreeMemory

CERTCLIAPI
HRESULT
WINAPI
CertServerRetrievePending(
    IN DWORD RequestId,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszAuthority,
    OUT CERTSERVERENROLL **ppcsEnroll); // free via CertServerFreeMemory

CERTCLIAPI
VOID
WINAPI
CertServerFreeMemory(
    IN VOID *pv);


enum ENUM_PERIOD
{
    ENUM_PERIOD_INVALID = -1,
    ENUM_PERIOD_SECONDS = 0,
    ENUM_PERIOD_MINUTES,
    ENUM_PERIOD_HOURS,
    ENUM_PERIOD_DAYS,
    ENUM_PERIOD_WEEKS,
    ENUM_PERIOD_MONTHS,
    ENUM_PERIOD_YEARS
};

typedef struct _PERIODUNITS
{
    LONG             lCount;
    enum ENUM_PERIOD enumPeriod;
} PERIODUNITS;


HRESULT
caTranslateFileTimePeriodToPeriodUnits(
    IN FILETIME const *pftGMT,
    IN BOOL fExact,
    OUT DWORD *pcPeriodUnits,
    OUT PERIODUNITS **prgPeriodUnits);


#ifdef __cplusplus
}
#endif
#endif //__CERTCA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\certlib.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certlib.h
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#ifndef __CERTLIB_H__
#define __CERTLIB_H__

#include <wintrust.h>	// for spc_xxxx
#include <cryptui.h>	// for CRYPTUI_CA_CONTEXT
#include <setupapi.h>	// for HINF
#include <stdio.h>	// for wprintf -- include before cs.h
#include "cs.h"         // for CSASSERT
#include <xelib.h>	// for CERTLIB_ALLOCATOR
#include "csregstr.h"	// for ENUM_CATYPES
#include "csfile.h"	// for __dwFILE__
#include "csauto.h"     // self cleaning pointers

#ifndef CERTREQUEST_CLIENT_CERTREQ	// moved to xelib.h
#define SECURITY_WIN32
#include <security.h>	// for EXTENDED_NAME_FORMAT
#define DWORDROUND(cb)	(((cb) + (sizeof(DWORD) - 1)) & ~(sizeof(DWORD) - 1))
#define POINTERROUND(cb) (((cb) + (sizeof(VOID *) - 1)) & ~(sizeof(VOID *) - 1))
#endif

#define myCASIGN_KEY_USAGE \
	    (CERT_KEY_CERT_SIGN_KEY_USAGE | CERT_DIGITAL_SIGNATURE_KEY_USAGE | \
	     CERT_CRL_SIGN_KEY_USAGE)

// "flags" property values for DS CA object
// CN=CAName,CN=Certification Authorities
#define CA_SERVER_TYPE_UNKNOWN          0x0
#define CA_SERVER_TYPE_SERVER           0x1
#define CA_SERVER_TYPE_ADVANCEDSERVER   0x2

#define _16BITMASK			((1 << 16) - 1)
#define MAKECANAMEID(iCert, iKey)	(((iKey) << 16) | (iCert))
#define CANAMEIDTOIKEY(NameId)		((NameId) >> 16)
#define CANAMEIDTOICERT(NameId)		(_16BITMASK & (NameId))

#define MAKECROSSCAVERSION(iSource, iTarget)	(((iSource) << 16) | (iTarget))
#define CROSSCAVERSIONTOSOURCE(CrossCAVersion)	((CrossCAVersion) >> 16)
#define CROSSCAVERSIONTOTARGET(CrossCAVersion)	(_16BITMASK & (CrossCAVersion))


#define cwcHRESULTSTRING	40
#define cwcDWORDSPRINTF		(1 + 10 + 1)	// DWORD "%d" w/sign & '\0'
#define cwcULONG_INTEGERSPRINTF	2*cwcDWORDSPRINTF

#define GETCERT_CAXCHGCERT	   TRUE
#define GETCERT_CASIGCERT	   FALSE
#define GETCERT_CHAIN		   0x80000000	// internal use only
#define GETCERT_CRLS		   0x00800000	// internal use only

#define GETCERT_FILEVERSION	   0x66696c65	// "file"
#define GETCERT_PRODUCTVERSION	   0x70726f64	// "prod"
#define GETCERT_POLICYVERSION	   0x706f6c69	// "poli"
#define GETCERT_CANAME		   0x6e616d65	// "name"

#define GETCERT_SANITIZEDCANAME	   0x73616e69	// "sani"
#define GETCERT_SHAREDFOLDER	   0x73686172	// "shar"
#define GETCERT_ERRORTEXT1	   0x65727231	// "err1"
#define GETCERT_ERRORTEXT2	   0x65727232	// "err2"

#define GETCERT_CATYPE		   0x74797065	// "type"
#define GETCERT_CAINFO		   0x696e666f	// "info"
#define GETCERT_PARENTCONFIG	   0x70617265	// "pare"

#define GETCERT_CURRENTCRL	   0x6363726c	// "ccrl"
#define GETCERT_CACERTBYINDEX	   0x63740000	// "ct??" + 0 based index
#define GETCERT_CACERTSTATEBYINDEX 0x73740000	// "st??" + 0 based index
#define GETCERT_CRLBYINDEX	   0x636c0000	// "cl??" + 0 based index
#define GETCERT_CRLSTATEBYINDEX	   0x736c0000	// "sl??" + 0 based index
#define GETCERT_EXITVERSIONBYINDEX 0x65780000	// "ex??" + 0 based index
#define GETCERT_BYINDEXMASK	   0x7f7f0000	// mask for fetch by index
#define GETCERT_INDEXVALUEMASK	   0x0000ffff	// mask for index extraction

#define GETCERT_VERSIONMASK	   0x7f7f7f7f	// mask for above

#define CSREG_UPGRADE    0x00000001
#define CSREG_APPEND     0x00000002
#define CSREG_REPLACE    0x00000004
#define CSREG_MERGE      0x00000008

#define wszCERTENROLLSHARENAME	L"CertEnroll"
#define wszCERTENROLLSHAREPATH	L"CertSrv\\CertEnroll"

#define wszCERTCONFIGSHARENAME  L"CertConfig"

#define CB_IPV4ADDRESS	4
#define CB_IPV6ADDRESS	16

// Constants chosen to avoid DWORD overflow:

#define CVT_WEEKS	(7 * CVT_DAYS)
#define CVT_DAYS	(24 * CVT_HOURS)
#define CVT_HOURS	(60 * CVT_MINUTES)
#define CVT_MINUTES	(60 * CVT_SECONDS)
#define CVT_SECONDS	(1)
#define CVT_BASE	(1000 * 1000 * 10)


#define chLBRACKET	'['
#define chRBRACKET	']'
#define szLBRACKET	"["
#define szRBRACKET	"]"
#define wcLBRACKET	L'['
#define wcRBRACKET	L']'
#define wszLBRACKET	L"["
#define wszRBRACKET	L"]"

#define chLBRACE	'{'
#define chRBRACE	'}'
#define szLBRACE	"{"
#define szRBRACE	"}"
#define wcLBRACE	L'{'
#define wcRBRACE	L'}'
#define wszLBRACE	L"{"
#define wszRBRACE	L"}"

#define chLPAREN	'('
#define chRPAREN	')'
#define szLPAREN	"("
#define szRPAREN	")"
#define wcLPAREN	L'('
#define wcRPAREN	L')'
#define wszLPAREN	L"("
#define wszRPAREN	L")"

#define wcENDASH	(WCHAR) 0x2013
#define wcEMDASH	(WCHAR) 0x2014
#define wcMINUSSIGN	(WCHAR) 0x2212

#define myIsMinusSign(wc) \
  (L'-' == (wc) || wcENDASH == (wc) || wcEMDASH == (wc) || wcMINUSSIGN == (wc))

#define myIsSwitchChar(wc)	(L'/' == (wc) || myIsMinusSign(wc))

BOOL
myIsMinusSignString(
    IN WCHAR const *pwsz);


typedef struct _CSURLTEMPLATE
{
    DWORD  Flags;
    WCHAR *pwszURL;
} CSURLTEMPLATE;


WCHAR const *
myHResultToString(
    IN OUT WCHAR *awchr,
    IN HRESULT hr);

WCHAR const *
myHResultToStringRaw(
    IN OUT WCHAR *awchr,
    IN HRESULT hr);

WCHAR const *
myGetErrorMessageText(
    IN HRESULT hr,
    IN BOOL fHResultString);

WCHAR const *
myGetErrorMessageText1(
    IN HRESULT hr,
    IN BOOL fHResultString,
    IN OPTIONAL WCHAR const *pwszInsertionText);

WCHAR const *
myGetErrorMessageTextEx(
    IN HRESULT hr,
    IN BOOL fHResultString,
    IN OPTIONAL WCHAR const * const *papwszInsertionText);

HRESULT
myJetHResult(IN HRESULT hr);

BOOL
myIsDelayLoadHResult(IN HRESULT hr);

BOOL
myShouldPrintError(
    IN HRESULT hr,
    IN HRESULT hrquiet);

HRESULT
myGetLong(
    IN WCHAR const *pwszIn,
    OUT LONG *pLong);

HRESULT
myGetSignedLong(
    IN WCHAR const *pwszIn,
    OUT LONG *pLong);

// Case-ignore compare a dynamic string (possibly supplied by the user)
// against a static string.  WSZARRAYSIZE will assert the static string
// parameter is indeed static.  mylstrcmpiS wil assert the static string
// contains a strict subset of 7-bit ASCII characters.

#if DBG_CERTSRV
# define LSTRCMPIS(pwszDynamic, pwszStatic) \
    (WSZARRAYSIZE(pwszStatic), \
     mylstrcmpiS((pwszDynamic), (pwszStatic)))
#else
# define LSTRCMPIS(pwszDynamic, pwszStatic) \
    mylstrcmpiS((pwszDynamic), (pwszStatic))
#endif //DBG_CERTSRV


// Locale-independent case-ignore string compare
// asserts the static string contains a strict subset of 7-bit ASCII characters.

int
mylstrcmpiS(
    IN WCHAR const *pwszDynamic,
    IN WCHAR const *pwszStatic);

// Locale-independent case-ignore string compare

int
mylstrcmpiL(
    IN WCHAR const *pwsz1,
    IN WCHAR const *pwsz2);


#define CBMAX_CRYPT_HASH_LEN	20

BOOL
myCryptSignMessage(
    IN CRYPT_SIGN_MESSAGE_PARA const *pcsmp,
    IN BYTE const *pbToBeSigned,
    IN DWORD cbToBeSigned,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbSignedBlob,   // CoTaskMem*
    OUT DWORD *pcbSignedBlob);


HRESULT
myCryptMsgGetParam(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT VOID **ppvData,
    OUT DWORD *pcbData);

BOOL
myEncodeCert(
    IN DWORD dwEncodingType,
    IN CERT_SIGNED_CONTENT_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

BOOL
myEncodeName(
    IN DWORD dwEncodingType,
    IN CERT_NAME_INFO const *pInfo,
    IN DWORD dwFlags,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

BOOL
myEncodeKeyAttributes(
    IN DWORD dwEncodingType,
    IN CERT_KEY_ATTRIBUTES_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

BOOL
myEncodeKeyUsage(
    IN DWORD dwEncodingType,
    IN CRYPT_BIT_BLOB const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

BOOL
myEncodeKeyAuthority(
    IN DWORD dwEncodingType,
    IN CERT_AUTHORITY_KEY_ID_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

BOOL
myEncodeKeyAuthority2(
    IN DWORD dwEncodingType,
    IN CERT_AUTHORITY_KEY_ID2_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

BOOL
myEncodeToBeSigned(
    DWORD dwEncodingType,
    CERT_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded);

BOOL
myDecodeName(
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_NAME_INFO **ppNameInfo,
    OUT DWORD *pcbNameInfo);


HRESULT
myDecodeCSPProviderAttribute(
    IN BYTE const *pbCSPEncoded,
    IN DWORD cbCSPEncoded,
    OUT CRYPT_CSP_PROVIDER **ppccp);

BOOL
myDecodeKeyGenRequest(
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_KEYGEN_REQUEST_INFO **ppKeyGenRequest,
    OUT DWORD *pcbKeyGenRequest);

BOOL
myDecodeExtensions(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_EXTENSIONS **ppInfo,
    OUT DWORD *pcbInfo);

BOOL
myDecodeKeyAuthority(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_AUTHORITY_KEY_ID_INFO const **ppInfo,
    OUT DWORD *pcbInfo);

BOOL
myDecodeKeyAuthority2(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_AUTHORITY_KEY_ID2_INFO const **ppInfo,
    OUT DWORD *pcbInfo);

BOOL
myCertGetCertificateContextProperty(
    IN CERT_CONTEXT const *pCertContext,
    IN DWORD dwPropId,
    IN CERTLIB_ALLOCATOR allocType,
    OUT VOID **ppvData,
    OUT DWORD *pcbData);

HRESULT
myCryptEncrypt(
    IN HCRYPTKEY hKey,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbEncrypted,
    OUT DWORD *pcbEncrypted);

HRESULT
myCryptDecrypt(
    IN HCRYPTKEY hKey,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbDecrypted,
    OUT DWORD *pcbDecrypted);

HRESULT
myCryptEncryptMessage(
    IN ALG_ID algId,
    IN DWORD cCertRecipient,
    IN CERT_CONTEXT const **rgCertRecipient,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN OPTIONAL HCRYPTPROV hCryptProv,
    OUT BYTE **ppbEncrypted,
    OUT DWORD *pcbEncrypted);

HRESULT
myCryptDecryptMessage(
    IN HCERTSTORE hStoreCA,
    IN BYTE const *pbEncrypted,
    IN DWORD cbEncrypted,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbDecrypted,
    OUT DWORD *pcbDecrypted);

HRESULT
myGetInnerPKCS10(
    IN HCRYPTMSG hMsg,
    IN char const *pszInnerContentObjId,
    OUT CERT_REQUEST_INFO **ppRequest);

BOOL
myDecodeNameValuePair(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CRYPT_ENROLLMENT_NAME_VALUE_PAIR **ppInfo,
    OUT DWORD *pcbInfo);

HRESULT
myEncodeExtension(
    IN DWORD Flags,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut);

HRESULT
myDecodeExtension(
    IN DWORD Flags,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut);

HRESULT
myGenerateKeys(
    IN WCHAR const *pwszContainer,
    OPTIONAL IN WCHAR const *pwszProvName,
    IN DWORD dwFlags,
    IN BOOL fMachineKeySet,
    IN DWORD dwKeySpec,
    IN DWORD dwProvType,
    IN DWORD dwKeySize,
    OUT HCRYPTPROV *phProv);

HRESULT
myCryptExportKey(
    IN HCRYPTKEY hKey,
    IN HCRYPTKEY hKeyExp,
    IN DWORD dwBlobType,
    IN DWORD dwFlags,
    OUT BYTE **ppbKey,
    OUT DWORD *pcbKey);

HRESULT
mySetEnablePrivateKeyUsageCount(
    IN HCRYPTPROV hProv,
    IN BOOL fEnabled);

HRESULT
myGetSigningKeyUsageCount(
    IN HCRYPTPROV hProv,
    OUT BOOL *pfSupported,
    OUT BOOL *pfEnabled,
    OPTIONAL OUT ULARGE_INTEGER *puliCount);

HRESULT
myIsDeltaCRL(
    IN CRL_CONTEXT const *pCRL,
    OUT BOOL *pfIsDeltaCRL);

HCERTSTORE
myUrlCertOpenStore(
    IN DWORD dwFlags,
    IN WCHAR const *pwszURL);

HRESULT
myCertGetNameString(
    IN CERT_CONTEXT const *pcc,
    IN DWORD dwType,
    OUT WCHAR **ppwszSimpleName);

#define CA_VERIFY_FLAGS_ALLOW_UNTRUSTED_ROOT	0x00000001
#define CA_VERIFY_FLAGS_IGNORE_OFFLINE		0x00000002
#define CA_VERIFY_FLAGS_NO_REVOCATION		0x00000004
#define CA_VERIFY_FLAGS_FULL_CHAIN_REVOCATION	0x00000008
#define CA_VERIFY_FLAGS_NT_AUTH			0x00000010
#define CA_VERIFY_FLAGS_IGNORE_INVALID_POLICIES	0x00000020
#define CA_VERIFY_FLAGS_IGNORE_NOREVCHECK	0x00000040

#define CA_VERIFY_FLAGS_DUMP_CHAIN		0x40000000
#define CA_VERIFY_FLAGS_SAVE_CHAIN		0x80000000

typedef VOID (FNSIMPLECHAINELEMENTCALLBACK)(
    IN DWORD dwFlags,
    IN DWORD iElement,
    IN CERT_SIMPLE_CHAIN const *pChain);

HRESULT
myVerifyCertContext(
    IN CERT_CONTEXT const *pCert,
    IN DWORD dwFlags,
    IN DWORD cUsageOids,
    OPTIONAL IN CHAR const * const *apszUsageOids,
    OPTIONAL IN HCERTCHAINENGINE hChainEngine,
    OPTIONAL IN HCERTSTORE hAdditionalStore,
    OPTIONAL OUT WCHAR **ppwszMissingIssuer);

HRESULT
myVerifyCertContextEx(
    IN CERT_CONTEXT const *pCert,
    IN DWORD dwFlags,
    IN DWORD dwmsTimeout,
    IN DWORD cUsageOids,
    OPTIONAL IN CHAR const * const *apszUsageOids,
    IN DWORD cIssuanceOids,
    OPTIONAL IN CHAR const * const *apszIssuanceOids,
    OPTIONAL IN HCERTCHAINENGINE hChainEngine,
    OPTIONAL IN FILETIME const *pft,
    OPTIONAL IN HCERTSTORE hAdditionalStore,
    OPTIONAL IN FNSIMPLECHAINELEMENTCALLBACK *pfnCallback,
    OPTIONAL OUT WCHAR **ppwszMissingIssuer,
    OPTIONAL OUT WCHAR **ppwszzIssuancePolicies,
    OPTIONAL OUT WCHAR **ppwszzApplicationPolicies,
    OPTIONAL OUT WCHAR **ppwszExtendedErrorInfo,
    OPTIONAL OUT CERT_TRUST_STATUS *pTrustStatus);

VOID
myDumpChain(
    IN HRESULT hrVerify,
    IN DWORD dwFlags,
    IN CERT_CONTEXT const *pCert,
    OPTIONAL IN FNSIMPLECHAINELEMENTCALLBACK *pfnCallback,
    OPTIONAL IN WCHAR const *pwszMissingIssuer,
    IN CERT_CHAIN_CONTEXT const *pChainContext);

HRESULT
myVerifyKRACertContext(
    IN CERT_CONTEXT const *pCert,
    IN DWORD dwFlags);

DWORD
myCRLNumber(
    IN CRL_CONTEXT const *pCRL);

HRESULT
myCertStrToName(
    IN DWORD dwCertEncodingType,
    IN LPCWSTR pszX500,
    IN DWORD dwStrType,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded,
    OUT OPTIONAL LPCWSTR *ppszError);

HRESULT
myCertNameToStr(
    IN DWORD dwCertEncodingType,
    IN CERT_NAME_BLOB const *pName,
    IN DWORD dwStrType,
    OUT WCHAR **ppwszName);

HRESULT
myCryptStringToBinaryA(
    IN     LPCSTR    pszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    OUT    BYTE    **ppbBinary,
    OUT    DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    // OPTIONAL
    OUT    DWORD    *pdwFlags);  // OPTIONAL

HRESULT
myCryptStringToBinary(
    IN     LPCWSTR   pwszString,
    IN     DWORD     cwcString,
    IN     DWORD     dwFlags,
    OUT    BYTE    **ppbBinary,
    OUT    DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    // OPTIONAL
    OUT    DWORD    *pdwFlags);  // OPTIONAL

HRESULT
myCryptBinaryToStringA(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    OUT    LPSTR       *ppszString);

HRESULT
myCryptBinaryToString(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    OUT    LPWSTR      *ppwszString);

HRESULT
myIsFirstSigner(
    IN CERT_NAME_BLOB const *pNameBlob,
    OUT BOOL *pfDummy);

HRESULT
myCopyKeys(
    IN CRYPT_KEY_PROV_INFO const *pkpi,
    IN WCHAR const *pwszOldContainer,
    IN WCHAR const *pwszNewContainer,
    IN WCHAR const *pwszNewCSP,
    IN BOOL fOldUserKey,
    IN BOOL fNewUserKey,
    IN BOOL fNewProtect,
    IN BOOL fForceOverWrite);

HRESULT
mySaveChainAndKeys(
    IN CERT_SIMPLE_CHAIN const *pSimpleChain,
    IN WCHAR const *pwszStore,
    IN DWORD dwStoreFlags,
    IN CRYPT_KEY_PROV_INFO const *pkpi,
    OPTIONAL OUT CERT_CONTEXT const **ppCert);

HCERTSTORE
myPFXImportCertStore(
    IN CRYPT_DATA_BLOB *ppfx,
    OPTIONAL IN WCHAR const *pwszPassword,
    IN DWORD dwFlags);

HRESULT
myPFXExportCertStore(
    IN HCERTSTORE hStore,
    OUT CRYPT_DATA_BLOB *ppfx,
    IN WCHAR const *pwszPassword,
    IN BOOL fEnhancedStrength,
    IN DWORD dwFlags);

HRESULT
myAddChainToMemoryStore(
    IN HCERTSTORE hMemoryStore,
    IN CERT_CONTEXT const *pCertContext,
    IN DWORD dwmsTimeout);


typedef struct _RESTORECHAIN
{
    CERT_CHAIN_CONTEXT const *pChain;
    DWORD		      NameId;
} RESTORECHAIN;

HRESULT
myGetChainArrayFromStore(
    IN HCERTSTORE hStore,
    IN BOOL fCAChain,
    IN BOOL fUserStore,
    OPTIONAL OUT WCHAR **ppwszCommonName,
    IN OUT DWORD *pcRestoreChain,
    OPTIONAL OUT RESTORECHAIN *paRestoreChain);

#ifndef CERTREQUEST_CLIENT_CERTREQ	// moved to xelib.h
HRESULT
myGetUserNameEx(
    IN EXTENDED_NAME_FORMAT NameFormat,
    OUT WCHAR **ppwszUserName);
#endif

HRESULT
myGetComputerObjectName(
    IN EXTENDED_NAME_FORMAT NameFormat,
    OUT WCHAR **ppwszDnsName);

HRESULT
myGetComputerNameEx(
    IN COMPUTER_NAME_FORMAT NameFormat,
    OUT WCHAR **ppwszName);

HRESULT
myGetComputerNames(
    OUT WCHAR **ppwszDnsName,
    OUT WCHAR **ppwszOldName);

#ifndef CERTREQUEST_CLIENT_CERTREQ	// moved to xelib.h
HRESULT
myGetMachineDnsName(
    OUT WCHAR **ppwszDnsName);
#endif

LANGID
mySetThreadUILanguage(
    IN WORD wReserved);

BOOL
myConvertStringSecurityDescriptorToSecurityDescriptor(
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor,
    OUT PULONG SecurityDescriptorSize OPTIONAL);

BOOL
myConvertSidToStringSid(
    IN  PSID    Sid,
    OUT LPWSTR *StringSid);

BOOL
myConvertStringSidToSid(
    IN LPCWSTR   StringSid,
    OUT PSID   *Sid);


#define DH_INDENTMASK	0x000000ff
#define DH_MULTIADDRESS	0x00000100	// add address to multi-line output only
#define DH_NOADDRESS	0x00000200
#define DH_NOASCIIHEX	0x00000400
#define DH_NOTABPREFIX	0x00000800	// double space after addr if displayed
#define DH_PRIVATEDATA	0x00001000	// private data -- don't write to log

VOID
DumpHex(
    IN DWORD Flags,
    IN BYTE const *pb,
    IN ULONG cb);

DWORD
myGetDisplayLength(
    IN WCHAR const *pwsz);

LONG
myConsolePrintString(
    IN DWORD ccolMin,
    IN WCHAR const *pwszString);

BOOL
myConsolePrintfDisable(
    IN BOOL fDisable);

int __cdecl
myConsolePrintf(
    IN WCHAR const *pwszFmt,
    ...);

//+==============================
// Date/Time conversion routines:

HRESULT
myDateToFileTime(
    IN DATE const *pDate,
    OUT FILETIME *pft);

HRESULT
myFileTimeToDate(
    IN FILETIME const *pft,
    OUT DATE *pDate);

HRESULT
myFileTimePeriodToWszTimePeriod(
    IN FILETIME const *pftGMT,
    IN BOOL fExact,
    OUT WCHAR **ppwszTimePeriod);

HRESULT
myTranslateUnlocalizedPeriodString(
    IN enum ENUM_PERIOD enumPeriod,
    OUT WCHAR const **ppwszPeriodString);

HRESULT
myGMTFileTimeToWszLocalTime(
    IN FILETIME const *pftGMT,
    IN BOOL fSeconds,
    OUT WCHAR **ppwszLocalTime);

HRESULT
myFileTimeToWszTime(
    IN FILETIME const *pftGMT,
    IN BOOL fSeconds,
    OUT WCHAR **ppwszGMTTime);

HRESULT
myGMTDateToWszLocalTime(
    IN DATE const *pDateGMT,
    IN BOOL fSeconds,
    OUT WCHAR **ppwszLocalTime);

HRESULT
myWszLocalTimeToGMTDate(
    IN WCHAR const *pwszLocalTime,
    OUT DATE *pDateGMT);

HRESULT
myWszLocalTimeToGMTFileTime(
    IN WCHAR const *pwszLocalTime,
    OUT FILETIME *pftGMT);

HRESULT
mySystemTimeToGMTSystemTime(
    IN OUT SYSTEMTIME *pSys);


enum ENUM_FORCETELETEX
{
    ENUM_TELETEX_OFF = 0,
    ENUM_TELETEX_ON = 1,
    ENUM_TELETEX_AUTO = 2,
    ENUM_TELETEX_MASK = 0xf,
    ENUM_TELETEX_UTF8 = 0x10
};


typedef struct _LLFILETIME
{
    union {
	LONGLONG ll;
	FILETIME ft;
    };
} LLFILETIME;


__inline VOID
myAddToFileTime(
    IN OUT FILETIME *pft,
    IN LONGLONG ll)
{
    LLFILETIME llft;

    llft.ft = *pft;
    llft.ll += ll;
    *pft = llft.ft;
}


__inline LONGLONG
mySubtractFileTimes(
    IN FILETIME const *pft1,
    IN FILETIME const *pft2)
{
    LLFILETIME llft1;
    LLFILETIME llft2;

    llft1.ft = *pft1;
    llft2.ft = *pft2;
    return(llft1.ll - llft2.ll);
}


HRESULT
myMakeExprDate(
    IN OUT DATE *pDate,
    IN LONG lDelta,
    IN enum ENUM_PERIOD enumPeriod);

HRESULT
myTranslatePeriodUnits(
    IN WCHAR const *pwszPeriod,
    IN LONG lCount,
    OUT enum ENUM_PERIOD *penumPeriod,
    OUT LONG *plCount);

HRESULT
myDupString(
    IN WCHAR const *pwszIn,
    OUT WCHAR **ppwszOut);

HRESULT
myDupStringA(
    IN CHAR const *pszIn,
    OUT CHAR **ppszOut);

HRESULT
myUnmarshalVariant(
    IN DWORD PropType,
    IN DWORD cbValue,
    IN BYTE const *pbValue,
    OUT VARIANT *pvarValue);

HRESULT
myUnmarshalFormattedVariant(
    IN DWORD Flags,
    IN DWORD PropId,
    IN DWORD PropType,
    IN DWORD cbValue,
    IN BYTE const *pbValue,
    OUT VARIANT *pvarValue);

HRESULT
myMarshalVariant(
    IN VARIANT const *pvarPropertyValue,
    IN DWORD PropType,
    OUT DWORD *pcbprop,
    OUT BYTE **ppbprop);

// Output values for myCheck7f's *pState parameter:

#define CHECK7F_NONE			0x0000
#define CHECK7F_OTHER			0x0001
#define CHECK7F_ISSUER			0x0002
#define CHECK7F_ISSUER_RDN		0x0003
#define CHECK7F_ISSUER_RDN_ATTRIBUTE	0x0004
#define CHECK7F_ISSUER_RDN_STRING	0x0005
#define CHECK7F_SUBJECT			0x0006
#define CHECK7F_SUBJECT_RDN		0x0007
#define CHECK7F_SUBJECT_RDN_ATTRIBUTE	0x0008
#define CHECK7F_SUBJECT_RDN_STRING	0x0009
#define CHECK7F_EXTENSIONS		0x000a
#define CHECK7F_EXTENSION_ARRAY		0x000b
#define CHECK7F_EXTENSION		0x000c
#define CHECK7F_EXTENSION_VALUE		0x000d
#define CHECK7F_EXTENSION_VALUE_RAW	0x000e
#define CHECK7F_COUNT			0x000f

HRESULT
myCheck7f(
    IN const BYTE *pbCert,
    IN DWORD cbCert,
    IN BOOL fVerbose,
    OUT DWORD *pState,
    OPTIONAL OUT DWORD *pIndex1,
    OPTIONAL OUT DWORD *pIndex2,
    OPTIONAL IN OUT DWORD *pcwcField,
    OPTIONAL OUT WCHAR *pwszField,
    OPTIONAL IN OUT DWORD *pcwcObjectId,
    OPTIONAL OUT WCHAR *pwszObjectId,
    OPTIONAL OUT WCHAR const **ppwszObjectIdDescription); // Static: don't free!

HRESULT
myVerifyObjIdA(
    IN char const *pszObjId);

HRESULT
myVerifyObjId(
    IN WCHAR const *pwszObjId);

WCHAR const *
myGetOIDNameA(
    IN char const *pszObjId);

WCHAR const *
myGetOIDName(
    IN WCHAR const *pwszObjId);

BOOL
myIsCharSanitized(
    IN WCHAR wc);

HRESULT
mySanitizeName(
    IN WCHAR const *pwszName,
    OUT WCHAR **ppwszNameOut);

HRESULT
myRevertSanitizeName(
    IN WCHAR const *pwszName,
    OUT WCHAR **ppwszNameOut);

HRESULT
mySanitizedNameToDSName(
    IN WCHAR const *pwszName,
    OUT WCHAR **ppwszNameOut);

HRESULT
myAppendString(
    IN WCHAR const *pwszNew,
    OPTIONAL IN WCHAR const *pwszSeparator,
    IN OUT WCHAR **ppwszInOut);

HRESULT
myPrependString(
    IN WCHAR const *pwszNew,
    OPTIONAL IN WCHAR const *pwszSeparator,
    IN OUT WCHAR **ppwszInOut);

HRESULT
myGetCommonName(
    IN CERT_NAME_BLOB const *pNameBlob,
    IN BOOL fAllowDefault,
    OUT WCHAR **ppwszCN);

HRESULT
myGetRDNAttributeFromNameBlob(
    IN CERT_NAME_BLOB const *pNameBlob,
    IN LPCSTR pcszAttributeOID,
    OUT WCHAR **ppwszCN);

HRESULT
myDecodeCMCRegInfo(
    IN BYTE const *pbOctet,
    IN DWORD cbOctet,
    OUT WCHAR **ppwszOut);

HRESULT
mySplitConfigString(
    IN WCHAR const *pwszConfig,
    OUT WCHAR **ppwszServer,
    OUT WCHAR **ppwszAuthority);

HRESULT
myCLSIDToWsz(
    IN CLSID const *pclsid,
    OUT WCHAR **ppwsz);

VOID
myUuidCreate(
    OUT UUID *pUuid);

interface ICertAdminD2;
interface ICertRequestD2;

HRESULT
myOpenAdminDComConnection(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR const **ppwszAuthority,
    OPTIONAL IN OUT WCHAR **ppwszServerName,
    IN OUT DWORD *pdwServerVersion,
    IN OUT ICertAdminD2 **ppICertAdminD);

HRESULT
myOpenRequestDComConnection(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR const **ppwszAuthority,
    OPTIONAL IN OUT WCHAR **ppwszServerName,
    OPTIONAL OUT BOOL *pfNewConnection,
    IN OUT DWORD *pdwServerVersion,
    IN OUT ICertRequestD2 **ppICertRequestD);

VOID
myCloseDComConnection(
    OPTIONAL IN OUT IUnknown **ppUnknown,
    OPTIONAL IN OUT WCHAR **ppwszServerName);

HRESULT
myPingCertSrv(
    IN WCHAR const *pwszCAName,
    OPTIONAL IN WCHAR const *pwszMachineName,
    OPTIONAL OUT WCHAR **ppwszzCANames,
    OPTIONAL OUT WCHAR **ppwszSharedFolder,
    OPTIONAL OUT CAINFO **ppCAInfo,
    OPTIONAL OUT DWORD *pdwServerVersion,
    OPTIONAL OUT WCHAR **ppwszCADnsName);

DWORD
myGetCertNameProperty(
    IN BOOL fFirstRDN,	// else last matching RDN
    IN CERT_NAME_INFO const *pNameInfo,
    IN char const *pszObjId,
    OUT WCHAR const **ppwszName);

HRESULT
mySetCARegFileNameTemplate(
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszFileName);

HRESULT
myGetCARegFileNameTemplate(
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN DWORD iCRL,
    OUT WCHAR **ppwszFileName);


#define CSRH_CASIGCERT	0
#define CSRH_CAXCHGCERT	1
#define CSRH_CAKRACERT	2

HRESULT
mySetCARegHash(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index,
    IN CERT_CONTEXT const *pCert);

HRESULT
myGetCARegHash(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index,
    OUT BYTE **ppbHash,
    OUT DWORD *pcbHash);

HRESULT
myGetCARegHashCount(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    OUT DWORD *pCount);

HRESULT myShrinkCARegHash(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index);

HRESULT
myGetNameId(
    IN CERT_CONTEXT const *pCACert,
    OUT DWORD *pdwNameId);

HRESULT
myGetCRLNameId(
    IN CRL_CONTEXT const *pCRL,
    OUT DWORD *pdwNameId);

HRESULT
myFindCACertByHash(
    IN HCERTSTORE hStore,
    IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT OPTIONAL DWORD *pdwNameId,
    OUT CERT_CONTEXT const **ppCACert);

HRESULT
myFindCACertByHashIndex(
    IN HCERTSTORE hStore,
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index,
    OPTIONAL OUT DWORD *pdwNameId,
    OUT CERT_CONTEXT const **ppCACert);

BOOL
myAreBlobsSame(
    IN BYTE const *pbData1,
    IN DWORD cbData1,
    IN BYTE const *pbData2,
    IN DWORD cbData2);

BOOL
myAreSerialNumberBlobsSame(
    IN CRYPT_INTEGER_BLOB const *pBlob1,
    IN CRYPT_INTEGER_BLOB const *pBlob2);

BOOL
myAreCertContextBlobsSame(
    IN CERT_CONTEXT const *pcc1,
    IN CERT_CONTEXT const *pcc2);

VOID
myGenerateGuidSerialNumber(
    OUT GUID *pguidSerialNumber);


#define CSRF_INSTALLCACERT	0x00000000
#define CSRF_RENEWCACERT	0x00000001
#define CSRF_NEWKEYS		0x00000002
#define CSRF_UNATTENDED		0x40000000
#define CSRF_OVERWRITE		0x80000000

HRESULT
CertServerRequestCACertificateAndComplete(
    IN HINSTANCE             hInstance,
    IN HWND                  hwnd,
    IN DWORD                 Flags,
    IN WCHAR const          *pwszCAName,
    OPTIONAL IN WCHAR const *pwszParentMachine,
    OPTIONAL IN WCHAR const *pwszParentCA,
    OPTIONAL IN WCHAR const *pwszCAChainFile,
    OPTIONAL OUT WCHAR     **ppwszRequestFile);

HRESULT
myBuildPathAndExt(
    IN WCHAR const *pwszDir,
    IN WCHAR const *pwszFile,
    OPTIONAL IN WCHAR const *pwszExt,
    OUT WCHAR **ppwszPath);

HRESULT
myCreateBackupDir(
    IN WCHAR const *pwszDir,
    IN BOOL fForceOverWrite);

typedef struct _DBBACKUPPROGRESS
{
    DWORD dwDBPercentComplete;
    DWORD dwLogPercentComplete;
    DWORD dwTruncateLogPercentComplete;
} DBBACKUPPROGRESS;

#define CDBBACKUP_INCREMENTAL	0x00000001  // else full backup
#define CDBBACKUP_KEEPOLDLOGS	0x00000002  // else truncate logs
#define CDBBACKUP_OVERWRITE	    0x00000100  // for myBackupDB only
#define CDBBACKUP_VERIFYONLY	0x00000200  // for myBackupDB and myRestoreDB

#define CDBBACKUP_BACKUPVALID	(CDBBACKUP_INCREMENTAL | \
				 CDBBACKUP_KEEPOLDLOGS | \
				 CDBBACKUP_OVERWRITE | \
                 CDBBACKUP_VERIFYONLY)

#define CDBBACKUP_RESTOREVALID	(CDBBACKUP_INCREMENTAL | \
				 CDBBACKUP_KEEPOLDLOGS | \
				 CDBBACKUP_VERIFYONLY)

HRESULT
myBackupDB(
    OPTIONAL IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    IN WCHAR const *pwszBackupDir,
    OPTIONAL OUT DBBACKUPPROGRESS *pdbp);

HRESULT
myRestoreDB(
    IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    OPTIONAL IN WCHAR const *pwszBackupDir,
    OPTIONAL IN WCHAR const *pwszCheckPointFilePath,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN WCHAR const *pwszBackupLogPath,
    OPTIONAL OUT DBBACKUPPROGRESS *pdbp);

HRESULT
myDeleteDBFilesInDir(
    IN WCHAR const *pwszDir);

HRESULT
myDoDBFilesExist(
    IN WCHAR const *pwszSanitizedName,
    OUT BOOL *pfFilesExist,
    OPTIONAL OUT WCHAR **ppwszFileInUse);

HRESULT
myDoDBFilesExistInDir(
    IN WCHAR const *pwszDir,
    OUT BOOL *pfFilesExist,
    OPTIONAL OUT WCHAR **ppwszFileInUse);

HRESULT
myIsConfigLocal(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR **ppwszMachine,
    OUT BOOL *pfLocal);

HRESULT
myIsConfigLocal2(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszDnsName,
    IN WCHAR const *pwszOldName,
    OUT BOOL *pfLocal);

HRESULT
myGetConfig(
    IN DWORD dwUIFlag,
    OUT WCHAR **ppwszConfig);

HRESULT
myConvertLocalPathToUNC(
    OPTIONAL IN WCHAR const *pwszServer,
    IN WCHAR const *pwszFile,
    OUT WCHAR **ppwszFileUNC);

HRESULT
myConvertUNCPathToLocal(
    IN WCHAR const *pwszUNCPath,
    OUT WCHAR **ppwszLocalPath);

ULONG
myLocalPathwcslen(
    IN WCHAR const *pwsz);

VOID
myLocalPathwcscpy(
    OUT WCHAR *pwszOut,
    IN WCHAR const *pwszIn);

HRESULT
myCertServerExportPFX(
    IN WCHAR const *pwszCAName,
    IN WCHAR const *pwszBackupDir,
    IN WCHAR const *pwszPassword,
    IN BOOL fEnhancedStrength,
    IN BOOL fForceOverWrite,
    IN BOOL fMustExportPrivateKeys,
    IN DWORD dwmsTimeout,
    OPTIONAL OUT WCHAR **ppwszPFXFile);

HRESULT
myCertServerImportPFX(
    IN WCHAR const *pwszBackupDirOrPFXFile,
    IN WCHAR const *pwszPassword,
    IN BOOL fForceOverWrite,
    OPTIONAL OUT WCHAR **ppwszCommonName,
    OPTIONAL OUT WCHAR **ppwszPFXFile,
    OPTIONAL OUT CERT_CONTEXT const **ppSavedLeafCert);

HRESULT
myDeleteGuidKeys(
    IN HCERTSTORE hStorePFX,
    IN BOOL fMachineKeySet);

#define IsHrSkipPrivateKey(hresult) \
    (NTE_BAD_KEY_STATE == (hresult) || \
     CRYPT_E_NO_KEY_PROPERTY == (hresult) || \
     E_HANDLE == (hresult))

HRESULT
myCryptExportPrivateKey(
    IN HCRYPTKEY hKey,
    OUT BYTE **ppbKey,
    OUT DWORD *pcbKey);

HRESULT
myCertGetKeyProviderInfo(
    IN CERT_CONTEXT const *pCert,
    OUT CRYPT_KEY_PROV_INFO **ppkpi);

HRESULT
myRepairCertKeyProviderInfo(
    IN CERT_CONTEXT const *pCert,
    IN BOOL fForceMachineKey,
    OPTIONAL OUT CRYPT_KEY_PROV_INFO **ppkpi);

HRESULT
myVerifyPublicKey(
    IN OPTIONAL CERT_CONTEXT const *pCert,
    IN BOOL fV1Cert,
    IN OPTIONAL CRYPT_KEY_PROV_INFO const *pKeyProvInfo,
    IN OPTIONAL CERT_PUBLIC_KEY_INFO const *pSubjectPublicKeyInfo,
    OPTIONAL OUT BOOL *pfMatchingKey);

HRESULT
myVerifyPublicKeyFromHProv(
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec,
    IN OPTIONAL CERT_CONTEXT const *pCert,
    IN BOOL fV1Cert,
    IN OPTIONAL CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    OPTIONAL OUT BOOL *pfMatchingKey);

HRESULT
myValidateKeyBlob(
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN BOOL fV1Cert,
    OUT BOOL *pfSigningKey,
    OPTIONAL OUT CRYPT_KEY_PROV_INFO *pkpi);

DWORD
myASNGetDataIndex(
    IN BYTE bBERTag,
    IN DWORD iStart,
    IN BYTE const *pb,
    IN DWORD cb,
    OUT DWORD *pdwLen);

HRESULT
myCanonicalizePublicKey(
    IN BYTE const *pbKeyIn,
    IN DWORD cbKeyIn,
    OUT BYTE **ppbKeyOut,
    OUT DWORD *pcbKeyOut);

HRESULT
mySqueezePublicKey(
    IN BYTE const *pbKeyIn,
    IN DWORD cbKeyIn,
    OUT BYTE **ppbKeyOut,
    OUT DWORD *pcbKeyOut);

BOOL
myCertComparePublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN BOOL fV1Cert,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKey1,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKey2);

BOOL
myIsDirectory(
    IN WCHAR const *pwszDirectoryPath);

BOOL
myIsDirEmpty(
    IN WCHAR const *pwszDir);

HRESULT
myIsDirWriteable(
    IN WCHAR const *pwszPath,
    IN BOOL fFilePath);

BOOL
myIsFileInUse(
    IN WCHAR const *pwszFile);

__inline BOOL
myDoesFileExist(
    IN WCHAR const *pwszFile)
{
    DWORD dw;
    
    // Allow Ansi subdirectory builds, use GetFileAttributesW

    dw = GetFileAttributesW(pwszFile);
    return(MAXDWORD != dw && 0 == (FILE_ATTRIBUTE_DIRECTORY & dw));
}


WCHAR *
myLoadResourceStringNoCache(
    IN HINSTANCE hInstance,
    IN DWORD ResourceId);

WCHAR const *
myLoadResourceString(
    IN DWORD ResourceId);

VOID
myFreeResourceStrings(
    IN char const *pszModule);

HRESULT
myDoesDSExist(
    IN BOOL fRetry);

#define GCFPF_USEDS		0x00000001
#define GCFPF_SKIPLOCALCA	0x00000002

HRESULT
myGetConfigFromPicker(
    OPTIONAL IN HWND               hwndParent,
    OPTIONAL IN WCHAR const       *pwszPrompt,
    OPTIONAL IN WCHAR const       *pwszTitle,
    OPTIONAL IN WCHAR const       *pwszSharedFolder,
    IN  DWORD                      dwFlags,	// GCFPF_*
    IN  BOOL                       fCountOnly,
    OUT DWORD                     *pdwCACount,
    OUT CRYPTUI_CA_CONTEXT const **ppCAContext);

HRESULT
myGetConfigStringFromPicker(
    OPTIONAL IN HWND               hwndParent,
    OPTIONAL IN WCHAR const       *pwszPrompt,
    OPTIONAL IN WCHAR const       *pwszTitle,
    OPTIONAL IN WCHAR const       *pwszSharedFolder,
    IN  DWORD                      dwFlags,	// GCFPF_*
    OUT WCHAR                    **ppwszConfig);

HRESULT
myDeleteCertRegValueEx(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN BOOL                  fAbsolutePath);

HRESULT
myDeleteCertRegValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName);

HRESULT
myDeleteCertRegKeyEx(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN BOOL                  fConfigLevel);

HRESULT
myDeleteCertRegKey(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3);

HRESULT
myCreateCertRegKeyEx(
    IN BOOL                  fUpgrade,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3);

HRESULT
myCreateCertRegKey(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3);

HRESULT
mySetCertRegValue(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    IN DWORD const           dwValueType,
    IN BYTE const           *pbData,
    IN DWORD const           cbData,
    IN BOOL                  fAbsolutePath);

HRESULT
mySetCertRegValueEx(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN BOOL                  fConfigLevel,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN DWORD const           dwValueType,
    IN BYTE const           *pbData,
    IN DWORD const           cbData,
    IN BOOL                  fAbsolutePath);

HRESULT
myGetCertRegValue(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT BYTE               **ppbData,		// free using LocalFree
    OPTIONAL OUT DWORD      *pcbData,
    OPTIONAL OUT DWORD      *pValueType);

HRESULT
myGetCertRegValueEx(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN BOOL                  fConfigLevel,
    IN WCHAR const          *pwszValueName,
    OUT BYTE               **ppbData,
    OPTIONAL OUT DWORD      *pcbData,
    OPTIONAL OUT DWORD      *pValueType);

HRESULT
mySetCertRegMultiStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN WCHAR const          *pwszzValue);

HRESULT
myGetCertRegMultiStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    OUT WCHAR               **ppwszzValue);

HRESULT
mySetCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    IN WCHAR const          *pwszValue);

HRESULT
mySetCertRegStrValueEx(
    IN BOOL                  fUpgrade,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN WCHAR const          *pwszValue);

HRESULT
mySetCertRegMultiStrValueEx(
    IN DWORD                 dwFlags, //CSREG_UPGRADE | CSREG_APPEND
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN WCHAR const          *pwszzValue);

HRESULT
mySetAbsRegMultiStrValue(
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszValueName,
    IN WCHAR const *pwszzValue);

HRESULT
mySetAbsRegStrValue(
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszValueName,
    IN WCHAR const *pwszValue);

HRESULT
mySetCertRegDWValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    IN DWORD const           dwValue);

HRESULT
mySetCertRegDWValueEx(
    IN BOOL                  fUpgrade,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN DWORD const           dwValue);

HRESULT
myGetCertRegBinaryValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT BYTE               **ppbValue);

HRESULT
myGetCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT WCHAR               **ppwszValue);	// free using LocalFree


HRESULT
myGetCertRegDWValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT DWORD               *pdwValue);

HRESULT
myCopyCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszSrcName1,
    OPTIONAL IN WCHAR const *pwszSrcName2,
    OPTIONAL IN WCHAR const *pwszSrcName3,
    IN WCHAR const          *pwszSrcValueName,
    OPTIONAL IN WCHAR const *pwszDesName1,
    OPTIONAL IN WCHAR const *pwszDesName2,
    OPTIONAL IN WCHAR const *pwszDesName3,
    OPTIONAL IN WCHAR const *pwszDesValueName,
    IN BOOL                  fMultiStr);

HRESULT
myMoveCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszSrcName1,
    OPTIONAL IN WCHAR const *pwszSrcName2,
    OPTIONAL IN WCHAR const *pwszSrcName3,
    IN WCHAR const          *pwszSrcValueName,
    OPTIONAL IN WCHAR const *pwszDesName1,
    OPTIONAL IN WCHAR const *pwszDesName2,
    OPTIONAL IN WCHAR const *pwszDesName3,
    OPTIONAL IN WCHAR const *pwszDesValueName,
    IN BOOL                  fMultiStr);

HRESULT
myMoveOrCopyCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszSrcName1,
    OPTIONAL IN WCHAR const *pwszSrcName2,
    OPTIONAL IN WCHAR const *pwszSrcName3,
    IN WCHAR const          *pwszSrcValueName,
    OPTIONAL IN WCHAR const *pwszDesName1,
    OPTIONAL IN WCHAR const *pwszDesName2,
    OPTIONAL IN WCHAR const *pwszDesName3,
    OPTIONAL IN WCHAR const *pwszDesValueName,
    IN BOOL                  fMultiStr,
    IN BOOL                  fMove);

HRESULT
SetSetupStatus(
    OPTIONAL IN WCHAR const *pwszSanitizedCAName,
    IN const DWORD  dwFlag,
    IN const BOOL   fComplete);

HRESULT
GetSetupStatus(
    OPTIONAL IN WCHAR const *pwszSanitizedCAName,
    OUT DWORD *pdwStatus);

HRESULT
myGetCASerialNumber(
    IN  WCHAR const *pwszSanitizedCAName,
    OUT BYTE      **ppbSerialNumber,
    OUT DWORD      *cbSerialNumber);

HRESULT
myGetColumnDisplayName(
    IN  WCHAR const  *pwszColumnName,
    OUT WCHAR const **ppwszDisplayName);

HRESULT
myGetColumnName(
    IN  DWORD         Index,
    IN  BOOL          fDisplayName,
    OUT WCHAR const **ppwszName);

VOID
myFreeColumnDisplayNames(VOID);


typedef struct _CATRANSPROP	// Marshalled form
{
    LONG         lPropId;
    LONG         lPropFlags;
    ULONG	 obwszDisplayName;
} CATRANSPROP;

typedef struct _CAPROP		// Native form
{
    LONG         lPropId;
    LONG         lPropFlags;
    WCHAR const *pwszDisplayName;
} CAPROP;

HRESULT
myCAPropGetDisplayName(
    IN  LONG          lPropId,
    OUT WCHAR const **ppwszDisplayName);

HRESULT
myCAPropInfoUnmarshal(
    IN CATRANSPROP const *pCATransPropInfo,
    IN LONG cCAPropInfo,
    IN DWORD cbCATransPropInfo,
    OUT CAPROP **ppCAPropInfo);

HRESULT
myCAPropInfoLookup(
    IN CAPROP const *pCAPropInfo,
    IN LONG cCAPropInfo,
    IN LONG lPropId,
    OUT CAPROP const **ppcap);


// active modules
HRESULT
myGetActiveModule(
    OPTIONAL IN WCHAR const *pwszMachine,
    IN WCHAR const *pwszCAName,
    IN BOOL fPolicyModule,
    IN DWORD Index,
    OUT LPOLESTR *ppwszProgIdModule,   // CoTaskMem*
    OUT CLSID *pclsidModule);

// active manage module
HRESULT
myGetActiveManageModule(
    OPTIONAL IN WCHAR const *pwszMachine,
    IN WCHAR const *pwszCAName,
    IN BOOL fPolicyModule,
    IN DWORD Index,
    OUT LPOLESTR *ppwszProgIdManageModule,   // CoTaskMem*
    OUT CLSID *pclsidManageModule);

HRESULT
myFormConfigString(
    IN WCHAR const  *pwszServer,
    IN WCHAR const  *pwszCAName,
    OUT WCHAR      **ppwszConfig);

HRESULT
myLoadRCString(
    IN HINSTANCE hInstance,
    IN int       iRCId,
    OUT WCHAR  **ppwsz);


#define RORKF_FULLPATH		0x00000001
#define RORKF_CREATESUBKEYS	0x00000002
#define RORKF_USERKEY		0x00000004
#define RORKF_CREATEKEY		0x00000008

HRESULT
myRegOpenRelativeKey(
    OPTIONAL IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszRegName,
    IN DWORD Flags,		// RORKF_*
    OUT WCHAR **ppwszPath,
    OUT OPTIONAL WCHAR **ppwszName,
    OUT OPTIONAL HKEY *phkey);

HRESULT
myFixupRCFilterString(
    IN WCHAR *pwszFilter);


// NOTE: disappears in release builds
#define ASSERTVALIDCATYPE(__CATYPE__) \
   CSASSERT( (\
     ENUM_ENTERPRISE_SUBCA == (__CATYPE__) || \
     ENUM_ENTERPRISE_ROOTCA == (__CATYPE__) || \
     ENUM_UNKNOWN_CA == (__CATYPE__) || \
     ENUM_STANDALONE_SUBCA == (__CATYPE__) || \
     ENUM_STANDALONE_ROOTCA == (__CATYPE__) ))


__inline BOOL
IsEnterpriseCA(
    IN ENUM_CATYPES CAType)
{
    // assert we're a valid type
    ASSERTVALIDCATYPE(CAType);

    return(ENUM_ENTERPRISE_SUBCA == CAType || ENUM_ENTERPRISE_ROOTCA == CAType);
}

__inline BOOL
IsStandaloneCA(
    IN ENUM_CATYPES CAType)
{
    // assert we're a valid type
    ASSERTVALIDCATYPE(CAType);

    return(ENUM_STANDALONE_SUBCA == CAType || ENUM_STANDALONE_ROOTCA == CAType);
}

__inline BOOL
IsRootCA(
    IN ENUM_CATYPES CAType)
{
    // assert we're a valid type
    ASSERTVALIDCATYPE(CAType);

    return(ENUM_STANDALONE_ROOTCA == CAType || ENUM_ENTERPRISE_ROOTCA == CAType);
}

__inline BOOL
IsSubordinateCA(
    IN ENUM_CATYPES CAType)
{
    // assert we're a valid type
    ASSERTVALIDCATYPE(CAType);

    return(ENUM_ENTERPRISE_SUBCA == CAType || ENUM_STANDALONE_SUBCA == CAType);
}



HRESULT
myEnablePrivilege(
    IN LPCTSTR szPrivilege,
    IN BOOL fEnable);


HRESULT
myDeleteFilePattern(
    IN WCHAR const *pwszDir,
    OPTIONAL IN WCHAR const *pwszPattern,	// defaults to L"*.*"
    IN BOOL fRecurse);

HRESULT
myRemoveFilesAndDirectory(
    IN WCHAR const *pwszPath,
    IN BOOL fRecurse);

HRESULT
myCreateNestedDirectories(
    WCHAR const *pwszDirectory);


#define VFF_CREATEVROOTS	0x00000001
#define VFF_CREATEFILESHARES	0x00000002
#define VFF_DELETEVROOTS	0x00000004
#define VFF_DELETEFILESHARES	0x00000008

#define VFF_SETREGFLAGFIRST	0x00000010
#define VFF_CHECKREGFLAGFIRST	0x00000020
#define VFF_CLEARREGFLAGFIRST	0x00000040

#define VFF_CLEARREGFLAGIFOK	0x00000100
#define VFF_SETRUNONCEIFERROR	0x00000200
#define VFF_ENABLEASP           0x00000400


#define VFCSEC_TIMEOUT	15	// Recommended timeout in seconds

#define VFD_NOACTION		0
#define VFD_CREATED		1
#define VFD_DELETED		2
#define VFD_EXISTS		3
#define VFD_NOTFOUND		4
#define VFD_CREATEERROR		5
#define VFD_DELETEERROR		6
#define VFD_NOTSUPPORTED	7
#define VFD_VERIFYERROR		8

HRESULT
myModifyVirtualRootsAndFileShares(
    IN DWORD Flags,		// VFF_*: Create/Delete VRoots and/or Shares
    IN ENUM_CATYPES CAType,	// CA Type
    IN BOOL fAsynchronous,      // block during call?
    IN DWORD csecTimeOut,	// 0 implies synchronous call
    OPTIONAL OUT DWORD *pVRootDisposition,  // VFD_*
    OPTIONAL OUT DWORD *pShareDisposition); // VFD_*

HRESULT
myAddShare(
    IN LPCWSTR szShareName,
    IN LPCWSTR szShareDescr,
    IN LPCWSTR szSharePath,
    IN BOOL fOverwrite,
    OPTIONAL OUT BOOL *pfCreated);


typedef struct {
    HINSTANCE hInstance;         // instance handle
    HWND      hDlg;              // dialog handle
    HWND      hwndComputerEdit;  // control handle of computer edit
    HWND      hwndCAList;  // control handle of ca list control
    WNDPROC   pfnUICASelectionComputerWndProcs; // computer edit win procs

    // info on selected CA

    ENUM_CATYPES CAType;
    bool fWebProxySetup;
    bool fSkipLocalCA;
} CERTSRVUICASELECTION;

LRESULT CALLBACK
myUICASelectionComputerEditFilterHook(
    HWND hwndComputer,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam);

#define   UNC_PATH    1
#define   LOCAL_PATH  2

BOOL
myIsFullPath(
    IN WCHAR const *pwszPath,
    OUT DWORD      *pdwFlag);

HRESULT
myUICAHandleCABrowseButton(
    CERTSRVUICASELECTION *pData,
    IN BOOL               fUseDS,
    OPTIONAL IN int       idsPickerTitle,
    OPTIONAL IN int       idsPickerSubTitle,
    OPTIONAL OUT WCHAR   **ppwszSharedFolder);

HRESULT
myUICAHandleCAListDropdown(
    IN int                       iNotification,
    IN OUT CERTSRVUICASELECTION *pData,
    IN OUT BOOL                 *pfComputerChange);

HRESULT
myUICASelectionValidation(
    CERTSRVUICASELECTION *pData,
    BOOL                 *pfValidate);

HRESULT
myInitUICASelectionControls(
    IN OUT CERTSRVUICASELECTION *pUICASelection,
    IN HINSTANCE                 hInstance,
    IN HWND                      hDlg,
    IN HWND                      hwndBrowseButton,
    IN HWND                      hwndComputerEdit,
    IN HWND                      hwndCAList,
    IN BOOL                      fDSCA,
    OUT BOOL			*pfCAsExist);

HRESULT
myUICASelectionUpdateCAList(
    HWND hwndList,
    WCHAR const *pwszzCAList);

HRESULT
myUICAConditionallyDisplayEnterpriseWarning(
    IN CERTSRVUICASELECTION *pData);

char PrintableChar(char ch);

HRESULT
myGetMapiInfo(
    OPTIONAL IN WCHAR const *pwszServerName,
    OUT WCHAR **ppwszProfileName,
    OUT WCHAR **ppwszLogonName,
    OUT WCHAR **ppwszPassword);

HRESULT
mySaveMapiInfo(
    OPTIONAL IN WCHAR const *pwszServerName,
    OUT WCHAR const *pwszProfileName,
    OUT WCHAR const *pwszLogonName,
    OUT WCHAR const *pwszPassword);


#define cwcFILENAMESUFFIXMAX		20
#define cwcSUFFIXMAX	(1 + 5 + 1)	// five decimal digits plus parentheses

#define wszFCSAPARM_SERVERDNSNAME		L"%1"
#define wszFCSAPARM_SERVERSHORTNAME		L"%2"
#define wszFCSAPARM_SANITIZEDCANAME		L"%3"
#define wszFCSAPARM_CERTFILENAMESUFFIX		L"%4"
#define wszFCSAPARM_DOMAINDN			L"%5"
#define wszFCSAPARM_CONFIGDN			L"%6"
#define wszFCSAPARM_SANITIZEDCANAMEHASH		L"%7"
#define wszFCSAPARM_CRLFILENAMESUFFIX		L"%8"
#define wszFCSAPARM_CRLDELTAFILENAMESUFFIX	L"%9"
#define wszFCSAPARM_DSCRLATTRIBUTE		L"%10"
#define wszFCSAPARM_DSCACERTATTRIBUTE		L"%11"
#define wszFCSAPARM_DSUSERCERTATTRIBUTE		L"%12"
#define wszFCSAPARM_DSKRACERTATTRIBUTE		L"%13"
#define wszFCSAPARM_DSCROSSCERTPAIRATTRIBUTE	L"%14"


HRESULT
myFormatCertsrvStringArray(
    IN BOOL fURL,
    IN LPCWSTR pwszServerName_p1_2,
    IN LPCWSTR pwszSanitizedName_p3_7,
    IN DWORD   iCert_p4,
    IN DWORD   iCertTarget_p4,
    IN LPCWSTR pwszDomainDN_p5,
    IN LPCWSTR pwszConfigDN_p6,
    IN DWORD   iCRL_p8,
    IN BOOL    fDeltaCRL_p9,
    IN BOOL    fDSAttrib_p10_11,
    IN DWORD   cStrings,
    IN LPCWSTR *apwszStringsIn,
    OUT LPWSTR *apwszStringsOut);

HRESULT
myUncanonicalizeURLParm(
    IN WCHAR const *pwszParmIn,
    OUT WCHAR **ppwszParmOut);

HRESULT
myAllocIndexedName(
    IN WCHAR const *pwszName,
    IN DWORD Index,
    IN DWORD IndexTarget,
    OUT WCHAR **ppwszIndexedName);

HRESULT
myUIGetWindowText(
    IN HWND     hwndCtrl,
    OUT WCHAR **ppwszText);

HRESULT
myGetSaveFileName(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags, //see OPENFILENAME Flags
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile);

HRESULT
myGetOpenFileName(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags, //see OPENFILENAME Flags
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile);

HRESULT
myGetSaveFileNameEx(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN WCHAR const *pwszTitleInsert,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags, //see OPENFILENAME Flags
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile);

HRESULT
myGetOpenFileNameEx(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN WCHAR const *pwszTitleInsert,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags, //see OPENFILENAME Flags
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile);

int
myWtoI(
    IN WCHAR const *pwszDigitString,
    OUT BOOL *pfValid);

HRESULT
myFormCertRegPath(
    IN  WCHAR const *pwszName1,
    IN  WCHAR const *pwszName2,
    IN  WCHAR const *pwszName3,
    IN  BOOL         fConfigLevel,  // from CertSrv if FALSE
    OUT WCHAR      **ppwszPath);

HRESULT
myGetEnvString(
    OUT WCHAR **ppwszOut,
    IN  WCHAR const *pwszVariable);


typedef HRESULT (FNMYINFGETEXTENSION)(
    IN  HINF hInf,
    OUT CERT_EXTENSION *pext);

FNMYINFGETEXTENSION myInfGetPolicyConstraintsExtension;
FNMYINFGETEXTENSION myInfGetPolicyMappingExtension;
FNMYINFGETEXTENSION myInfGetPolicyStatementExtension;
FNMYINFGETEXTENSION myInfGetApplicationPolicyConstraintsExtension;
FNMYINFGETEXTENSION myInfGetApplicationPolicyMappingExtension;
FNMYINFGETEXTENSION myInfGetApplicationPolicyStatementExtension;
FNMYINFGETEXTENSION myInfGetNameConstraintsExtension;
FNMYINFGETEXTENSION myInfGetEnhancedKeyUsageExtension;
FNMYINFGETEXTENSION myInfGetBasicConstraints2CAExtension;
FNMYINFGETEXTENSION myInfGetBasicConstraints2CAExtensionOrDefault;
FNMYINFGETEXTENSION myInfGetCrossCertDistributionPointsExtension;

WCHAR *
myInfGetError();

VOID
myInfClearError();

HRESULT
myInfGetUnreferencedSectionNames(
    OUT WCHAR **ppwszzSectionNames);

HRESULT
myInfOpenFile(
    OPTIONAL IN WCHAR const *pwszfnPolicy,
    OUT HINF *phInf,
    OUT DWORD *pErrorLine);

VOID
myInfCloseFile(
    IN HINF hInf);

HRESULT
myInfGetCRLDistributionPoints(
    IN HINF hInf,
    OUT BOOL *pfCritical,
    OUT WCHAR **ppwszz);

HRESULT
myInfGetAuthorityInformationAccess(
    IN HINF hInf,
    OUT BOOL *pfCritical,
    OUT WCHAR **ppwszz);

HRESULT
myInfGetEnhancedKeyUsage(
    IN HINF hInf,
    OUT BOOL *pfCritical,
    OUT WCHAR **ppwszz);

HRESULT
myInfGetValidityPeriod(
    IN HINF hInf,
    OPTIONAL IN WCHAR const *pwszValidityPeriodCount,
    OPTIONAL IN WCHAR const *pwszValidityPeriodString,
    OUT DWORD *pdwValidityPeriodCount,
    OUT ENUM_PERIOD *penumValidityPeriod,
    OPTIONAL OUT BOOL *pfSwap);

HRESULT
myInfGetCRLPublicationParams(
   IN HINF hInf,
   IN WCHAR const *pwszKeyCRLPeriodString,
   IN WCHAR const *pwszKeyCRLPeriodCount,
   OUT WCHAR **ppwszCRLPeriodString, 
   OUT DWORD *pdwCRLPeriodCount);

HRESULT
myInfGetKeyLength(
    IN HINF hInf,
    OUT DWORD *pdwKeyLength);

HRESULT
myInfParseBooleanValue(
    IN WCHAR const *pwszValue,
    OUT BOOL *pfValue);

HRESULT
myInfGetNumericKeyValue(
    IN HINF hInf,
    IN BOOL fLog,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN DWORD Index,
    IN BOOL fLastValue,
    OUT DWORD *pdwValue);

HRESULT
myInfGetBooleanValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN BOOL fIgnoreMissingKey,
    OUT BOOL *pfValue);

HRESULT
myInfGetKeyValue(
    IN HINF hInf,
    IN BOOL fLog,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN DWORD Index,
    IN BOOL fLastValue,
    OUT WCHAR **ppwszValue);

HRESULT
myInfGetKeyList(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    OPTIONAL IN WCHAR const *pwszKey,
    OPTIONAL WCHAR const * const *ppwszValidKeys,
    OPTIONAL OUT BOOL *pfCritical,
    OPTIONAL OUT WCHAR **ppwszz);

typedef struct _INFVALUES
{
    WCHAR *pwszKey;
    DWORD cValues;
    WCHAR **rgpwszValues;
} INFVALUES;

HRESULT
myInfGetSectionValues(
    IN  HINF hInf,
    IN  WCHAR const *pwszSection,
    OUT DWORD *pcInfValues,
    OUT INFVALUES **prgInfValues);

VOID
myInfFreeSectionValues(
    IN DWORD cInfValues,
    IN OUT INFVALUES *rgInfValues);

HRESULT
myInfGetRequestAttributes(
    IN HINF hInf,
    OUT DWORD *pcAttribute,
    OUT CRYPT_ATTR_BLOB **ppaAttribute,
    OUT WCHAR **ppwszTemplateName);

HRESULT
myInfGetEnableKeyCounting(
    IN HINF hInf,
    OUT BOOL *pfValue);

VOID
myInfFreeRequestAttributes(
    IN DWORD cAttribute,
    IN OUT CRYPT_ATTR_BLOB *paAttribute);

VOID
myInfFreeExtensions(
    IN DWORD cExt,
    IN CERT_EXTENSION *rgExt);

HRESULT
myInfGetExtensions(
    IN HINF hInf,
    OUT DWORD *pcExt,
    OUT CERT_EXTENSION **ppExt);

VOID
myPackExtensionArray(
    IN BOOL fFreeData,
    IN OUT DWORD *pcExt,
    IN OUT CERT_EXTENSION **prgExt);

HRESULT
myMergeExtensions(
    IN DWORD cExtOrg,
    IN CERT_EXTENSION *rgExtOrg,
    IN DWORD cExtInf,
    IN CERT_EXTENSION *rgExtInf,
    OUT DWORD *pcExtMerged,
    OUT CERT_EXTENSION **prgExtMerged);

HRESULT
myBuildOSVersionAttribute(
    OUT BYTE **ppbVersion,
    OUT DWORD *pcbVersion);

WCHAR const *
myFixTemplateCase(
    IN WCHAR const *pwszCertType);

HRESULT
myBuildCertTypeExtension(
    IN WCHAR const *pwszCertType,
    OUT CERT_EXTENSION *pExt);

HRESULT
myParseNextAttribute(
    IN OUT WCHAR **ppwszBuf,
    IN BOOL fURL,
    OUT WCHAR const **ppwszName,
    OUT WCHAR const **ppwszValue);

HRESULT
myParseIPAddress(
    IN WCHAR const *pwszValue,
    OUT BYTE *pbData,
    OUT DWORD *pcbData);

#define CUCS_MYSTORE		0x00000001
#define CUCS_CASTORE		0x00000002
#define CUCS_KRASTORE		0x00000004
#define CUCS_ROOTSTORE		0x00000008

#define CUCS_MACHINESTORE	0x00010000
#define CUCS_USERSTORE		0x00020000
#define CUCS_DSSTORE		0x00040000

#define CUCS_V1ONLY		0x04000000
#define CUCS_V3ONLY		0x08000000
#define CUCS_ARCHIVED		0x10000000
#define CUCS_USAGEREQUIRED      0x20000000
#define CUCS_SILENT             0x40000000
#define CUCS_PRIVATEKEYREQUIRED 0x80000000
#define CUCS_USAGEKEYENCIPHER   0x02000000

HRESULT
myGetCertificateFromPicker(
    OPTIONAL IN HINSTANCE           hInstance,
    OPTIONAL IN HWND                hwndParent,
    OPTIONAL IN int                 idTitle,
    OPTIONAL IN int                 idSubTitle,
    IN DWORD                        dwFlags,	// CUCS_*
    OPTIONAL IN WCHAR const        *pwszCommonName,
    OPTIONAL IN DWORD               cStore,
    OPTIONAL IN HCERTSTORE         *rghStore,
    IN DWORD		            cpszObjId,
    OPTIONAL IN CHAR const * const *apszObjId,
    OUT CERT_CONTEXT const        **ppCert);

HRESULT
myGetKRACertificateFromPicker(
    OPTIONAL IN HINSTANCE    hInstance,
    OPTIONAL IN HWND         hwndParent,
    OPTIONAL IN int          idTitle,
    OPTIONAL IN int          idSubTitle,
    OPTIONAL IN WCHAR const *pwszCommonName,
    IN BOOL		     fUseDS,
    IN BOOL		     fSilent,
    OUT CERT_CONTEXT const **ppCert);

HRESULT
myGetERACertificateFromPicker(
    OPTIONAL IN HINSTANCE    hInstance,
    OPTIONAL IN HWND         hwndParent,
    OPTIONAL IN int          idTitle,
    OPTIONAL IN int          idSubTitle,
    OPTIONAL IN WCHAR const *pwszCommonName,
    IN BOOL		     fSilent,
    OUT CERT_CONTEXT const **ppCert);

HRESULT
myMakeSerialBstr(
    IN WCHAR const *pwszSerialNumber,
    OUT BSTR *pstrSerialNumber);

HRESULT
myNameBlobMatch(
    IN CERT_NAME_BLOB const *pSubject,
    IN WCHAR const *pwszCertName,
    IN BOOL fAllowMissingCN,
    OUT BOOL *pfMatch);

HRESULT
mySerialNumberMatch(
    IN CRYPT_INTEGER_BLOB const *pSerialNumber,
    IN WCHAR const *pwszSerialNumber,
    OUT BOOL *pfMatch);

HRESULT
myCertHashMatch(
    IN CERT_CONTEXT const *pCert,
    IN DWORD cb,
    IN BYTE const *pb,
    OUT BOOL *pfMatch);

HRESULT
myCertMatch(
    IN CERT_CONTEXT const *pCert,
    IN WCHAR const *pwszCertName,
    IN BOOL fAllowMissingCN,
    OPTIONAL IN BYTE const *pbHash,
    IN DWORD cbHash,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OUT BOOL *pfMatch);

HRESULT
myCRLHashMatch(
    IN CRL_CONTEXT const *pCRL,
    IN DWORD cb,
    IN BYTE const *pb,
    OUT BOOL *pfMatch);

HRESULT
myCRLMatch(
    IN CRL_CONTEXT const *pCRL,
    IN WCHAR const *pwszCRLName,
    IN BOOL fAllowMissingCN,
    OPTIONAL IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT BOOL *pfMatch);

HRESULT
myCTLMatch(
    IN CTL_CONTEXT const *pCTL,
    OPTIONAL IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT BOOL *pfMatch);

HRESULT
myCertMatchEKUOrApplicationPolicies(
    IN CERT_CONTEXT const *pCert,
    IN DWORD cpszObjId,
    IN CHAR const * const *apszObjId,
    IN BOOL fUsageRequired,
    OUT BOOL *pfMatch);

HRESULT
myLoadPrivateKey(
    IN CERT_PUBLIC_KEY_INFO const *pPubKeyInfo,
    IN DWORD dwFlags,		// CUCS_*
    OUT HCRYPTPROV *phProv,
    OUT DWORD *pdwKeySpec,
    OUT BOOL *pfCallerFreeProv);

HRESULT
myLoadPrivateKeyFromCertStores(
    IN CERT_PUBLIC_KEY_INFO const *pPubKeyInfo,
    IN DWORD cStore,
    IN HCERTSTORE *rghStore,
    OUT HCRYPTPROV *phProv,
    OUT DWORD *pdwKeySpec,
    OUT BOOL *pfCallerFreeProv);

HRESULT
myOpenCertStores(
    IN DWORD dwFlags,		// CUCS_*
    OUT DWORD *pcStore,
    OUT HCERTSTORE **prghStore);

VOID
myCloseCertStores(
    IN DWORD cStore,
    IN HCERTSTORE *rghStore);


#define DECF_FORCEOVERWRITE		0x00000100

HRESULT
DecodeFileW(
    IN WCHAR const *pwszfn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN DWORD Flags);

HRESULT
EncodeToFileW(
    IN WCHAR const *pwszfn,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags);

HRESULT
DecodeCertString(
    IN BSTR const bstrIn,
    IN DWORD Flags,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut);

HRESULT
EncodeCertString(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT BSTR *pbstrOut);

HRESULT
WszToMultiByteIntegerBuf(
    IN BOOL fOctetString,
    IN WCHAR const *pwszIn,
    IN OUT DWORD *pcbOut,
    OPTIONAL OUT BYTE const *pbOut);

HRESULT
WszToMultiByteInteger(
    IN BOOL fOctetString,
    IN WCHAR const *pwszIn,
    OUT DWORD *pcbOut,
    OUT BYTE **ppbOut);

HRESULT
myGetSecurityDescriptorDacl(
    IN PSECURITY_DESCRIPTOR   pSD,
    OUT PACL                 *ppDacl); // no free

HRESULT 
myRegValueToVariant(
    IN DWORD dwType,
    IN DWORD cbValue,
    IN BYTE const *pbValue,
    OUT VARIANT *pVar);

HRESULT
myVariantToRegValue(
    IN VARIANT const *pvarPropertyValue,
    OUT DWORD *pdwType,
    OUT DWORD *pcbprop,
    OUT BYTE **ppbprop);

// are we the Whistler version?
BOOL IsWhistler(VOID);

// should we run advanced functionality?
BOOL FIsAdvancedServer(VOID);

// should we be running at all?
BOOL FIsServer(VOID);

HRESULT
myAddLogSourceToRegistry(
    IN LPWSTR   pwszMsgDLL,
    IN LPWSTR   pwszApp);


#define LOCAL_FREE(ptr) \
    if(NULL != ptr) \
        LocalFree(ptr)

inline bool EmptyString(LPCWSTR pwszString) 
{
    return((NULL == pwszString || L'\0' == *pwszString)? true : false);
}

HRESULT
myOIDHashOIDToString(
    IN WCHAR const *pwszOID,
    OUT WCHAR **ppwsz);

LPCWSTR
myCAGetDN(
    IN HCAINFO hCAInfo);

HRESULT
myIsCurrentUserBuiltinAdmin(
    OUT bool *pfIsMember);

HRESULT
mySetRegistryLocalPathString(
    IN HKEY hkey,
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszUNCPath);

HRESULT
myLocalMachineIsDomainMember(
    OUT bool *pfIsDomainMember);

HRESULT
myComputeMAC(
    IN WCHAR const *pcwsFileName,
    OUT WCHAR **ppwszMAC);

HRESULT IsASPEnabledInIIS(
    bool& rfEnabled);

HRESULT EnableASPInIIS(
    OUT BOOL *pfEnabledASP);

HRESULT
EnableISAPIExtension(
    IN LPCWSTR pcwszExtension,
    OUT BOOL *pfEnabledASP);

HRESULT IsISAPIExtensionEnabled(
    LPCWSTR pcwszExtension,
    bool& rfEnabled);

HRESULT EnableASPInIIS_New(
    OUT BOOL *pfEnabledASP);

HRESULT IsASPEnabledInIIS_New(
    bool& rfEnabled);

HRESULT
SetCertSrvASPDependency();

HRESULT myFindCertTypeByNameOrOID(
    IN const HCERTTYPE &hCertTypeList,
    IN OPTIONAL LPCWSTR pcwszCertName,
    IN OPTIONAL LPCWSTR pcwszCertOID,
    OUT HCERTTYPE& hCertType);

HRESULT 
myGetCertSubjectField(
    IN CERT_CONTEXT const *pCert,
    IN LPCSTR pcszFieldOID,
    OUT WCHAR **ppwszField);

HRESULT
myCertGetEnhancedKeyUsage(
    IN CERT_CONTEXT const *pcc,
    IN DWORD dwFlags,
    OUT CERT_ENHKEY_USAGE **ppUsage);

HRESULT
myEncodeUTF8(
    IN WCHAR const *pwszIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut);

HRESULT
myEncodeOtherNameBinary(
    IN WCHAR const *pwszIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut);


VOID 
myZeroDataString(
    IN WCHAR *pwsz);

VOID 
myZeroDataStringA(
    IN char *psz);

///////////////////////////////////////////////////////////////////////////////
// ConvertToString*
HRESULT ConvertToStringI2I4(
    LONG lVal,
    LPWSTR *ppwszOut);

HRESULT ConvertToStringUI2UI4(
    ULONG ulVal,
    LPWSTR *ppwszOut);

HRESULT ConvertToStringUI8(
    ULARGE_INTEGER *puliVal,
        LPWSTR *ppwszOut);

HRESULT ConvertToStringWSZ(
    LPCWSTR pcwszVal,
    LPWSTR *ppwszOut,
    bool fDoublePercentsInString = false);

HRESULT ConvertToStringArrayUI1(
    LPSAFEARRAY psa,
    LPWSTR *ppwszOut);

HRESULT ConvertToStringArrayBSTR(
    LPSAFEARRAY psa,
    LPWSTR *ppwszOut,
    bool fDoublePercentsInString = false);

HRESULT DoublePercentsInString(
    LPCWSTR pcwszIn,
    LPWSTR *ppwszOut);

HRESULT ConvertToStringDATE(
    IN DATE const *pDate,
    IN BOOL fGMT,
    OUT LPWSTR *ppwszOut);

// ConvertToString*
///////////////////////////////////////////////////////////////////////////////

HRESULT
myRegQueryValueEx(
  IN HKEY hKey,
  IN LPCTSTR pwszValueName,
  OUT LPDWORD pValueType,
  OUT LPBYTE *ppbData,
  OUT LPDWORD pcbData);

HRESULT
myGetSidFromRid(
    DWORD dwGroupRid, 
    OPTIONAL PSID *ppSid, 
    OPTIONAL LPWSTR* ppwszSid);

HRESULT
myConvertAppPoliciesToEKU(
    IN BYTE * pbAppPolicies,
    IN DWORD cbAppPolicies,
    OUT BYTE **ppbEKU,
    OUT DWORD *pcbEKU);

using namespace CertSrv;

#endif // __CERTLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\certreq.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certreq.h
//
// Contents:    ICertRequest definitions
//
// History:     03-Jan-97       vich created
//
//---------------------------------------------------------------------------

#ifndef __CERTREQ_H__
#define __CERTREQ_H__

#ifdef __cplusplus
extern "C" {
#endif


// begin_certsrv

//+--------------------------------------------------------------------------
// Known request Attribute names and Value strings

// RequestType attribute name:
#define wszCERT_TYPE		L"RequestType"	// attribute name

// RequestType attribute values:
// Not specified: 				// Non-specific certificate
#define wszCERT_TYPE_CLIENT	L"Client"	// Client authentication cert
#define wszCERT_TYPE_SERVER	L"Server"	// Server authentication cert
#define wszCERT_TYPE_CODESIGN	L"CodeSign"	// Code signing certificate
#define wszCERT_TYPE_CUSTOMER	L"SetCustomer"	// SET Customer certificate
#define wszCERT_TYPE_MERCHANT	L"SetMerchant"	// SET Merchant certificate
#define wszCERT_TYPE_PAYMENT	L"SetPayment"	// SET Payment certificate


// Version attribute name:
#define wszCERT_VERSION		L"Version"	// attribute name

// Version attribute values:
// Not specified: 				// Whetever is current
#define wszCERT_VERSION_1	L"1"		// Version one certificate
#define wszCERT_VERSION_2	L"2"		// Version two certificate
#define wszCERT_VERSION_3	L"3"		// Version three certificate

// end_certsrv

#ifdef __cplusplus
}
#endif
#endif // __CERTREQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\certsd.h ===
//+--------------------------------------------------------------------------
// File:        certsd.h
// Contents:    CA's security descriptor class declaration
//---------------------------------------------------------------------------
#ifndef __CERTSD_H__
#define __CERTSD_H__

namespace CertSrv
{

typedef struct _SID_LIST
{
    DWORD dwSidCount;
    DWORD SidListStart[ANYSIZE_ARRAY];

} SID_LIST, *PSID_LIST;

HRESULT GetWellKnownSID(
    PSID *ppSid,
    SID_IDENTIFIER_AUTHORITY *pAuth,
    BYTE  SubauthorityCount,
    DWORD SubAuthority1,
    DWORD SubAuthority2=0,
    DWORD SubAuthority3=0,
    DWORD SubAuthority4=0,
    DWORD SubAuthority5=0,
    DWORD SubAuthority6=0,
    DWORD SubAuthority7=0,
    DWORD SubAuthority8=0);

// caller is responsible for LocalFree'ing PSID
HRESULT GetEveryoneSID(PSID *ppSid);
HRESULT GetLocalSystemSID(PSID *ppSid);
HRESULT GetBuiltinAdministratorsSID(PSID *ppSid);
HRESULT GetLocalSID(PSID *ppSid);
HRESULT GetNetworkSID(PSID *ppSid);

// This class wraps a SD with single writer multiple reader access control on
// it. Allows any number of threads to LockGet() the pointer to the SD if no
// thread is in the middle of a Set(). Set() is blocked until all threads
// that already retrieved the SD released it (calling Unlock)
//
// Also provides the support for persistently saving/loading the SD to registy

class CProtectedSecurityDescriptor
{
public:

    CProtectedSecurityDescriptor() :
        m_pSD(NULL),
        m_fInitialized(false),
        m_cReaders(0),
        m_hevtNoReaders(NULL),
        m_pcwszSanitizedName(NULL),
        m_pcwszPersistRegVal(NULL)
        {};
   ~CProtectedSecurityDescriptor()
    {
       Uninitialize();
    }

    void Uninitialize()
    {
       if(m_pSD)
       {
           LocalFree(m_pSD);
           m_pSD = NULL;
       }
       if(m_hevtNoReaders)
       {
           CloseHandle(m_hevtNoReaders);
           m_hevtNoReaders = NULL;
       }
       if(IsInitialized())
       {
           DeleteCriticalSection(&m_csWrite);
       }
       m_pcwszSanitizedName = NULL;
       m_fInitialized = false;
       m_cReaders = 0;
    }

    BOOL IsInitialized() const { return m_fInitialized;}

    // init, loading SD from the registry
    HRESULT Initialize(LPCWSTR pwszSanitizedName);
    // init from supplied SD
    HRESULT Initialize(const PSECURITY_DESCRIPTOR pSD, LPCWSTR pwszSanitizedName);

    HRESULT InitializeFromTemplate(LPCWSTR pcwszTemplate, LPCWSTR pwszSanitizedName);

    HRESULT Set(const PSECURITY_DESCRIPTOR pSD);
    HRESULT LockGet(PSECURITY_DESCRIPTOR *ppSD);
    HRESULT Unlock();

    PSECURITY_DESCRIPTOR Get() { return m_pSD; };

    // load SD from registry
    HRESULT Load();
    // save SD to registry
    HRESULT Save();
    // delete SD from registry
    HRESULT Delete();

    LPCWSTR GetPersistRegistryVal() { return m_pcwszPersistRegVal;}

    void ImportResourceStrings(LPCWSTR *pcwszStrings) 
    {m_pcwszResources = pcwszStrings;};

protected:

    HRESULT Init(LPCWSTR pwszSanitizedName);
    HRESULT SetSD(PSECURITY_DESCRIPTOR pSD);
    
    PSECURITY_DESCRIPTOR m_pSD;
    bool m_fInitialized;
    LONG m_cReaders;
    HANDLE m_hevtNoReaders;
    CRITICAL_SECTION m_csWrite;
    LPCWSTR m_pcwszSanitizedName; // no free
    LPCWSTR m_pcwszPersistRegVal; // no free

    static LPCWSTR const *m_pcwszResources; // no free

}; //class CProtectedSecurityDescriptor



// The class stores a list of officers/groups and the principals they are
// allowed to manage certificates for:
//
// officerSID1 -> clientSID1, clientSID2...
// officerSID2 -> clientSID3, clientSID4...
//
// The information is stored as a DACL containing callback ACEs .
// The officer SID is stored as in the ACE's SID and the list of client 
// SIDs are stored in the custom data space following the officer SID 
// (see definition of _ACCESS_*_CALLBACK_ACE)
//
// The DACL will be used to AccessCheck if an officer is allowed to perform
// an action over a certificate.
//
// The SD contains only the officer DACL, SACL or other data is not used.

class COfficerRightsSD : public CProtectedSecurityDescriptor
{
public:

    COfficerRightsSD() : m_fEnabled(FALSE) 
    { m_pcwszPersistRegVal = wszREGOFFICERRIGHTS; }

    HRESULT InitializeEmpty();
    HRESULT Initialize(LPCWSTR pwszSanitizedName);

    // The officer rights have to be in sync with the CA security descriptor.
    // An officer ACE for a certain SID can exist only if the principal is
    // an officer as defined by the CA SD. 
    // Merge sets the internal officer DACL making sure it's in sync 
    // with the CA SD:
    // - removes any ACE found in the officer DACL which is not present as an
    //   allow ACE in the CA DACL
    // - add an Everyone ACE in the officer DACL for each allow ACE in CA DACL
    //   that is not already present
    HRESULT Merge(
        PSECURITY_DESCRIPTOR pOfficerSD,
        PSECURITY_DESCRIPTOR pCASD);

    // Same as above but using the internal officer SD. Used to generate the
    // initial officer SD and to update it when CA SD changes
    HRESULT Adjust(
        PSECURITY_DESCRIPTOR pCASD);

    BOOL IsEnabled() { return m_fEnabled; }
    void SetEnable(BOOL fEnable) { m_fEnabled = fEnable;}
    HRESULT Save();
    HRESULT Load();
    HRESULT Validate() { return S_OK; }

    static HRESULT ConvertToString(
        IN PSECURITY_DESCRIPTOR pSD,
        OUT LPWSTR& rpwszSD);

protected:

    static HRESULT ConvertAceToString(
        IN PACCESS_ALLOWED_CALLBACK_ACE pAce,
        OUT OPTIONAL PDWORD pdwSize,
        IN OUT OPTIONAL LPWSTR pwszSD);


    BOOL m_fEnabled;
}; // class COfficerRightsSD

class CCertificateAuthoritySD : public CProtectedSecurityDescriptor
{
public:

    CCertificateAuthoritySD() : 
        m_pDefaultDSSD(NULL),
        m_pDefaultServiceSD(NULL),
        m_pDefaultDSAcl(NULL),
        m_pDefaultServiceAcl(NULL),
        m_pwszComputerSID(NULL)
    { m_pcwszPersistRegVal = wszREGCASECURITY; }

    ~CCertificateAuthoritySD()
    {
        if(m_pDefaultDSSD)
            LocalFree(m_pDefaultDSSD);
        if(m_pDefaultServiceSD)
            LocalFree(m_pDefaultServiceSD);
        if(m_pwszComputerSID)
            LocalFree(m_pwszComputerSID);
    }

    // Sets a new CA SD. Uses the new DACL but keeps the old owner, group and
    // SACL.
    // Also rebuilds the DACL for objects CA owns (eg DS pKIEnrollmentService, 
    // service). The new DACL contains a default DACL plus additional aces 
    // depending on the object:
    // DS - add an enroll ace for each enroll ace found in CA DACL
    // Service - add a full control ace for each CA admin ace
    HRESULT Set(const PSECURITY_DESCRIPTOR pSD, bool fSetDSSecurity);
    static HRESULT Validate(const PSECURITY_DESCRIPTOR pSD);
    HRESULT ResetSACL();
    HRESULT MapAndSetDaclOnObjects(bool fSetDSSecurity);

    // Upgrade SD from Win2k.
    HRESULT UpgradeWin2k(bool fUseEnterpriseAcl);

    static HRESULT ConvertToString(
        IN PSECURITY_DESCRIPTOR pSD,
        OUT LPWSTR& rpwszSD);

protected:

    enum ObjType
    {
        ObjType_DS,
        ObjType_Service,
    };

    HRESULT MapAclGetSize(PVOID pAce, ObjType type, DWORD& dwSize);
    HRESULT MapAclAddAce(PACL pAcl, ObjType type, PVOID pAce);
    HRESULT SetDefaultAcl(ObjType type);
    HRESULT SetComputerSID();
    HRESULT MapAclSetOnDS(const PACL pAcl);
    HRESULT MapAclSetOnService(const PACL pAcl);

    DWORD GetUpgradeAceSizeAndType(PVOID pAce, DWORD *pdwType, PSID *ppSid);

    static HRESULT ConvertAceToString(
        IN PACCESS_ALLOWED_ACE pAce,
        OUT OPTIONAL PDWORD pdwSize,
        IN OUT OPTIONAL LPWSTR pwszSD);


    PSECURITY_DESCRIPTOR m_pDefaultDSSD;
    PSECURITY_DESCRIPTOR m_pDefaultServiceSD;
    PACL m_pDefaultDSAcl; // no free
    PACL m_pDefaultServiceAcl; // no free
    LPWSTR m_pwszComputerSID;
};

} // namespace CertSrv

#endif //__CERTSD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\certsrv.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       CertSrv.h
//  Contents:   Main Certificate Server header
//              Also includes .h files for the COM interfaces
//
//----------------------------------------------------------------------------

#if !defined( _CERTSRV_H_ )
#define _CERTSRV_H_

#include <certadm.h>
#include <certbcli.h>
#include <certcli.h>
#include <certenc.h>
#include <certexit.h>
#include <certif.h>
#include <certpol.h>
#include <certmod.h>
#include <certview.h>

#ifndef DBG_CERTSRV
# if defined(_DEBUG)
#  define DBG_CERTSRV     1
# elif defined(DBG)
#  define DBG_CERTSRV     DBG
# else
#  define DBG_CERTSRV     0
# endif
#endif

#define wszSERVICE_NAME		TEXT("CertSvc")

#define wszREGKEYNOSYSTEMCERTSVCPATH \
				TEXT("CurrentControlSet\\Services\\") \
				wszSERVICE_NAME

#define wszREGKEYCERTSVCPATH	TEXT("SYSTEM\\") wszREGKEYNOSYSTEMCERTSVCPATH
#define wszREGKEYBASE		wszREGKEYCERTSVCPATH	// obsolete definition

//======================================================================
// Full path to "CertSvc\Configuration\":
#define wszREGKEYCONFIGPATH	wszREGKEYCERTSVCPATH TEXT("\\") wszREGKEYCONFIG
#define wszREGKEYCONFIGPATH_BS	wszREGKEYCONFIGPATH TEXT("\\")
#define wszREGKEYCONFIGCANAME	wszREGKEYCONFIGPATH_BS	// obsolete definition

//======================================================================
// Full path to "CertSvc\Configuration\RestoreInProgress":
#define wszREGKEYCONFIGRESTORE wszREGKEYCONFIGPATH_BS wszREGKEYRESTOREINPROGRESS

//======================================================================
// Key Under "CertSvc":
#define wszREGKEYCONFIG		TEXT("Configuration")

//======================================================================
// Values Under "CertSvc\Configuration":
#define wszREGACTIVE		      TEXT("Active")
#define wszREGDIRECTORY		      TEXT("ConfigurationDirectory")
#define wszREGDBDIRECTORY             TEXT("DBDirectory")
#define wszREGDBLOGDIRECTORY          TEXT("DBLogDirectory")
#define wszREGDBSYSDIRECTORY          TEXT("DBSystemDirectory")
#define wszREGDBTEMPDIRECTORY         TEXT("DBTempDirectory")
#define wszREGDBSESSIONCOUNT	      TEXT("DBSessionCount")
#define wszREGDBFLAGS		      TEXT("DBFlags")
#define wszREGDBLASTFULLBACKUP	      TEXT("DBLastFullBackup")
#define wszREGDBLASTINCREMENTALBACKUP TEXT("DBLastIncrementalBackup")
#define wszREGDBLASTRECOVERY	      TEXT("DBLastRecovery")
#define wszREGWEBCLIENTCAMACHINE      TEXT("WebClientCAMachine")
#define wszREGVERSION		      TEXT("Version")
#define wszREGWEBCLIENTCANAME         TEXT("WebClientCAName")
#define wszREGWEBCLIENTCATYPE         TEXT("WebClientCAType")
#define wszREGLDAPFLAGS               TEXT("LDAPFlags")
#define wszREGCERTSRVDEBUG	      TEXT("Debug")


// Default value for wszREGDBSESSIONCOUNT
#define DBSESSIONCOUNTDEFAULT	     20

// Values for wszREGDBFLAGS
// Default is zero (same as a missing registry value):

#define DBFLAGS_READONLY		0x00000001	// ignored in registry
#define DBFLAGS_CREATEIFNEEDED		0x00000002
#define DBFLAGS_CIRCULARLOGGING		0x00000004
#define DBFLAGS_LAZYFLUSH		0x00000008
#define DBFLAGS_MAXCACHESIZEX100	0x00000010
#define DBFLAGS_CHECKPOINTDEPTH60MB	0x00000020
#define DBFLAGS_LOGBUFFERSLARGE		0x00000040
#define DBFLAGS_LOGBUFFERSHUGE		0x00000080
#define DBFLAGS_LOGFILESIZE16MB		0x00000100
#define DBFLAGS_MULTITHREADTRANSACTIONS	0x00000200
#define DBFLAGS_DISABLESNAPSHOTBACKUP	0x00000400	// ignored in registry

#define DBFLAGS_DEFAULT		(DBFLAGS_LAZYFLUSH | \
				 DBFLAGS_MAXCACHESIZEX100 | \
				 DBFLAGS_CHECKPOINTDEPTH60MB | \
				 DBFLAGS_LOGBUFFERSHUGE)


// Values for wszREGLDAPSSLFLAGS
// Default is zero (same as a missing registry value):
//    0: Don't use SSL, but sign all LDAP traffic.
//    3: Use SSL but don't sign LDAP traffic.
#define LDAPF_SSLENABLE		0x00000001	// use SSL for LDAP traffic
#define LDAPF_SIGNDISABLE	0x00000002	// disable signing LDAP traffic

// Default value for wszREGMAXINCOMINGMESSAGESIZE
#define MAXINCOMINGMESSAGESIZEDEFAULT		(64 * 1024)

// Default value for wszREGMAXINCOMINGALLOCSIZE
#define MAXINCOMINGALLOCSIZEDEFAULT		(64 * 1024)

// Value for wszREGVERSION:

// win2k version
#define CSVER_MAJOR_WIN2K            1 // actually this wasn't define in win2k
#define CSVER_MINOR_WIN2K            1

// whistler version
#define CSVER_MAJOR_WHISTLER         2
#define CSVER_MINOR_WHISTLER_BETA2   1
#define CSVER_MINOR_WHISTLER_BETA3   2

// current version
#define CSVER_MAJOR		     CSVER_MAJOR_WHISTLER	// high 16 bits
#define CSVER_MINOR		     CSVER_MINOR_WHISTLER_BETA3	// low 16 bits

// version manipulation
#define CSVER_EXTRACT_MAJOR(version) ((version)>>16)
#define CSVER_EXTRACT_MINOR(version) ((version)&0xffff)
#define CSVER_BUILD_VERSION(major, minor) (((major)<<16)|(minor))

// Keys Under "CertSvc\Configuration":
#define wszREGKEYRESTOREINPROGRESS   TEXT("RestoreInProgress")
#define wszREGKEYDBPARAMETERS	     TEXT("DBParameters")

//======================================================================
// Values Under "CertSvc\Configuration\<CAName>":
#define wszREGCADESCRIPTION          TEXT("CADescription")
#define wszREGCACERTHASH	     TEXT("CACertHash")
#define wszREGCASERIALNUMBER	     TEXT("CACertSerialNumber")
#define wszREGCAXCHGCERTHASH	     TEXT("CAXchgCertHash")
#define wszREGKRACERTHASH	     TEXT("KRACertHash")
#define wszREGKRACERTCOUNT	     TEXT("KRACertCount")
#define wszREGKRAFLAGS		     TEXT("KRAFlags")
#define wszREGCATYPE		     TEXT("CAType")
#define wszREGCERTENROLLCOMPATIBLE   TEXT("CertEnrollCompatible")
#define wszREGENFORCEX500NAMELENGTHS TEXT("EnforceX500NameLengths")
#define wszREGCOMMONNAME	     TEXT("CommonName")
#define wszREGCLOCKSKEWMINUTES	     TEXT("ClockSkewMinutes")

#define wszREGCRLNEXTPUBLISH         TEXT("CRLNextPublish")
#define wszREGCRLPERIODSTRING	     TEXT("CRLPeriod")
#define wszREGCRLPERIODCOUNT	     TEXT("CRLPeriodUnits")
#define wszREGCRLOVERLAPPERIODSTRING TEXT("CRLOverlapPeriod")
#define wszREGCRLOVERLAPPERIODCOUNT  TEXT("CRLOverlapUnits")

#define wszREGCRLDELTANEXTPUBLISH    TEXT("CRLDeltaNextPublish")
#define wszREGCRLDELTAPERIODSTRING   TEXT("CRLDeltaPeriod")
#define wszREGCRLDELTAPERIODCOUNT    TEXT("CRLDeltaPeriodUnits")
#define wszREGCRLDELTAOVERLAPPERIODSTRING TEXT("CRLDeltaOverlapPeriod")
#define wszREGCRLDELTAOVERLAPPERIODCOUNT  TEXT("CRLDeltaOverlapUnits")

#define wszREGCRLPUBLICATIONURLS     TEXT("CRLPublicationURLs")
#define wszREGCACERTPUBLICATIONURLS  TEXT("CACertPublicationURLs")

#define wszREGCAXCHGVALIDITYPERIODSTRING  TEXT("CAXchgValidityPeriod")
#define wszREGCAXCHGVALIDITYPERIODCOUNT   TEXT("CAXchgValidityPeriodUnits")
#define wszREGCAXCHGOVERLAPPERIODSTRING   TEXT("CAXchgOverlapPeriod")
#define wszREGCAXCHGOVERLAPPERIODCOUNT    TEXT("CAXchgOverlapPeriodUnits")

#define wszREGCRLPATH_OLD            TEXT("CRLPath")
#define wszREGCRLEDITFLAGS	     TEXT("CRLEditFlags")
#define wszREGCRLFLAGS		     TEXT("CRLFlags")
#define wszREGCRLATTEMPTREPUBLISH    TEXT("CRLAttemptRepublish")
#define wszREGENABLED		     TEXT("Enabled")
#define wszREGFORCETELETEX           TEXT("ForceTeletex")
#define wszREGLOGLEVEL		     TEXT("LogLevel")
#define wszREGHIGHSERIAL	     TEXT("HighSerial")
#define wszREGPOLICYFLAGS	     TEXT("PolicyFlags")
#define wszREGNAMESEPARATOR          TEXT("SubjectNameSeparator")
#define wszREGSUBJECTTEMPLATE	     TEXT("SubjectTemplate")
#define wszREGCAUSEDS		     TEXT("UseDS")
#define wszREGVALIDITYPERIODSTRING   TEXT("ValidityPeriod")
#define wszREGVALIDITYPERIODCOUNT    TEXT("ValidityPeriodUnits")
#define wszREGPARENTCAMACHINE        TEXT("ParentCAMachine")
#define wszREGPARENTCANAME           TEXT("ParentCAName")
#define wszREGREQUESTFILENAME        TEXT("RequestFileName")
#define wszREGREQUESTID              TEXT("RequestId")
#define wszREGREQUESTKEYCONTAINER    TEXT("RequestKeyContainer")
#define wszREGREQUESTKEYINDEX        TEXT("RequestKeyIndex")
#define wszREGCASERVERNAME           TEXT("CAServerName")
#define wszREGCACERTFILENAME         TEXT("CACertFileName")
#define wszREGCASECURITY             TEXT("Security")
#define wszREGAUDITFILTER            TEXT("AuditFilter")
#define wszREGOFFICERRIGHTS          TEXT("OfficerRights")
#define wszREGMAXINCOMINGMESSAGESIZE TEXT("MaxIncomingMessageSize")
#define wszREGMAXINCOMINGALLOCSIZE   TEXT("MaxIncomingAllocSize")
#define wszREGROLESEPARATIONENABLED  TEXT("RoleSeparationEnabled")
#define wszREGALTERNATEPUBLISHDOMAINS TEXT("AlternatePublishDomains")

#define wszREGSETUPSTATUS            TEXT("SetupStatus")
#define wszREGINTERFACEFLAGS         TEXT("InterfaceFlags")    
#define wszREGDSCONFIGDN	     TEXT("DSConfigDN")    
#define wszREGDSDOMAINDN	     TEXT("DSDomainDN")    
#define wszREGVIEWAGEMINUTES	     TEXT("ViewAgeMinutes")
#define wszREGVIEWIDLEMINUTES	     TEXT("ViewIdleMinutes")


#define wszCRTFILENAMEEXT	     TEXT(".crt")
#define wszPFXFILENAMEEXT	     TEXT(".p12")
#define wszDATFILENAMEEXT	     TEXT(".dat")
#define wszLOGFILENAMEEXT	     TEXT(".log")
#define wszDBFILENAMEEXT	     TEXT(".edb")
#define szDBBASENAMEPARM	     "edb"
#define wszDBBASENAMEPARM	     TEXT(szDBBASENAMEPARM)
#define wszLOGPATH		     TEXT("CertLog")
#define wszDBBACKUPSUBDIR	     TEXT("DataBase")
#define wszDBBACKUPCERTBACKDAT	     TEXT("certbkxp.dat")

#ifndef __ENUM_CATYPES__
#define __ENUM_CATYPES__

// Values for wszREGCATYPE:
typedef enum {
    ENUM_ENTERPRISE_ROOTCA = 0,
    ENUM_ENTERPRISE_SUBCA = 1,
    //ENUM_UNUSED2 = 2,
    ENUM_STANDALONE_ROOTCA = 3,
    ENUM_STANDALONE_SUBCA = 4,
    ENUM_UNKNOWN_CA = 5,
} ENUM_CATYPES;

typedef struct _CAINFO
{
    DWORD   cbSize;
    ENUM_CATYPES CAType;
    DWORD   cCASignatureCerts;
    DWORD   cCAExchangeCerts;
    DWORD   cExitModules;
    LONG    lPropIdMax;
    LONG    lRoleSeparationEnabled;
    DWORD   cKRACertUsedCount;
    DWORD   cKRACertCount;
    DWORD   fAdvancedServer;   
} CAINFO;

#endif __ENUM_CATYPES__

// Default value for wszREGCLOCKSKEWMINUTES
#define CCLOCKSKEWMINUTESDEFAULT	      10


// Default value for wszREGVIEWAGEMINUTES, wszREGVIEWIDLEMINUTES
#define CVIEWAGEMINUTESDEFAULT			16
#define CVIEWIDLEMINUTESDEFAULT			(CVIEWAGEMINUTESDEFAULT / 2)

// Default validity period for ROOT CA certs:
#define dwVALIDITYPERIODCOUNTDEFAULT_ROOT	5

// Default validity periods for certs issued by a CA:
#define dwVALIDITYPERIODCOUNTDEFAULT_ENTERPRISE	2
#define dwVALIDITYPERIODCOUNTDEFAULT_STANDALONE	1
#define dwVALIDITYPERIODENUMDEFAULT	      ENUM_PERIOD_YEARS
#define wszVALIDITYPERIODSTRINGDEFAULT	      wszPERIODYEARS

#define dwCAXCHGVALIDITYPERIODCOUNTDEFAULT    1
#define dwCAXCHGVALIDITYPERIODENUMDEFAULT     ENUM_PERIOD_WEEKS
#define wszCAXCHGVALIDITYPERIODSTRINGDEFAULT  wszPERIODWEEKS

#define dwCAXCHGOVERLAPPERIODCOUNTDEFAULT     1
#define dwCAXCHGOVERLAPPERIODENUMDEFAULT      ENUM_PERIOD_DAYS
#define wszCAXCHGOVERLAPPERIODSTRINGDEFAULT   wszPERIODDAYS

#define dwCRLPERIODCOUNTDEFAULT		      1
#define wszCRLPERIODSTRINGDEFAULT	      wszPERIODWEEKS

#define dwCRLOVERLAPPERIODCOUNTDEFAULT	      0		// 0 --> disabled
#define wszCRLOVERLAPPERIODSTRINGDEFAULT      wszPERIODHOURS

#define dwCRLDELTAPERIODCOUNTDEFAULT          1
#define wszCRLDELTAPERIODSTRINGDEFAULT        wszPERIODDAYS

#define dwCRLDELTAOVERLAPPERIODCOUNTDEFAULT   0		// 0 --> disabled
#define wszCRLDELTAOVERLAPPERIODSTRINGDEFAULT wszPERIODMINUTES


// Values for wszREGLOGLEVEL:
#define CERTLOG_MINIMAL		(DWORD) 0
#define CERTLOG_TERSE		(DWORD) 1
#define CERTLOG_ERROR		(DWORD) 2
#define CERTLOG_WARNING		(DWORD) 3
#define CERTLOG_VERBOSE		(DWORD) 4
#define CERTLOG_EXHAUSTIVE	(DWORD) 5


// Values for wszREGSETUPSTATUS:
#define SETUP_SERVER_FLAG		0x00000001	// server installed
#define SETUP_CLIENT_FLAG		0x00000002	// client installed
#define SETUP_SUSPEND_FLAG		0x00000004	// incomplete install
#define SETUP_REQUEST_FLAG		0x00000008	// new cert requested
#define SETUP_ONLINE_FLAG		0x00000010	// requested online
#define SETUP_DENIED_FLAG		0x00000020	// request denied
#define SETUP_CREATEDB_FLAG		0x00000040	// create new DB
#define SETUP_ATTEMPT_VROOT_CREATE	0x00000080	// try to create vroots
#define SETUP_FORCECRL_FLAG		     0x00000100	// force new CRL(s)
#define SETUP_UPDATE_CAOBJECT_SVRTYPE	     0x00000200	// add server type to CA DS object "flags" attr
#define SETUP_SERVER_UPGRADED_FLAG	     0x00000400	// server was upgraded
#define SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG 0x00000800 // still need to upgrade security
#define SETUP_SECURITY_CHANGED          0x00001000 // permissons changed while CA was down, certsrv will
                                                   // need to update DS & service when it restarts

// Values for wszREGCRLFLAGS:
#define CRLF_DELTA_USE_OLDEST_UNEXPIRED_BASE	0x00000001 // use oldest base:
// else use newest base CRL that satisfies base CRL propagation delay

#define CRLF_DELETE_EXPIRED_CRLS		0x00000002
#define CRLF_CRLNUMBER_CRITICAL			0x00000004
#define CRLF_REVCHECK_IGNORE_OFFLINE		0x00000008
#define CRLF_IGNORE_INVALID_POLICIES		0x00000010
#define CRLF_REBUILD_MODIFIED_SUBJECT_ONLY	0x00000020
#define CRLF_SAVE_FAILED_CERTS			0x00000040
#define CRLF_IGNORE_UNKNOWN_CMC_ATTRIBUTES	0x00000080
#define CRLF_IGNORE_CROSS_CERT_TRUST_ERROR	0x00000100
#define CRLF_PUBLISH_EXPIRED_CERT_CRLS		0x00000200
#define CRLF_ENFORCE_ENROLLMENT_AGENT		0x00000400
#define CRLF_DISABLE_RDN_REORDER		0x00000800
#define CRLF_DISABLE_ROOT_CROSS_CERTS		0x00001000
#define CRLF_LOG_FULL_RESPONSE	     0x00002000 // hex dump response to console
#define CRLF_USE_XCHG_CERT_TEMPLATE  0x00004000 // enforce xchg template access
#define CRLF_USE_CROSS_CERT_TEMPLATE 0x00008000 // enforce cross template access
#define CRLF_ALLOW_REQUEST_ATTRIBUTE_SUBJECT	0x00010000
#define CRLF_REVCHECK_IGNORE_NOREVCHECK		0x00020000
#define CRLF_PRESERVE_EXPIRED_CA_CERTS		0x00040000
#define CRLF_PRESERVE_REVOKED_CA_CERTS		0x00080000

// Values for wszREGKRAFLAGS:
#define KRAF_ENABLEFOREIGN	0x00000001 // allow foreign cert, key archival
#define KRAF_SAVEBADREQUESTKEY	0x00000002 // save failed request w/archived key
#define KRAF_ENABLEARCHIVEALL	0x00000004

// Values for wszREGINTERFACEFLAGS:
#define IF_LOCKICERTREQUEST		0x00000001
#define IF_NOREMOTEICERTREQUEST		0x00000002
#define IF_NOLOCALICERTREQUEST		0x00000004
#define IF_NORPCICERTREQUEST		0x00000008
#define IF_NOREMOTEICERTADMIN		0x00000010
#define IF_NOLOCALICERTADMIN		0x00000020
#define IF_NOREMOTEICERTADMINBACKUP	0x00000040
#define IF_NOLOCALICERTADMINBACKUP	0x00000080
#define IF_NOSNAPSHOTBACKUP		0x00000100
#define IF_ENFORCEENCRYPTICERTREQUEST   0x00000200
#define IF_ENFORCEENCRYPTICERTADMIN     0x00000400

#define IF_DEFAULT			(IF_NOREMOTEICERTADMINBACKUP)

// Values for numeric prefixes for
// wszREGCRLPUBLICATIONURLS and wszREGCACERTPUBLICATIONURLS:
//
// URL publication template Flags values, encoded as a decimal prefix for URL
// publication templates in the registry:
//   "1:c:\winnt\System32\CertSrv\CertEnroll\MyCA.crl"
//   "2:http:\//MyServer.MyDomain.com/CertEnroll\MyCA.crl"

#define CSURL_SERVERPUBLISH	 0x00000001
#define CSURL_ADDTOCERTCDP	 0x00000002
#define CSURL_ADDTOFRESHESTCRL	 0x00000004
#define CSURL_ADDTOCRLCDP	 0x00000008
#define CSURL_PUBLISHRETRY	 0x00000010
#define CSURL_ADDTOCERTOCSP	 0x00000020
#define CSURL_SERVERPUBLISHDELTA 0x00000040
//======================================================================
// Keys Under "CertSvc\Configuration\<CAName>":
#define wszREGKEYCSP			TEXT("CSP")
#define wszREGKEYENCRYPTIONCSP		TEXT("EncryptionCSP")
#define wszREGKEYEXITMODULES		TEXT("ExitModules")
#define wszREGKEYPOLICYMODULES	        TEXT("PolicyModules")
#define wszSECUREDATTRIBUTES		TEXT("SignedAttributes")

#define wszzDEFAULTSIGNEDATTRIBUTES     TEXT("RequesterName\0")

//======================================================================
// Values Under "CertSvc\Configuration\RestoreInProgress":
#define wszREGBACKUPLOGDIRECTORY	TEXT("BackupLogDirectory")
#define wszREGCHECKPOINTFILE		TEXT("CheckPointFile")
#define wszREGHIGHLOGNUMBER		TEXT("HighLogNumber")
#define wszREGLOWLOGNUMBER		TEXT("LowLogNumber")
#define wszREGLOGPATH			TEXT("LogPath")
#define wszREGRESTOREMAPCOUNT		TEXT("RestoreMapCount")
#define wszREGRESTOREMAP		TEXT("RestoreMap")
#define wszREGDATABASERECOVERED		TEXT("DatabaseRecovered")
#define wszREGRESTORESTATUS		TEXT("RestoreStatus")

// values under \Configuration\PolicyModules in nt5 beta 2
#define wszREGB2ICERTMANAGEMODULE   TEXT("ICertManageModule")
// values under \Configuration in nt4 sp4
#define wszREGSP4DEFAULTCONFIGURATION  TEXT("DefaultConfiguration")
// values under ca in nt4 sp4
#define wszREGSP4KEYSETNAME            TEXT("KeySetName")
#define wszREGSP4SUBJECTNAMESEPARATOR  TEXT("SubjectNameSeparator")
#define wszREGSP4NAMES                 TEXT("Names")
#define wszREGSP4QUERIES               TEXT("Queries")
// both nt4 sp4 and nt5 beta 2
#define wszREGNETSCAPECERTTYPE         TEXT("NetscapeCertType")
#define wszNETSCAPEREVOCATIONTYPE      TEXT("Netscape")


//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\CSP":
// and "CertSvc\Configuration\<CAName>\EncryptionCSP":
#define wszREGPROVIDERTYPE     TEXT("ProviderType")
#define wszREGPROVIDER         TEXT("Provider")
#define wszHASHALGORITHM       TEXT("HashAlgorithm")
#define wszENCRYPTIONALGORITHM TEXT("EncryptionAlgorithm")
#define wszMACHINEKEYSET       TEXT("MachineKeyset")
#define wszREGKEYSIZE	       TEXT("KeySize")


//======================================================================
// Value strings for "CertSvc\Configuration\<CAName>\SubjectNameSeparator":
#define szNAMESEPARATORDEFAULT   "\n"
#define wszNAMESEPARATORDEFAULT   TEXT(szNAMESEPARATORDEFAULT)


//======================================================================
// Value strings for "CertSvc\Configuration\<CAName>\ValidityPeriod", etc.:
#define wszPERIODYEARS		TEXT("Years")
#define wszPERIODMONTHS		TEXT("Months")
#define wszPERIODWEEKS		TEXT("Weeks")
#define wszPERIODDAYS		TEXT("Days")
#define wszPERIODHOURS		TEXT("Hours")
#define wszPERIODMINUTES	TEXT("Minutes")
#define wszPERIODSECONDS	TEXT("Seconds")

//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\PolicyModules\<ProgId>":
#define wszREGISSUERCERTURLFLAGS    TEXT("IssuerCertURLFlags")
#define wszREGEDITFLAGS		    TEXT("EditFlags")
#define wszREGSUBJECTALTNAME	    TEXT("SubjectAltName")
#define wszREGSUBJECTALTNAME2	    TEXT("SubjectAltName2")
#define wszREGREQUESTDISPOSITION    TEXT("RequestDisposition")
#define wszREGCAPATHLENGTH	    TEXT("CAPathLength")
#define wszREGREVOCATIONTYPE	    TEXT("RevocationType")

#define wszREGLDAPREVOCATIONCRLURL_OLD	TEXT("LDAPRevocationCRLURL")
#define wszREGREVOCATIONCRLURL_OLD	TEXT("RevocationCRLURL")
#define wszREGFTPREVOCATIONCRLURL_OLD	TEXT("FTPRevocationCRLURL")
#define wszREGFILEREVOCATIONCRLURL_OLD	TEXT("FileRevocationCRLURL")

#define wszREGREVOCATIONURL		TEXT("RevocationURL")

#define wszREGLDAPISSUERCERTURL_OLD	TEXT("LDAPIssuerCertURL")
#define wszREGISSUERCERTURL_OLD		TEXT("IssuerCertURL")
#define wszREGFTPISSUERCERTURL_OLD	TEXT("FTPIssuerCertURL")
#define wszREGFILEISSUERCERTURL_OLD	TEXT("FileIssuerCertURL")

#define wszREGENABLEREQUESTEXTENSIONLIST  TEXT("EnableRequestExtensionList")
#define wszREGENABLEENROLLEEREQUESTEXTENSIONLIST  TEXT("EnableEnrolleeRequestExtensionList")
#define wszREGDISABLEEXTENSIONLIST  TEXT("DisableExtensionList")

#define wszREGDEFAULTSMIME		TEXT("DefaultSMIME")

// wszREGCAPATHLENGTH Values:
#define CAPATHLENGTH_INFINITE		0xffffffff

// wszREGREQUESTDISPOSITION Values:
#define REQDISP_PENDING			0x00000000
#define REQDISP_ISSUE			0x00000001
#define REQDISP_DENY			0x00000002
#define REQDISP_USEREQUESTATTRIBUTE	0x00000003
#define REQDISP_MASK			0x000000ff
#define REQDISP_PENDINGFIRST		0x00000100
#define REQDISP_DEFAULT_STANDALONE	(REQDISP_PENDINGFIRST | REQDISP_ISSUE)
#define REQDISP_DEFAULT_ENTERPRISE	(REQDISP_ISSUE)

// wszREGREVOCATIONTYPE Values:
#define REVEXT_CDPLDAPURL_OLD		0x00000001
#define REVEXT_CDPHTTPURL_OLD		0x00000002
#define REVEXT_CDPFTPURL_OLD		0x00000004
#define REVEXT_CDPFILEURL_OLD		0x00000008
#define REVEXT_CDPURLMASK_OLD		0x000000ff
#define REVEXT_CDPENABLE		0x00000100
#define REVEXT_ASPENABLE		0x00000200

#define REVEXT_DEFAULT_NODS		(REVEXT_CDPENABLE)
#define REVEXT_DEFAULT_DS		(REVEXT_CDPENABLE)

// wszREGISSUERCERTURLFLAGS Values:
#define ISSCERT_LDAPURL_OLD		0x00000001
#define ISSCERT_HTTPURL_OLD		0x00000002
#define ISSCERT_FTPURL_OLD		0x00000004
#define ISSCERT_FILEURL_OLD		0x00000008
#define ISSCERT_URLMASK_OLD		0x000000ff
#define ISSCERT_ENABLE			0x00000100

#define ISSCERT_DEFAULT_NODS		(ISSCERT_ENABLE)
#define ISSCERT_DEFAULT_DS		(ISSCERT_ENABLE)

// wszREGEDITFLAGS Values:				   Defaults:
// Under CA key: wszREGCRLEDITFLAGS Values (EDITF_ENABLEAKI* only):
#define EDITF_ENABLEREQUESTEXTENSIONS	0x00000001	// neither
#define EDITF_REQUESTEXTENSIONLIST	0x00000002	// both
#define EDITF_DISABLEEXTENSIONLIST	0x00000004	// both
#define EDITF_ADDOLDKEYUSAGE		0x00000008	// both
#define EDITF_ADDOLDCERTTYPE		0x00000010	// neither
#define EDITF_ATTRIBUTEENDDATE		0x00000020	// Standalone
#define EDITF_BASICCONSTRAINTSCRITICAL	0x00000040	// both
#define EDITF_BASICCONSTRAINTSCA	0x00000080	// Standalone
#define EDITF_ENABLEAKIKEYID		0x00000100	// both
#define EDITF_ATTRIBUTECA		0x00000200	// Standalone
#define EDITF_IGNOREREQUESTERGROUP      0x00000400	// neither
#define EDITF_ENABLEAKIISSUERNAME	0x00000800	// neither
#define EDITF_ENABLEAKIISSUERSERIAL	0x00001000	// neither
#define EDITF_ENABLEAKICRITICAL		0x00002000	// neither
#define EDITF_SERVERUPGRADED		0x00004000	// neither
#define EDITF_ATTRIBUTEEKU		0x00008000	// Standalone
#define EDITF_ENABLEDEFAULTSMIME	0x00010000	// Enterprise
#define EDITF_EMAILOPTIONAL		0x00020000	// neither
#define EDITF_ATTRIBUTESUBJECTALTNAME2	0x00040000	// neither
#define EDITF_ENABLELDAPREFERRALS	0x00080000	// neither
#define EDITF_ENABLECHASECLIENTDC	0x00100000	// Enterprise

#define EDITF_DEFAULT_STANDALONE	(EDITF_REQUESTEXTENSIONLIST | \
					 EDITF_DISABLEEXTENSIONLIST | \
					 EDITF_ADDOLDKEYUSAGE | \
					 EDITF_ATTRIBUTEENDDATE | \
					 EDITF_BASICCONSTRAINTSCRITICAL | \
					 EDITF_BASICCONSTRAINTSCA | \
					 EDITF_ENABLEAKIKEYID | \
					 EDITF_ATTRIBUTECA | \
					 EDITF_ATTRIBUTEEKU)

#define EDITF_DEFAULT_ENTERPRISE	(EDITF_REQUESTEXTENSIONLIST | \
					 EDITF_DISABLEEXTENSIONLIST | \
					 EDITF_ADDOLDKEYUSAGE | \
                                         EDITF_BASICCONSTRAINTSCRITICAL | \
                                         EDITF_ENABLEAKIKEYID | \
					 EDITF_ENABLEDEFAULTSMIME | \
					 EDITF_ENABLECHASECLIENTDC)


//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\ExitModules\<ProgId>":

// LDAP based CRL and URL issuance
#define wszREGLDAPREVOCATIONDN_OLD	   TEXT("LDAPRevocationDN")
#define wszREGLDAPREVOCATIONDNTEMPLATE_OLD TEXT("LDAPRevocationDNTemplate")
#define wszCRLPUBLISHRETRYCOUNT    TEXT("CRLPublishRetryCount")
#define wszREGCERTPUBLISHFLAGS     TEXT("PublishCertFlags")

// wszREGCERTPUBLISHFLAGS Values:
#define EXITPUB_FILE			0x00000001
#define EXITPUB_ACTIVEDIRECTORY		0x00000002
#define EXITPUB_REMOVEOLDCERTS		0x00000010

#define EXITPUB_DEFAULT_ENTERPRISE	EXITPUB_ACTIVEDIRECTORY

#define EXITPUB_DEFAULT_STANDALONE	EXITPUB_FILE


#define wszCLASS_CERTADMIN	  TEXT("CertificateAuthority.Admin")
#define wszCLASS_CERTCONFIG	  TEXT("CertificateAuthority.Config")
#define wszCLASS_CERTGETCONFIG	  TEXT("CertificateAuthority.GetConfig")
#define wszCLASS_CERTENCODE	  TEXT("CertificateAuthority.Encode")
#define wszCLASS_CERTREQUEST	  TEXT("CertificateAuthority.Request")
#define wszCLASS_CERTSERVEREXIT   TEXT("CertificateAuthority.ServerExit")
#define wszCLASS_CERTSERVERPOLICY TEXT("CertificateAuthority.ServerPolicy")
#define wszCLASS_CERTVIEW	  TEXT("CertificateAuthority.View")

// class name templates
#define wszMICROSOFTCERTMODULE_PREFIX  TEXT("CertificateAuthority_MicrosoftDefault") 
#define wszCERTMANAGE_SUFFIX TEXT("Manage")
#define wszCERTEXITMODULE_POSTFIX	TEXT(".Exit")
#define wszCERTMANAGEEXIT_POSTFIX	wszCERTEXITMODULE_POSTFIX wszCERTMANAGE_SUFFIX
#define wszCERTPOLICYMODULE_POSTFIX	TEXT(".Policy")
#define wszCERTMANAGEPOLICY_POSTFIX	wszCERTPOLICYMODULE_POSTFIX wszCERTMANAGE_SUFFIX


// actual policy/exit manage class names
#define wszCLASS_CERTMANAGEEXITMODULE   wszMICROSOFTCERTMODULE_PREFIX wszCERTMANAGEEXIT_POSTFIX 

#define wszCLASS_CERTMANAGEPOLICYMODULE wszMICROSOFTCERTMODULE_PREFIX wszCERTMANAGEPOLICY_POSTFIX 

// actual policy/exit class names
#define wszCLASS_CERTEXIT	wszMICROSOFTCERTMODULE_PREFIX wszCERTEXITMODULE_POSTFIX

#define wszCLASS_CERTPOLICY	wszMICROSOFTCERTMODULE_PREFIX wszCERTPOLICYMODULE_POSTFIX


#define wszCAPOLICYFILE			L"CAPolicy.inf"

#define wszINFSECTION_CDP		L"CRLDistributionPoint"
#define wszINFSECTION_AIA		L"AuthorityInformationAccess"
#define wszINFSECTION_EKU		L"EnhancedKeyUsageExtension"
#define wszINFSECTION_CCDP		L"CrossCertificateDistributionPointsExtension"

#define wszINFSECTION_CERTSERVER	L"certsrv_server"
#define wszINFKEY_RENEWALKEYLENGTH	L"RenewalKeyLength"
#define wszINFKEY_RENEWALVALIDITYPERIODSTRING	L"RenewalValidityPeriod"
#define wszINFKEY_RENEWALVALIDITYPERIODCOUNT	L"RenewalValidityPeriodUnits"
#define wszINFKEY_UTF8			L"UTF8"
#define wszINFKEY_CRLPERIODSTRING	wszREGCRLPERIODSTRING
#define wszINFKEY_CRLPERIODCOUNT	wszREGCRLPERIODCOUNT
#define wszINFKEY_CRLDELTAPERIODSTRING	wszREGCRLDELTAPERIODSTRING
#define wszINFKEY_CRLDELTAPERIODCOUNT	wszREGCRLDELTAPERIODCOUNT
#define wszINFKEY_LOADDEFAULTTEMPLATES  L"LoadDefaultTemplates"
#define wszINFKEY_ENABLEKEYCOUNTING     L"EnableKeyCounting"

#define wszINFKEY_CRITICAL		L"Critical"
#define wszINFKEY_EMPTY			L"Empty"

#define wszINFKEY_CCDPSYNCDELTATIME	L"SyncDeltaTime"

#define wszINFSECTION_CAPOLICY		L"CAPolicy"
#define wszINFSECTION_POLICYSTATEMENT	L"PolicyStatementExtension"
#define wszINFSECTION_APPLICATIONPOLICYSTATEMENT	L"ApplicationPolicyStatementExtension"
#define wszINFKEY_POLICIES		L"Policies"
#define wszINFKEY_OID			L"OID"
#define wszINFKEY_NOTICE		L"Notice"

#define wszINFSECTION_REQUESTATTRIBUTES	L"RequestAttributes"

#define wszINFSECTION_NAMECONSTRAINTS	L"NameConstraintsExtension"
#define wszINFKEY_INCLUDE		L"Include"
#define wszINFKEY_EXCLUDE		L"Exclude"

#define wszINFKEY_UPN			L"UPN"
#define wszINFKEY_EMAIL			L"EMail"
#define wszINFKEY_DNS			L"DNS"
#define wszINFKEY_DIRECTORYNAME		L"DirectoryName"
#define wszINFKEY_URL			L"URL"
#define wszINFKEY_IPADDRESS		L"IPAddress"
#define wszINFKEY_REGISTEREDID		L"RegisteredId"
#define wszINFKEY_OTHERNAME		L"OtherName"

#define wszINFSECTION_POLICYMAPPINGS	L"PolicyMappingsExtension"
#define wszINFSECTION_APPLICATIONPOLICYMAPPINGS	L"ApplicationPolicyMappingsExtension"

#define wszINFSECTION_POLICYCONSTRAINTS	L"PolicyConstraintsExtension"
#define wszINFSECTION_APPLICATIONPOLICYCONSTRAINTS	L"ApplicationPolicyConstraintsExtension"
#define wszINFKEY_REQUIREEXPLICITPOLICY	L"RequireExplicitPolicy"
#define wszINFKEY_INHIBITPOLICYMAPPING	L"InhibitPolicyMapping"

#define wszINFSECTION_BASICCONSTRAINTS	L"BasicConstraintsExtension"
#define wszINFKEY_PATHLENGTH		L"PathLength"

//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\ExitModules\CertificateAuthority_MicrosoftDefault.Exit\SMTP":
//
// exit module mail support
//
#define wszREGEXITSMTPKEY	    	L"SMTP"
#define wszREGEXITSMTPTEMPLATES		L"Templates"
#define wszREGEXITSMTPEVENTFILTER	L"EventFilter"
#define wszREGEXITSMTPSERVER		L"SMTPServer"
#define wszREGEXITSMTPAUTHENTICATE	L"SMTPAuthenticate"

// Subkeys:
#define wszREGEXITDENIEDKEY		L"Denied"
#define wszREGEXITISSUEDKEY		L"Issued"
#define wszREGEXITPENDINGKEY		L"Pending"
#define wszREGEXITREVOKEDKEY		L"Revoked"
#define wszREGEXITCRLISSUEDKEY		L"CRLIssued"
#define wszREGEXITSHUTDOWNKEY		L"Shutdown"
#define wszREGEXITSTARTUPKEY		L"Startup"

//======================================================================
// Values Under 
// "CertSvc\Configuration\<CAName>\ExitModules\CertificateAuthority_MicrosoftDefault.Exit\SMTP\Issued| 
// Pending|Denied|Revoked|CRLIssued|Shutdown":
#define wszREGEXITSMTPFROM		L"From"
#define wszREGEXITSMTPTO		L"To"
#define wszREGEXITSMTPCC		L"Cc"
#define wszREGEXITTITLEFORMAT		L"TitleFormat"
#define wszREGEXITTITLEARG		L"TitleArg"
#define wszREGEXITBODYFORMAT		L"BodyFormat"
#define wszREGEXITBODYARG		L"BodyArg"

#define wszREGEXITPROPNOTFOUND		L"???"


//+--------------------------------------------------------------------------
// Name properties:

#define wszPROPDISTINGUISHEDNAME   TEXT("DistinguishedName")
#define wszPROPRAWNAME             TEXT("RawName")

#define wszPROPCOUNTRY             TEXT("Country")
#define wszPROPORGANIZATION        TEXT("Organization")
#define wszPROPORGUNIT             TEXT("OrgUnit")
#define wszPROPCOMMONNAME          TEXT("CommonName")
#define wszPROPLOCALITY            TEXT("Locality")
#define wszPROPSTATE               TEXT("State")
#define wszPROPTITLE               TEXT("Title")
#define wszPROPGIVENNAME           TEXT("GivenName")
#define wszPROPINITIALS            TEXT("Initials")
#define wszPROPSURNAME             TEXT("SurName")
#define wszPROPDOMAINCOMPONENT     TEXT("DomainComponent")
#define wszPROPEMAIL               TEXT("EMail")
#define wszPROPSTREETADDRESS       TEXT("StreetAddress")
#define wszPROPUNSTRUCTUREDNAME    TEXT("UnstructuredName")
#define wszPROPUNSTRUCTUREDADDRESS TEXT("UnstructuredAddress")
#define wszPROPDEVICESERIALNUMBER  TEXT("DeviceSerialNumber")

//+--------------------------------------------------------------------------
// Subject Name properties:

#define wszPROPSUBJECTDOT	    TEXT("Subject.")
#define wszPROPSUBJECTDISTINGUISHEDNAME \
				    wszPROPSUBJECTDOT wszPROPDISTINGUISHEDNAME
#define wszPROPSUBJECTRAWNAME       wszPROPSUBJECTDOT wszPROPRAWNAME

#define wszPROPSUBJECTCOUNTRY       wszPROPSUBJECTDOT wszPROPCOUNTRY
#define wszPROPSUBJECTORGANIZATION  wszPROPSUBJECTDOT wszPROPORGANIZATION
#define wszPROPSUBJECTORGUNIT       wszPROPSUBJECTDOT wszPROPORGUNIT
#define wszPROPSUBJECTCOMMONNAME    wszPROPSUBJECTDOT wszPROPCOMMONNAME
#define wszPROPSUBJECTLOCALITY      wszPROPSUBJECTDOT wszPROPLOCALITY
#define wszPROPSUBJECTSTATE         wszPROPSUBJECTDOT wszPROPSTATE
#define wszPROPSUBJECTTITLE	    wszPROPSUBJECTDOT wszPROPTITLE
#define wszPROPSUBJECTGIVENNAME	    wszPROPSUBJECTDOT wszPROPGIVENNAME
#define wszPROPSUBJECTINITIALS	    wszPROPSUBJECTDOT wszPROPINITIALS
#define wszPROPSUBJECTSURNAME	    wszPROPSUBJECTDOT wszPROPSURNAME
#define wszPROPSUBJECTDOMAINCOMPONENT wszPROPSUBJECTDOT wszPROPDOMAINCOMPONENT
#define wszPROPSUBJECTEMAIL	    wszPROPSUBJECTDOT wszPROPEMAIL
#define wszPROPSUBJECTSTREETADDRESS wszPROPSUBJECTDOT wszPROPSTREETADDRESS
#define wszPROPSUBJECTUNSTRUCTUREDNAME wszPROPSUBJECTDOT wszPROPUNSTRUCTUREDNAME
#define wszPROPSUBJECTUNSTRUCTUREDADDRESS wszPROPSUBJECTDOT wszPROPUNSTRUCTUREDADDRESS
#define wszPROPSUBJECTDEVICESERIALNUMBER wszPROPSUBJECTDOT wszPROPDEVICESERIALNUMBER


//+--------------------------------------------------------------------------
// Request properties:
#define wszPROPREQUESTDOT	            TEXT("Request.")

#define wszPROPREQUESTREQUESTID		    TEXT("RequestID")
#define wszPROPREQUESTRAWREQUEST	    TEXT("RawRequest")
#define wszPROPREQUESTRAWARCHIVEDKEY	    TEXT("RawArchivedKey")
#define wszPROPREQUESTKEYRECOVERYHASHES	    TEXT("KeyRecoveryHashes")
#define wszPROPREQUESTRAWOLDCERTIFICATE	    TEXT("RawOldCertificate")
#define wszPROPREQUESTATTRIBUTES	    TEXT("RequestAttributes")
#define wszPROPREQUESTTYPE		    TEXT("RequestType")
#define wszPROPREQUESTFLAGS		    TEXT("RequestFlags")
#define wszPROPREQUESTSTATUSCODE	    TEXT("StatusCode")
#define wszPROPREQUESTDISPOSITION	    TEXT("Disposition")
#define wszPROPREQUESTDISPOSITIONMESSAGE    TEXT("DispositionMessage")
#define wszPROPREQUESTSUBMITTEDWHEN	    TEXT("SubmittedWhen")
#define wszPROPREQUESTRESOLVEDWHEN	    TEXT("ResolvedWhen")
#define wszPROPREQUESTREVOKEDWHEN	    TEXT("RevokedWhen")
#define wszPROPREQUESTREVOKEDEFFECTIVEWHEN  TEXT("RevokedEffectiveWhen")
#define wszPROPREQUESTREVOKEDREASON	    TEXT("RevokedReason")
#define wszPROPREQUESTERNAME		    TEXT("RequesterName")
#define wszPROPCALLERNAME		    TEXT("CallerName")
#define wszPROPSIGNERPOLICIES		    TEXT("SignerPolicies")
#define wszPROPSIGNERAPPLICATIONPOLICIES    TEXT("SignerApplicationPolicies")
#define wszPROPOFFICER			    TEXT("Officer")

//+--------------------------------------------------------------------------
// Request attribute properties:

#define wszPROPCHALLENGE		TEXT("Challenge")
#define wszPROPEXPECTEDCHALLENGE	TEXT("ExpectedChallenge")

#define wszPROPDISPOSITION		TEXT("Disposition")
#define wszPROPDISPOSITIONDENY		TEXT("Deny")
#define wszPROPDISPOSITIONPENDING	TEXT("Pending")

#define wszPROPVALIDITYPERIODSTRING	TEXT("ValidityPeriod")
#define wszPROPVALIDITYPERIODCOUNT	TEXT("ValidityPeriodUnits")

#define wszPROPCERTTYPE			TEXT("CertType")
#define wszPROPCERTTEMPLATE		TEXT("CertificateTemplate")
#define wszPROPCERTUSAGE		TEXT("CertificateUsage")

#define wszPROPREQUESTOSVERSION		TEXT("RequestOSVersion")
#define wszPROPREQUESTCSPPROVIDER       TEXT("RequestCSPProvider")

#define wszPROPEXITCERTFILE		TEXT("CertFile")
#define wszPROPCLIENTBROWSERMACHINE	TEXT("cbm")
#define wszPROPCERTCLIENTMACHINE	TEXT("ccm")
#define wszPROPCLIENTDCDNS		L"cdc"
#define wszPROPREQUESTMACHINEDNS	L"rmd"
#define wszPROPSUBJECTALTNAME2		TEXT("san")
#define wszPROPDNS			TEXT("dns")
#define wszPROPDN			TEXT("dn")
#define wszPROPURL			TEXT("url")
#define wszPROPIPADDRESS		TEXT("ipaddress")
#define wszPROPGUID			TEXT("guid")
#define wszPROPOID			TEXT("oid")
#define wszPROPUPN			TEXT("upn")
#define wszPROPUPN			TEXT("upn")

#define szPROPASNTAG			"{asn}"

#define wszPROPUTF8TAG			TEXT("{utf8}")
#define wszPROPOCTETTAG			TEXT("{octet}")
#define wszPROPASNTAG			TEXT(szPROPASNTAG)


//+--------------------------------------------------------------------------
// "System" properties
// ".#" means ".0", ".1", ".2" ... may be appended to the property name to
// collect context specific values.  For some properties, the suffix selects
// the CA certificate context.  For others, it selects the the CA CRL context.

#define wszPROPCATYPE                   TEXT("CAType")
#define wszPROPSANITIZEDCANAME          TEXT("SanitizedCAName")
#define wszPROPSANITIZEDSHORTNAME       TEXT("SanitizedShortName")
#define wszPROPMACHINEDNSNAME           TEXT("MachineDNSName")
#define wszPROPMODULEREGLOC             TEXT("ModuleRegistryLocation")
#define wszPROPUSEDS                    TEXT("fUseDS")
#define wszPROPDELTACRLSDISABLED        TEXT("fDeltaCRLsDisabled")
#define wszPROPSERVERUPGRADED           TEXT("fServerUpgraded")
#define wszPROPCONFIGDN			TEXT("ConfigDN")
#define wszPROPDOMAINDN			TEXT("DomainDN")
#define wszPROPLOGLEVEL			TEXT("LogLevel")
#define wszPROPSESSIONCOUNT		TEXT("SessionCount")
#define wszPROPTEMPLATECHANGESEQUENCENUMBER TEXT("TemplateChangeSequenceNumber")

// Request Context properties:

#define wszPROPREQUESTERCAACCESS	TEXT("RequesterCAAccess")
#define wszPROPUSERDN			TEXT("UserDN")
#define wszPROPKEYARCHIVED		TEXT("KeyArchived")


// CA Certificate properties: (all ".#" extensible except wszPROPCERTCOUNT)

#define wszPROPCERTCOUNT                TEXT("CertCount")
#define wszPROPRAWCACERTIFICATE         TEXT("RawCACertificate")
#define wszPROPCERTSTATE                TEXT("CertState")
#define wszPROPCERTSUFFIX               TEXT("CertSuffix")

// CA CRL properties: (all ".#" extensible)

#define wszPROPRAWCRL                   TEXT("RawCRL")
#define wszPROPRAWDELTACRL              TEXT("RawDeltaCRL")
#define wszPROPCRLINDEX                 TEXT("CRLIndex")
#define wszPROPCRLSTATE                 TEXT("CRLState")
#define wszPROPCRLSUFFIX                TEXT("CRLSuffix")

// Values for wszPROPCERTSTATE (see certadm.h):
//   CA_DISP_REVOKED    // This Cert has been revoked.
//   CA_DISP_VALID      // This Cert is still valid
//   CA_DISP_INVALID    // This Cert has expired.
//   CA_DISP_ERROR      // Cert unavailable (placehholder in registry?)

// Values for wszPROPCRLSTATE (see certadm.h):
//   CA_DISP_REVOKED	// All unexpired certs using this Cert's CRL have been
//			// revoked.
//   CA_DISP_VALID	// This Cert is still publishing CRLs as needed.
//   CA_DISP_INVALID    // All certs using this Cert's CRL are expired.
//   CA_DISP_ERROR      // This Cert's CRL is managed by another Cert.

// "Settable" system properties:
#define wszPROPEVENTLOGTERSE		TEXT("EventLogTerse")
#define wszPROPEVENTLOGERROR		TEXT("EventLogError")
#define wszPROPEVENTLOGWARNING		TEXT("EventLogWarning")
#define wszPROPEVENTLOGVERBOSE		TEXT("EventLogVerbose")
#define wszPROPEVENTLOGEXHAUSTIVE	TEXT("EventLogExhaustive")
#define wszPROPDCNAME			TEXT("DCName")

//+--------------------------------------------------------------------------
// Certificate properties:

#define wszPROPCERTIFICATEREQUESTID	       TEXT("RequestID")
#define wszPROPRAWCERTIFICATE		       TEXT("RawCertificate")
#define wszPROPCERTIFICATEHASH		       TEXT("CertificateHash")
#define wszPROPCERTIFICATETEMPLATE	       TEXT("CertificateTemplate")
#define wszPROPCERTIFICATEENROLLMENTFLAGS      TEXT("EnrollmentFlags")
#define wszPROPCERTIFICATEGENERALFLAGS         TEXT("GeneralFlags")
#define wszPROPCERTIFICATESERIALNUMBER	       TEXT("SerialNumber")
#define wszPROPCERTIFICATENOTBEFOREDATE	       TEXT("NotBefore")
#define wszPROPCERTIFICATENOTAFTERDATE	       TEXT("NotAfter")
#define wszPROPCERTIFICATESUBJECTKEYIDENTIFIER TEXT("SubjectKeyIdentifier")
#define wszPROPCERTIFICATERAWPUBLICKEY	       TEXT("RawPublicKey")
#define wszPROPCERTIFICATEPUBLICKEYLENGTH      TEXT("PublicKeyLength")
#define wszPROPCERTIFICATEPUBLICKEYALGORITHM   TEXT("PublicKeyAlgorithm")
#define wszPROPCERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS \
    TEXT("RawPublicKeyAlgorithmParameters")
#define wszPROPCERTIFICATEUPN		       TEXT("UPN")

// Obsolete:
#define wszPROPCERTIFICATETYPE		       TEXT("CertificateType")
#define wszPROPCERTIFICATERAWSMIMECAPABILITIES TEXT("RawSMIMECapabilities")
#define wszPROPNAMETYPE			       TEXT("NameType")

//+--------------------------------------------------------------------------
// Certificate extension properties:

#define EXTENSION_CRITICAL_FLAG	      0x00000001
#define EXTENSION_DISABLE_FLAG	      0x00000002
#define EXTENSION_POLICY_MASK	      0x0000ffff // Settable by admin+policy

#define EXTENSION_ORIGIN_REQUEST      0x00010000
#define EXTENSION_ORIGIN_POLICY	      0x00020000
#define EXTENSION_ORIGIN_ADMIN	      0x00030000
#define EXTENSION_ORIGIN_SERVER	      0x00040000
#define EXTENSION_ORIGIN_RENEWALCERT  0x00050000
#define EXTENSION_ORIGIN_IMPORTEDCERT 0x00060000
#define EXTENSION_ORIGIN_PKCS7	      0x00070000
#define EXTENSION_ORIGIN_CMC	      0x00080000
#define EXTENSION_ORIGIN_CACERT       0x00090000
#define EXTENSION_ORIGIN_MASK	      0x000f0000

//+--------------------------------------------------------------------------
// Extension properties:

#define wszPROPEXTREQUESTID		TEXT("ExtensionRequestId")
#define wszPROPEXTNAME			TEXT("ExtensionName")
#define wszPROPEXTFLAGS			TEXT("ExtensionFlags")
#define wszPROPEXTRAWVALUE		TEXT("ExtensionRawValue")

//+--------------------------------------------------------------------------
// Attribute properties:

#define wszPROPATTRIBREQUESTID		TEXT("AttributeRequestId")
#define wszPROPATTRIBNAME		TEXT("AttributeName")
#define wszPROPATTRIBVALUE		TEXT("AttributeValue")

//+--------------------------------------------------------------------------
// CRL properties:

#define wszPROPCRLROWID			TEXT("CRLRowId")
#define wszPROPCRLNUMBER		TEXT("CRLNumber")
#define wszPROPCRLMINBASE		TEXT("CRLMinBase") // Delta CRLs only
#define wszPROPCRLNAMEID		TEXT("CRLNameId")
#define wszPROPCRLCOUNT			TEXT("CRLCount")
#define wszPROPCRLTHISUPDATE		TEXT("CRLThisUpdate")
#define wszPROPCRLNEXTUPDATE		TEXT("CRLNextUpdate")
#define wszPROPCRLTHISPUBLISH		TEXT("CRLThisPublish")
#define wszPROPCRLNEXTPUBLISH		TEXT("CRLNextPublish")
#define wszPROPCRLEFFECTIVE		TEXT("CRLEffective")
#define wszPROPCRLPROPAGATIONCOMPLETE	TEXT("CRLPropagationComplete")
#define wszPROPCRLLASTPUBLISHED		TEXT("CRLLastPublished")
#define wszPROPCRLPUBLISHATTEMPTS	TEXT("CRLPublishAttempts")
#define wszPROPCRLPUBLISHFLAGS		TEXT("CRLPublishFlags")
#define wszPROPCRLPUBLISHSTATUSCODE	TEXT("CRLPublishStatusCode")
#define wszPROPCRLPUBLISHERROR		TEXT("CRLPublishError")
#define wszPROPCRLRAWCRL		TEXT("CRLRawCRL")

//+--------------------------------------------------------------------------
// CRL Published Flags:

#define CPF_BASE		0x00000001
#define CPF_DELTA		0x00000002
#define CPF_COMPLETE		0x00000004
#define CPF_SHADOW		0x00000008
#define CPF_CASTORE_ERROR	0x00000010
#define CPF_BADURL_ERROR	0x00000020
#define CPF_MANUAL		0x00000040
#define CPF_SIGNATURE_ERROR	0x00000080
#define CPF_LDAP_ERROR		0x00000100
#define CPF_FILE_ERROR		0x00000200
#define CPF_FTP_ERROR		0x00000400
#define CPF_HTTP_ERROR		0x00000800

//+--------------------------------------------------------------------------
// GetProperty/SetProperty Flags:
//
// Choose one Type

#define PROPTYPE_LONG		 0x00000001	// Signed long
#define PROPTYPE_DATE		 0x00000002	// Date+Time
#define PROPTYPE_BINARY		 0x00000003	// Binary data
#define PROPTYPE_STRING		 0x00000004	// Unicode String
#define PROPTYPE_MASK		 0x000000ff

// Choose one Caller:

#define PROPCALLER_SERVER	 0x00000100
#define PROPCALLER_POLICY	 0x00000200
#define PROPCALLER_EXIT		 0x00000300
#define PROPCALLER_ADMIN	 0x00000400
#define PROPCALLER_REQUEST	 0x00000500
#define PROPCALLER_MASK		 0x00000f00
#define PROPFLAGS_INDEXED	 0x00010000	

// RequestFlags definitions:

#define CR_FLG_FORCETELETEX	 	0x00000001
#define CR_FLG_RENEWAL		 	0x00000002
#define CR_FLG_FORCEUTF8	 	0x00000004
#define CR_FLG_CAXCHGCERT	 	0x00000008
#define CR_FLG_ENROLLONBEHALFOF	 	0x00000010
#define CR_FLG_SUBJECTUNMODIFIED 	0x00000020
#define CR_FLG_VALIDENCRYPTEDKEYHASH	0x00000040
#define CR_FLG_CACROSSCERT		0x00000080
#define CR_FLG_PUBLISHERROR		0x80000000

// Disposition property values:

// Disposition values for requests in the queue:
#define DB_DISP_ACTIVE	        8	// being processed
#define DB_DISP_PENDING		9	// taken under submission
#define DB_DISP_QUEUE_MAX	9	// max disposition value for queue view

#define DB_DISP_FOREIGN		12	// archived foreign cert

#define DB_DISP_CA_CERT		15	// CA cert
#define DB_DISP_CA_CERT_CHAIN	16	// CA cert chain
#define DB_DISP_KRA_CERT	17	// KRA cert

// Disposition values for requests in the log:
#define DB_DISP_LOG_MIN		20	// min disposition value for log view
#define DB_DISP_ISSUED		20	// cert issued
#define DB_DISP_REVOKED	        21	// issued and revoked

// Disposition values for failed requests in the log:
#define DB_DISP_LOG_FAILED_MIN	30	// min disposition value for log view
#define DB_DISP_ERROR		30	// request failed
#define DB_DISP_DENIED		31	// request denied


// VerifyRequest() return values

#define VR_PENDING	0	 // request will be accepted or denied later
#define VR_INSTANT_OK	1	 // request was accepted
#define VR_INSTANT_BAD	2	 // request was rejected


//+--------------------------------------------------------------------------
// Known request Attribute names and Value strings

// RequestType attribute name:
#define wszCERT_TYPE		L"RequestType"	// attribute name

// RequestType attribute values:
// Not specified: 				// Non-specific certificate
#define wszCERT_TYPE_CLIENT	L"Client"	// Client authentication cert
#define wszCERT_TYPE_SERVER	L"Server"	// Server authentication cert
#define wszCERT_TYPE_CODESIGN	L"CodeSign"	// Code signing certificate
#define wszCERT_TYPE_CUSTOMER	L"SetCustomer"	// SET Customer certificate
#define wszCERT_TYPE_MERCHANT	L"SetMerchant"	// SET Merchant certificate
#define wszCERT_TYPE_PAYMENT	L"SetPayment"	// SET Payment certificate


// Version attribute name:
#define wszCERT_VERSION		L"Version"	// attribute name

// Version attribute values:
// Not specified: 				// Whetever is current
#define wszCERT_VERSION_1	L"1"		// Version one certificate
#define wszCERT_VERSION_2	L"2"		// Version two certificate
#define wszCERT_VERSION_3	L"3"		// Version three certificate

#endif // _CERTSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\certmsg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       certmsg.h
//
//--------------------------------------------------------------------------

#ifndef __CERTMSG_H__
#define __CERTMSG_H__

#define CMB_NOERRFROMSYS         0x10000000L
#define CMB_REPEATWIZPREFIX      0x20000000L

int
CertMessageBox
(
    IN  HINSTANCE hInstance,
    IN  BOOL fUnattended,
    IN  HWND hWnd,
    IN  DWORD dwMsgId,
    IN  HRESULT hrCode,
    IN  UINT uType,
    IN OPTIONAL  const WCHAR * pwszCustomMsg
);


int
CertInfoMessageBox
(
    IN  HINSTANCE hInstance,
    IN  BOOL fUnattended,
    IN  HWND hWnd,
    IN  DWORD dwMsgId,
    IN OPTIONAL const WCHAR * pwszCustomMsg
);

int
CertErrorMessageBox
(
    IN  HINSTANCE hInstance,
    IN  BOOL fUnattended,
    IN  HWND hWnd,
    IN  DWORD dwMsgId,
    IN  HRESULT hrCode,
    IN OPTIONAL  const WCHAR * pwszCustomMsg
);

int
CertWarningMessageBox
(
    IN  HINSTANCE hInstance,
    IN  BOOL fUnattended,
    IN  HWND hWnd,
    IN  DWORD dwMsgId,
    IN  HRESULT hrCode,
    IN OPTIONAL  const WCHAR * pwszCustomMsg
);


typedef VOID (FNLOGMESSAGEBOX)(
    IN HRESULT hrMsg,
    IN UINT idMsg,
    IN WCHAR const *pwszTitle,
    IN WCHAR const *pwszMessage);

VOID
CertLogMessageBoxInit(
    IN FNLOGMESSAGEBOX *pfnLogMessagBox);

#endif //__CERTMSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\certsrv0.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       CertSrv.h
//  Contents:   Main Certificate Server header
//              Also includes .h files for the COM interfaces
//
//----------------------------------------------------------------------------

#if !defined( _CERTSRV_H_ )
#define _CERTSRV_H_

#include <certadm.h>
#include <certbcli.h>
#include <certcli.h>
#include <certenc.h>
#include <certexit.h>
#include <certif.h>
#include <certpol.h>
#include <certmod.h>
#include <certview.h>

#ifndef DBG_CERTSRV
# if defined(_DEBUG)
#  define DBG_CERTSRV     1
# elif defined(DBG)
#  define DBG_CERTSRV     DBG
# else
#  define DBG_CERTSRV     0
# endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\certsrv2.h ===
#endif // _CERTSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\ciinit.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        ciinit.h
//
// Contents:    Cert Server common definitions
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#ifndef __CIINIT_H__
#define __CIINIT_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _SERVERCALLBACKS {
    FNCIGETPROPERTY  *pfnGetProperty;
    FNCISETPROPERTY  *pfnSetProperty;
    FNCIGETEXTENSION *pfnGetExtension;
    FNCISETEXTENSION *pfnSetExtension;
    FNCIENUMSETUP    *pfnEnumSetup;
    FNCIENUMNEXT     *pfnEnumNext;
    FNCIENUMCLOSE    *pfnEnumClose;
} SERVERCALLBACKS;

HRESULT WINAPI
CertificateInterfaceInit(
    IN SERVERCALLBACKS const *psb,
    IN DWORD cbsb);

#ifdef __cplusplus
}
#endif

#endif // __CIINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\clibres.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:			clibres.h
//
// Contents:			Cert Server certclib resource definitions
//
//---------------------------------------------------------------------------

#ifndef __CLIBRES_H__
#define __CLIBRES_H__

// Default cert type friendly names

// Important, use only 900-1999 range to avoid conflict

#define IDS_CERTTYPE_USER			900
#define IDS_CERTTYPE_USER_AS			901
#define IDS_CERTTYPE_USER_SMARTCARD_LOGON	902
#define IDS_CERTTYPE_EFS			903
#define IDS_CERTTYPE_ADMIN			904
#define IDS_CERTTYPE_EFS_RECOVERY		905
#define IDS_CERTTYPE_CODE_SIGNING		906
#define IDS_CERTTYPE_CTL_SIGNING		907
#define IDS_CERTTYPE_MACHINE			908
#define IDS_CERTTYPE_DC				909

#define IDS_CERTTYPE_WEBSERVER			910
#define IDS_CERTTYPE_KDC			911
#define IDS_CERTTYPE_ROOT_CA			912
#define IDS_CERTTYPE_SUBORDINATE_CA		913
#define IDS_CERTTYPE_ENROLLMENT_AGENT		914
#define IDS_CERTTYPE_SMARTCARD_USER		915
//#define IDS_UNUSED				916
#define IDS_CERTTYPE_USER_SIGNATURE		917
//#define IDS_UNUSED				918
#define IDS_ILOG_BAD_NUMERICFIELD		919

// progress dlg

#define IDD_PROGRESS_BAR			920
#define IDC_JOB_DESCRIPTION			921
#define IDD_PROGRESS_BOX			922

#define IDS_CERTTYPE_IPSEC_INTERMEDIATE_ONLINE	923
#define IDS_ILOG_BAD_VALIDITY_COUNT		924
#define IDS_CERTTYPE_IPSEC_INTERMEDIATE_OFFLINE	925
#define IDS_ILOG_BAD_VALIDITY_STRING		926
#define IDS_CERTTYPE_ROUTER_OFFLINE		927
#define IDS_REQUEST_FILE_DEFEXT			928
#define IDS_REQUEST_OPEN_TITLE			929

#define IDS_REQUEST_FILE_FILTER			930
#define IDS_WRN_COMPUTERNAME_EMPTY		931
#define IDS_WRN_CANAME_EMPTY			932
#define IDS_WRN_CANAME_NOT_MATCH		933
#define IDS_WRN_PINGCA_FAIL			934
#define IDS_CERTTYPE_ENROLLMENT_AGENT_OFFLINE	935
#define IDS_CERTTYPE_EXCHANGE_USER		936
#define IDS_CERTTYPE_EXCHANGE_USER_SIGNATURE	937
#define IDS_WRN_CALIST_EMPTY			938
#define IDS_CERTTYPE_MACHINE_ENROLLMENT_AGENT	939

#define IDS_REQUEST_SAVE_TITLE			940
#define IDS_CERTTYPE_CEP_ENCRYPTION     	941


#define IDS_ILOG_CAPOLICY_BUILD			942
#define IDS_ILOG_CAPOLICY_ELEMENT		943
#define IDS_ILOG_CAPOLICY_EXTENSION		944
#define IDS_ILOG_CAPOLICY_NOKEY			945
#define IDS_ILOG_CAPOLICY_OPEN			946
#define IDS_ILOG_CAPOLICY_OPEN_FAILED		947
#define IDS_ILOG_BEGIN				948
#define IDS_ILOG_END				949

// description of access right defines

#define IDS_ACTRL_CAADMIN			950
#define IDS_ACTRL_OFFICER			951
#define IDS_ACTRL_AUDITOR			952
#define IDS_ACTRL_OPERATOR			953
#define IDS_ACTRL_CAREAD			954
#define IDS_ACTRL_ENROLL			955

#define IDS_ILOG_CAPOLICY_CLOSE			964
#define IDS_ILOG_MESSAGEBOX			965
#define IDS_ILOG_BAD_VALIDITY_STRING_UNATTEND	966

#define IDS_CERTTYPE_KEY_RECOVERY_AGENT		967
#define IDS_CERTTYPE_CA_EXCHANGE		968
#define IDS_EMPTY_FRIENDLY_NAME			969
#define IDS_CERTTYPE_CROSS_CA			970
#define IDS_CERTTYPE_DC_AUTH			971
#define IDS_CERTTYPE_DS_EMAIL_REPLICATION	972


#define IDS_WARN_ENTERPRISE_REQUIREMENTS	974
#define IDC_CLIENT_WARN_ENTERPRISE_REQUIREMENTS	975
#define IDS_WRN_OLD_CA				976
#define IDS_ILOG_BAD_BOOLEAN			977
#define IDS_CERTTYPE_WORKSTATION		978
#define IDS_CERTTYPE_RASIASSERVER		979
#define IDS_LOW_ASSURANCE_DISPLAY_NAME		980
#define IDS_MEDIUM_ASSURANCE_DISPLAY_NAME	981
#define IDS_HIGH_ASSURANCE_DISPLAY_NAME		982

#define IDS_KRA_DESCRIPTION                 1000
#define IDS_EMAIL_REPLICATION_DESCRIPTION   1001
#define IDS_CROSS_CA_DESCRIPTION            1002
#define IDS_CA_DESCRIPTION                  1003
#define IDS_MACHINE_DESCRIPTION             1004
#define IDS_END_USER_DESCRIPTION            1005
#define IDS_UNKNOWN_DESCRIPTION             1006

#define IDS_STORENAME_DS_KRA                1007
#define IDS_STORENAME_DS_AIA                1008


#endif // __CLIBRES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\certtype.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certtype.h
//
// Contents:    Declaration of CCertTypeInfo
//
// History:     16-dec-97       petesk created
//
//---------------------------------------------------------------------------

#include "cainfop.h"
#include <certca.h>
#include <gpedit.h>
#include <userenv.h>


//ACLs for templates
#define USER_GROUP_SD L"O:%1-519G:%1-519D:P(A;;RPLCLORC;;;AU)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-512)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-519)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-513)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-512)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-519)"

#define ADMIN_GROUP_SD L"O:%1-519G:%1-519D:P(A;;RPLCLORC;;;AU)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-512)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-519)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-512)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-519)"

#define MACHINE_GROUP_SD L"O:%1-519G:%1-519D:P(A;;RPLCLORC;;;AU)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-512)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-519)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-515)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-512)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-519)"

#define RASIASSERVER_GROUP_SD				\
    L"O:%1-519"						\
    L"G:%1-519"						\
    L"D:P"						\
	L"(A;;RPLCLORC;;;AU)"				\
	L"(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-512)"	\
	L"(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-519)"	\
	/* DOMAIN_ALIAS_RID_RAS_SERVERS: */		\
	L"(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-553)"	\
	L"(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-512)"	\
	L"(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-519)"

#define DOMAIN_CONTROLLERS_GROUP_SD L"O:%1-519G:%1-519D:P(A;;RPLCLORC;;;AU)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-512)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-519)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-516)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;S-1-5-9)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-512)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-519)"

#define IPSEC_GROUP_SD L"O:%1-519G:%1-519D:P(A;;RPLCLORC;;;AU)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-512)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-519)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-515)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-512)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-516)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-519)"

#define V2_DOMAIN_CONTROLLERS_GROUP_SD L"O:%1-519G:%1-519D:P(A;;RPLCLORC;;;AU)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-512)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-519)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-516)(OA;;WPRPCR;" WSZ_GUID_AUTOENROLL L";;%1-516)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;S-1-5-9)(OA;;WPRPCR;" WSZ_GUID_AUTOENROLL L";;S-1-5-9)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-512)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-519)"



//for defining default certificate types
#define OVERLAP_ONE_DAY 60*60*24*1
#define OVERLAP_TWO_WEEKS 60*60*24*14
#define OVERLAP_SIX_WEEKS 60*60*24*42
#define EXPIRATION_ONE_YEAR 60*60*24*365
#define EXPIRATION_TWO_YEARS 60*60*24*365*2
#define EXPIRATION_FIVE_YEARS 60*60*24*365*5
#define EXPIRATION_ONE_WEEK  60*60*24*7

/////////////////////////////////////////////////////////////////////////////
// description property for certificate template

#define CERT_TYPE_GENERAL_FILTER   (CT_FLAG_MACHINE_TYPE | CT_FLAG_IS_CA | CT_FLAG_IS_CROSS_CA)
#define CERT_TYPE_ENROLL_FILTER    (CT_FLAG_PUBLISH_TO_KRA_CONTAINER)
#define CERT_TYPE_NAME_FILTER      (CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID)

typedef struct _CERT_TYPE_DESCRIPTION
{
    DWORD   dwGeneralValue;
    DWORD   dwEnrollValue;
    DWORD   dwNameValue;
    UINT    idsDescription;
}CERT_TYPE_DESCRIPTION;


/////////////////////////////////////////////////////////////////////////////
// certcli

typedef struct _CERT_TYPE_DEFAULT
{
	WCHAR *wszName;
	UINT  idFriendlyName;
	WCHAR *wszSD;
	WCHAR *wszCSPs;
	WCHAR *wszEKU;
	SHORT bKU;
	BOOL  dwFlags;
	DWORD dwKeySpec;
	DWORD dwDepth;
	WCHAR *wszCriticalExt;
	DWORD dwExpiration;
	DWORD dwOverlap;
	DWORD dwRevision;
    DWORD dwMinorRevision;
	DWORD dwEnrollmentFlags;			
	DWORD dwPrivateKeyFlags;			
	DWORD dwCertificateNameFlags;	
	DWORD dwMinimalKeySize;				
	DWORD dwRASignature;				
	DWORD dwSchemaVersion;			
	WCHAR *wszOID;						
	WCHAR *wszSupersedeTemplates;		
	WCHAR *wszRAPolicy;				
	WCHAR *wszCertificatePolicy;
    WCHAR *wszRAAppPolicy;
    WCHAR *wszCertificateAppPolicy;

} CERT_TYPE_DEFAULT, *PCERT_TYPE_DEFAULT;

//
//  Default OID to install during certificate template installation
//
typedef struct _CERT_DEFAULT_OID_INFO
{
    LPWSTR  pwszOID;
    UINT    idsDisplayName;
    DWORD   dwType;
}CERT_DEFAULT_OID_INFO;


#define CERTTYPE_VERSION_BASE      0     // for w2k, 0
#define CERTTYPE_VERSION_NEXT    100     // for w2k+1.  This is the starting point
										 // for the major version.

#define CERTTYPE_MINIMAL_KEY			1024
#define CERTTYPE_2K_KEY			        2048

#define CERTTYPE_MINIMAL_KEY_SMART_CARD	512


#define MAX_SID_COUNT					5
#define MAX_DEFAULT_STRING_COUNT		20
#define MAX_DEFAULT_CSP_COUNT			10
#define MAX_DEFAULT_FRIENDLY_NAME		255

extern CERT_TYPE_DEFAULT g_aDefaultCertTypes[];
extern DWORD g_cDefaultCertTypes;

#define FILETIME_TICKS_PER_SECOND  10000000
#define DEFAULT_EXPIRATION         60*60*24*365   // 1 year
#define DEFAULT_OVERLAP            60*60*24*14    // 2 weeks

HANDLE
myEnterCriticalPolicySection(
    IN BOOL bMachine);

BOOL
myLeaveCriticalPolicySection(
    IN HANDLE hSection);

class CCertTypeInfo
{
public:
    CCertTypeInfo()
    {
        m_cRef = 1;
        m_pNext = NULL;
        m_pLast = NULL;
        m_dwFlags = 0;
        m_pProperties = NULL;
        m_BasicConstraints.fCA = FALSE;
        m_BasicConstraints.fPathLenConstraint = FALSE;
        m_BasicConstraints.dwPathLenConstraint = 0;
        m_KeyUsage.pbData = NULL;
        m_KeyUsage.cbData = NULL;
		m_dwMinorRevision = 0;
        m_dwEnrollmentFlags = 0;			
		m_dwPrivateKeyFlags = 0;			
		m_dwCertificateNameFlags = 0;	
		m_dwMinimalKeySize = 0;				
		m_dwRASignature = 0;				
		m_dwSchemaVersion=0;			

        m_bstrType = NULL;
        m_pSD = NULL;
        m_fLocalSystemCache = FALSE;

        m_fNew = TRUE;
        m_Revision = CERTTYPE_VERSION_BASE;
        m_fUpdateDisplayName = FALSE;



        ((LARGE_INTEGER *)&m_ftExpiration)->QuadPart = Int32x32To64(FILETIME_TICKS_PER_SECOND, DEFAULT_EXPIRATION);
        ((LARGE_INTEGER *)&m_ftOverlap)->QuadPart = Int32x32To64(FILETIME_TICKS_PER_SECOND, DEFAULT_OVERLAP);
    }

    ~CCertTypeInfo();

    DWORD Release();


static HRESULT Enum(
                    LPCWSTR                 wszScope , 
                    DWORD                   dwFlags,
                    CCertTypeInfo **        ppCertTypeInfo
                    );

static HRESULT FindByNames(
                           LPCWSTR *        awszNames,
                           LPCWSTR          wszScope, 
                           DWORD            dwFlags,
                           CCertTypeInfo ** ppCertTypeInfo
                           );

static HRESULT Create(
                      LPCWSTR               wszName, 
                      LPCWSTR                wszScope, 
                      CCertTypeInfo **      ppCTInfo
                      );

static HRESULT InstallDefaultTypes(VOID);


    HRESULT Update(VOID);

    HRESULT Delete(VOID);

    HRESULT Next(CCertTypeInfo **ppCertTypeInfo);

    DWORD Count()
    {
        if(m_pNext)
        {
            return m_pNext->Count()+1;
        }
        return 1;
    }

    HRESULT GetProperty(LPCWSTR wszPropertyName, LPWSTR **pawszProperties);
    HRESULT SetProperty(LPCWSTR wszPropertyName, LPWSTR *awszProperties);
    HRESULT GetPropertyEx(LPCWSTR wszPropertyName, LPVOID   pPropertyValue);
    HRESULT SetPropertyEx(LPCWSTR wszPropertyName, LPVOID   pPropertyValue);
    HRESULT FreeProperty(LPWSTR *pawszProperties);


    HRESULT GetExtensions(IN  DWORD               dwFlags,
                          OUT PCERT_EXTENSIONS *  ppCertExtensions);

    HRESULT FreeExtensions(PCERT_EXTENSIONS pCertExtensions) 
    {
        LocalFree(pCertExtensions);
        return S_OK;
    }

    HRESULT SetExtension(   IN LPCWSTR wszExtensionName,
                            IN LPVOID pExtension,
                            IN DWORD  dwFlags);


    HRESULT AccessCheck(
        IN HANDLE       ClientToken,
        IN DWORD        dwOption
        );

    HRESULT SetSecurity(IN PSECURITY_DESCRIPTOR         pSD);
    HRESULT GetSecurity(OUT PSECURITY_DESCRIPTOR *     ppSD);


    DWORD GetFlags(DWORD    dwOption);

    HRESULT  SetFlags(DWORD    dwOption, DWORD dwFlags);

    DWORD GetKeySpec(VOID)
    {
        return m_dwKeySpec;
    }

    VOID SetKeySpec(DWORD dwKeySpec)
    {
        m_dwKeySpec = dwKeySpec;
    }

    HRESULT SetExpiration(IN OPTIONAL FILETIME  * pftExpiration,
                          IN OPTIONAL FILETIME  * pftOverlap);

    HRESULT GetExpiration(OUT OPTIONAL FILETIME  * pftExpiration,
                          OUT OPTIONAL FILETIME  * pftOverlap);


    static CCertTypeInfo * _Append(CCertTypeInfo **ppCertTypeInfo, CCertTypeInfo *pInfo);

	BOOL	IsValidSecurityOwner();


protected:

    static HRESULT _EnumFromDSCache(DWORD                   dwFlags,                            
                                    CCertTypeInfo **        ppCTInfo);

    static HRESULT _HasDSCacheExpired(  DWORD               dwFlags);
    static HRESULT _EnumScopeFromDS(
                                        LDAP *              pld,
                                        DWORD               dwFlags,
                                        LPCWSTR             wszScope,
                                        CCertTypeInfo **    ppCTInfo);                 
    static HRESULT _EnumFromDS(
                    LDAP *              pld,
                    DWORD               dwFlags,
                    CCertTypeInfo **    ppCTInfo
                    );

    static HRESULT _FindInDS(
                             LDAP *              pld,
                             LPCWSTR *           wszNames,
                             DWORD               dwFlags,
                             CCertTypeInfo **    ppCTInfo
                             );


    static CCertTypeInfo * _FilterByFlags(CCertTypeInfo **ppCertTypeInfo, 
                                          DWORD dwFlags);

    static  HRESULT _UpdateDSCache(
                        DWORD               dwFlags,
                        CCertTypeInfo *     pCTInfo
                        );
    
    HRESULT _Cleanup();

    DWORD AddRef();
    HRESULT _GetTypeExtensionValue(IN BOOL fCheckVersion, OUT CERTSTR *  bstrValue);

    HRESULT _GetEKUValue(OUT CERTSTR *  bstrValue);

    HRESULT _GetKUValue(OUT CERTSTR *  bstrValue);

    HRESULT _GetBasicConstraintsValue(OUT CERTSTR *  bstrValue);

    HRESULT _GetPoliciesValue(IN LPCWSTR pwszPropertyName, OUT CERTSTR *  bstrValue);

    BOOL _IsCritical(IN LPCWSTR wszExtId, LPCWSTR *awszCriticalExtensions);

    HRESULT _LoadFromRegBase(LPCWSTR wszType, HKEY hCertTypes);

    HRESULT _LoadCachedCTFromReg(LPCWSTR wszType, HKEY hRoot);

    HRESULT _BaseUpdateToReg(HKEY hKey);
    HRESULT _UpdateToDS(VOID);


    HRESULT _SetWszzProperty(
		    IN WCHAR const *pwszPropertyName,
		    OPTIONAL IN WCHAR const *pwszzPropertyValue);

    HRESULT _LoadFromDefaults(PCERT_TYPE_DEFAULT pDefault,
                              LPWSTR            wszDomain);

    HRESULT _LoadFromDSEntry(LDAP *pld, LDAPMessage *Entry);


    HRESULT _BuildDefaultSecurity(PCERT_TYPE_DEFAULT pDefault);

	HRESULT _UpdateSecurity();

	HRESULT _UpdateSecurityOwner();


    LONG                    m_cRef;
    CERTSTR                 m_bstrType;

    CERT_BASIC_CONSTRAINTS2_INFO m_BasicConstraints;
    CRYPT_BIT_BLOB          m_KeyUsage;


    DWORD                   m_dwFlags;

    DWORD                   m_dwKeySpec;
    DWORD                   m_dwMinorRevision;
	DWORD					m_dwEnrollmentFlags;			
	DWORD					m_dwPrivateKeyFlags;			
	DWORD					m_dwCertificateNameFlags;	
	DWORD					m_dwMinimalKeySize;				
	DWORD					m_dwRASignature;				
	DWORD					m_dwSchemaVersion;			


    CCAProperty             *m_pProperties;

    FILETIME                m_ftExpiration;
    FILETIME                m_ftOverlap;

    BOOL                    m_fNew;
    BOOL                    m_fLocalSystemCache;
    BOOL                    m_fUpdateDisplayName;

    PSECURITY_DESCRIPTOR    m_pSD;
    DWORD                   m_Revision;

    CCertTypeInfo *m_pNext;
    CCertTypeInfo *m_pLast;

private:
};

#define m_dwCritical


// These are additional LDAP attribute names that define cert type data, that are not included in the
// primary cert type property list

// flags
// 
#define CERTTYPE_PROP_FLAGS                 L"flags"
#define CERTTYPE_PROP_DEFAULT_KEYSPEC       L"pKIDefaultKeySpec"
#define CERTTYPE_SECURITY_DESCRIPTOR_NAME   L"NTSecurityDescriptor"
#define CERTTYPE_PROP_KU                    L"pKIKeyUsage"
#define CERTTYPE_PROP_MAX_DEPTH             L"pKIMaxIssuingDepth"
#define CERTTYPE_PROP_EXPIRATION            L"pKIExpirationPeriod"
#define CERTTYPE_PROP_OVERLAP               L"pKIOverlapPeriod"
//begining of V2 template attributes
#define CERTTYPE_RPOP_ENROLLMENT_FLAG		L"msPKI-Enrollment-Flag"
#define CERTTYPE_PROP_PRIVATE_KEY_FLAG		L"msPKI-Private-Key-Flag"
#define CERTTYPE_PROP_NAME_FLAG				L"msPKI-Certificate-Name-Flag"

//
//
#define CERTTYPE_REFRESH_PERIOD  60*10 // 10 minutes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\counter.h ===
#ifndef CTICKCOUNTER
#define CTICKCOUNTER

extern LONG g_cCallsActive;

class CTickCounter
{
public:
CTickCounter(LPCWSTR pcwszFuncName)
{
    m_pcwszFuncName = pcwszFuncName;
    m_dwTickCount = GetTickCount();
}
~CTickCounter()
{
    DWORD dwCrtTickCount = GetTickCount();
    CONSOLEPRINT0((MAXDWORD, "%d\t%d\t%d\n", dwCrtTickCount-m_dwTickCount, dwCrtTickCount, g_cCallsActive));
}

private:
    DWORD m_dwTickCount;
    LPCWSTR m_pcwszFuncName;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\config.h ===
//+--------------------------------------------------------------------------
// File:        config.h
// Contents:    CConfigStorage implements read/write to CA configuration data 
//              currently stored under HKLM\System\CCS\Services\Certsvc\
//              Configuration
//---------------------------------------------------------------------------

namespace CertSrv
{
class CConfigStorage
{
public:

    CConfigStorage() : 
      m_hRemoteHKLM(NULL),
      m_hRootConfigKey(NULL), 
      m_hCAKey(NULL),
      m_pwszMachine(NULL) {};

   ~CConfigStorage();

    HRESULT InitMachine(LPCWSTR pcwszMachine);

    HRESULT GetEntry(
        LPCWSTR pcwszAuthorityName,
        LPCWSTR pcwszRelativeNodePath,
        LPCWSTR pcwszValue,
        VARIANT *pVariant);

    HRESULT SetEntry(
        LPCWSTR pwszAuthorityName,
        LPCWSTR pcwszRelativeNodePath,
        LPCWSTR pwszEntry,
        VARIANT *pVariant);

private:

    HRESULT InitRootKey();
    HRESULT InitCAKey(LPCWSTR pcwszAuthority);
    
    HKEY m_hRemoteHKLM; // HKLM if connecting to remote machine
    HKEY m_hRootConfigKey; // HKLM\System\CCS\Services\CertSvc\Configuration
    HKEY m_hCAKey; // ...Configuration\CAName
    LPWSTR m_pwszMachine;

}; // class CConfigStorage

}; // namespace CertSrv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\csauto.h ===
#pragma once

namespace CertSrv
{

typedef VOID (WINAPI* PFNAUTOCLEANUP)(VOID*);


template<class PTR, PFNAUTOCLEANUP pfn, UINT_PTR pInvalid = NULL> 
class CAutoPtr {

public:
    CAutoPtr() { m_ptr = pInvalid; }
    CAutoPtr(PTR ptr) : m_ptr(ptr) { }
   ~CAutoPtr() { Cleanup(); }

    bool IsValid()  const { return(m_ptr != pInvalid); }
    bool IsInvalid()const { return(!IsValid()); }

    PTR operator=(PTR ptr) { return Attach(ptr); }
    operator PTR() const { return m_ptr; }
    PTR* operator &() { CSASSERT(NULL==m_ptr); return &m_ptr; }
    PTR& operator *()  const { CSASSERT(NULL!=m_ptr); return *m_ptr; }
    PTR  operator ->() const { return m_ptr; }
    bool operator ==(const PTR ptr) const { return m_ptr==ptr; }
    bool operator !=(const PTR ptr) const { return m_ptr!=ptr; }
    bool operator !() const { return NULL == m_ptr; }
    
    void Cleanup() 
    { 
        if (IsValid()) 
        {
            pfn(m_ptr);
            m_ptr = pInvalid;
        }
    }

    PTR Attach(PTR ptr)
    {
        Cleanup(); 
        m_ptr = ptr;
        return(*this);  
    }

    PTR Detach()
    {
        PTR ptrTemp = m_ptr;
        m_ptr = pInvalid;
        return m_ptr;
    }
        
private:
    
    // disable default copy constructor and assignment operator for
    // CAutoPtr objects
    CAutoPtr(const CAutoPtr& src) { }
    CAutoPtr operator=(CAutoPtr p) { }

    PTR m_ptr;           // The member representing the object
};


#define DefineAutoClass(className, tData, pfnCleanup) \
   typedef CAutoPtr<tData, (PFNAUTOCLEANUP) pfnCleanup> className;

#define DefineAutoClassEx(className, tData, pfnCleanup, pInvalid) \
   typedef CAutoPtr<tData, (PFNAUTOCLEANUP) pfnCleanup, \
   pInvalid> className;


// Instances of the template C++ class for common data PTRs.
DefineAutoClass(CAutoLPWSTR,    LPWSTR, LocalFree);
DefineAutoClass(CAutoLPSTR,     LPSTR,  LocalFree);
DefineAutoClass(CAutoPBYTE,     PBYTE,  LocalFree);
DefineAutoClass(CAutoHANDLE,    HANDLE, CloseHandle);
DefineAutoClass(CAutoBSTR,      BSTR,   SysFreeString);   
DefineAutoClass(CAutoHCERTTYPE, HCERTTYPE, CACloseCertType);
DefineAutoClass(CAutoHKEY,      HKEY,   RegCloseKey);


}; // namespace CertSrv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\cs.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cs.h
//
// Contents:    Cert Server common definitions
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------


#ifndef __CS_H__
#define __CS_H__

#ifndef __CERTLIB_H__
# error -- cs.h should only be included from certlib.h!
#endif

#include <ntverp.h>

#ifndef DBG
# if defined _DEBUG
#  define DBG 1
# else
#  define DBG 0
# endif
#endif

#ifndef DBG_CERTSRV
# define DBG_CERTSRV	DBG
#endif


// _tcslen of a static string:
#define _TSZARRAYSIZE(a)	((DWORD) ((sizeof(a)/sizeof((a)[0])) - 1))


#if !defined(DBG_CERTSRV_DEBUG_PRINT) && !defined(DBG_CERTSRV_DEBUG_PRINT_LINEFILE)
# if DBG_CERTSRV
#  define DBG_CERTSRV_DEBUG_PRINT		  // checked build logging
# else
//#  define DBG_CERTSRV_DEBUG_PRINT_LINEFILE	1 // basic file#, line# logging
//#  define DBG_CERTSRV_DEBUG_PRINT_LINEFILE	2 // add Error2, etc. logging
#  define DBG_CERTSRV_DEBUG_PRINT_LINEFILE	3 // also add dynamic strings
# endif
#endif //DBG_CERTSRV


#define DBG_SS_ERROR	 0x00000001
#define DBG_SS_ASSERT	 0x00000002
#define DBG_SS_INFO	 0x00000004	// or in with any of the below
#define DBG_SS_MODLOAD	 0x00000008
#define DBG_SS_NOQUIET	 0x00000010

#define DBG_SS_CERTHIER	 0x00000100
#define DBG_SS_CERTREQ	 0x00000200
#define DBG_SS_CERTUTIL	 0x00000400
#define DBG_SS_CERTSRV	 0x00000800

#define DBG_SS_CERTADM	 0x00001000
#define DBG_SS_CERTCLI	 0x00002000
#define DBG_SS_CERTDB	 0x00004000
#define DBG_SS_CERTENC	 0x00008000
#define DBG_SS_CERTEXIT	 0x00010000
#define DBG_SS_CERTIF	 0x00020000
#define DBG_SS_CERTMMC	 0x00040000
#define DBG_SS_CERTOCM	 0x00080000
#define DBG_SS_CERTPOL	 0x00100000
#define DBG_SS_CERTVIEW	 0x00200000
#define DBG_SS_CERTBCLI	 0x00400000
#define DBG_SS_CERTJET	 0x00800000
#define DBG_SS_CERTLIBXE 0x10000000	// same as dbgdef.h's DBG_SS_APP
#define DBG_SS_AUDIT	 0x20000000
#define DBG_SS_CERTLIB	 0x40000000

#define DBG_SS_OPENLOG	 0x80000000

#define DBG_SS_CERTHIERI	(DBG_SS_CERTHIER | DBG_SS_INFO)
#define DBG_SS_CERTREQI		(DBG_SS_CERTREQ | DBG_SS_INFO)
#define DBG_SS_CERTUTILI	(DBG_SS_CERTUTIL | DBG_SS_INFO)
#define DBG_SS_CERTSRVI		(DBG_SS_CERTSRV | DBG_SS_INFO)

#define DBG_SS_CERTADMI		(DBG_SS_CERTADM | DBG_SS_INFO)
#define DBG_SS_CERTCLII		(DBG_SS_CERTCLI | DBG_SS_INFO)
#define DBG_SS_CERTDBI		(DBG_SS_CERTDB | DBG_SS_INFO)
#define DBG_SS_CERTENCI		(DBG_SS_CERTENC | DBG_SS_INFO)
#define DBG_SS_CERTEXITI	(DBG_SS_CERTEXIT | DBG_SS_INFO)
#define DBG_SS_CERTIFI		(DBG_SS_CERTIF | DBG_SS_INFO)
#define DBG_SS_CERTMMCI		(DBG_SS_CERTMMC | DBG_SS_INFO)
#define DBG_SS_CERTOCMI		(DBG_SS_CERTOCM | DBG_SS_INFO)
#define DBG_SS_CERTPOLI		(DBG_SS_CERTPOL | DBG_SS_INFO)
#define DBG_SS_CERTVIEWI	(DBG_SS_CERTVIEW | DBG_SS_INFO)
#define DBG_SS_CERTBCLII	(DBG_SS_CERTBCLI | DBG_SS_INFO)
#define DBG_SS_CERTJETI		(DBG_SS_CERTJET | DBG_SS_INFO)

#define DBG_SS_CERTLIBI		(DBG_SS_CERTLIB | DBG_SS_INFO)


// begin_certsrv

// VerifyRequest() return values

#define VR_PENDING	0	 // request will be accepted or denied later
#define VR_INSTANT_OK	1	 // request was accepted
#define VR_INSTANT_BAD	2	 // request was rejected

// end_certsrv

// Certificate types:

#define CERT_TYPE_NONE	0	// cannot create certificates
#define CERT_TYPE_X509	1	// CCITT x509 certificates
#define CERT_TYPE_SDSI	2	// SDSI certificates
#define CERT_TYPE_PGP	3	// PGP certificates


#if DBG_CERTSRV
# define DBGCODE(a)	a
# define DBGPARM0(parm)  parm
# define DBGPARM(parm)   , parm
#else // DBG_CERTSRV
# define DBGCODE(a)
# define DBGPARM0(parm)
# define DBGPARM(parm)
#endif // DBG_CERTSRV

#define wprintf			myConsolePrintf
#define printf			Use_wprintf_Instead_Of_printf
#define LdapMapErrorToWin32	Use_myHLdapError_Instead_Of_LdapMapErrorToWin32

#if 0 == i386
# define IOBUNALIGNED(pf) ((sizeof(WCHAR) - 1) & (DWORD) (ULONG_PTR) (pf)->_ptr)
# define ALIGNIOB(pf) \
    { \
	if (IOBUNALIGNED(pf)) \
	{ \
	    fflush(pf); /* fails when running as a service */ \
	} \
	if (IOBUNALIGNED(pf)) \
	{ \
	    fprintf(pf, " "); \
	    fflush(pf); \
	} \
    }
#else
# define IOBUNALIGNED(pf) FALSE
# define ALIGNIOB(pf)
#endif

HRESULT myHExceptionCode(IN EXCEPTION_POINTERS const *pep);


typedef VOID (WINAPI FNPRINTERROR)(
    IN char const *pszMessage,
    OPTIONAL IN WCHAR const *pwszData,
    IN char const *pszFile,
    IN DWORD dwLine,
    IN HRESULT hr,
    IN HRESULT hrquiet);

FNPRINTERROR CSPrintError;


typedef VOID (WINAPI FNPRINTASSERT)(
    IN char const *pszFailedAssertion,
    IN char const *pszFileName,
    IN DWORD dwLine,
    IN char const *pszMessage);

FNPRINTASSERT CSPrintAssert;


typedef VOID (WINAPI FNPRINTERRORLINEFILE)(
    IN DWORD dwLineFile,
    IN HRESULT hr);

FNPRINTERRORLINEFILE CSPrintErrorLineFile;


typedef VOID (WINAPI FNPRINTERRORLINEFILE2)(
    IN DWORD dwLineFile,
    IN HRESULT hr,
    IN HRESULT hrquiet);

FNPRINTERRORLINEFILE2 CSPrintErrorLineFile2;


typedef VOID (WINAPI FNPRINTERRORLINEFILE2)(
    IN DWORD dwLineFile,
    IN HRESULT hr,
    IN HRESULT hrquiet);

FNPRINTERRORLINEFILE2 CSPrintErrorLineFile2;


typedef VOID (WINAPI FNPRINTERRORLINEFILEDATA)(
    OPTIONAL IN WCHAR const *pwszData,
    IN DWORD dwLineFile,
    IN HRESULT hr);

FNPRINTERRORLINEFILEDATA CSPrintErrorLineFileData;


typedef VOID (WINAPI FNPRINTERRORLINEFILEDATA2)(
    OPTIONAL IN WCHAR const *pwszData,
    IN DWORD dwLineFile,
    IN HRESULT hr,
    IN HRESULT hrquiet);

FNPRINTERRORLINEFILEDATA2 CSPrintErrorLineFileData2;


#define __LINEFILE__			__MAKELINEFILE__(__dwFILE__, __LINE__)
#define __MAKELINEFILE__(file, line)	((file) | ((line) << 16))
#define __LINEFILETOFILE__(dwLineFile)	((DWORD) (USHORT) (dwLineFile))
#define __LINEFILETOLINE__(dwLineFile)	((dwLineFile) >> 16)


#ifdef DBG_CERTSRV_DEBUG_PRINT

#define __FILEDIR__	__DIR__ "\\" __FILE__

__inline BOOL CSExpr(IN BOOL expr) { return(expr); }
__inline BOOL CSExprA(IN char const *pszexpr) { return(NULL != pszexpr); }
__inline BOOL CSExprW(IN WCHAR const *pwszexpr) { return(NULL != pwszexpr); }

# define CSASSERT(exp)	CSASSERTMSG(NULL, exp)

# define CSASSERTMSG(pszmsg, exp) \
    if (!(exp)) \
	CSPrintAssert(#exp, __FILEDIR__, __LINE__, (pszmsg))

# define DBGERRORPRINT(pszMessage, pwszData, dwLine, hr, hrquiet) \
    CSPrintError((pszMessage), (pwszData), __FILEDIR__, (dwLine), (hr), (hrquiet))

# define myHEXCEPTIONCODE() myHExceptionCodePrint(GetExceptionInformation(), __FILEDIR__, __dwFILE__, __LINE__)

#else // DBG_CERTSRV_DEBUG_PRINT

# ifdef DBG_CERTSRV_DEBUG_PRINT_LINEFILE	// free build tracing

# define myHEXCEPTIONCODE() myHExceptionCodePrintLineFile(GetExceptionInformation(), __LINEFILE__)

# else // DBG_CERTSRV_DEBUG_PRINT_LINEFILE

# define DBGERRORPRINT(pszMessage, pwszData, dwLine, hr, hrquiet)
# define myHEXCEPTIONCODE() myHExceptionCodePrint(GetExceptionInformation(), NULL, __dwFILE__, __LINE__)

# endif // DBG_CERTSRV_DEBUG_PRINT_LINEFILE

# define CSASSERT(exp)
# define CSASSERTMSG(msg, exp)

#endif // DBG_CERTSRV_DEBUG_PRINT


#ifdef DBG_CERTSRV_DEBUG_PRINT_LINEFILE

#define DBGERRORPRINTLINE(pszMessage, hr) \
    CSPrintErrorLineFile(__LINEFILE__, (hr))

# if (2 <= DBG_CERTSRV_DEBUG_PRINT_LINEFILE)

# define DBGERRORPRINTLINE2(pszMessage, hr, hrquiet) \
    CSPrintErrorLineFile2(__LINEFILE__, (hr), (hrquiet))

# else

# define DBGERRORPRINTLINE2(pszMessage, hr, hrquiet)

# endif

#if (3 <= DBG_CERTSRV_DEBUG_PRINT_LINEFILE)

# define DBGERRORPRINTLINESTR(pszMessage, pwszData, hr) \
    CSPrintErrorLineFileData((pwszData), __LINEFILE__, (hr))

# define DBGERRORPRINTLINESTR2(pszMessage, pwszData, hr, hrquiet) \
    CSPrintErrorLineFileData2((pwszData), __LINEFILE__, (hr), (hrquiet))

#else

# define DBGERRORPRINTLINESTR(pszMessage, pwszData, hr) \
    CSPrintErrorLineFile(__LINEFILE__, (hr))

# if (2 <= DBG_CERTSRV_DEBUG_PRINT_LINEFILE)

# define DBGERRORPRINTLINESTR2(pszMessage, pwszData, hr, hrquiet) \
    CSPrintErrorLineFile2(__LINEFILE__, (hr), (hrquiet))

# else

# define DBGERRORPRINTLINESTR2(pszMessage, pwszData, hr, hrquiet)

# endif

#endif

#else // DBG_CERTSRV_DEBUG_PRINT_LINEFILE

#define DBGERRORPRINTLINE(pszMessage, hr) \
	DBGERRORPRINTLINESTR2((pszMessage), NULL, (hr), 0)

#define DBGERRORPRINTLINE2(pszMessage, hr, hrquiet) \
	DBGERRORPRINTLINESTR2((pszMessage), NULL, (hr), (hrquiet))

#define DBGERRORPRINTLINESTR(pszMessage, pwszData, hr) \
	DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), 0)

#define DBGERRORPRINTLINESTR2(pszMessage, pwszData, hr, hrquiet) \
    { \
	DBGERRORPRINT((pszMessage), (pwszData), __LINE__, (hr), (hrquiet)); \
    }

#endif // DBG_CERTSRV_DEBUG_PRINT_LINEFILE


typedef VOID (FNLOGSTRING)(
    IN char const *pszString);

typedef VOID (FNLOGEXCEPTION)(
    IN HRESULT hrExcept,
    IN EXCEPTION_POINTERS const *pep,
    OPTIONAL IN char const *pszFileName,
    IN DWORD dwFile,
    IN DWORD dwLine);

HRESULT myHExceptionCodePrint(
    IN EXCEPTION_POINTERS const *pep,
    OPTIONAL IN char const *pszFile,
    IN DWORD dwFile,
    IN DWORD dwLine);

HRESULT myHExceptionCodePrintLineFile(
    IN EXCEPTION_POINTERS const *pep,
    IN DWORD dwLineFile);

VOID myLogExceptionInit(
    IN FNLOGEXCEPTION *pfnLogException);

int WINAPIV DbgPrintf(DWORD dwSubSysId, char const *pszfmt, ...);
int WINAPIV DbgPrintfW(DWORD dwSubSysId, WCHAR const *pwszfmt, ...);
VOID DbgPrintfInit(OPTIONAL IN CHAR const *pszFile);
BOOL DbgIsSSActive(DWORD dwSSIn);
VOID DbgLogStringInit(FNLOGSTRING *pfnLog);
VOID DbgTerminate(VOID);



#if (VER_FILEFLAGS & VS_FF_DEBUG)
#define szCSVER_DEBUG_STR	" debug"
#else
#define szCSVER_DEBUG_STR	" retail"
#endif

#if (VER_FILEFLAGS & VS_FF_PRIVATEBUILD)
#define szCSVER_PRIVATE_STR	" private"
#else
#define szCSVER_PRIVATE_STR
#endif

#define szCSVER_STR \
    VER_FILEVERSION_STR szCSVER_DEBUG_STR szCSVER_PRIVATE_STR BUILD_MACHINE_TAG

__inline VOID
DbgLogFileVersion(
    IN char const *pszFile,
    IN char const *pszVersion)
{
    DbgPrintf(MAXDWORD, "%hs: %hs\n", pszFile, pszVersion);
}

#define CBLOGMAXAPPEND	(512 * 1024)

#ifdef DBG_CERTSRV_DEBUG_PRINT
# define DBGPRINT(a)		DbgPrintf a
# define DBGPRINTW(a)		DbgPrintfW a
# define DBGDUMPHEX(a)		mydbgDumpHex a
# define DBGPARMREFERENCED(parm) parm
#else
# define DBGPRINT(a)
# define DBGPRINTW(a)
# define DBGDUMPHEX(a)
# define DBGPARMREFERENCED(parm)
#endif

#define CONSOLEPRINT0(a)	DbgPrintf a
#define CONSOLEPRINT1(a)	DbgPrintf a
#define CONSOLEPRINT2(a)	DbgPrintf a
#define CONSOLEPRINT3(a)	DbgPrintf a
#define CONSOLEPRINT4(a)	DbgPrintf a
#define CONSOLEPRINT5(a)	DbgPrintf a
#define CONSOLEPRINT6(a)	DbgPrintf a
#define CONSOLEPRINT7(a)	DbgPrintf a
#define CONSOLEPRINT8(a)	DbgPrintf a

#if 1 < DBG_CERTSRV
# define DBGTRACE(a)	DbgPrintf a
#else
# define DBGTRACE(a)
#endif


#define _LeaveError(hr, pszMessage) \
    { \
	DBGERRORPRINTLINE((pszMessage), (hr)); \
	__leave; \
    }

#define _LeaveError2(hr, pszMessage, hrquiet) \
    { \
	DBGERRORPRINTLINE2((pszMessage), (hr), (hrquiet)); \
	__leave; \
    }

#define _LeaveErrorStr(hr, pszMessage, pwszData) \
    { \
	DBGERRORPRINTLINESTR((pszMessage), (pwszData), (hr)); \
	__leave; \
    }

#define _LeaveError3(hr, pszMessage, hrquiet, hrquiet2) \
	_LeaveErrorStr3((hr), (pszMessage), NULL, (hrquiet), (hrquiet2))

#define _LeaveErrorStr2(hr, pszMessage, pwszData, hrquiet) \
    { \
	DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	__leave; \
    }

#define _LeaveErrorStr3(hr, pszMessage, pwszData, hrquiet, hrquiet2) \
    { \
	if ((hrquiet2) != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	} \
	__leave; \
    }


#define _LeaveIfError(hr, pszMessage) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINE((pszMessage), (hr)); \
	    __leave; \
	} \
    }

#define _LeaveIfError2(hr, pszMessage, hrquiet) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINE2((pszMessage), (hr), (hrquiet)); \
	    __leave; \
	} \
    }

#define _LeaveIfErrorStr(hr, pszMessage, pwszData) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR((pszMessage), (pwszData), (hr)); \
	    __leave; \
	} \
    }

#define _LeaveIfError3(hr, pszMessage, hrquiet, hrquiet2) \
    { \
	if (S_OK != (hr)) \
	{ \
	    if ((hrquiet2) != (hr)) \
	    { \
		DBGERRORPRINTLINE2((pszMessage), (hr), (hrquiet)); \
	    } \
	    __leave; \
	} \
    }

#define _LeaveIfErrorStr2(hr, pszMessage, pwszData, hrquiet) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	    __leave; \
	} \
    }

#define _LeaveIfErrorStr3(hr, pszMessage, pwszData, hrquiet, hrquiet2) \
    { \
	if (S_OK != (hr)) \
	{ \
	    if ((hrquiet2) != (hr)) \
	    { \
		DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	    } \
	    __leave; \
	} \
    }


#define _PrintError(hr, pszMessage) \
    { \
	DBGERRORPRINTLINE((pszMessage), (hr)); \
    }

#define _PrintError2(hr, pszMessage, hrquiet) \
    { \
	DBGERRORPRINTLINE2((pszMessage), (hr), (hrquiet)); \
    }

#define _PrintErrorStr(hr, pszMessage, pwszData) \
    { \
	DBGERRORPRINTLINESTR((pszMessage), (pwszData), (hr)); \
    }

#define _PrintError3(hr, pszMessage, hrquiet, hrquiet2) \
    { \
	if ((hrquiet2) != (hr)) \
	{ \
	    DBGERRORPRINTLINE2((pszMessage), (hr), (hrquiet)); \
	} \
    }

#define _PrintErrorStr2(hr, pszMessage, pwszData, hrquiet) \
    { \
	DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
    }

#define _PrintErrorStr3(hr, pszMessage, pwszData, hrquiet, hrquiet2) \
    { \
	if ((hrquiet2) != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	} \
    }


#define _PrintIfError(hr, pszMessage) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINE((pszMessage), (hr)); \
	} \
    }

#define _PrintIfError2(hr, pszMessage, hrquiet) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINE2((pszMessage), (hr), (hrquiet)); \
	} \
    }

#define _PrintIfError3(hr, pszMessage, hrquiet, hrquiet2) \
    { \
	if (S_OK != (hr)) \
	{ \
	    if ((hrquiet2) != (hr)) \
	    { \
		DBGERRORPRINTLINE2((pszMessage), (hr), (hrquiet)); \
	    } \
	} \
    }

#define _PrintIfError4(hr, pszMessage, hrquiet, hrquiet2, hrquiet3) \
    { \
	if (S_OK != (hr)) \
	{ \
	    if ((hrquiet2) != (hr) && (hrquiet3) != (hr)) \
	    { \
		DBGERRORPRINTLINE2((pszMessage), (hr), (hrquiet)); \
	    } \
	} \
    }

#define _PrintIfErrorStr(hr, pszMessage, pwszData) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR((pszMessage), (pwszData), (hr)); \
	} \
    }

#define _PrintIfErrorStr2(hr, pszMessage, pwszData, hrquiet) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	} \
    }

#define _PrintIfErrorStr3(hr, pszMessage, pwszData, hrquiet, hrquiet2) \
    { \
	if (S_OK != (hr)) \
	{ \
	    if ((hrquiet2) != (hr)) \
	    { \
		DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	    } \
	} \
    }

#define _PrintIfErrorStr4(hr, pszMessage, pwszData, hrquiet, hrquiet2, hrquiet3) \
    { \
	if (S_OK != (hr)) \
	{ \
	    if ((hrquiet2) != (hr) && (hrquiet3) != (hr)) \
	    { \
		DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	    } \
	} \
    }

#define _PrintExpectedError(hr, pszMessage) \
    { \
    if (S_OK != (hr)) \
    { \
        DBGERRORPRINTLINESTR(("Expected error "), (pszMessage), (hr)); \
    } \
    }



#define _JumpError(hr, label, pszMessage) \
    { \
	DBGERRORPRINTLINE((pszMessage), (hr)); \
	goto label; \
    }

#define _JumpError2(hr, label, pszMessage, hrquiet) \
    { \
	DBGERRORPRINTLINE2((pszMessage), (hr), (hrquiet)); \
	goto label; \
    }

#define _JumpErrorStr(hr, label, pszMessage, pwszData) \
    { \
	DBGERRORPRINTLINESTR((pszMessage), (pwszData), (hr)); \
	goto label; \
    }

#define _JumpErrorStr2(hr, label, pszMessage, pwszData, hrquiet) \
    { \
	DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	goto label; \
    }

#define _JumpErrorStr3(hr, label, pszMessage, pwszData, hrquiet, hrquiet2) \
    { \
	if ((hrquiet2) != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	} \
	goto label; \
    }


#define _JumpIfError(hr, label, pszMessage) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINE((pszMessage), (hr)); \
	    goto label; \
	} \
    }

#define _JumpIfError2(hr, label, pszMessage, hrquiet) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINE2((pszMessage), (hr), (hrquiet)); \
	    goto label; \
	} \
    }

#define _JumpIfErrorStr(hr, label, pszMessage, pwszData) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR((pszMessage), (pwszData), (hr)); \
	    goto label; \
	} \
    }

#define _JumpIfError3(hr, label, pszMessage, hrquiet, hrquiet2) \
    { \
	if (S_OK != (hr)) \
	{ \
	    if ((hrquiet2) != (hr)) \
	    { \
		DBGERRORPRINTLINE2((pszMessage), (hr), (hrquiet)); \
	    } \
	    goto label; \
	} \
    }

#define _JumpIfError4(hr, label, pszMessage, hrquiet, hrquiet2, hrquiet3) \
    { \
	if (S_OK != (hr)) \
	{ \
	    if ((hrquiet2) != (hr) && (hrquiet3) != (hr)) \
	    { \
		DBGERRORPRINTLINE2((pszMessage), (hr), (hrquiet)); \
	    } \
	    goto label; \
	} \
    }

#define _JumpIfErrorStr2(hr, label, pszMessage, pwszData, hrquiet) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	    goto label; \
	} \
    }

#define _JumpIfErrorStr3(hr, label, pszMessage, pwszData, hrquiet, hrquiet2) \
    { \
	if (S_OK != (hr)) \
	{ \
	    if ((hrquiet2) != (hr)) \
	    { \
		DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	    } \
	    goto label; \
	} \
    }

#define _JumpIfErrorStr4(hr, label, pszMessage, pwszData, hrquiet, hrquiet2, hrquiet3) \
    { \
	if (S_OK != (hr)) \
	{ \
	    if ((hrquiet2) != (hr) && (hrquiet3) != (hr)) \
	    { \
		DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	    } \
	    goto label; \
	} \
    }

#define _JumpIfWin32Error(err, label, pszMessage) \
    { \
	if (ERROR_SUCCESS != (err)) \
	{ \
	    hr = HRESULT_FROM_WIN32((err)); \
	    DBGERRORPRINTLINE((pszMessage), hr); \
	    goto label; \
	} \
    }

#define _JumpIfErrorNotSpecific(hr, label, pszMessage, hrquiet) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINE2((pszMessage), (hr), (hrquiet)); \
	    if ((hrquiet) != (hr)) \
	    { \
		goto label; \
	    } \
	} \
    }

#define _JumpIfAllocFailed(ptr, label) \
    { \
	if ((ptr) == NULL) \
	{ \
	    hr = E_OUTOFMEMORY; \
	    DBGERRORPRINTLINE("allocation error", (hr)); \
	    goto label; \
	} \
    }

#define Add2Ptr(pb, cb)	((VOID *) ((BYTE *) (pb) + (ULONG_PTR) (cb)))


#define Add2ConstPtr(pb, cb) \
	((VOID const *) ((BYTE const *) (pb) + (ULONG_PTR) (cb)))


#define WSZARRAYSIZE(a)		csWSZARRAYSIZE(a, _TSZARRAYSIZE(a))
#define SZARRAYSIZE(a)		csSZARRAYSIZE(a, _TSZARRAYSIZE(a))

#ifdef UNICODE
#define TSZARRAYSIZE(a)		WSZARRAYSIZE(a)
#else
#define TSZARRAYSIZE(a)		SZARRAYSIZE(a)
#endif

#if DBG_CERTSRV
__inline DWORD
csWSZARRAYSIZE(
    IN WCHAR const *pwsz,
    IN DWORD cwc)
{
    CSASSERT(wcslen(pwsz) == cwc);
    return(cwc);
}

__inline DWORD
csSZARRAYSIZE(
    IN CHAR const *psz,
    IN DWORD cch)
{
    CSASSERT(strlen(psz) == cch);
    return(cch);
}
#else
#define csWSZARRAYSIZE(pwsz, cwc)	(cwc)
#define csSZARRAYSIZE(psz, cch)		(cch)
#endif // DBG_CERTSRV

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

#endif // __CS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\cscomres.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:		cscomres.h
//
// Contents:		Cert Server COM resource definitions
//
//---------------------------------------------------------------------------

#ifndef __CSCOMRES_H__
#define __CSCOMRES_H__

// config string ids

#define IDS_CERTCONFIG_DESC		1
#define IDS_CERTGETCONFIG_DESC		2
#define IDS_CERTREQUEST_DESC		3
#define IDS_CERTADMIN_DESC		4
#define IDS_CERTSERVERPOLICY_DESC	5
#define IDS_CERTSERVEREXIT_DESC		6
#define IDS_CERTVIEW_DESC		7
#define IDS_CERTMANAGEPOLICYMODULE_DESC	8
#define IDS_LEGACYPOLICYMODULE_NAME	9
#define IDS_CERTMANAGEEXITMODULE_DESC	10
#define IDS_LEGACYEXITMODULE_NAME	11

#endif // __CSCOMRES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\csber.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       csber.h
//
//--------------------------------------------------------------------------

#ifndef __CSBER_H__
#define __CSBER_H__

// tag definitions for ASN.1 encoding decoding:

#define BER_UNIVERSAL		0x00
#define BER_APPLICATION		0x40
#define BER_CONTEXT_SPECIFIC	0x80
#define BER_PRIVATE		0xc0

#define BER_PRIMITIVE		0x00
#define BER_CONSTRUCTED		0x20

#define BER_BOOL		0x01
#define BER_INTEGER		0x02
#define BER_BIT_STRING		0x03
#define BER_OCTET_STRING	0x04
#define BER_NULL		0x05
#define BER_OBJECT_ID		0x06
#define BER_OBJECT_DESC		0x07
#define BER_EXTERNAL		0x08
#define BER_REAL		0x09
#define BER_ENUMERATED		0x0a
#define BER_EMBEDDED_VALUE	0x0b	// Embedded presentation data value
#define BER_UTF8_STRING		0x0c
//#define BER_UNKNOWN		0x0d
//#define BER_UNKNOWN		0x0e
//#define BER_UNKNOWN		0x0f

#define BER_SEQUENCE_RAW	0x10
#define BER_SEQUENCE		(BER_SEQUENCE_RAW | BER_CONSTRUCTED)	// 0x30
#define BER_SET_RAW		0x11
#define BER_SET			(BER_SET_RAW | BER_CONSTRUCTED)		// 0x31

#define BER_NUMERIC_STRING	0x12
#define BER_PRINTABLE_STRING	0x13
#define BER_TELETEX_STRING	0x14	// Teletex, or T61
#define BER_VIDEOTEX_STRING	0x15
#define BER_IA5_STRING		0x16
#define BER_UTC_TIME		0x17
#define BER_GENERALIZED_TIME	0x18
#define BER_GRAPHIC_STRING	0x19
#define BER_VISIBLE_STRING	0x1a
#define BER_GENERAL_STRING	0x1b
#define BER_UNIVERSAL_STRING	0x1c
//#define BER_UNKNOWN		0x1d
#define BER_UNICODE_STRING	0x1e	// BMP: Basic Multilingual Plane
//#define BER_UNKNOWN		0x1f

#define BER_OPTIONAL		(BER_CONTEXT_SPECIFIC | BER_CONSTRUCTED) //0xa0

#endif  // __CSBER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\cscsp.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cscsp.h
//
// Contents:    Cert Server CSP routines.
//
//---------------------------------------------------------------------------

#ifndef __CSCSP_H__
#define __CSCSP_H__

HRESULT
myGetCertSrvCSP(
    IN BOOL fEncryptionCSP,
    IN WCHAR const *pwszCAName,
    OUT DWORD *pdwProvType,
    OUT WCHAR **ppwszProvName,
    OUT ALG_ID *pidAlg,
    OUT BOOL *pfMachineKeyset,
    OPTIONAL OUT DWORD *pdwKeySize);

BOOL
myCertSrvCryptAcquireContext(
    OUT HCRYPTPROV *phProv,
    IN WCHAR const *pwszContainer,
    IN WCHAR const *pwszProvider,
    IN DWORD        dwProvType,
    IN DWORD        dwFlags,
    IN BOOL         fMachineKeyset);

HRESULT
myGetSigningOID(
    OPTIONAL IN HCRYPTPROV hProv,	// hProv OR pwszProvName & dwProvType
    OPTIONAL IN WCHAR const *pwszProvName,
    OPTIONAL IN DWORD dwProvType,
    IN ALG_ID idHashAlg,
    OUT CHAR **ppszAlgId);

HRESULT
myValidateSigningKey(
    IN WCHAR const *pwszKeyContainerName,
    IN WCHAR const *pwszProvName,
    IN DWORD dwProvType,
    IN BOOL fCryptSilent,
    IN BOOL fMachineKeyset,
    IN BOOL fForceSignatureTest,
    IN OPTIONAL CERT_CONTEXT const *pcc,
    IN OPTIONAL CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN ALG_ID idAlg,
    OPTIONAL OUT BOOL *pfSigningTestAttempted,
    OPTIONAL OUT HCRYPTPROV *phProv);

HRESULT
myValidateKeyForSigning(
    IN HCRYPTPROV hProv,
    OPTIONAL IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN ALG_ID algId);

HRESULT
myValidateKeyForEncrypting(
    IN HCRYPTPROV hProv,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN ALG_ID algId);

HRESULT
myEnumProviders(
   IN DWORD dwIndex,
   IN DWORD *pdwReserved,
   IN DWORD dwFlags,
   OUT DWORD *pdwProvType,
   OUT WCHAR **ppwszProvName);

#endif // __CSCSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\csdisp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       csdisp.h
//
//  Contents:   IDispatch helper functions
//
//  History:    09-Dec-96   vich    created
//
//--------------------------------------------------------------------------

#ifndef __CSDISP_H__
#define __CSDISP_H__

typedef struct _DISPATCHTABLE
{
    OLECHAR **apszNames;
    DWORD     cdispid;
    DWORD     idispid;
} DISPATCHTABLE;

class DISPATCHINTERFACE
{
public:
    DISPATCHINTERFACE()
    {
	pDispatch = NULL;
	pUnknown = NULL;
	pDispatchTable = NULL;
	m_cDispatchTable = 0;
	m_fiidValid = FALSE;
	m_adispid = NULL;
	m_dwVersion = 0;
    }

    VOID SetIID(
	OPTIONAL IN IID const *piid)
    {
	if (NULL != piid)
	{
	    m_iid = *piid;
	    m_fiidValid = TRUE;
	}
    }

    IID const *GetIID() { return(m_fiidValid? &m_iid : NULL); }

    IDispatch     *pDispatch;
    IUnknown      *pUnknown;
    DISPATCHTABLE *pDispatchTable;
    DWORD          m_cDispatchTable;
    DWORD          m_cdispid;
    DISPID        *m_adispid;
    DWORD	   m_dwVersion;
    DWORD	   m_ClassContext;

private:
    IID	           m_iid;
    BOOL           m_fiidValid;
};


#define DECLARE_DISPATCH_ENTRY(apszMethod) \
    { apszMethod, ARRAYSIZE(apszMethod), },


// DispatchSetup Flags:
#define DISPSETUP_COM		0x00000000
#define DISPSETUP_IDISPATCH	0x00000001
#define DISPSETUP_COMFIRST	0x00000002	// Try COM, then IDispatch

HRESULT
DispatchInvoke(
    IN DISPATCHINTERFACE *pDispatchInterface,
    IN LONG MethodIndex,
    IN DWORD cvar,
    IN VARIANT avar[],
    IN LONG Type,
    OPTIONAL OUT VOID *pretval);

HRESULT
DispatchGetReturnValue(
    IN OUT VARIANT *pvar,
    IN LONG Type,
    OUT VOID *pretval);

HRESULT
DispatchGetIds(
    IN IDispatch *pDispatch,
    IN DWORD cDispatchTable,
    IN OUT DISPATCHTABLE *pDispatchTable,
    IN OUT DISPATCHINTERFACE *pDispatchInterface);

HRESULT
DispatchSetup(
    IN DWORD Flags,
    IN DWORD ClassContext,
    OPTIONAL IN TCHAR const *pszProgID,	        // for IDispatch
    OPTIONAL IN CLSID const *pclsid,		// for COM
    OPTIONAL IN IID const *piid,		// for COM
    IN DWORD cDispatchTable,
    IN OUT DISPATCHTABLE *pDispatchTable,
    IN OUT DISPATCHINTERFACE *pDispatchInterface);

HRESULT
DispatchSetup2(
    IN DWORD Flags,
    IN DWORD ClassContext,
    IN WCHAR const *pwszClass,		// wszRegKeyAdminClsid
    IN CLSID const *pclsid,
    IN DWORD cver,
    IN IID const * const *ppiid,	// cver elements
    IN DWORD const *pcDispatch,		// cver elements
    IN OUT DISPATCHTABLE *pDispatchTable,
    IN OUT DISPATCHINTERFACE *pDispatchInterface);

VOID
DispatchRelease(
    IN OUT DISPATCHINTERFACE *pDispatchInterface);

HRESULT
DispatchSetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const *pwszProgId,
    OPTIONAL IN IID const *piid);

// Temporary:
#define ConvertWszToBstr	myConvertWszToBstr
#define ConvertSzToBstr		myConvertSzToBstr
#define ConvertWszToSz		myConvertWszToSz
#define ConvertSzToWsz		myConvertSzToWsz

BOOL
myConvertWszToBstr(
    OUT BSTR *pbstr,
    IN WCHAR const *pwc,
    IN LONG cb);

BOOL
myConvertSzToBstr(
    OUT BSTR *pbstr,
    IN CHAR const *pch,
    IN LONG cch);

//+-------------------------------------------------------------------------
// ICertConfig dispatch support

HRESULT
Config_Init(
    IN DWORD Flags,			// See DispatchSetup() Flags
    IN OUT DISPATCHINTERFACE *pdiConfig);

VOID
Config_Release(
    IN OUT DISPATCHINTERFACE *pdiConfig);

HRESULT
Config_Reset(
    IN DISPATCHINTERFACE *pdiConfig,
    IN LONG Index,
    OUT LONG *pcount);

HRESULT
Config_Next(
    IN DISPATCHINTERFACE *pdiConfig,
    OUT LONG *pcount);

HRESULT
Config_GetField(
    IN DISPATCHINTERFACE *pdiConfig,
    IN WCHAR const *pwszField,
    OUT BSTR *pbstr);

HRESULT
Config_GetConfig(
    IN DISPATCHINTERFACE *pdiConfig,
    IN LONG Flags,
    OUT BSTR *pbstrConfig);

HRESULT
Config2_SetSharedFolder(
    IN DISPATCHINTERFACE *pdiConfig,
    IN WCHAR const *pwszSharedFolder);


HRESULT
ConfigDump(
    IN DWORD Flags,				// See DispatchSetup() Flags
    IN WCHAR const *pwszEntry,			// localized L"Entry"
    OPTIONAL IN WCHAR const *pwszLocalSuffix,	// localized L"(Local)"
    OPTIONAL IN WCHAR const *pwszMach1,
    OPTIONAL IN WCHAR const *pwszMach2);

HRESULT
ConfigDumpSetDisplayNames(
    IN WCHAR const * const *apwszFieldNames,
    IN WCHAR const * const *apwszDisplayNames,
    IN DWORD cNames);

HRESULT
ConfigDumpEntry(
    IN DISPATCHINTERFACE *pdiConfig,
    IN WCHAR const *pwszEntry,                // localized L"Entry"
    IN LONG Index,  // less than 0 skip index, entry, & suffix print
    OPTIONAL IN WCHAR const *pwszSuffix);

HRESULT
ConfigGetConfig(
    IN DWORD Flags,			// See DispatchSetup() Flags
    IN DWORD dwDefault,     		// see CC_ defines in certcli.h
    OUT BSTR *pstrConfig);


//+-------------------------------------------------------------------------
// ICertRequest dispatch support

HRESULT
Request_Init(
    IN DWORD Flags,			// See DispatchSetup() Flags
    IN OUT DISPATCHINTERFACE *pdiRequest);

VOID
Request_Release(
    IN OUT DISPATCHINTERFACE *pdiRequest);

HRESULT
Request_Submit(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG Flags,
    IN WCHAR const *pwszRequest,
    IN DWORD cbRequest,
    IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszConfig,
    OUT LONG *pDisposition);

HRESULT
Request_RetrievePending(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG RequestId,
    IN WCHAR const *pwszConfig,
    OUT LONG *pDisposition);

HRESULT
Request_GetLastStatus(
    IN DISPATCHINTERFACE *pdiRequest,
    OUT LONG *pLastStatus);

HRESULT
Request_GetRequestId(
    IN DISPATCHINTERFACE *pdiRequest,
    OUT LONG *pRequestId);

HRESULT
Request_GetDispositionMessage(
    IN DISPATCHINTERFACE *pdiRequest,
    OUT BSTR *pstrMessage);

HRESULT
Request_GetCertificate(
    IN DISPATCHINTERFACE *pdiRequest,
    IN DWORD Flags,
    OUT BSTR *pstrCert);

HRESULT
Request_GetCACertificate(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG fExchangeCertificate,
    IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    OUT BSTR *pstrCert);

HRESULT
Request2_GetIssuedCertificate(
    IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszSerialNumber,
    OUT LONG *pDisposition);

HRESULT
Request2_GetErrorMessageText(
    IN LONG hrMessage,
    IN LONG Flags,
    OUT BSTR *pstrErrorMessageText);

HRESULT
Request2_GetCAProperty(
    IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    IN LONG PropIndex,
    IN LONG PropType,
    IN LONG Flags,
    OUT VOID *pPropertyValue);

HRESULT
Request2_GetCAPropertyFlags(
    IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT LONG *pPropFlags);

HRESULT
Request2_GetCAPropertyDisplayName(
    IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT BSTR *pstrDisplayName);

HRESULT
Request2_GetFullResponseProperty(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG PropId,
    IN LONG PropIndex,
    IN LONG PropType,
    IN LONG Flags,
    OUT VOID *pPropertyValue);


//+-------------------------------------------------------------------------
// ICertServerExit dispatch support

HRESULT
CIExit_Init(
    IN DWORD Flags,			// See DispatchSetup() Flags
    IN OUT DISPATCHINTERFACE *pdiCIExit);

VOID
CIExit_Release(
    IN OUT DISPATCHINTERFACE *pdiCIExit);

HRESULT
CIExit_SetContext(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN LONG Context);

HRESULT
CIExit_GetRequestProperty(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue);

HRESULT
CIExit_GetRequestAttribute(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszPropName,
    OUT BSTR *pbstrPropValue);

HRESULT
CIExit_GetCertificateProperty(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue);

HRESULT
CIExit_GetCertificateExtension(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    OUT BSTR *pbstrValue);

HRESULT
CIExit_GetCertificateExtensionFlags(
    IN DISPATCHINTERFACE *pdiCIExit,
    OUT LONG *pExtFlags);

HRESULT
CIExit_EnumerateExtensionsSetup(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN LONG Flags);

HRESULT
CIExit_EnumerateExtensions(
    IN DISPATCHINTERFACE *pdiCIExit,
    OUT BSTR *pstrExtensionName);

HRESULT
CIExit_EnumerateExtensionsClose(
    IN DISPATCHINTERFACE *pdiCIExit);

HRESULT
CIExit_EnumerateAttributesSetup(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN LONG Flags);

HRESULT
CIExit_EnumerateAttributes(
    IN DISPATCHINTERFACE *pdiCIExit,
    OUT BSTR *pstrAttributeName);

HRESULT
CIExit_EnumerateAttributesClose(
    IN DISPATCHINTERFACE *pdiCIExit);


//+-------------------------------------------------------------------------
// ICertServerPolicy dispatch support


HRESULT
CIPolicy_Init(
    IN DWORD Flags,			// See DispatchSetup() Flags
    IN OUT DISPATCHINTERFACE *pdiCIPolicy);

VOID
CIPolicy_Release(
    IN OUT DISPATCHINTERFACE *pdiCIPolicy);

HRESULT
CIPolicy_SetContext(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN LONG Context);

HRESULT
CIPolicy_GetRequestProperty(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue);

HRESULT
CIPolicy_GetRequestAttribute(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    OUT BSTR *pbstrPropValue);

HRESULT
CIPolicy_GetCertificateProperty(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue);

HRESULT
CIPolicy_SetCertificateProperty(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    IN WCHAR const *pwszPropValue);

HRESULT
CIPolicy_GetCertificateExtension(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    OUT BSTR *pbstrValue);

HRESULT
CIPolicy_GetCertificateExtensionFlags(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    OUT LONG *pExtFlags);

HRESULT
CIPolicy_SetCertificateExtension(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    IN LONG ExtFlags,
    IN void const *pvValue);

HRESULT
CIPolicy_EnumerateExtensionsSetup(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN LONG Flags);

HRESULT
CIPolicy_EnumerateExtensions(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    OUT BSTR *pstrExtensionName);

HRESULT
CIPolicy_EnumerateExtensionsClose(
    IN DISPATCHINTERFACE *pdiCIPolicy);

HRESULT
CIPolicy_EnumerateAttributesSetup(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN LONG Flags);

HRESULT
CIPolicy_EnumerateAttributes(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    OUT BSTR *pstrAttributeName);

HRESULT
CIPolicy_EnumerateAttributesClose(
    IN DISPATCHINTERFACE *pdiCIPolicy);


//+-------------------------------------------------------------------------
// ICertAdmin dispatch support

HRESULT
Admin_Init(
    IN DWORD Flags,			// See DispatchSetup() Flags
    IN OUT DISPATCHINTERFACE *pdiAdmin);

VOID
Admin_Release(
    IN OUT DISPATCHINTERFACE *pdiAdmin);

HRESULT
Admin_IsValidCertificate(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSerialNumber,
    OUT LONG *pDisposition);

HRESULT
Admin_GetRevocationReason(
    IN DISPATCHINTERFACE *pdiAdmin,
    OUT LONG *pReason);

HRESULT
Admin_RevokeCertificate(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSerialNumber,
    IN LONG Reason,
    IN DATE Date);

HRESULT
Admin_SetRequestAttributes(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszAttributes);

HRESULT
Admin_SetCertificateExtension(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    IN LONG Flags,
    IN VARIANT const *pvarValue);

HRESULT
Admin_DenyRequest(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId);

HRESULT
Admin_ResubmitRequest(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    OUT LONG *pDisposition);

HRESULT
Admin_PublishCRL(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN DATE Date);

HRESULT
Admin_GetCRL(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG Flags,
    OUT BSTR *pstrCRL);

HRESULT
Admin_ImportCertificate(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszCertificate,
    IN DWORD cbCertificate,
    IN LONG dwFlags,
    OUT LONG *RequestId);

HRESULT
Admin2_PublishCRLs(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN DATE Date,
    IN LONG CRLFlags);		// CA_CRL_*

HRESULT
Admin2_GetCAProperty(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    IN LONG PropIndex,
    IN LONG PropType,
    IN LONG Flags,
    OUT VOID *pPropertyValue);

HRESULT
Admin2_SetCAProperty(
    IN WCHAR const *pwszConfig,
    IN LONG PropId,		// CR_PROP_*
    IN LONG PropIndex,
    IN LONG PropType,		// PROPTYPE_*
    IN VARIANT *pvarPropertyValue);

HRESULT
Admin2_GetCAPropertyFlags(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT LONG *pPropFlags);

HRESULT
Admin2_GetCAPropertyDisplayName(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT BSTR *pstrDisplayName);

HRESULT
Admin2_GetArchivedKey(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN LONG Flags,		// CR_OUT_*
    OUT BSTR *pstrArchivedKey);

HRESULT
Admin2_GetConfigEntry(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszNodePath,
    IN WCHAR const *pwszEntryName,
    OUT VARIANT *pvarEntry);

HRESULT
Admin2_SetConfigEntry(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszNodePath,
    IN WCHAR const *pwszEntryName,
    IN VARIANT const *pvarEntry);

HRESULT
Admin2_ImportKey(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszCertHash,
    IN LONG Flags,
    IN WCHAR const *pwszKey,
    IN DWORD cbKey);

HRESULT
Admin2_GetMyRoles(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    OUT LONG *pRoles);		// CA_ACCESS_*

HRESULT
Admin2_DeleteRow(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG Flags,		// CDR_*
    IN DATE Date,
    IN LONG Table,		// CVRC_TABLE_*
    IN LONG RowId,
    OUT LONG *pcDeleted);

HRESULT
AdminRevokeCertificate(
    IN DWORD Flags,
    OPTIONAL IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSerialNumber,
    IN LONG Reason,
    IN DATE Date);

//+-------------------------------------------------------------------------
// ICertView dispatch support

HRESULT
View_Init(
    IN DWORD Flags,			// See DispatchSetup() Flags
    IN OUT DISPATCHINTERFACE *pdiView);

VOID
View_Release(
    IN OUT DISPATCHINTERFACE *pdiView);

HRESULT
View_OpenConnection(
    IN DISPATCHINTERFACE *pdiView,
    IN WCHAR const *pwszConfig);

HRESULT
View_EnumCertViewColumn(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG fResultColumn,
    IN OUT DISPATCHINTERFACE *pdiViewColumn);

HRESULT
View_GetColumnCount(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG fResultColumn,
    OUT LONG *pcColumn);

HRESULT
View_GetColumnIndex(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG fResultColumn,
    IN WCHAR const *pwszColumnName,
    OUT LONG *pColumnIndex);

HRESULT
View_SetResultColumnCount(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG cResultColumn);

HRESULT
View_SetResultColumn(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG ColumnIndex);

HRESULT
View_SetRestriction(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG ColumnIndex,
    IN LONG SeekOperator,
    IN LONG SortOrder,
    IN VARIANT const *pvarValue);

HRESULT
View_OpenView(
    IN DISPATCHINTERFACE *pdiView,
    IN OUT DISPATCHINTERFACE *pdiViewRow);

HRESULT
View2_SetTable(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG Table);


//+-------------------------------------------------------------------------
// IEnumCERTVIEWCOLUMN dispatch support

interface IEnumCERTVIEWCOLUMN;

HRESULT
ViewColumn_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWCOLUMN *pEnumColumn,
    IN OUT DISPATCHINTERFACE *pdiViewColumn);

VOID
ViewColumn_Release(
    IN OUT DISPATCHINTERFACE *pdiViewColumn);

HRESULT
ViewColumn_Next(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pIndex);

HRESULT
ViewColumn_GetName(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT BSTR *pstrOut);

HRESULT
ViewColumn_GetDisplayName(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT BSTR *pstrOut);

HRESULT
ViewColumn_GetType(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pType);

HRESULT
ViewColumn_IsIndexed(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pIndexed);

HRESULT
ViewColumn_GetMaxLength(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pMaxLength);

HRESULT
ViewColumn_GetValue(
    IN DISPATCHINTERFACE *pdiViewColumn,
    IN LONG Flags,
    IN LONG ColumnType,
    OUT VOID *pColumnValue);

HRESULT
ViewColumn_Skip(
    IN DISPATCHINTERFACE *pdiViewColumn,
    IN LONG celt);

HRESULT
ViewColumn_Reset(
    IN DISPATCHINTERFACE *pdiViewColumn);

HRESULT
ViewColumn_Clone(
    IN DISPATCHINTERFACE *pdiViewColumn,
    IN OUT DISPATCHINTERFACE *pdiViewColumnClone);


//+-------------------------------------------------------------------------
// IEnumCERTVIEWATTRIBUTE dispatch support

interface IEnumCERTVIEWATTRIBUTE;

HRESULT
ViewAttribute_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWATTRIBUTE *pEnumAttribute,
    IN OUT DISPATCHINTERFACE *pdiViewAttribute);

VOID
ViewAttribute_Release(
    IN OUT DISPATCHINTERFACE *pdiViewAttribute);

HRESULT
ViewAttribute_Next(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    OUT LONG *pIndex);

HRESULT
ViewAttribute_GetName(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    OUT BSTR *pstrOut);

HRESULT
ViewAttribute_GetValue(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    OUT BSTR *pstrOut);

HRESULT
ViewAttribute_Skip(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    IN LONG celt);

HRESULT
ViewAttribute_Reset(
    IN DISPATCHINTERFACE *pdiViewAttribute);

HRESULT
ViewAttribute_Clone(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    IN OUT DISPATCHINTERFACE *pdiViewAttributeClone);


//+-------------------------------------------------------------------------
// IEnumCERTVIEWEXTENSION dispatch support

interface IEnumCERTVIEWEXTENSION;

HRESULT
ViewExtension_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWEXTENSION *pEnumExtension,
    IN OUT DISPATCHINTERFACE *pdiViewExtension);

VOID
ViewExtension_Release(
    IN OUT DISPATCHINTERFACE *pdiViewExtension);

HRESULT
ViewExtension_Next(
    IN DISPATCHINTERFACE *pdiViewExtension,
    OUT LONG *pIndex);

HRESULT
ViewExtension_GetName(
    IN DISPATCHINTERFACE *pdiViewExtension,
    OUT BSTR *pstrOut);

HRESULT
ViewExtension_GetFlags(
    IN DISPATCHINTERFACE *pdiViewExtension,
    OUT LONG *pFlags);

HRESULT
ViewExtension_GetValue(
    IN DISPATCHINTERFACE *pdiViewExtension,
    IN LONG Type,
    IN LONG Flags,
    OUT VOID *pValue);

HRESULT
ViewExtension_Skip(
    IN DISPATCHINTERFACE *pdiViewExtension,
    IN LONG celt);

HRESULT
ViewExtension_Reset(
    IN DISPATCHINTERFACE *pdiViewExtension);

HRESULT
ViewExtension_Clone(
    IN DISPATCHINTERFACE *pdiViewExtension,
    IN OUT DISPATCHINTERFACE *pdiViewExtensionClone);


//+-------------------------------------------------------------------------
// IEnumCERTVIEWROW dispatch support

interface IEnumCERTVIEWROW;

HRESULT
ViewRow_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWROW *pEnumRow,
    IN OUT DISPATCHINTERFACE *pdiViewRow);

VOID
ViewRow_Release(
    IN OUT DISPATCHINTERFACE *pdiViewRow);

HRESULT
ViewRow_Next(
    IN DISPATCHINTERFACE *pdiViewRow,
    OUT LONG *pIndex);

HRESULT
ViewRow_GetMaxIndex(
    IN DISPATCHINTERFACE *pdiViewRow,
    OUT LONG *pIndex);

HRESULT
ViewRow_EnumCertViewColumn(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN OUT DISPATCHINTERFACE *pdiViewColumn);

HRESULT
ViewRow_EnumCertViewAttribute(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN LONG Flags,
    IN OUT DISPATCHINTERFACE *pdiViewAttribute);

HRESULT
ViewRow_EnumCertViewExtension(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN LONG Flags,
    IN OUT DISPATCHINTERFACE *pdiViewExtension);

HRESULT
ViewRow_Skip(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN LONG celt);

HRESULT
ViewRow_Reset(
    IN DISPATCHINTERFACE *pdiViewRow);

HRESULT
ViewRow_Clone(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN OUT DISPATCHINTERFACE *pdiViewRowClone);

//+-------------------------------------------------------------------------
// IManageModule dispatch support
HRESULT
ManageModule_Init(
    IN DWORD Flags,
    IN WCHAR const *pszProgID,
    IN CLSID const *pclsid,		
    IN OUT DISPATCHINTERFACE *pdiManage);

HRESULT
ManageModule_Init2(
    IN BOOL fIDispatch,
    IN ICertManageModule *pManage,
    OUT DISPATCHINTERFACE *pdiManage);

VOID
ManageModule_Release(
    IN OUT DISPATCHINTERFACE *pdiManage);

HRESULT
ManageModule_GetProperty( 
    IN DISPATCHINTERFACE *pdiManage,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszStorageLocation,
    IN WCHAR const *pwszPropertyName,
    IN DWORD dwFlags,
    IN LONG PropertyType,
    OUT VOID *pProperty);
 
HRESULT
ManageModule_SetProperty( 
    IN DISPATCHINTERFACE *pdiManage,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszStorageLocation,
    IN WCHAR const *pwszPropertyName,
    IN DWORD dwFlags,
    IN LONG PropertyType,
    IN VOID *pProperty);

HRESULT 
ManageModule_Configure( 
    IN DISPATCHINTERFACE *pdiManage,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszStorageLocation,
    IN DWORD dwFlags);

//+-------------------------------------------------------------------------
// ICertPolicy dispatch support

#define POLICY_VERIFYREQUEST    0
#define POLICY_GETDESCRIPTION   1
#define POLICY_INITIALIZE       2
#define POLICY_SHUTDOWN         3
#define POLICY2_GETMANAGEMODULE 4

#define CPOLICYDISPATCH_V1	POLICY2_GETMANAGEMODULE
#define CPOLICYDISPATCH_V2	CPOLICYDISPATCH

extern DWORD s_acPolicyDispatch[2];
extern IID const *s_apPolicyiid[2];
extern DISPATCHTABLE g_adtPolicy[];
extern DWORD CPOLICYDISPATCH;

HRESULT
Policy_Initialize(
    IN DISPATCHINTERFACE *pdiPolicy,
    IN WCHAR const *pwszConfig);

HRESULT
Policy_ShutDown(
    IN DISPATCHINTERFACE *pdiPolicy);

HRESULT
Policy_VerifyRequest(
    IN DISPATCHINTERFACE *pdiPolicy,
    IN WCHAR const *pwszConfig,
    IN LONG Context,
    IN LONG bNewRequest,
    IN LONG Flags,
    OUT LONG *pResult);

HRESULT
Policy_GetDescription(
    IN DISPATCHINTERFACE *pdiPolicy,
    OUT BSTR *pstrDescription);

HRESULT
Policy2_GetManageModule(
    IN DISPATCHINTERFACE *pdiPolicy,
    OUT DISPATCHINTERFACE *pdiManageModule);

HRESULT
Policy_Init(
    IN DWORD Flags,
    IN LPCWSTR pcwszProgID,
    IN CLSID const *pclsid,
    OUT DISPATCHINTERFACE *pdiCIPolicy);

VOID
Policy_Release(
    IN OUT DISPATCHINTERFACE *pdiManage);

//+-------------------------------------------------------------------------
// ICertExit dispatch support

#define EXIT_INITIALIZE         0
#define EXIT_NOTIFY             1
#define EXIT_GETDESCRIPTION     2
#define EXIT2_GETMANAGEMODULE   3

#define CEXITDISPATCH_V1	EXIT2_GETMANAGEMODULE
#define CEXITDISPATCH_V2	CEXITDISPATCH

extern DISPATCHTABLE g_adtExit[];
extern DWORD CEXITDISPATCH;
extern DWORD s_acExitDispatch[2];
extern IID const *s_apExitiid[2];

HRESULT
Exit_Init(
    IN DWORD Flags,
    IN LPCWSTR pcwszProgID,
    IN CLSID const *pclsid,
    OUT DISPATCHINTERFACE *pdi);

VOID
Exit_Release(
    IN OUT DISPATCHINTERFACE *pdiManage);

HRESULT
Exit_Initialize(
    IN DISPATCHINTERFACE *pdiExit,
    IN WCHAR const *pwszConfig,
    OUT LONG *pEventMask);

HRESULT
Exit_Notify(
    IN DISPATCHINTERFACE *pdiExit,
    IN LONG ExitEvent,
    IN LONG Context);

HRESULT
Exit_GetDescription(
    IN DISPATCHINTERFACE *pdiExit,
    OUT BSTR *pstrDescription);

HRESULT
Exit2_GetManageModule(
    IN DISPATCHINTERFACE *pdiExit,
    OUT DISPATCHINTERFACE *pdiManageModule);


#endif // __CSDISP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\csfile.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2001
//
// File:        csfile.h
//
// Contents:    Cert Server file number definitions
//
//---------------------------------------------------------------------------

#ifndef __CSFILE_H__
#define __CSFILE_H__

// Do not comment out unused identifiers and do not remove or renumber any
// identifiers.  This preserves compatibility so certlog.exe can use this
// include file to process old log files into the correct file names and line
// numbers.

#define __dwFILE_OCMSETUP_BROWSEDI_CPP__	101
#define __dwFILE_OCMSETUP_CONFIG_CPP__		102
#define __dwFILE_OCMSETUP_CRYPTFIX_CPP__	103
#define __dwFILE_OCMSETUP_CSOCM_CPP__		104
#define __dwFILE_OCMSETUP_CSPENUM_CPP__		105
#define __dwFILE_OCMSETUP_DSSETUP_CPP__		106
#define __dwFILE_OCMSETUP_PFXIMPT_CPP__		107
#define __dwFILE_OCMSETUP_REGD_CPP__		108
#define __dwFILE_OCMSETUP_SETUPUT_CPP__		109
#define __dwFILE_OCMSETUP_UNATTEND_CPP__	110
#define __dwFILE_OCMSETUP_USECERT_CPP__		111
#define __dwFILE_OCMSETUP_WIZPAGE_CPP__		112
#define __dwFILE_OCMSETUP_REG_CPP__		113

#define __dwFILE_INITLIB_CERTHIER_CPP__		201
#define __dwFILE_INITLIB_INITLIB_CPP__		202
#define __dwFILE_INITLIB_KEYENUM_CPP__		203
#define __dwFILE_INITLIB_LOG_CPP__		204
#define __dwFILE_INITLIB_CERTMSG_CPP__		205
#define __dwFILE_INITLIB_CERTUI_CPP__		206

#define __dwFILE_CERTUTIL_CERTUTIL_CPP__	301
#define __dwFILE_CERTUTIL_ADMIN_CPP__		302
#define __dwFILE_CERTUTIL_BACKUP_CPP__		303
#define __dwFILE_CERTUTIL_DB2_CPP__		304
#define __dwFILE_CERTUTIL_DBCNVT_CPP__		305
#define __dwFILE_CERTUTIL_DBCORE_CPP__		306
#define __dwFILE_CERTUTIL_DS_CPP__		307
#define __dwFILE_CERTUTIL_DUMP_CPP__		308
#define __dwFILE_CERTUTIL_INFO_CPP__		309
#define __dwFILE_CERTUTIL_MISC_CPP__		310
#define __dwFILE_CERTUTIL_ODBC_CPP__		311
#define __dwFILE_CERTUTIL_REG_CPP__		312
#define __dwFILE_CERTUTIL_STORE_CPP__		313
#define __dwFILE_CERTUTIL_TCAINFO_CPP__		314
#define __dwFILE_CERTUTIL_VERIFY_CPP__		315
#define __dwFILE_CERTUTIL_VIEW_CPP__		316
#define __dwFILE_CERTUTIL_SCINFO_CPP__		317
#define __dwFILE_CERTUTIL_EPF_CPP__             318
#define __dwFILE_CERTUTIL_URL_CPP__             319
#define __dwFILE_CERTUTIL_CACHE_CPP__           320

#define __dwFILE_CERTLIB_INF_CPP__		401
#define __dwFILE_CERTLIB_LOG_CPP__		402
#define __dwFILE_CERTLIB_CERTMSG_CPP__		403
#define __dwFILE_CERTLIB_ACL_CPP__		404
#define __dwFILE_CERTLIB_ADMIN_CPP__		405
#define __dwFILE_CERTLIB_ADVAPI32_CPP__		406
#define __dwFILE_CERTLIB_BACKUP_CPP__		407
#define __dwFILE_CERTLIB_BASE64_CPP__		408
#define __dwFILE_CERTLIB_CASD_CPP__		409
#define __dwFILE_CERTLIB_CERTLIB_CPP__		410
#define __dwFILE_CERTLIB_CERTPICK_CPP__		411
#define __dwFILE_CERTLIB_CERTSD_CPP__		412
#define __dwFILE_CERTLIB_CHECK7F_CPP__		413
#define __dwFILE_CERTLIB_CIEXIT_CPP__		414
#define __dwFILE_CERTLIB_CIPOLICY_CPP__		415
#define __dwFILE_CERTLIB_CNFGSTG_CPP__		416
#define __dwFILE_CERTLIB_CONFIG_CPP__		417
#define __dwFILE_CERTLIB_CRFILE_CPP__		418
#define __dwFILE_CERTLIB_CRYPT_CPP__		419
#define __dwFILE_CERTLIB_CSCSP_CPP__		420
#define __dwFILE_CERTLIB_CSLISTVW_CPP__		421
#define __dwFILE_CERTLIB_CSPELOG_CPP__		422
#define __dwFILE_CERTLIB_CSW97PPG_CPP__		423
#define __dwFILE_CERTLIB_CSW97SHT_CPP__		424
#define __dwFILE_CERTLIB_DCOM_CPP__		425
#define __dwFILE_CERTLIB_DISPATCH_CPP__		426
#define __dwFILE_CERTLIB_HEX_CPP__		427
#define __dwFILE_CERTLIB_KEYGEN2_CPP__		428
#define __dwFILE_CERTLIB_LDAP_CPP__		429
#define __dwFILE_CERTLIB_MANAGE_CPP__		430
#define __dwFILE_CERTLIB_MAPI_CPP__		431
#define __dwFILE_CERTLIB_OFFICER_CPP__		432
#define __dwFILE_CERTLIB_PKIFMT_CPP__		433
#define __dwFILE_CERTLIB_PROGRESS_CPP__		434
#define __dwFILE_CERTLIB_PROP2_CPP__		435
#define __dwFILE_CERTLIB_PRVLG_CPP__		436
#define __dwFILE_CERTLIB_REG_CPP__		437
#define __dwFILE_CERTLIB_REQUEST_CPP__		438
#define __dwFILE_CERTLIB_STRING_CPP__		439
#define __dwFILE_CERTLIB_TFC_CPP__		440
#define __dwFILE_CERTLIB_TFCPROP_CPP__		441
#define __dwFILE_CERTLIB_TMPLLIST_CPP__		442
#define __dwFILE_CERTLIB_VIEW_CPP__		443
#define __dwFILE_CERTLIB_VIEWATTR_CPP__		444
#define __dwFILE_CERTLIB_VIEWCOL_CPP__		445
#define __dwFILE_CERTLIB_VIEWEXT_CPP__		446
#define __dwFILE_CERTLIB_VIEWROW_CPP__		447

#define __dwFILE_CERTSRV_ADMIN_CPP__		501
#define __dwFILE_CERTSRV_CALLBACK_CPP__		502
#define __dwFILE_CERTSRV_CERTSRV_CPP__		503
#define __dwFILE_CERTSRV_CERTSRVD_CPP__		504
#define __dwFILE_CERTSRV_CIENUM_CPP__		505
#define __dwFILE_CERTSRV_COM_CPP__		506
#define __dwFILE_CERTSRV_COMTEST_CPP__		507
#define __dwFILE_CERTSRV_CORE_CPP__		508
#define __dwFILE_CERTSRV_CRL_CPP__		509
#define __dwFILE_CERTSRV_DB3_CPP__		510
#define __dwFILE_CERTSRV_ELOG_CPP__		511
#define __dwFILE_CERTSRV_EVENT_CPP__		512
#define __dwFILE_CERTSRV_PKCS_CPP__		513
#define __dwFILE_CERTSRV_PROP_CPP__		514
#define __dwFILE_CERTSRV_REQUEST_CPP__		515
#define __dwFILE_CERTSRV_RPC_CPP__		516
#define __dwFILE_CERTSRV_SERVICE_CPP__		517

#define __dwFILE_CERTADM_ADMIN_CPP__		601
#define __dwFILE_CERTADM_ATL_CPP__		602
#define __dwFILE_CERTADM_BACKUP_CPP__		603
#define __dwFILE_CERTADM_CERTADM_CPP__		604
#define __dwFILE_CERTADM_MANAGE_CPP__		605
#define __dwFILE_CERTADM_RESTORE_CPP__		606

#define __dwFILE_CERTCLI_ATL_CPP__		701
#define __dwFILE_CERTCLI_CERTCLI_CPP__		702
#define __dwFILE_CERTCLI_COLUMN_CPP__		703
#define __dwFILE_CERTCLI_CONFIG_CPP__		704
#define __dwFILE_CERTCLI_CONFIGP_CPP__		705
#define __dwFILE_CERTCLI_CRYPT_CPP__		706
#define __dwFILE_CERTCLI_GETCONF_CPP__		707
#define __dwFILE_CERTCLI_REQUEST_CPP__		708
#define __dwFILE_CERTCLI_UWBASE64_CPP__		709
#define __dwFILE_CERTCLI_VROOT_CPP__		710

#define __dwFILE_CERTCLIB_ALLOC_CPP__		801
#define __dwFILE_CERTCLIB_ASSERT_CPP__		802
#define __dwFILE_CERTCLIB_AUTOENRL_CPP__	803
#define __dwFILE_CERTCLIB_CAINFO_CPP__		804
#define __dwFILE_CERTCLIB_CAINFOC_CPP__		805
#define __dwFILE_CERTCLIB_CAINFOP_CPP__		806
#define __dwFILE_CERTCLIB_CERTDEC_CPP__		807
#define __dwFILE_CERTCLIB_CERTTYPE_CPP__	808
#define __dwFILE_CERTCLIB_CTNOTIFY_CPP__	809
#define __dwFILE_CERTCLIB_DEBUG_CPP__		810
#define __dwFILE_CERTCLIB_DEFTYPES_CPP__	811
#define __dwFILE_CERTCLIB_DSTEST_CPP__		812
#define __dwFILE_CERTCLIB_ERROR_CPP__		813
#define __dwFILE_CERTCLIB_LOGON_CPP__		814
#define __dwFILE_CERTCLIB_OIDMGR_CPP__		815
#define __dwFILE_CERTCLIB_SERIAL_CPP__		816

#define __dwFILE_CERTMMC_ABOUT_CPP__		901
#define __dwFILE_CERTMMC_BROWSEDI_CPP__		902
#define __dwFILE_CERTMMC_CASEC_CPP__		903
#define __dwFILE_CERTMMC_CERTIF_CPP__		904
#define __dwFILE_CERTMMC_CERTWRAP_CPP__		905
#define __dwFILE_CERTMMC_CHOOSER_CPP__		906
#define __dwFILE_CERTMMC_COMPDATA_CPP__		907
#define __dwFILE_CERTMMC_CSNAPIN_CPP__		908
#define __dwFILE_CERTMMC_DATAOBJ_CPP__		909
#define __dwFILE_CERTMMC_EVENTS_CPP__		910
#define __dwFILE_CERTMMC_FOLDERS_CPP__		911
#define __dwFILE_CERTMMC_GENPAGE_CPP__		912
#define __dwFILE_CERTMMC_KRAPAGE_CPP__		913
#define __dwFILE_CERTMMC_MISC_CPP__		914
#define __dwFILE_CERTMMC_OFFICER_CPP__		915
#define __dwFILE_CERTMMC_SNAPIN_CPP__		916
#define __dwFILE_CERTMMC_URLS_CPP__		917
#define __dwFILE_CERTMMC_UUIDS_CPP__		918

#define __dwFILE_POLICY_DEFAULT_ATL_CPP__	1001
#define __dwFILE_POLICY_DEFAULT_CERTPDEF_CPP__	1002
#define __dwFILE_POLICY_DEFAULT_MODULE_CPP__	1003
#define __dwFILE_POLICY_DEFAULT_POLICY_CPP__	1004
#define __dwFILE_POLICY_DEFAULT_REQUEST_CPP__	1005
#define __dwFILE_POLICY_DEFAULT_TEMPLATE_CPP__	1006

#define __dwFILE_CERTDB_ATL_CPP__		1101
#define __dwFILE_CERTDB_BACKUP_CPP__		1102
#define __dwFILE_CERTDB_CERTDB_CPP__		1103
#define __dwFILE_CERTDB_COLUMN_CPP__		1104
#define __dwFILE_CERTDB_DB_CPP__		1105
#define __dwFILE_CERTDB_DBTABLE_CPP__		1106
#define __dwFILE_CERTDB_DBW_CPP__		1107
#define __dwFILE_CERTDB_ENUM_CPP__		1108
#define __dwFILE_CERTDB_PCH_CPP__		1109
#define __dwFILE_CERTDB_RESTORE_CPP__		1110
#define __dwFILE_CERTDB_ROW_CPP__		1111
#define __dwFILE_CERTDB_VIEW_CPP__		1112

#define __dwFILE_CERTVIEW_ATTRIB_CPP__		1201
#define __dwFILE_CERTVIEW_CERTVIEW_CPP__	1202
#define __dwFILE_CERTVIEW_COLUMN_CPP__		1203
#define __dwFILE_CERTVIEW_EXT_CPP__		1204
#define __dwFILE_CERTVIEW_PCH_CPP__		1205
#define __dwFILE_CERTVIEW_ROW_CPP__		1206
#define __dwFILE_CERTVIEW_VIEW_CPP__		1207
#define __dwFILE_CERTLIB_POLDISP_CPP__		1208
#define __dwFILE_CERTLIB_EXITDISP_CPP__		1209
#define __dwFILE_CERTLIB_MULTISZ_CPP__		1210
#define __dwFILE_CERTLIB_CSTRING_CPP__		1211

#define __dwFILE_CERTIF_CIEXIT_CPP__		1301
#define __dwFILE_CERTIF_CIPOLICY_CPP__		1302

#define __dwFILE_CERTREQ_CERTREQ_CPP__		1401

#define __dwFILE_CAPESNPN_ABOUT_CPP__		1501
#define __dwFILE_CAPESNPN_COMPDATA_CPP__	1502
#define __dwFILE_CAPESNPN_CSNAPIN_CPP__		1503
#define __dwFILE_CAPESNPN_CTSHLEXT_CPP__	1504
#define __dwFILE_CAPESNPN_DATAOBJ_CPP__		1505
#define __dwFILE_CAPESNPN_EVENTS_CPP__		1506
#define __dwFILE_CAPESNPN_GENPAGE_CPP__		1507
#define __dwFILE_CAPESNPN_MISC_CPP__		1508
#define __dwFILE_CAPESNPN_SERVICE_CPP__		1509
#define __dwFILE_CAPESNPN_SNAPIN_CPP__		1510
#define __dwFILE_CAPESNPN_UUIDS_CPP__		1511

#define __dwFILE_EXIT_DEFAULT_ATL_CPP__		1601
#define __dwFILE_EXIT_DEFAULT_CERTXDS_CPP__	1602
#define __dwFILE_EXIT_DEFAULT_EXIT_CPP__	1603
#define __dwFILE_EXIT_DEFAULT_MODULE_CPP__	1604

#define __dwFILE_CERTLOG_CERTLOG_CPP__		1701

#define __dwFILE_INCLUDE_CSPROP2_CPP__		1801

#endif // __CSFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\csldap.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csldap.h
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#ifndef __CSLDAP_H__
#define __CSLDAP_H__

#define csecLDAPTIMEOUT	(2 * 60)	// two minute default search timeout

#define wszDSUSERCERTATTRIBUTE		L"userCertificate"
#define wszDSCROSSCERTPAIRATTRIBUTE	L"crossCertificatePair"
#define wszDSKRACERTATTRIBUTE		wszDSUSERCERTATTRIBUTE
#define wszDSCACERTATTRIBUTE		L"cACertificate"
#define wszDSBASECRLATTRIBUTE		L"certificateRevocationList"
#define wszDSDELTACRLATTRIBUTE		L"deltaRevocationList"
#define wszDSAUTHORITYCRLATTRIBUTE	L"authorityRevocationList"
#define wszDSOBJECTCLASSATTRIBUTE	L"objectClass"
#define wszDSFLAGSATTRIBUTE		L"flags"
#define wszDSSAMACCOUNTNAMEATTRIBUTE	L"sAMAccountName"
#define wszDSMAILATTRIBUTE		L"mail"
#define wszDSDNSHOSTNAMEATTRIBUTE       L"dNSHostName"
#define wszDSDNATTRIBUTE		L"distinguishedName"
#define wszDSNAMEATTRIBUTE              L"name"


#define wszDSBASESEARCH		L"?base"
#define wszDSONESEARCH		L"?one"
#define wszDSSUBSEARCH		L"?sub"

#define wszDSTOPCLASSNAME	L"top"
#define wszDSPERSONCLASSNAME	L"person"
#define wszDSORGPERSONCLASSNAME	L"organizationalPerson"
#define wszDSUSERCLASSNAME	L"user"
#define wszDSCONTAINERCLASSNAME L"container"
#define wszDSENROLLMENTSERVICECLASSNAME L"pKIEnrollmentService"
#define wszDSMACHINECLASSNAME	L"computer"
#define wszDSTEMPLATELASSNAME	L"pKICertificateTemplate"
#define wszDSKRACLASSNAME	L"msPKI-PrivateKeyRecoveryAgent"
#define wszDSCDPCLASSNAME	L"cRLDistributionPoint"
#define wszDSOIDCLASSNAME	L"msPKI-Enterprise-Oid"
#define wszDSCACLASSNAME	L"certificationAuthority"
#define wszDSAIACLASSNAME	wszDSCACLASSNAME

#define wszDSCDPCLASS	L"?" wszDSOBJECTCLASSATTRIBUTE L"=" wszDSCDPCLASSNAME
#define wszDSCACLASS	L"?" wszDSOBJECTCLASSATTRIBUTE L"=" wszDSCACLASSNAME
#define wszDSUSERCLASS	L"?" wszDSOBJECTCLASSATTRIBUTE L"=*"
#define wszDSKRACLASS	L"?" wszDSOBJECTCLASSATTRIBUTE L"=" wszDSKRACLASSNAME
#define wszDSAIACLASS	L"?" wszDSOBJECTCLASSATTRIBUTE L"=" wszDSAIACLASSNAME

#define wszDSSEARCHBASECRLATTRIBUTE \
    L"?" \
    wszDSBASECRLATTRIBUTE \
    wszDSBASESEARCH \
    wszDSCDPCLASS

#define wszDSSEARCHDELTACRLATTRIBUTE \
    L"?" \
    wszDSDELTACRLATTRIBUTE \
    wszDSBASESEARCH \
    wszDSCDPCLASS

#define wszDSSEARCHUSERCERTATTRIBUTE \
    L"?" \
    wszDSUSERCERTATTRIBUTE \
    wszDSBASESEARCH \
    wszDSUSERCLASS

#define wszDSSEARCHCACERTATTRIBUTE \
    L"?" \
    wszDSCACERTATTRIBUTE \
    wszDSBASESEARCH \
    wszDSCACLASS

#define wszDSSEARCHKRACERTATTRIBUTE \
    L"?" \
    wszDSUSERCERTATTRIBUTE \
    wszDSONESEARCH \
    wszDSKRACLASS

#define wszDSSEARCHCROSSCERTPAIRATTRIBUTE \
    L"?" \
    wszDSCROSSCERTPAIRATTRIBUTE \
    wszDSONESEARCH \
    wszDSAIACLASS

#define wszDSSEARCHAIACERTATTRIBUTE \
    L"?" \
    wszDSCACERTATTRIBUTE \
    wszDSONESEARCH \
    wszDSAIACLASS

#define wszDSKRAQUERYTEMPLATE		\
    L"ldap:///CN=KRA,"			\
	L"CN=Public Key Services,"	\
	L"CN=Services,"			\
	wszFCSAPARM_CONFIGDN		\
	wszDSSEARCHKRACERTATTRIBUTE

#define wszDSAIAQUERYTEMPLATE		\
    L"ldap:///CN=AIA,"			\
	L"CN=Public Key Services,"	\
	L"CN=Services,"			\
	wszFCSAPARM_CONFIGDN		\
	wszDSSEARCHAIACERTATTRIBUTE

// Default URL Template Values:

extern WCHAR const g_wszzLDAPIssuerCertURLTemplate[];
extern WCHAR const g_wszzLDAPKRACertURLTemplate[];
extern WCHAR const g_wszzLDAPRevocationURLTemplate[];
extern WCHAR const g_wszASPRevocationURLTemplate[];

extern WCHAR const g_wszLDAPNTAuthURLTemplate[];
extern WCHAR const g_wszLDAPRootTrustURLTemplate[];

extern WCHAR const g_wszCDPDNTemplate[];
extern WCHAR const g_wszAIADNTemplate[];
extern WCHAR const g_wszKRADNTemplate[];

extern WCHAR const g_wszHTTPRevocationURLTemplate[];
extern WCHAR const g_wszFILERevocationURLTemplate[];
extern WCHAR const g_wszHTTPIssuerCertURLTemplate[];
extern WCHAR const g_wszFILEIssuerCertURLTemplate[];

// Default Server Controls:

extern LDAPControl *g_rgLdapControls[];

HRESULT
myGetAuthoritativeDomainDn(
    IN LDAP *pld,
    OPTIONAL OUT BSTR *pstrDomainDN,
    OPTIONAL OUT BSTR *pstrConfigDN);

HRESULT
myDomainFromDn(
    IN WCHAR const *pwszDN,
    OUT WCHAR **ppwszDomainDNS);

DWORD
myGetLDAPFlags();

HRESULT
myLdapOpen(
    OPTIONAL IN WCHAR const *pwszDomainName,
    IN DWORD dwFlags,	// RLBF_*
    OUT LDAP **ppld,
    OPTIONAL OUT BSTR *pstrDomainDN,
    OPTIONAL OUT BSTR *pstrConfigDN);

VOID
myLdapClose(
    OPTIONAL IN LDAP *pld,
    OPTIONAL IN BSTR strDomainDN,
    OPTIONAL IN BSTR strConfigDN);

BOOL
myLdapRebindRequired(
    IN ULONG ldaperrParm,
    OPTIONAL IN LDAP *pld);

HRESULT
myLdapGetDSHostName(
    IN LDAP *pld,
    OUT WCHAR **ppwszHostName);

HRESULT
myLdapCreateContainer(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN BOOL  fSkipObject,       // Does the DN contain a leaf object name
    IN DWORD cMaxLevel,         // create this many nested containers as needed
    IN PSECURITY_DESCRIPTOR pContainerSD,
    OPTIONAL OUT WCHAR **ppwszError);

#define LPC_CAOBJECT		0x00000000
#define LPC_KRAOBJECT		0x00000001
#define LPC_USEROBJECT		0x00000002
#define LPC_MACHINEOBJECT	0x00000003
#define LPC_OBJECTMASK		0x0000000f

#define LPC_CREATECONTAINER	0x00000100
#define LPC_CREATEOBJECT	0x00000200

HRESULT
myLdapPublishCertToDS(
    IN LDAP *pld,
    IN CERT_CONTEXT const *pccPublish,
    IN WCHAR const *pwszURL,
    IN WCHAR const *pwszAttribute,
    IN DWORD dwObjectType,	// LPC_*
    IN BOOL fDelete,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myLdapPublishCRLToDS(
    IN LDAP *pld,
    IN CRL_CONTEXT const *pCRLPublish,
    IN WCHAR const *pwszURL,
    IN WCHAR const *pwszAttribute,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myLdapCreateCAObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    OPTIONAL IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN PSECURITY_DESCRIPTOR pSD,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myLdapCreateCDPObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN PSECURITY_DESCRIPTOR pSD,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myLdapCreateUserObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    OPTIONAL IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN PSECURITY_DESCRIPTOR pSD,
    IN DWORD dwObjectType,	// LPC_* (but LPC_CREATE* is ignored)
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myLdapCreateOIDObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN DWORD dwType,
    IN WCHAR const *pwszObjId,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myLdapOIDIsMatchingLangId(
    IN WCHAR const *pwszDisplayName,
    IN DWORD dwLanguageId,
    OUT BOOL *pfLangIdExists);

HRESULT
myLdapAddOrDeleteOIDDisplayNameToAttribute(
    IN LDAP *pld,
    OPTIONAL IN WCHAR **ppwszDisplayNames,
    IN DWORD dwLanguageId,
    OPTIONAL IN WCHAR const *pwszDisplayName,
    IN WCHAR const *pwszDN,
    IN WCHAR const *pwszAttribute,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myHLdapError(
    OPTIONAL IN LDAP *pld,
    IN ULONG ldaperrParm,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myHLdapError2(
    OPTIONAL IN LDAP *pld,
    IN ULONG ldaperrParm,
    IN ULONG ldaperrParmQuiet,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myHLdapError3(
    OPTIONAL IN LDAP *pld,
    IN ULONG ldaperrParm,
    IN ULONG ldaperrParmQuiet,
    IN ULONG ldaperrParmQuiet2,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myHLdapLastError(
    OPTIONAL IN LDAP *pld,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
AddCertToAttribute(
    IN LDAP *pld,
    IN CERT_CONTEXT const *pccPublish,
    IN WCHAR const *pwszDN,
    IN WCHAR const *pwszAttribute,
    IN BOOL fDelete,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myLDAPSetStringAttribute(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN WCHAR const *pwszAttribute,
    IN WCHAR const *pwszValue,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
CurrentUserCanInstallCA(
    bool& fCanInstall);

HRESULT
myLdapFindObjectInForest(
    IN LDAP *pld,
    IN LPCWSTR pwszFilter,
    OUT LPWSTR *ppwszURL);

HRESULT
myLdapFindComputerInForest(
    IN LDAP *pld,
    IN LPCWSTR pwszMachineDNS,
    OUT LPWSTR *ppwszURL);

HRESULT
myLdapFilterCertificates(
    IN LDAP *pld,
    IN LPCWSTR pcwszDN,
    IN LPCWSTR pcwszAttribute,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

#endif // __CSLDAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\cslistvw.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cslistvw.h
//
//--------------------------------------------------------------------------
#ifndef __CSLISTVW_H__
#define __CSLISTVW_H__

// help is embedded in certmmc.hlp
BOOL OnDialogHelp(LPHELPINFO pHelpInfo, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);
BOOL OnDialogContextHelp(HWND hWnd, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);

#endif //__CSLISTVW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\cspelog.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2002

Module Name:

    cspelog.h

Abstract:

    Headers for the cert server policy module logging functions

Author:

    petesk  1-Jan-1999


Revision History:

    
--*/

HRESULT
SetModuleErrorInfo(
    IN ICreateErrorInfo *pCreateErrorInfo);

HRESULT
LogModuleStatus(
    IN HMODULE hModule,
    IN HRESULT hrMsg,
    IN DWORD dwLogID,				// Resource ID of log string
    IN BOOL fPolicy, 
    IN WCHAR const *pwszSource, 
    IN WCHAR const * const *ppwszInsert,	// array of insert strings
    OPTIONAL OUT ICreateErrorInfo **ppCreateErrorInfo);

HRESULT
LogPolicyEvent(
    IN HMODULE hModule,
    IN HRESULT hrMsg,
    IN DWORD dwLogID,				// Resource ID of log string
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropEvent,
    IN WCHAR const * const *ppwszInsert);	// array of insert strings
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\cspolicy.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cspolicy.h
//
// Contents:    Cert Server Policy interfaces
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#ifndef __CSPOLICY_H__
#define __CSPOLICY_H__

//+****************************************************
// Policy Module:

DWORD			// VR_PENDING || VR_INSTANT_OK || VR_INSTANT_BAD
PolicyVerifyRequest(
    IN DWORD ReqId);

#endif // __CSPOLICY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\csprop.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csprop.h
//
// Contents:    Cert Server Property interfaces
//
// History:     31-Jul-96       vich created
//
//---------------------------------------------------------------------------

#ifndef __CSPROP_H__
#define __CSPROP_H__

#include "certdb.h"

// begin_certsrv

//+--------------------------------------------------------------------------
// Name properties:

#define wszPROPDISTINGUISHEDNAME   TEXT("DistinguishedName")
#define wszPROPRAWNAME             TEXT("RawName")

#define wszPROPCOUNTRY             TEXT("Country")
#define wszPROPORGANIZATION        TEXT("Organization")
#define wszPROPORGUNIT             TEXT("OrgUnit")
#define wszPROPCOMMONNAME          TEXT("CommonName")
#define wszPROPLOCALITY            TEXT("Locality")
#define wszPROPSTATE               TEXT("State")
#define wszPROPTITLE               TEXT("Title")
#define wszPROPGIVENNAME           TEXT("GivenName")
#define wszPROPINITIALS            TEXT("Initials")
#define wszPROPSURNAME             TEXT("SurName")
#define wszPROPDOMAINCOMPONENT     TEXT("DomainComponent")
#define wszPROPEMAIL               TEXT("EMail")
#define wszPROPSTREETADDRESS       TEXT("StreetAddress")
#define wszPROPUNSTRUCTUREDNAME    TEXT("UnstructuredName")
#define wszPROPUNSTRUCTUREDADDRESS TEXT("UnstructuredAddress")
#define wszPROPDEVICESERIALNUMBER  TEXT("DeviceSerialNumber")

//+--------------------------------------------------------------------------
// Subject Name properties:

#define wszPROPSUBJECTDOT	    TEXT("Subject.")
#define wszPROPSUBJECTDISTINGUISHEDNAME \
				    wszPROPSUBJECTDOT wszPROPDISTINGUISHEDNAME
#define wszPROPSUBJECTRAWNAME       wszPROPSUBJECTDOT wszPROPRAWNAME

#define wszPROPSUBJECTCOUNTRY       wszPROPSUBJECTDOT wszPROPCOUNTRY
#define wszPROPSUBJECTORGANIZATION  wszPROPSUBJECTDOT wszPROPORGANIZATION
#define wszPROPSUBJECTORGUNIT       wszPROPSUBJECTDOT wszPROPORGUNIT
#define wszPROPSUBJECTCOMMONNAME    wszPROPSUBJECTDOT wszPROPCOMMONNAME
#define wszPROPSUBJECTLOCALITY      wszPROPSUBJECTDOT wszPROPLOCALITY
#define wszPROPSUBJECTSTATE         wszPROPSUBJECTDOT wszPROPSTATE
#define wszPROPSUBJECTTITLE	    wszPROPSUBJECTDOT wszPROPTITLE
#define wszPROPSUBJECTGIVENNAME	    wszPROPSUBJECTDOT wszPROPGIVENNAME
#define wszPROPSUBJECTINITIALS	    wszPROPSUBJECTDOT wszPROPINITIALS
#define wszPROPSUBJECTSURNAME	    wszPROPSUBJECTDOT wszPROPSURNAME
#define wszPROPSUBJECTDOMAINCOMPONENT wszPROPSUBJECTDOT wszPROPDOMAINCOMPONENT
#define wszPROPSUBJECTEMAIL	    wszPROPSUBJECTDOT wszPROPEMAIL
#define wszPROPSUBJECTSTREETADDRESS wszPROPSUBJECTDOT wszPROPSTREETADDRESS
#define wszPROPSUBJECTUNSTRUCTUREDNAME wszPROPSUBJECTDOT wszPROPUNSTRUCTUREDNAME
#define wszPROPSUBJECTUNSTRUCTUREDADDRESS wszPROPSUBJECTDOT wszPROPUNSTRUCTUREDADDRESS
#define wszPROPSUBJECTDEVICESERIALNUMBER wszPROPSUBJECTDOT wszPROPDEVICESERIALNUMBER

// end_certsrv

//+--------------------------------------------------------------------------
// Issuer Name properties:

#define wszPROPISSUERDOT	    TEXT("Issuer.")
#define wszPROPISSUERDISTINGUISHEDNAME \
				    wszPROPISSUERDOT wszPROPDISTINGUISHEDNAME
#define wszPROPISSUERRAWNAME        wszPROPISSUERDOT wszPROPRAWNAME

#define wszPROPISSUERCOUNTRY        wszPROPISSUERDOT wszPROPCOUNTRY
#define wszPROPISSUERORGANIZATION   wszPROPISSUERDOT wszPROPORGANIZATION
#define wszPROPISSUERORGUNIT        wszPROPISSUERDOT wszPROPORGUNIT
#define wszPROPISSUERCOMMONNAME     wszPROPISSUERDOT wszPROPCOMMONNAME
#define wszPROPISSUERLOCALITY       wszPROPISSUERDOT wszPROPLOCALITY
#define wszPROPISSUERSTATE          wszPROPISSUERDOT wszPROPSTATE
#define wszPROPISSUERTITLE	    wszPROPISSUERDOT wszPROPTITLE
#define wszPROPISSUERGIVENNAME	    wszPROPISSUERDOT wszPROPGIVENNAME
#define wszPROPISSUERINITIALS	    wszPROPISSUERDOT wszPROPINITIALS
#define wszPROPISSUERSURNAME	    wszPROPISSUERDOT wszPROPSURNAME
#define wszPROPISSUERDOMAINCOMPONENT wszPROPISSUERDOT wszPROPDOMAINCOMPONENT
#define wszPROPISSUEREMAIL	    wszPROPISSUERDOT wszPROPEMAIL
#define wszPROPISSUERSTREETADDRESS  wszPROPISSUERDOT wszPROPSTREETADDRESS
#define wszPROPISSUERUNSTRUCTUREDNAME wszPROPISSUERDOT wszPROPUNSTRUCTUREDNAME
#define wszPROPISSUERUNSTRUCTUREDADDRESS wszPROPISSUERDOT wszPROPUNSTRUCTUREDADDRESS
#define wszPROPISSUERDEVICESERIALNUMBER wszPROPISSUERDOT wszPROPDEVICESERIALNUMBER

#define wszPROPISSUERCOUNTRYOBJID \
    wszPROPISSUERDOT TEXT(szOID_COUNTRY_NAME)

#define wszPROPISSUERORGANIZATIONOBJID \
    wszPROPISSUERDOT TEXT(szOID_ORGANIZATION_NAME)

#define wszPROPISSUERORGUNITOBJID \
    wszPROPISSUERDOT TEXT(szOID_ORGANIZATIONAL_UNIT_NAME)

#define wszPROPISSUERCOMMONNAMEOBJID \
    wszPROPISSUERDOT TEXT(szOID_COMMON_NAME)

#define wszPROPISSUERLOCALITYOBJID \
    wszPROPISSUERDOT TEXT(szOID_LOCALITY_NAME)

#define wszPROPISSUERSTATEOBJID \
    wszPROPISSUERDOT TEXT(szOID_STATE_OR_PROVINCE_NAME)

#define wszPROPISSUERTITLEOBJID \
    wszPROPISSUERDOT TEXT(szOID_TITLE)

#define wszPROPISSUERGIVENNAMEOBJID \
    wszPROPISSUERDOT TEXT(szOID_GIVEN_NAME)

#define wszPROPISSUERINITIALSOBJID \
    wszPROPISSUERDOT TEXT(szOID_INITIALS)

#define wszPROPISSUERSURNAMEOBJID \
    wszPROPISSUERDOT TEXT(szOID_SUR_NAME)

#define wszPROPISSUERDOMAINCOMPONENTOBJID \
    wszPROPISSUERDOT TEXT(szOID_DOMAIN_COMPONENT)

#define wszPROPISSUEREMAILOBJID \
    wszPROPISSUERDOT TEXT(szOID_RSA_emailAddr)

#define wszPROPISSUERSTREETADDRESSOBJID \
    wszPROPISSUERDOT TEXT(szOID_STREET_ADDRESS)

#define wszPROPISSUERUNSTRUCTUREDNAMEOBJID \
    wszPROPISSUERDOT TEXT(szOID_RSA_unstructName)

#define wszPROPISSUERUNSTRUCTUREDADDRESSOBJID \
    wszPROPISSUERDOT TEXT(szOID_RSA_unstructAddr)

#define wszPROPISSUERDEVICESERIALNUMBEROBJID \
    wszPROPISSUERDOT TEXT(szOID_DEVICE_SERIAL_NUMBER)


//+--------------------------------------------------------------------------
// For mapping request attribute names to internal property names:

// Map to wszPROPSUBJECTCOUNTRY:
#define wszATTRCOUNTRY1			TEXT("C")
#define wszATTRCOUNTRY2			TEXT("Country")

// Map to wszPROPSUBJECTORGANIZATION:
#define wszATTRORG1			TEXT("O")
#define wszATTRORG2			TEXT("Org")
#define wszATTRORG3			TEXT("Organization")

// Map to wszPROPSUBJECTORGUNIT:
#define wszATTRORGUNIT1			TEXT("OU")
#define wszATTRORGUNIT2			TEXT("OrgUnit")
#define wszATTRORGUNIT3			TEXT("OrganizationUnit")
#define wszATTRORGUNIT4			TEXT("OrganizationalUnit")

// Map to wszPROPSUBJECTCOMMONNAME:
#define wszATTRCOMMONNAME1		TEXT("CN")
#define wszATTRCOMMONNAME2		TEXT("CommonName")

// Map to wszPROPSUBJECTLOCALITY:
#define wszATTRLOCALITY1		TEXT("L")
#define wszATTRLOCALITY2		TEXT("Locality")

// Map to wszPROPSUBJECTSTATE:
#define wszATTRSTATE1			TEXT("S")
#define wszATTRSTATE2			TEXT("ST")
#define wszATTRSTATE3			TEXT("State")

// Map to wszPROPSUBJECTTITLE:
#define wszATTRTITLE1			TEXT("T")
#define wszATTRTITLE2			TEXT("Title")

// Map to wszPROPSUBJECTGIVENNAME:
#define wszATTRGIVENNAME1		TEXT("G")
#define wszATTRGIVENNAME2		TEXT("GivenName")

// Map to wszPROPSUBJECTINITIALS:
#define wszATTRINITIALS1		TEXT("I")
#define wszATTRINITIALS2		TEXT("Initials")

// Map to wszPROPSUBJECTSURNAME:
#define wszATTRSURNAME1			TEXT("SN")
#define wszATTRSURNAME2			TEXT("SurName")

// Map to wszPROPSUBJECTDOMAINCOMPONENT:
#define wszATTRDOMAINCOMPONENT1		TEXT("DC")
#define wszATTRDOMAINCOMPONENT2		TEXT("DomainComponent")

// Map to wszPROPSUBJECTEMAIL:
#define wszATTREMAIL1			TEXT("E")
#define wszATTREMAIL2			TEXT("EMail")

// Map to wszPROPSUBJECTSTREETADDRESS:
#define wszATTRSTREETADDRESS1		TEXT("Street")
#define wszATTRSTREETADDRESS2		TEXT("StreetAddress")

// Map to wszPROPSUBJECTUNSTRUCTUREDNAME:
#define wszATTRUNSTRUCTUREDNAME1	TEXT("UnstructuredName")

// Map to wszPROPSUBJECTUNSTRUCTUREDADDRESS:
#define wszATTRUNSTRUCTUREDADDRESS1	TEXT("UnstructuredAddress")

// Map to wszPROPSUBJECTDEVICESERIALNUMBER:
#define wszATTRDEVICESERIALNUMBER1	TEXT("DeviceSerialNumber")

#define wszPROPCERTCLIDLL_VERSION	TEXT("..CertCli Version")

// begin_certsrv

//+--------------------------------------------------------------------------
// Request properties:
#define wszPROPREQUESTDOT	            TEXT("Request.")

#define wszPROPREQUESTREQUESTID		    TEXT("RequestID")
#define wszPROPREQUESTRAWREQUEST	    TEXT("RawRequest")
#define wszPROPREQUESTRAWARCHIVEDKEY	    TEXT("RawArchivedKey")
#define wszPROPREQUESTKEYRECOVERYHASHES	    TEXT("KeyRecoveryHashes")
#define wszPROPREQUESTRAWOLDCERTIFICATE	    TEXT("RawOldCertificate")
#define wszPROPREQUESTATTRIBUTES	    TEXT("RequestAttributes")
#define wszPROPREQUESTTYPE		    TEXT("RequestType")
#define wszPROPREQUESTFLAGS		    TEXT("RequestFlags")
#define wszPROPREQUESTSTATUSCODE	    TEXT("StatusCode")
#define wszPROPREQUESTDISPOSITION	    TEXT("Disposition")
#define wszPROPREQUESTDISPOSITIONMESSAGE    TEXT("DispositionMessage")
#define wszPROPREQUESTSUBMITTEDWHEN	    TEXT("SubmittedWhen")
#define wszPROPREQUESTRESOLVEDWHEN	    TEXT("ResolvedWhen")
#define wszPROPREQUESTREVOKEDWHEN	    TEXT("RevokedWhen")
#define wszPROPREQUESTREVOKEDEFFECTIVEWHEN  TEXT("RevokedEffectiveWhen")
#define wszPROPREQUESTREVOKEDREASON	    TEXT("RevokedReason")
#define wszPROPREQUESTERNAME		    TEXT("RequesterName")
#define wszPROPCALLERNAME		    TEXT("CallerName")
#define wszPROPREQUESTERADDRESS		    TEXT("RequesterAddress") // no_certsrv
#define wszPROPSIGNERPOLICIES		    TEXT("SignerPolicies")
#define wszPROPSIGNERAPPLICATIONPOLICIES    TEXT("SignerApplicationPolicies")
#define wszPROPOFFICER			    TEXT("Officer")

//+--------------------------------------------------------------------------
// Request attribute properties:

#define wszPROPCHALLENGE		TEXT("Challenge")
#define wszPROPEXPECTEDCHALLENGE	TEXT("ExpectedChallenge")

#define wszPROPDISPOSITION		TEXT("Disposition")
#define wszPROPDISPOSITIONDENY		TEXT("Deny")
#define wszPROPDISPOSITIONPENDING	TEXT("Pending")

#define wszPROPVALIDITYPERIODSTRING	TEXT("ValidityPeriod")
#define wszPROPVALIDITYPERIODCOUNT	TEXT("ValidityPeriodUnits")

#define wszPROPCERTTYPE			TEXT("CertType")
#define wszPROPCERTTEMPLATE		TEXT("CertificateTemplate")
#define wszPROPCERTUSAGE		TEXT("CertificateUsage")

#define wszPROPREQUESTOSVERSION		TEXT("RequestOSVersion")
#define wszPROPREQUESTCSPPROVIDER       TEXT("RequestCSPProvider")

#define wszPROPEXITCERTFILE		TEXT("CertFile")
#define wszPROPCLIENTBROWSERMACHINE	TEXT("cbm")
#define wszPROPCERTCLIENTMACHINE	TEXT("ccm")
#define wszPROPCLIENTDCDNS		L"cdc"
#define wszPROPREQUESTMACHINEDNS	L"rmd"
#define wszPROPSUBJECTALTNAME2		TEXT("san")
#define wszPROPDNS			TEXT("dns")
#define wszPROPDN			TEXT("dn")
#define wszPROPURL			TEXT("url")
#define wszPROPIPADDRESS		TEXT("ipaddress")
#define wszPROPGUID			TEXT("guid")
#define wszPROPOID			TEXT("oid")
#define wszPROPUPN			TEXT("upn")
#define wszPROPUPN			TEXT("upn")

#define szPROPASNTAG			"{asn}"

#define wszPROPUTF8TAG			TEXT("{utf8}")
#define wszPROPOCTETTAG			TEXT("{octet}")
#define wszPROPASNTAG			TEXT(szPROPASNTAG)


//+--------------------------------------------------------------------------
// "System" properties
// ".#" means ".0", ".1", ".2" ... may be appended to the property name to
// collect context specific values.  For some properties, the suffix selects
// the CA certificate context.  For others, it selects the the CA CRL context.

#define wszPROPCATYPE                   TEXT("CAType")
#define wszPROPSANITIZEDCANAME          TEXT("SanitizedCAName")
#define wszPROPSANITIZEDSHORTNAME       TEXT("SanitizedShortName")
#define wszPROPMACHINEDNSNAME           TEXT("MachineDNSName")
#define wszPROPMODULEREGLOC             TEXT("ModuleRegistryLocation")
#define wszPROPUSEDS                    TEXT("fUseDS")
#define wszPROPDELTACRLSDISABLED        TEXT("fDeltaCRLsDisabled")
#define wszPROPSERVERUPGRADED           TEXT("fServerUpgraded")
#define wszPROPCONFIGDN			TEXT("ConfigDN")
#define wszPROPDOMAINDN			TEXT("DomainDN")
#define wszPROPLOGLEVEL			TEXT("LogLevel")
#define wszPROPSESSIONCOUNT		TEXT("SessionCount")
#define wszPROPTEMPLATECHANGESEQUENCENUMBER TEXT("TemplateChangeSequenceNumber")

// Request Context properties:

#define wszPROPREQUESTERTOKEN		TEXT("RequesterToken") // no_certsrv
#define wszPROPREQUESTERCAACCESS	TEXT("RequesterCAAccess")
#define wszPROPUSERDN			TEXT("UserDN")
#define wszPROPKEYARCHIVED		TEXT("KeyArchived")


// CA Certificate properties: (all ".#" extensible except wszPROPCERTCOUNT)

#define wszPROPCERTCOUNT                TEXT("CertCount")
#define wszPROPRAWCACERTIFICATE         TEXT("RawCACertificate")
#define wszPROPCERTSTATE                TEXT("CertState")
#define wszPROPCERTSUFFIX               TEXT("CertSuffix")

// CA CRL properties: (all ".#" extensible)

#define wszPROPRAWCRL                   TEXT("RawCRL")
#define wszPROPRAWDELTACRL              TEXT("RawDeltaCRL")
#define wszPROPCRLINDEX                 TEXT("CRLIndex")
#define wszPROPCRLSTATE                 TEXT("CRLState")
#define wszPROPCRLSUFFIX                TEXT("CRLSuffix")

// Values for wszPROPCERTSTATE (see certadm.h):
//   CA_DISP_REVOKED    // This Cert has been revoked.
//   CA_DISP_VALID      // This Cert is still valid
//   CA_DISP_INVALID    // This Cert has expired.
//   CA_DISP_ERROR      // Cert unavailable (placehholder in registry?)

// Values for wszPROPCRLSTATE (see certadm.h):
//   CA_DISP_REVOKED	// All unexpired certs using this Cert's CRL have been
//			// revoked.
//   CA_DISP_VALID	// This Cert is still publishing CRLs as needed.
//   CA_DISP_INVALID    // All certs using this Cert's CRL are expired.
//   CA_DISP_ERROR      // This Cert's CRL is managed by another Cert.

// "Settable" system properties:
#define wszPROPEVENTLOGTERSE		TEXT("EventLogTerse")
#define wszPROPEVENTLOGERROR		TEXT("EventLogError")
#define wszPROPEVENTLOGWARNING		TEXT("EventLogWarning")
#define wszPROPEVENTLOGVERBOSE		TEXT("EventLogVerbose")
#define wszPROPEVENTLOGEXHAUSTIVE	TEXT("EventLogExhaustive")
#define wszPROPDCNAME			TEXT("DCName")

//+--------------------------------------------------------------------------
// Certificate properties:

#define wszPROPCERTIFICATEREQUESTID	       TEXT("RequestID")
#define wszPROPRAWCERTIFICATE		       TEXT("RawCertificate")
#define wszPROPCERTIFICATEHASH		       TEXT("CertificateHash")
#define wszPROPCERTIFICATETEMPLATE	       TEXT("CertificateTemplate")
#define wszPROPCERTIFICATEENROLLMENTFLAGS      TEXT("EnrollmentFlags")
#define wszPROPCERTIFICATEGENERALFLAGS         TEXT("GeneralFlags")
#define wszPROPCERTIFICATESERIALNUMBER	       TEXT("SerialNumber")
#define wszPROPCERTIFICATEISSUERNAMEID	       TEXT("IssuerNameID")//no_certsrv
#define wszPROPCERTIFICATENOTBEFOREDATE	       TEXT("NotBefore")
#define wszPROPCERTIFICATENOTAFTERDATE	       TEXT("NotAfter")
#define wszPROPCERTIFICATESUBJECTKEYIDENTIFIER TEXT("SubjectKeyIdentifier")
#define wszPROPCERTIFICATERAWPUBLICKEY	       TEXT("RawPublicKey")
#define wszPROPCERTIFICATEPUBLICKEYLENGTH      TEXT("PublicKeyLength")
#define wszPROPCERTIFICATEPUBLICKEYALGORITHM   TEXT("PublicKeyAlgorithm")
#define wszPROPCERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS \
    TEXT("RawPublicKeyAlgorithmParameters")
#define wszPROPCERTIFICATEUPN		       TEXT("UPN")

// Obsolete:
#define wszPROPCERTIFICATETYPE		       TEXT("CertificateType")
#define wszPROPCERTIFICATERAWSMIMECAPABILITIES TEXT("RawSMIMECapabilities")
#define wszPROPNAMETYPE			       TEXT("NameType")

//+--------------------------------------------------------------------------
// Certificate extension properties:

#define EXTENSION_CRITICAL_FLAG	      0x00000001
#define EXTENSION_DISABLE_FLAG	      0x00000002
#define EXTENSION_POLICY_MASK	      0x0000ffff // Settable by admin+policy

#define EXTENSION_ORIGIN_REQUEST      0x00010000
#define EXTENSION_ORIGIN_POLICY	      0x00020000
#define EXTENSION_ORIGIN_ADMIN	      0x00030000
#define EXTENSION_ORIGIN_SERVER	      0x00040000
#define EXTENSION_ORIGIN_RENEWALCERT  0x00050000
#define EXTENSION_ORIGIN_IMPORTEDCERT 0x00060000
#define EXTENSION_ORIGIN_PKCS7	      0x00070000
#define EXTENSION_ORIGIN_CMC	      0x00080000
#define EXTENSION_ORIGIN_CACERT       0x00090000
#define EXTENSION_ORIGIN_MASK	      0x000f0000

//+--------------------------------------------------------------------------
// Extension properties:

#define wszPROPEXTREQUESTID		TEXT("ExtensionRequestId")
#define wszPROPEXTNAME			TEXT("ExtensionName")
#define wszPROPEXTFLAGS			TEXT("ExtensionFlags")
#define wszPROPEXTRAWVALUE		TEXT("ExtensionRawValue")

//+--------------------------------------------------------------------------
// Attribute properties:

#define wszPROPATTRIBREQUESTID		TEXT("AttributeRequestId")
#define wszPROPATTRIBNAME		TEXT("AttributeName")
#define wszPROPATTRIBVALUE		TEXT("AttributeValue")

//+--------------------------------------------------------------------------
// CRL properties:

#define wszPROPCRLROWID			TEXT("CRLRowId")
#define wszPROPCRLNUMBER		TEXT("CRLNumber")
#define wszPROPCRLMINBASE		TEXT("CRLMinBase") // Delta CRLs only
#define wszPROPCRLNAMEID		TEXT("CRLNameId")
#define wszPROPCRLCOUNT			TEXT("CRLCount")
#define wszPROPCRLTHISUPDATE		TEXT("CRLThisUpdate")
#define wszPROPCRLNEXTUPDATE		TEXT("CRLNextUpdate")
#define wszPROPCRLTHISPUBLISH		TEXT("CRLThisPublish")
#define wszPROPCRLNEXTPUBLISH		TEXT("CRLNextPublish")
#define wszPROPCRLEFFECTIVE		TEXT("CRLEffective")
#define wszPROPCRLPROPAGATIONCOMPLETE	TEXT("CRLPropagationComplete")
#define wszPROPCRLLASTPUBLISHED		TEXT("CRLLastPublished")
#define wszPROPCRLPUBLISHATTEMPTS	TEXT("CRLPublishAttempts")
#define wszPROPCRLPUBLISHFLAGS		TEXT("CRLPublishFlags")
#define wszPROPCRLPUBLISHSTATUSCODE	TEXT("CRLPublishStatusCode")
#define wszPROPCRLPUBLISHERROR		TEXT("CRLPublishError")
#define wszPROPCRLRAWCRL		TEXT("CRLRawCRL")

//+--------------------------------------------------------------------------
// CRL Published Flags:

#define CPF_BASE		0x00000001
#define CPF_DELTA		0x00000002
#define CPF_COMPLETE		0x00000004
#define CPF_SHADOW		0x00000008
#define CPF_CASTORE_ERROR	0x00000010
#define CPF_BADURL_ERROR	0x00000020
#define CPF_MANUAL		0x00000040
#define CPF_SIGNATURE_ERROR	0x00000080
#define CPF_LDAP_ERROR		0x00000100
#define CPF_FILE_ERROR		0x00000200
#define CPF_FTP_ERROR		0x00000400
#define CPF_HTTP_ERROR		0x00000800

//+--------------------------------------------------------------------------
// GetProperty/SetProperty Flags:
//
// Choose one Type

#define PROPTYPE_LONG		 0x00000001	// Signed long
#define PROPTYPE_DATE		 0x00000002	// Date+Time
#define PROPTYPE_BINARY		 0x00000003	// Binary data
#define PROPTYPE_STRING		 0x00000004	// Unicode String
#define PROPTYPE_MASK		 0x000000ff

// Choose one Caller:

#define PROPCALLER_SERVER	 0x00000100
#define PROPCALLER_POLICY	 0x00000200
#define PROPCALLER_EXIT		 0x00000300
#define PROPCALLER_ADMIN	 0x00000400
#define PROPCALLER_REQUEST	 0x00000500
#define PROPCALLER_MASK		 0x00000f00
// end_certsrv

// Choose one Table:

#define PROPTABLE_REQCERT	 0x00000000	// OpenRow only
#define PROPTABLE_REQUEST	 0x00001000
#define PROPTABLE_CERTIFICATE	 0x00002000
#define PROPTABLE_EXTENSION	 0x00003000
#define PROPTABLE_ATTRIBUTE      0x00004000
#define PROPTABLE_CRL		 0x00005000
#define PROPTABLE_MASK		 0x0000f000

#define PROPFLAGS_INDEXED	 0x00010000	// add_certsrv
#define PROPFLAGS_MASK		 0x000f0000

#define PROPMARSHAL_LOCALSTRING	 0x00100000
#define PROPMARSHAL_NULLBSTROK	 0x00200000

#define PROPOPEN_READONLY	 0x00400000	// OpenRow only
#define PROPOPEN_DELETE	 	 0x00800000	// OpenRow only
#define PROPOPEN_CERTHASH 	 0x01000000	// OpenRow only


// begin_certsrv

// RequestFlags definitions:

#define CR_FLG_FORCETELETEX	 	0x00000001
#define CR_FLG_RENEWAL		 	0x00000002
#define CR_FLG_FORCEUTF8	 	0x00000004
#define CR_FLG_CAXCHGCERT	 	0x00000008
#define CR_FLG_ENROLLONBEHALFOF	 	0x00000010
#define CR_FLG_SUBJECTUNMODIFIED 	0x00000020
#define CR_FLG_VALIDENCRYPTEDKEYHASH	0x00000040
#define CR_FLG_CACROSSCERT		0x00000080
#define CR_FLG_PUBLISHERROR		0x80000000
// end_certsrv


#define CB_DBMAXBINARY            (4 * 1024)
#define CB_DBMAXRAWCERTIFICATE    (16 * 1024)
#define CB_DBMAXRAWREQUEST        (64 * 1024)
#define CB_DBMAXRAWCRL		  (512 * 1024 * 1024)	// 512mb

#define CCH_DBMAXTEXT_MAXINTERNAL (255 / sizeof(WCHAR))    // 127 chars!
#define CB_DBMAXTEXT_MAXINTERNAL  (CCH_DBMAXTEXT_MAXINTERNAL * sizeof(WCHAR))

#define CCH_DBMAXTEXT_SHORT       1024
#define CB_DBMAXTEXT_SHORT        (CCH_DBMAXTEXT_SHORT * sizeof(WCHAR))

#define CCH_DBMAXTEXT_MEDIUM      (4 * 1024)
#define CB_DBMAXTEXT_MEDIUM       (CCH_DBMAXTEXT_MEDIUM * sizeof(WCHAR))

#define CCH_DBMAXTEXT_LONG        (16 * 1024)
#define CB_DBMAXTEXT_LONG         (CCH_DBMAXTEXT_LONG * sizeof(WCHAR))

#define CCH_DBMAXTEXT_OID         CCH_DBMAXTEXT_MAXINTERNAL
#define CB_DBMAXTEXT_OID          CB_DBMAXTEXT_MAXINTERNAL

#define CCH_DBMAXTEXT_REQUESTNAME CCH_DBMAXTEXT_SHORT
#define CB_DBMAXTEXT_REQUESTNAME  CB_DBMAXTEXT_SHORT

#define CCH_DBMAXTEXT_DISPSTRING  CCH_DBMAXTEXT_MEDIUM
#define CB_DBMAXTEXT_DISPSTRING   CB_DBMAXTEXT_MEDIUM


#define CCH_DBMAXTEXT_RDN         CCH_DBMAXTEXT_MEDIUM
#define CB_DBMAXTEXT_RDN          CB_DBMAXTEXT_MEDIUM

#define CCH_DBMAXTEXT_DN          CCH_DBMAXTEXT_MEDIUM
#define CB_DBMAXTEXT_DN           CB_DBMAXTEXT_MEDIUM


#define CCH_DBMAXTEXT_ATTRNAME    CCH_DBMAXTEXT_MAXINTERNAL
#define CB_DBMAXTEXT_ATTRNAME     CB_DBMAXTEXT_MAXINTERNAL

#define CCH_DBMAXTEXT_ATTRVALUE   CCH_DBMAXTEXT_MEDIUM
#define CB_DBMAXTEXT_ATTRVALUE    CB_DBMAXTEXT_MEDIUM

#define CCH_DBMAXTEXT_ATTRSTRING  CCH_DBMAXTEXT_LONG
#define CB_DBMAXTEXT_ATTRSTRING   CB_DBMAXTEXT_LONG


#define cchHASHMAX			64
#define cchSERIALNUMBERMAX		64

#define cchUNSTRUCTUREDNAMEMAX		CCH_DBMAXTEXT_SHORT
#define cchUNSTRUCTUREDADDRESSMAX	CCH_DBMAXTEXT_SHORT
#define cchDEVICESERIALNUMBERMAX	CCH_DBMAXTEXT_SHORT

// Subject RDN string length limits from PKIX Part 1 doc:

#define cchCOUNTRYNAMEMAX		2
#define cchORGANIZATIONNAMEMAX		64
#define cchORGANIZATIONALUNITNAMEMAX	64
#define cchCOMMONNAMEMAX		64
#define cchLOCALITYMANAMEMAX		128
#define cchSTATEORPROVINCENAMEMAX	128
#define cchTITLEMAX			64
#define cchGIVENNAMEMAX			16
#define cchINITIALSMAX			5
#define cchSURNAMEMAX			40
#define cchDOMAINCOMPONENTMAX		128
#define cchEMAILMAX			128
#define cchSTREETADDRESSMAX		30

#ifdef cchCOMMONNAMEMAX_XELIB
# if cchCOMMONNAMEMAX_XELIB != cchCOMMONNAMEMAX
#  error cchCOMMONNAMEMAX_XELIB != cchCOMMONNAMEMAX
# endif
#endif



// begin_certsrv

// Disposition property values:

// Disposition values for requests in the queue:
#define DB_DISP_ACTIVE	        8	// being processed
#define DB_DISP_PENDING		9	// taken under submission
#define DB_DISP_QUEUE_MAX	9	// max disposition value for queue view

#define DB_DISP_FOREIGN		12	// archived foreign cert

#define DB_DISP_CA_CERT		15	// CA cert
#define DB_DISP_CA_CERT_CHAIN	16	// CA cert chain
#define DB_DISP_KRA_CERT	17	// KRA cert

// Disposition values for requests in the log:
#define DB_DISP_LOG_MIN		20	// min disposition value for log view
#define DB_DISP_ISSUED		20	// cert issued
#define DB_DISP_REVOKED	        21	// issued and revoked

// Disposition values for failed requests in the log:
#define DB_DISP_LOG_FAILED_MIN	30	// min disposition value for log view
#define DB_DISP_ERROR		30	// request failed
#define DB_DISP_DENIED		31	// request denied

// end_certsrv


// CertIF property callback support:

typedef HRESULT (WINAPI FNCIGETPROPERTY)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    OUT VARIANT *pvarPropertyValue);

FNCIGETPROPERTY PropCIGetProperty;


typedef HRESULT (WINAPI FNCISETPROPERTY)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    IN VARIANT const *pvarPropertyValue);

FNCISETPROPERTY PropCISetProperty;


typedef HRESULT (WINAPI FNCIGETEXTENSION)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    OUT DWORD *pdwExtFlags,
    OUT VARIANT *pvarValue);

FNCIGETEXTENSION PropCIGetExtension;


typedef HRESULT (WINAPI FNCISETEXTENSION)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    IN DWORD ExtFlags,
    IN VARIANT const *pvarValue);

FNCISETEXTENSION PropCISetExtension;



// CertIF property enumeration callback support:

#define CIE_OBJECTID	     0x00000001	// return object ids for names
#define CIE_RESET            0x00000002

#define CIE_TABLE_EXTENSIONS 0x00000010
#define CIE_TABLE_ATTRIBUTES 0x00000020
#define CIE_TABLE_MASK       0x000000f0

#define CIE_CALLER_POLICY    0x00000200
#define CIE_CALLER_EXIT	     0x00000300
#define CIE_CALLER_MASK	     0x00000f00


class CIENUM {
public:
    CIENUM() { m_penum = NULL; }

    HRESULT EnumSetup(IN DWORD RequestId, IN LONG Context, IN DWORD Flags);
    HRESULT EnumNext(OUT BSTR *pstrPropertyName);
    HRESULT EnumClose();

    LONG GetContext() { return(m_Context); }
    DWORD GetFlags() { return(m_Flags); }

private:
    IEnumCERTDBNAME *m_penum;
    LONG             m_Context;
    DWORD            m_Flags;
};

typedef HRESULT (WINAPI FNCIENUMSETUP)(
    IN LONG Context,
    IN LONG Flags,
    IN OUT CIENUM *pciEnum);

FNCIENUMSETUP PropCIEnumSetup;


typedef HRESULT (WINAPI FNCIENUMNEXT)(
    IN OUT CIENUM *pciEnum,
    OUT BSTR *pstrPropertyName);

FNCIENUMNEXT PropCIEnumNext;


typedef HRESULT (WINAPI FNCIENUMCLOSE)(
    IN OUT CIENUM *pciEnum);

FNCIENUMCLOSE PropCIEnumClose;


#endif // __CSPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\csprop2.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       csprop2.cpp
//
//  Contents:   ICertAdmin2 & ICertRequest2 CA Property methods
//
//--------------------------------------------------------------------------

#define __DIR__		"include"
#define __dwFILE__	__dwFILE_INCLUDE_CSPROP2_CPP__

#if defined(CCERTADMIN)

# define CCertProp	CCertAdmin
# define wszCCertProp	L"CCertAdmin"
# define m_pICertPropD	m_pICertAdminD
# define fRPCARG(fRPC)

#elif defined(CCERTREQUEST)

# define CCertProp	CCertRequest
# define wszCCertProp	L"CCertRequest"
# define m_pICertPropD	m_pICertRequestD
# define fRPCARG(fRPC)	(fRPC),

#else
# error -- CCERTADMIN or CCERTREQUEST must be defined
#endif


//+--------------------------------------------------------------------------
// CCertProp::_InitCAPropInfo -- Initialize CA Prop Info
//
// Initialize CA Prop Info member varaibles
//+--------------------------------------------------------------------------

VOID
CCertProp::_InitCAPropInfo()
{
    m_pbKRACertState = NULL;
    m_pbForwardCrossCertState = NULL;
    m_pbBackwardCrossCertState = NULL;
    m_pbCACertState = NULL;
    m_pbCACertVersion = NULL;
    m_pbCRLState = NULL;
    m_pCAPropInfo = NULL;
    m_pCAInfo = NULL;
}


//+--------------------------------------------------------------------------
// CCertProp::_CleanupCAPropInfo -- free memory
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertProp::_CleanupCAPropInfo()
{
    // Memory returned from DCOM calls were MIDL_user_allocate'd

    if (NULL != m_pbKRACertState)
    {
        MIDL_user_free(m_pbKRACertState);
        m_pbKRACertState = NULL;
    }
    if (NULL != m_pbForwardCrossCertState)
    {
        MIDL_user_free(m_pbForwardCrossCertState);
        m_pbForwardCrossCertState = NULL;
    }
    if (NULL != m_pbBackwardCrossCertState)
    {
        MIDL_user_free(m_pbBackwardCrossCertState);
        m_pbBackwardCrossCertState = NULL;
    }
    if (NULL != m_pbCACertState)
    {
        MIDL_user_free(m_pbCACertState);
	m_pbCACertState = NULL;
    }
    if (NULL != m_pbCACertVersion)
    {
        MIDL_user_free(m_pbCACertVersion);
	m_pbCACertVersion = NULL;
    }
    if (NULL != m_pbCRLState)
    {
        MIDL_user_free(m_pbCRLState);
	m_pbCRLState = NULL;
    }
    if (NULL != m_pCAInfo)
    {
	MIDL_user_free(m_pCAInfo);
	m_pCAInfo = NULL;
    }
    if (NULL != m_pCAPropInfo)
    {
	LocalFree(m_pCAPropInfo);
	m_pCAPropInfo = NULL;
    }
    m_cCAPropInfo = 0;
}


//+--------------------------------------------------------------------------
// CCertProp::GetCAProperty -- Get a CA property
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertProp::GetCAProperty(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG PropId,		// CR_PROP_*
    /* [in] */ LONG PropIndex,
    /* [in] */ LONG PropType,		// PROPTYPE_*
    /* [in] */ LONG Flags,		// CR_OUT_*
    /* [out, retval] */ VARIANT *pvarPropertyValue)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbCAProp = { 0, NULL };
    DWORD dwCAInfoOffset = MAXDWORD;
    BYTE const *pb;
    DWORD cb;
    BYTE **ppb = NULL;
    DWORD *pcb;
    DWORD cbCachedVal = sizeof(BYTE);
    DWORD dwVal;

    if (NULL == pvarPropertyValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    VariantInit(pvarPropertyValue);

    hr = _OpenConnection(fRPCARG(FALSE) strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    // Check for cached data:

    pcb = NULL;
    switch (PropId)
    {
	case CR_PROP_CATYPE:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, CAType);
	    break;

	case CR_PROP_CASIGCERTCOUNT:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, cCASignatureCerts);
	    break;

	case CR_PROP_CAXCHGCERTCOUNT:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, cCAExchangeCerts);
	    break;

	case CR_PROP_EXITCOUNT:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, cExitModules);
	    break;

	case CR_PROP_CAPROPIDMAX:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, lPropIdMax);
	    break;

	case CR_PROP_CACERTSTATE:
	    ppb = &m_pbCACertState;
	    pcb = &m_cbCACertState;
	    break;

	case CR_PROP_CACERTVERSION:
	    ppb = &m_pbCACertVersion;
	    pcb = &m_cbCACertVersion;
	    cbCachedVal = sizeof(DWORD);
	    break;

	case CR_PROP_CRLSTATE:
	    ppb = &m_pbCRLState;
	    pcb = &m_cbCRLState;
	    break;

	case CR_PROP_ROLESEPARATIONENABLED:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, lRoleSeparationEnabled);
	    break;

	case CR_PROP_KRACERTUSEDCOUNT:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, cKRACertUsedCount);
	    break;

	case CR_PROP_KRACERTCOUNT:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, cKRACertCount);
	    break;

	case CR_PROP_ADVANCEDSERVER:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, fAdvancedServer);
	    break;

	case CR_PROP_KRACERTSTATE:
	    ppb = &m_pbKRACertState;
	    pcb = &m_cbKRACertState;
	    break;

	case CR_PROP_CAFORWARDCROSSCERTSTATE:
	    ppb = &m_pbForwardCrossCertState;
	    pcb = &m_cbForwardCrossCertState;
	    break;

	case CR_PROP_CABACKWARDCROSSCERTSTATE:
	    ppb = &m_pbBackwardCrossCertState;
	    pcb = &m_cbBackwardCrossCertState;
	    break;
    }

    // Call server if:
    //   non-cached property ||
    //   cached state is empty ||
    //   cached CAInfo is empty

    pb = NULL;
    cb = 0;
    if ((NULL == ppb && MAXDWORD == dwCAInfoOffset) ||
	(NULL != ppb && NULL == *ppb) ||
	(MAXDWORD != dwCAInfoOffset && NULL == m_pCAInfo))
    {
	__try
	{
	    hr = m_pICertPropD->GetCAProperty(
					    pwszAuthority,
					    PropId,
					    PropIndex,
					    PropType,
					    &ctbCAProp);
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	if (S_OK != hr)
	{
	    DBGPRINT((
		E_INVALIDARG == hr? DBG_SS_CERTLIBI : DBG_SS_ERROR,
		"GetCAProperty(Propid=%u, PropIndex=%u, PropType=%u) -> %x\n",
		PropId,
		PropIndex,
		PropType,
		hr));
	}
	_JumpIfError3(
		    hr,
		    error,
		    "GetCAProperty",
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND),
		    E_INVALIDARG);

	DBGDUMPHEX((DBG_SS_CERTLIBI, DH_NOADDRESS, ctbCAProp.pb, ctbCAProp.cb));

	if (NULL != ctbCAProp.pb)
	{
	    myRegisterMemAlloc(ctbCAProp.pb, ctbCAProp.cb, CSM_COTASKALLOC);
	}
	pb = ctbCAProp.pb;
	cb = ctbCAProp.cb;

	// populate CAInfo cache

	if (MAXDWORD != dwCAInfoOffset)
	{
	    if (CCSIZEOF_STRUCT(CAINFO, cbSize) >
		    ((CAINFO *) ctbCAProp.pb)->cbSize ||
		cb != ((CAINFO *) ctbCAProp.pb)->cbSize)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "CAINFO size");
	    }
	    m_cbCAInfo = ctbCAProp.cb;
	    m_pCAInfo = (CAINFO *) ctbCAProp.pb;
	    ctbCAProp.pb = NULL;
	}

	// populate Cert or CRL state cache

	else if (NULL != ppb)
	{
	    *pcb = ctbCAProp.cb;
	    *ppb = ctbCAProp.pb;
	    ctbCAProp.pb = NULL;
	}
    }
	
    // fetch from CAInfo cache

    if (MAXDWORD != dwCAInfoOffset)
    {
	pb = (BYTE const *) Add2Ptr(m_pCAInfo, dwCAInfoOffset);
	cb = sizeof(DWORD);

	if (dwCAInfoOffset + sizeof(DWORD) > m_cbCAInfo)
	{
	    hr = E_NOTIMPL;
	    _JumpError(hr, error, "CAINFO size");
	}
    }

    // fetch from Cert or CRL state cache

    else if (NULL != ppb)
    {
	DWORD obCache = PropIndex * cbCachedVal;
	
	if (obCache + cbCachedVal > *pcb)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropIndex");
	}
	CSASSERT(sizeof(dwVal) >= cbCachedVal);
	dwVal = 0;
	CopyMemory(&dwVal, &(*ppb)[obCache], cbCachedVal);
	pb = (BYTE const *) &dwVal;
	cb = sizeof(dwVal);
    }

    __try
    {
	hr = myUnmarshalFormattedVariant(
				    Flags,
				    PropId,
				    PropType,
				    cb,
				    pb,
				    pvarPropertyValue);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "myUnmarshalFormattedVariant");

error:
    if (S_OK != hr && NULL != pvarPropertyValue)
    {
	VariantClear(pvarPropertyValue);
    }
    if (NULL != ctbCAProp.pb)
    {
	MIDL_user_free(ctbCAProp.pb);
    }
    return(_SetErrorInfo(hr, wszCCertProp L"::GetCAProperty"));
}


//+--------------------------------------------------------------------------
// CCertProp::_FindCAPropInfo -- Get a CA property's CAPROP info pointer
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertProp::_FindCAPropInfo(
    IN BSTR const strConfig,
    IN LONG PropId,		// CR_PROP_*
    OUT CAPROP const **ppcap)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbCAPropInfo = { 0, NULL };

    CSASSERT(NULL != ppcap);
    *ppcap = NULL;
    
    hr = _OpenConnection(fRPCARG(FALSE) strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    if (NULL == m_pCAPropInfo)
    {
	__try
	{
	    hr = m_pICertPropD->GetCAPropertyInfo(
					    pwszAuthority,
					    &m_cCAPropInfo,
					    &ctbCAPropInfo);
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	_JumpIfError(hr, error, "GetCAPropertyInfo");

	if (NULL != ctbCAPropInfo.pb)
	{
	    myRegisterMemAlloc(
			    ctbCAPropInfo.pb,
			    ctbCAPropInfo.cb,
			    CSM_COTASKALLOC);
	}
	__try
	{
	    hr = myCAPropInfoUnmarshal(
				(CATRANSPROP *) ctbCAPropInfo.pb,
				m_cCAPropInfo,
				ctbCAPropInfo.cb,
				&m_pCAPropInfo);
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	_JumpIfError(hr, error, "myCAPropInfoUnmarshal");
    }

    hr = myCAPropInfoLookup(m_pCAPropInfo, m_cCAPropInfo, PropId, ppcap);
    _JumpIfError(hr, error, "myCAPropInfoLookup");

error:
    if (NULL != ctbCAPropInfo.pb)
    {
	MIDL_user_free(ctbCAPropInfo.pb);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertProp::GetCAPropertyFlags -- Get a CA property's type and flags
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertProp::GetCAPropertyFlags(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG PropId,		// CR_PROP_*
    /* [out, retval] */ LONG *pPropFlags)
{
    HRESULT hr;
    CAPROP const *pcap;

    if (NULL == pPropFlags)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _FindCAPropInfo(strConfig, PropId, &pcap);
    _JumpIfError(hr, error, "_FindCAPropInfo");

    *pPropFlags = pcap->lPropFlags;

error:
    return(_SetErrorInfo(hr, wszCCertProp L"::GetCAPropertyFlags"));
}


//+--------------------------------------------------------------------------
// CCertProp::GetCAPropertyDisplayName -- Get a CA property's display name
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertProp::GetCAPropertyDisplayName(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG PropId,		// CR_PROP_*
    /* [out, retval] */ BSTR *pstrDisplayName)
{
    HRESULT hr;
    CAPROP const *pcap;

    if (NULL == pstrDisplayName)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pstrDisplayName = NULL;
    hr = _FindCAPropInfo(strConfig, PropId, &pcap);
    _JumpIfError(hr, error, "_FindCAPropInfo");

    if (!ConvertWszToBstr(pstrDisplayName, pcap->pwszDisplayName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

error:
    return(_SetErrorInfo(hr, wszCCertProp L"::GetCAPropertyDisplayName"));
}


#if defined(CCERTADMIN)
//+--------------------------------------------------------------------------
// CCertProp::SetCAProperty -- Set a CA property
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertProp::SetCAProperty(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG PropId,     // CR_PROP_*
    /* [in] */ LONG PropIndex,
    /* [in] */ LONG PropType,   // PROPTYPE_*
    /* [in] */ VARIANT *pvarPropertyValue)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbValue;

    ctbValue.pb = NULL;
    if (NULL == pvarPropertyValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _OpenConnection(strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    hr = myMarshalVariant(pvarPropertyValue, PropType, &ctbValue.cb, &ctbValue.pb);
    _JumpIfError(hr, error, "myMarshalVariant");

    __try
    {
        hr = m_pICertAdminD->SetCAProperty(
                pwszAuthority,
                PropId,
                PropIndex,
                PropType,
                &ctbValue);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "SetCAProperty");

error:
    if (NULL != ctbValue.pb)
    {
        LocalFree(ctbValue.pb);
    }
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::SetCAProperty"));
}
#endif // defined(CCERTADMIN)

HRESULT
myCAPropInfoUnmarshal(
    IN CATRANSPROP const *pCATransPropInfo,
    IN LONG cCAPropInfo,
    IN DWORD cbCATransPropInfo,
    OUT CAPROP **ppCAPropInfo)
{
    HRESULT hr;
    CATRANSPROP const *pcatp;
    CATRANSPROP const *pcatpEnd;
    CAPROP *rgcap = NULL;
    CAPROP *pcap;
    BYTE *pbEnd;
    DWORD cb;
    DWORD cbAlloc;
    DWORD cbT;
    WCHAR const *pwszDisplayName;

    if (NULL == pCATransPropInfo || NULL == ppCAPropInfo)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppCAPropInfo = NULL;

    pbEnd = (BYTE *) Add2Ptr(pCATransPropInfo, cbCATransPropInfo);
    pcatpEnd = &pCATransPropInfo[cCAPropInfo];

    cb = sizeof(CAPROP) * cCAPropInfo;
    for (pcatp = pCATransPropInfo; pcatp < pcatpEnd; pcatp++)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	if ((BYTE *) (pcatp + 1) > pbEnd)
	{
	    _JumpError(hr, error, "bad marshalled data");
	}
	pwszDisplayName = NULL;
	if (0 != pcatp->obwszDisplayName)
	{
	    pwszDisplayName = (WCHAR const *) Add2Ptr(
						pCATransPropInfo,
						pcatp->obwszDisplayName);
	    if ((BYTE *) pwszDisplayName < (BYTE *) (pcatp + 1) ||
		(BYTE *) pwszDisplayName >= pbEnd)
	    {
		_JumpError(hr, error, "bad marshalled pointer");
	    }
	    cbT = sizeof(WCHAR) * (wcslen(pwszDisplayName) + 1);
	    if ((BYTE *) Add2Ptr(pwszDisplayName, cbT) > pbEnd)
	    {
		_JumpError(hr, error, "bad marshalled string");
	    }
	    hr = myCAPropGetDisplayName(pcatp->lPropId, &pwszDisplayName);
	    _PrintIfError(hr, "myCAPropGetDisplayName");
	    if (S_OK != hr)
	    {
		cb += DWORDROUND(cbT);
	    }
	}
    }
    cbAlloc = cb;

    rgcap = (CAPROP *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == rgcap)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    cb = sizeof(CAPROP) * cCAPropInfo;
    pcap = rgcap;
    for (pcatp = pCATransPropInfo; pcatp < pcatpEnd; pcap++,pcatp++)
    {
	WCHAR *pwszT;
	
	pcap->lPropId = pcatp->lPropId;
	pcap->lPropFlags = pcatp->lPropFlags;
	pcap->pwszDisplayName = NULL;

	hr = myCAPropGetDisplayName(pcatp->lPropId, &pwszDisplayName);
	_PrintIfError(hr, "myCAPropGetDisplayName");
	if (S_OK != hr && 0 != pcatp->obwszDisplayName)
	{
	    pwszDisplayName = (WCHAR const *) Add2Ptr(
						pCATransPropInfo,
						pcatp->obwszDisplayName);
	    pwszT = (WCHAR *) Add2Ptr(rgcap, cb);
	    cbT = sizeof(WCHAR) * (wcslen(pwszDisplayName) + 1);
	    CopyMemory(pwszT, pwszDisplayName, cbT);
	    cb += DWORDROUND(cbT);
	    pwszDisplayName = pwszT;
	}
	if (NULL != pwszDisplayName)
	{
	    pcap->pwszDisplayName = const_cast<WCHAR *>(pwszDisplayName);
	}

	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "RequestGetCAPropertyInfo: ielt=%d idx=%x t=%x \"%ws\"\n",
	    SAFE_SUBTRACT_POINTERS(pcatp, pCATransPropInfo),
	    pcap->lPropId,
	    pcap->lPropFlags,
	    pcap->pwszDisplayName));
    }
    CSASSERT(cbAlloc == cb);
    *ppCAPropInfo = rgcap;
    rgcap = NULL;
    hr = S_OK;

error:
    if (NULL != rgcap)
    {
	LocalFree(rgcap);
    }
    return(hr);
}


#undef __DIR__
#undef __dwFILE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\csmmchlp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       csmmchlp.h
//
//--------------------------------------------------------------------------

#define CERTMMC_HELPFILENAME L"Certmmc.hlp"

#define	IDH_CM_MODULE_LIST			70008125
#define	IDH_CRL_COMBO_PERIODSTRING		70008173
#define	IDH_CRL_EDIT_LASTUPDATE			70008174
#define	IDH_CRL_EDIT_PERIODCOUNT		70008175
#define IDH_CRL_ENABLE_DELTAPUBLISH		70008176
#define IDH_CRL_EDIT_DELTACRLPERIODCOUNT	70008177
#define IDH_CRL_COMBO_DELTACRLPERIODSTRING	70008178
#define IDH_CRL_VIEW_LIST_CRL			70008179
#define IDH_CRL_VIEW_LIST_DELTA			70008180
#define IDH_CRL_VIEW_BTN_VIEWCRL		70008181
#define IDH_CRL_VIEW_BTN_VIEWDELTA		70008182


#define	IDH_DQ_ADD_RESTRICTION	70008201
#define	IDH_DQ_DELETE_RESTRICTION	70008202
#define	IDH_DQ_QUERY_LIST	70008200
#define	IDH_DQ_RESET_BUTTON	70008203
#define	IDH_ED_COMBO_REASON	70008250
#define	IDH_NR_EDIT_NEWQUERY_FIELD	70008225
#define	IDH_NR_EDIT_NEWQUERY_OPERATION	70008226
#define	IDH_NR_EDIT_NEWQUERY_VALUE	70008227
#define	IDH_NR_DATEPICKER_NEWQUERY	70008228
#define IDH_NR_TIMEPICKER_NEWQUERY	70008229
#define	IDH_PP_BUTTON_DN	70008102
#define	IDH_PP_BUTTON_UP	70008101
#define	IDH_PP_CHECK1	70008075
#define	IDH_PP_EDIT_DATABASE_LOC	70008077
#define	IDH_PP_EDIT_LOG_LOC	70008078
#define	IDH_PP_EDIT_SHAREDFOLDER	70008076
#define	IDH_PP_LIST_AVAILABLE	70008100
#define	IDH_PP1_CANAME	70008000
#define	IDH_PP1_CSP_NAME	70008003
#define	IDH_PP1_DESCRIPTION	70008001
#define	IDH_PP1_HASHALG	70008004
#define	IDH_PP1_VIEW_CERT	70008002
#define	IDH_PP2_ACTIVE_MODULE	70008210
#define	IDH_PP2_CONFIGURE	70008209
#define	IDH_PP2_COPYRIGHT	70008028
#define	IDH_PP2_DESCRIPTION	70008026
#define	IDH_PP2_MODULENAME	70008025
#define	IDH_PP2_VERSION	70008027
#define	IDH_PP3_ACTIVE_MODULE	70008058
#define	IDH_PP3_ADDBUTTON1	70008051
#define	IDH_PP3_CONFIGURE	70008057
#define	IDH_PP3_COPYRIGHT	70008056
#define	IDH_PP3_DESCRIPTION	70008054
#define	IDH_PP3_EDIT1	70008050
#define	IDH_PP3_MODULENAME	70008053
#define	IDH_PP3_REMOVEBUTTON4	70008052
#define	IDH_PP3_VERSION	70008055
#define	IDH_RESTORE_DEFOK2	70008103
#define	IDH_ADDURL_EDITURL	70008400
#define	IDH_CRL_ADD	70008426
#define	IDH_CRL_LIST	70008425
#define	IDH_CRL_REMOVE	70008427
#define	IDH_EXIT_CHECK_FILE	70008451
#define	IDH_EXIT2_CHECK_DS	70008450
#define	IDH_DA_RADIO_PENDFIRST	70008500
#define	IDH_DA_RADIO_ISSUE	70008501
#define	IDH_POL2_ADD_AIA	70008529
#define	IDH_POL2_ADD_CRL	70008526
#define	IDH_POL2_AIA_LIST	70008528
#define	IDH_POL2_CRL_LIST	70008525
#define	IDH_POL2_REMOVE_AIA	70008530
#define	IDH_POL2_REMOVE_CRL	70008527
#define IDH_RADIO_REUSEKEY	70008541
#define IDH_RADIO_NEWKEY	70008542
#define IDH_RADIO_DISABLEOFFICERS	70008543
#define IDH_RADIO_ENABLEOFFICERS	70008544
#define IDH_LIST_CERTMANAGERS	70008545
#define IDH_LIST_SUBJECTS	70008546
#define IDH_ALLOWDENY		70008547
#define IDH_ADDSUBJECT		70008548
#define IDH_REMOVESUBJECT	70008549
#define IDH_AUDIT_BACKUPRESTORE	70008550
#define IDH_AUDIT_CACONFIG	70008551
#define IDH_AUDIT_CASEC		70008552
#define IDH_AUDIT_CERTIFICATE	70008553
#define IDH_AUDIT_CRL		70008554
#define IDH_AUDIT_KEYARCHIVAL	70008555
#define IDH_AUDIT_STARTSTOP	70008556
#define IDH_KRA_DISABLE		70008557
#define IDH_KRA_ENABLE		70008558
#define IDH_KRA_EDITCOUNT	70008559
#define IDH_LIST_KRA		70008560
#define IDH_KRA_ADD		70008561
#define IDH_KRA_REMOVE		70008562
#define IDH_KRA_VIEW		70008563
#define IDH_CERTIFICATE_TYPE_LIST	70008564
#define IDH_CERTIFICATE_TEMPLATE_NAME	70008565
#define IDH_PURPOSE_LIST 	70008566
#define IDH_OTHER_INFO_LIST	70008567
#define IDH_PP1_LIST_CERTS      70008568
#define IDH_PP3_EXIT_LIST      	70008569
#define IDH_EXT_SELECT		70008570
#define IDH_ADDTOCERTCDP	70008571
#define IDH_ADDTOFRESHESTCRL	70008572
#define IDH_ADDTOCRLCDP 	70008573
#define IDH_ADDTOCERTOCSP	70008574
#define IDH_SERVERPUBLISH	70008575
#define IDH_PP_LIST_ATTR        70008576
#define	IDH_PP_LIST_EXTN        70008577
#define IDH_PP_EDIT_EXTN        70008578
#define IDH_COMBO_VARIABLE      70008579
#define IDH_BUTTON_INSERTVAR    70008580
#define IDH_EDIT_VARIABLEDESCRIPTION 70008581
#define IDH_SERVERPUBLISHDELTA  70008582

#if defined (_CERTMMC_)

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE1[]=
{
	IDC_HASHALG,IDH_PP1_HASHALG,
	IDC_CANAME,IDH_PP1_CANAME,
	IDC_DESCRIPTION,IDH_PP1_DESCRIPTION,
	IDC_VIEW_CERT,IDH_PP1_VIEW_CERT,
	IDC_CSP_NAME,IDH_PP1_CSP_NAME,
        IDC_LIST_CERTS, IDH_PP1_LIST_CERTS,
	0, 0
};


const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE2[]=
{
	IDC_DESCRIPTION,IDH_PP2_DESCRIPTION,
	IDC_CONFIGURE,IDH_PP2_CONFIGURE,
	IDC_MODULENAME,IDH_PP2_MODULENAME,
	IDC_COPYRIGHT,IDH_PP2_COPYRIGHT,
	IDC_VERSION,IDH_PP2_VERSION,
	IDC_ACTIVE_MODULE,IDH_PP2_ACTIVE_MODULE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE3[]=
{
	IDC_ACTIVE_MODULE,IDH_PP3_ACTIVE_MODULE,
	IDC_EDIT1,IDH_PP3_EDIT1,
	IDC_BUTTON1,IDH_PP3_ADDBUTTON1,
	IDC_DESCRIPTION,IDH_PP3_DESCRIPTION,
	IDC_VERSION,IDH_PP3_VERSION,
	IDC_COPYRIGHT,IDH_PP3_COPYRIGHT,
	IDC_CONFIGURE,IDH_PP3_CONFIGURE,
	IDC_MODULENAME,IDH_PP3_MODULENAME,
	IDC_BUTTON4,IDH_PP3_REMOVEBUTTON4,
        IDC_EXIT_LIST,IDH_PP3_EXIT_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE4_AIA[]=
{
	IDC_URL_REMOVE,IDH_POL2_REMOVE_CRL,
	IDC_URL_ADD,IDH_POL2_ADD_CRL,
	IDC_URL_LIST,IDH_POL2_CRL_LIST,
	IDC_EXT_SELECT,IDH_EXT_SELECT,
	IDC_ADDTOCERTCDP,IDH_ADDTOCERTCDP,
	IDC_ADDTOFRESHESTCRL,IDH_ADDTOFRESHESTCRL,
	IDC_ADDTOCRLCDP,IDH_ADDTOCRLCDP,
	IDC_ADDTOCERTOCSP,IDH_ADDTOCERTOCSP,
	IDC_SERVERPUBLISH,IDH_SERVERPUBLISH,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE4_CDP[]=
{
	IDC_URL_REMOVE,IDH_POL2_REMOVE_CRL,
	IDC_URL_ADD,IDH_POL2_ADD_CRL,
	IDC_URL_LIST,IDH_POL2_CRL_LIST,
	IDC_EXT_SELECT,IDH_EXT_SELECT,
	IDC_ADDTOCERTCDP,IDH_ADDTOCERTCDP,
	IDC_ADDTOFRESHESTCRL,IDH_ADDTOFRESHESTCRL,
	IDC_ADDTOCRLCDP,IDH_ADDTOCRLCDP,
	IDC_ADDTOCERTOCSP,IDH_SERVERPUBLISHDELTA,
	IDC_SERVERPUBLISH,IDH_SERVERPUBLISH,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE5[]=
{
	IDC_CHECK1,IDH_PP_CHECK1,
	IDC_EDIT_SHAREDFOLDER,IDH_PP_EDIT_SHAREDFOLDER,
	IDC_EDIT_LOG_LOC,IDH_PP_EDIT_LOG_LOC,
	IDC_EDIT_DATABASE_LOC,IDH_PP_EDIT_DATABASE_LOC,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ATTR_PROPPAGE[] = 
{
	IDC_LIST_ATTR,IDH_PP_LIST_ATTR,
	0, 0
};

const DWORD g_aHelpIDs_IDD_EXTN_PROPPAGE[] =
{
	IDC_LIST_EXTN,IDH_PP_LIST_EXTN,
        IDC_EDIT_EXTN,IDH_PP_EDIT_EXTN,
	0, 0
};


const DWORD g_aHelpIDs_IDD_CHOOSE_COLUMNS[]=
{
	IDC_LIST_AVAILABLE,IDH_PP_LIST_AVAILABLE,
	IDC_BUTTON_UP,IDH_PP_BUTTON_UP,
	IDC_BUTTON_DN,IDH_PP_BUTTON_DN,
	IDOK2,IDH_RESTORE_DEFOK2,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CHOOSE_MODULE[]=
{
	IDC_MODULE_LIST,IDH_CM_MODULE_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CRL_PROPPAGE[]=
{
	IDC_EDIT_CRLPERIODCOUNT,IDH_CRL_EDIT_PERIODCOUNT,
	IDC_COMBO_CRLPERIODSTRING,IDH_CRL_COMBO_PERIODSTRING,
	IDC_EDIT_LASTUPDATE,IDH_CRL_EDIT_LASTUPDATE,
	IDC_ENABLE_DELTAPUBLISH,IDH_CRL_ENABLE_DELTAPUBLISH,
	IDC_EDIT_DELTACRLPERIODCOUNT,IDH_CRL_EDIT_DELTACRLPERIODCOUNT,
	IDC_COMBO_DELTACRLPERIODSTRING,IDH_CRL_COMBO_DELTACRLPERIODSTRING,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CRL_VIEWPAGE[]=
{
	IDC_CRL_VIEW_LIST_CRL,      IDH_CRL_VIEW_LIST_CRL,
	IDC_CRL_VIEW_LIST_DELTA,    IDH_CRL_VIEW_LIST_DELTA,
	IDC_CRL_VIEW_BTN_VIEWCRL,   IDH_CRL_VIEW_BTN_VIEWCRL,
	IDC_CRL_VIEW_BTN_VIEWDELTA, IDH_CRL_VIEW_BTN_VIEWDELTA,
	0, 0
};

const DWORD g_aHelpIDs_IDD_DEFINE_QUERY[]=
{
	IDC_RESET_BUTTON,IDH_DQ_RESET_BUTTON,
	IDC_QUERY_LIST,IDH_DQ_QUERY_LIST,
	IDC_ADD_RESTRICTION,IDH_DQ_ADD_RESTRICTION,
	IDC_DELETE_RESTRICTION,IDH_DQ_DELETE_RESTRICTION,
	0, 0
};

const DWORD g_aHelpIDs_IDD_NEW_RESTRICTION[]=
{
	IDC_EDIT_NEWQUERY_VALUE,IDH_NR_EDIT_NEWQUERY_VALUE,
	IDC_EDIT_NEWQUERY_FIELD,IDH_NR_EDIT_NEWQUERY_FIELD,
	IDC_EDIT_NEWQUERY_OPERATION,IDH_NR_EDIT_NEWQUERY_OPERATION,
	IDC_DATEPICKER_NEWQUERY, IDH_NR_DATEPICKER_NEWQUERY,
	IDC_TIMEPICKER_NEWQUERY, IDH_NR_TIMEPICKER_NEWQUERY,
	0, 0
};

const DWORD g_aHelpIDs_IDD_REVOCATION_DIALOG[]=
{
	IDC_COMBO_REASON,IDH_ED_COMBO_REASON,
	0, 0
};


const DWORD g_aHelpIDs_IDD_RENEW_REUSEKEYS[]=
{
	IDC_RADIO_REUSEKEY,IDH_RADIO_REUSEKEY,
	IDC_RADIO_NEWKEY,IDH_RADIO_NEWKEY,
	0,0
};

const DWORD g_aHelpIDs_IDD_ADDURL[]=
{
	IDC_EDITURL, IDH_ADDURL_EDITURL,
	IDC_COMBO_VARIABLE, IDH_COMBO_VARIABLE,
	IDC_BUTTON_INSERTVAR, IDH_BUTTON_INSERTVAR,
	IDC_EDIT_VARIABLEDESCRIPTION, IDH_EDIT_VARIABLEDESCRIPTION,
	0,0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE6[]=
{
	IDC_RADIO_DISABLEOFFICERS, IDH_RADIO_DISABLEOFFICERS,
	IDC_RADIO_ENABLEOFFICERS, IDH_RADIO_ENABLEOFFICERS,
	IDC_LIST_CERTMANAGERS, IDH_LIST_CERTMANAGERS,
	IDC_LIST_SUBJECTS, IDH_LIST_SUBJECTS,
	IDC_ALLOWDENY, IDH_ALLOWDENY,
	IDC_ADDSUBJECT, IDH_ADDSUBJECT,
	IDC_REMOVESUBJECT, IDH_REMOVESUBJECT,
	0,0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE7[]=
{
	IDC_AUDIT_BACKUPRESTORE, IDH_AUDIT_BACKUPRESTORE,
	IDC_AUDIT_CACONFIG, IDH_AUDIT_CACONFIG,
	IDC_AUDIT_CASEC, IDH_AUDIT_CASEC,
	IDC_AUDIT_CERTIFICATE, IDH_AUDIT_CERTIFICATE,
	IDC_AUDIT_CRL, IDH_AUDIT_CRL,
	IDC_AUDIT_KEYARCHIVAL, IDH_AUDIT_KEYARCHIVAL,
	IDC_AUDIT_STARTSTOP, IDH_AUDIT_STARTSTOP,
	0,0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE_CHOOSE_KRA[]=
{
	IDC_KRA_DISABLE, IDH_KRA_DISABLE,
	IDC_KRA_ENABLE, IDH_KRA_ENABLE,
	IDC_KRA_EDITCOUNT, IDH_KRA_EDITCOUNT,
	IDC_LIST_KRA, IDH_LIST_KRA,
	IDC_KRA_ADD, IDH_KRA_ADD,
	IDC_KRA_REMOVE, IDH_KRA_REMOVE,
	IDC_KRA_VIEW, IDH_KRA_VIEW,
	0,0
};

#endif // #if defined (_CERTMMC_)


#if defined (_CERTEXIT_)

//certexit.rc
const DWORD g_aHelpIDs_IDD_ADDURL[]=
{
	IDC_EDITURL, IDH_ADDURL_EDITURL,
	0,0
};

const DWORD g_aHelpIDs_IDD_EXITPG1[]=
{
	IDC_REMOVE_CRL, IDH_CRL_REMOVE,
	IDC_ADD_CRL, IDH_CRL_ADD,
	IDC_CRL_LIST, IDH_CRL_LIST,
	0,0
};

const DWORD g_aHelpIDs_IDD_EXITPG2[]=
{
	IDC_CHECK_FILE, IDH_EXIT_CHECK_FILE,
	0,0
};

#endif // #if defined (_CERTEXIT_)


#if defined (_CERTPDEF_)

//certpent.rc
const DWORD g_aHelpIDs_IDD_POLICYPG1[]=
{
	IDC_RADIO_ISSUE,IDH_DA_RADIO_ISSUE,
	IDC_RADIO_PENDFIRST,IDH_DA_RADIO_PENDFIRST,
	0,0
};


#endif // #if defined (_CERTPDEF_)


#if defined (_CAPESNPN_)

const DWORD g_aHelpIDs_IDD_SELECT_CERTIFICATE_TEMPLATE[]=
{
	IDC_CERTIFICATE_TYPE_LIST, IDH_CERTIFICATE_TYPE_LIST,
	0,0
};

const DWORD g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE[]=
{
	IDC_CERTIFICATE_TEMPLATE_NAME, IDH_CERTIFICATE_TEMPLATE_NAME,
	IDC_PURPOSE_LIST, IDH_PURPOSE_LIST,
	IDC_OTHER_INFO_LIST, IDH_OTHER_INFO_LIST,
	0,0
};

#endif // #if defined (_CAPESNPN_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\csregstr.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csregstr.h
//
// Contents:    Cert Server registry string definitions
//
//---------------------------------------------------------------------------

#ifndef __CSREGSTR_H__
#define __CSREGSTR_H__

#define wszROOT_CERTSTORE       TEXT("ROOT")
#define wszKRA_CERTSTORE        TEXT("KRA")
#define wszCA_CERTSTORE         TEXT("CA")
#define wszMY_CERTSTORE         TEXT("MY")
#define wszACRS_CERTSTORE	TEXT("ACRS")
#define wszREQUEST_CERTSTORE	TEXT("REQUEST")
#define wszNTAUTH_CERTSTORE     TEXT("NTAUTH")


// begin_certsrv

#define wszSERVICE_NAME		TEXT("CertSvc")

#define wszREGKEYNOSYSTEMCERTSVCPATH \
				TEXT("CurrentControlSet\\Services\\") \
				wszSERVICE_NAME

#define wszREGKEYCERTSVCPATH	TEXT("SYSTEM\\") wszREGKEYNOSYSTEMCERTSVCPATH
#define wszREGKEYBASE		wszREGKEYCERTSVCPATH	// obsolete definition

//======================================================================
// Full path to "CertSvc\Configuration\":
#define wszREGKEYCONFIGPATH	wszREGKEYCERTSVCPATH TEXT("\\") wszREGKEYCONFIG
#define wszREGKEYCONFIGPATH_BS	wszREGKEYCONFIGPATH TEXT("\\")
#define wszREGKEYCONFIGCANAME	wszREGKEYCONFIGPATH_BS	// obsolete definition

//======================================================================
// Full path to "CertSvc\Configuration\RestoreInProgress":
#define wszREGKEYCONFIGRESTORE wszREGKEYCONFIGPATH_BS wszREGKEYRESTOREINPROGRESS

//======================================================================
// Key Under "CertSvc":
#define wszREGKEYCONFIG		TEXT("Configuration")

//======================================================================
// Values Under "CertSvc\Configuration":
#define wszREGACTIVE		      TEXT("Active")
#define wszREGDIRECTORY		      TEXT("ConfigurationDirectory")
#define wszREGDBDIRECTORY             TEXT("DBDirectory")
#define wszREGDBLOGDIRECTORY          TEXT("DBLogDirectory")
#define wszREGDBSYSDIRECTORY          TEXT("DBSystemDirectory")
#define wszREGDBTEMPDIRECTORY         TEXT("DBTempDirectory")
#define wszREGDBSESSIONCOUNT	      TEXT("DBSessionCount")
#define wszREGDBFLAGS		      TEXT("DBFlags")
#define wszREGDBLASTFULLBACKUP	      TEXT("DBLastFullBackup")
#define wszREGDBLASTINCREMENTALBACKUP TEXT("DBLastIncrementalBackup")
#define wszREGDBLASTRECOVERY	      TEXT("DBLastRecovery")
#define wszREGWEBCLIENTCAMACHINE      TEXT("WebClientCAMachine")
#define wszREGVERSION		      TEXT("Version")
#define wszREGWEBCLIENTCANAME         TEXT("WebClientCAName")
#define wszREGWEBCLIENTCATYPE         TEXT("WebClientCAType")
#define wszREGLDAPFLAGS               TEXT("LDAPFlags")
#define wszREGCERTSRVDEBUG	      TEXT("Debug")

// end_certsrv

#define wszREGCERTSRVMEMTRACK	     TEXT("MemTrack")

// Environment variables:
#define szCERTSRV_DEBUG		     "CERTSRV_DEBUG"
#define szCERTSRV_LOGFILE	     "CERTSRV_LOGFILE"
#define szCERTSRV_LOGMAX	     "CERTSRV_LOGMAX"
#define szCERTSRV_MEMTRACK	     "CERTSRV_MEMTRACK"

// begin_certsrv

// Default value for wszREGDBSESSIONCOUNT
#define DBSESSIONCOUNTDEFAULT	     20

// Values for wszREGDBFLAGS
// Default is zero (same as a missing registry value):

#define DBFLAGS_READONLY		0x00000001	// ignored in registry
#define DBFLAGS_CREATEIFNEEDED		0x00000002
#define DBFLAGS_CIRCULARLOGGING		0x00000004
#define DBFLAGS_LAZYFLUSH		0x00000008
#define DBFLAGS_MAXCACHESIZEX100	0x00000010
#define DBFLAGS_CHECKPOINTDEPTH60MB	0x00000020
#define DBFLAGS_LOGBUFFERSLARGE		0x00000040
#define DBFLAGS_LOGBUFFERSHUGE		0x00000080
#define DBFLAGS_LOGFILESIZE16MB		0x00000100
#define DBFLAGS_MULTITHREADTRANSACTIONS	0x00000200
#define DBFLAGS_DISABLESNAPSHOTBACKUP	0x00000400	// ignored in registry

#define DBFLAGS_DEFAULT		(DBFLAGS_LAZYFLUSH | \
				 DBFLAGS_MAXCACHESIZEX100 | \
				 DBFLAGS_CHECKPOINTDEPTH60MB | \
				 DBFLAGS_LOGBUFFERSHUGE)


// Values for wszREGLDAPSSLFLAGS
// Default is zero (same as a missing registry value):
//    0: Don't use SSL, but sign all LDAP traffic.
//    3: Use SSL but don't sign LDAP traffic.
#define LDAPF_SSLENABLE		0x00000001	// use SSL for LDAP traffic
#define LDAPF_SIGNDISABLE	0x00000002	// disable signing LDAP traffic

// Default value for wszREGMAXINCOMINGMESSAGESIZE
#define MAXINCOMINGMESSAGESIZEDEFAULT		(64 * 1024)

// Default value for wszREGMAXINCOMINGALLOCSIZE
#define MAXINCOMINGALLOCSIZEDEFAULT		(64 * 1024)

// Value for wszREGVERSION:

// win2k version
#define CSVER_MAJOR_WIN2K            1 // actually this wasn't define in win2k
#define CSVER_MINOR_WIN2K            1

// whistler version
#define CSVER_MAJOR_WHISTLER         2
#define CSVER_MINOR_WHISTLER_BETA2   1
#define CSVER_MINOR_WHISTLER_BETA3   2

// current version
#define CSVER_MAJOR		     CSVER_MAJOR_WHISTLER	// high 16 bits
#define CSVER_MINOR		     CSVER_MINOR_WHISTLER_BETA3	// low 16 bits

// version manipulation
#define CSVER_EXTRACT_MAJOR(version) ((version)>>16)
#define CSVER_EXTRACT_MINOR(version) ((version)&0xffff)
#define CSVER_BUILD_VERSION(major, minor) (((major)<<16)|(minor))

// Keys Under "CertSvc\Configuration":
#define wszREGKEYRESTOREINPROGRESS   TEXT("RestoreInProgress")
#define wszREGKEYDBPARAMETERS	     TEXT("DBParameters")

//======================================================================
// Values Under "CertSvc\Configuration\<CAName>":
#define wszREGCADESCRIPTION          TEXT("CADescription")
#define wszREGCACERTHASH	     TEXT("CACertHash")
#define wszREGCASERIALNUMBER	     TEXT("CACertSerialNumber")
#define wszREGCAXCHGCERTHASH	     TEXT("CAXchgCertHash")
#define wszREGKRACERTHASH	     TEXT("KRACertHash")
#define wszREGKRACERTCOUNT	     TEXT("KRACertCount")
#define wszREGKRAFLAGS		     TEXT("KRAFlags")
#define wszREGCATYPE		     TEXT("CAType")
#define wszREGCERTENROLLCOMPATIBLE   TEXT("CertEnrollCompatible")
#define wszREGENFORCEX500NAMELENGTHS TEXT("EnforceX500NameLengths")
#define wszREGCOMMONNAME	     TEXT("CommonName")
#define wszREGCLOCKSKEWMINUTES	     TEXT("ClockSkewMinutes")

#define wszREGCRLNEXTPUBLISH         TEXT("CRLNextPublish")
#define wszREGCRLPERIODSTRING	     TEXT("CRLPeriod")
#define wszREGCRLPERIODCOUNT	     TEXT("CRLPeriodUnits")
#define wszREGCRLOVERLAPPERIODSTRING TEXT("CRLOverlapPeriod")
#define wszREGCRLOVERLAPPERIODCOUNT  TEXT("CRLOverlapUnits")

#define wszREGCRLDELTANEXTPUBLISH    TEXT("CRLDeltaNextPublish")
#define wszREGCRLDELTAPERIODSTRING   TEXT("CRLDeltaPeriod")
#define wszREGCRLDELTAPERIODCOUNT    TEXT("CRLDeltaPeriodUnits")
#define wszREGCRLDELTAOVERLAPPERIODSTRING TEXT("CRLDeltaOverlapPeriod")
#define wszREGCRLDELTAOVERLAPPERIODCOUNT  TEXT("CRLDeltaOverlapUnits")

#define wszREGCRLPUBLICATIONURLS     TEXT("CRLPublicationURLs")
#define wszREGCACERTPUBLICATIONURLS  TEXT("CACertPublicationURLs")

#define wszREGCAXCHGVALIDITYPERIODSTRING  TEXT("CAXchgValidityPeriod")
#define wszREGCAXCHGVALIDITYPERIODCOUNT   TEXT("CAXchgValidityPeriodUnits")
#define wszREGCAXCHGOVERLAPPERIODSTRING   TEXT("CAXchgOverlapPeriod")
#define wszREGCAXCHGOVERLAPPERIODCOUNT    TEXT("CAXchgOverlapPeriodUnits")

#define wszREGCRLPATH_OLD            TEXT("CRLPath")
#define wszREGCRLEDITFLAGS	     TEXT("CRLEditFlags")
#define wszREGCRLFLAGS		     TEXT("CRLFlags")
#define wszREGCRLATTEMPTREPUBLISH    TEXT("CRLAttemptRepublish")
#define wszREGENABLED		     TEXT("Enabled")
#define wszREGFORCETELETEX           TEXT("ForceTeletex")
#define wszREGLOGLEVEL		     TEXT("LogLevel")
#define wszREGHIGHSERIAL	     TEXT("HighSerial")
#define wszREGPOLICYFLAGS	     TEXT("PolicyFlags")
#define wszREGNAMESEPARATOR          TEXT("SubjectNameSeparator")
#define wszREGSUBJECTTEMPLATE	     TEXT("SubjectTemplate")
#define wszREGCAUSEDS		     TEXT("UseDS")
#define wszREGVALIDITYPERIODSTRING   TEXT("ValidityPeriod")
#define wszREGVALIDITYPERIODCOUNT    TEXT("ValidityPeriodUnits")
#define wszREGPARENTCAMACHINE        TEXT("ParentCAMachine")
#define wszREGPARENTCANAME           TEXT("ParentCAName")
#define wszREGREQUESTFILENAME        TEXT("RequestFileName")
#define wszREGREQUESTID              TEXT("RequestId")
#define wszREGREQUESTKEYCONTAINER    TEXT("RequestKeyContainer")
#define wszREGREQUESTKEYINDEX        TEXT("RequestKeyIndex")
#define wszREGCASERVERNAME           TEXT("CAServerName")
#define wszREGCACERTFILENAME         TEXT("CACertFileName")
#define wszREGCASECURITY             TEXT("Security")
#define wszREGAUDITFILTER            TEXT("AuditFilter")
#define wszREGOFFICERRIGHTS          TEXT("OfficerRights")
#define wszREGMAXINCOMINGMESSAGESIZE TEXT("MaxIncomingMessageSize")
#define wszREGMAXINCOMINGALLOCSIZE   TEXT("MaxIncomingAllocSize")
#define wszREGROLESEPARATIONENABLED  TEXT("RoleSeparationEnabled")
#define wszREGALTERNATEPUBLISHDOMAINS TEXT("AlternatePublishDomains")

#define wszREGSETUPSTATUS            TEXT("SetupStatus")
#define wszREGINTERFACEFLAGS         TEXT("InterfaceFlags")    
#define wszREGDSCONFIGDN	     TEXT("DSConfigDN")    
#define wszREGDSDOMAINDN	     TEXT("DSDomainDN")    
#define wszREGVIEWAGEMINUTES	     TEXT("ViewAgeMinutes")
#define wszREGVIEWIDLEMINUTES	     TEXT("ViewIdleMinutes")


#define wszCRTFILENAMEEXT	     TEXT(".crt")
#define wszPFXFILENAMEEXT	     TEXT(".p12")
#define wszDATFILENAMEEXT	     TEXT(".dat")
#define wszLOGFILENAMEEXT	     TEXT(".log")
#define wszDBFILENAMEEXT	     TEXT(".edb")
#define szDBBASENAMEPARM	     "edb"
#define wszDBBASENAMEPARM	     TEXT(szDBBASENAMEPARM)
#define wszLOGPATH		     TEXT("CertLog")
#define wszDBBACKUPSUBDIR	     TEXT("DataBase")
#define wszDBBACKUPCERTBACKDAT	     TEXT("certbkxp.dat")

#ifndef __ENUM_CATYPES__
#define __ENUM_CATYPES__

// Values for wszREGCATYPE:
typedef enum {
    ENUM_ENTERPRISE_ROOTCA = 0,
    ENUM_ENTERPRISE_SUBCA = 1,
    //ENUM_UNUSED2 = 2,
    ENUM_STANDALONE_ROOTCA = 3,
    ENUM_STANDALONE_SUBCA = 4,
    ENUM_UNKNOWN_CA = 5,
} ENUM_CATYPES;

typedef struct _CAINFO
{
    DWORD   cbSize;
    ENUM_CATYPES CAType;
    DWORD   cCASignatureCerts;
    DWORD   cCAExchangeCerts;
    DWORD   cExitModules;
    LONG    lPropIdMax;
    LONG    lRoleSeparationEnabled;
    DWORD   cKRACertUsedCount;
    DWORD   cKRACertCount;
    DWORD   fAdvancedServer;   
} CAINFO;

#endif __ENUM_CATYPES__

// Default value for wszREGCLOCKSKEWMINUTES
#define CCLOCKSKEWMINUTESDEFAULT	      10


// Default value for wszREGVIEWAGEMINUTES, wszREGVIEWIDLEMINUTES
#define CVIEWAGEMINUTESDEFAULT			16
#define CVIEWIDLEMINUTESDEFAULT			(CVIEWAGEMINUTESDEFAULT / 2)

// Default validity period for ROOT CA certs:
#define dwVALIDITYPERIODCOUNTDEFAULT_ROOT	5

// Default validity periods for certs issued by a CA:
#define dwVALIDITYPERIODCOUNTDEFAULT_ENTERPRISE	2
#define dwVALIDITYPERIODCOUNTDEFAULT_STANDALONE	1
#define dwVALIDITYPERIODENUMDEFAULT	      ENUM_PERIOD_YEARS
#define wszVALIDITYPERIODSTRINGDEFAULT	      wszPERIODYEARS

#define dwCAXCHGVALIDITYPERIODCOUNTDEFAULT    1
#define dwCAXCHGVALIDITYPERIODENUMDEFAULT     ENUM_PERIOD_WEEKS
#define wszCAXCHGVALIDITYPERIODSTRINGDEFAULT  wszPERIODWEEKS

#define dwCAXCHGOVERLAPPERIODCOUNTDEFAULT     1
#define dwCAXCHGOVERLAPPERIODENUMDEFAULT      ENUM_PERIOD_DAYS
#define wszCAXCHGOVERLAPPERIODSTRINGDEFAULT   wszPERIODDAYS

#define dwCRLPERIODCOUNTDEFAULT		      1
#define wszCRLPERIODSTRINGDEFAULT	      wszPERIODWEEKS

#define dwCRLOVERLAPPERIODCOUNTDEFAULT	      0		// 0 --> disabled
#define wszCRLOVERLAPPERIODSTRINGDEFAULT      wszPERIODHOURS

#define dwCRLDELTAPERIODCOUNTDEFAULT          1
#define wszCRLDELTAPERIODSTRINGDEFAULT        wszPERIODDAYS

#define dwCRLDELTAOVERLAPPERIODCOUNTDEFAULT   0		// 0 --> disabled
#define wszCRLDELTAOVERLAPPERIODSTRINGDEFAULT wszPERIODMINUTES


// Values for wszREGLOGLEVEL:
#define CERTLOG_MINIMAL		(DWORD) 0
#define CERTLOG_TERSE		(DWORD) 1
#define CERTLOG_ERROR		(DWORD) 2
#define CERTLOG_WARNING		(DWORD) 3
#define CERTLOG_VERBOSE		(DWORD) 4
#define CERTLOG_EXHAUSTIVE	(DWORD) 5


// Values for wszREGSETUPSTATUS:
#define SETUP_SERVER_FLAG		0x00000001	// server installed
#define SETUP_CLIENT_FLAG		0x00000002	// client installed
#define SETUP_SUSPEND_FLAG		0x00000004	// incomplete install
#define SETUP_REQUEST_FLAG		0x00000008	// new cert requested
#define SETUP_ONLINE_FLAG		0x00000010	// requested online
#define SETUP_DENIED_FLAG		0x00000020	// request denied
#define SETUP_CREATEDB_FLAG		0x00000040	// create new DB
#define SETUP_ATTEMPT_VROOT_CREATE	0x00000080	// try to create vroots
#define SETUP_FORCECRL_FLAG		     0x00000100	// force new CRL(s)
#define SETUP_UPDATE_CAOBJECT_SVRTYPE	     0x00000200	// add server type to CA DS object "flags" attr
#define SETUP_SERVER_UPGRADED_FLAG	     0x00000400	// server was upgraded
#define SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG 0x00000800 // still need to upgrade security
#define SETUP_SECURITY_CHANGED          0x00001000 // permissons changed while CA was down, certsrv will
                                                   // need to update DS & service when it restarts

// Values for wszREGCRLFLAGS:
#define CRLF_DELTA_USE_OLDEST_UNEXPIRED_BASE	0x00000001 // use oldest base:
// else use newest base CRL that satisfies base CRL propagation delay

#define CRLF_DELETE_EXPIRED_CRLS		0x00000002
#define CRLF_CRLNUMBER_CRITICAL			0x00000004
#define CRLF_REVCHECK_IGNORE_OFFLINE		0x00000008
#define CRLF_IGNORE_INVALID_POLICIES		0x00000010
#define CRLF_REBUILD_MODIFIED_SUBJECT_ONLY	0x00000020
#define CRLF_SAVE_FAILED_CERTS			0x00000040
#define CRLF_IGNORE_UNKNOWN_CMC_ATTRIBUTES	0x00000080
#define CRLF_IGNORE_CROSS_CERT_TRUST_ERROR	0x00000100
#define CRLF_PUBLISH_EXPIRED_CERT_CRLS		0x00000200
#define CRLF_ENFORCE_ENROLLMENT_AGENT		0x00000400
#define CRLF_DISABLE_RDN_REORDER		0x00000800
#define CRLF_DISABLE_ROOT_CROSS_CERTS		0x00001000
#define CRLF_LOG_FULL_RESPONSE	     0x00002000 // hex dump response to console
#define CRLF_USE_XCHG_CERT_TEMPLATE  0x00004000 // enforce xchg template access
#define CRLF_USE_CROSS_CERT_TEMPLATE 0x00008000 // enforce cross template access
#define CRLF_ALLOW_REQUEST_ATTRIBUTE_SUBJECT	0x00010000
#define CRLF_REVCHECK_IGNORE_NOREVCHECK		0x00020000
#define CRLF_PRESERVE_EXPIRED_CA_CERTS		0x00040000
#define CRLF_PRESERVE_REVOKED_CA_CERTS		0x00080000

// Values for wszREGKRAFLAGS:
#define KRAF_ENABLEFOREIGN	0x00000001 // allow foreign cert, key archival
#define KRAF_SAVEBADREQUESTKEY	0x00000002 // save failed request w/archived key
#define KRAF_ENABLEARCHIVEALL	0x00000004

// Values for wszREGINTERFACEFLAGS:
#define IF_LOCKICERTREQUEST		0x00000001
#define IF_NOREMOTEICERTREQUEST		0x00000002
#define IF_NOLOCALICERTREQUEST		0x00000004
#define IF_NORPCICERTREQUEST		0x00000008
#define IF_NOREMOTEICERTADMIN		0x00000010
#define IF_NOLOCALICERTADMIN		0x00000020
#define IF_NOREMOTEICERTADMINBACKUP	0x00000040
#define IF_NOLOCALICERTADMINBACKUP	0x00000080
#define IF_NOSNAPSHOTBACKUP		0x00000100
#define IF_ENFORCEENCRYPTICERTREQUEST   0x00000200
#define IF_ENFORCEENCRYPTICERTADMIN     0x00000400

#define IF_DEFAULT			(IF_NOREMOTEICERTADMINBACKUP)

// Values for numeric prefixes for
// wszREGCRLPUBLICATIONURLS and wszREGCACERTPUBLICATIONURLS:
//
// URL publication template Flags values, encoded as a decimal prefix for URL
// publication templates in the registry:
//   "1:c:\winnt\System32\CertSrv\CertEnroll\MyCA.crl"
//   "2:http:\//MyServer.MyDomain.com/CertEnroll\MyCA.crl"

#define CSURL_SERVERPUBLISH	 0x00000001
#define CSURL_ADDTOCERTCDP	 0x00000002
#define CSURL_ADDTOFRESHESTCRL	 0x00000004
#define CSURL_ADDTOCRLCDP	 0x00000008
#define CSURL_PUBLISHRETRY	 0x00000010
#define CSURL_ADDTOCERTOCSP	 0x00000020
#define CSURL_SERVERPUBLISHDELTA 0x00000040
// end_certsrv

// Initialization internal definitions -- not written to the registry:
#define CSURL_ADDSYSTEM32DIR	0x20000000
#define CSURL_NODS		0x40000000
#define CSURL_DSONLY		0x80000000
#define CSURL_INITMASK		0xf0000000

// begin_certsrv
//======================================================================
// Keys Under "CertSvc\Configuration\<CAName>":
#define wszREGKEYCSP			TEXT("CSP")
#define wszREGKEYENCRYPTIONCSP		TEXT("EncryptionCSP")
#define wszREGKEYEXITMODULES		TEXT("ExitModules")
#define wszREGKEYPOLICYMODULES	        TEXT("PolicyModules")
#define wszSECUREDATTRIBUTES		TEXT("SignedAttributes")

#define wszzDEFAULTSIGNEDATTRIBUTES     TEXT("RequesterName\0")

//======================================================================
// Values Under "CertSvc\Configuration\RestoreInProgress":
#define wszREGBACKUPLOGDIRECTORY	TEXT("BackupLogDirectory")
#define wszREGCHECKPOINTFILE		TEXT("CheckPointFile")
#define wszREGHIGHLOGNUMBER		TEXT("HighLogNumber")
#define wszREGLOWLOGNUMBER		TEXT("LowLogNumber")
#define wszREGLOGPATH			TEXT("LogPath")
#define wszREGRESTOREMAPCOUNT		TEXT("RestoreMapCount")
#define wszREGRESTOREMAP		TEXT("RestoreMap")
#define wszREGDATABASERECOVERED		TEXT("DatabaseRecovered")
#define wszREGRESTORESTATUS		TEXT("RestoreStatus")

// values under \Configuration\PolicyModules in nt5 beta 2
#define wszREGB2ICERTMANAGEMODULE   TEXT("ICertManageModule")
// values under \Configuration in nt4 sp4
#define wszREGSP4DEFAULTCONFIGURATION  TEXT("DefaultConfiguration")
// values under ca in nt4 sp4
#define wszREGSP4KEYSETNAME            TEXT("KeySetName")
#define wszREGSP4SUBJECTNAMESEPARATOR  TEXT("SubjectNameSeparator")
#define wszREGSP4NAMES                 TEXT("Names")
#define wszREGSP4QUERIES               TEXT("Queries")
// both nt4 sp4 and nt5 beta 2
#define wszREGNETSCAPECERTTYPE         TEXT("NetscapeCertType")
#define wszNETSCAPEREVOCATIONTYPE      TEXT("Netscape")

// end_certsrv


// CSPs
#define wszBASECSP     MS_STRONG_PROV_W
#define wszENHCSP      TEXT("Microsoft Enhanced Cryptographic Provider v1.0")
#define wszMITVCSP     TEXT("MITV Smart Card Crypto Provider V0.2")
#define wszBBNCSP      TEXT("BBN SafeKeyer Crypto Provider V0.1")
#define wszSLBCSP      TEXT("Schlumberger Cryptographic Service Provider v0.1")
#define wszSLBCSP2     TEXT("Schlumberger Cryptographic Service Provider")
#define wszGEMPLUS     TEXT("Gemplus GemPASS Card CSP v1.0")
#define wszGEMPLUS2    TEXT("Gemplus GemSAFE Card CSP v1.0")
#define wszDDSCSP      TEXT("Microsoft Base DSS Cryptographic Provider")

// Hash Algorithms
#define wszHashMD5     TEXT("MD5")
#define wszHashMD4     TEXT("MD4")
#define wszHashMD2     TEXT("MD2")
#define wszHashSHA1    TEXT("SHA-1")

// begin_certsrv

//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\CSP":
// and "CertSvc\Configuration\<CAName>\EncryptionCSP":
#define wszREGPROVIDERTYPE     TEXT("ProviderType")
#define wszREGPROVIDER         TEXT("Provider")
#define wszHASHALGORITHM       TEXT("HashAlgorithm")
#define wszENCRYPTIONALGORITHM TEXT("EncryptionAlgorithm")
#define wszMACHINEKEYSET       TEXT("MachineKeyset")
#define wszREGKEYSIZE	       TEXT("KeySize")


//======================================================================
// Value strings for "CertSvc\Configuration\<CAName>\SubjectNameSeparator":
#define szNAMESEPARATORDEFAULT   "\n"
#define wszNAMESEPARATORDEFAULT   TEXT(szNAMESEPARATORDEFAULT)


//======================================================================
// Value strings for "CertSvc\Configuration\<CAName>\ValidityPeriod", etc.:
#define wszPERIODYEARS		TEXT("Years")
#define wszPERIODMONTHS		TEXT("Months")
#define wszPERIODWEEKS		TEXT("Weeks")
#define wszPERIODDAYS		TEXT("Days")
#define wszPERIODHOURS		TEXT("Hours")
#define wszPERIODMINUTES	TEXT("Minutes")
#define wszPERIODSECONDS	TEXT("Seconds")

//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\PolicyModules\<ProgId>":
#define wszREGISSUERCERTURLFLAGS    TEXT("IssuerCertURLFlags")
#define wszREGEDITFLAGS		    TEXT("EditFlags")
#define wszREGSUBJECTALTNAME	    TEXT("SubjectAltName")
#define wszREGSUBJECTALTNAME2	    TEXT("SubjectAltName2")
#define wszREGREQUESTDISPOSITION    TEXT("RequestDisposition")
#define wszREGCAPATHLENGTH	    TEXT("CAPathLength")
#define wszREGREVOCATIONTYPE	    TEXT("RevocationType")

#define wszREGLDAPREVOCATIONCRLURL_OLD	TEXT("LDAPRevocationCRLURL")
#define wszREGREVOCATIONCRLURL_OLD	TEXT("RevocationCRLURL")
#define wszREGFTPREVOCATIONCRLURL_OLD	TEXT("FTPRevocationCRLURL")
#define wszREGFILEREVOCATIONCRLURL_OLD	TEXT("FileRevocationCRLURL")

#define wszREGREVOCATIONURL		TEXT("RevocationURL")

#define wszREGLDAPISSUERCERTURL_OLD	TEXT("LDAPIssuerCertURL")
#define wszREGISSUERCERTURL_OLD		TEXT("IssuerCertURL")
#define wszREGFTPISSUERCERTURL_OLD	TEXT("FTPIssuerCertURL")
#define wszREGFILEISSUERCERTURL_OLD	TEXT("FileIssuerCertURL")

#define wszREGENABLEREQUESTEXTENSIONLIST  TEXT("EnableRequestExtensionList")
#define wszREGENABLEENROLLEEREQUESTEXTENSIONLIST  TEXT("EnableEnrolleeRequestExtensionList")
#define wszREGDISABLEEXTENSIONLIST  TEXT("DisableExtensionList")

#define wszREGDEFAULTSMIME		TEXT("DefaultSMIME")

// wszREGCAPATHLENGTH Values:
#define CAPATHLENGTH_INFINITE		0xffffffff

// wszREGREQUESTDISPOSITION Values:
#define REQDISP_PENDING			0x00000000
#define REQDISP_ISSUE			0x00000001
#define REQDISP_DENY			0x00000002
#define REQDISP_USEREQUESTATTRIBUTE	0x00000003
#define REQDISP_MASK			0x000000ff
#define REQDISP_PENDINGFIRST		0x00000100
#define REQDISP_DEFAULT_STANDALONE	(REQDISP_PENDINGFIRST | REQDISP_ISSUE)
#define REQDISP_DEFAULT_ENTERPRISE	(REQDISP_ISSUE)

// wszREGREVOCATIONTYPE Values:
#define REVEXT_CDPLDAPURL_OLD		0x00000001
#define REVEXT_CDPHTTPURL_OLD		0x00000002
#define REVEXT_CDPFTPURL_OLD		0x00000004
#define REVEXT_CDPFILEURL_OLD		0x00000008
#define REVEXT_CDPURLMASK_OLD		0x000000ff
#define REVEXT_CDPENABLE		0x00000100
#define REVEXT_ASPENABLE		0x00000200

#define REVEXT_DEFAULT_NODS		(REVEXT_CDPENABLE)
#define REVEXT_DEFAULT_DS		(REVEXT_CDPENABLE)

// wszREGISSUERCERTURLFLAGS Values:
#define ISSCERT_LDAPURL_OLD		0x00000001
#define ISSCERT_HTTPURL_OLD		0x00000002
#define ISSCERT_FTPURL_OLD		0x00000004
#define ISSCERT_FILEURL_OLD		0x00000008
#define ISSCERT_URLMASK_OLD		0x000000ff
#define ISSCERT_ENABLE			0x00000100

#define ISSCERT_DEFAULT_NODS		(ISSCERT_ENABLE)
#define ISSCERT_DEFAULT_DS		(ISSCERT_ENABLE)

// wszREGEDITFLAGS Values:				   Defaults:
// Under CA key: wszREGCRLEDITFLAGS Values (EDITF_ENABLEAKI* only):
#define EDITF_ENABLEREQUESTEXTENSIONS	0x00000001	// neither
#define EDITF_REQUESTEXTENSIONLIST	0x00000002	// both
#define EDITF_DISABLEEXTENSIONLIST	0x00000004	// both
#define EDITF_ADDOLDKEYUSAGE		0x00000008	// both
#define EDITF_ADDOLDCERTTYPE		0x00000010	// neither
#define EDITF_ATTRIBUTEENDDATE		0x00000020	// Standalone
#define EDITF_BASICCONSTRAINTSCRITICAL	0x00000040	// both
#define EDITF_BASICCONSTRAINTSCA	0x00000080	// Standalone
#define EDITF_ENABLEAKIKEYID		0x00000100	// both
#define EDITF_ATTRIBUTECA		0x00000200	// Standalone
#define EDITF_IGNOREREQUESTERGROUP      0x00000400	// neither
#define EDITF_ENABLEAKIISSUERNAME	0x00000800	// neither
#define EDITF_ENABLEAKIISSUERSERIAL	0x00001000	// neither
#define EDITF_ENABLEAKICRITICAL		0x00002000	// neither
#define EDITF_SERVERUPGRADED		0x00004000	// neither
#define EDITF_ATTRIBUTEEKU		0x00008000	// Standalone
#define EDITF_ENABLEDEFAULTSMIME	0x00010000	// Enterprise
#define EDITF_EMAILOPTIONAL		0x00020000	// neither
#define EDITF_ATTRIBUTESUBJECTALTNAME2	0x00040000	// neither
#define EDITF_ENABLELDAPREFERRALS	0x00080000	// neither
#define EDITF_ENABLECHASECLIENTDC	0x00100000	// Enterprise

#define EDITF_DEFAULT_STANDALONE	(EDITF_REQUESTEXTENSIONLIST | \
					 EDITF_DISABLEEXTENSIONLIST | \
					 EDITF_ADDOLDKEYUSAGE | \
					 EDITF_ATTRIBUTEENDDATE | \
					 EDITF_BASICCONSTRAINTSCRITICAL | \
					 EDITF_BASICCONSTRAINTSCA | \
					 EDITF_ENABLEAKIKEYID | \
					 EDITF_ATTRIBUTECA | \
					 EDITF_ATTRIBUTEEKU)

#define EDITF_DEFAULT_ENTERPRISE	(EDITF_REQUESTEXTENSIONLIST | \
					 EDITF_DISABLEEXTENSIONLIST | \
					 EDITF_ADDOLDKEYUSAGE | \
                                         EDITF_BASICCONSTRAINTSCRITICAL | \
                                         EDITF_ENABLEAKIKEYID | \
					 EDITF_ENABLEDEFAULTSMIME | \
					 EDITF_ENABLECHASECLIENTDC)


//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\ExitModules\<ProgId>":

// LDAP based CRL and URL issuance
#define wszREGLDAPREVOCATIONDN_OLD	   TEXT("LDAPRevocationDN")
#define wszREGLDAPREVOCATIONDNTEMPLATE_OLD TEXT("LDAPRevocationDNTemplate")
#define wszCRLPUBLISHRETRYCOUNT    TEXT("CRLPublishRetryCount")
#define wszREGCERTPUBLISHFLAGS     TEXT("PublishCertFlags")

// wszREGCERTPUBLISHFLAGS Values:
#define EXITPUB_FILE			0x00000001
#define EXITPUB_ACTIVEDIRECTORY		0x00000002
#define EXITPUB_REMOVEOLDCERTS		0x00000010

#define EXITPUB_DEFAULT_ENTERPRISE	EXITPUB_ACTIVEDIRECTORY

#define EXITPUB_DEFAULT_STANDALONE	EXITPUB_FILE

// end_certsrv

//======================================================================
// KeysNotToRestore Registry Key:

#define wszREGKEYKEYSNOTTORESTORE	TEXT("SYSTEM\\CurrentControlSet\\Control\\BackupRestore\\KeysNotToRestore")

// Certificate Authority = REG_MULTI_SZ "CurrentControlSet\Control\Services\CertSvc\Configuration\RestoreInProgress\\0"

#define wszREGRESTORECERTIFICATEAUTHORITY	TEXT("Certificate Authority")

#define wszzREGVALUERESTORECERTIFICATEAUTHORITY	\
					wszREGKEYNOSYSTEMCERTSVCPATH \
					TEXT("\\") \
					wszREGKEYCONFIG \
					TEXT("\\") \
					wszREGKEYRESTOREINPROGRESS \
					TEXT("\\\0")

//======================================================================
// FilesNotToRestore Registry Key:

#define wszREGKEYFILESNOTTOBACKUP	TEXT("SYSTEM\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup")

// Certificate Authority = REG_MULTI_SZ DBFile DBLogDir DBSysDir DBTempDir

//#define wszREGRESTORECERTIFICATEAUTHORITY	TEXT("Certificate Authority")

//======================================================================
// Key Manager Base Registry Key, value name and value string:
#define wszREGKEYKEYRING	TEXT("SOFTWARE\\Microsoft\\KeyRing\\Parameters\\Certificate Authorities\\Microsoft Certificate Server")
#define wszREGCERTGETCONFIG	TEXT("CertGetConfig")
#define wszREGCERTREQUEST	TEXT("CertRequest")

// begin_certsrv

#define wszCLASS_CERTADMIN	  TEXT("CertificateAuthority.Admin")
#define wszCLASS_CERTCONFIG	  TEXT("CertificateAuthority.Config")
#define wszCLASS_CERTGETCONFIG	  TEXT("CertificateAuthority.GetConfig")
#define wszCLASS_CERTENCODE	  TEXT("CertificateAuthority.Encode")
#define wszCLASS_CERTDB		  TEXT("CertificateAuthority.DB") // no_certsrv
#define wszCLASS_CERTDBRESTORE	  TEXT("CertificateAuthority.DBRestore") // no_certsrv
#define wszCLASS_CERTREQUEST	  TEXT("CertificateAuthority.Request")
#define wszCLASS_CERTSERVEREXIT   TEXT("CertificateAuthority.ServerExit")
#define wszCLASS_CERTSERVERPOLICY TEXT("CertificateAuthority.ServerPolicy")
#define wszCLASS_CERTVIEW	  TEXT("CertificateAuthority.View")

// class name templates
#define wszMICROSOFTCERTMODULE_PREFIX  TEXT("CertificateAuthority_MicrosoftDefault") 
#define wszCERTMANAGE_SUFFIX TEXT("Manage")
#define wszCERTEXITMODULE_POSTFIX	TEXT(".Exit")
#define wszCERTMANAGEEXIT_POSTFIX	wszCERTEXITMODULE_POSTFIX wszCERTMANAGE_SUFFIX
#define wszCERTPOLICYMODULE_POSTFIX	TEXT(".Policy")
#define wszCERTMANAGEPOLICY_POSTFIX	wszCERTPOLICYMODULE_POSTFIX wszCERTMANAGE_SUFFIX


// actual policy/exit manage class names
#define wszCLASS_CERTMANAGEEXITMODULE   wszMICROSOFTCERTMODULE_PREFIX wszCERTMANAGEEXIT_POSTFIX 

#define wszCLASS_CERTMANAGEPOLICYMODULE wszMICROSOFTCERTMODULE_PREFIX wszCERTMANAGEPOLICY_POSTFIX 

// actual policy/exit class names
#define wszCLASS_CERTEXIT	wszMICROSOFTCERTMODULE_PREFIX wszCERTEXITMODULE_POSTFIX

#define wszCLASS_CERTPOLICY	wszMICROSOFTCERTMODULE_PREFIX wszCERTPOLICYMODULE_POSTFIX


#define wszCAPOLICYFILE			L"CAPolicy.inf"

#define wszINFSECTION_CDP		L"CRLDistributionPoint"
#define wszINFSECTION_AIA		L"AuthorityInformationAccess"
#define wszINFSECTION_EKU		L"EnhancedKeyUsageExtension"
#define wszINFSECTION_CCDP		L"CrossCertificateDistributionPointsExtension"

#define wszINFSECTION_CERTSERVER	L"certsrv_server"
#define wszINFKEY_RENEWALKEYLENGTH	L"RenewalKeyLength"
#define wszINFKEY_RENEWALVALIDITYPERIODSTRING	L"RenewalValidityPeriod"
#define wszINFKEY_RENEWALVALIDITYPERIODCOUNT	L"RenewalValidityPeriodUnits"
#define wszINFKEY_UTF8			L"UTF8"
#define wszINFKEY_CRLPERIODSTRING	wszREGCRLPERIODSTRING
#define wszINFKEY_CRLPERIODCOUNT	wszREGCRLPERIODCOUNT
#define wszINFKEY_CRLDELTAPERIODSTRING	wszREGCRLDELTAPERIODSTRING
#define wszINFKEY_CRLDELTAPERIODCOUNT	wszREGCRLDELTAPERIODCOUNT
#define wszINFKEY_LOADDEFAULTTEMPLATES  L"LoadDefaultTemplates"
#define wszINFKEY_ENABLEKEYCOUNTING     L"EnableKeyCounting"

#define wszINFKEY_CRITICAL		L"Critical"
#define wszINFKEY_EMPTY			L"Empty"

#define wszINFKEY_CCDPSYNCDELTATIME	L"SyncDeltaTime"

#define wszINFSECTION_CAPOLICY		L"CAPolicy"
#define wszINFSECTION_POLICYSTATEMENT	L"PolicyStatementExtension"
#define wszINFSECTION_APPLICATIONPOLICYSTATEMENT	L"ApplicationPolicyStatementExtension"
#define wszINFKEY_POLICIES		L"Policies"
#define wszINFKEY_OID			L"OID"
#define wszINFKEY_NOTICE		L"Notice"

#define wszINFSECTION_REQUESTATTRIBUTES	L"RequestAttributes"

#define wszINFSECTION_NAMECONSTRAINTS	L"NameConstraintsExtension"
#define wszINFKEY_INCLUDE		L"Include"
#define wszINFKEY_EXCLUDE		L"Exclude"

#define wszINFKEY_UPN			L"UPN"
#define wszINFKEY_EMAIL			L"EMail"
#define wszINFKEY_DNS			L"DNS"
#define wszINFKEY_DIRECTORYNAME		L"DirectoryName"
#define wszINFKEY_URL			L"URL"
#define wszINFKEY_IPADDRESS		L"IPAddress"
#define wszINFKEY_REGISTEREDID		L"RegisteredId"
#define wszINFKEY_OTHERNAME		L"OtherName"

#define wszINFSECTION_POLICYMAPPINGS	L"PolicyMappingsExtension"
#define wszINFSECTION_APPLICATIONPOLICYMAPPINGS	L"ApplicationPolicyMappingsExtension"

#define wszINFSECTION_POLICYCONSTRAINTS	L"PolicyConstraintsExtension"
#define wszINFSECTION_APPLICATIONPOLICYCONSTRAINTS	L"ApplicationPolicyConstraintsExtension"
#define wszINFKEY_REQUIREEXPLICITPOLICY	L"RequireExplicitPolicy"
#define wszINFKEY_INHIBITPOLICYMAPPING	L"InhibitPolicyMapping"

#define wszINFSECTION_BASICCONSTRAINTS	L"BasicConstraintsExtension"
#define wszINFKEY_PATHLENGTH		L"PathLength"

//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\ExitModules\CertificateAuthority_MicrosoftDefault.Exit\SMTP":
//
// exit module mail support
//
#define wszREGEXITSMTPKEY	    	L"SMTP"
#define wszREGEXITSMTPTEMPLATES		L"Templates"
#define wszREGEXITSMTPEVENTFILTER	L"EventFilter"
#define wszREGEXITSMTPSERVER		L"SMTPServer"
#define wszREGEXITSMTPAUTHENTICATE	L"SMTPAuthenticate"

// Subkeys:
#define wszREGEXITDENIEDKEY		L"Denied"
#define wszREGEXITISSUEDKEY		L"Issued"
#define wszREGEXITPENDINGKEY		L"Pending"
#define wszREGEXITREVOKEDKEY		L"Revoked"
#define wszREGEXITCRLISSUEDKEY		L"CRLIssued"
#define wszREGEXITSHUTDOWNKEY		L"Shutdown"
#define wszREGEXITSTARTUPKEY		L"Startup"

//======================================================================
// Values Under 
// "CertSvc\Configuration\<CAName>\ExitModules\CertificateAuthority_MicrosoftDefault.Exit\SMTP\Issued| 
// Pending|Denied|Revoked|CRLIssued|Shutdown":
#define wszREGEXITSMTPFROM		L"From"
#define wszREGEXITSMTPTO		L"To"
#define wszREGEXITSMTPCC		L"Cc"
#define wszREGEXITTITLEFORMAT		L"TitleFormat"
#define wszREGEXITTITLEARG		L"TitleArg"
#define wszREGEXITBODYFORMAT		L"BodyFormat"
#define wszREGEXITBODYARG		L"BodyArg"

#define wszREGEXITPROPNOTFOUND		L"???"

// end_certsrv


// begin CertSrv MMC Snapin
#define wszREGKEYMGMT                 L"Software\\Microsoft\\MMC"
#define wszREGKEYMGMTSNAPIN           wszREGKEYMGMT L"\\SnapIns"
#define wszREGKEYMGMTNODETYPES        wszREGKEYMGMT L"\\NodeTypes"
#define wszSNAPINNAMESTRING           L"NameString"
#define wszSNAPINNAMESTRINGINDIRECT   L"NameStringIndirect"
#define wszSNAPINABOUT                L"About"
#define wszSNAPINSTANDALONE           L"StandAlone"
#define wszSNAPINNODETYPES            L"NodeTypes"
#define wszSNAPINEXTENSIONS           L"Extensions"
#define wszSNAPINNAMESPACE            L"NameSpace"
#define wszSNAPINPROPERTYSHEET        L"PropertySheet"
#define wszSNAPINNAMESTRINGINDIRECT_TEMPLATE     L"@%ws,-%d"	// "@dllname, -<resource id>"

// main snapin uuid
#define wszSNAPINNODETYPE_UUID1               L"{de751566-4cc6-11d1-8ca0-00c04fc297eb}"
#define wszREGKEYMGMTSNAPINUUID1              wszREGKEYMGMTSNAPIN L"\\" wszSNAPINNODETYPE_UUID1
#define wszSNAPINNODETYPE_ABOUT               L"{4653e860-4cc7-11d1-8ca0-00c04fc297eb}"
#define wszREGKEYMGMTSNAPINUUID1_STANDALONE   wszREGKEYMGMTSNAPINUUID1 L"\\" wszSNAPINSTANDALONE
#define wszREGKEYMGMTSNAPINUUID1_NODETYPES    wszREGKEYMGMTSNAPINUUID1 L"\\" wszSNAPINNODETYPES

#define wszSNAPINNODETYPE_1   L"{89b31b94-4cc7-11d1-8ca0-00c04fc297eb}" // cNODETYPEMACHINEINSTANCE
#define wszSNAPINNODETYPE_2   L"{5d972ee4-7576-11d1-8cbe-00c04fc297eb}" // cNODETYPESERVERINSTANCE
#define wszSNAPINNODETYPE_3   L"{5946E36C-757C-11d1-8CBE-00C04FC297EB}" // cNODETYPECRLPUBLICATION
#define wszSNAPINNODETYPE_4   L"{783E4E5F-757C-11d1-8CBE-00C04FC297EB}" // cNODETYPEISSUEDCERTS
#define wszSNAPINNODETYPE_5   L"{783E4E63-757C-11d1-8CBE-00C04FC297EB}" // cNODETYPEPENDINGCERTS
#define wszREGKEYMGMTSNAPINUUID1_NODETYPES_1  wszREGKEYMGMTSNAPINUUID1_NODETYPES L"\\" wszSNAPINNODETYPE_1
#define wszREGKEYMGMTSNAPINUUID1_NODETYPES_2  wszREGKEYMGMTSNAPINUUID1_NODETYPES L"\\" wszSNAPINNODETYPE_2
#define wszREGKEYMGMTSNAPINUUID1_NODETYPES_3  wszREGKEYMGMTSNAPINUUID1_NODETYPES L"\\" wszSNAPINNODETYPE_3
#define wszREGKEYMGMTSNAPINUUID1_NODETYPES_4  wszREGKEYMGMTSNAPINUUID1_NODETYPES L"\\" wszSNAPINNODETYPE_4
#define wszREGKEYMGMTSNAPINUUID1_NODETYPES_5  wszREGKEYMGMTSNAPINUUID1_NODETYPES L"\\" wszSNAPINNODETYPE_5


// register snapin nodetypes
#define wszREGKEYMGMTSNAPIN_NODETYPES_1        wszREGKEYMGMTNODETYPES L"\\" wszSNAPINNODETYPE_1
#define wszREGKEYMGMTSNAPIN_NODETYPES_2        wszREGKEYMGMTNODETYPES L"\\" wszSNAPINNODETYPE_2
#define wszREGKEYMGMTSNAPIN_NODETYPES_3        wszREGKEYMGMTNODETYPES L"\\" wszSNAPINNODETYPE_3
#define wszREGKEYMGMTSNAPIN_NODETYPES_4        wszREGKEYMGMTNODETYPES L"\\" wszSNAPINNODETYPE_4
#define wszREGKEYMGMTSNAPIN_NODETYPES_5        wszREGKEYMGMTNODETYPES L"\\" wszSNAPINNODETYPE_5
#define wszREGCERTSNAPIN_NODETYPES_1          L"CertSvr MMC Machine Instance"
#define wszREGCERTSNAPIN_NODETYPES_2          L"CertSvr MMC Server Instance"
#define wszREGCERTSNAPIN_NODETYPES_3          L"CertSvr MMC CRL Publication"
#define wszREGCERTSNAPIN_NODETYPES_4          L"CertSvr MMC Issued Certificates"
#define wszREGCERTSNAPIN_NODETYPES_5          L"CertSvr MMC Pending Certificates"


// restore through ini file
#define wszRESTORE_FILENAME L"CertsrvRestore"
#define wszRESTORE_SECTION L"Restore"
#define wszRESTORE_NEWLOGSUFFIX L"New"

#endif // __CSREGSTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\csresstr.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csresstr.h
//
// Contents:    Cert Server resource verification support
//
//---------------------------------------------------------------------------


// Build a local resstr.h, include this include file in one compiland, and
// invoke myVerifyResourceStrings() to verify all resources are present.

#if DBG
#define myVerifyResourceStrings(h)	_myVerifyResourceStrings(h)
#else
#define myVerifyResourceStrings(h)	S_OK
#endif


#if DBG
typedef struct _RESSTRING
{
    WCHAR const *pwszSymbol;
    DWORD IdString;
} RESSTRING;

#define RESSTR(id)		{ L#id, id }

RESSTRING g_aResString[] = {
#include "resstr.h"
    { NULL, 0 }
};


//+------------------------------------------------------------------------
//  Function:   _myVerifyResourceStrings
//
//  Synopsis:   Load and verify all resource strings are present
//
//-------------------------------------------------------------------------

HRESULT
_myVerifyResourceStrings(
    HINSTANCE hInstance)
{
    HRESULT hr = S_OK;
    BOOL fDump, fRet;
    int i;
    int cFail;
    CAutoLPWSTR pwszStrBuf;
    WCHAR wszBuf[64];

    fDump = NULL != getenv("CertSrv_DumpStrings");

    cFail = 0;
    for (i = 0; NULL != g_aResString[i].pwszSymbol; i++)
    {
	pwszStrBuf = myLoadResourceStringNoCache(
				    hInstance,
				    g_aResString[i].IdString);
	if (pwszStrBuf == NULL)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _PrintErrorStr(hr, "myLoadResourceStringNoCache", g_aResString[i].pwszSymbol);
	    cFail++;
	}
	if (fDump)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"Resource(%ws: %ws)\n",
		g_aResString[i].pwszSymbol,
		pwszStrBuf != NULL? pwszStrBuf : L"-- MISSING"));
	}
	pwszStrBuf.Cleanup();
    }
    fRet = GetModuleFileName(hInstance, wszBuf, ARRAYSIZE(wszBuf));
    wszBuf[ARRAYSIZE(wszBuf) - 1] = L'\0';
    if (!fRet)
    {
	HRESULT hr2 = myHLastError();

	_PrintError(hr2, "GetModuleFileName");
	wcscpy(wszBuf, L"UNKNOWN MODULE");
    }

    if (0 == cFail)
    {
	if (fDump)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"%ws: Resource strings all present\n",
		wszBuf));
	}
    }
    else
    {
	DBGPRINT((
	    DBG_SS_ERROR,
	    "%ws: %u Resource strings missing\n",
	    wszBuf,
	    cFail));
    }

//error:
    return(hr);
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\cstring.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tfc.h
//
//--------------------------------------------------------------------------

#ifndef _CSTRING_H_
#define _CSTRING_H_


class CString
{
public:
    // empty constructor
    CString(); 
    // copy constructor
    CString(const CString& stringSrc);
	// from an ANSI string (converts to WCHAR)
	CString(LPCSTR lpsz);
	// from a UNICODE string (converts to WCHAR)
	CString(LPCWSTR lpsz);
    
    
    ~CString();

private:	
    // data members
    LPWSTR szData;
    DWORD  dwDataLen;
    
public:
    void Init();
    void Empty(); 
    BOOL IsEmpty() const; 
    LPWSTR GetBuffer(DWORD x=0);

    DWORD GetLength() const; 
    void ReleaseBuffer() {}

    bool IsZeroTerminated()
    {
        if(dwDataLen)
        {
            if(L'\0' == szData[dwDataLen/sizeof(WCHAR)-1])
                return true;
        }
        return false;
    }


    // warning: insertion strings cannot exceed MAX_PATH chars
    void Format(LPCWSTR lpszFormat, ...);

    BSTR AllocSysString() const;

    // resource helpers    
    BOOL LoadString(UINT iRsc);
    BOOL FromWindow(HWND hWnd);
    BOOL ToWindow(HWND hWnd);

    void SetAt(int nIndex, WCHAR ch);

    // operators
    operator LPCWSTR ( ) const 
        { 
            if (szData) 
                return (LPCWSTR)szData; 
            else
                return (LPCWSTR)L"";
        }
    
    // test
    BOOL IsEqual(LPCWSTR sz); 

    // assignmt
    const CString& operator=(const CString& stringSrc) ;
   

    
    // W 
    const CString& operator=(LPCWSTR lpsz);
    const CString& operator=(LPWSTR lpsz);

    // A 
    const CString& operator=(LPCSTR lpsz);
    const CString& operator=(LPSTR lpsz);

    // concat
    const CString& operator+=(LPCWSTR lpsz);
    const CString& operator+=(const CString& string);

    bool operator==(const CString& string) const { return 0==_wcsicmp(*this, string);}
    bool operator!=(const CString& string) const { return !operator==(string); }
    bool operator==(WCHAR const * pcwsz) const { return 0==_wcsicmp(*this, pcwsz);}
    bool operator!=(WCHAR const * pcwsz) const { return !operator==(pcwsz); }

    void Attach(LPWSTR pwszSrc);
    LPWSTR Detach() { LPWSTR pwszRet = szData; Init(); return pwszRet; }
};

#endif // #ifndef _CSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\csw97sht.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       csw97sht.h
//
//--------------------------------------------------------------------------

// csw97sht.h: interface for the CWizard97PropertySheet class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIZ97SHT_H__386C7214_A248_11D1_8618_00C04FB94F17__INCLUDED_)
#define AFX_WIZ97SHT_H__386C7214_A248_11D1_8618_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "tfc.h"
#include "tfcprop.h"

#define NUM_PAGES 10

class CWizard97PropertyPage; // Forward definition

class CWizard97PropertySheet  
{
public:
    void AddPage(CWizard97PropertyPage *pPage);

    CWizard97PropertySheet(
		    HINSTANCE hInstance,
		    UINT nIDCaption,
		    UINT nIDWaterMark,
		    UINT nIDBanner,
		    BOOL fWizard);
    virtual ~CWizard97PropertySheet();

    BOOL DoWizard(HWND hParent);

private:
    CString m_title;

    PROPSHEETHEADER		m_psh;
    HPROPSHEETPAGE		m_pPageArr[NUM_PAGES];
    CWizard97PropertyPage*	m_pPagePtr[NUM_PAGES];
    int				m_nPageCount;
    HWND			m_hWnd;
};

#endif // !defined(AFX_WIZ97SHT_H__386C7214_A248_11D1_8618_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\multisz.h ===
//
// Multi SZ wrapper class
//

#include "cstring.h"
#include "tptrlist.h"


class CMultiSz : public TPtrList<CString>
{
public:
    HRESULT Marshal(void *&rpBuffer, DWORD &cBuffer);
    HRESULT Unmarshal(void *pBuffer);
    bool Find(LPCWSTR pcwszValue, bool fCaseSensitive);
};

typedef TPtrListEnum<CString> CMultiSzEnum;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\csw97ppg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       csw97ppg.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_WIZ97PPG_H__386C7213_A248_11D1_8618_00C04FB94F17__INCLUDED_)
#define AFX_WIZ97PPG_H__386C7213_A248_11D1_8618_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "csw97sht.h"

/////////////////////////////////////////////////////////////////////////////
// CWizard97PropertyPage dialog

#define CSW97PG_IDLARGEFONTNAME	0
#define CSW97PG_IDLARGEFONTSIZE	1
#define CSW97PG_IDSMALLFONTNAME	2
#define CSW97PG_IDSMALLFONTSIZE	3
#define CSW97PG_COUNT		4

class CWizard97PropertyPage : public PropertyPage
{
// Construction
public:
    PROPSHEETPAGE		 m_psp97;
    CString			 m_szHeaderTitle;
    CString			 m_szHeaderSubTitle;
    CWizard97PropertySheet	*m_pWiz;

    void InitWizard97(bool bHideHeader);
    CWizard97PropertyPage();
    CWizard97PropertyPage(
	HINSTANCE hInstance,
	UINT nIDTemplate,
	UINT rgnIDFont[CSW97PG_COUNT]);
    virtual ~CWizard97PropertyPage();

// Dialog Data


// Overrides

// Implementation
protected:
    virtual BOOL OnInitDialog();

    BOOL SetupFonts();
    HFONT GetBigBoldFont();
    HFONT GetBoldFont();

    CFont m_boldFont;
    CFont m_bigBoldFont;
    HINSTANCE m_hInstance;
    UINT m_rgnIDFont[CSW97PG_COUNT];
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZ97PPG_H__386C7213_A248_11D1_8618_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\polreg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       polreg.h
//
//  Contents:   NT Enterprise CA Policy registry locations
//
//--------------------------------------------------------------------------

#ifndef _POLREG_H_
#define _POLREG_H_

/*
 *[HKEY_LOCAL_MACHINE]
 *   [Software]
 *       [Microsoft]
 *           [Cryptography]
 *              [CertificateTemplates]
 *                  [<CertType>] (Name)
 *
 *                       DisplayName:   REG_SZ:     - Display name of this cert type
 *                       SupportedCSPs: REG_MULTI_SZ - Supported CSP's
 *                       KeyUsage:      REG_BINARY: - KeyUsage bitfield
 *                       ExtKeyUsageSyntax: REG_SZ: - ExtKeyUsage OID's (comma separated)
 *                       BasicContraintsCA:REG_DWORD: - CA flag
 *                       BasicConstraintsLen:REG_DWORD: - Path Len
 *                       Flags:REG_DWORD:  - Flags
 *                       KeySpec:REG_DWORD:  - Key Spec
 */

// Policy root
// Cert Types
#define wszCERTTYPECACHE        TEXT("SOFTWARE\\Microsoft\\Cryptography\\CertificateTemplateCache")


// Values under each cert type
#define wszSECURITY         TEXT("Security")
#define wszDISPNAME         TEXT("DisplayName")
#define wszCSPLIST          TEXT("SupportedCSPs")
#define wszKEYUSAGE         TEXT("KeyUsage")
#define wszEXTKEYUSAGE      TEXT("ExtKeyUsageSyntax")
#define wszBASICCONSTCA     TEXT("IsCA")
#define wszBASICCONSTLEN    TEXT("PathLen")
#define wszCTFLAGS          TEXT("Flags")
#define wszCTREVISION       TEXT("Revision")
#define wszCTKEYSPEC        TEXT("KeySpec")

#define wszCRITICALEXTENSIONS TEXT("CriticalExtensions")
#define wszEXPIRATION      TEXT("ValidityPeriod")
#define wszOVERLAP         TEXT("RenewalOverlap")
/* Key Names */

#define wszTIMESTAMP     TEXT("Timestamp")

#define wszTIMESTAMP_AFTER     TEXT("TimestampAfter")


#endif // _POLREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\initcert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       initcert.h
//
//--------------------------------------------------------------------------

#ifndef __INITCERT_H__
#define __INITCERT_H__


typedef enum {
    CS_UPGRADE_UNKNOWN = 0,
    CS_UPGRADE_NO,        // install

    //CS_UPGRADE_NT4SP4 =2,    // upgrade from NT4 certsrv v10 or SP4 with certsrv   // upg unsupported
    //CS_UPGRADE_NT5BETA2 =3,  // upgrade from NT5 Beta 2                            // upg unsupported
    //CS_UPGRADE_NT5BETA3 =4,  // upgrade from NT5 Beta 3                            // upg unsupported

    CS_UPGRADE_WIN2000 =5,     // upgrade from Win2K
    CS_UPGRADE_UNSUPPORTED,    // upgrade is not supported
    CS_UPGRADE_WHISTLER,       // upgrade from build to build

} CS_ENUM_UPGRADE;

typedef enum {
    ENUM_WIZ_UNKNOWN = 0,
    ENUM_WIZ_OCM,
    ENUM_WIZ_CATYPE,
    ENUM_WIZ_ADVANCE,
    ENUM_WIZ_IDINFO,
    ENUM_WIZ_KEYGEN,
    ENUM_WIZ_STORE,
    ENUM_WIZ_REQUEST,
} ENUM_WIZPAGE;

typedef struct csp_hash_tag
{
    ALG_ID               idAlg;
    WCHAR               *pwszName;
    struct csp_hash_tag *next;
    struct csp_hash_tag *last;
} CSP_HASH;

typedef struct csp_info_tag {
    DWORD                dwProvType;
    WCHAR               *pwszProvName;
    BOOL                 fMachineKeyset;
    struct csp_info_tag *next;
    struct csp_info_tag *last;
    CSP_HASH            *pHashList;
} CSP_INFO;
    
typedef struct key_list_tag
{
    WCHAR    *pwszName;
    struct key_list_tag    *next;
    struct key_list_tag    *last;
} KEY_LIST;

// reasons why enterprise CA cannot be installed
typedef enum {
    ENUM_ENTERPRISE_UNAVAIL_REASON_AVAILABLE = 0, // enterprise can be installed
    ENUM_ENTERPRISE_UNAVAIL_REASON_DOMAIN_NOT_JOINED, // machine not joined to a domain
    ENUM_ENTERPRISE_UNAVAIL_REASON_DS_UNAVAILABLE, // no DC available
    ENUM_ENTERPRISE_UNAVAIL_REASON_NO_INSTALL_RIGHTS, // current user doesn't have the rights to install
    ENUM_ENTERPRISE_UNAVAIL_REASON_OLD_DS_VERSION, // DS version is too old, needs to be upgraded
} ENUM_ENTERPRISE_UNAVAIL_REASON;

typedef struct tagCAServerSetupInfo
{
    // setup attributes
// 0x0000
    ENUM_CATYPES          CAType;
    WCHAR                *pwszCACommonName;

// 0x0020
    BOOL                  fAdvance;
    CSP_INFO             *pCSPInfo;	// currently selected CSP
    CSP_HASH             *pHashInfo;	// currently selected hash algorithm
    DWORD                 dwKeyLength;
    ENUM_PERIOD           enumValidityPeriod;
    DWORD                 dwValidityPeriodCount;
    BOOL                  fUseDS;

// 0x0040
    WCHAR                *pwszSharedFolder;
    WCHAR                *pwszDBDirectory;
    WCHAR                *pwszLogDirectory;
    BOOL                  fSaveRequestAsFile;
    BOOL                  fCAsExist;
    WCHAR                *pwszRequestFile;
    WCHAR                *pwszParentCAMachine;
    WCHAR                *pwszParentCAName;

// 0x0060
    BOOL                  fPreserveDB;
    BOOL                  fInteractiveService; // allow service to interact
                                               // with the desktop

    // setup intermediate attributes
    ENUM_WIZPAGE          LastWiz;
    WCHAR                *pwszSanitizedName;
    CSP_INFO             *pCSPInfoList;		// list of all available CSPs
    CSP_INFO             *pDefaultCSPInfo;	// obj representing default CSP,
						// not a CSP in pCSPInfoList
    CSP_HASH             *pDefaultHashInfo;	// object representing default
						// hash algorithm, not a hash
						// algorighm in the currently
						// selected CSP
    KEY_LIST             *pKeyList;		// list of key containers for

// 0x0080
    DWORD                 dwKeyLenMin;		// minumum key length for the
						// currently selected CSP

    DWORD                 dwKeyLenMax;		// maximum key length for the
						// currently selected CSP
    WCHAR                *pwszValidityPeriodCount;
    LONG                  lExistingValidity;
    WCHAR                *pwszCACertFile;
    HCERTSTORE            hMyStore;
    CHAR                 *pszAlgId;
    BOOL                  fCertSrvWasRunning;

// 0x00a0
    FILETIME              NotBefore;
    FILETIME              NotAfter;
    DWORD                 dwRevocationFlags;

    // setup intermediate attributes for unattended

    WCHAR                *pwszCAType;
    WCHAR                *pwszValidityPeriodString;
    WCHAR                *pwszHashAlgorithm;

// 0x00c0
    WCHAR                *pwszKeyLength;
    BOOL                  fValidatedHashAndKey;
    WCHAR                *pwszUseExistingCert;
    WCHAR                *pwszPreserveDB;
    WCHAR                *pwszPFXFile;
    WCHAR                *pwszPFXPassword;
    WCHAR                *pwszInteractiveService;

    // upgrade attributes
    DWORD                 dwUpgradeEditFlags;
// 0x00e0
    BOOL                  fSavedCAInDS;
    BOOL                  fCreatedShare;
    WCHAR                *pwszCustomPolicy;
    WCHAR                *pwszzCustomExit;

    // * The following 2 variables replace these 5 variables:
    //   fCreatedKey,
    //   pwszRevertKey,
    //   pwszImportKey,
    //   pwszExistingKey,
    //   fUseExistingKey
    //
    // * Invariant: fUseExistingKey == (NULL != pwszKeyContainerName)
    //
    // * pwszKeyContainerName should always contains the name of an existing
    //   key container, or be NULL if a new key container needs to be created.
    //   Once the new container is created, the variable holds the name of the
    //   container.
    //
    // * Always use SetKeyContainerName() and ClearKeyContainerName() to modify
    //   these variables. This makes sure that pwszDesanitizedKeyContainerName
    //   is always in sync.

    WCHAR                *pwszKeyContainerName;	// exact name of the container
						// used by the CSP

    WCHAR                *pwszDesanitizedKeyContainerName; // name displayed
							   // to the user

    BOOL                  fDeletableNewKey;	// TRUE iff the

						// KeyContainerName points to a
						// key container that we should
						// delete if we don't use.

    BOOL                  fKeyGenFailed;	// TRUE if KeyGen failed

    // * The following 1 variable replace these 4 variables:
    //   fUseExistingCert,
    //   fFoundMatchedCertInStore,
    //   fMatchedCertType,
    //   pSCertContextFromStore
    //
    // * Invariant: fUseExistingCert==(NULL!=pccExistingCert)
    //
    // * pccExistingCert should always be a pointer to an existing cert context,
    //   or be NULL if we are not using an existing cert
    //
    // * Always use SetExistingCertToUse() and ClearExistingCertToUse() to
    //   modify these variables. This makes sure that pccExistingCert is
    //   properly freed.

// 0x0100
    CERT_CONTEXT const   *pccExistingCert;	// an open cert context
    CERT_CONTEXT const   *pccUpgradeCert;	// CA Cert context for upgrade
    DWORD                 dwCertNameId;		// CA Cert NameId
    BOOL                  fUNCPathNotFound; // flag for default shared folder
    WCHAR                *pwszDNSuffix;        // CN=%1, DC=x, DC=y, DC=z -- dynamically generated template
// 0x0114
    WCHAR                *pwszFullCADN;
    ENUM_ENTERPRISE_UNAVAIL_REASON   EnterpriseUnavailReason; // reason why can't install enterprise CA

} CASERVERSETUPINFO;

typedef struct tagCAWebClientSetupInfo
{
    WCHAR                *pwszWebCAMachine;
    WCHAR                *pwszWebCAName;
    WCHAR                *pwszSanitizedWebCAName;
    BOOL                  fUseDS;
    WCHAR                *pwszSharedFolder;
    ENUM_CATYPES          WebCAType;
} CAWEBCLIENTSETUPINFO;

typedef struct tagCASetupInfo
{
    CASERVERSETUPINFO    *pServer;
    CAWEBCLIENTSETUPINFO *pClient;
} CASETUPINFO;

typedef struct _PER_COMPONENT_DATA 
{
    // component generic
    WCHAR    *pwszComponent;	// Component name from OCM
    HINF      MyInfHandle;	// Open inf handle to per-component inf
    DWORDLONG Flags;		// Operation flags from SETUP_DATA structure
    OCMANAGER_ROUTINES HelperRoutines;

    // setup related
    HINSTANCE hInstance;
    HRESULT   hrContinue;   // set code if fatal error
    WCHAR    *pwszCustomMessage;
    int       iErrMsg;      // set msg id for fatal error pop up
    BOOL      fShownErr;    // set to TRUE if pop up earlier so avoid double
    BOOL      fUnattended;
    BOOL      fPostBase;
    WCHAR    *pwszUnattendedFile;
    WCHAR    *pwszServerName;
    WCHAR    *pwszServerNameOld;
    WCHAR    *pwszSystem32;
    HINF     hinfCAPolicy;

    // CA related
    DWORD     dwInstallStatus;
    CASETUPINFO  CA;
    CS_ENUM_UPGRADE UpgradeFlag;
    BOOL            fCreatedVRoot;
    DWORD dwVersion;
} PER_COMPONENT_DATA;


//+--------------------------------------------------------------------------
// Prototypes:

HRESULT
csiGetKeyList(
    IN DWORD        dwProvType,
    IN WCHAR const *pwszProvName,
    IN BOOL         fMachineKeySet,
    IN BOOL         fSilent,
    OUT KEY_LIST  **ppKeyList);

VOID
csiFreeKeyList(
    IN OUT KEY_LIST *pKeyList);

HRESULT
csiBuildRequest(
    OPTIONAL IN HINF hInf,
    OPTIONAL IN CERT_CONTEXT const *pccPrevious,
    IN BYTE const *pbSubjectEncoded,
    IN DWORD cbSubjectEncoded,
    IN char const *pszAlgId,
    IN BOOL fNewKey,
    IN DWORD iCert,
    IN DWORD iKey,
    IN HCRYPTPROV hProv,
    IN HWND hwnd,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    OUT BYTE **ppbEncode,
    OUT DWORD *pcbEncode);

HRESULT
csiBuildFileName(
    IN WCHAR const *pwszDirPath,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszExt,
    IN DWORD iCert,
    OUT WCHAR **ppszOut,
    HINSTANCE hInstance,
    BOOL fUnattended,
    IN HWND hwnd);

HRESULT
csiBuildCACertFileName(
    IN HINSTANCE hInstance,
    IN HWND hwnd,
    IN BOOL fUnattended,
    OPTIONAL IN WCHAR const *pwszSharedFolder,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszExt,
    IN DWORD iCert,
    OUT WCHAR **ppwszCACertFile);

HRESULT
csiGetCARequestFileName(
    IN HINSTANCE hInstance,
    IN HWND hwnd,
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD iCertNew,
    IN DWORD iKey,
    OUT WCHAR **ppwszRequestFile);

BOOL
csiWriteDERToFile(
    IN WCHAR const *pwszFileName,
    IN BYTE const *pbDER,
    IN DWORD cbDER,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd);

HRESULT
csiBuildAndWriteCert(
    IN HCRYPTPROV hCryptProv,
    IN CASERVERSETUPINFO const *pServer,
    OPTIONAL IN WCHAR const *pwszFile,
    IN WCHAR const *pwszEnrollFile,
    OPTIONAL IN CERT_CONTEXT const *pCertContextFromStore,
    OPTIONAL OUT CERT_CONTEXT const **ppCertContextOut,
    IN WCHAR const *pwszCAType,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd);

VOID
csiFreeCertNameInfo(
    IN OUT CERT_NAME_INFO *pNameInfo);

HRESULT
csiGetCRLPublicationURLTemplates(
    IN BOOL fUseDS,
    IN WCHAR const *pwszSystem32,
    OUT WCHAR **ppwszz);

HRESULT
csiGetCACertPublicationURLTemplates(
    IN BOOL fUseDS,
    IN WCHAR const *pwszSystem32,
    OUT WCHAR **ppwszz);

HRESULT
csiSetupCAInDS(
    IN WCHAR const        *pwszCAServer,
    IN WCHAR const        *pwszSanitizedCAName,
    IN WCHAR const        *pwszCADisplayName,
    IN BOOL                fLoadDefaultTemplates,
    IN ENUM_CATYPES        caType,
    IN DWORD               iCert,
    IN DWORD               iCRL,
    IN BOOL                fRenew,
    IN CERT_CONTEXT const *pCert);

HRESULT
csiFillKeyProvInfo(
    IN WCHAR const          *pwszContainerName,
    IN WCHAR const          *pwszProvName,
    IN DWORD		     dwProvType,
    IN BOOL  const           fMachineKeyset,
    OUT CRYPT_KEY_PROV_INFO *pKeyProvInfo);

VOID
csiFreeKeyProvInfo(
    IN OUT CRYPT_KEY_PROV_INFO *pKeyProvInfo);

BOOL
csiIsAnyDSCAAvailable(VOID);

HRESULT
csiSubmitCARequest(
    IN HINSTANCE     hInstance,
    IN BOOL          fUnattended,
    IN HWND          hwnd,
    IN BOOL          fRenew,
    IN DWORD	     iCert,
    IN BOOL          fRetrievePending,
    IN WCHAR const  *pwszSanitizedCAName,
    IN WCHAR const  *pwszParentCAMachine,
    IN WCHAR const  *pwszParentCAName,
    IN BYTE const   *pbRequest,
    IN DWORD         cbRequest,
    OUT BSTR        *pbStrChain);

HRESULT
csiFinishInstallationFromPKCS7(
    IN HINSTANCE     hInstance,
    IN BOOL          fUnattended,
    IN HWND          hwnd,
    IN WCHAR const  *pwszSanitizedCAName,
    IN WCHAR const  *pwszCACommonName,
    IN CRYPT_KEY_PROV_INFO const *pKeyProvInfo,
    IN ENUM_CATYPES  CAType,
    IN DWORD         iCert,
    IN DWORD         iCRL,
    IN BOOL          fUseDS,
    IN BOOL          fRenew,
    IN WCHAR const  *pwszServerName,
    IN BYTE const   *pbChainOrCert,
    IN DWORD         cbChainOrCert,
    OPTIONAL IN WCHAR const *pwszCACertFile);

HRESULT
csiSaveCertAndKeys(
    IN CERT_CONTEXT const *pCert,
    IN HCERTSTORE hAdditionalStore,
    IN CRYPT_KEY_PROV_INFO const *pkpi,
    IN ENUM_CATYPES CAType);

HRESULT 
csiInitializeCertSrvSecurity(
    IN WCHAR const *pwszSanitizedCAName, 
    IN BOOL         fUseEnterpriseACL,   // which ACL to use
    IN BOOL         fSetDsSecurity);     // whether to set DS security

HRESULT
csiGenerateCAKeys(
    IN WCHAR const *pwszContainer,
    IN WCHAR const *pwszProvName,
    IN DWORD        dwProvType,
    IN BOOL         fMachineKeyset,
    IN DWORD        dwKeyLength,
    IN HINSTANCE    hInstance,
    IN BOOL         fUnattended,
    IN BOOL         fEnableKeyCounting,
    IN HWND         hwnd,
    OUT BOOL       *pfKeyGenFailed);

HRESULT
csiGenerateKeysOnly(
    IN  WCHAR const *pwszContainer,
    IN  WCHAR const *pwszProvName,
    IN  DWORD 	     dwProvType,
    IN  BOOL  	     fMachineKeyset,
    IN  DWORD 	     dwKeyLength,
    IN  BOOL  	     fUnattended,
    IN  BOOL         fEnableKeyCounting,
    OUT HCRYPTPROV  *phProv,
    OUT int         *piMsg);

HRESULT
csiSetKeyContainerSecurity(
    IN HCRYPTPROV hProv);

HRESULT
csiSetAdminOnlyFolderSecurity(
    IN LPCWSTR    szFolderPath,
    IN BOOL       fAllowEveryoneRead,
    IN BOOL       fUseDS);

VOID
csiLogOpen(
    IN char const *pszFile);

VOID
csiLogClose();

VOID
csiLog(
    IN DWORD dwFile,
    IN DWORD dwLine,
    IN HRESULT hrMsg,
    IN UINT idMsg,
    OPTIONAL IN WCHAR const *pwsz1,
    OPTIONAL IN WCHAR const *pwsz2,
    OPTIONAL IN DWORD const *pdw);

VOID
csiLogFileVersion(
    IN DWORD dwFile,
    IN DWORD dwLine,
    IN UINT idMsg,
    IN WCHAR const *pwszFile,
    IN char const *pszVersion);

VOID
csiLogTime(
    IN DWORD dwFile,
    IN DWORD dwLine,
    IN UINT idMsg);

VOID
csiLogDWord(
    IN DWORD dwFile,
    IN DWORD dwLine,
    IN UINT idMsg,
    IN DWORD dwVal);

VOID
csiLogInfError(
    IN HINF hInf,
    IN HRESULT hr);

HRESULT
csiGetProviderTypeFromProviderName(
    IN WCHAR const *pwszName,
    OUT DWORD      *pdwType);

HRESULT
csiUpgradeCertSrvSecurity(
    IN WCHAR const *pwszSanitizedCAName, 
    BOOL            fUseEnterpriseACL, // which ACL to use
    BOOL            fSetDsSecurity,    // whether to set security on DS object
    CS_ENUM_UPGRADE UpgradeType);

HRESULT
csiGetCRLPublicationParams(
    BOOL fBaseCRL,
    WCHAR **ppwszCRLPeriodString,
    DWORD *pdwCRLPeriodCount);

HRESULT AddCNAndEncode(
    LPCWSTR pcwszName,
    LPCWSTR pcwszDNSuffix,
    BYTE** ppbEncodedDN,
    DWORD *pcbEncodedDN);


HRESULT
AddCAMachineToCertPublishers(VOID);
                   
HRESULT 
RemoveCAMachineFromCertPublishers(VOID);

HRESULT
AddCAMachineToPreWin2kGroup(VOID);
                   
HRESULT 
RemoveCAMachineFromPreWin2kGroup(VOID);

#define CSILOG(hr, idMsg, pwsz1, pwsz2, pdw) \
    csiLog(__dwFILE__, __LINE__, (hr), (idMsg), (pwsz1), (pwsz2), (pdw))

#define CSILOGFILEVERSION(idMsg, pwszFile, pszVersion) \
    csiLogFileVersion(__dwFILE__, __LINE__, (idMsg), (pwszFile), (pszVersion))

#define CSILOGTIME(idMsg) \
    csiLogTime(__dwFILE__, __LINE__, (idMsg))

#define CSILOGDWORD(idMsg, dw) \
    csiLogDWord(__dwFILE__, __LINE__, (idMsg), (dw))

#endif //__INITCERT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\rwlock.h ===
#ifndef __CRWLOCK_HPP__
#define __CRWLOCK_HPP__

namespace CertSrv
{

// Wrapper class for NTRTL's single writer multiple reader
//
// !!! NTRTL can throw exceptions. Make sure you code handles them correctly.

class CReadWriteLock
{
public:
    CReadWriteLock();
    ~CReadWriteLock();

    void GetExclusive(); // get write lock
    void GetShared(); // get read lock
    void Release();

private:
    RTL_RESOURCE m_RtlLock;

};// end CReadWriteLock 
} // end namespace Certsrv
#endif // __CRWLOCK_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\setupids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       setupids.h
//
//--------------------------------------------------------------------------

#ifndef __SETUPIDS_H__
#define __SETUPIDS_H__

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by initlib.lib, shared by certocm.dll, certmmc.dll and certutil.exe
// Shared range: 200-299

#define IDS_CAHIER_CERTFILE_FILTER			211
#define IDS_CAHIER_INSTALL_TITLE			212
#define IDS_ILOG_MISSING_PROVIDER          		213
#define IDS_ERR_INCOMPLETECHAIN				214
#define IDS_ERR_INVALIDCHAIN				215
#define IDS_ERR_RETRIEVE_PENDING			216
#define IDS_ILOG_GETCANAME				217
#define IDS_ILOG_SELECTCA				218

#define IDS_ILOG_SAVECERTANDKEYS			230
#define IDS_ILOG_RETRIEVECERT				231
#define IDS_ILOG_FINISHSUSPENDEDSETUP			232
#define IDS_ERR_NOTCACERT		             	233
#define IDS_ILOG_SETUPCOMPLETE				234
#define IDS_ILOG_RETRIEVEPENDING			235
#define IDS_ILOG_KEYINDEX				236
#define IDS_ILOG_LOADOLDCERT				237
#define IDS_ILOG_CLONECERT				238
#define IDS_ILOG_BUILDREQUEST				239
#define IDS_ILOG_RENEWOLDKEY				240
#define IDS_ILOG_INSTALLCERT				241
#define IDS_ILOG_RENEWNEWKEY				242
#define IDS_ILOG_BUILDCERT				243
#define IDS_ILOG_SAVECHAINANDKEYS			244
#define IDS_REQUEST_HELPTEXT				245
#define IDS_ILOG_CREATECDP				246
#define IDS_ILOG_CREATENTAUTHTRUST			247
#define IDS_ILOG_CREATEROOTTRUST			248
#define IDS_ILOG_PUBLISHCA				249
#define IDS_ILOG_SUBMITREQUEST				250
#define IDS_ERR_BADCSP                                  251
#define IDS_ERR_BAD_CA_CERT_7F                          252
#define IDS_ERR_RENEWEDCERTCAVERSION			253
#define IDS_ERR_UNTRUSTEDROOT				254
#define IDS_ERR_CERTADDCERTIFICATECONTEXTTOSTORE	255
#define IDS_ERR_CERTCREATECERTIFICATECONTEXT            256
#define IDS_ILOG_UNREFERENCEDINFSECTIONS		257
#define IDS_ILOG_SETSECURITY				258
#define IDS_ERR_CREATEFILE                              259
#define IDS_ERR_DELETEKEY                               260
#define IDS_ERR_ENCODEKEYATTR                           261
#define IDS_ERR_ENCODETOBESIGNED                        262
#define IDS_ERR_ENV_NOT_SET                             263
#define IDS_ERR_FULL_TOKEN                              264
#define IDS_ERR_GENKEYFAIL                              265
#define IDS_ERR_GETCOMPUTERNAME                         266
#define IDS_ERR_KEYSECURITY                             267
#define IDS_ERR_MYDECODENAME                            268
#define IDS_ERR_NOT_ENTERPRISE_USER                     269
#define IDS_ERR_NOT_MATCH_COMMONNAME                    270
#define IDS_ILOG_GENERATEKEYS				271
#define IDS_ERR_REPEATWIZPREFIX                         272
#define IDS_ERR_REQUEST_DENIED                          273
#define IDS_ERR_REQUEST_ERROR                           274
#define IDS_ERR_REQUEST_INCOMPLETE                      275
#define IDS_ERR_REQUEST_OUTOFBAND                       276
#define IDS_ERR_REQUEST_PENDING                         277
#define IDS_ERR_REQUEST_REVOKED                         278
#define IDS_ERR_SETKEYPROVIDER                          279
#define IDS_ERR_SUBMIT_REQUEST                          280
#define IDS_ERR_SUBMIT_REQUEST_FAIL                     281
#define IDS_ERR_NOT_MATCH_BINARYNAME                    282
#define IDS_ERR_NOT_MATCH_KEY                           283
#define IDS_CAHIER_INSTALL_MISIINGCERT_TITLE		284
#define IDS_ERR_WRITEDERTOFILE                          285
#define IDS_ERR_WRITEFILE                               286
#define IDS_ILOG_INFERROR				287
#define IDS_ILOG_SETKEYSECURITY				288
#define IDS_MSG_PARENTCA_CONFIG                         289
#define IDS_MSG_REQUEST_ID                              290
#define IDS_MSG_TITLE                                   291
#define IDS_ILOG_SETADMINONLYFOLDERSECURITY             292
//#define IDS_UNUSED					293
//#define IDS_UNUSED					294
//#define IDS_UNUSED					295
//#define IDS_UNUSED					296
//#define IDS_UNUSED					297
//#define IDS_UNUSED					298
#define IDS_ERR_NO_KEY_ACCESS               		299
// **NOTE** hit high end of the limited range

#define IDC_STATIC					(-1)

// dialogs
#define IDD_COMPLETE_DIALOG				4000
#define IDC_PARENT_COMPUTER_NAME			4001
#define IDC_PARENT_CA_NAME				4002
#define IDC_BROWSE_CA					4003
#define IDC_REQUEST_HELPTEXT			4004

#define IDS_CA_PICKER_TITLE				4050
#define IDS_CA_PICKER_PROMPT				4051

#endif // __SETUPIDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\progress.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       progress.h
//
//--------------------------------------------------------------------------


// progress bar on MMC window
HANDLE
StartProgressDlg(
    HINSTANCE hInstance,
    HWND      hwndParent,
    DWORD     dwTickerSeconds,
    DWORD     dwTimeoutSeconds,
    UINT      iRscJobDescription);

BOOL FProgressDlgRunning();
void EndProgressDlg(HANDLE hThread);


HANDLE
StartPercentCompleteDlg(
    HINSTANCE  hInstance,
    HWND       hwndParent,
    UINT       iRscJobDescription,
    DBBACKUPPROGRESS *pdbp);

void EndPercentCompleteDlg(HANDLE hProgressThread);



inline 
HANDLE StartProgressDlg(HINSTANCE hInstance, HWND hwndParent, DWORD dwTickerSeconds, DWORD dwTimeoutSeconds)
{ return StartProgressDlg(hInstance, hwndParent, dwTickerSeconds, dwTimeoutSeconds, 0);  }

inline 
HANDLE
StartPercentCompleteDlg(
    HINSTANCE  hInstance,
    HWND       hwndParent,
    DBBACKUPPROGRESS *pdbp)
{ return StartPercentCompleteDlg(hInstance, hwndParent, 0, pdbp); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\resstr0.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\sid.h ===
//+--------------------------------------------------------------------------
// File:        sid.h
// Contents:    class incapsulating a SID
//---------------------------------------------------------------------------
#ifndef __CERTSRV_CSID__
#define __CERTSRV_CSID__

#include <sddl.h>

namespace CertSrv 
{
class CSid
{
public:
    CSid() {Init();}
    CSid(PSID pSid)    {Init(); CopySid(pSid);}
    CSid(const CSid &copySid) {Init(); CopySid(copySid.m_pSid);}
    CSid(LPCWSTR pcwszSid) {Init(); CopySid(pcwszSid);}
    ~CSid()
    {
        if(m_pSid) 
            LocalFree(m_pSid);
        if(m_pwszSid) 
            LocalFree(m_pwszSid);
        if(m_pwszName) 
            LocalFree(m_pwszName);
    }
    operator LPCWSTR()
    {
        return GetStringSid();
    }
    operator PSID() {return m_pSid;}

    LPCWSTR GetName()
    {
        // attemp to map sid to name only once
        if(m_fCantResolveName ||
           S_OK!=MapSidToName())
        {   
            m_fCantResolveName = TRUE;
            return GetStringSid();
        }
        return m_pwszName;
    }

    PSID GetSid() { return m_pSid;}

protected:
    void Init() 
    {
        m_pSid = NULL; 
        m_pwszSid = NULL; 
        m_pwszName = NULL;
        m_fCantResolveName = FALSE;
    }
    void SetStringSid()
    {
        if(m_pSid)
            myConvertSidToStringSid(m_pSid, &m_pwszSid);
    }
    LPCWSTR GetStringSid()
    {
        if(!m_pwszSid)
            SetStringSid();
        return m_pwszSid?m_pwszSid:L"";
    }

    void CopySid(PSID pSid)
    {
        ULONG cbSid = GetLengthSid(pSid);
        m_pSid = (BYTE *) LocalAlloc(LMEM_FIXED, cbSid);
        if(m_pSid && !::CopySid(cbSid, m_pSid, pSid))
        {
            LocalFree(m_pSid);
            m_pSid = NULL;
        }
    }

    void CopySid(LPCWSTR pcwszSid)
    {
        if(pcwszSid)
            myConvertStringSidToSid(pcwszSid, &m_pSid);
    }

    HRESULT MapSidToName()
    {
        if(m_pwszName)
            return S_OK;
        WCHAR wszDummyBuffer[2];
        DWORD cchName = 0, cchDomain = 0;
        SID_NAME_USE use;
        LookupAccountSid(
            NULL,
            m_pSid,
            NULL,
            &cchName,
            NULL,
            &cchDomain,
            &use);
        HRESULT hr = myHLastError();
        if(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)!=hr)
        {
            return hr;
        }
        // build the full name "Domain\Name"
        m_pwszName = (LPWSTR) LocalAlloc(
            LMEM_FIXED, 
            sizeof(WCHAR)*(cchName+cchDomain+2));
        if(!m_pwszName)
        {
            return E_OUTOFMEMORY;
        }
        // special case for Everyone, LookupAccountSid returns empty domain name for it
        if(!LookupAccountSid(
                NULL,
                m_pSid,
                m_pwszName+((1==cchDomain)?0:cchDomain), 
                &cchName,
                (1==cchDomain)?wszDummyBuffer:m_pwszName,
                &cchDomain,
                &use))
        {
            LocalFree(m_pwszName);
            m_pwszName = NULL;
            hr = myHLastError();
            return hr;
        }
        if(cchDomain>1)
        {
            m_pwszName[cchDomain] = L'\\';
        }
        return S_OK;
    }

    CSid operator=(const CSid& sid); //protect callers from using it

    PSID m_pSid;
    LPWSTR  m_pwszSid;
    LPWSTR m_pwszName;
    BOOL m_fCantResolveName;
};

};//namespace CertSrv

#endif //__CERTSRV_CSID__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\tfcprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tfcprop.h
//
//--------------------------------------------------------------------------

#ifndef _TFCPROP_H_
#define _TFCPROP_H_

class PropertyPage
{
protected:
    PropertyPage() { ASSERT(0); }  // default, should never be called}
    PropertyPage(UINT uIDD);
    virtual ~PropertyPage();
    
public:
    // dlg notifications
    virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual BOOL UpdateData(BOOL fSuckFromDlg = TRUE);
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);
    virtual void OnDestroy();

    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual void OnOK();
    virtual BOOL OnWizardFinish();
    virtual LRESULT OnWizardNext();
    virtual LRESULT OnWizardBack();

    virtual void OnHelp(LPHELPINFO lpHelp);
    virtual void OnContextHelp(HWND hwnd);


public:
    HWND m_hWnd;
    PROPSHEETPAGE m_psp;

    HWND GetDlgItem(UINT uIDD) { return ::GetDlgItem(m_hWnd, uIDD); }
    HWND GetDlgItem(HWND hWnd, UINT uIDD) { return ::GetDlgItem(hWnd, uIDD); }

    LRESULT SendDlgItemMessage(
        int nIDDlgItem, 
        UINT uMsg,
        WPARAM wParam=0,  
        LPARAM lParam=0)
    {
        return ::SendDlgItemMessage(m_hWnd, nIDDlgItem, uMsg, wParam, lParam);
    }

    void SetModified(BOOL fModified = TRUE) 
    {   
        if (fModified)
            PropSheet_Changed( ::GetParent(m_hWnd), m_hWnd); 
        else
            PropSheet_UnChanged( ::GetParent(m_hWnd), m_hWnd); 
    }

    HWND GetParent() { return ::GetParent(m_hWnd); }

    void HideControls();

};


INT_PTR CALLBACK
    dlgProcPropPage(
      HWND hwndDlg,  
      UINT uMsg,     
      WPARAM wParam, 
      LPARAM lParam  );

#endif //_TFCPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\tfc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tfc.h
//
//--------------------------------------------------------------------------

#ifndef _TFC_H_
#define _TFC_H_

/////////////////////////////////////////////////////////////////////////////
// Diagnostic support

#define  AFX_MANAGE_STATE(__XX__) ((void)0)
#define AfxGetInstanceHandle() g_hInstance
#define AfxGetResourceHandle() g_hInstance

#define afx_msg
#define DECLARE_MESSAGE_MAP()
#define DECLARE_DYNCREATE(__XX__) 



#ifndef ASSERT

#ifdef _DEBUG
BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine); 
#define ASSERT(f) \
	do \
	{ \
	if (!(f) && AssertFailedLine(__FILE__, __LINE__)) \
		DebugBreak(); \
	} while (0)
#else // _DEBUG
#define ASSERT(f)          ((void)0)
#endif // _DEBUG

#endif // ASSERT


#ifdef _DEBUG
#define VERIFY(f)          ASSERT(f)
#else   // _DEBUG
#define VERIFY(f)          ((void)(f))
#endif // !_DEBUG


class CBitmap
{
private:
    HBITMAP m_hBmp;

public:
    CBitmap();
    ~CBitmap();
    
    HBITMAP LoadBitmap(UINT iRsc);

    // operators
    operator HBITMAP ( ) const { return m_hBmp; }
};


typedef struct _ELT_PTR
{
    _ELT_PTR* pNext;

    // other data
    void* pData;
} ELT_PTR, *PELT_PTR;


struct __POSITION { };
typedef __POSITION* POSITION;

template<class TYPE, class ARG_TYPE>
class CList
{
private:
    PELT_PTR m_pHead;

public:
    CList() {m_pHead = NULL;}
    ~CList() { Init();}
    
    void Init() 
    {
        RemoveAll();
        m_pHead = NULL;
    }
    
    TYPE  GetHead() { return (TYPE) m_pHead->pData; }
    TYPE  GetNext(POSITION& pos)
    { 
        POSITION poslast = pos;
        pos = (POSITION)((PELT_PTR)pos)->pNext; 
        return (TYPE) ( ((PELT_PTR)poslast)->pData); 
    }

    TYPE GetAt(POSITION pos) 
    { 
        return (TYPE)((PELT_PTR)pos)->pData;
    }


    POSITION GetHeadPosition() { return (POSITION)m_pHead; }
    POSITION GetTailPosition()
    {
        PELT_PTR p = m_pHead;
        PELT_PTR pPrev = NULL;
        while(p)
        {
            pPrev = p;
            p = p->pNext;
        }
        return (POSITION)pPrev;
    }
    POSITION AddHead(ARG_TYPE typeNewElt)
    {
        PELT_PTR p = (PELT_PTR)LocalAlloc(LMEM_FIXED, sizeof(ELT_PTR));
        if (p)
        {
            p->pData = (void*)typeNewElt;
            p->pNext = m_pHead;
            m_pHead = p;
        }
        return (POSITION)p;
    }

    POSITION AddTail(ARG_TYPE typeNewElt)
    {
        PELT_PTR ptail = (PELT_PTR)GetTailPosition();
        PELT_PTR p = (PELT_PTR)LocalAlloc(LMEM_FIXED, sizeof(ELT_PTR));
        if (p)
        {
            p->pData = (void*)typeNewElt; 
            p->pNext = NULL;
        }
        
        if (ptail)
        {
            ptail->pNext = p;
        }
        else
        {
            m_pHead = p;
        }

        return (POSITION)p;
    }

    void RemoveAt(POSITION pos)
    {
        PELT_PTR p = m_pHead;
        PELT_PTR pPrev = NULL;
        while (p && (p != (PELT_PTR)pos))
        {
            pPrev = p;                  // keep tabs on prev elt
            p = p->pNext;               // inc cur elt
        }

        if (p) // found
        {
            if (pPrev)
            {
                pPrev->pNext = p->pNext;    // pull out of list
            }
            else
            {
                m_pHead = p->pNext;         // pull out of head of list
            }

            LocalFree(p);               // free it
        }
    }

    void RemoveAll()
    {
        PELT_PTR p;
        while (m_pHead)
        {
            p = m_pHead;
            m_pHead = m_pHead->pNext;
            LocalFree(p);
        }
        ASSERT(m_pHead == NULL);
    }

};

template<class TYPE, class ARG_TYPE>
class CArray
{
private:
    TYPE* rgtypeArray;
    int iArraySize;

public:
    CArray() {iArraySize = 0; rgtypeArray=NULL;}
    ~CArray() { Init(); }

    void Init() 
    {
        if (rgtypeArray) 
        { 
            LocalFree(rgtypeArray); 
            rgtypeArray = NULL; 
            iArraySize = 0; 
        } 
    }

    // operators
    TYPE operator [](int i) { return GetAt(i); }


    int GetSize() { return iArraySize; }
    int GetUpperBound() { return iArraySize -1; }
    TYPE GetAt(int i) 
    { 
        ASSERT (i < iArraySize);
        return rgtypeArray[i];
    }

    int Add(ARG_TYPE arg)
    {
        TYPE* p;
        if (rgtypeArray)
            p = (TYPE*)LocalReAlloc(rgtypeArray, (iArraySize+1) * sizeof(TYPE), LMEM_MOVEABLE);
        else
            p = (TYPE*)LocalAlloc(LMEM_FIXED, sizeof(TYPE));
        if (p == NULL)
            return -1;

        rgtypeArray = p;
        rgtypeArray[iArraySize] = arg;
        iArraySize++;
        
        return iArraySize-1;
    }

    void RemoveAt(int idx, int nCount = 1)
    {
        // make sure idx is in our range AND
        // we're not asked to remove elts past end of our array
        ASSERT(GetUpperBound() >= idx);

        // IF idx is within bounds
        if (GetUpperBound() >= idx)
        {
            // truncate if we hit the end
            if (GetSize() < (idx + nCount))
                nCount = GetSize() - idx;

            MoveMemory(&rgtypeArray[idx], &rgtypeArray[idx+nCount], ((GetSize() - idx) - nCount)*sizeof(TYPE));
            iArraySize -= nCount;        
        }
    }

    const TYPE* GetData() { return rgtypeArray; }
};


class CComboBox
{
private:
    HWND m_hWnd;

public:
    CComboBox() { m_hWnd = NULL; }
    ~CComboBox() {}

    void Init(HWND hWnd); 

    void ResetContent()    ; 
    int SetItemData(int idx, DWORD dwData) ; 
    DWORD GetItemData(int idx)  ; 
    int AddString(LPWSTR sz)    ; 
    int AddString(LPCWSTR sz)   ; 
    int GetCurSel()             ; 
    int SetCurSel(int iSel)     ; 
    int SelectString(int nAfter, LPCWSTR szItem) ; 
};


class CFont
{
private:
    HFONT m_hFont;

public:
    CFont() {m_hFont = NULL;}
    ~CFont() {if (m_hFont)  DeleteObject(m_hFont);}

    operator HFONT () const { ASSERT(m_hFont); return m_hFont; }

    BOOL CreateFontIndirect(const LOGFONT* pFont) 
    { 
        if (m_hFont) 
            DeleteObject(m_hFont); 
        m_hFont = ::CreateFontIndirect(pFont); 
        return (m_hFont!=NULL); 
    }
};

class CWaitCursor
{
private:
    HCURSOR hPrevCur;
public:
    CWaitCursor() { hPrevCur = SetCursor(LoadCursor(NULL, IDC_WAIT));};
    ~CWaitCursor() { SetCursor(hPrevCur); };
};


// ListView helpers
int     ListView_NewItem(HWND hList, int iIndex, LPCWSTR szText, LPARAM lParam = NULL, int iImage=-1);
int     ListView_NewColumn(HWND hwndListView, int iCol, int cx, LPCWSTR szHeading=NULL, int fmt=0 /*LVCFMT_LEFT*/);
LPARAM  ListView_GetItemData(HWND hListView, int iItem);
int     ListView_GetCurSel(HWND hwndList);
void
ListView_SetItemFiletime(
    IN HWND hwndList,
    IN int  iItem,
    IN int  iColumn,
    IN FILETIME const *pft);

#define AfxMessageBox(__XX__)  MessageBox(NULL, __XX__, _TEXT("Debug Message"), MB_OK)

//
// Iterates through a 0 based safe array
//
template <class CElemType>
class SafeArrayEnum
{
public:
    SafeArrayEnum(SAFEARRAY* psa) :
        m_psa(psa),
        m_nIndex(0) {}

    void Reset() {m_nIndex = 0;}
    HRESULT Next(CElemType& elem)
    {
        HRESULT hr = S_OK;
        hr = SafeArrayGetElement(
            m_psa,
            &m_nIndex,
            &elem);
        if(S_OK==hr)
            m_nIndex++;
        return hr;
    }
    
    HRESULT GetAt(LONG nIndex, CElemType& elem)
    {
        return SafeArrayGetElement(
            m_psa,
            &nIndex,
            &elem);
    }

    LONG GetCount()
    {
        LONG lCount = -1;
        SafeArrayGetUBound(
            m_psa,
            1,
            &lCount);
        return lCount+1;
    }

    // test if one dimension and zero based
    bool IsValid()
    {
        if(1!=SafeArrayGetDim(m_psa))
            return false;

        LONG lCount = -1;
        SafeArrayGetLBound(
            m_psa,
            1,
            &lCount);
        return 0==lCount;
    }

protected:
    
    SAFEARRAY* m_psa;
    LONG m_nIndex;
};

#include "cstring.h"

#endif // #ifndef _TFC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\tmpllist.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1999 - 2000
//
// File:        tmpllist.h
//
// Contents:    certificate template list class
//
//---------------------------------------------------------------------------
#ifndef __TMPLLIST_H__
#define __TMPLLIST_H__

#include <tptrlist.h>

namespace CertSrv
{
class CTemplateInfo
{
public:

    CTemplateInfo() : 
        m_pwszTemplateName(NULL),
        m_pwszTemplateOID(NULL),
        m_hCertType(NULL){};
    ~CTemplateInfo()
    {
        if(m_pwszTemplateName)
            LocalFree(m_pwszTemplateName);
        if(m_pwszTemplateOID)
            LocalFree(m_pwszTemplateOID);
        // no free needed for m_hCertType
    };

    HRESULT SetInfo(
        LPCWSTR pcwszTemplateName,
        LPCWSTR pcwszTemplateOID);

    HRESULT SetInfo(HCERTTYPE hCertType) 
    { m_hCertType = hCertType; return S_OK;}

    LPCWSTR GetName();
    LPCWSTR GetOID();

    HCERTTYPE GetCertType() { return m_hCertType; }

    DWORD GetMarshalBufferSize()
    {
        return sizeof(WCHAR)*
            (2 + // trailing separators
             (GetName()?wcslen(GetName()):0) +
             (GetOID() ?wcslen(GetOID()) :0));
    }

    void FillInfoFromProperty(LPWSTR& pwszProp, LPCWSTR pcwszPropName);

    bool operator==(CTemplateInfo& rh);

protected:
    LPWSTR m_pwszTemplateName;
    LPWSTR m_pwszTemplateOID;
    HCERTTYPE m_hCertType;
}; // class CTemplateInfo

typedef LPCWSTR (CTemplateInfo::* GetIdentifierFunc) ();

class CTemplateList : public TPtrList<CTemplateInfo>
{
public:

    static const WCHAR m_gcchSeparator = L'\n';

    HRESULT Marshal(BYTE*& rpBuffer, DWORD& rcBuffer) const;
    HRESULT Unmarshal(const BYTE *pBuffer, DWORD cBuffer);
    HRESULT LoadTemplatesFromDS();
    HRESULT ValidateMarshalBuffer(const BYTE *pBuffer, DWORD cBuffer) const;

    HRESULT AddTemplateInfo(
		IN LPCWSTR pcwszTemplateName,
		IN LPCWSTR pcwszTemplateOID);

    HRESULT AddTemplateInfo(
		IN HCERTTYPE hCertType,
		IN BOOL fTransientCertTypeHandle); // don't hang onto hCertType

    HRESULT RemoveTemplateInfo(HCERTTYPE hCertType);

    bool TemplateExistsOID(LPCWSTR pcwszOID) const
    {
        return TemplateExists(pcwszOID, &CTemplateInfo::GetOID);
    }
    bool TemplateExistsName(LPCWSTR pcwszName) const
    {
        return TemplateExists(pcwszName, &CTemplateInfo::GetName);
    }

protected:
    DWORD GetMarshalBufferSize() const;

    bool TemplateExists(LPCWSTR pcwszOIDorName, GetIdentifierFunc func) const
    {
        TPtrListEnum<CTemplateInfo> listenum(*this);
        CTemplateInfo *pInfo;

        for(pInfo=listenum.Next();
            pInfo;
            pInfo=listenum.Next())
        {
            if(0 == _wcsicmp((pInfo->*func)(), pcwszOIDorName))
                return true;
        }
        return false;
    }

}; // class CTemplateList

typedef TPtrListEnum<CTemplateInfo> CTemplateListEnum;
} // namespace CertSrv

HRESULT
myUpdateCATemplateListToCA(
    IN HCAINFO hCAInfo,
    IN const CTemplateList& list);

HRESULT
myUpdateCATemplateListToDS(
    IN HCAINFO hCAInfo);

HRESULT
myRetrieveCATemplateList(
    IN HCAINFO hCAInfo,
    IN BOOL fTransientCertTypeHandle,	// don't hang onto hCertType
    OUT CTemplateList& list);

HRESULT
myAddToCATemplateList(
    IN HCAINFO hCAInfo,
    IN OUT CTemplateList& list,
    IN HCERTTYPE hCertType,
    IN BOOL fTransientCertTypeHandle);	// don't hang onto hCertType

HRESULT
myRemoveFromCATemplateList(
    IN HCAINFO hCAInfo,
    IN OUT CTemplateList& list,
    IN HCERTTYPE hCertType);

using namespace CertSrv;

#endif //__TMPLLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\initlib\certmsg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       certmsg.cpp
//
//--------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  File:       certmsg.cpp
// 
//  Contents:   message display APIs
//
//  History:    11/97   xtan
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// Application Includes
#include "setupids.h"
#include "certmsg.h"

#define __dwFILE__	__dwFILE_INITLIB_CERTMSG_CPP__


extern FNLOGMESSAGEBOX *g_pfnLogMessagBox;


//--------------------------------------------------------------------
// Throw up a dialog with the format "<Prefix><UserMsg><SysErrorMsg>".
//   <Prefix> is basically "An error was detected...run the 
//       wizard again..." and is prepended if CMB_REPEATWIZPREFIX
//       is specified.
//   <UserMsg> is specified by dwMsgId and can contain "%1" which
//       will be replaced with pwszCustomMsg. if dwMsgId is 0, 
//       pwszCustomMsg is used instead.
//   <SysErrorMsg> is the system message for hrCode. It can be
//       suppressed if CMB_NOERRFROMSYS is specified.
int
CertMessageBox(
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hWnd,
    IN DWORD dwMsgId,
    IN HRESULT hrCode,
    IN UINT uType,
    IN OPTIONAL const WCHAR * pwszCustomMsg)
{
    HRESULT hr;
    int nMsgBoxRetVal = -1;
    DWORD nMsgChars = 0;
    WCHAR szEmergency[36];

    // variables that must be cleaned up
    WCHAR * pwszTitle = NULL;
    WCHAR * pwszPrefix = NULL;
    WCHAR * pwszUserMsg = NULL;
    WCHAR * pwszExpandedUserMsg = NULL;
    WCHAR const *pwszSysMsg = NULL;
    WCHAR * pwszFinalMsg = NULL;

    // mask off CMB defines
    BOOL fRepeatWizPrefix = uType & CMB_REPEATWIZPREFIX;
    BOOL fNoErrFromSys    = uType & CMB_NOERRFROMSYS;
    uType &= ~(CMB_NOERRFROMSYS | CMB_REPEATWIZPREFIX);

    // load title
    hr=myLoadRCString(hInstance, IDS_MSG_TITLE, &pwszTitle);
    _JumpIfError(hr, error, "myLoadRCString");

    // load the "this wizard will need to be run again" prefix, if necessary
    if (fRepeatWizPrefix) {
        hr=myLoadRCString(hInstance, IDS_ERR_REPEATWIZPREFIX, &pwszPrefix);
        _JumpIfError(hr, error, "myLoadRCString");
        nMsgChars+=wcslen(pwszPrefix);
    }

    // get the system message for this error, if necessary
    if (!fNoErrFromSys) {
        pwszSysMsg = myGetErrorMessageText1(hrCode, TRUE, pwszCustomMsg);
        nMsgChars += wcslen(pwszSysMsg) + 1;
    }

    if (0!=dwMsgId) {
        // load requested message from resource
        hr=myLoadRCString(hInstance, dwMsgId, &pwszUserMsg);
        _JumpIfError(hr, error, "myLoadRCString");

        // perform substitution if necessary
        if (NULL==pwszCustomMsg) {
            // no substitution necessary
            CSASSERT(NULL==wcsstr(pwszUserMsg, L"%1")); // were we expecting a substitution?
        } else {
            // perform a substitution
            CSASSERT(NULL!=wcsstr(pwszUserMsg, L"%1")); // were we not expecting a substitution?
            if (!FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |                 // flags
                            FORMAT_MESSAGE_FROM_STRING |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        pwszUserMsg,                                     // source
                        0,                                               // message id
                        0,                                               // language id
                        reinterpret_cast<WCHAR *>(&pwszExpandedUserMsg), // output buffer
                        0,                                               // min size
                        reinterpret_cast<va_list *>(
                            const_cast<WCHAR **>(&pwszCustomMsg))))      // pointer to array of pointers
            {
                hr=myHLastError();
                _JumpError(hr, error, "FormatMessage");
            }

            // use the expanded message instead of the unexpanded message
            LocalFree(pwszUserMsg);
            pwszUserMsg=pwszExpandedUserMsg;
            pwszExpandedUserMsg = NULL;
        }

    } 
    else if (NULL != pwszCustomMsg)
    {

        // use pwszCustomMsg instead
        CSASSERT(NULL!=pwszCustomMsg);
        pwszUserMsg=const_cast<WCHAR *>(pwszCustomMsg);
    }
    else
    {
        hr = E_POINTER;
        _JumpError(hr, error, "Invalid NULL param");
    }

    nMsgChars+=wcslen(pwszUserMsg);

    // allocate buffer to hold everything
    pwszFinalMsg=(WCHAR *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, (nMsgChars+1)*sizeof(WCHAR));
    if (NULL == pwszFinalMsg)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // build the message
    if (NULL!=pwszPrefix) {
        wcscat(pwszFinalMsg, pwszPrefix);
    }
    wcscat(pwszFinalMsg, pwszUserMsg);
    if (NULL!=pwszSysMsg) {
        wcscat(pwszFinalMsg, L" ");
        wcscat(pwszFinalMsg, pwszSysMsg);
    }
    CSASSERT(wcslen(pwszFinalMsg) <= nMsgChars);

    // finally show message
    DBGPRINT((DBG_SS_CERTLIB, "MessageBox: %ws: %ws\n", pwszTitle, pwszFinalMsg));
    if (NULL != g_pfnLogMessagBox)
    {
	(*g_pfnLogMessagBox)(hrCode, dwMsgId, pwszTitle, pwszFinalMsg);
    }
    if (fUnattended)
    {
	nMsgBoxRetVal = IDYES;
    }
    else
    {
        nMsgBoxRetVal=MessageBox(hWnd, pwszFinalMsg, pwszTitle, uType | MB_SETFOREGROUND);
    }
    if (NULL != g_pfnLogMessagBox)
    {
	_snwprintf(szEmergency, ARRAYSIZE(szEmergency), L"%d", nMsgBoxRetVal);
	(*g_pfnLogMessagBox)(S_OK, dwMsgId, pwszTitle, szEmergency);
    }

    // skip error handling
    goto done;

error:
    // we had an error, but we really need to show something
    // build a non-localized desperation dialog: "Fatal: 0xNNNNNNNN  MsgId:0xNNNNNNNN"
    _snwprintf(szEmergency, ARRAYSIZE(szEmergency), L"Fatal: 0x%8X  MsgId: 0x%8X", hr, dwMsgId);
    DBGPRINT((DBG_SS_CERTLIB, "EmergencyMessageBox: %ws\n", szEmergency));
    if (NULL != g_pfnLogMessagBox)
    {
	(*g_pfnLogMessagBox)(hrCode, dwMsgId, L"EmergencyMessageBox", szEmergency);
    }
    if (!fUnattended) {
        // The message box with these flags is guaranteed to display
        MessageBox(hWnd, szEmergency, NULL, MB_ICONHAND | MB_SYSTEMMODAL);
    }

done:
    if (NULL!=pwszTitle) {
        LocalFree(pwszTitle);
    }
    if (NULL!=pwszPrefix) {
        LocalFree(pwszPrefix);
    }
    if (NULL!=pwszUserMsg && pwszUserMsg!=pwszCustomMsg) {
        LocalFree(pwszUserMsg);
    }
    if (NULL!=pwszExpandedUserMsg) {
        LocalFree(pwszExpandedUserMsg);
    }
    if (NULL!=pwszSysMsg) {
        LocalFree(const_cast<WCHAR *>(pwszSysMsg));
    }
    if (NULL!=pwszFinalMsg) {
        LocalFree(pwszFinalMsg);
    }

    return nMsgBoxRetVal;
}


//--------------------------------------------------------------------
// Throw up a dialog with the format "<UserMsg>".
//   <UserMsg> is specified by dwMsgId and can contain "%1" which
//       will be replaced with pwszCustomMsg.
int
CertInfoMessageBox(
    IN  HINSTANCE hInstance,
    IN  BOOL fUnattended,
    IN  HWND hWnd,
    IN  DWORD dwMsgId,
    IN OPTIONAL const WCHAR * pwszCustomMsg)
{
    return CertMessageBox(
               hInstance,
               fUnattended,
               hWnd,
               dwMsgId,
               0,
               MB_OK | MB_ICONINFORMATION | CMB_NOERRFROMSYS,
               pwszCustomMsg);
}

//--------------------------------------------------------------------
// Throw up a dialog with the format "<Prefix><UserMsg><SysErrorMsg>".
//   <Prefix> is basically "An error was detected...run the 
//       wizard again..." .
//   <UserMsg> is specified by dwMsgId and can contain "%1" which
//       will be replaced with pwszCustomMsg.
//   <SysErrorMsg> is the system message for hrCode.
int
CertErrorMessageBox(
    IN  HINSTANCE hInstance,
    IN  BOOL fUnattended,
    IN  HWND hWnd,
    IN  DWORD dwMsgId,
    IN  HRESULT hrCode,
    IN OPTIONAL  const WCHAR * pwszCustomMsg)
{
    return CertMessageBox(
               hInstance,
               fUnattended,
               hWnd,
               dwMsgId,
               hrCode,
               MB_OK | MB_ICONERROR | CMB_REPEATWIZPREFIX,
               pwszCustomMsg);
}

//--------------------------------------------------------------------
// Throw up a dialog with the format "<UserMsg><SysErrorMsg>".
//   <UserMsg> is specified by dwMsgId and can contain "%1" which
//       will be replaced with pwszCustomMsg.
//   <SysErrorMsg> is the system message for hrCode. It is
//       suppressed if a successful hrCode is specified.
int
CertWarningMessageBox(
    IN  HINSTANCE hInstance,
    IN  BOOL fUnattended,
    IN  HWND hWnd,
    IN  DWORD dwMsgId,
    IN  HRESULT hrCode,
    IN OPTIONAL  const WCHAR * pwszCustomMsg)
{
    UINT uType=MB_OK | MB_ICONWARNING;

    if (SUCCEEDED(hrCode)) {
        uType |= CMB_NOERRFROMSYS;
    }

    return CertMessageBox(
               hInstance,
               fUnattended,
               hWnd,
               dwMsgId,
               hrCode,
               uType,
               pwszCustomMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\initlib\certui.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cryptui.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "certmsg.h"
#include "clibres.h"
#include "setupids.h"
#include "tfc.h"
#include "Windowsx.h"

#define __dwFILE__	__dwFILE_INITLIB_CERTUI_CPP__


HRESULT
myGetConfigStringFromPicker(
    OPTIONAL IN HWND hwndParent,
    OPTIONAL IN WCHAR const *pwszPrompt,
    OPTIONAL IN WCHAR const *pwszTitle,
    OPTIONAL IN WCHAR const *pwszSharedFolder,
    IN DWORD dwFlags,	// GCFPF_*
    OUT WCHAR **ppwszConfig)
{
    HRESULT hr;
    DWORD dwCACount;
    CRYPTUI_CA_CONTEXT const *pCAContext = NULL;

    hr = myGetConfigFromPicker(
			hwndParent,
			pwszPrompt,
			pwszTitle,
			pwszSharedFolder,
			dwFlags,
			FALSE,
			&dwCACount,
			&pCAContext);
    _JumpIfError(hr, error, "myGetConfigFromPicker");

    if (NULL == pCAContext)
    {
        hr = E_INVALIDARG;
        _JumpIfError(hr, error, "Internal error: myGetConfigFromPicker");
    }

    hr = myFormConfigString(
			pCAContext->pwszCAMachineName,
			pCAContext->pwszCAName,
			ppwszConfig);
    _JumpIfError(hr, error, "myFormConfigString");

error:
    if (NULL != pCAContext)
    {
        CryptUIDlgFreeCAContext(pCAContext);
    }
    return(hr);
}


HRESULT
myUIGetWindowText(
    IN HWND     hwndCtrl,
    OUT WCHAR **ppwszText)
{
    HRESULT  hr;
    LRESULT  len;
    WCHAR   *pwszBegin;
    WCHAR   *pwszEnd;
    WCHAR   *pwszText = NULL;

    CSASSERT(NULL != hwndCtrl &&
             NULL != ppwszText);

    // init
    *ppwszText = NULL;

    // get text string size
    len = SendMessage(hwndCtrl, WM_GETTEXTLENGTH, 0, 0);
    if (0 < len)
    {
        pwszText = (WCHAR*)LocalAlloc(LMEM_FIXED, (UINT)((len+1) * sizeof(WCHAR)));
	if (NULL == pwszText)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
        if (len !=
            SendMessage(hwndCtrl, WM_GETTEXT, (WPARAM)len+1, (LPARAM)pwszText))
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_LENGTH);
            _JumpError(hr, error, "Internal error");
        }
    }
    else
    {
        goto done;
    }

    // trim trailing and heading blank strings
    pwszBegin = pwszText;
    pwszEnd = &pwszText[wcslen(pwszText) - 1];

    while (pwszEnd > pwszBegin && iswspace(*pwszEnd) )
    {
        *pwszEnd = L'\0';
         --pwszEnd;
    }
    while (pwszBegin <= pwszEnd &&
           L'\0' != *pwszBegin &&
           iswspace(*pwszBegin) )
    {
        ++pwszBegin;
    }

    if (pwszEnd >= pwszBegin)
    {
        MoveMemory(
	    pwszText,
	    pwszBegin,
	    (SAFE_SUBTRACT_POINTERS(pwszEnd, pwszBegin) + 2) * sizeof(WCHAR));
    }
    else
    {
        goto done;
    }

    *ppwszText = pwszText;
    pwszText = NULL;

done:
    hr = S_OK;
error:
    if (NULL != pwszText)
    {
        LocalFree(pwszText);
    }
    return hr;
}


// following code for CA selection UI control

HRESULT
myUICASelectionUpdateCAList(
    HWND  hwndList,
    WCHAR const *pwszzCAList)
{
    HRESULT  hr;
    int      nItem;
    WCHAR const *pwszCA = pwszzCAList;

    // remove current list
    SendMessage(hwndList, CB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0);

    // add to list
    while (NULL != pwszCA && L'\0' != pwszCA[0])
    {
        nItem = (INT)SendMessage(
                    hwndList,
                    CB_ADDSTRING,
                    (WPARAM) 0,
                    (LPARAM) pwszCA);
        if (LB_ERR == nItem)
        {
            hr = myHLastError();
            _JumpError(hr, error, "SendMessage");
        }
        pwszCA += wcslen(pwszCA) + 1;
    }

    if (NULL != pwszzCAList)
    {
        // attempt to choose the 1st one as default
        SendMessage(hwndList, CB_SETCURSEL, (WPARAM) 0, (LPARAM) 0);
    }
    hr = S_OK;

error:
    return hr;
}


LRESULT CALLBACK
myUICASelectionComputerEditFilterHook(
    HWND hwndComputer,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT  lr;
    HRESULT  hr;
    CERTSRVUICASELECTION *pData = (CERTSRVUICASELECTION *)
                 GetWindowLongPtr(hwndComputer, GWLP_USERDATA);
    CSASSERT(NULL != pData);

    switch (iMsg)
    {
        case WM_CHAR:
            // empty ca list
            hr = myUICASelectionUpdateCAList(pData->hwndCAList, NULL);
            _PrintIfError(hr, "myUICASelectionUpdateCAList");
	    break;
    }

    lr = CallWindowProc(
		    pData->pfnUICASelectionComputerWndProcs,
		    hwndComputer,
		    iMsg,
		    wParam,
		    lParam);

//error:
    return lr;
}

HRESULT
myUICAConditionallyDisplayEnterpriseWarning(
    IN CERTSRVUICASELECTION *pData)
{
    HRESULT hr = S_OK;
    WCHAR szCA[MAX_PATH];
    WCHAR szComputer[MAX_PATH];
    CAINFO *pCAInfo = NULL;
    BOOL fCoInit = FALSE;
    int iSel;
    
    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, Ret, "CoInitialize");
    }
    fCoInit = TRUE;
    hr = S_OK; // don't want to return this error 
    
    pData->CAType = ENUM_UNKNOWN_CA;
    
    // pinging specific CA is done in both cases -- reselect or new machine
    // pointed at

    szCA[0] = L'\0';
    szComputer[0] = L'\0';
    iSel = ComboBox_GetCurSel(pData->hwndCAList);
    ComboBox_GetLBText(pData->hwndCAList, iSel, szCA);
    GetWindowText(pData->hwndComputerEdit, szComputer, MAX_PATH);
    
    if ((szCA[0] == L'\0') || (szComputer[0] == L'\0'))
    {
        ShowWindow(GetDlgItem(pData->hDlg, IDC_CLIENT_WARN_ENTERPRISE_REQUIREMENTS), SW_HIDE);
        goto Ret;
    }
    
    hr = myPingCertSrv(
        szCA,
        szComputer,
        NULL,
        NULL,
        &pCAInfo,
        NULL,
        NULL);
    
    if ((hr == S_OK) && (pCAInfo != NULL))
    {
	// copy catype into returned data
	pData->CAType = pCAInfo->CAType;

	if (IsEnterpriseCA(pCAInfo->CAType))
	{
	    ShowWindow(
		    GetDlgItem(
			pData->hDlg,
			IDC_CLIENT_WARN_ENTERPRISE_REQUIREMENTS),
		    SW_SHOW);
	}
	else
	{
	    ShowWindow(
		    GetDlgItem(
			pData->hDlg,
			IDC_CLIENT_WARN_ENTERPRISE_REQUIREMENTS),
		    SW_HIDE);
	}
    }

    
Ret:
    if (NULL != pCAInfo)
        LocalFree(pCAInfo);
    
    if (fCoInit)
        CoUninitialize();
    
    return hr;
}


HRESULT
myUICAHandleCAListDropdown(
    IN int                       iNotification,
    IN OUT CERTSRVUICASELECTION *pData,
    IN OUT BOOL                 *pfComputerChange)
{
    HRESULT  hr;
    WCHAR   *pwszComputer = NULL;
    WCHAR   *pwszzCAList = NULL;
    BOOL     fCoInit = FALSE;
    WCHAR   *pwszDnsName = NULL;
    DWORD   dwVersion;

    CSASSERT(NULL != pData);

    // if this isn't a focus or selection change and computer name stayed the
    // same, nothing to do

    if ((CBN_SELCHANGE != iNotification) && !*pfComputerChange) 
    {
        goto done;
    }

    ShowWindow(GetDlgItem(pData->hDlg, IDC_CLIENT_WARN_ENTERPRISE_REQUIREMENTS), SW_HIDE);  
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    if (NULL == pData->hwndComputerEdit)
    {
        // not init
        goto done;
    }

    // make sure computer edit field is not empty
    hr = myUIGetWindowText(pData->hwndComputerEdit,
                           &pwszComputer);
    _JumpIfError(hr, error, "myUIGetWindowText");
    if (NULL == pwszComputer)
    {
        goto done;
    }

    if (*pfComputerChange)
    {
	// ping to get ca list

	hr = CoInitialize(NULL);
	if (S_OK != hr && S_FALSE != hr)
	{
	    _JumpError(hr, error, "CoInitialize");
	}
	fCoInit = TRUE;


	// reset once ca list is updated.  Do this now to prevent recursion
	*pfComputerChange = FALSE;

	hr = myPingCertSrv(
		    pwszComputer,
		    NULL,
		    &pwszzCAList,
		    NULL,
		    NULL,
		    &dwVersion,
		    &pwszDnsName);
	CSILOG(hr, IDS_ILOG_GETCANAME, pwszComputer, NULL, NULL);
	if (S_OK != hr)
	{
	    // make sure null
	    CSASSERT(NULL == pwszzCAList);

	    // can't ping the ca.  Set focus now to prevent recursion
	    SetFocus(pData->hwndComputerEdit);
	    SendMessage(pData->hwndComputerEdit, EM_SETSEL, 0, -1);

	    CertWarningMessageBox(
		    pData->hInstance,
		    FALSE,
		    pData->hDlg,
		    IDS_WRN_PINGCA_FAIL,
		    hr,
		    NULL);
	}
	else if (dwVersion<2 && pData->fWebProxySetup)
	{
	    //bug 262316: don't allow installing Whistler proxy to an older CA

	    hr = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);

	    if (pwszzCAList)
	    {
		LocalFree(pwszzCAList);
		pwszzCAList = NULL;
	    }

	    SetFocus(pData->hwndComputerEdit);
	    SendMessage(pData->hwndComputerEdit, EM_SETSEL, 0, -1);

	    CertWarningMessageBox(
		    pData->hInstance,
		    FALSE,
		    pData->hDlg,
		    IDS_WRN_OLD_CA,
		    hr,
		    NULL);
	}

	if (NULL != pwszDnsName && 0 != mylstrcmpiL(pwszComputer, pwszDnsName))
	{
	    // update computer

	    SendMessage(
		    pData->hwndComputerEdit,
		    WM_SETTEXT,
		    0,
		    (LPARAM) pwszDnsName);
	}

	// update ca list
	hr = myUICASelectionUpdateCAList(pData->hwndCAList, pwszzCAList);
	_JumpIfError(hr, error, "myUICASelectionUpdateCAList");
    }

    // pinging specific CA is done in both cases -- reselect or new machine
    // pointed at

    hr = myUICAConditionallyDisplayEnterpriseWarning(pData);
    _PrintIfError(hr, "myUICAConditionallyDisplayEnterpriseWarning");

done:
    hr = S_OK;

error:
    SetCursor(LoadCursor(NULL, IDC_ARROW));

    if (fCoInit)
    {
        CoUninitialize();
    }
    if (NULL != pwszzCAList)
    {
        LocalFree(pwszzCAList);
    }
    if (NULL != pwszComputer)
    {
        LocalFree(pwszComputer);
    }
    if (NULL != pwszDnsName)
    {
        LocalFree(pwszDnsName);
    }
    return hr;
}


HRESULT
myInitUICASelectionControls(
    IN OUT CERTSRVUICASELECTION *pUICASelection,
    IN HINSTANCE                 hInstance,
    IN HWND                      hDlg,
    IN HWND                      hwndBrowseButton,
    IN HWND                      hwndComputerEdit,
    IN HWND                      hwndCAList,
    IN BOOL                      fDSCA,
    OUT BOOL			*pfCAsExist)
{
    HRESULT  hr;
    PCCRYPTUI_CA_CONTEXT  pCAContext = NULL;
    DWORD          dwCACount;
    CString cstrText;
    DWORD dwFlags = fDSCA? GCFPF_USEDS : 0;

    if (pUICASelection->fSkipLocalCA)
    {
	dwFlags |= GCFPF_SKIPLOCALCA;
    }
    SetCursor(LoadCursor(NULL, IDC_WAIT));
    hr = myGetConfigFromPicker(
			  hDlg,
			  NULL,
			  NULL,
			  NULL,
                          dwFlags,
			  TRUE,	// fCountOnly
			  &dwCACount,
			  &pCAContext);
    SetCursor(LoadCursor(NULL, IDC_ARROW));
    if (S_OK != hr)
    {
        dwCACount = 0;
        _PrintError(hr, "myGetConfigFromPicker");
    }

    // enable/disable
    *pfCAsExist = 0 < dwCACount;
    EnableWindow(hwndBrowseButton, *pfCAsExist);

    // set computer edit control hook
    pUICASelection->pfnUICASelectionComputerWndProcs =
        (WNDPROC)SetWindowLongPtr(hwndComputerEdit,
             GWLP_WNDPROC, (LPARAM)myUICASelectionComputerEditFilterHook);

    pUICASelection->hInstance = hInstance;
    pUICASelection->hDlg = hDlg;
    pUICASelection->hwndComputerEdit = hwndComputerEdit;
    pUICASelection->hwndCAList = hwndCAList;

    // pass data to both controls
    SetWindowLongPtr(hwndComputerEdit, GWLP_USERDATA, (ULONG_PTR)pUICASelection);
    SetWindowLongPtr(hwndCAList, GWLP_USERDATA, (ULONG_PTR)pUICASelection);

    // by default, don't show Enterprise CA warning
    cstrText.LoadString(IDS_WARN_ENTERPRISE_REQUIREMENTS);
    SetWindowText(GetDlgItem(hDlg, IDC_CLIENT_WARN_ENTERPRISE_REQUIREMENTS), cstrText);
    ShowWindow(GetDlgItem(hDlg, IDC_CLIENT_WARN_ENTERPRISE_REQUIREMENTS), SW_HIDE);

    if (NULL != pCAContext)
    {
        CryptUIDlgFreeCAContext(pCAContext);
    }
    hr = S_OK;

//error:
    return hr;
}


HRESULT
myUICAHandleCABrowseButton(
    CERTSRVUICASELECTION *pData,
    IN BOOL               fUseDS,
    OPTIONAL IN int       idsPickerTitle,
    OPTIONAL IN int       idsPickerSubTitle,
    OPTIONAL OUT WCHAR   **ppwszSharedFolder)
{
    HRESULT   hr = S_OK;
    PCCRYPTUI_CA_CONTEXT  pCAContext = NULL;
    WCHAR         *pwszSubTitle = NULL;
    WCHAR         *pwszTitle = NULL;
    DWORD          dwCACount;
    WCHAR         *pwszzCAList = NULL;
    WCHAR         *pwszComputer = NULL;
    WCHAR         *pwszTemp = NULL;
    BOOL           fCoInit = FALSE;
    DWORD          dwVersion;
    DWORD dwFlags = fUseDS? GCFPF_USEDS : 0;

    if (NULL != ppwszSharedFolder)
    {
        *ppwszSharedFolder = NULL;
    }
    if (pData->fSkipLocalCA)
    {
	dwFlags |= GCFPF_SKIPLOCALCA;
    }
    if (0 != idsPickerTitle)
    {
        hr = myLoadRCString(pData->hInstance, idsPickerTitle, &pwszTitle);
        if (S_OK != hr)
        {
            pwszTitle = NULL;
            _PrintError(hr, "myLoadRCString");
        }
    }

    if (0 != idsPickerSubTitle)
    {
        hr = myLoadRCString(pData->hInstance, idsPickerSubTitle, &pwszSubTitle);
        if (S_OK != hr)
        {
            pwszSubTitle = NULL;
            _PrintError(hr, "myLoadRCString");
        }
    }

/*
// REMOVED mattt 6/26/00: is this ever wanted: "Browse uses shared folder of machine editbox currently points at"?
// just seems to make changing away from bad machine very very slow

    // get remote shared folder if possible
    hr = myUIGetWindowText(pData->hwndComputerEdit, &pwszComputer);
    _JumpIfError(hr, error, "myUIGetWindowText");

    if (NULL != pwszComputer)
    {
        hr = CoInitialize(NULL);
        if (S_OK != hr && S_FALSE != hr)
        {
            _JumpError(hr, error, "CoInitialize");
        }
        fCoInit = TRUE;
        // get shared folder path on remote machine here
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        hr = myPingCertSrv(pwszComputer, NULL, NULL, &pwszTemp, NULL, NULL, NULL);
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        if (S_OK != hr)
        {
            CSASSERT(NULL == pwszTemp);
            _JumpError(hr, localsharedfolder, "myPingCertSrv");
        }
    }

localsharedfolder:
*/
    hr = myGetConfigFromPicker(
			  pData->hDlg,
			  pwszSubTitle,
			  pwszTitle,
			  pwszTemp,
			  dwFlags,
			  FALSE,	// fCountOnly
			  &dwCACount,
			  &pCAContext);
    if (S_OK != hr && HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
    {
	CSILOG(hr, IDS_ILOG_SELECTCA, NULL, NULL, NULL);
        _JumpError(hr, error, "myGetConfigFromPicker");
    }

    if (S_OK != hr)
	goto done;

    if (NULL == pCAContext)
    {
        CertWarningMessageBox(
            pData->hInstance,
            FALSE,
            pData->hDlg,
            IDS_WRN_CALIST_EMPTY,
            S_OK,
            NULL);
        SetWindowText(pData->hwndCAList, L"");
        SetFocus(pData->hwndComputerEdit);
        SendMessage(pData->hwndComputerEdit, EM_SETSEL, 0, -1);
    }
    else
    {
        CSILOG(hr, IDS_ILOG_SELECTCA, pCAContext->pwszCAMachineName, pCAContext->pwszCAName, NULL);
        
        // update computer
        SendMessage(pData->hwndComputerEdit, WM_SETTEXT,
            0, (LPARAM)pCAContext->pwszCAMachineName);
        
        // construct a single multi string for list update
        DWORD len = wcslen(pCAContext->pwszCAName);
        pwszzCAList = (WCHAR*)LocalAlloc(LMEM_FIXED, (len+2) * sizeof(WCHAR));
        if (NULL == pwszzCAList)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        wcscpy(pwszzCAList, pCAContext->pwszCAName);
        pwszzCAList[len+1] = '\0';
        
        hr = myUICASelectionUpdateCAList(pData->hwndCAList, pwszzCAList);
        _JumpIfError(hr, error, "myUICASelectionUpdateCAList");
        LocalFree(pwszzCAList);
        pwszzCAList = NULL;

        // this thread blocks paint message, send it before ping
        UpdateWindow(pData->hDlg);
        
        // ping the computer to see if found a matched ca
        
        if (!fCoInit)
        {
            hr = CoInitialize(NULL);
            if (S_OK != hr && S_FALSE != hr)
            {
                _JumpError(hr, error, "CoInitialize");
            }
            fCoInit = TRUE;
        }
        
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        // ping to get ca list
        hr = myPingCertSrv(
            pCAContext->pwszCAMachineName,
            NULL,
            &pwszzCAList,
            NULL,
            NULL,
            &dwVersion,
            NULL);
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        CSILOG(hr, IDS_ILOG_GETCANAME, pCAContext->pwszCAMachineName, NULL, NULL);
        if (S_OK == hr)
        {
            //bug 262316: don't allow installing Whistler proxy to an older CA
            if (dwVersion<2 && pData->fWebProxySetup)
            {
                hr = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
                // focus on the CA list to trigger a verification of the CA
                SetFocus(pData->hwndCAList);

            }
	    else
            {
		// ping successful
		WCHAR const *pwszPingCA = pwszzCAList;
            
		// go through the list to see if any match
		while (NULL != pwszPingCA && L'\0' != pwszPingCA[0])
		{
		    if (0 == mylstrcmpiL(pCAContext->pwszCAName, pwszPingCA))
		    {
			// found matched one
			goto done;
		    }
		    pwszPingCA += wcslen(pwszPingCA) + 1;
		}
		
		// if we get here, either the CA is offline or the machine is
		// offline and another machine is using the same IP address.
		
		CertWarningMessageBox(
		    pData->hInstance,
		    FALSE,
		    pData->hDlg,
		    IDS_WRN_CANAME_NOT_MATCH,
		    0,
		    NULL);
		// only empty combo edit field
		SetWindowText(pData->hwndCAList, L"");
		SetFocus(pData->hwndCAList);
            }
        }
        else
        {
            // can't ping the ca, selected an estranged ca

            CertWarningMessageBox(
                pData->hInstance,
                FALSE,
                pData->hDlg,
                IDS_WRN_PINGCA_FAIL,
                hr,
                NULL);

            // empty list anyway

            hr = myUICASelectionUpdateCAList(pData->hwndCAList, NULL);
            _JumpIfError(hr, error, "UICASelectionUpdateCAList");
            
            SetFocus(pData->hwndComputerEdit);
            SendMessage(pData->hwndComputerEdit, EM_SETSEL, 0, -1);
        }
    }

done:
    hr = myUICAConditionallyDisplayEnterpriseWarning(pData);
    _PrintIfError(hr, "myUICAConditionallyDisplayEnterpriseWarning");

    if (NULL != ppwszSharedFolder)
    {
        *ppwszSharedFolder = pwszTemp;
        pwszTemp = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszzCAList)
    {
        LocalFree(pwszzCAList);
    }
    if (NULL != pwszSubTitle)
    {
        LocalFree(pwszSubTitle);
    }
    if (NULL != pwszTitle)
    {
        LocalFree(pwszTitle);
    }
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    if (NULL != pwszComputer)
    {
        LocalFree(pwszComputer);
    }
    if (NULL != pCAContext)
    {
        CryptUIDlgFreeCAContext(pCAContext);
    }
    if (fCoInit)
    {
        CoUninitialize();
    }


    return hr;
}

HRESULT
myUICASelectionValidation(
    CERTSRVUICASELECTION *pData,
    BOOL                 *pfValidate)
{
    HRESULT  hr;
    WCHAR   *pwszComputer = NULL;
    WCHAR   *pwszCA = NULL;

    CSASSERT(NULL != pData);

    *pfValidate = FALSE;

    // first, make sure not empty
    hr = myUIGetWindowText(pData->hwndComputerEdit, &pwszComputer);
    _JumpIfError(hr, error, "myUIGetWindowText");

    if (NULL == pwszComputer)
    {
        CertWarningMessageBox(
                pData->hInstance,
                FALSE,
                pData->hDlg,
                IDS_WRN_COMPUTERNAME_EMPTY,
                0,
                NULL);
        SetFocus(pData->hwndComputerEdit);
        goto done;
    }

    hr = myUIGetWindowText(pData->hwndCAList, &pwszCA);
    _JumpIfError(hr, error, "myUIGetWindowText");

    if (NULL == pwszCA)
    {
        CertWarningMessageBox(
                pData->hInstance,
                FALSE,
                pData->hDlg,
                IDS_WRN_CANAME_EMPTY,
                0,
                NULL);
        SetFocus(pData->hwndComputerEdit);
	SendMessage(pData->hwndComputerEdit, EM_SETSEL, 0, -1);
        goto done;
    }

    CSASSERT(pData->CAType != ENUM_UNKNOWN_CA);
    if (pData->CAType == ENUM_UNKNOWN_CA)
    {
         hr = E_UNEXPECTED;
         _JumpIfError(hr, error, "CAType not determined");
    }

    // if hit here
    *pfValidate = TRUE;

done:
    hr = S_OK;
error:
    if (NULL != pwszComputer)
    {
        LocalFree(pwszComputer);
    }
    if (NULL != pwszCA)
    {
        LocalFree(pwszCA);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\initlib\initlib.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       initlib.cpp
//
//  Contents:   Install cert server
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

// C Run-Time Includes
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <io.h>
#include <winldap.h>
#include <ntldap.h>

// Windows System Includes
#include <winsvc.h>
#include <rpc.h>
#include <tchar.h>
#include <lmaccess.h>
#include <lmwksta.h>
#include <csdisp.h>
#include <wincrypt.h>
#include <objbase.h>
#include <initguid.h>
#include <userenv.h>
#include <cainfop.h>


#define SECURITY_WIN32
#include <security.h>

#include <lmerr.h>

// Application Includes
#include "setupids.h"
#include "certmsg.h"
#include "certca.h"
#include "certhier.h"
#include "tfc.h"
#include "cscsp.h"
#include "csldap.h"
#include "certacl.h"

#define __dwFILE__	__dwFILE_INITLIB_INITLIB_CPP__

WCHAR const g_szSlash[] = L"\\";
DWORD g_dwNameEncodeFlags = CERT_RDN_ENABLE_UTF8_UNICODE_FLAG;

#define MAX_COMPUTER_DNS_NAME  256

using namespace CertSrv;


//+=====================================================================
// DS DNs:
//
// DomainDN Example (no longer used for Cert server DS objects):
//	DC=pksdom2,DC=nttest,DC=microsoft,DC=com
//
// ConfigDN Example:
//	CN=Configuration,DC=pksdom2,DC=nttest,DC=microsoft,DC=com
//
// Cert server DS objects reside in Public Key Services container under
// the Configuraton container:
//	CN=Public Key Services,CN=Services,<ConfigDN>
//
//
// In the Public Key Services container:
//
// Root Trust container:
//  Each Root CA creates a Root Trust object in this container to store trusted 
//  Root CA certificates downloaded by all DS clients.
//  Renewed CAs and CAs on multiple machines using the same CA name may use the
//  same Root Trust object, because certs are always added -- they are never
//  removed.
//
//  CN=Certification Authorities
//	CN=CA foo
//	CN=CA bar
//	...
//
//
// Authority Information Access container:
//  Each CA creates an AIA object in this container to store CA certs for chain
//  building.  Renewed CAs and CAs on multiple machines using the same CA name
//  may use the same AIA object, because certs are always added -- they are
//  never removed.
//
//  CN=AIA
//	CN=CA foo
//	CN=CA bar
//	...
//
//
// CRL Distribution Point containers:
//  Each CA creates a CDP object in this container for each unique CA key to
//  store CRLs for revocation checking.  Only one base CRL and zero or one
//  delta CRL are stored in each CDP object, due to potential size constraints,
//  and because the attribute is single valued.  When a CA is renewed and a new
//  CA key is generated during the renewal, a new CDP object is created with
//  the CA's key index (in parentheses) appended to the CN.  A nested container
//  is created for each machine with the CN set to the short machine name
//  (first component of the machine's full DNS name).
//
//  CN=CDP
//      CN=<CA foo's MachineName>
//	    CN=CA foo
//	    CN=CA foo(1)
//	    CN=CA foo(3)
//      CN=<CA bar's MachineName>
//	    CN=CA bar
//	    CN=CA bar(1)
//
//
// Enrollment Services container:
//  Each CA creates an Enrollment Services object in this container.  A flags
//  attribute indicates whether the CA supports autoenrollment (an Enterprise
//  CA) or not (Standalone CA).  The Enrollment Services object publishes the
//  existence of the CA to all DS clients.  Enrollment Services objects are
//  created and managed by the certca.h CA APIs.
//
//  CN=Enrollment Services
//	CN=CA foo
//	CN=CA bar
//	...
//
// Enterprise Trust object:
//  A single Enterprise Trust object contains certificates for all
//  autoenrollment-enabled CAs (root and subordinate Entrprise CAs).
//
//  CN=NTAuthCertificates
//
//======================================================================


WCHAR const s_wszRootCAs[] =
    L","
    L"CN=Certification Authorities,"
    L"CN=Public Key Services,"
    L"CN=Services,";

WCHAR const s_wszEnterpriseCAs[] =
    L"CN=NTAuthCertificates,"
    L"CN=Public Key Services,"
    L"CN=Services,";


//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------

BOOL
csiWriteDERToFile(
    IN WCHAR const *pwszFileName,
    IN BYTE const *pbDER,
    IN DWORD cbDER,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd)
{
    BOOL fResult = FALSE;
    HRESULT hr;
    HANDLE hLocalFile;
    DWORD dwBytesWritten;

    hr = S_OK;

    // Write the Encoded Blob to the file
    hLocalFile = CreateFile(
			pwszFileName,
			GENERIC_WRITE,
			0,
			NULL,
			CREATE_ALWAYS,
			0,
			0);
    if (INVALID_HANDLE_VALUE == hLocalFile)
    {
	hr = myHLastError();
	CertErrorMessageBox(
		    hInstance,
		    fUnattended,
		    hwnd,
		    IDS_ERR_CREATEFILE,
		    hr,
		    pwszFileName);
	_JumpError(hr, error, "CreateFile");
    }

    if (!WriteFile(hLocalFile, pbDER, cbDER, &dwBytesWritten, NULL))
    {
	hr = myHLastError();
	CertErrorMessageBox(
		    hInstance,
		    fUnattended,
		    hwnd,
		    IDS_ERR_WRITEFILE,
		    hr,
		    pwszFileName);
	_JumpError(hr, error, "WriteFile");
    }
    fResult = TRUE;

error:
    if (INVALID_HANDLE_VALUE != hLocalFile)
    {
	CloseHandle(hLocalFile);
    }
    if (!fResult)
    {
	SetLastError(hr);
    }
    return(fResult);
}


BOOL
CreateKeyUsageExtension(
    BYTE bIntendedKeyUsage,
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded,
    HINSTANCE hInstance,
    BOOL fUnattended,
    HWND hwnd)
{
    BOOL fResult = FALSE;
    HRESULT hr;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CRYPT_BIT_BLOB KeyUsage;

    KeyUsage.pbData = &bIntendedKeyUsage;
    KeyUsage.cbData = 1;
    KeyUsage.cUnusedBits = 0;

    hr = S_OK;
    if (!myEncodeKeyUsage(
		    X509_ASN_ENCODING,
		    &KeyUsage,
		    CERTLIB_USE_LOCALALLOC,
		    &pbEncoded,
		    &cbEncoded))
    {
        hr = myHLastError();
        CertErrorMessageBox(
		    hInstance,
		    fUnattended,
		    hwnd,
		    IDS_ERR_ENCODEKEYATTR,
		    hr,
		    NULL);
	cbEncoded = 0;
        goto error;
    }
    fResult = TRUE;

error:
    if (!fResult)
    {
	SetLastError(hr);
    }
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return(fResult);
}


#ifdef USE_NETSCAPE_TYPE_EXTENSION
BOOL
CreateNetscapeTypeExtension(
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    BOOL fResult = FALSE;
    CRYPT_BIT_BLOB NetscapeType;
    BYTE temp = NETSCAPE_SSL_CA_CERT_TYPE | NETSCAPE_SMIME_CA_CERT_TYPE;

    NetscapeType.pbData = &temp;
    NetscapeType.cbData = 1;
    NetscapeType.cUnusedBits = 0;
    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_BITS,
		    &NetscapeType,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbEncoded,
		    pcbEncoded))
    {
	goto exit;
    }
    fResult = TRUE;

exit:
    return(fResult);
}
#endif


HRESULT
GetRegCRLDistributionPoints(
    IN WCHAR const *pwszSanitizedName,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;
    WCHAR *pwszz = NULL;
    WCHAR *pwsz;
    WCHAR *pwszzCopy;
    DWORD cwc;
    DWORD Flags;
    WCHAR *pwszT;

    *ppwszz = NULL;
    hr = myGetCertRegMultiStrValue(
                        pwszSanitizedName,
                        NULL,
                        NULL,
			wszREGCRLPUBLICATIONURLS,
                        &pwszz);

    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        hr = S_OK;
	goto error;
    }
    _JumpIfErrorStr(
		hr,
		error,
		"myGetCertRegMultiStrValue",
		wszREGCRLPUBLICATIONURLS);
    cwc = 0;
    for (pwsz = pwszz; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	Flags = _wtoi(pwsz);
	if (CSURL_ADDTOCERTCDP & Flags)
	{
	    pwszT = pwsz;
	    while (iswdigit(*pwszT))
	    {
		pwszT++;
	    }
	    if (pwszT > pwsz && L':' == *pwszT)
	    {
		pwszT++;
		cwc += wcslen(pwszT) + 1;
	    }
	}
    }
    if (0 == cwc)
    {
        hr = S_OK;
	goto error;
    }

    pwszzCopy = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszzCopy)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *ppwszz = pwszzCopy;

    for (pwsz = pwszz; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	Flags = _wtoi(pwsz);
	if (CSURL_ADDTOCERTCDP & Flags)
	{
	    pwszT = pwsz;
	    while (iswdigit(*pwszT))
	    {
		pwszT++;
	    }
	    if (pwszT > pwsz && L':' == *pwszT)
	    {
		pwszT++;
		wcscpy(pwszzCopy, pwszT);
		pwszzCopy += wcslen(pwszT) + 1;
	    }
	}
    }
    *pwszzCopy = L'\0';
    CSASSERT(SAFE_SUBTRACT_POINTERS(pwszzCopy, *ppwszz) == cwc);

error:
    if (NULL != pwszz)
    {
	LocalFree(pwszz);
    }
    return(hr);
}


HRESULT
FormatTemplateURLs(
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN DWORD iCRL,
    IN BOOL fUseDS,
    IN WCHAR const *pwszzIn,
    OUT DWORD *pcpwsz,
    OUT WCHAR ***ppapwszOut)
{
    HRESULT hr;
    DWORD i;
    WCHAR const **papwszTemplate = NULL;
    WCHAR const *pwsz;
    WCHAR **papwszOut = NULL;
    DWORD cpwsz = 0;
    WCHAR *pwszServerName = NULL;
    LDAP *pld = NULL;
    BSTR strConfigDN = NULL;
    BSTR strDomainDN = NULL;

    *pcpwsz = 0;
    *ppapwszOut = NULL;

    cpwsz = 0;
    if (NULL != pwszzIn)
    {
	for (pwsz = pwszzIn; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    cpwsz++;
        }
    }
    if (0 == cpwsz)
    {
        hr = S_FALSE;
        goto error;
    }

    papwszTemplate = (WCHAR const **) LocalAlloc(
				    LMEM_FIXED,
				    cpwsz * sizeof(papwszTemplate[0]));
    if (NULL == papwszTemplate)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    i = 0;
    for (pwsz = pwszzIn; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	papwszTemplate[i++] = pwsz;
    }
    CSASSERT(i == cpwsz);

    papwszOut = (WCHAR **) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    cpwsz * sizeof(papwszOut[0]));
    if (NULL == papwszOut)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    hr = myGetMachineDnsName(&pwszServerName);
    _JumpIfError(hr, error, "myGetMachineDnsName");

    // bind to ds -- even for !fUseDS, just in case the URLs need to domain DN

    hr = myLdapOpen(
		NULL,		// pwszDomainName
		RLBF_REQUIRE_SECURE_LDAP, // dwFlags
		&pld,
		&strDomainDN,
		&strConfigDN);
    if (S_OK != hr)
    {
	_PrintError(hr, "myLdapOpen");
	if (fUseDS)
	{
	    _JumpError(hr, error, "myLdapOpen");
	}
        strDomainDN = SysAllocString(L"");
	strConfigDN = SysAllocString(L"");
	if (NULL == strDomainDN || NULL == strConfigDN)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "SysAllocString");
	}
    }
    hr = myFormatCertsrvStringArray(
			    TRUE,		// fURL
			    pwszServerName,	// pwszServerName_p1_2
			    pwszSanitizedName,	// pwszSanitizedName_p3_7
			    iCert,		// iCert_p4
			    MAXDWORD,		// iCertTarget_p4
			    strDomainDN,	// pwszDomainDN_p5
			    strConfigDN, 	// pwszConfigDN_p6
			    iCRL,		// iCRL_p8
			    FALSE,		// fDeltaCRL_p9
			    TRUE,		// fDSAttrib_p10_11
			    cpwsz,		// cStrings
			    papwszTemplate,	// apwszStringsIn
			    papwszOut);		// apwszStringsOut
    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

    *pcpwsz = cpwsz;
    *ppapwszOut = papwszOut;
    papwszOut = NULL;

error:
    if (NULL != pwszServerName)
    {
        LocalFree(pwszServerName);
    }
    myLdapClose(pld, strDomainDN, strConfigDN);
    if (NULL != papwszTemplate)
    {
        LocalFree(papwszTemplate);
    }
    if (NULL != papwszOut)
    {
        for (i = 0; i < cpwsz; i++)
        {
            if (papwszOut[i])
            {
                LocalFree(papwszOut[i]);
            }
        }
        LocalFree(papwszOut);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CreateRevocationExtension
//
// Return S_OK if extension has been constructed.
// Return S_FALSE if empty section detected in INF file
// Return other error if no section detected in INF file
//+--------------------------------------------------------------------------

HRESULT
CreateRevocationExtension(
    IN HINF hInf,
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN DWORD iCRL,
    IN BOOL fUseDS,
    IN DWORD dwRevocationFlags,
    OUT BOOL *pfCritical,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    HRESULT hr;
    DWORD i;
    WCHAR *pwszzCDP = NULL;
    WCHAR **papwszURL = NULL;
    CRL_DIST_POINTS_INFO CRLDistInfo;
    CRL_DIST_POINT CRLDistPoint;
    CERT_ALT_NAME_INFO *pAltInfo;

    ZeroMemory(&CRLDistPoint, sizeof(CRLDistPoint));
    pAltInfo = &CRLDistPoint.DistPointName.FullName;

    *ppbEncoded = NULL;
    *pcbEncoded = 0;

    hr = E_HANDLE;
    if (INVALID_HANDLE_VALUE != hInf)
    {
	hr = myInfGetCRLDistributionPoints(hInf, pfCritical, &pwszzCDP);
	csiLogInfError(hInf, hr);
    }
    if (S_OK != hr)
    {
	if (S_FALSE == hr)
	{
	    _JumpError2(hr, error, "myInfGetCRLDistributionPoints", hr);
	}
	hr = GetRegCRLDistributionPoints(
				pwszSanitizedName,
				&pwszzCDP);
	_JumpIfError(hr, error, "GetRegCRLDistributionPoints");
    }

    if (0 == (REVEXT_CDPENABLE & dwRevocationFlags))
    {
        hr = S_OK;
        goto error;
    }
    hr = FormatTemplateURLs(
		    pwszSanitizedName,
		    iCert,
		    iCRL,
		    fUseDS,
		    pwszzCDP,
		    &pAltInfo->cAltEntry,
		    &papwszURL);
    _JumpIfError(hr, error, "FormatTemplateURLs");

    CRLDistInfo.cDistPoint = 1;
    CRLDistInfo.rgDistPoint = &CRLDistPoint;

    CRLDistPoint.DistPointName.dwDistPointNameChoice = CRL_DIST_POINT_FULL_NAME;

    pAltInfo->rgAltEntry = (CERT_ALT_NAME_ENTRY *) LocalAlloc(
			LMEM_FIXED | LMEM_ZEROINIT,
			pAltInfo->cAltEntry * sizeof(pAltInfo->rgAltEntry[0]));
    if (NULL == pAltInfo->rgAltEntry)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    for (i = 0; i < pAltInfo->cAltEntry; i++)
    {
        pAltInfo->rgAltEntry[i].pwszURL = papwszURL[i];
        pAltInfo->rgAltEntry[i].dwAltNameChoice = CERT_ALT_NAME_URL;

	DBGPRINT((DBG_SS_CERTLIB, "CDP[%u] = '%ws'\n", i, papwszURL[i]));
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CRL_DIST_POINTS,
		    &CRLDistInfo,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbEncoded,
		    pcbEncoded))
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != pAltInfo->rgAltEntry)
    {
        LocalFree(pAltInfo->rgAltEntry);
    }
    if (NULL != papwszURL)
    {
        for (i = 0; i < pAltInfo->cAltEntry; i++)
        {
            if (NULL != papwszURL[i])
            {
                LocalFree(papwszURL[i]);
            }
        }
        LocalFree(papwszURL);
    }
    if (NULL != pwszzCDP)
    {
	LocalFree(pwszzCDP);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CreateAuthorityInformationAccessExtension
//
// Return S_OK if extension has been constructed.
// Return S_FALSE if empty section detected in INF file
// Return other error if no section detected in INF file
//+--------------------------------------------------------------------------

HRESULT
CreateAuthorityInformationAccessExtension(
    IN HINF hInf,
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN DWORD iCRL,
    IN BOOL fUseDS,
    OUT BOOL *pfCritical,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    HRESULT hr;
    DWORD i;
    WCHAR *pwszzAIA = NULL;
    WCHAR **papwszURL = NULL;
    CERT_AUTHORITY_INFO_ACCESS caio;

    caio.cAccDescr = 0;
    caio.rgAccDescr = NULL;

    *ppbEncoded = NULL;
    *pcbEncoded = 0;

    hr = E_HANDLE;
    if (INVALID_HANDLE_VALUE != hInf)
    {
	hr = myInfGetAuthorityInformationAccess(hInf, pfCritical, &pwszzAIA);
	csiLogInfError(hInf, hr);
    }
    _JumpIfError3(
	    hr,
	    error,
	    "myInfGetAuthorityInformationAccess",
	    E_HANDLE,
	    S_FALSE);

    hr = FormatTemplateURLs(
		    pwszSanitizedName,
		    iCert,
		    iCRL,
		    fUseDS,
		    pwszzAIA,
		    &caio.cAccDescr,
		    &papwszURL);
    _JumpIfError(hr, error, "FormatTemplateURLs");

    caio.rgAccDescr = (CERT_ACCESS_DESCRIPTION *) LocalAlloc(
			LMEM_FIXED | LMEM_ZEROINIT,
			caio.cAccDescr * sizeof(CERT_ACCESS_DESCRIPTION));
    if (NULL == caio.rgAccDescr)
    {
        hr = E_OUTOFMEMORY;
	_JumpIfError(hr, error, "LocalAlloc");
    }

    for (i = 0; i < caio.cAccDescr; i++)
    {
	caio.rgAccDescr[i].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
	caio.rgAccDescr[i].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
	caio.rgAccDescr[i].AccessLocation.pwszURL = papwszURL[i];

	DBGPRINT((DBG_SS_CERTLIB, "AIA[%u] = '%ws'\n", i, papwszURL[i]));
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_AUTHORITY_INFO_ACCESS,
		    &caio,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbEncoded,
		    pcbEncoded))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "myEncodeObject");
    }

error:
    if (NULL != caio.rgAccDescr)
    {
	LocalFree(caio.rgAccDescr);
    }
    if (NULL != papwszURL)
    {
        for (i = 0; i < caio.cAccDescr; i++)
        {
            if (NULL != papwszURL[i])
            {
                LocalFree(papwszURL[i]);
            }
        }
        LocalFree(papwszURL);
    }
    if (NULL != pwszzAIA)
    {
	LocalFree(pwszzAIA);
    }
    return(hr);
}


HRESULT
FillRDN(
    IN char const *pszObjId,
    IN WCHAR const *pwszRDN,
    IN OUT CERT_RDN *prgRDN)
{
    HRESULT hr;
    CERT_RDN_ATTR *prgAttr = NULL;

    prgAttr = (CERT_RDN_ATTR *) LocalAlloc(LMEM_FIXED, sizeof(*prgAttr));
    if (NULL == prgAttr)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    prgAttr->pszObjId = const_cast<char *>(pszObjId);
    prgAttr->dwValueType = 0;
    prgAttr->Value.pbData = (BYTE *) pwszRDN;
    prgAttr->Value.cbData = 0;

    prgRDN->cRDNAttr = 1;
    prgRDN->rgRDNAttr = prgAttr;

    hr = S_OK;

error:
    return(hr);
}


VOID
csiFreeCertNameInfo(
    CERT_NAME_INFO *pNameInfo)
{
    DWORD iRDN;

    if (NULL != pNameInfo)
    {
        if (NULL != pNameInfo->rgRDN)
        {
            for (iRDN = 0; iRDN < pNameInfo->cRDN; ++iRDN)
            {
                if (NULL != pNameInfo->rgRDN[iRDN].rgRDNAttr)
                {
                    LocalFree(pNameInfo->rgRDN[iRDN].rgRDNAttr);
                }
            }
            LocalFree(pNameInfo->rgRDN);
        }
        LocalFree(pNameInfo);
    }
}





HRESULT
FillExtension(
   IN OUT CERT_EXTENSION  *pDesExt,
   IN OUT DWORD           *pdwIndex,
   IN     CERT_EXTENSION  *pSrcExt)
{
   CSASSERT(NULL != pDesExt && NULL != pSrcExt);

   if (NULL != pSrcExt->Value.pbData && 0 != pSrcExt->Value.cbData)
   {
        pDesExt[*pdwIndex].pszObjId = pSrcExt->pszObjId;
        pDesExt[*pdwIndex].fCritical = pSrcExt->fCritical;
        pDesExt[*pdwIndex].Value = pSrcExt->Value;
        ++(*pdwIndex);
   }
   return(S_OK);
}


HRESULT
EncodeCertAndSign(
    IN HCRYPTPROV hProv,
    IN CERT_INFO *pCert,
    IN char const *pszAlgId,
    OUT BYTE **ppbSigned,
    OUT DWORD *pcbSigned,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd)
{
    HRESULT hr;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    
    *ppbSigned = NULL;
    if (!myEncodeToBeSigned(
		    X509_ASN_ENCODING,
		    pCert,
		    CERTLIB_USE_LOCALALLOC,
		    &pbEncoded,
		    &cbEncoded))
    {
        hr = myHLastError();
        CertErrorMessageBox(
		    hInstance,
		    fUnattended,
		    hwnd,
		    IDS_ERR_ENCODETOBESIGNED,
		    hr,
		    NULL);
	_JumpError(hr, error, "myEncodeToBeSigned");
    }

    hr = myEncodeSignedContent(
			hProv,
			X509_ASN_ENCODING,
			pszAlgId,
			pbEncoded,
			cbEncoded,
			CERTLIB_USE_LOCALALLOC,
			ppbSigned,
			pcbSigned);
    _JumpIfError(hr, error, "myEncodeSignedContent");

error:
    if (NULL != pbEncoded)
    {
        LocalFree(pbEncoded);
    }
    return(hr);
}


HRESULT
EncodeCACert(
    IN CASERVERSETUPINFO const *pSetupInfo,
    IN HCRYPTPROV hProv,
    IN const WCHAR *pwszCAType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd)
{
    HRESULT hr = E_FAIL;
    BYTE *pbSubjectEncoded = NULL;
    DWORD cbSubjectEncoded = 0;
    BYTE *pbIssuerEncoded = NULL;
    DWORD cbIssuerEncoded = 0;
    CERT_PUBLIC_KEY_INFO *pPubKey = NULL;
    DWORD cbPubKey;
    HINF hInf = INVALID_HANDLE_VALUE;
    DWORD ErrorLine;
    DWORD cExtInf = 0;
    CERT_EXTENSION *rgExtInf = NULL;
    DWORD cExtMerged;
    CERT_EXTENSION *rgExtMerged = NULL;

    CERT_EXTENSIONS     *pStdExts = NULL;
    CERT_EXTENSION      *pAllExts = NULL;
    CERT_EXTENSION      extKeyUsage = 
                        {szOID_KEY_USAGE,                 FALSE, 0, NULL};
    CERT_EXTENSION      extBasicConstraints = 
                        {NULL,        			  FALSE, 0, NULL};
    CERT_EXTENSION      extAKI = 
                        {szOID_AUTHORITY_KEY_IDENTIFIER2, FALSE, 0, NULL};
    CERT_EXTENSION      extSKI = 
                        {szOID_SUBJECT_KEY_IDENTIFIER,    FALSE, 0, NULL};
    CERT_EXTENSION      extCDP = 
                        {szOID_CRL_DIST_POINTS,           FALSE, 0, NULL};
    CERT_EXTENSION      extCCDP = 
			{szOID_CROSS_CERT_DIST_POINTS,    FALSE, 0, NULL};
    CERT_EXTENSION      extVersion = 
                        {szOID_CERTSRV_CA_VERSION,        FALSE, 0, NULL};
    CERT_EXTENSION      extPolicy = 
                        {szOID_CERT_POLICIES,		  FALSE, 0, NULL};
    CERT_EXTENSION      extAIA = 
                        {szOID_AUTHORITY_INFO_ACCESS,     FALSE, 0, NULL};
    CERT_EXTENSION      extEKU = 
                        {NULL,				  FALSE, 0, NULL};
#ifdef USE_NETSCAPE_TYPE_EXTENSION
    CERT_EXTENSION      extNetscape = 
                        {szOID_NETSCAPE_CERT_TYPE,        FALSE, 0, NULL};
#endif
    DWORD               cExtension;
    HCERTTYPE           hCertType = NULL;
    DWORD               i;
    DWORD               j;

    GUID guidSerialNumber;
    CERT_INFO Cert;

    *ppbEncoded = NULL;

    hr = myInfOpenFile(NULL, &hInf, &ErrorLine);
    _PrintIfError2(
	    hr,
	    "myInfOpenFile",
	    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    if (INVALID_HANDLE_VALUE != hInf)
    {
	BOOL fUTF8;
	
	hr = myInfGetBooleanValue(
			hInf,
			wszINFSECTION_CERTSERVER,
			wszINFKEY_UTF8,
			TRUE,
			&fUTF8);
	csiLogInfError(hInf, hr);
	if (S_OK == hr)
	{
	    g_dwNameEncodeFlags = fUTF8? CERT_RDN_ENABLE_UTF8_UNICODE_FLAG : 0;
	}
    }

    // SUBJECT

    hr = AddCNAndEncode(
        pSetupInfo->pwszCACommonName,
        pSetupInfo->pwszDNSuffix,
        &pbSubjectEncoded,
        &cbSubjectEncoded);
    _JumpIfError(hr, error, "AddCNAndEncodeCertStrToName");

    // ISSUER

    hr = AddCNAndEncode(
        pSetupInfo->pwszCACommonName,
        pSetupInfo->pwszDNSuffix,
        &pbIssuerEncoded,
        &cbIssuerEncoded);
    _JumpIfError(hr, error, "AddCNAndEncodeCertStrToName");

    if (!myCryptExportPublicKeyInfo(
				hProv,
				AT_SIGNATURE,
				CERTLIB_USE_LOCALALLOC,
				&pPubKey,
				&cbPubKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }

    // get cert type
    hr = CAFindCertTypeByName(
			    pwszCAType, 
                            NULL, 
                            CT_FIND_LOCAL_SYSTEM |
				CT_ENUM_MACHINE_TYPES |
				CT_ENUM_USER_TYPES, 
                            &hCertType);
    if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
    {
	hr = CAFindCertTypeByName(
			    pwszCAType,
			    NULL,
                            CT_FIND_LOCAL_SYSTEM |
				CT_ENUM_MACHINE_TYPES |
				CT_ENUM_USER_TYPES |
				CT_FIND_BY_OID,
			    &hCertType);
    }
    if (S_OK == hr)
    {
        // get cert type standard extensions

        hr = CAGetCertTypeExtensions(hCertType, &pStdExts);
        _JumpIfErrorStr(hr, error, "CAGetCertTypeExtensions", pwszCAType);

        cExtension = pStdExts->cExtension;
    }
    else
    {
        cExtension = 0;
        DBGERRORPRINTLINE("CAFindCertTypeByName", hr);
    }

    if (NULL == pStdExts)
    {
        // standard extensions not available from CAGetCertTypeExtensions
        if (!CreateKeyUsageExtension(
			    myCASIGN_KEY_USAGE,
			    &extKeyUsage.Value.pbData,
			    &extKeyUsage.Value.cbData,
			    hInstance,
			    fUnattended,
			    hwnd))
        {
	    hr = myHLastError();
	    _JumpError(hr, error, "CreateKeyUsageExtension");
        }
        ++cExtension;
    }

    hr = myInfGetBasicConstraints2CAExtensionOrDefault(hInf, &extBasicConstraints);
    csiLogInfError(hInf, hr);
    _JumpIfError(hr, error, "myInfGetBasicConstraints2CAExtensionOrDefault");
    ++cExtension;

    // Subject Key Identifier extension:

    hr = myCreateSubjectKeyIdentifierExtension(
				    pPubKey,
				    &extSKI.Value.pbData,
				    &extSKI.Value.cbData);
    _JumpIfError(hr, error, "myCreateSubjectKeyIdentifierExtension");

    ++cExtension;

    hr = CreateRevocationExtension(
			    hInf,
			    pSetupInfo->pwszSanitizedName,
			    0,			// iCert
			    0,			// iCRL
			    pSetupInfo->fUseDS,
			    pSetupInfo->dwRevocationFlags,
			    &extCDP.fCritical,
			    &extCDP.Value.pbData,
			    &extCDP.Value.cbData);
    _PrintIfError(hr, "CreateRevocationExtension");
    CSASSERT((NULL == extCDP.Value.pbData) ^ (S_OK == hr));
    if (S_OK == hr)
    {
	++cExtension;
    }

    hr = myInfGetCrossCertDistributionPointsExtension(hInf, &extCCDP);
    csiLogInfError(hInf, hr);
    _PrintIfError(hr, "myInfGetCrossCertDistributionPointsExtension");
    CSASSERT((NULL == extCCDP.Value.pbData) ^ (S_OK == hr));
    if (S_OK == hr)
    {
	++cExtension;
    }

    // Build the CA Version extension

    if (!myEncodeObject(
		X509_ASN_ENCODING,
		X509_INTEGER,
		&pSetupInfo->dwCertNameId,
		0,
		CERTLIB_USE_LOCALALLOC,
		&extVersion.Value.pbData,
		&extVersion.Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    ++cExtension;

    hr = myInfGetPolicyStatementExtension(hInf, &extPolicy);
    csiLogInfError(hInf, hr);
    _PrintIfError(hr, "myInfCreatePolicyStatementExtension");
    CSASSERT((NULL == extPolicy.Value.pbData) ^ (S_OK == hr));
    if (S_OK == hr)
    {
	++cExtension;
    }

    hr = CreateAuthorityInformationAccessExtension(
			    hInf,
			    pSetupInfo->pwszSanitizedName,
			    0,			// iCert
			    0,			// iCRL
			    pSetupInfo->fUseDS,
			    &extAIA.fCritical,
			    &extAIA.Value.pbData,
			    &extAIA.Value.cbData);
    _PrintIfError(hr, "CreateAuthorityInformationAccessExtension");
    CSASSERT((NULL == extAIA.Value.pbData) ^ (S_OK == hr));
    if (S_OK == hr)
    {
	++cExtension;
    }

    hr = myInfGetEnhancedKeyUsageExtension(hInf, &extEKU);
    csiLogInfError(hInf, hr);
    _PrintIfError(hr, "myInfGetEnhancedKeyUsageExtension");
    CSASSERT((NULL == extEKU.Value.pbData) ^ (S_OK == hr));
    if (S_OK == hr)
    {
	++cExtension;
    }

#ifdef USE_NETSCAPE_TYPE_EXTENSION
    // Netscape Cert Type extension:
    if (!CreateNetscapeTypeExtension(
		    &extNetscape.Value.pbData,
		    &extNetscape.Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CreateNetscapeTypeExtension");
    }
    ++cExtension;
#endif

    hr = myInfGetExtensions(hInf, &cExtInf, &rgExtInf);
    csiLogInfError(hInf, hr);
    _PrintIfError(hr, "myInfGetExtensions");

    // put all extensions together

    pAllExts = (CERT_EXTENSION *) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    cExtension * sizeof(CERT_EXTENSION));
    if (NULL == pAllExts)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    i = 0;
    if (NULL != pStdExts)
    {
        for (j = 0 ; j < pStdExts->cExtension; j++)
        {
	    if (0 == strcmp(szOID_BASIC_CONSTRAINTS2, pStdExts->rgExtension[j].pszObjId))
	    {
		continue;
	    }
            pAllExts[i].pszObjId = pStdExts->rgExtension[j].pszObjId;
            pAllExts[i].fCritical = pStdExts->rgExtension[j].fCritical;
            pAllExts[i].Value = pStdExts->rgExtension[j].Value;
	    i++;
        }
    }

    FillExtension(pAllExts, &i, &extKeyUsage);
    FillExtension(pAllExts, &i, &extBasicConstraints);
    FillExtension(pAllExts, &i, &extAKI);
    FillExtension(pAllExts, &i, &extSKI);
    FillExtension(pAllExts, &i, &extCDP);
    FillExtension(pAllExts, &i, &extCCDP);
    FillExtension(pAllExts, &i, &extVersion);
    FillExtension(pAllExts, &i, &extPolicy);
    FillExtension(pAllExts, &i, &extAIA);
    FillExtension(pAllExts, &i, &extEKU);

#ifdef USE_NETSCAPE_TYPE_EXTENSION
    FillExtension(pAllExts, &i, &extKeyNetscape);
#endif
    CSASSERT(i <= cExtension);

    // CERT
    ZeroMemory(&Cert, sizeof(Cert));
    Cert.dwVersion = CERT_V3;
    myGenerateGuidSerialNumber(&guidSerialNumber);

    Cert.SerialNumber.pbData = (BYTE *) &guidSerialNumber;
    Cert.SerialNumber.cbData = sizeof(guidSerialNumber);
    Cert.SignatureAlgorithm.pszObjId = pSetupInfo->pszAlgId;
    Cert.Issuer.pbData = pbIssuerEncoded;
    Cert.Issuer.cbData = cbIssuerEncoded;

    GetSystemTimeAsFileTime(&Cert.NotBefore);
    myMakeExprDateTime(
		&Cert.NotBefore,
		-CCLOCKSKEWMINUTESDEFAULT,
		ENUM_PERIOD_MINUTES);
    if (0 < CompareFileTime(&Cert.NotBefore, &pSetupInfo->NotBefore))
    {
	Cert.NotBefore = pSetupInfo->NotBefore;
    }
    Cert.NotAfter = pSetupInfo->NotAfter;

    Cert.Subject.pbData = pbSubjectEncoded;
    Cert.Subject.cbData = cbSubjectEncoded;
    Cert.SubjectPublicKeyInfo = *pPubKey;	// Structure assignment

    Cert.cExtension = i;
    Cert.rgExtension = pAllExts;
    if (0 != cExtInf)
    {
	hr = myMergeExtensions(
			Cert.cExtension,
			Cert.rgExtension,
			cExtInf,
			rgExtInf,
			&cExtMerged,
			&rgExtMerged);
	_JumpIfError(hr, error, "myMergeExtensions");

        Cert.cExtension = cExtMerged;
        Cert.rgExtension = rgExtMerged;
    }
    if (0 == Cert.cExtension)
    {
	Cert.dwVersion = CERT_V1;
    }

    hr = EncodeCertAndSign(
		    hProv,
		    &Cert,
		    pSetupInfo->pszAlgId,
		    ppbEncoded,
		    pcbEncoded,
		    hInstance,
		    fUnattended,
		    hwnd);
    _JumpIfError(hr, error, "EncodeCertAndSign");

error:
    if (INVALID_HANDLE_VALUE != hInf)
    {
	myInfCloseFile(hInf);
    }
    if (NULL != rgExtMerged)
    {
        LocalFree(rgExtMerged);
    }
    myInfFreeExtensions(cExtInf, rgExtInf);
    if (NULL != extKeyUsage.Value.pbData)
    {
        LocalFree(extKeyUsage.Value.pbData);
    }
    if (NULL != extBasicConstraints.Value.pbData)
    {
        LocalFree(extBasicConstraints.Value.pbData);
    }
    if (NULL != extAKI.Value.pbData)
    {
        LocalFree(extAKI.Value.pbData);
    }
    if (NULL != extSKI.Value.pbData)
    {
        LocalFree(extSKI.Value.pbData);
    }
    if (NULL != extCDP.Value.pbData)
    {
        LocalFree(extCDP.Value.pbData);
    }
    if (NULL != extCCDP.Value.pbData)
    {
        LocalFree(extCCDP.Value.pbData);
    }
    if (NULL != extVersion.Value.pbData)
    {
        LocalFree(extVersion.Value.pbData);
    }
    if (NULL != extPolicy.Value.pbData)
    {
        LocalFree(extPolicy.Value.pbData);
    }
    if (NULL != extAIA.Value.pbData)
    {
        LocalFree(extAIA.Value.pbData);
    }
    if (NULL != extEKU.Value.pbData)
    {
        LocalFree(extEKU.Value.pbData);
    }
#ifdef USE_NETSCAPE_TYPE_EXTENSION
    if (NULL != extKeyNetscape.Value.pbData)
    {
        LocalFree(extKeyNetscape.Value.pbData);
    }
#endif
    if (NULL != hCertType)
    {
        if (NULL != pStdExts)
        {
            CAFreeCertTypeExtensions(hCertType, pStdExts);
        }
        CACloseCertType(hCertType);
    }
    if (NULL != pAllExts)
    {
        LocalFree(pAllExts);
    }
    if (NULL != pbSubjectEncoded)
    {
        LocalFree(pbSubjectEncoded);
    }
    if (NULL != pbIssuerEncoded)
    {
        LocalFree(pbIssuerEncoded);
    }
    if (NULL != pPubKey)
    {
        LocalFree(pPubKey);
    }
    CSILOG(hr, IDS_ILOG_BUILDCERT, NULL, NULL, NULL);
    return(hr);
}


HRESULT
csiGetCRLPublicationParams(
    BOOL fBaseCRL,
    WCHAR **ppwszCRLPeriodString,
    DWORD *pdwCRLPeriodCount)
{
    HRESULT hr;
    HINF hInf = INVALID_HANDLE_VALUE;
    DWORD ErrorLine;
    static WCHAR const * const s_apwszKeys[] =
    { 
	wszINFKEY_CRLPERIODSTRING,
	wszINFKEY_CRLDELTAPERIODSTRING,
	wszINFKEY_CRLPERIODCOUNT,
	wszINFKEY_CRLDELTAPERIODCOUNT,
	NULL
    };

    hr = myInfOpenFile(NULL, &hInf, &ErrorLine);
    _JumpIfError2(
	    hr,
            error,
	    "myInfOpenFile",
	    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));


    if (INVALID_HANDLE_VALUE != hInf)
    {
	HRESULT hr2;

	hr = myInfGetCRLPublicationParams(
	    hInf,
	    fBaseCRL? wszINFKEY_CRLPERIODSTRING : wszINFKEY_CRLDELTAPERIODSTRING,
	    fBaseCRL? wszINFKEY_CRLPERIODCOUNT : wszINFKEY_CRLDELTAPERIODCOUNT,
	    ppwszCRLPeriodString, 
	    pdwCRLPeriodCount);

	// log any error, but befre returning the eorror, also log any
	// unexpected Keys in the same INF file section, so the log will
	// describe any Key name typos.

	csiLogInfError(hInf, hr);
	_PrintIfErrorStr(
		    hr,
		    "myInfGetCRLPublicationParams",
		    fBaseCRL? L"Base" : L"Delta");

	hr2 = myInfGetKeyList(
		    hInf,
		    wszINFSECTION_CERTSERVER,
		    NULL,		// pwszKey
		    s_apwszKeys,
		    NULL,		// pfCritical
		    NULL);		// ppwszzTemplateList
	csiLogInfError(hInf, hr2);
	_PrintIfErrorStr(hr2, "myInfGetKeyList", wszINFSECTION_CERTSERVER);

	_JumpIfError(hr, error, "myInfGetCRLPublicationParams");
    } 
    hr = S_OK;

error:
    if (INVALID_HANDLE_VALUE != hInf)
    {
	myInfCloseFile(hInf);
    }
    return hr;
}


HRESULT
csiBuildFileName(
    IN WCHAR const *pwszDirPath,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszExt,
    IN DWORD iCert,
    OUT WCHAR **ppwszOut,
    HINSTANCE hInstance,
    BOOL fUnattended,
    IN HWND hwnd)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwszServerName = NULL;
    WCHAR wszIndex[cwcFILENAMESUFFIXMAX];	// L"(%u)"

    *ppwszOut = NULL;
    wszIndex[0] = L'\0';
    if (0 != iCert)
    {
	wsprintf(wszIndex, L"(%u)", iCert);
    }

    hr = myGetMachineDnsName(&pwszServerName);
    if (S_OK != hr)
    {
	CertErrorMessageBox(
		    hInstance,
		    fUnattended,
		    hwnd,
		    IDS_ERR_GETCOMPUTERNAME,
		    hr,
		    NULL);
	_JumpError(hr, error, "myGetMachineDnsName");
    }

    cwc = wcslen(pwszDirPath) + 
		    WSZARRAYSIZE(g_szSlash) + 
		    wcslen(pwszServerName) + 
		    WSZARRAYSIZE(L"_") + 
		    wcslen(pwszSanitizedName) + 
		    wcslen(wszIndex) + 
		    wcslen(pwszExt) +
		    1;	// NULL term

    *ppwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == *ppwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
	
    wcscpy(*ppwszOut, pwszDirPath);
    wcscat(*ppwszOut, g_szSlash);
    wcscat(*ppwszOut, pwszServerName);
    wcscat(*ppwszOut, L"_");
    wcscat(*ppwszOut, pwszSanitizedName);
    wcscat(*ppwszOut, wszIndex);
    wcscat(*ppwszOut, pwszExt);

    hr = S_OK;

error:
    if (NULL != pwszServerName)
    {
	LocalFree(pwszServerName);
    }
    return(hr);
}


HRESULT
csiBuildCACertFileName(
    IN HINSTANCE             hInstance,
    IN HWND                  hwnd,
    IN BOOL                  fUnattended,
    OPTIONAL IN WCHAR const *pwszSharedFolder,
    IN WCHAR const          *pwszSanitizedName,
    IN WCHAR const          *pwszExt,
    IN DWORD 	             iCert,
    OUT WCHAR              **ppwszCACertFile)
{
    HRESULT   hr;
    WCHAR *pwszCACertFile = NULL;
    WCHAR const *pwszDir = pwszSharedFolder;
    WCHAR *pwszDirAlloc = NULL;

    CSASSERT(NULL != ppwszCACertFile);
    *ppwszCACertFile = NULL;

    if (NULL == pwszDir)
    {
        // no shared folder, go system drive
        hr = myGetEnvString(&pwszDirAlloc, L"SystemDrive");
        _JumpIfError(hr, error, "myGetEnvString");

	pwszDir = pwszDirAlloc;
    }
    // build ca cert file name here
    hr = csiBuildFileName(
		pwszDir,
		pwszSanitizedName,
		pwszExt,
		iCert,
		&pwszCACertFile,
		hInstance,
		fUnattended,
		hwnd);
    _JumpIfError(hr, error, "csiBuildFileName");

    CSASSERT(NULL != pwszCACertFile);

    *ppwszCACertFile = pwszCACertFile;
    hr = S_OK;

error:
    if (NULL != pwszDirAlloc)
    {
        LocalFree(pwszDirAlloc);
    }
    return(hr);
}


HRESULT
csiBuildAndWriteCert(
    IN HCRYPTPROV hCryptProv,
    IN CASERVERSETUPINFO const *pServer,
    OPTIONAL IN WCHAR const *pwszFile,
    IN WCHAR const *pwszEnrollFile,
    OPTIONAL IN CERT_CONTEXT const *pCertContextFromStore,
    OPTIONAL OUT CERT_CONTEXT const **ppCertContextOut,
    IN WCHAR const *pwszCAType,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd)
{
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_CONTEXT const *pccCA = NULL;
    HRESULT hr;

    if (NULL != ppCertContextOut)
    {
	*ppCertContextOut = NULL;
    }
    if (NULL == pCertContextFromStore)
    {
        // create cert
        hr = EncodeCACert(
		    pServer,
		    hCryptProv, 
		    pwszCAType,
		    &pbEncoded,
		    &cbEncoded,
		    hInstance,
		    fUnattended,
		    hwnd);
        _JumpIfError(hr, error, "EncodeCACert");

        pccCA = CertCreateCertificateContext(
					X509_ASN_ENCODING,
					pbEncoded,
					cbEncoded);
        if (NULL == pccCA)
        {
	    hr = myHLastError();
	    _JumpError(hr, error, "CertCreateCertificateContext");
        }
    }
    else
    {
	pccCA = CertDuplicateCertificateContext(pCertContextFromStore);
	if (NULL == pccCA)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertDuplicateCertificateContext");
	}
    }

    if (NULL != pwszFile && !csiWriteDERToFile(
				    pwszFile,
				    pccCA->pbCertEncoded,
				    pccCA->cbCertEncoded,
				    hInstance,
				    fUnattended,
				    hwnd))
    {
	hr = myHLastError();
	_JumpError(hr, error, "csiWriteDERToFile");
    }

    if (!csiWriteDERToFile(
		pwszEnrollFile,
		pccCA->pbCertEncoded,
		pccCA->cbCertEncoded,
		hInstance,
		fUnattended,
		hwnd))
    {
	hr = myHLastError();
	_JumpError(hr, error, "csiWriteDERToFile(enroll)");
    }

    if (NULL != ppCertContextOut)
    {
	*ppCertContextOut = pccCA;
	pccCA = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pccCA)
    {
	if (!CertFreeCertificateContext(pccCA))
	{
	    HRESULT hr2;

	    hr2 = myHLastError();
	    _PrintError(hr2, "CertFreeCertificateContext");
	    CSASSERT(S_OK == hr2);
	}
    }

    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(hr);
}


HRESULT
IsCACert(
    IN HINSTANCE           hInstance,
    IN BOOL                fUnattended,
    IN HWND                hwnd,
    IN CERT_CONTEXT const *pCert,
    IN ENUM_CATYPES CAType)
{
    HRESULT hr;
    BOOL fCA;
    CERT_EXTENSION *pExt;
    DWORD cb;
    CERT_BASIC_CONSTRAINTS2_INFO Constraints;

    fCA = FALSE;
    hr = S_OK;
    pExt = CertFindExtension(
			szOID_BASIC_CONSTRAINTS2,
			pCert->pCertInfo->cExtension,
			pCert->pCertInfo->rgExtension);
    if (NULL == pExt)
    {
	if (IsRootCA(CAType) && CERT_V1 == pCert->pCertInfo->dwVersion)
	{
	    _PrintError(hr, "V1 root cert");
	    hr = S_OK;
	    goto error;
	}
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_PrintError(hr, "No Basic Constraints Extension");
    }
    else
    {
	cb = sizeof(Constraints);
	if (!CryptDecodeObject(
			    X509_ASN_ENCODING,
			    X509_BASIC_CONSTRAINTS2,
			    pExt->Value.pbData,
			    pExt->Value.cbData,
			    0,
			    &Constraints,
			    &cb))
	{
	    hr = myHLastError();
	    _PrintError(hr, "CryptDecodeObject");
	}
	else
	{
	    fCA = Constraints.fCA;
	    if (!fCA)
	    {
		hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
		_PrintError(hr, "fCA not set");
	    }
	}
    }
    if (!fCA)
    {
	CertMessageBox(
		    hInstance,
		    fUnattended,
		    hwnd,
		    IDS_ERR_NOTCACERT,
		    S_OK,
		    MB_OK | MB_ICONERROR | CMB_NOERRFROMSYS,
		    NULL);
	_JumpError(hr, error, "not a CA cert");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
ExtractCACertFromPKCS7(
    IN WCHAR const                   *pwszCommonName,
    IN BYTE const                    *pbPKCS7,
    IN DWORD                          cbPKCS7,
    OPTIONAL OUT CERT_CONTEXT const **ppccCA)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    HCERTSTORE hChainStore = NULL;
    CRYPT_DATA_BLOB chainBlob;
    CERT_RDN_ATTR rdnAttr = { szOID_COMMON_NAME, CERT_RDN_ANY_TYPE, };
    CERT_RDN rdn = { 1, &rdnAttr };
    CERT_CHAIN_PARA ChainPara;
    CERT_CHAIN_CONTEXT const *pChainContext = NULL;
    CERT_CHAIN_CONTEXT const *pLongestChainContext = NULL;
    
    *ppccCA = NULL;
    if (NULL == pbPKCS7 || 0 == cbPKCS7)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Invalid input parameters");
    }
    
    chainBlob.pbData = const_cast<BYTE *>(pbPKCS7);
    chainBlob.cbData = cbPKCS7;
    hChainStore = CertOpenStore(
			    CERT_STORE_PROV_PKCS7,
			    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			    NULL,		// hProv
			    0,
			    (const void*) &chainBlob);
    if (NULL == hChainStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }
    
    rdnAttr.Value.pbData = (BYTE *) pwszCommonName;
    rdnAttr.Value.cbData = 0;
    
    // Find the longest chain in the passed PKCS7 with a leaf CA cert that
    // matches the passed common name
    
    for (;;)
    {
        pCert = CertFindCertificateInStore(
				hChainStore,
				X509_ASN_ENCODING,
				CERT_UNICODE_IS_RDN_ATTRS_FLAG |
				    CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG,
				CERT_FIND_SUBJECT_ATTR,
				&rdn,
				pCert);
        if (NULL == pCert)
        {
            if (NULL == pLongestChainContext)
            {
                hr = E_INVALIDARG;
                _JumpError(hr, error, "can't find matched cert in chain");
            }
            break;	// most common case, done here
        }

	ZeroMemory(&ChainPara, sizeof(ChainPara));
	ChainPara.cbSize = sizeof(CERT_CHAIN_PARA);
	ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
	//ChainPara.RequestedUsage.Usage.cUsageIdentifier = 0;
	//ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = NULL;
    
        if (!CertGetCertificateChain(
				HCCE_LOCAL_MACHINE,
				pCert,
				NULL,
				hChainStore,
				&ChainPara,
				0,
				NULL,
				&pChainContext))
        {
            // couldn't get the chain
            
            if (NULL == pLongestChainContext)
            {
                // fail to find a chain
                hr = myHLastError();
                _JumpError(hr, error, "CertGetCertificateChain");
            }
            break;	// done with it
        }

        // we have assumed each chain context contains
        // only one simple chain, ie. pChainContext->cChain = 1
        CSASSERT(1 == pChainContext->cChain);
            
        if (NULL == pLongestChainContext ||
            pChainContext->rgpChain[0]->cElement >
		pLongestChainContext->rgpChain[0]->cElement)
        {
            if (NULL != pLongestChainContext)
            {
                CertFreeCertificateChain(pLongestChainContext);
            }
            
            // save pointer to this chain

            pLongestChainContext = pChainContext;
        }
        else
        {
            CertFreeCertificateChain(pChainContext);
        }
    }
    CSASSERT(NULL == pCert);
    if (NULL != pLongestChainContext &&
	0 < pLongestChainContext->rgpChain[0]->cElement)
    {
	*ppccCA = CertDuplicateCertificateContext(
	    pLongestChainContext->rgpChain[0]->rgpElement[0]->pCertContext);
	if (NULL == *ppccCA)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertDuplicateCertificateContext");
	}
    }
    hr = S_OK;

error:
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    if (NULL != pLongestChainContext)
    {
        CertFreeCertificateChain(pLongestChainContext);
    }
    if (hChainStore)
    {
        CertCloseStore(hChainStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    CSILOG(hr, IDS_ILOG_SAVECHAINANDKEYS, pwszCommonName, NULL, NULL);
    return(hr);
}


#define ENTERPRISECATEMPLATELIST \
    wszCERTTYPE_ADMIN, \
    wszCERTTYPE_SUBORDINATE_CA, \
    wszCERTTYPE_USER, \
    wszCERTTYPE_MACHINE, \
    wszCERTTYPE_WEBSERVER, \
    wszCERTTYPE_DC, \
    wszCERTTYPE_EFS, \
    wszCERTTYPE_EFS_RECOVERY

WCHAR *s_apwszCertTypeServer[] =
{
    ENTERPRISECATEMPLATELIST,
    NULL
};

WCHAR *s_apwszCertTypeAdvancedServer[] =
{
    ENTERPRISECATEMPLATELIST,
    wszCERTTYPE_DC_AUTH,
    wszCERTTYPE_DS_EMAIL_REPLICATION,
    NULL
};

WCHAR *s_apwszCertTypeEmpty[] = 
{
    L" ",
    NULL
};


HRESULT
GetValidCRLIndexes(
    IN  LPCWSTR pwszSanitizedCAName,
    OUT DWORD **ppdwCRLIndexes,
    OUT DWORD *pnCRLIndexes)
{
    HRESULT hr;
    DWORD dwHashCount;
    HCERTSTORE hMyStore = NULL;
    CERT_CONTEXT const *pccCert = NULL;
    DWORD NameId;
    DWORD nCRLIndexes;
    DWORD *pdwCRLIndexes = NULL;

    *ppdwCRLIndexes = NULL;
    *pnCRLIndexes = 0;

    hr = myGetCARegHashCount(pwszSanitizedCAName, CSRH_CASIGCERT, &dwHashCount);
    _JumpIfError(hr, error, "myGetCARegHashCount");

    pdwCRLIndexes = (DWORD *) LocalAlloc(LMEM_FIXED, dwHashCount*sizeof(DWORD));
    _JumpIfAllocFailed(pdwCRLIndexes, error);

    hMyStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_W,
			X509_ASN_ENCODING,
			NULL,                    // hProv
			CERT_SYSTEM_STORE_LOCAL_MACHINE |
			    CERT_STORE_READONLY_FLAG |
			    CERT_STORE_ENUM_ARCHIVED_FLAG,
			wszMY_CERTSTORE);
    if (NULL == hMyStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    for(DWORD dwCount=0; dwCount<dwHashCount; dwCount++)
    {
        hr = myFindCACertByHashIndex(
                                hMyStore,
                                pwszSanitizedCAName,
                                CSRH_CASIGCERT,
                                dwCount,
                                &NameId,
                                &pccCert);
        if (S_FALSE == hr)
        {
            continue;
        }
        _JumpIfError(hr, error, "myFindCACertByHashIndex");

        if (MAXDWORD==NameId)
        {
            pdwCRLIndexes[dwCount] = dwCount;
        }
        else
        {
            pdwCRLIndexes[dwCount] = CANAMEIDTOIKEY(NameId);
        }

        CertFreeCertificateContext(pccCert);
        pccCert = NULL;
    }

    // The index list looks like this: 0 1 2 2 3 4 5 5 5 6. Compact it
    // in place, eliminating duplicates.
    nCRLIndexes = 0;
    for(DWORD dwCount=0; dwCount<dwHashCount;dwCount++)
    {
        if(dwCount>0 && 
           pdwCRLIndexes[dwCount] == pdwCRLIndexes[dwCount-1])
        {
            continue;
        }
        
        pdwCRLIndexes[nCRLIndexes] = pdwCRLIndexes[dwCount];

        nCRLIndexes++;
    }

    *pnCRLIndexes = nCRLIndexes;
    *ppdwCRLIndexes = pdwCRLIndexes;
    hr = S_OK;

error:
    if(S_OK != hr && 
       NULL != pdwCRLIndexes)
    {
        LocalFree(pdwCRLIndexes);
    }
    if(NULL != pccCert)
    {
        CertFreeCertificateContext(pccCert);
    }
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return hr;
}


HRESULT
CreateCDPAndAIAAndKRAEntry(
    IN WCHAR const *pwszSanitizedCAName,
    IN WCHAR const *pwszServerName,
    IN DWORD iCert,
    IN DWORD iCRL,
    IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN PSECURITY_DESCRIPTOR pSD,
    IN PSECURITY_DESCRIPTOR pContainerSD)
{
    HRESULT hr;
    LDAP *pld = NULL;
    BSTR strConfigDN = NULL;
    BSTR strDomainDN = NULL;
    WCHAR *pwszCDPDN = NULL;
    WCHAR *pwszAIADN;
    WCHAR *pwszKRADN;
    WCHAR const *apwszIn[2];
    WCHAR *apwszOut[2];
    DWORD i;
    DWORD dwDisp;
    WCHAR *pwszError = NULL;
    DWORD *pdwCRLIndexes = NULL;
    DWORD nCRLIndexes;

    ZeroMemory(apwszOut, sizeof(apwszOut));

    hr = myLdapOpen(
		NULL,		// pwszDomainName
		RLBF_REQUIRE_SECURE_LDAP, // dwFlags
		&pld,
		&strDomainDN,
		&strConfigDN);
    _JumpIfError(hr, error, "myLdapOpen");

    DBGPRINT((DBG_SS_CERTLIBI, "DomainDN='%ws'\n", strDomainDN));
    DBGPRINT((DBG_SS_CERTLIBI, "ConfigDN='%ws'\n", strConfigDN));

    //+=====================================================================
    // Create the CDP container and objects:

    hr = GetValidCRLIndexes(
        pwszSanitizedCAName,
        &pdwCRLIndexes,
        &nCRLIndexes);
    _JumpIfError(hr, error, "GetValidCRLIndexes");

    apwszIn[0] = g_wszCDPDNTemplate;

    for(DWORD dwCount=0; dwCount<nCRLIndexes; dwCount++)
    {
        hr = myFormatCertsrvStringArray(
            FALSE,              // fURL
            pwszServerName,     // pwszServerName_p1_2
            pwszSanitizedCAName,// pwszSanitizedName_p3_7
            iCert,              // iCert_p4
	    MAXDWORD,		// iCertTarget_p4
            strDomainDN,        // pwszDomainDN_p5
            strConfigDN,        // pwszConfigDN_p6
            pdwCRLIndexes[dwCount], // iCRL_p8
            FALSE,              // fDeltaCRL_p9
            FALSE,              // fDSAttrib_p10_11
            1,                  // cStrings
            (LPCWSTR *) apwszIn,// apwszStringsIn
            apwszOut);          // apwszStringsOut
        _JumpIfError(hr, error, "myFormatCertsrvStringArray");

        // attemp to create container just once
        if(0==dwCount)
        {
            hr = myLdapCreateContainer(
                pld,
                apwszOut[0],
                TRUE,
                1,
                pContainerSD,
                &pwszError);
            _JumpIfError(hr, error, "myLdapCreateContainer");

            CSASSERT(NULL == pwszError);
        }

        DBGPRINT((DBG_SS_CERTLIBI, "CDPDN='%ws'\n", apwszOut[0]));

        hr = myLdapCreateCDPObject(pld, apwszOut[0], pSD, &dwDisp, &pwszError);
        _JumpIfErrorStr(hr, error, "myLdapCreateCDPObject", apwszOut[0]);

        CSASSERT(NULL == pwszError);

        LocalFree(apwszOut[0]);
        apwszOut[0] = NULL;
    }

    //+=====================================================================
    // Create the KRA and AIA containers and objects

    apwszIn[0] = g_wszAIADNTemplate;
    apwszIn[1] = g_wszKRADNTemplate;

    // Format the KRA and AIA templates into real names

    hr = myFormatCertsrvStringArray(
		    FALSE,			// fURL
		    pwszServerName,		// pwszServerName_p1_2
		    pwszSanitizedCAName,	// pwszSanitizedName_p3_7
		    iCert,			// iCert_p4
		    MAXDWORD,			// iCertTarget_p4
		    strDomainDN,		// pwszDomainDN_p5
		    strConfigDN,		// pwszConfigDN_p6
		    iCRL,			// iCRL_p8
		    FALSE,			// fDeltaCRL_p9
		    FALSE,			// fDSAttrib_p10_11
		    ARRAYSIZE(apwszIn),		// cStrings
		    (LPCWSTR *) apwszIn,	// apwszStringsIn
		    apwszOut);			// apwszStringsOut
    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

    pwszAIADN = apwszOut[0];
    pwszKRADN = apwszOut[1];


    DBGPRINT((DBG_SS_CERTLIBI, "AIADN='%ws'\n", pwszAIADN));
    DBGPRINT((DBG_SS_CERTLIBI, "KRADN='%ws'\n", pwszKRADN));

    //+=====================================================================
    // Create the container and AIA object:

    hr = myLdapCreateContainer(
			pld,
			pwszAIADN,
			TRUE,
			0,
			pContainerSD,
			&pwszError);
    _JumpIfError(hr, error, "myLdapCreateContainer");

    CSASSERT(NULL == pwszError);

    hr = myLdapCreateCAObject(
			pld,
			pwszAIADN,
			pbCert,
			cbCert,
			pSD,
			&dwDisp,
			&pwszError);
    _JumpIfErrorStr(hr, error, "myLdapCreateCAObject", pwszAIADN);

    hr = myLdapFilterCertificates(
            pld,
            pwszAIADN,
            wszDSCACERTATTRIBUTE,
            &dwDisp,
            &pwszError);
    _JumpIfErrorStr(hr, error, "myLdapFilterCertificates", pwszAIADN);


    CSASSERT(NULL == pwszError);


    //+=====================================================================
    // Create the KRA container and object:

    hr = myLdapCreateContainer(
			pld,
			pwszKRADN,
			TRUE,
			0,
			pContainerSD,
			&pwszError);
    _JumpIfError(hr, error, "myLdapCreateContainer");

    CSASSERT(NULL == pwszError);

    hr = myLdapCreateUserObject(
			    pld,
			    pwszKRADN,
			    NULL,
			    0,
			    pSD,
			    LPC_KRAOBJECT,
			    &dwDisp,
			    &pwszError);
    //_JumpIfErrorStr(hr, error, "myLdapCreateUserObject", pwszKRADN);
    _PrintIfErrorStr(hr, "myLdapCreateUserObject", pwszKRADN);
    CSASSERT(S_OK == hr || NULL != pwszError);
    hr = S_OK;

error:
    CSILOG(hr, IDS_ILOG_CREATECDP, pwszCDPDN, pwszError, NULL);
    if (NULL != pdwCRLIndexes)
    {
        LocalFree(pdwCRLIndexes);
    }
    if (NULL != pwszError)
    {
        LocalFree(pwszError);
    }
    for (i = 0; i < ARRAYSIZE(apwszOut); i++)
    {
	if (NULL != apwszOut[i])
	{
	    LocalFree(apwszOut[i]);
	}
    }
    myLdapClose(pld, strDomainDN, strConfigDN);
    return(hr);
}


HRESULT
CreateEnterpriseAndRootEntry(
    IN WCHAR const *pwszSanitizedDSName,
    IN CERT_CONTEXT const *pccPublish,
    IN ENUM_CATYPES caType,
    IN PSECURITY_DESCRIPTOR pSD,
    IN PSECURITY_DESCRIPTOR pContainerSD)
{
    HRESULT hr;
    LDAP *pld = NULL;
    BSTR strConfig = NULL;
    BSTR strDomainDN = NULL;
    WCHAR *pwszRootDN = NULL;
    WCHAR *pwszEnterpriseDN = NULL;
    PSECURITY_DESCRIPTOR pNTAuthSD = NULL;
    DWORD cwc;
    DWORD dwDisp;
    WCHAR *pwszError = NULL;

    if (!IsEnterpriseCA(caType) && !IsRootCA(caType))
    {
        hr = S_OK;
	goto error;
    }
    hr = myLdapOpen(
		NULL,		// pwszDomainName
		RLBF_REQUIRE_SECURE_LDAP, // dwFlags
		&pld,
		&strDomainDN,
		&strConfig);
    _JumpIfError(hr, error, "myLdapOpen");

    cwc = WSZARRAYSIZE(L"CN=") +
		     wcslen(pwszSanitizedDSName) +
		     WSZARRAYSIZE(s_wszRootCAs) +
		     wcslen(strConfig);
    pwszRootDN = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (pwszRootDN == NULL)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszRootDN, L"CN=");
    wcscat(pwszRootDN, pwszSanitizedDSName);
    wcscat(pwszRootDN, s_wszRootCAs);
    wcscat(pwszRootDN, strConfig);
    CSASSERT(wcslen(pwszRootDN) == cwc);

    cwc = wcslen(s_wszEnterpriseCAs) + wcslen(strConfig);
    pwszEnterpriseDN = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwc + 1) * sizeof(WCHAR));
    if (pwszEnterpriseDN == NULL)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszEnterpriseDN, s_wszEnterpriseCAs);
    wcscat(pwszEnterpriseDN, strConfig);
    CSASSERT(wcslen(pwszEnterpriseDN) == cwc);

    //+=====================================================================
    // Create the root trust CA container and entry (Root only):

    if (IsRootCA(caType))
    {
	DBGPRINT((DBG_SS_CERTLIBI, "Creating Services Containers: '%ws'\n", pwszRootDN));
	hr = myLdapCreateContainer(
			    pld,
			    pwszRootDN,
			    TRUE,
			    1,
			    pContainerSD,
			    &pwszError);
	_JumpIfError(hr, error, "myLdapCreateContainer");

	CSASSERT(NULL == pwszError);

	DBGPRINT((DBG_SS_CERTLIBI, "Creating DS Root Trust: '%ws'\n", pwszRootDN));
	hr = myLdapCreateCAObject(
			    pld,
			    pwszRootDN,
			    pccPublish->pbCertEncoded,
			    pccPublish->cbCertEncoded,
			    pSD,
			    &dwDisp,
			    &pwszError);
	_JumpIfErrorStr(hr, error, "myLdapCreateCAObject", pwszRootDN);
    }

    //+=====================================================================
    // Create the NTAuth trust entry (Enterprise only):

    if (IsEnterpriseCA(caType))
    {
        DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "Creating DS Enterprise Trust: '%ws'\n",
	    pwszEnterpriseDN));

        hr = myGetSDFromTemplate(WSZ_DEFAULT_NTAUTH_SECURITY, NULL, &pNTAuthSD);
        _JumpIfError(hr, error, "myGetSDFromTemplate");

	hr = myLdapCreateCAObject(
			    pld,
			    pwszEnterpriseDN,
			    NULL,
			    0,
			    pNTAuthSD,
			    &dwDisp,
			    &pwszError);
	_JumpIfErrorStr(hr, error, "myLdapCreateCAObject", pwszEnterpriseDN);

	hr = AddCertToAttribute(
			    pld,
			    pccPublish,
			    pwszEnterpriseDN,
			    wszDSCACERTATTRIBUTE,
			    FALSE,	// fDelete
			    &dwDisp,
			    &pwszError);
	_JumpIfErrorStr(hr, error, "AddCertToAttribute", pwszEnterpriseDN);

        CSILOG(S_OK, IDS_ILOG_CREATENTAUTHTRUST, pwszEnterpriseDN, NULL, NULL);
    }

error:
    CSILOG(hr, IDS_ILOG_CREATEROOTTRUST, pwszRootDN, pwszError, NULL);
    if (NULL != pwszError)
    {
        LocalFree(pwszError);
    }
    if (NULL != pwszEnterpriseDN)
    {
        LocalFree(pwszEnterpriseDN);
    }
    if (NULL != pwszRootDN)
    {
        LocalFree(pwszRootDN);
    }
    myLdapClose(pld, strDomainDN, strConfig);
    if (NULL != pNTAuthSD)
    {
        LocalFree(pNTAuthSD);
    }
    return(hr);
}


#define wszCOLON	L":"

// Suppress FILE URLs if a DS is available, as LDAP access within the
// enterprise should suffice, and http: should work outside the enterprise.
// Certs with too many URLs don't always fit on smart cards.

#define wszCRLPATHDEFAULT \
		wszCERTENROLLSHAREPATH \
		L"\\" \
		wszFCSAPARM_SANITIZEDCANAME \
		wszFCSAPARM_CRLFILENAMESUFFIX \
		wszFCSAPARM_CRLDELTAFILENAMESUFFIX \
		L".crl"

CSURLTEMPLATE const s_aRevURL[] = {
    {
	CSURL_SERVERPUBLISH | CSURL_SERVERPUBLISHDELTA | CSURL_ADDSYSTEM32DIR,
	wszCRLPATHDEFAULT,
    },
    {
	CSURL_SERVERPUBLISH | CSURL_SERVERPUBLISHDELTA | CSURL_ADDTOCERTCDP | CSURL_ADDTOFRESHESTCRL | CSURL_ADDTOCRLCDP | CSURL_DSONLY,
	const_cast<WCHAR *>(g_wszzLDAPRevocationURLTemplate),
    },
    {
	CSURL_ADDTOCERTCDP | CSURL_ADDTOFRESHESTCRL,
	const_cast<WCHAR *>(g_wszHTTPRevocationURLTemplate),
    },
    {
	CSURL_ADDTOCERTCDP | CSURL_ADDTOFRESHESTCRL | CSURL_NODS,
	const_cast<WCHAR *>(g_wszFILERevocationURLTemplate),
    },
#if 0
    {
	CSURL_SERVERPUBLISH | CSURL_SERVERPUBLISHDELTA | CSURL_DSONLY,
	const_cast<WCHAR *>(g_wszCDPDNTemplate),
    },
#endif
    { 0, NULL }
};


#define wszCACERTPATHDEFAULT \
		wszCERTENROLLSHAREPATH \
		L"\\" \
		wszFCSAPARM_SERVERDNSNAME \
		L"_" \
		wszFCSAPARM_SANITIZEDCANAME \
		wszFCSAPARM_CERTFILENAMESUFFIX \
		L".crt"

CSURLTEMPLATE const s_aCACertURL[] = {
    {
	CSURL_SERVERPUBLISH | CSURL_ADDSYSTEM32DIR,
	wszCACERTPATHDEFAULT,
    },
    {
	CSURL_SERVERPUBLISH | CSURL_ADDTOCERTCDP | CSURL_DSONLY,
	const_cast<WCHAR *>(g_wszzLDAPIssuerCertURLTemplate),
    },
    {
	CSURL_ADDTOCERTCDP,
	const_cast<WCHAR *>(g_wszHTTPIssuerCertURLTemplate),
    },
    {
	CSURL_ADDTOCERTCDP | CSURL_NODS,
	const_cast<WCHAR *>(g_wszFILEIssuerCertURLTemplate),
    },
#if 0
    {
	CSURL_SERVERPUBLISH | CSURL_DSONLY,
	const_cast<WCHAR *>(g_wszAIADNTemplate),
    },
#endif
    { 0, NULL }
};

#define CSURL_DSDEPENDENT \
    (CSURL_SERVERPUBLISH | \
     CSURL_SERVERPUBLISHDELTA | \
     CSURL_ADDTOCERTCDP | \
     CSURL_ADDTOFRESHESTCRL)


HRESULT
GetPublicationURLTemplates(
    IN CSURLTEMPLATE const *aTemplate,
    IN BOOL fUseDS,
    IN WCHAR const *pwszSystem32,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;
    WCHAR *pwszz;
    DWORD cwc;
    CSURLTEMPLATE const *pTemplate;
    WCHAR awc[cwcDWORDSPRINTF];
    DWORD Flags;

    *ppwszz = NULL;
    cwc = 1;	// final trailing L'\0'

    for (pTemplate = aTemplate; NULL != pTemplate->pwszURL; pTemplate++)
    {
	Flags = ~CSURL_INITMASK & pTemplate->Flags;
	if ((!fUseDS && (CSURL_DSONLY & pTemplate->Flags)) ||
	    (fUseDS && (CSURL_NODS & pTemplate->Flags)))
	{
	    Flags &= ~CSURL_DSDEPENDENT;
	}
	cwc += wsprintf(awc, L"%u", Flags);
	cwc += WSZARRAYSIZE(wszCOLON);
	if (CSURL_ADDSYSTEM32DIR & pTemplate->Flags)
	{
	    cwc += wcslen(pwszSystem32);
	}
	cwc += wcslen(pTemplate->pwszURL);
	cwc += 1;	// trailing L'\0'
    }

    pwszz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *ppwszz = pwszz;

    for (pTemplate = aTemplate; NULL != pTemplate->pwszURL; pTemplate++)
    {
	Flags = ~CSURL_INITMASK & pTemplate->Flags;
	if ((!fUseDS && (CSURL_DSONLY & pTemplate->Flags)) ||
	    (fUseDS && (CSURL_NODS & pTemplate->Flags)))
	{
	    Flags &= ~CSURL_DSDEPENDENT;
	}
	DBGPRINT((
	    DBG_SS_CERTLIB,
	    "URL Template: %x %x:%ws\n",
	    Flags,
	    pTemplate->Flags,
	    pTemplate->pwszURL));

	wsprintf(pwszz, L"%u", Flags);
	wcscat(pwszz, wszCOLON);
	if (CSURL_ADDSYSTEM32DIR & pTemplate->Flags)
	{
	    wcscat(pwszz, pwszSystem32);
	}
	wcscat(pwszz, pTemplate->pwszURL);
	pwszz += wcslen(pwszz) + 1; // skip L'\0'
    }

    *pwszz = L'\0';
    CSASSERT(cwc == (DWORD) (pwszz - *ppwszz + 1));

#ifdef DBG_CERTSRV_DEBUG_PRINT
    {
	DWORD i = 0;
	WCHAR const *pwsz;
	
	for (pwsz = *ppwszz; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"URL Template[%u]: %ws\n",
		i,
		pwsz));
	    i++;
	}
    }
#endif // DBG_CERTSRV_DEBUG_PRINT
    hr = S_OK;

error:
    return(hr);
}


HRESULT
csiGetCRLPublicationURLTemplates(
    IN BOOL fUseDS,
    IN WCHAR const *pwszSystem32,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;

    hr = GetPublicationURLTemplates(s_aRevURL, fUseDS, pwszSystem32, ppwszz);
    _JumpIfError(hr, error, "GetPublicationURLTemplates");

error:
    return(hr);
}


HRESULT
csiGetCACertPublicationURLTemplates(
    IN BOOL fUseDS,
    IN WCHAR const *pwszSystem32,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;

    hr = GetPublicationURLTemplates(s_aCACertURL, fUseDS, pwszSystem32, ppwszz);
    _JumpIfError(hr, error, "GetPublicationURLTemplates");

error:
    return(hr);
}


HRESULT
csiSetupCAInDS(
    IN WCHAR const        *pwszCAServer,
    IN WCHAR const        *pwszSanitizedCAName,
    IN WCHAR const        *pwszCADisplayName,
    IN BOOL                fLoadDefaultTemplates,
    IN ENUM_CATYPES        caType,
    IN DWORD               iCert,
    IN DWORD               iCRL,
    IN BOOL                fRenew,
    IN CERT_CONTEXT const *pCert)
{
    HRESULT      hr;
    HCAINFO      hCAInfo = NULL;
    WCHAR       *pCAProp[2];
    WCHAR       *pCertSubjectString = NULL;
    
    CAutoLPWSTR  wszNameBuffer;
    WCHAR        wszDomainNameBuffer[MAX_PATH];
    DWORD        cDomainNameBuffer;
    DWORD        cbSid;
    BYTE         pSid[MAX_SID_LEN];
    SID_NAME_USE SidUse;
    WCHAR       *pwszStringSid = NULL;
    PSECURITY_DESCRIPTOR pContainerSD = NULL;
    PSECURITY_DESCRIPTOR pCDPSD = NULL;

    CERT_CONTEXT const *pCertForDS = NULL;
    WCHAR *pwszSanitizedDSName = NULL;

    hr = mySanitizedNameToDSName(pwszSanitizedCAName, &pwszSanitizedDSName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    // Get the SID of the local machine.

    hr = myGetComputerObjectName(NameSamCompatible, &wszNameBuffer);
    _JumpIfError(hr, error, "myGetComputerObjectName");

    DBGPRINT((DBG_SS_CERTLIB, "GetComputerObjectName: '%ws'\n", wszNameBuffer));

    cbSid = sizeof(pSid);
    cDomainNameBuffer = ARRAYSIZE(wszDomainNameBuffer);

    if (!LookupAccountName(NULL,
                          wszNameBuffer,
                          pSid,
                          &cbSid,
                          wszDomainNameBuffer,
                          &cDomainNameBuffer,
                          &SidUse))
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "LookupAccountName", wszNameBuffer);
    }

    if (!myConvertSidToStringSid(pSid, &pwszStringSid))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myConvertSidToStringSid");
    }

    // get default DS CDP security descriptor
    hr = myGetSDFromTemplate(WSZ_DEFAULT_CDP_DS_SECURITY,
                             pwszStringSid,
                             &pCDPSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    // get default DS AIA security descriptor
    hr = myGetSDFromTemplate(WSZ_DEFAULT_CA_DS_SECURITY,
                             NULL,
                             &pContainerSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    hr = CreateEnterpriseAndRootEntry(
				pwszSanitizedDSName,
				pCert,
				caType,
				pContainerSD, 
				pContainerSD);
    _JumpIfError(hr, error, "CreateEnterpriseAndRootEntry");


    hr = CreateCDPAndAIAAndKRAEntry(
			pwszSanitizedCAName,
			pwszCAServer,
			iCert,
			iCRL,
			pCert->pbCertEncoded,
			pCert->cbCertEncoded,
			pCDPSD,
			pContainerSD);
    _JumpIfError(hr, error, "CreateCDPAndAIAAndKRAEntry");


    // Add enterprise
    // service publish entry

    hr = CAFindByName(
		pwszSanitizedDSName,
		NULL,
		CA_FIND_INCLUDE_UNTRUSTED | CA_FIND_INCLUDE_NON_TEMPLATE_CA,
		&hCAInfo);
    if (S_OK != hr || NULL == hCAInfo)
    {
        hCAInfo = NULL;
	fRenew = FALSE;		// recreate security settings, etc.

        hr = CACreateNewCA(pwszSanitizedDSName, NULL, NULL, &hCAInfo);
	_JumpIfError(hr, error, "CACreateNewCA");

        if (NULL == hCAInfo)
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "hCAInfo(NULL)");
        }
    }

    if (!fRenew)
    {
	pCAProp[0] = const_cast<WCHAR *>(pwszCAServer);
	pCAProp[1] = NULL;
	hr = CASetCAProperty(hCAInfo, CA_PROP_DNSNAME, pCAProp);
	_JumpIfError(hr, error, "CASetCAProperty(CA_PROP_DNSNAME)");

	pCAProp[0] = const_cast<WCHAR *>(pwszCADisplayName);
	pCAProp[1] = NULL;
	hr = CASetCAProperty(hCAInfo, CA_PROP_DISPLAY_NAME, pCAProp);
	_JumpIfError(hr, error, "CASetCAProperty(CA_PROP_DISPLAY_NAME)");

	hr = myCertNameToStr(
			X509_ASN_ENCODING,
			&pCert->pCertInfo->Subject,
			CERT_X500_NAME_STR | CERT_NAME_STR_NO_QUOTING_FLAG,
			&pCertSubjectString);
	_JumpIfError(hr, error, "myCertNameToStr");

	pCAProp[0] = pCertSubjectString;
	pCAProp[1] = NULL;
	hr = CASetCAProperty(hCAInfo, CA_PROP_CERT_DN, pCAProp);
	_JumpIfError(hr, error, "CASetCAProperty(CA_PROP_CERT_DN)");

	switch (caType)
	{
	    case ENUM_ENTERPRISE_ROOTCA:
		hr = CASetCAFlags(hCAInfo, CA_FLAG_SUPPORTS_NT_AUTHENTICATION);
		_JumpIfError(hr, error, "CASetCAFlags");

		break;

	    case ENUM_ENTERPRISE_SUBCA:
		hr = CASetCAFlags(hCAInfo, CA_FLAG_SUPPORTS_NT_AUTHENTICATION);
		_JumpIfError(hr, error, "CASetCAFlags");

		break;

	    case ENUM_STANDALONE_ROOTCA:
		hr = CASetCAFlags(hCAInfo, CA_FLAG_NO_TEMPLATE_SUPPORT | CA_FLAG_CA_SUPPORTS_MANUAL_AUTHENTICATION);
		_JumpIfError(hr, error, "CASetCAFlags");
		break;

	    case ENUM_STANDALONE_SUBCA:
		hr = CASetCAFlags(hCAInfo, CA_FLAG_NO_TEMPLATE_SUPPORT | CA_FLAG_CA_SUPPORTS_MANUAL_AUTHENTICATION);
		_JumpIfError(hr, error, "CASetCAFlags");
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Invalid CA Type");
	}
	if (IsEnterpriseCA(caType))
	{
	    hr = CASetCAProperty(
			    hCAInfo,
			    CA_PROP_CERT_TYPES,
			    fLoadDefaultTemplates?
                    (FIsAdvancedServer()?
				     s_apwszCertTypeAdvancedServer :
                     s_apwszCertTypeServer):
                s_apwszCertTypeEmpty);
	    _JumpIfError(hr, error, "CASetCAProperty(CA_PROP_CERT_TYPES)");
	}
    }

    // create a new cert context without key prov info
    pCertForDS = CertCreateCertificateContext(X509_ASN_ENCODING,
                     pCert->pbCertEncoded,
                     pCert->cbCertEncoded);
    if (NULL == pCertForDS)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertCreateCertificateContext");
    }

    hr = CASetCACertificate(hCAInfo, pCertForDS);
    _JumpIfError(hr, error, "CASetCACertificate");

    if (!fRenew)
    {
	hr = CASetCASecurity(hCAInfo, pCDPSD);
	_JumpIfError(hr, error, "CASetCASecurity");
    }
    hr = CAUpdateCA(hCAInfo);
    _JumpIfError(hr, error, "CAUpdateCA");
    
error:
    if (NULL != pwszStringSid)
    {
        LocalFree(pwszStringSid);
    }
    if (NULL != pwszSanitizedDSName)
    {
        LocalFree(pwszSanitizedDSName);
    }
    if (NULL != pCertSubjectString)
    {
        LocalFree(pCertSubjectString);
    }
    if (NULL != hCAInfo)
    {
        CACloseCA(hCAInfo);
    }
    if (NULL != pCDPSD)
    {
        LocalFree(pCDPSD);
    }
    if (NULL != pContainerSD)
    {
        LocalFree(pContainerSD);
    }
    if (NULL != pCertForDS)
    {
        CertFreeCertificateContext(pCertForDS);
    }
    CSILOG(hr, IDS_ILOG_PUBLISHCA, NULL, NULL, NULL);
    return(hr);
}


BOOL
csiIsAnyDSCAAvailable(VOID)
{
    // this is an expensive call; cache result
    static BOOL    available = FALSE;           // static inits to FALSE
    static BOOL    fKnowAvailable = FALSE;      // static inits to FALSE

    HCAINFO hCAInfo = NULL;

    if (!fKnowAvailable)
    {
        HRESULT hr;
        
        fKnowAvailable = TRUE;

        hr = CAEnumFirstCA(
		    NULL,
		    CA_FIND_INCLUDE_UNTRUSTED | CA_FIND_INCLUDE_NON_TEMPLATE_CA,
		    &hCAInfo);
        _JumpIfError(hr, error, "CAEnumFirstCA");

        if (NULL == hCAInfo)
        {
            goto error;
        }
        available = TRUE;
    }

error:
    if (NULL != hCAInfo)
        CACloseCA(hCAInfo);

    return available;
}


HRESULT
csiSetKeyContainerSecurity(
    IN HCRYPTPROV hProv)
{
    HRESULT hr;

    hr = mySetKeyContainerSecurity(hProv);
    _JumpIfError(hr, error, "mySetKeyContainerSecurity");

error:
    CSILOG(hr, IDS_ILOG_SETKEYSECURITY, NULL, NULL, NULL);
    return(hr);
}


HRESULT
csiSetAdminOnlyFolderSecurity(
    IN LPCWSTR    szFolderPath,
    IN BOOL       fAllowEveryoneRead,
    IN BOOL       fUseDS)
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;

    // choose which access we want to allow
    LPCWSTR pwszDescriptor;
    if (fUseDS)
        if (fAllowEveryoneRead)
            pwszDescriptor = WSZ_DEFAULT_SF_USEDS_EVERYONEREAD_SECURITY;
        else
            pwszDescriptor = WSZ_DEFAULT_SF_USEDS_SECURITY;
    else
        if (fAllowEveryoneRead)
            pwszDescriptor = WSZ_DEFAULT_SF_EVERYONEREAD_SECURITY;
        else
            pwszDescriptor = WSZ_DEFAULT_SF_SECURITY;

    hr = myGetSDFromTemplate(pwszDescriptor, NULL, &pSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    if (!SetFileSecurity(
        szFolderPath,
        DACL_SECURITY_INFORMATION,
        pSD))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetFileSecurity");
    }

    hr = S_OK;

error:
    if (NULL != pSD)
    {
        LocalFree(pSD);
    }
    CSILOG(hr, IDS_ILOG_SETADMINONLYFOLDERSECURITY, szFolderPath, NULL, NULL);
    return(hr);
}


HRESULT
csiSaveCertAndKeys(
    IN CERT_CONTEXT const *pCert,
    IN HCERTSTORE hAdditionalStore,
    IN CRYPT_KEY_PROV_INFO const *pkpi,
    IN ENUM_CATYPES CAType)
{
    HRESULT hr;
    CERT_CHAIN_CONTEXT const *pCertChain = NULL;
    CERT_CHAIN_PARA CertChainPara;
    HCERTSTORE hNTAuthStore = NULL;

    ZeroMemory(&CertChainPara, sizeof(CertChainPara));
    CertChainPara.cbSize = sizeof(CertChainPara);

    if (!CertGetCertificateChain(
			    HCCE_LOCAL_MACHINE,
			    pCert,
			    NULL,
			    hAdditionalStore,
			    &CertChainPara,
			    0,
			    NULL,
			    &pCertChain))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertGetCertificateChain");
    }

    // make sure there is at least 1 simple chain

    if (0 == pCertChain->cChain)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        _JumpError(hr, error, "pCertChain->cChain");
    }

    hr = mySaveChainAndKeys(
			pCertChain->rgpChain[0],
			wszMY_CERTSTORE,
			CERT_SYSTEM_STORE_LOCAL_MACHINE,
			pkpi,
			NULL);
    _JumpIfError(hr, error, "mySaveChainAndKeys");

    if (IsEnterpriseCA(CAType))
    {
        hNTAuthStore = CertOpenStore(
			    CERT_STORE_PROV_SYSTEM_REGISTRY_W,
			    X509_ASN_ENCODING,
			    NULL,		// hProv
			    CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE,
			    wszNTAUTH_CERTSTORE);
        if (NULL == hNTAuthStore)
        {
            hr = myHLastError();
            _JumpErrorStr(hr, error, "CertOpenStore", wszNTAUTH_CERTSTORE);
        }

        if (!CertAddEncodedCertificateToStore(
		        hNTAuthStore,
		        X509_ASN_ENCODING,
		        pCert->pbCertEncoded,
		        pCert->cbCertEncoded,
			CERT_STORE_ADD_REPLACE_EXISTING,
		        NULL))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CertAddEncodedCertificateToStore");
        }
    }

error:
    if (pCertChain != NULL)
    {
	CertFreeCertificateChain(pCertChain);
    }
    if (NULL != hNTAuthStore)
    {
        CertCloseStore(hNTAuthStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
AddCertBlobToMemAndRootStores(
    IN OUT HCERTSTORE hStore,
    IN BYTE const *pb,
    IN DWORD cb)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    HCERTSTORE hStoreRoot = NULL;
    BOOL fRoot;

    pCert = CertCreateCertificateContext(X509_ASN_ENCODING, pb, cb);
    if (NULL == pCert)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    if (!CertAddCertificateContextToStore(
				    hStore,
				    pCert,
				    CERT_STORE_ADD_REPLACE_EXISTING,
				    NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertAddCertificateContextToStore");
    }

    fRoot = CertCompareCertificateName(
			    X509_ASN_ENCODING,
			    &pCert->pCertInfo->Subject,
			    &pCert->pCertInfo->Issuer);
    if (fRoot)
    {
	hStoreRoot = CertOpenStore(
			    CERT_STORE_PROV_SYSTEM_REGISTRY_W,
			    X509_ASN_ENCODING,
			    NULL,                    // hProv
			    CERT_SYSTEM_STORE_LOCAL_MACHINE |
				CERT_STORE_ENUM_ARCHIVED_FLAG,
			    wszROOT_CERTSTORE);
	if (NULL == hStoreRoot)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertOpenStore");
	}
	if (!CertAddCertificateContextToStore(
					hStoreRoot,
					pCert,
					CERT_STORE_ADD_REPLACE_EXISTING,
					NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertAddCertificateContextToStore");
	}
    }
    hr = S_OK;

error:
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != hStoreRoot)
    {
        CertCloseStore(hStoreRoot, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
LoadMissingCertBlob(
    IN OUT HCERTSTORE hStore,
    IN BYTE const    *pb,
    IN DWORD          cb)
{
    HRESULT hr;
    BYTE *pbDecoded = NULL;
    DWORD cbDecoded;
    CERT_CONTEXT const *pCert = NULL;
    HCERTSTORE hStorePKCS7 = NULL;
    BOOL fTryPKCS7 = TRUE;

    if (myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_TO_BE_SIGNED,
		    pb,
		    cb,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pbDecoded,
		    &cbDecoded))
    {
	hr = AddCertBlobToMemAndRootStores(hStore, pb, cb);
	_JumpIfError(hr, error, "AddCertBlobToMemAndRootStores");

	fTryPKCS7 = FALSE;
    }
    else
    if (myDecodeObject(
		    X509_ASN_ENCODING,
		    PKCS_CONTENT_INFO_SEQUENCE_OF_ANY,
		    pb,
		    cb,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pbDecoded,
		    &cbDecoded))
    {
	CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY const *pSeq;
	DWORD iCert;

	pSeq = (CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY const *) pbDecoded;

	if (0 == strcmp(szOID_NETSCAPE_CERT_SEQUENCE, pSeq->pszObjId))
	{
	    fTryPKCS7 = FALSE;
	    for (iCert = 0; iCert < pSeq->cValue; iCert++)
	    {
		hr = AddCertBlobToMemAndRootStores(
				    hStore,
				    pSeq->rgValue[iCert].pbData,
				    pSeq->rgValue[iCert].cbData);
		_JumpIfError(hr, error, "AddCertBlobToMemAndRootStores");
	    }
	}
    }
    if (fTryPKCS7)
    {
	CRYPT_DATA_BLOB blobPKCS7;

	blobPKCS7.pbData = const_cast<BYTE *>(pb);
	blobPKCS7.cbData = cb;

	hStorePKCS7 = CertOpenStore(
			    CERT_STORE_PROV_PKCS7,
			    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
			    NULL,		// hCryptProv
			    0,			// dwFlags
			    &blobPKCS7);
	if (NULL == hStorePKCS7)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertOpenStore");
	}
	for (;;)
	{
	    pCert = CertEnumCertificatesInStore(hStorePKCS7, pCert);
	    if (NULL == pCert)
	    {
		break;
	    }
	    hr = AddCertBlobToMemAndRootStores(
				hStore,
				pCert->pbCertEncoded,
				pCert->cbCertEncoded);
	    _JumpIfError(hr, error, "AddCertBlobToMemAndRootStores");
	}
    }
    hr = S_OK;

error:
    if (NULL != pbDecoded)
    {
	LocalFree(pbDecoded);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != hStorePKCS7)
    {
	CertCloseStore(hStorePKCS7, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
LoadMissingCert(
    IN HINSTANCE      hInstance,
    IN HWND           hwnd,
    IN OUT HCERTSTORE hStore,
    IN OPTIONAL WCHAR const *pwszMissingIssuer)
{
    HRESULT hr;
    WCHAR *pwszFile = NULL;
    BYTE *pb = NULL;
    DWORD cb;

    hr = myGetOpenFileNameEx(
		 hwnd,
		 hInstance,
		 IDS_CAHIER_INSTALL_MISIINGCERT_TITLE,
		 pwszMissingIssuer,
		 IDS_CAHIER_CERTFILE_FILTER,
		 0,		// no def ext
		 OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY,
		 NULL,	// no default file
		 &pwszFile);
    if (S_OK == hr && NULL == pwszFile)
    {
	hr = E_INVALIDARG;
    }
    _JumpIfError(hr, error, "myGetOpenFileName");

    hr = DecodeFileW(pwszFile, &pb, &cb, CRYPT_STRING_ANY);
    _JumpIfError(hr, error, "DecodeFileW");

    hr = LoadMissingCertBlob(hStore, pb, cb);
    _JumpIfError(hr, error, "LoadMissingCertBlob");

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    if (NULL != pwszFile)
    {
	LocalFree(pwszFile);
    }
    return(hr);
}


HRESULT
InstallCAChain(
    IN HINSTANCE                   hInstance,
    IN BOOL                        fUnattended,
    IN HWND                        hwnd,
    IN PCCERT_CONTEXT              pCert,
    IN CRYPT_KEY_PROV_INFO const  *pKeyProvInfo,
    IN ENUM_CATYPES                CAType,
    OPTIONAL IN BYTE const       *pbChain,
    IN DWORD                      cbChain)
{
    HRESULT hr;
    WCHAR *pwszMissingIssuer = NULL;
    HCERTSTORE hTempMemoryStore = NULL;

    if (IsSubordinateCA(CAType))
    {
	hTempMemoryStore = CertOpenStore(
				    CERT_STORE_PROV_MEMORY,
				    X509_ASN_ENCODING,
				    NULL,
				    0,
				    NULL);
	if (NULL == hTempMemoryStore)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertOpenSystemStore");
	}

	if (NULL != pbChain)
	{
	    hr = LoadMissingCertBlob(hTempMemoryStore, pbChain, cbChain);
	    _JumpIfError(hr, error, "LoadMissingCertBlob");
	}

	// see if CA chain can be built

	for (;;)
	{
	    if (NULL != pwszMissingIssuer)
	    {
		LocalFree(pwszMissingIssuer);
		pwszMissingIssuer = NULL;
	    }
	    hr = myVerifyCertContext(
				pCert,			// pCert
				0,			// dwFlags
				0,			// cUsageOids
				NULL,			// apszUsageOids
				HCCE_LOCAL_MACHINE,	// hChainEngine
				hTempMemoryStore,	// hAdditionalStore
				&pwszMissingIssuer);
	    if (S_OK != hr)
	    {
		if (NULL != pwszMissingIssuer)
		{
		    if (IDCANCEL == CertMessageBox(
					hInstance,
					fUnattended,
					hwnd,
					IDS_ERR_INCOMPLETECHAIN,
					hr,
					MB_OKCANCEL | MB_ICONWARNING,
					pwszMissingIssuer) ||
			fUnattended)
		    {
			_JumpError(hr, error, "cannot build CA chain");
		    }

		    hr = LoadMissingCert(
				     hInstance,
				     hwnd,
				     hTempMemoryStore,
				     pwszMissingIssuer);
		    _PrintIfError(hr, "LoadMissingCert");
		    continue;
		}
		else
		{
		    // recommend not continue

		    if (IDCANCEL == CertMessageBox(
					hInstance,
					fUnattended,
					hwnd,
					CERT_E_UNTRUSTEDROOT == hr?
					    IDS_ERR_UNTRUSTEDROOT :
					    IDS_ERR_INVALIDCHAIN,
					hr,
					MB_OKCANCEL | MB_ICONWARNING,
					NULL))
		    {
			_JumpError(hr, error, "cannot verify CA chain");
		    }
		    break;
		}
	    }
	    break;
	}
    }

    hr = csiSaveCertAndKeys(pCert, hTempMemoryStore, pKeyProvInfo, CAType);
    if (S_OK != hr)
    {
        CertErrorMessageBox(
                        hInstance,
                        fUnattended,
                        hwnd,
                        IDS_ERR_CERTADDCERTIFICATECONTEXTTOSTORE,
                        hr,
                        NULL);
	_JumpError(hr, error, "csiSaveCertAndKeys");
    }

error:
    if (NULL != pwszMissingIssuer)
    {
	LocalFree(pwszMissingIssuer);
    }
    if (NULL != hTempMemoryStore)
    {
	CertCloseStore(hTempMemoryStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
VerifyPublicKeyMatch(
    IN CERT_CONTEXT const *pCert,
    IN CRYPT_KEY_PROV_INFO const *pKeyProvInfo)
{
    HRESULT hr;

    hr = myVerifyPublicKey(
		    NULL,		// pCert
		    FALSE,		// fV1Cert
		    pKeyProvInfo,
		    &pCert->pCertInfo->SubjectPublicKeyInfo,
		    NULL);		// pfMatchingKey
    return(S_OK);
}


HRESULT
BuildCAChainFromCert(
    IN HINSTANCE                  hInstance,
    IN BOOL                       fUnattended,
    IN HWND                       hwnd,
    IN CRYPT_KEY_PROV_INFO const *pKeyProvInfo,
    IN WCHAR const  		 *pwszSanitizedCAName,
    IN WCHAR const               *pwszCommonName,
    IN const ENUM_CATYPES         CAType,
    IN DWORD	     		  iCert,
    IN DWORD	     		  iCRL,
    OPTIONAL IN BYTE const       *pbChain,
    IN DWORD                      cbChain,
    IN CERT_CONTEXT const        *pCert)
{
    HRESULT hr;
    UINT idserr;
    CERT_NAME_INFO *pNameInfo = NULL;
    DWORD cbNameInfo;
    WCHAR const *pwszCN;
    HCERTSTORE hMyStore = NULL;
    CERT_CONTEXT const *pccPrevious = NULL;

    // make sure the cert file matches current ca name

    if (!myDecodeName(
                  X509_ASN_ENCODING,
                  X509_UNICODE_NAME,
                  pCert->pCertInfo->Subject.pbData,
                  pCert->pCertInfo->Subject.cbData,
                  CERTLIB_USE_LOCALALLOC,
                  &pNameInfo,
                  &cbNameInfo))
    {
        hr = myHLastError();
        CertErrorMessageBox(
                        hInstance,
                        fUnattended,
                        hwnd,
                        IDS_ERR_MYDECODENAME,
                        hr,
                        NULL);
        _JumpError(hr, error, "myDecodeName");
    }

    hr = myGetCertNameProperty(FALSE, pNameInfo, szOID_COMMON_NAME, &pwszCN);
    _PrintIfError(hr, "myGetCertNameProperty");

    if (S_OK == hr && 0 != lstrcmp(pwszCommonName, pwszCN))
    {
        hr = E_INVALIDARG;
	_PrintErrorStr(hr, "lstrcmp", pwszCN);
    }
    idserr = IDS_ERR_NOT_MATCH_COMMONNAME;

    // If renewing and reusing the old key, verify the binary subject matches
    // the previous cert subject, to prevent CRL Issuer and cert Issuer
    // mismatches when verifying chains.

    if (S_OK == hr && 0 < iCert && iCert != iCRL)
    {
	DWORD NameId;

	hMyStore = CertOpenStore(
			    CERT_STORE_PROV_SYSTEM_W,
			    X509_ASN_ENCODING,
			    NULL,                    // hProv
			    CERT_SYSTEM_STORE_LOCAL_MACHINE |
				CERT_STORE_MAXIMUM_ALLOWED_FLAG |
				CERT_STORE_READONLY_FLAG,
			    wszMY_CERTSTORE);
	if (NULL == hMyStore)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertOpenStore");
	}
	hr = myFindCACertByHashIndex(
				hMyStore,
				pwszSanitizedCAName,
				CSRH_CASIGCERT,
				iCert - 1,
				&NameId,
				&pccPrevious);
	_PrintIfError(hr, "myFindCACertByHashIndex");

	if (S_OK == hr &&
	    !CertCompareCertificateName(
				X509_ASN_ENCODING,
				&pCert->pCertInfo->Subject,
				&pccPrevious->pCertInfo->Subject))
	{
	    hr = E_INVALIDARG;
	    idserr = IDS_ERR_NOT_MATCH_BINARYNAME;
	    _PrintErrorStr(hr, "CertCompareCertificateName", pwszCN);
	}
    }
    if (S_OK != hr)
    {
        CertErrorMessageBox(
                        hInstance,
                        fUnattended,
                        hwnd,
                        idserr,
                        hr,
                        NULL);
        _JumpError(hr, error, "cert common/binary name mismatch");
    }

    hr = myVerifyPublicKey(
		    NULL,		// pCert
		    FALSE,		// fV1Cert
		    pKeyProvInfo,
		    &pCert->pCertInfo->SubjectPublicKeyInfo,
		    NULL);		// pfMatchingKey
    if (S_OK != hr)
    {
        CertErrorMessageBox(
                        hInstance,
                        fUnattended,
                        hwnd,
                        IDS_ERR_NOT_MATCH_KEY,
                        hr,
                        NULL);
	_JumpError(hr, error, "myVerifyPublicKey");
    }
    hr = IsCACert(hInstance, fUnattended, hwnd, pCert, CAType);
    _JumpIfError(hr, error, "IsCACert");

    hr = InstallCAChain(
		    hInstance,
		    fUnattended,
		    hwnd,
		    pCert,
		    pKeyProvInfo,
		    CAType,
		    pbChain,
		    cbChain);
    _JumpIfError(hr, error, "InstallCAChain");

error:
    if (NULL != pccPrevious)
    {
        CertFreeCertificateContext(pccPrevious);
    }
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    CSILOG(hr, IDS_ILOG_SAVECERTANDKEYS, NULL, NULL, NULL);
    return(hr);
}


HRESULT
csiFinishInstallationFromPKCS7(
    IN HINSTANCE     hInstance,
    IN BOOL          fUnattended,
    IN HWND          hwnd,
    IN WCHAR const  *pwszSanitizedCAName,
    IN WCHAR const  *pwszCACommonName,
    IN CRYPT_KEY_PROV_INFO const *pKeyProvInfo,
    IN ENUM_CATYPES  CAType,
    IN DWORD	     iCert,
    IN DWORD	     iCRL,
    IN BOOL          fUseDS,
    IN BOOL          fRenew,
    IN WCHAR const  *pwszServerName,
    IN BYTE const   *pbChainOrCert,
    IN DWORD         cbChainOrCert,
    OPTIONAL IN WCHAR const *pwszCACertFile)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    WCHAR *pwszWebCACertFile = NULL;
    WCHAR *pwszKeyContainer = NULL;
    WCHAR wszTemp[MAX_PATH];
    WCHAR wszBuffer[MAX_PATH];
    DWORD NameId;
    WCHAR *pwszRequestFile = NULL;
    DWORD cwc;

    hr = E_FAIL;
    if (!IsRootCA(CAType))	// skip PKCS7 code for known raw X509 root cert
    {
	hr = ExtractCACertFromPKCS7(
			    pwszCACommonName,
			    pbChainOrCert,
			    cbChainOrCert,
			    &pCert);
	_PrintIfError(hr, "ExtractCACertFromPKCS7");
    }

    if (NULL == pCert)
    {
	pCert = CertCreateCertificateContext(
				    X509_ASN_ENCODING,
				    pbChainOrCert,
				    cbChainOrCert);
	if (NULL == pCert)
	{
	    hr = myHLastError();
	    CertErrorMessageBox(
			hInstance,
			fUnattended,
			hwnd,
			IDS_ERR_CERTCREATECERTIFICATECONTEXT,
			hr,
			NULL);
	    _JumpError(hr, error, "CertCreateCertificateContext");
	}
	pbChainOrCert = NULL;	// Don't need to process this cert any further
    }

    hr = myGetNameId(pCert, &NameId);
    _PrintIfError(hr, "myGetNameId");
    if (S_OK == hr && MAKECANAMEID(iCert, iCRL) != NameId)
    {
	// get request file name

	hr = csiGetCARequestFileName(
			    hInstance,
			    hwnd,
			    pwszSanitizedCAName,
			    iCert,
			    iCRL,
			    &pwszRequestFile);
	_PrintIfError(hr, "csiGetCARequestFileName");

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	CertErrorMessageBox(
		    hInstance,
		    fUnattended,
		    hwnd,
		    IDS_ERR_RENEWEDCERTCAVERSION,
		    hr,
		    pwszRequestFile);
	_JumpError(hr, error, "CA Version");
    }

    // build a chain and install it

    hr = BuildCAChainFromCert(
		    hInstance,
		    fUnattended,
		    hwnd,
		    pKeyProvInfo,
		    pwszSanitizedCAName,
		    pwszCACommonName,
		    CAType,
		    iCert,
		    iCRL,
		    pbChainOrCert,
		    cbChainOrCert,
		    pCert);
    _JumpIfError(hr, error, "BuildCAChainFromCert");

    // store CA cert hash

    hr = mySetCARegHash(pwszSanitizedCAName, CSRH_CASIGCERT, iCert, pCert);
    _JumpIfError(hr, error, "mySetCARegHash");

    if (fUseDS)
    {
        // save in ds
        hr = csiSetupCAInDS(
		    pwszServerName,
		    pwszSanitizedCAName,
		    pwszCACommonName,
		    TRUE,
		    CAType,
		    iCert,
		    iCRL,
		    fRenew,
		    pCert);
    	_JumpIfError(hr, error, "csiSetupCAInDS");
    }

    if (NULL != pwszCACertFile)
    {
	// write this CA cert into shared folder

	if (!DeleteFile(pwszCACertFile))
	{
	    hr = myHLastError();
	    _PrintErrorStr2(
			hr,
			"DeleteFile",
			pwszCACertFile,
			HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
	}
	if (!csiWriteDERToFile(
			pwszCACertFile,
			(BYTE *) pCert->pbCertEncoded,
			pCert->cbCertEncoded,
			hInstance,
			fUnattended,
			hwnd))
	{
	    hr = myHLastError();
	    _PrintErrorStr(hr, "csiWriteDERToFile", pwszCACertFile);
	}
    }

    // write cert file for web pages

    cwc = GetEnvironmentVariable(L"SystemRoot", wszTemp, ARRAYSIZE(wszTemp));
    if (0 == cwc || ARRAYSIZE(wszTemp) <= cwc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        CertErrorMessageBox(
		hInstance,
		fUnattended,
		hwnd,
		IDS_ERR_ENV_NOT_SET,
		hr,
		NULL);
        _JumpError(hr, error, "GetEnvironmentVariable");
    }

    if(ARRAYSIZE(wszBuffer)<wcslen(wszTemp)+wcslen(L"\\System32\\")+
       wcslen(wszCERTENROLLSHAREPATH)+1)
    {
        hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
        _JumpError(hr, error, "file name too long");
    }

    wcscpy(wszBuffer, wszTemp);
    wcscat(wszBuffer, L"\\System32\\" wszCERTENROLLSHAREPATH);

    hr = csiBuildFileName(
		wszBuffer,
		pwszSanitizedCAName,
		L".crt",
		iCert,
		&pwszWebCACertFile, 
		hInstance,
		fUnattended,
		NULL);
    _JumpIfError(hr, error, "csiBuildFileName");

    hr = EncodeToFileW(
		pwszWebCACertFile,
		pCert->pbCertEncoded,
		pCert->cbCertEncoded,
		DECF_FORCEOVERWRITE | CRYPT_STRING_BINARY);
    if (S_OK != hr)
    {
        CertErrorMessageBox(
			hInstance,
			fUnattended,
			hwnd,
			IDS_ERR_WRITEDERTOFILE,
			hr,
			pwszWebCACertFile);
        _JumpError(hr, error, "EncodeToFileW");
    }

    // Set the security on the ds/registry/files etc.

    if (!fRenew)
    {
	hr = myAllocIndexedName(
			pwszSanitizedCAName,
			iCRL,
			MAXDWORD,		// IndexTarget
			&pwszKeyContainer);
	_JumpIfError(hr, error, "myAllocIndexedName");

	hr = csiInitializeCertSrvSecurity(
			pwszSanitizedCAName,
			fUseDS, 
			fUseDS);    // set DS security if using DS
	_JumpIfError(hr, error, "csiInitializeCertSrvSecurity");
    }

error:
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    if (NULL != pwszRequestFile)
    {
        LocalFree(pwszRequestFile);
    }
    if (NULL != pwszKeyContainer)
    {
        LocalFree(pwszKeyContainer);
    }
    if (NULL != pwszWebCACertFile)
    {
        LocalFree(pwszWebCACertFile);
    }
    return(hr);
}


HRESULT
FormRequestHelpMessage(
    IN HINSTANCE     hInstance,
    IN LONG          lRequestId,
    IN BSTR          bStrMsgFromServer,
    IN WCHAR const  *pwszParentConfig,
    OUT WCHAR      **ppwszHelpMsg)
{

#define wszHELPNEWLINE  L"\n"
#define wszCOMMASPACE   L", "

    HRESULT  hr;
    WCHAR    wszRequestIdValue[16];
    WCHAR   *pwszMsgConfigPrefix = NULL;
    WCHAR   *pwszMsgRequestIdPrefix = NULL;
    WCHAR   *pwszHelpMsg = NULL;
    DWORD cwc;

    *ppwszHelpMsg = NULL;

    // load some format strings in help msg
    hr = myLoadRCString(hInstance, IDS_MSG_PARENTCA_CONFIG, &pwszMsgConfigPrefix);
    _JumpIfError(hr, error, "myLoadRCString");

    hr = myLoadRCString(hInstance, IDS_MSG_REQUEST_ID, &pwszMsgRequestIdPrefix);
    _JumpIfError(hr, error, "myLoadRCString");

    swprintf(wszRequestIdValue, L"%ld", lRequestId);

    cwc = wcslen(pwszMsgConfigPrefix) +
			wcslen(pwszParentConfig) +
			WSZARRAYSIZE(wszCOMMASPACE) +
			wcslen(pwszMsgRequestIdPrefix) +
			wcslen(wszRequestIdValue) +
			1;
    if (NULL != bStrMsgFromServer)
    {
	cwc += SysStringLen(bStrMsgFromServer) + WSZARRAYSIZE(wszHELPNEWLINE);
    }

    pwszHelpMsg = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszHelpMsg)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // form help message

    pwszHelpMsg[0] = L'\0';
    if (NULL != bStrMsgFromServer)
    {
        wcscpy(pwszHelpMsg, bStrMsgFromServer);
        wcscat(pwszHelpMsg, wszHELPNEWLINE);
    }
    wcscat(pwszHelpMsg, pwszMsgConfigPrefix);
    wcscat(pwszHelpMsg, pwszParentConfig);
    wcscat(pwszHelpMsg, wszCOMMASPACE);
    wcscat(pwszHelpMsg, pwszMsgRequestIdPrefix);
    wcscat(pwszHelpMsg, wszRequestIdValue);

    CSASSERT(wcslen(pwszHelpMsg) + 1 == cwc);

    *ppwszHelpMsg = pwszHelpMsg;
    pwszHelpMsg = NULL;
    hr = S_OK;

error:
    if (NULL != pwszMsgConfigPrefix)
    {
        LocalFree(pwszMsgConfigPrefix);
    }
    if (NULL != pwszMsgRequestIdPrefix)
    {
        LocalFree(pwszMsgRequestIdPrefix);
    }
    if (NULL != pwszHelpMsg)
    {
        LocalFree(pwszHelpMsg);
    }
    return(hr);
}


HRESULT
HandleSubmitOrRetrieveNotIssued(
    IN HWND          hwnd,
    IN HINSTANCE     hInstance,
    IN BOOL          fUnattended,
    IN WCHAR const  *pwszSanitizedCAName,
    IN WCHAR const  *pwszParentCAConfig,
    IN LONG          disposition,
    IN BSTR	     strDispositionMessage,
    IN BOOL          fRenew,
    IN DWORD         iCert,
    IN LONG          requestId,
    IN HRESULT       hrSubmit,
    IN HRESULT       hrLastStatus,
    IN int           iMsgId)
{
    HRESULT    hr;
    WCHAR     *pwszHelpMsg = NULL;
    DWORD      dwStatusDisable;
    DWORD      dwStatusEnable;
    BOOL       fPopup = FALSE;

    // form custom message

    hr = FormRequestHelpMessage(
			 hInstance,
			 requestId,
			 strDispositionMessage,
			 pwszParentCAConfig,
			 &pwszHelpMsg);
    _JumpIfError(hr, error, "FromRequestHelpMessage");


    // Assume suspended install, denied request:

    dwStatusEnable = SETUP_DENIED_FLAG | SETUP_REQUEST_FLAG;
    if (!fRenew && 0 == iCert)
    {
	dwStatusEnable |= SETUP_SUSPEND_FLAG;
    }

    // Assume the pending request is denied, don't use online parent any more

    dwStatusDisable = SETUP_ONLINE_FLAG;

    // now handle disposition

    switch (disposition)
    {
        case CR_DISP_UNDER_SUBMISSION:
	    // the online request is pending, not denied

	    dwStatusEnable &= ~SETUP_DENIED_FLAG;
	    dwStatusEnable |= SETUP_ONLINE_FLAG;

	    // online is still enabled

	    dwStatusDisable &= ~SETUP_ONLINE_FLAG;

            iMsgId = IDS_ERR_REQUEST_PENDING;
            break;

        case CR_DISP_DENIED:
            // request id is no good any more

            hr = myDeleteCertRegValue(
                                pwszSanitizedCAName,
                                NULL,
                                NULL,
                                wszREGREQUESTID);
            _PrintIfErrorStr(hr, "myDeleteCertRegValue", wszREGREQUESTID);

	    if (0 == iMsgId)
	    {
		iMsgId = IDS_ERR_REQUEST_DENIED;
	    }
            break;

        case CR_DISP_INCOMPLETE:
            iMsgId = IDS_ERR_REQUEST_INCOMPLETE;
            break;

        case CR_DISP_ERROR:
            iMsgId = IDS_ERR_REQUEST_ERROR;
            break;

        case CR_DISP_ISSUED_OUT_OF_BAND:

            // same as pending request, but not denied

            dwStatusEnable &= ~SETUP_DENIED_FLAG;

            iMsgId = IDS_ERR_REQUEST_OUTOFBAND;
            break;

        case CR_DISP_REVOKED:
            iMsgId = IDS_ERR_REQUEST_REVOKED;
            break;

        default:
            hr = E_INVALIDARG;
            _JumpError(hr, error, "Internal error");
    }

    if (0 != dwStatusDisable)
    {
        // fix status, unset

        hr = SetSetupStatus(pwszSanitizedCAName, dwStatusDisable, FALSE);
        _JumpIfError(hr, error, "SetSetupStatus");
    }
    if (0 != dwStatusEnable)
    {
        // fix status, set

        hr = SetSetupStatus(pwszSanitizedCAName, dwStatusEnable, TRUE);
        _JumpIfError(hr, error, "SetSetupStatus");
    }

    // pop up a warning for generic error
    CertWarningMessageBox(
                    hInstance,
                    fUnattended,
                    hwnd,
                    iMsgId,
                    hrLastStatus,
                    pwszHelpMsg);
    fPopup = TRUE;

    // use proper error code

    if (S_OK == hrSubmit)
    {
        // for any disposition, use not ready as error

        hr = HRESULT_FROM_WIN32(ERROR_NOT_READY);
    }
    else
    {
        // use submit error

        hr = hrSubmit;
    }

    // note, never return S_OK

error:
    if (!fPopup)
    {
        // a generic one because we won't have any popup later
        CertWarningMessageBox(
                        hInstance,
                        fUnattended,
                        hwnd,
                        IDS_ERR_SUBMIT_REQUEST_FAIL,
                        hr,
                        L"");
    }
    if (NULL != pwszHelpMsg)
    {
        LocalFree(pwszHelpMsg);
    }
    CSILOG(hr, IDS_ILOG_RETRIEVECERT, NULL, NULL, NULL);
    return(hr);
}


HRESULT
csiSubmitCARequest(
    IN HINSTANCE     hInstance,
    IN BOOL          fUnattended,
    IN HWND          hwnd,
    IN BOOL          fRenew,
    IN DWORD	     iCert,
    IN BOOL	     fRetrievePending,
    IN WCHAR const  *pwszSanitizedCAName,
    IN WCHAR const  *pwszParentCAMachine,
    IN WCHAR const  *pwszParentCAName,
    IN BYTE const   *pbRequest,
    IN DWORD         cbRequest,
    OUT BSTR        *pbStrChain)
{
    HRESULT             hr;
    HRESULT             hrSubmit;
    HRESULT             hrLastStatus;
    WCHAR              *pwszParentCAConfig = NULL;
    LONG                disposition = CR_DISP_INCOMPLETE;
    LONG                requestId = 0;
    int                 iMsgId;
    ICertRequest       *pICertRequest = NULL;
    BOOL                fCoInit = FALSE;
    BSTR                bstrConfig = NULL;
    BSTR                bstrRequest = NULL;
    BSTR		strDispositionMessage = NULL;

    // register parent ca config
    hr = mySetCertRegStrValue(
			 pwszSanitizedCAName,
			 NULL,
			 NULL,
			 wszREGPARENTCAMACHINE,
			 pwszParentCAMachine);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", wszREGPARENTCAMACHINE);

    hr = mySetCertRegStrValue(
			 pwszSanitizedCAName,
			 NULL,
			 NULL,
			 wszREGPARENTCANAME,
			 pwszParentCAName);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", wszREGPARENTCANAME);
    
    if (fRetrievePending)
    {
	// get request id

	hr = myGetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGREQUESTID,
			(DWORD *) &requestId);
	if (S_OK != hr)
	{
	    fRetrievePending = FALSE;
	    requestId = 0;
	}
    }

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    hr = CoCreateInstance(
		    CLSID_CCertRequest,
		    NULL,
		    CLSCTX_INPROC_SERVER,
		    IID_ICertRequest,
		    (VOID **) &pICertRequest);
    _JumpIfError(hr, error, "CoCreateInstance");

    // get config string

    hr = myFormConfigString(
			pwszParentCAMachine,
			pwszParentCAName,
			&pwszParentCAConfig);
    _JumpIfError(hr, error, "myFormConfigString");

    // to bstr

    bstrConfig = SysAllocString(pwszParentCAConfig);
    if (NULL == bstrConfig)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // request to bstr

    bstrRequest = SysAllocStringByteLen((CHAR *) pbRequest, cbRequest);
    if (NULL == bstrRequest)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    myDeleteCertRegValue(pwszSanitizedCAName, NULL, NULL, wszREGREQUESTID);

    {
        CWaitCursor cwait;

	if (fRetrievePending)
	{
	    // retrieve the request
	    hr = pICertRequest->RetrievePending(
					requestId,
					bstrConfig,
					&disposition);
	}
	else
	{
	    hr = pICertRequest->Submit(
				CR_IN_BINARY | CR_IN_PKCS10,
				bstrRequest,
				NULL,
				bstrConfig,
				&disposition);
	}
	hrSubmit = hr;
	hrLastStatus = hr;
    }

    hr = pICertRequest->GetDispositionMessage(&strDispositionMessage);
    _PrintIfError(hr, "pICertRequest->GetDispositionMessage");

    if (S_OK == hrSubmit)
    {
	hr = pICertRequest->GetLastStatus(&hrLastStatus);
	_PrintIfError(hr, "pICertRequest->GetLastStatus");
    }

    CSILOG(
	hrLastStatus,
	fRetrievePending? IDS_ILOG_RETRIEVEPENDING : IDS_ILOG_SUBMITREQUEST,
	bstrConfig,
	strDispositionMessage,
	(DWORD const *) &disposition);

    iMsgId = 0;
    if (S_OK != hrSubmit)
    {
        // default to a generic message

        iMsgId = fRetrievePending?
		    IDS_ERR_RETRIEVE_PENDING : IDS_ERR_SUBMIT_REQUEST_FAIL;

        if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER) == hrSubmit)
        {
            iMsgId = IDS_ERR_NOT_ENTERPRISE_USER;
        }

        // if failed, treat as denied

        disposition = CR_DISP_DENIED;
    }

    if (CR_DISP_ISSUED != disposition)
    {
	if (!fRetrievePending)
	{
	    pICertRequest->GetRequestId(&requestId);
	}
	hr = mySetCertRegDWValue(
			    pwszSanitizedCAName,
			    NULL,
			    NULL,
			    wszREGREQUESTID,
			    requestId);
	_JumpIfErrorStr(hr, error, "mySetCertRegDWValue", wszREGREQUESTID);

        hr = HandleSubmitOrRetrieveNotIssued(
				    hwnd,
				    hInstance,
				    fUnattended,
				    pwszSanitizedCAName,
				    pwszParentCAConfig,
				    disposition,
				    strDispositionMessage,
				    fRenew,
				    iCert,
				    requestId,
				    hrSubmit,
				    hrLastStatus,
				    iMsgId);

	// not issued, always exit with error

        _JumpError(hr, error, "Cert is not issued");
    }

    // get pkcs7 chain

    hr = pICertRequest->GetCertificate(
			    CR_OUT_CHAIN | CR_OUT_BINARY,
			    pbStrChain);
    _JumpIfError(hr, error, "pICertRequest->GetCertificate");

error:
    if (NULL != strDispositionMessage)
    {
        SysFreeString(strDispositionMessage);
    }
    if (NULL != pwszParentCAConfig)
    {
        LocalFree(pwszParentCAConfig);
    }
    if (NULL != bstrConfig)
    {
        SysFreeString(bstrConfig);
    }
    if (NULL != bstrRequest)
    {
        SysFreeString(bstrRequest);
    }
    if (NULL != pICertRequest)
    {
        pICertRequest->Release();
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    CSILOG(
	hr,
	fRetrievePending? IDS_ILOG_RETRIEVEPENDING : IDS_ILOG_SUBMITREQUEST,
	pwszParentCAMachine,
	pwszParentCAName,
	(DWORD const *) &disposition);
    return(hr);
}


HRESULT
csiInitializeCertSrvSecurity(
    IN WCHAR const *pwszSanitizedCAName, 
    BOOL            fUseEnterpriseACL, // which ACL to use
    BOOL            fSetDsSecurity)    // whether to set security on DS object
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;
    CCertificateAuthoritySD CASD;

    hr = CASD.InitializeFromTemplate(
            fUseEnterpriseACL?
            WSZ_DEFAULT_CA_ENT_SECURITY :
            WSZ_DEFAULT_CA_STD_SECURITY,
            pwszSanitizedCAName);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::InitializeFromTemplate");

    hr = CASD.Save();
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Save");

    hr = CASD.MapAndSetDaclOnObjects(fSetDsSecurity?true:false);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::MapAndSetDaclOnObjects");

error:
    if (pSD)
    {
        LocalFree(pSD);
    }
    CSILOG(hr, IDS_ILOG_SETSECURITY, NULL, NULL, NULL);
    return(hr);
}


HRESULT
csiGenerateKeysOnly(
    IN  WCHAR const   *pwszContainer,
    IN  WCHAR const   *pwszProvName,
    IN  DWORD          dwProvType,
    IN  BOOL           fMachineKeyset,
    IN  DWORD          dwKeyLength,
    IN  BOOL           fUnattended,
    IN  BOOL           fEnableKeyCounting,
    OUT HCRYPTPROV    *phProv,
    OUT int           *piMsg)
{
    HRESULT hr;
    HCRYPTKEY hKey = NULL;
    DWORD dwKeyGenFlags;
    DWORD dwAcquireFlags;
    BOOL fExists;

    *phProv = NULL;
    *piMsg = 0;

    // see if the container already exists

    dwAcquireFlags = 0;
    if (fMachineKeyset)
    {
	dwAcquireFlags |= CRYPT_MACHINE_KEYSET;
    }
    if (fUnattended)
    {
	dwAcquireFlags |= CRYPT_SILENT;
    }
    fExists = CryptAcquireContext(
			    phProv,
			    pwszContainer,
			    pwszProvName,
			    dwProvType,
			    CRYPT_SILENT | dwAcquireFlags);
    if (NULL != *phProv)
    {
        CryptReleaseContext(*phProv, 0);
        *phProv = NULL;
    }
    if (fExists)
    {
        // container exists, but we did not choose to reuse keys,
        // so remove old keys and generate new ones.

        if (!CryptAcquireContext(
			    phProv,
			    pwszContainer,
			    pwszProvName,
			    dwProvType,
			    CRYPT_DELETEKEYSET | dwAcquireFlags))
        {
            hr = myHLastError();
            *piMsg = IDS_ERR_DELETEKEY;
            _JumpError(hr, error, "CryptAcquireContext");
        }
    }

    // create new container

    if (!CryptAcquireContext(
		    phProv,
		    pwszContainer,
		    pwszProvName,
		    dwProvType,
		    CRYPT_NEWKEYSET | dwAcquireFlags)) // force new container
    {
        hr = myHLastError();

        if (NTE_TOKEN_KEYSET_STORAGE_FULL == hr)
        {
            // Smart cards can only hold a limited number of keys
            // The user must pick an existing key or use a blank card

            *piMsg = IDS_ERR_FULL_TOKEN;
            _JumpError(hr, error, "CryptAcquireContext");
        }
        else if (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr)
        {
            // user must have clicked cancel on a smart card dialog.
            // go to previous page, and display no error message

            _JumpError(hr, error, "CryptAcquireContext");
        }
        else if (NTE_EXISTS == hr)
        {
            // since fExists shows NOT, it is likely the current user
            // doesn't have access permission for this existing key
            *piMsg = IDS_ERR_NO_KEY_ACCESS;
            _JumpError(hr, error, "CryptAcquireContext");
        }
        else
        {
            // Unexpected error in CryptAcquireContext.
            *piMsg = IDS_ERR_BADCSP;
            _JumpError(hr, error, "CryptAcquireContext");
        }
    }

    // enable key usage count for audit purposes

    if (fEnableKeyCounting)
    {
	hr = mySetEnablePrivateKeyUsageCount(*phProv, TRUE);
	_JumpIfError(hr, error, "mySetEnablePrivateKeyUsageCount");
    }
 
    // set key length

    dwKeyGenFlags = (dwKeyLength << 16) | CRYPT_EXPORTABLE;

    // create signature keys 

    if (!CryptGenKey(*phProv, AT_SIGNATURE, dwKeyGenFlags, &hKey))
    {
        hr = myHLastError();
        _PrintError(hr, "CryptGenKey(exportable)");

	dwKeyGenFlags &= ~CRYPT_EXPORTABLE;
	if (!CryptGenKey(*phProv, AT_SIGNATURE, dwKeyGenFlags, &hKey))
	{
	    hr = myHLastError();
	    *piMsg = IDS_ERR_GENKEYFAIL;
	    _JumpError(hr, error, "CryptGenKey");
	}
    }
    hr = S_OK;

error:
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    CSILOG(hr, IDS_ILOG_GENERATEKEYS, pwszContainer, pwszProvName, &dwKeyLength);
    return(hr);
}


HRESULT
csiGenerateCAKeys(
    IN WCHAR const *pwszContainer,
    IN WCHAR const *pwszProvName,
    IN DWORD        dwProvType,
    IN BOOL         fMachineKeyset,
    IN DWORD        dwKeyLength,
    IN HINSTANCE    hInstance,
    IN BOOL         fUnattended,
    IN BOOL         fEnableKeyCounting,
    IN HWND         hwnd,
    OUT BOOL       *pfKeyGenFailed)
{
    HRESULT    hr;
    HCRYPTPROV hProv = NULL;
    int        iMsg;

    // generate key first
    hr = csiGenerateKeysOnly(
		    pwszContainer,
		    pwszProvName,
		    dwProvType,
		    fMachineKeyset,
		    dwKeyLength,
		    fUnattended,
            fEnableKeyCounting,
		    &hProv,
		    &iMsg);
    if (S_OK != hr)
    {
        CertWarningMessageBox(
			hInstance,
			fUnattended,
			hwnd,
			iMsg,
			hr,
			pwszContainer);
        *pfKeyGenFailed = TRUE;
        _JumpError(hr, error, "csiGenerateKeysOnly");
    }
    *pfKeyGenFailed = FALSE;

    // now apply acl on key
    // BUG, this is not necessary, CertSrvSetSecurity will reset
    hr = csiSetKeyContainerSecurity(hProv);
    if (S_OK != hr)
    {
        CertWarningMessageBox(
			hInstance,
			fUnattended,
			hwnd,
			IDS_ERR_KEYSECURITY,
			hr,
			pwszContainer);
        _PrintError(hr, "csiSetKeyContainerSecurity");
    }
    hr = S_OK;

error:
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


HRESULT
csiGetProviderTypeFromProviderName(
    IN WCHAR const *pwszName,
    OUT DWORD      *pdwType)
{
    HRESULT  hr;
    DWORD i;
    DWORD dwProvType;
    WCHAR *pwszProvName = NULL;

    // Provider name should not be null.  This could be changed to ...
    CSASSERT(NULL != pwszName); 

    *pdwType = 0;
    dwProvType = 0;

    for (i = 0; ; i++)
    {
	// get provider name

	hr = myEnumProviders(i, NULL, 0, &dwProvType, &pwszProvName);
	if (S_OK != hr)
	{
	    hr = myHLastError();
	    CSASSERT(
		HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr ||
		NTE_FAIL == hr);

	    if(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr ||
		NTE_FAIL == hr)
	    {
		// no more providers, terminate loop

		hr = E_INVALIDARG;
		CSILOG(
		    hr,
		    IDS_ILOG_MISSING_PROVIDER,
		    pwszName,
		    NULL,
		    NULL);
		_JumpErrorStr(hr, error, "not found", pwszName);
            }
	}
	else
	{
	    CSASSERT(NULL != pwszProvName);
	    if (0 == mylstrcmpiL(pwszName, pwszProvName))
	    {
		break;	// found it
	    }
	    LocalFree(pwszProvName);
	    pwszProvName = NULL;
	}
    }
    *pdwType = dwProvType;
    hr = S_OK;

error:
    if (NULL != pwszProvName)
    {
        LocalFree(pwszProvName);
    }
    return(hr);
}

HRESULT
csiUpgradeCertSrvSecurity(
    IN WCHAR const *pwszSanitizedCAName, 
    BOOL            fUseEnterpriseACL, // which ACL to use
    BOOL            fSetDsSecurity,    // whether to set security on DS object
    CS_ENUM_UPGRADE UpgradeType) 
{
    HRESULT hr = S_OK;
    CertSrv::CCertificateAuthoritySD CASD;
    PSECURITY_DESCRIPTOR pDefaultSD = NULL;

    hr = CASD.Initialize(pwszSanitizedCAName);
    _PrintIfError(hr, "CASD.Initialize");
    if(S_OK==hr)
    {
        if(CS_UPGRADE_WHISTLER==UpgradeType)
        {
            // validate the SD
            hr = CASD.Validate(CASD.Get());
            _PrintIfError(hr, "CASD.Validate");
        }
        else // win2k
        {
            hr = CASD.UpgradeWin2k(fUseEnterpriseACL?true:false);
            _PrintIfError(hr, "CASD.UpgradeWin2k");
        }
    }

    // never fail, fall back to a default SD

    if(S_OK!=hr)
    {
        CASD.Uninitialize();

        hr = CASD.InitializeFromTemplate(
                    fUseEnterpriseACL?
                    WSZ_DEFAULT_CA_ENT_SECURITY :
                    WSZ_DEFAULT_CA_STD_SECURITY,
                    pwszSanitizedCAName);
        _JumpIfError(hr, error, 
                "CProtectedSecurityDescriptor::InitializeFromTemplate");
    }

    hr = CASD.Save();
    _JumpIfError(hr, error, "CASD.Save");

    hr = CASD.MapAndSetDaclOnObjects(fSetDsSecurity? true:false);
    _PrintIfError(hr, "CASD::MapAndSetDaclOnObjects");

    // When upgrading from win2k we need to upgrade security in DS. Usually 
    // DS is unavailable during upgrade.
    if ((hr != S_OK) && fSetDsSecurity && (UpgradeType == CS_UPGRADE_WIN2000))
    {
        // if asked to set security on DS and this is UPGRADE, we can't touch DS. 
        // Leave security changes to the certsrv snapin 

        // set a flag so certmmc knows to do something
        hr = SetSetupStatus(pwszSanitizedCAName, SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG, TRUE);
        _JumpIfError(hr, error, "SetSetupStatus");      

        hr = HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE);
        _PrintError(hr, "DS unavailable");
    }
    else
    {
        // make sure this bit is cleared
        hr = SetSetupStatus(pwszSanitizedCAName, SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG, FALSE);
        _JumpIfError(hr, error, "SetSetupStatus");      
    }

error:
    LOCAL_FREE(pDefaultSD);
    return hr;
}

DefineAutoClass(CAutoPCERT_NAME_INFO, PCERT_NAME_INFO, LocalFree);
DefineAutoClass(CAutoPCERT_RDN, PCERT_RDN, LocalFree);

HRESULT AddCNAndEncode(
    LPCWSTR pcwszName,
    LPCWSTR pcwszDNSuffix,
    BYTE** ppbEncodedDN,
    DWORD *pcbEncodedDN)
{
    HRESULT hr;
    CAutoPBYTE pbDNSuffix;
    CAutoPCERT_NAME_INFO pCertNameInfo;
    DWORD cbCertNameInfo;
    CAutoPCERT_RDN pCertRDN;
    CERT_RDN_ATTR attrDN;
    CAutoPBYTE pbEncodedDN;
    DWORD cbEncodedDN;

    attrDN.pszObjId = szOID_COMMON_NAME;
    attrDN.dwValueType = CERT_RDN_ANY_TYPE;
    attrDN.Value.cbData = 0;
    attrDN.Value.pbData = (PBYTE)pcwszName;

    hr = myCertStrToName(
        X509_ASN_ENCODING,
        pcwszDNSuffix,
        CERT_X500_NAME_STR | 
        CERT_NAME_STR_COMMA_FLAG | 
        CERT_NAME_STR_REVERSE_FLAG |
        ((g_dwNameEncodeFlags&CERT_RDN_ENABLE_UTF8_UNICODE_FLAG)?
        CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG:0), 
        NULL,
        &pbEncodedDN,
        &cbEncodedDN,
        NULL);
    _JumpIfError(hr, error, "myCertStrToName");

    if (!myDecodeName(
            X509_ASN_ENCODING,
            X509_UNICODE_NAME,
            pbEncodedDN,
            cbEncodedDN,
            CERTLIB_USE_LOCALALLOC,
            &pCertNameInfo,
            &cbCertNameInfo))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myDecodeName");
    }

    pCertRDN = (PCERT_RDN)LocalAlloc(
        LMEM_FIXED, 
        (pCertNameInfo->cRDN+1)*sizeof(CERT_RDN));
    _JumpIfAllocFailed(pCertRDN, error);

    CopyMemory(
        pCertRDN, 
        pCertNameInfo->rgRDN, 
        pCertNameInfo->cRDN*sizeof(CERT_RDN));

    pCertRDN[pCertNameInfo->cRDN].cRDNAttr = 1;
    pCertRDN[pCertNameInfo->cRDN].rgRDNAttr = &attrDN;

    pCertNameInfo->cRDN++;
    pCertNameInfo->rgRDN = pCertRDN;

    if (!myEncodeName(
		X509_ASN_ENCODING,
		pCertNameInfo,
		g_dwNameEncodeFlags,
		CERTLIB_USE_LOCALALLOC,
		ppbEncodedDN,
		pcbEncodedDN))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myEncodeName");
    }

error:
    return hr;
}


HRESULT
myLDAPAddOrRemoveMachine(
    bool fAdd, 
    LPWSTR pwszCertPublishersFilter)
{
    HRESULT hr = S_OK;
    LPWSTR pwszComputerDN = NULL;
    LDAP *pld = NULL;
    LPWSTR pwszComputerDomainDN; // no free
    LDAPMessage* pResult = NULL;
    LDAPMessage *pEntry;
    LPWSTR pwszAttrArray[2];
    LPWSTR pwszDNAttr = L"distinguishedName";
    LPWSTR pwszMemberAttr = L"member";
    LPWSTR* pwszCertPublishersDN = NULL;
    LDAPMod *mods[2];
    LDAPMod member;
    LPWSTR memberVals[2];
    
    hr = myGetComputerObjectName(
        NameFullyQualifiedDN,
        &pwszComputerDN);
    _JumpIfError(hr, error, "myGetComputerObjectName");

    pwszComputerDomainDN = wcsstr(pwszComputerDN, L"DC=");
    pwszAttrArray[0] = pwszDNAttr;
    pwszAttrArray[1] = NULL;

    hr = myLdapOpen(
		NULL,		// pwszDomainName
		RLBF_REQUIRE_SECURE_LDAP, // dwFlags
		&pld,
		NULL,		// pstrDomainDN
		NULL);		// pstrConfigDN
    _JumpIfError(hr, error, "myLdapOpen");

    hr = ldap_search_s(
                    pld,
                    pwszComputerDomainDN,
                    LDAP_SCOPE_SUBTREE,
                    pwszCertPublishersFilter,
                    pwszAttrArray,
                    FALSE,
                    &pResult);
    hr = myHLdapError(pld, hr, NULL);
    _JumpIfError(hr, error, "ldap_search_sW");

    pEntry = ldap_first_entry(pld, pResult);
    if (NULL == pEntry)
    {
        hr = ERROR_NO_SUCH_GROUP;
        _JumpErrorStr(hr, error, "ldap_search", pwszCertPublishersFilter);
    }

    pwszCertPublishersDN = ldap_get_values(
                            pld,
                            pEntry,
                            pwszDNAttr);

    if (NULL == pwszCertPublishersDN || NULL==*pwszCertPublishersDN)
    {
	hr = myHLdapLastError(pld, NULL);
        _JumpError(hr, error, "ldap_get_values");
    }

    memberVals[0] = pwszComputerDN;
    memberVals[1] = NULL;
    member.mod_op = fAdd?LDAP_MOD_ADD:LDAP_MOD_DELETE;
    member.mod_type = pwszMemberAttr;
    member.mod_values = memberVals;
    mods[0] = &member;
    mods[1] = NULL;

    hr = ldap_modify_ext_s(
                    pld,
                    *pwszCertPublishersDN,
                    mods,
                    NULL,
                    NULL);
    // don't fail if already member of cert publishers
    if(((HRESULT)LDAP_ALREADY_EXISTS)==hr)
        hr = LDAP_SUCCESS;

    hr = myHLdapError(pld, hr, NULL);
    _JumpIfErrorStr(hr, error, "ldap_modify_exts", *pwszCertPublishersDN);

error:
    LOCAL_FREE(pwszComputerDN);
    if (NULL != pwszCertPublishersDN)
    {
        ldap_value_free(pwszCertPublishersDN);
    }
    if (NULL != pResult)
    {
        ldap_msgfree(pResult);
    }
    myLdapClose(pld, NULL, NULL);
    return hr;
}


HRESULT AddOrRemoveMachineToGroup(
    PSID pGroupSid,
    bool fAdd)
{
    HRESULT hr;
    LPWSTR pwszFilter = NULL;
    LPWSTR pwszEscapedGroupSid = NULL;
    ULONG len;

    static LPCWSTR pcwszFilterFormat = 
        L"(&(objectCategory=group)(objectSid=%s))";

    len = ldap_escape_filter_element(
        (PCHAR)pGroupSid,
        GetLengthSid(pGroupSid),
        NULL,
        0);

    len *= sizeof(WCHAR);

    pwszEscapedGroupSid = (LPWSTR) LocalAlloc(LMEM_FIXED, len);
    _JumpIfAllocFailed(pwszEscapedGroupSid, error);

    ldap_escape_filter_element(
        (PCHAR)pGroupSid,
        GetLengthSid(pGroupSid),
        pwszEscapedGroupSid,
        len);
    
    pwszFilter = (LPWSTR)LocalAlloc(
			    LMEM_FIXED,
			    sizeof(WCHAR) *
				(wcslen(pcwszFilterFormat) +
				 wcslen(pwszEscapedGroupSid) +
				 1));
    _JumpIfAllocFailed(pwszFilter, error);

    wsprintf(
        pwszFilter,
        pcwszFilterFormat,
        pwszEscapedGroupSid);

    hr = myLDAPAddOrRemoveMachine(fAdd, pwszFilter);
    _JumpIfError(hr, error, "myLDAPAddOrRemoveMachine");

error:
    LOCAL_FREE(pwszFilter);
    LOCAL_FREE(pwszEscapedGroupSid);
    return hr;
}

HRESULT AddOrRemoveMachineToGroup(
    LPCWSTR pcwszGroupSid,
    bool fAdd)
{
    HRESULT hr;
    PSID pGroupSid = NULL;

    if(!ConvertStringSidToSid(
        pcwszGroupSid,
        &pGroupSid))
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "ConvertStringSidToSid", pcwszGroupSid);
    }
    myRegisterMemAlloc(pGroupSid, -1, CSM_LOCALALLOC);

    hr = AddOrRemoveMachineToGroup(
        pGroupSid,
        fAdd);
    _JumpIfError(hr, error, "AddOrRemoveMachineToGroup");

error:
    LOCAL_FREE(pGroupSid);
    return hr;
}

HRESULT
AddOrRemoveMachineToDomainGroup(
    IN bool fAdd)
{
    HRESULT hr;
    PSID pGroupSid = NULL;

    hr = myGetSidFromRid(
        DOMAIN_GROUP_RID_CERT_ADMINS,
        &pGroupSid,
        NULL);
    _JumpIfError(hr, error, "myGetSidFromRid");

    hr = AddOrRemoveMachineToGroup(pGroupSid, fAdd);
    _JumpIfError(hr, error, "AddOrRemoveMachineToGroup");

error:
    LOCAL_FREE(pGroupSid);
    return hr;
}
                   
HRESULT 
AddCAMachineToCertPublishers()
{
    return AddOrRemoveMachineToDomainGroup(true);
}

HRESULT 
RemoveCAMachineFromCertPublishers(VOID)
{
    return AddOrRemoveMachineToDomainGroup(false);
}

static LPCWSTR pcwszPreWin2kSid = L"S-1-5-32-554";

HRESULT AddCAMachineToPreWin2kGroup(VOID)
{
    return AddOrRemoveMachineToGroup(
        pcwszPreWin2kSid,
        true);
}

HRESULT RemoveCAMachineFromPreWin2kGroup(VOID)
{
    return AddOrRemoveMachineToGroup(
        pcwszPreWin2kSid,
        false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\include\tptrlist.h ===
namespace CertSrv
{
template <class C> class TPtrListEnum;

template <class C> class TPtrList
{
public:
    TPtrList() : m_pHead(NULL), m_dwCount(0) {}
    ~TPtrList(){ Cleanup(); }
    bool AddHead(C* pData);
    bool AddTail(C* pData);
    void Cleanup();
    DWORD GetCount() const { return m_dwCount;}
    bool IsEmpty() const {return NULL==m_pHead;}
    bool InsertAt(C* pData, DWORD dwIndex);
    bool RemoveAt(DWORD dwIndex);
    C* GetAt(DWORD dwIndex);
    C* Find(C& Data);
    DWORD FindIndex(C& Data);

    friend class TPtrListEnum<C>;

protected:
    struct TPtrListNode
    {
        TPtrListNode(C* pData) :
        m_pData(pData), m_pNext(NULL) {}
        ~TPtrListNode() { delete m_pData;}
        C* m_pData;
        TPtrListNode* m_pNext;
    };
    typedef TPtrListNode* TNODEPTR;
    typedef TPtrListNode  TNODE;

    TNODEPTR m_pHead;
    DWORD m_dwCount;
};

template <class C> class TPtrListEnum
{
public:
    TPtrListEnum() : m_pList(NULL), m_pCrt(NULL) {}
    TPtrListEnum(const TPtrList<C>& List) { Set(List);}
    void Set(const TPtrList<C>& List) { m_pList = &List; Reset(); }
    void Reset() { m_pCrt = m_pList->m_pHead; }
    C*   Next();

protected:
    const TPtrList<C> *m_pList;
    typename TPtrList<C>::TNODEPTR m_pCrt;
};

template <class C> C* TPtrListEnum<C>::Next()
{
    if(!m_pCrt)
        return NULL;
    C* pResult = m_pCrt->m_pData;
    m_pCrt = m_pCrt->m_pNext;
    return pResult;
}

template <class C> void TPtrList<C>::Cleanup()
{
    TNODEPTR pCrt, pNext;
    for(pCrt = m_pHead; pCrt; pCrt=pNext)
    {
        pNext = pCrt->m_pNext;
        delete pCrt;
    }
    m_pHead = NULL;
    m_dwCount = 0;
}

template <class C> bool TPtrList<C>::AddHead(C* pData)
{
    TNODEPTR pNew = new TNODE(pData);
    if(!pNew)
        return false;
    pNew->m_pNext = m_pHead;
    m_pHead = pNew;
    m_dwCount++;
    return true;
}


template <class C> bool TPtrList<C>::AddTail(C* pData)
{
    TNODEPTR pNew =  new TNODE(pData);
    if(!pNew)
        return false;
    for(TNODEPTR *ppCrt = &m_pHead; *ppCrt; ppCrt = &(*ppCrt)->m_pNext)
        NULL;
    *ppCrt = pNew;
    m_dwCount++;
    return true;
}

template <class C> C* TPtrList<C>::Find(C& Data)
{
    TPtrListEnum<C> ListEnum(*this);
    for(C* pResult = ListEnum.Next(); pResult; pResult= ListEnum.Next())
    {
        if(*pResult == Data)
            return pResult;
    }
    return NULL;
}

#define DWORD_MAX 0xffffffff
template <class C> DWORD TPtrList<C>::FindIndex(C& Data)
{
    DWORD dwIndex = 0;
    TPtrListEnum<C> ListEnum(*this);
    for(C* pResult = ListEnum.Next();
        pResult;
        pResult= ListEnum.Next(), dwIndex++)
    {
        if(*pResult == Data)
            return dwIndex;
    }
    return DWORD_MAX;
}

template <class C> bool TPtrList<C>::InsertAt(C* pData, DWORD dwIndex)
{
    DWORD dwCrt;
    TNODEPTR *ppCrt;
    TNODEPTR pNew =  new TNODE(pData);
    if(!pNew)
        return false;
    for(ppCrt = &m_pHead, dwCrt=0;
        NULL!=*ppCrt && (dwCrt<dwIndex);
        ppCrt = &(*ppCrt)->m_pNext, dwCrt++)
        NULL;
    pNew->m_pNext = *ppCrt;
    *ppCrt = pNew;
    m_dwCount++;
    return true;
}
template <class C> bool TPtrList<C>::RemoveAt(DWORD dwIndex)
{
    DWORD dwCrt;
    TNODEPTR *ppCrt, pDel;
    for(ppCrt = &m_pHead, dwCrt=0;
        NULL!=*ppCrt && (dwCrt<dwIndex);
        ppCrt = &(*ppCrt)->m_pNext, dwCrt++)
        NULL;
    if(!*ppCrt)
        return false;
    pDel = *ppCrt;
    *ppCrt = (*ppCrt)->m_pNext;
    delete pDel;
    m_dwCount--;
    return true;
}

template <class C> C* TPtrList<C>::GetAt(DWORD dwIndex)
{
    DWORD dwCrt;
    TNODEPTR pCrt;
    for(pCrt = m_pHead, dwCrt=0;
        NULL!=pCrt && (dwCrt<dwIndex);
        pCrt = pCrt->m_pNext, dwCrt++)
        NULL;
    return pCrt?pCrt->m_pData:NULL;
}

} // namespace CertSrv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\initlib\certhier.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certhier.cpp
//
//  Contents:   Install cert server hierarchical
//
//  History:    09-26-96
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

// C Run-Time Includes
#include <stdlib.h>
#include <string.h>
#include <memory.h>


// Windows System Includes
#include <winsvc.h>
#include <rpc.h>
#include <tchar.h>
#include <csdisp.h>
#include <certca.h>

// Application Includes
#include "cscsp.h"
#include "certmsg.h"
#include "certhier.h"
#include "setupids.h"

#include "tfc.h"

#define __dwFILE__	__dwFILE_INITLIB_CERTHIER_CPP__

// following veriables are extern in initlib, bad.
LPSTR pszObjIdSignatureAlgorithm = szOID_OIWSEC_sha1RSASign;


HRESULT
csiFillKeyProvInfo(
    IN WCHAR const          *pwszContainerName,
    IN WCHAR const          *pwszProvName,
    IN DWORD		     dwProvType,
    IN BOOL		     fMachineKeyset,
    OUT CRYPT_KEY_PROV_INFO *pKeyProvInfo) // call csiFreeKeyProvInfo to free
{
    HRESULT hr;
    WCHAR *pwszContainerNameT = NULL;
    WCHAR *pwszProvNameT = NULL;

    ZeroMemory(pKeyProvInfo, sizeof(*pKeyProvInfo));

    hr = myDupString(pwszContainerName, &pwszContainerNameT);
    _JumpIfError(hr, error, "myDupString");

    hr = myDupString(pwszProvName, &pwszProvNameT);
    _JumpIfError(hr, error, "myDupString");

    pKeyProvInfo->pwszContainerName = pwszContainerNameT;
    pKeyProvInfo->pwszProvName = pwszProvNameT;
    pKeyProvInfo->dwProvType = dwProvType;
    if (fMachineKeyset)
    {
       pKeyProvInfo->dwFlags = CRYPT_MACHINE_KEYSET;
    }
    pKeyProvInfo->dwKeySpec = AT_SIGNATURE;
    pwszContainerNameT = NULL;
    pwszProvNameT = NULL;
    hr = S_OK;

error:
    if (NULL != pwszContainerNameT)
    {
	LocalFree(pwszContainerNameT);
    }
    if (NULL != pwszProvNameT)
    {
	LocalFree(pwszProvNameT);
    }
    return(hr);
}


VOID
csiFreeKeyProvInfo(
    IN OUT CRYPT_KEY_PROV_INFO *pKeyProvInfo)
{
    if (NULL != pKeyProvInfo->pwszProvName)
    {
	LocalFree(pKeyProvInfo->pwszProvName);
	pKeyProvInfo->pwszProvName = NULL;
    }
    if (NULL != pKeyProvInfo->pwszContainerName)
    {
	LocalFree(pKeyProvInfo->pwszContainerName);
	pKeyProvInfo->pwszContainerName = NULL;
    }
}


HRESULT
GetCertServerKeyProviderInfo(
    IN WCHAR const          *pwszSanitizedCAName,
    IN WCHAR const          *pwszKeyContainerName,
    OUT ALG_ID		    *pidAlg,
    OUT BOOL		    *pfMachineKeyset,
    OUT CRYPT_KEY_PROV_INFO *pKeyProvInfo) // call csiFreeKeyProvInfo to free
{
    HRESULT hr;
    WCHAR *pwszProvName = NULL;
    DWORD dwProvType;

    ZeroMemory(pKeyProvInfo, sizeof(*pKeyProvInfo));

    // get CSP info

    hr = myGetCertSrvCSP(
		    FALSE,		// fEncryptionCSP
		    pwszSanitizedCAName,
		    &dwProvType,
		    &pwszProvName,
		    pidAlg,
		    pfMachineKeyset,
		    NULL);		// pdwKeySize
    _JumpIfError(hr, error, "myGetCertSrvCSP");

    hr = csiFillKeyProvInfo(
		    pwszKeyContainerName,
		    pwszProvName,
		    dwProvType,
		    *pfMachineKeyset,
		    pKeyProvInfo);
    _JumpIfError(hr, error, "csiFillKeyProvInfo");

error:
    if (NULL != pwszProvName)
    {
	LocalFree(pwszProvName);
    }
    return(hr);
}


HRESULT
mySetCertRegKeyIndexAndContainer(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD iKey,
    IN WCHAR const *pwszKeyContainer)
{
    HRESULT hr;
    
    hr = mySetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGREQUESTKEYINDEX,
			iKey);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValue", wszREGREQUESTKEYINDEX);

    hr = mySetCertRegStrValue(
			 pwszSanitizedCAName,
			 NULL,
			 NULL,
			 wszREGREQUESTKEYCONTAINER,
			 pwszKeyContainer);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", wszREGREQUESTKEYCONTAINER);

error:
    return(hr);
}


HRESULT
myGetCertRegKeyIndexAndContainer(
    IN WCHAR const *pwszSanitizedCAName,
    OUT DWORD *piKey,
    OUT WCHAR **ppwszKeyContainer)
{
    HRESULT hr;
    
    *ppwszKeyContainer = NULL;

    hr = myGetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGREQUESTKEYINDEX,
			piKey);
    if (S_OK != hr)
    {
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
	{
	    _JumpErrorStr(hr, error, "myGetCertRegDWValue", wszREGREQUESTKEYINDEX);
	}
	*piKey = 0;
    }

    hr = myGetCertRegStrValue(
		    pwszSanitizedCAName,
		    NULL,
		    NULL,
		    wszREGREQUESTKEYCONTAINER,
		    ppwszKeyContainer);
    if (S_OK != hr)
    {
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
	{
	    _JumpErrorStr(hr, error, "myGetCertRegStrValue", wszREGREQUESTKEYCONTAINER);
	}
	hr = myDupString(pwszSanitizedCAName, ppwszKeyContainer);
	_JumpIfError(hr, error, "myDupString");
    }
    CSASSERT(S_OK == hr);

error:
    return(hr);
}


HRESULT
FinishSuspendedSetupFromPKCS7(
    IN HINSTANCE    hInstance,
    IN BOOL         fUnattended,
    IN HWND         hwnd,
    IN WCHAR const *pwszSanitizedCAName,
    IN OPTIONAL WCHAR const *pwszKeyContainer,
    IN DWORD        iKey,
    IN BOOL         fRenew,
    IN BYTE const  *pbChain,
    IN DWORD        cbChain)
{
    HRESULT  hr;
    CRYPT_KEY_PROV_INFO KeyProvInfo;
    WCHAR *pwszCommonName = NULL;
    WCHAR *pwszServerName = NULL;
    WCHAR *pwszCertFile = NULL;
    WCHAR *pwszKeyContainerReg = NULL;
    ENUM_CATYPES CAType;
    DWORD iCertNew;
    BOOL fUseDS;
    ALG_ID idAlg;
    BOOL fMachineKeyset;

    ZeroMemory(&KeyProvInfo, sizeof(KeyProvInfo));

    hr = myGetCARegHashCount(pwszSanitizedCAName, CSRH_CASIGCERT, &iCertNew);
    _JumpIfError(hr, error, "myGetCARegHashCount");

    if (NULL == pwszKeyContainer)
    {
	// get Key Index and Container name from registry

	hr = myGetCertRegKeyIndexAndContainer(
			    pwszSanitizedCAName,
			    &iKey,
			    &pwszKeyContainerReg);
	_JumpIfError(hr, error, "myGetCertRegKeyIndexAndContainer");

	pwszKeyContainer = pwszKeyContainerReg;
    }

    // get CSP info
    hr = GetCertServerKeyProviderInfo(
			    pwszSanitizedCAName,
			    pwszKeyContainer,
			    &idAlg,
			    &fMachineKeyset,
			    &KeyProvInfo);
    _JumpIfError(hr, error, "GetCertServerKeyProviderInfo");

    // get common name
    hr = myGetCertRegStrValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGCOMMONNAME,
			&pwszCommonName);
    _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", wszREGCOMMONNAME);

    // get ca type

    hr = myGetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGCATYPE,
			(DWORD *) &CAType);
    _JumpIfErrorStr(hr, error, "myGetCertRegDWValue", wszREGCATYPE);

    // use DS or not

    hr = myGetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGCAUSEDS,
			(DWORD *) &fUseDS);
    _JumpIfErrorStr(hr, error, "myGetCertRegDWValue", wszREGCAUSEDS);

    // server name

    hr = myGetCertRegStrValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGCASERVERNAME,
			&pwszServerName);
    _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", wszREGCASERVERNAME);

    hr = myGetCARegFileNameTemplate(
			wszREGCACERTFILENAME,
			pwszServerName,
			pwszSanitizedCAName,
			iCertNew,
			iKey,
			&pwszCertFile);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
	_JumpIfError(hr, error, "myGetCARegFileNameTemplate");
    }

    hr = csiFinishInstallationFromPKCS7(
			    hInstance,
			    fUnattended,
			    hwnd,
			    pwszSanitizedCAName,
			    pwszCommonName,
			    &KeyProvInfo,
			    CAType,
			    iCertNew,
			    iKey,
			    fUseDS,
			    fRenew,
			    pwszServerName,
			    pbChain,
			    cbChain,
			    pwszCertFile);
    _JumpIfError(hr, error, "csiFinishInstallationFromPKCS7");

error:
    if (NULL != pwszKeyContainerReg)
    {
        LocalFree(pwszKeyContainerReg);
    }
    if (NULL != pwszCommonName)
    {
        LocalFree(pwszCommonName);
    }
    if (NULL != pwszCertFile)
    {
        LocalFree(pwszCertFile);
    }
    if (NULL != pwszServerName)
    {
        LocalFree(pwszServerName);
    }
    csiFreeKeyProvInfo(&KeyProvInfo);
    CSILOG(hr, IDS_ILOG_FINISHSUSPENDEDSETUP, NULL, NULL, NULL);
    return(hr);
}


typedef struct _CERTHIERINFO
{
    HINSTANCE   hInstance;
    BOOL        fUnattended;
    WCHAR      *pwszSanitizedCAName;
    WCHAR      *pwszParentMachine;
    WCHAR      *pwszParentCA;
    WCHAR      *pwszParentMachineDefault;
    WCHAR      *pwszParentCADefault;
    DWORD       iCertNew;
    DWORD       iKey;
} CERTHIERINFO;


VOID
FreeCertHierInfo(
    IN OUT CERTHIERINFO *pCertHierInfo)
{
    if (NULL != pCertHierInfo->pwszSanitizedCAName)
    {
        LocalFree(pCertHierInfo->pwszSanitizedCAName);
    }
    if (NULL != pCertHierInfo->pwszParentMachine)
    {
        LocalFree(pCertHierInfo->pwszParentMachine);
    }
    if (NULL != pCertHierInfo->pwszParentCA)
    {
        LocalFree(pCertHierInfo->pwszParentCA);
    }
    if (NULL != pCertHierInfo->pwszParentMachineDefault)
    {
        LocalFree(pCertHierInfo->pwszParentMachineDefault);
    }
    if (NULL != pCertHierInfo->pwszParentCADefault)
    {
        LocalFree(pCertHierInfo->pwszParentCADefault);
    }
}


CERTSRVUICASELECTION g_CertHierCARequestUICASelection =
    { NULL, NULL, NULL, NULL, NULL, ENUM_UNKNOWN_CA, false, true };

HRESULT
csiGetCARequestFileName(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD        iCertNew,
    IN DWORD        iKey,
    OUT WCHAR     **ppwszRequestFile)
{
    HRESULT  hr;
    WCHAR   *pwszServerName = NULL;
    WCHAR   *pwszRequestFile = NULL;
    WCHAR   *pwszSharedFolder = NULL;

    // init
    *ppwszRequestFile = NULL;

    // get server name
    hr = myGetCertRegStrValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGCASERVERNAME,
			&pwszServerName);
    _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", wszREGCASERVERNAME);

    hr = myGetCARegFileNameTemplate(
                        wszREGREQUESTFILENAME,
                        pwszServerName,
                        pwszSanitizedCAName,
                        iCertNew,
                        iKey,
                        &pwszRequestFile);
    if (S_OK != hr)
    {
        hr = myGetCertRegStrValue(
                        NULL,
                        NULL,
                        NULL,
                        wszREGDIRECTORY,
                        &pwszSharedFolder);
        if (S_OK != hr)
        {
            CSASSERT(NULL == pwszSharedFolder);
        }

        hr = csiBuildCACertFileName(
				    hInstance,
				    hwnd,
				    TRUE, 		// fUnattended
				    pwszSharedFolder,
				    pwszSanitizedCAName,
				    L".req",
				    0,			// iCertNew == 0!
				    &pwszRequestFile);
        _JumpIfError(hr, error, "csiBuildCACertFileName");

        hr = mySetCARegFileNameTemplate(
				wszREGREQUESTFILENAME,
				pwszServerName,
				pwszSanitizedCAName,
				pwszRequestFile);
        _JumpIfError(hr, error, "mySetCARegFileNameTemplate");

        LocalFree(pwszRequestFile);
        pwszRequestFile = NULL;

        hr = csiBuildCACertFileName(
				    hInstance,
				    hwnd,
				    TRUE, 		// fUnattended
				    pwszSharedFolder,
				    pwszSanitizedCAName,
				    L".req",
				    iCertNew,
				    &pwszRequestFile);
        _JumpIfError(hr, error, "csiBuildCACertFileName");
    }

    *ppwszRequestFile = pwszRequestFile;
    pwszRequestFile = NULL;

    hr = S_OK;
error:
    if (NULL != pwszRequestFile)
    {
        LocalFree(pwszRequestFile);
    }
    if (NULL != pwszServerName)
    {
        LocalFree(pwszServerName);
    }
    if (NULL != pwszSharedFolder)
    {
        LocalFree(pwszSharedFolder);
    }
    return hr;
}

HRESULT
InitCertHierControls(
    HWND          hDlg,
    CERTHIERINFO *pCertHierInfo)
{
    HRESULT hr;
    BOOL fCAsExist;
    WCHAR *pwszHelpText = NULL;
    WCHAR *pwszRequestFile = NULL;
    WCHAR *pwszExpandedHelpText = NULL;
    WCHAR *pwszzCAList = NULL;
    BOOL fSetCA = FALSE;

    if (NULL != pCertHierInfo->pwszParentMachineDefault)
    {
        if (!SetWindowText(
		GetDlgItem(hDlg, IDC_PARENT_COMPUTER_NAME),
		pCertHierInfo->pwszParentMachineDefault))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "SetWindowText");
	}

	if (NULL != pCertHierInfo->pwszParentCADefault)
	{
	    DWORD cwcCA = wcslen(pCertHierInfo->pwszParentCADefault);
	    
	    pwszzCAList = (WCHAR *) LocalAlloc(
					    LMEM_FIXED,
					    (cwcCA + 2) * sizeof(WCHAR));
	    if (NULL == pwszzCAList)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    wcscpy(pwszzCAList, pCertHierInfo->pwszParentCADefault);
	    pwszzCAList[cwcCA + 1] = L'\0';

	    hr = myUICASelectionUpdateCAList(
				    GetDlgItem(hDlg, IDC_PARENT_CA_NAME),
				    pwszzCAList);
	    _JumpIfError(hr, error, "myUICASelectionUpdateCAList");

	    fSetCA = TRUE;
	}
    }

    // load formatted help string
    hr = myLoadRCString(
             pCertHierInfo->hInstance,
             IDS_REQUEST_HELPTEXT,
             &pwszHelpText);
    _JumpIfError(hr, error, "myLoadRCString");

    // get request file name
    hr = csiGetCARequestFileName(
                         pCertHierInfo->hInstance,
                         hDlg,
                         pCertHierInfo->pwszSanitizedCAName,
                         pCertHierInfo->iCertNew,
                         pCertHierInfo->iKey,
                         &pwszRequestFile);
    _JumpIfError(hr, error, "csiGetCARequestFileName");

    // replace %1
    if (!FormatMessage(
                 FORMAT_MESSAGE_ALLOCATE_BUFFER |
                 FORMAT_MESSAGE_FROM_STRING |
                 FORMAT_MESSAGE_ARGUMENT_ARRAY,
                 pwszHelpText,
                 0,
                 0,
                 reinterpret_cast<WCHAR *>(&pwszExpandedHelpText),
                 0,
                 reinterpret_cast<va_list *>
                     (const_cast<WCHAR **>(&pwszRequestFile))) )
    {
        hr = myHLastError();
        _JumpError(hr, error, "FormatMessage");
    }

    // set help text
    SetWindowText(GetDlgItem(hDlg, IDC_REQUEST_HELPTEXT), pwszExpandedHelpText);

    hr = myInitUICASelectionControls(
			    &g_CertHierCARequestUICASelection,
			    pCertHierInfo->hInstance,
			    hDlg,
			    GetDlgItem(hDlg, IDC_BROWSE_CA),
			    GetDlgItem(hDlg, IDC_PARENT_COMPUTER_NAME),
			    GetDlgItem(hDlg, IDC_PARENT_CA_NAME),
			    csiIsAnyDSCAAvailable(),
			    &fCAsExist);
    _JumpIfError(hr, error, "myInitUICASelectionControls");

    if (fSetCA)
    {
	hr = myUICAConditionallyDisplayEnterpriseWarning(
					    &g_CertHierCARequestUICASelection);
	_JumpIfError(hr, error, "myUICAConditionallyDisplayEnterpriseWarning");
    }

error:
    if (NULL != pwszzCAList)
    {
        LocalFree(pwszzCAList);
    }
    if (NULL != pwszHelpText)
    {
        LocalFree(pwszHelpText);
    }
    if (NULL != pwszRequestFile)
    {
        LocalFree(pwszRequestFile);
    }
    if (NULL != pwszExpandedHelpText)
    {
        LocalFree(pwszExpandedHelpText);
    }
    return(hr);
}


HRESULT
HandleOKButton(
    HWND          hDlg,
    CERTHIERINFO *pCertHierInfo,
    BOOL         *pfLeave)
{
    HRESULT   hr;
    WCHAR    *pwszParentMachine = NULL;
    WCHAR    *pwszParentCA = NULL;

    hr = myUICASelectionValidation(&g_CertHierCARequestUICASelection, pfLeave);
    _JumpIfError(hr, error, "myUICASelectionValidation");
    if (!*pfLeave)
    {
        goto error;
    }
    
    // get parent ca info
    hr = myUIGetWindowText(GetDlgItem(hDlg, IDC_PARENT_COMPUTER_NAME),
                           &pwszParentMachine);
    _JumpIfError(hr, error, "myUIGetWindowText");

    hr = myUIGetWindowText(GetDlgItem(hDlg, IDC_PARENT_CA_NAME),
                           &pwszParentCA);
    _JumpIfError(hr, error, "myUIGetWindowText");

    pCertHierInfo->pwszParentMachine = pwszParentMachine;
    pwszParentMachine = NULL;
    pCertHierInfo->pwszParentCA = pwszParentCA;
    pwszParentCA = NULL;

    hr = S_OK;
error:
    if (NULL != pwszParentMachine)
    {
        LocalFree(pwszParentMachine);
    }
    if (NULL != pwszParentCA)
    {
        LocalFree(pwszParentCA);
    }
    return(hr);
}


INT_PTR CALLBACK
CertHierProc(
    HWND hDlg,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    HRESULT hr;
    BOOL  ret = FALSE;
    BOOL  fLeave;
    static CERTHIERINFO *s_pCertHierInfo = NULL;
    static BOOL s_fComputerChange = FALSE;

    switch (iMsg)
    {
        case WM_INITDIALOG:
            s_pCertHierInfo = (CERTHIERINFO *) lParam;

            hr = InitCertHierControls(hDlg, s_pCertHierInfo);
            _JumpIfError(hr, error, "InitCertHierControls");

            ret = TRUE;
	    break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
	    {
                case IDC_BROWSE_CA:
                    ret = TRUE;
                    hr = myUICAHandleCABrowseButton(
                              &g_CertHierCARequestUICASelection,
                              csiIsAnyDSCAAvailable(),
                              IDS_CA_PICKER_TITLE,
                              IDS_CA_PICKER_PROMPT,
                              NULL);
                    _JumpIfError(hr, error, "myUICAHandleCABrowseButton");
		    break;

                case IDC_PARENT_CA_NAME:
                    hr = myUICAHandleCAListDropdown(
                                (int)HIWORD(wParam),
                                &g_CertHierCARequestUICASelection,
                                &s_fComputerChange);
                    _PrintIfError(hr, "myUICAHandleCAListDropdown");
                    break;

                case IDC_PARENT_COMPUTER_NAME:
                    switch ((int)HIWORD(wParam))
                    {
                        case EN_CHANGE: // edit change
			    s_fComputerChange = TRUE;
			    break;
                    }
                    break;

                case IDOK:
                    ret = TRUE;
                    hr = HandleOKButton(hDlg, s_pCertHierInfo, &fLeave);
                    _PrintIfError(hr, "HandleOKButton");
                    if (fLeave)
                    {
                        // update return status
                        ret = EndDialog(hDlg, IDOK);
                        goto error; //done;
                    }
		    break;

                case IDCANCEL:
                    ret = EndDialog(hDlg, IDCANCEL);
		    break;
            }
	    break;
    }

error:
    return(ret);
}


VOID
MarkSetupComplete(
    IN WCHAR const *pwszSanitizedCAName)
{
    HRESULT hr;
    
    // Clear pending/denied flags:

    hr = SetSetupStatus(
		pwszSanitizedCAName,
		SETUP_SUSPEND_FLAG |
		    SETUP_ONLINE_FLAG |
		    SETUP_REQUEST_FLAG |
		    SETUP_DENIED_FLAG,
		FALSE);
    _PrintIfError(hr, "SetSetupStatus");

    // Force new CRL generation on startup:
    
    hr = SetSetupStatus(pwszSanitizedCAName, SETUP_FORCECRL_FLAG, TRUE);
    _PrintIfError(hr, "SetSetupStatus");

    CSILOG(hr, IDS_ILOG_SETUPCOMPLETE, NULL, NULL, NULL);
}


HRESULT
FindKeyIndex(
    IN HCERTSTORE hMyStore,
    IN WCHAR const *pwszSanitizedCAName,
    IN BOOL fUnattended,
    IN BOOL fMachineKeyset,
    IN DWORD cCert,
    CRYPT_KEY_PROV_INFO *pKeyMatch,
    OUT DWORD *piKey)
{
    HRESULT hr;
    DWORD i;
    CERT_CONTEXT const *pccCert = NULL;
    CRYPT_KEY_PROV_INFO *pKey = NULL;
    HCRYPTPROV hProv = NULL;
    CERT_PUBLIC_KEY_INFO *pPubKeyMatch = NULL;
    CERT_PUBLIC_KEY_INFO *pPubKey = NULL;
    DWORD cb;
    DWORD NameId;

    *piKey = MAXDWORD;

    // get CSP handle

    if (!myCertSrvCryptAcquireContext(
			    &hProv,
			    pKeyMatch->pwszContainerName,
			    pKeyMatch->pwszProvName,
			    pKeyMatch->dwProvType,
			    fUnattended? CRYPT_SILENT : 0,
			    fMachineKeyset))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }
    if (hProv == NULL)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }

    if (!myCryptExportPublicKeyInfo(
				hProv,
				AT_SIGNATURE,
				CERTLIB_USE_LOCALALLOC,
				&pPubKeyMatch,
				&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }
    CryptReleaseContext(hProv, 0);
    hProv = NULL;

    for (i = 0; ; i++)
    {
	if (i >= cCert)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _JumpError(hr, error, "old key not found");
	}
	hr = myFindCACertByHashIndex(
				hMyStore,
				pwszSanitizedCAName,
				CSRH_CASIGCERT,
				i,
				&NameId,
				&pccCert);
	if (S_FALSE == hr)
	{
	    continue;
	}
	_JumpIfError(hr, error, "myFindCACertByHashIndex");

	// get the key provider info

	if (!myCertGetCertificateContextProperty(
					pccCert,
					CERT_KEY_PROV_INFO_PROP_ID,
					CERTLIB_USE_LOCALALLOC,
					(VOID **) &pKey,
					&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetCertificateContextProperty");
	}

	// get CSP handle

	if (!myCertSrvCryptAcquireContext(
				&hProv,
				pKey->pwszContainerName,
				pKey->pwszProvName,
				pKey->dwProvType,
				fUnattended? CRYPT_SILENT : 0,
				fMachineKeyset))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myCertSrvCryptAcquireContext");
	}
	if (hProv == NULL)
	{
	    hr = E_HANDLE;
	    _JumpError(hr, error, "myCertSrvCryptAcquireContext");
	}

	if (!myCryptExportPublicKeyInfo(
				    hProv,
				    AT_SIGNATURE,
				    CERTLIB_USE_LOCALALLOC,
				    &pPubKey,
				    &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myCryptExportPublicKeyInfo");
	}

	// by design, CertComparePublicKeyInfo doesn't set last error!

	if (CertComparePublicKeyInfo(X509_ASN_ENCODING, pPubKey, pPubKeyMatch))
	{
	    hr = myGetNameId(pccCert, &NameId);
	    if (S_OK != hr)
	    {
		*piKey = i;
	    }
	    else
	    {
		*piKey = CANAMEIDTOIKEY(NameId);
	    }
	    break;
	}

        LocalFree(pPubKey);
        pPubKey = NULL;

	CryptReleaseContext(hProv, 0);
	hProv = NULL;

        LocalFree(pKey);
	pKey = NULL;

	CertFreeCertificateContext(pccCert);
	pccCert = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pPubKeyMatch)
    {
        LocalFree(pPubKeyMatch);
    }
    if (NULL != pPubKey)
    {
        LocalFree(pPubKey);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != pKey)
    {
        LocalFree(pKey);
    }
    if (NULL != pccCert)
    {
	CertFreeCertificateContext(pccCert);
    }
    CSILOG(hr, IDS_ILOG_KEYINDEX, NULL, NULL, piKey);
    return(hr);
}


HRESULT
LoadCurrentCACertAndKeyInfo(
    IN WCHAR const *pwszSanitizedCAName,
    IN BOOL fNewKey,
    IN BOOL fUnattended,
    IN BOOL fMachineKeyset,
    IN DWORD iCertNew,
    OUT DWORD *piKey,
    OUT WCHAR **ppwszKeyContainer,
    OUT CERT_CONTEXT const **ppccCertOld)
{
    HRESULT hr;
    HCERTSTORE hMyStore = NULL;
    DWORD cbKey;
    CRYPT_KEY_PROV_INFO *pKey = NULL;
    WCHAR *pwszKeyContainer = NULL;
    DWORD NameId;

    *ppwszKeyContainer = NULL;
    *ppccCertOld = NULL;
    *piKey = MAXDWORD;

    // open MY store
    hMyStore = CertOpenStore(
		       CERT_STORE_PROV_SYSTEM_W,
		       X509_ASN_ENCODING,
		       NULL,			// hProv
		       CERT_SYSTEM_STORE_LOCAL_MACHINE |
			   CERT_STORE_READONLY_FLAG,
		       wszMY_CERTSTORE);
    if (NULL == hMyStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }
    hr = myFindCACertByHashIndex(
			    hMyStore,
			    pwszSanitizedCAName,
			    CSRH_CASIGCERT,
			    iCertNew - 1,
			    &NameId,
			    ppccCertOld);
    _JumpIfError(hr, error, "myFindCACertByHashIndex");

    if (fNewKey)
    {
	*piKey = iCertNew;	// New key: iKey set to iCert

	hr = myAllocIndexedName(
			pwszSanitizedCAName,
			*piKey,
			MAXDWORD,		// IndexTarget
			&pwszKeyContainer);
	_JumpIfError(hr, error, "myAllocIndexedName");
    }
    else
    {
	// get the key provider info
	if (!myCertGetCertificateContextProperty(
					*ppccCertOld,
					CERT_KEY_PROV_INFO_PROP_ID,
					CERTLIB_USE_LOCALALLOC,
					(VOID **) &pKey,
					&cbKey))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetCertificateContextProperty");
	}
	hr = myDupString(pKey->pwszContainerName, &pwszKeyContainer);
	_JumpIfError(hr, error, "myDupString");

	// Reuse key: iKey set to match oldest iCert using this key:

	hr = FindKeyIndex(
		    hMyStore,
		    pwszSanitizedCAName,
		    fUnattended,
		    fMachineKeyset,
		    iCertNew,
		    pKey,
		    piKey);
	_JumpIfError(hr, error, "FindKeyIndex");

	CSASSERT(MAXDWORD != *piKey);
    }
    *ppwszKeyContainer = pwszKeyContainer;
    pwszKeyContainer = NULL;
    CSASSERT(S_OK == hr);

error:
    if (NULL != pwszKeyContainer)
    {
        LocalFree(pwszKeyContainer);
    }
    if (NULL != pKey)
    {
        LocalFree(pKey);
    }
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    CSILOG(hr, IDS_ILOG_LOADOLDCERT, *ppwszKeyContainer, NULL, piKey);
    return(hr);
}


HRESULT
ReplaceExtension(
    IN CERT_EXTENSION const *pExtension,
    IN OUT DWORD *pcExtension,
    IN OUT CERT_EXTENSION *rgExtension)
{
    DWORD i;

    CSASSERT(NULL != pExtension->pszObjId);
    for (i = 0; ; i++)
    {
	if (i == *pcExtension)
	{
	    if (NULL != pExtension->Value.pbData)
	    {
		(*pcExtension)++;	// not found: append to array
	    }
	    break;
	}
	CSASSERT(i < *pcExtension);
	if (0 == strcmp(pExtension->pszObjId, rgExtension[i].pszObjId))
	{
	    if (NULL == pExtension->Value.pbData)
	    {
		// remove extension: copy last extension on top of this one
		// and decrement extension count

		(*pcExtension)--;
		pExtension = &rgExtension[*pcExtension];
	    }
	    break;
	}
    }
    rgExtension[i] = *pExtension;	// append or overwrite extension
    return(S_OK);
}


HRESULT
GetMinimumCertValidityPeriod(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD cCert,
    OUT LONGLONG *pTimeDelta)
{
    HRESULT hr;
    HCERTSTORE hMyStore = NULL;
    DWORD NameId;
    CERT_CONTEXT const *pcc = NULL;
    BOOL fFirst = TRUE;
    DWORD i;

    // open MY store
    hMyStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_W,
			X509_ASN_ENCODING,
			NULL,			// hProv
			CERT_SYSTEM_STORE_LOCAL_MACHINE |
			    CERT_STORE_READONLY_FLAG,
			wszMY_CERTSTORE);
    if (NULL == hMyStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }
    for (i = 0; i < cCert; i++)
    {
	LONGLONG TimeDelta;

	hr = myFindCACertByHashIndex(
				hMyStore,
				pwszSanitizedCAName,
				CSRH_CASIGCERT,
				i,
				&NameId,
				&pcc);
	if (S_OK != hr)
	{
	    _PrintError(hr, "myFindCACertByHashIndex");
	    continue;
	}

	TimeDelta = mySubtractFileTimes(
					&pcc->pCertInfo->NotAfter,
					&pcc->pCertInfo->NotBefore);

	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "iCert=%u TimeDelta=%x:%x\n",
	    i,
	    (DWORD) (TimeDelta >> 32),
	    (DWORD) TimeDelta));

	if (fFirst || *pTimeDelta > TimeDelta)
	{
	    *pTimeDelta = TimeDelta;
	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"iCert=%u *pTimeDelta=%x:%x\n",
		i,
		(DWORD) (*pTimeDelta >> 32),
		(DWORD) *pTimeDelta));
	    fFirst = FALSE;
	}

	CertFreeCertificateContext(pcc);
	pcc = NULL;
    }
    if (fFirst)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "no old Certs");
    }
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
GetCertHashExtension(
    IN CERT_CONTEXT const *pCert,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData)
{
    HRESULT hr;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    CRYPT_DATA_BLOB Blob;
    DWORD cbHash;

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
			pCert,
			CERT_HASH_PROP_ID,
			abHash,
			&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }
    Blob.cbData = cbHash;
    Blob.pbData = abHash;
    if (!myEncodeObject(
		X509_ASN_ENCODING,
		X509_OCTET_STRING,
		&Blob,
		0,
		CERTLIB_USE_LOCALALLOC,
		ppbData,
		pcbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    return(hr);
}


VOID
csiLogInfError(
    IN HINF hInf,
    IN HRESULT hr)
{
    if (S_OK != hr && INVALID_HANDLE_VALUE != hInf)
    {
	WCHAR *pwszInfError = myInfGetError();

	_PrintErrorStr(hr, "csiLogInfError", pwszInfError);
	CSILOG(hr, IDS_ILOG_INFERROR, pwszInfError, NULL, NULL);
	if (NULL != pwszInfError)
	{
	    LocalFree(pwszInfError);
	}
    }
}


HRESULT
CloneRootCert(
    IN HINF hInf,
    IN CERT_CONTEXT const *pccCertOld,
    IN HCRYPTPROV hProv,
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD iCert,
    IN DWORD iKey,
    IN BOOL fUseDS,
    IN BOOL fNewKey,
    IN DWORD dwRevocationFlags,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd,
    OUT BYTE **ppbCert,
    OUT DWORD *pcbCert)
{
    HRESULT hr;
    CERT_INFO Cert;
    GUID guidSerialNumber;
    LONGLONG TimeDelta;
    CERT_PUBLIC_KEY_INFO *pPubKey = NULL;
    DWORD cbPubKey;
    DWORD NameId;
    CERT_EXTENSION *paext = NULL;
    FILETIME ftNotAfterMin;
    DWORD dwValidityPeriodCount;
    ENUM_PERIOD enumValidityPeriod;
    CERT_EXTENSION *pext;
    DWORD cExtInf = 0;
    CERT_EXTENSION *rgExtInf = NULL;
    DWORD cExtMerged;
    CERT_EXTENSION *rgExtMerged = NULL;

#define CEXT_REPLACED	9

    CERT_EXTENSION extBasicConstraints = 
                        { NULL,        			    FALSE, 0, NULL};
    CERT_EXTENSION extSKI = 
                        { szOID_SUBJECT_KEY_IDENTIFIER,     FALSE, 0, NULL };
    CERT_EXTENSION extCDP = 
                        { szOID_CRL_DIST_POINTS,            FALSE, 0, NULL };
    CERT_EXTENSION extVersion = 
                        { szOID_CERTSRV_CA_VERSION,         FALSE, 0, NULL };
    CERT_EXTENSION extPreviousHash = 
                        { szOID_CERTSRV_PREVIOUS_CERT_HASH, FALSE, 0, NULL };
    CERT_EXTENSION extPolicy = 
                        { szOID_CERT_POLICIES,		    FALSE, 0, NULL };
    CERT_EXTENSION extCross = 
                        { szOID_CROSS_CERT_DIST_POINTS,	    FALSE, 0, NULL };
    CERT_EXTENSION extAIA = 
                        { szOID_AUTHORITY_INFO_ACCESS,      FALSE, 0, NULL };
    CERT_EXTENSION extEKU =
			{ NULL,				    FALSE, 0, NULL};

    *ppbCert = NULL;

    CopyMemory(&Cert, pccCertOld->pCertInfo, sizeof(Cert));
    Cert.dwVersion = CERT_V3;
    myGenerateGuidSerialNumber(&guidSerialNumber);

    Cert.SerialNumber.pbData = (BYTE *) &guidSerialNumber;
    Cert.SerialNumber.cbData = sizeof(guidSerialNumber);
    if (!myAreBlobsSame(
		Cert.Issuer.pbData,
		Cert.Issuer.cbData,
		Cert.Subject.pbData,
		Cert.Subject.cbData))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "non-Root Cert");
    }

    if (!myCryptExportPublicKeyInfo(
				hProv,
				AT_SIGNATURE,
				CERTLIB_USE_LOCALALLOC,
				&pPubKey,
				&cbPubKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }

    Cert.SubjectPublicKeyInfo = *pPubKey;	// Structure assignment

    // make new cert expire at least 1 minute after old cert.

    ftNotAfterMin = Cert.NotAfter;
    myMakeExprDateTime(&ftNotAfterMin, 1, ENUM_PERIOD_MINUTES);

    GetSystemTimeAsFileTime(&Cert.NotBefore);

    hr = myInfGetValidityPeriod(
			hInf,
			NULL,		// pwszValidityPeriodCount
			NULL,		// pwszValidityPeriodString
			&dwValidityPeriodCount,
			&enumValidityPeriod,
			NULL);		// pfSwap
    csiLogInfError(hInf, hr);
    if (S_OK == hr)
    {
	Cert.NotAfter = Cert.NotBefore;
	myMakeExprDateTime(
		    &Cert.NotAfter,
		    dwValidityPeriodCount,
		    enumValidityPeriod);
	TimeDelta = 0;
    }
    else
    {
	hr = GetMinimumCertValidityPeriod(
				    pwszSanitizedCAName,
				    iCert,
				    &TimeDelta);
	_JumpIfError(hr, error, "GetMinimumCertValidityPeriod");

	CSASSERT(0 != TimeDelta);
    }
    myMakeExprDateTime(
		&Cert.NotBefore,
		-CCLOCKSKEWMINUTESDEFAULT,
		ENUM_PERIOD_MINUTES);
    if (0 != TimeDelta)
    {
	Cert.NotAfter = Cert.NotBefore;
	myAddToFileTime(&Cert.NotAfter, TimeDelta);
    }

    // make new cert expire at least 1 minute after old cert.

    if (0 > CompareFileTime(&Cert.NotAfter, &ftNotAfterMin))
    {
	Cert.NotAfter = ftNotAfterMin;
    }

    if (!fNewKey)
    {
	Cert.NotBefore = pccCertOld->pCertInfo->NotBefore;
    }

    paext = (CERT_EXTENSION *) LocalAlloc(
			LMEM_FIXED,
			(Cert.cExtension + CEXT_REPLACED) * sizeof(paext[0]));
    if (NULL == paext)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(paext, Cert.rgExtension, Cert.cExtension * sizeof(paext[0]));
    Cert.rgExtension = paext;

    // Basic constraints extension:

    hr = myInfGetBasicConstraints2CAExtensionOrDefault(hInf, &extBasicConstraints);
    csiLogInfError(hInf, hr);
    _JumpIfError(hr, error, "myInfGetBasicConstraints2CAExtensionOrDefault");

    ReplaceExtension(&extBasicConstraints, &Cert.cExtension, Cert.rgExtension);

    // Subject Key Identifier extension:
    // If we're reusing the old key, reuse the old SKI -- even if it's "wrong".

    pext = NULL;
    if (!fNewKey)
    {
	pext = CertFindExtension(
			    szOID_SUBJECT_KEY_IDENTIFIER,
			    Cert.cExtension,
			    Cert.rgExtension);
    }
    if (NULL == pext)
    {
	hr = myCreateSubjectKeyIdentifierExtension(
					pPubKey,
					&extSKI.Value.pbData,
					&extSKI.Value.cbData);
	_JumpIfError(hr, error, "myCreateSubjectKeyIdentifierExtension");

	ReplaceExtension(&extSKI, &Cert.cExtension, Cert.rgExtension);
    }

    hr = CreateRevocationExtension(
			    hInf,
			    pwszSanitizedCAName,
			    iCert,
			    iKey,
			    fUseDS,
			    dwRevocationFlags,
			    &extCDP.fCritical,
			    &extCDP.Value.pbData,
			    &extCDP.Value.cbData);
    _PrintIfError2(hr, "CreateRevocationExtension", S_FALSE);
    if (S_OK == hr || S_FALSE == hr)
    {
	ReplaceExtension(&extCDP, &Cert.cExtension, Cert.rgExtension);
    }

    // Build the CA Version extension

    NameId = MAKECANAMEID(iCert, iKey);

    if (!myEncodeObject(
		X509_ASN_ENCODING,
		X509_INTEGER,
		&NameId,
		0,
		CERTLIB_USE_LOCALALLOC,
		&extVersion.Value.pbData,
		&extVersion.Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    ReplaceExtension(&extVersion, &Cert.cExtension, Cert.rgExtension);


    // Build the previous CA cert hash extension

    hr = GetCertHashExtension(
			pccCertOld,
			&extPreviousHash.Value.pbData,
			&extPreviousHash.Value.cbData);
    _JumpIfError(hr, error, "GetCertHashExtension");

    ReplaceExtension(&extPreviousHash, &Cert.cExtension, Cert.rgExtension);


    // Build the Policy Statement extension

    hr = myInfGetPolicyStatementExtension(hInf, &extPolicy);
    csiLogInfError(hInf, hr);
    if (S_OK == hr || S_FALSE == hr)
    {
	ReplaceExtension(&extPolicy, &Cert.cExtension, Cert.rgExtension);
    }


    // Build the Cross Cert Dist Points extension

    hr = myInfGetCrossCertDistributionPointsExtension(hInf, &extCross);
    csiLogInfError(hInf, hr);
    if (S_OK == hr || S_FALSE == hr)
    {
	ReplaceExtension(&extCross, &Cert.cExtension, Cert.rgExtension);
    }


    // Build the Authority Information Access extension

    hr = CreateAuthorityInformationAccessExtension(
				hInf,
				pwszSanitizedCAName,
				iCert,
				iKey,
				fUseDS,
				&extAIA.fCritical,
				&extAIA.Value.pbData,
				&extAIA.Value.cbData);
    _PrintIfError3(
	    hr,
	    "CreateAuthorityInformationAccessExtension",
	    E_HANDLE,
	    S_FALSE);
    if (S_OK == hr || S_FALSE == hr)
    {
	ReplaceExtension(&extAIA, &Cert.cExtension, Cert.rgExtension);
    }


    // Build the Enhanced Key Usage extension

    hr = myInfGetEnhancedKeyUsageExtension(hInf, &extEKU);
    csiLogInfError(hInf, hr);
    if (S_OK == hr || S_FALSE == hr)
    {
	ReplaceExtension(&extEKU, &Cert.cExtension, Cert.rgExtension);
    }

    hr = myInfGetExtensions(hInf, &cExtInf, &rgExtInf);
    csiLogInfError(hInf, hr);
    _PrintIfError(hr, "myInfGetExtensions");
    if (0 != cExtInf)
    {
	hr = myMergeExtensions(
			Cert.cExtension,
			Cert.rgExtension,
			cExtInf,
			rgExtInf,
			&cExtMerged,
			&rgExtMerged);
	_JumpIfError(hr, error, "myMergeExtensions");

        Cert.cExtension = cExtMerged;
        Cert.rgExtension = rgExtMerged;
    }
    if (0 == Cert.cExtension)
    {
	Cert.dwVersion = CERT_V1;
    }

    hr = EncodeCertAndSign(
		    hProv,
		    &Cert,
		    Cert.SignatureAlgorithm.pszObjId,
		    ppbCert,
		    pcbCert,
		    hInstance,
		    fUnattended,
		    hwnd);
    _JumpIfError(hr, error, "EncodeCertAndSign");

error:
    if (NULL != extBasicConstraints.Value.pbData)
    {
	LocalFree(extBasicConstraints.Value.pbData);
    }
    if (NULL != extSKI.Value.pbData)
    {
	LocalFree(extSKI.Value.pbData);
    }
    if (NULL != extCDP.Value.pbData)
    {
	LocalFree(extCDP.Value.pbData);
    }
    if (NULL != extVersion.Value.pbData)
    {
	LocalFree(extVersion.Value.pbData);
    }
    if (NULL != extPreviousHash.Value.pbData)
    {
	LocalFree(extPreviousHash.Value.pbData);
    }
    if (NULL != extPolicy.Value.pbData)
    {
	LocalFree(extPolicy.Value.pbData);
    }
    if (NULL != extCross.Value.pbData)
    {
	LocalFree(extCross.Value.pbData);
    }
    if (NULL != extAIA.Value.pbData)
    {
	LocalFree(extAIA.Value.pbData);
    }
    if (NULL != extEKU.Value.pbData)
    {
	LocalFree(extEKU.Value.pbData);
    }
    if (NULL != rgExtMerged)
    {
        LocalFree(rgExtMerged);
    }
    myInfFreeExtensions(cExtInf, rgExtInf);
    if (NULL != paext)
    {
        LocalFree(paext);
    }
    if (NULL != pPubKey)
    {
        LocalFree(pPubKey);
    }
    CSILOG(hr, IDS_ILOG_CLONECERT, NULL, NULL, NULL);
    return(hr);
}


HRESULT
csiBuildRequest(
    OPTIONAL IN HINF hInf,
    OPTIONAL IN CERT_CONTEXT const *pccPrevious,
    IN BYTE const *pbSubjectEncoded,
    IN DWORD cbSubjectEncoded,
    IN char const *pszAlgId,
    IN BOOL fNewKey,
    IN DWORD iCert,
    IN DWORD iKey,
    IN HCRYPTPROV hProv,
    IN HWND hwnd,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    OUT BYTE **ppbEncode,
    OUT DWORD *pcbEncode)
{
    HRESULT hr;
    CERT_PUBLIC_KEY_INFO  *pInfo = NULL;
    DWORD                  cbInfo = 0;
    BYTE                  *pbEncode = NULL;
    DWORD                  cbEncode;
    CERT_REQUEST_INFO      CertRequestInfo;
    CRYPT_ALGORITHM_IDENTIFIER AlgId;
    HCERTTYPE              hCertType = NULL;
    CRYPT_ATTR_BLOB        ExtBlob;
    CRYPT_ATTR_BLOB        ExtBlobNT4;
    CRYPT_ATTR_BLOB        VersionBlob;
    CRYPT_ATTRIBUTE        aAttrib[3];
    CERT_EXTENSIONS       *pExtensions = NULL;
    CERT_EXTENSIONS Extensions;
    CERT_EXTENSIONS ExtensionsNT4;
    CERT_EXTENSION aext[8];
    CERT_EXTENSION aextNT4[4];
    CERT_EXTENSION *paext = NULL;
    char const *apszOIDNT4[] = {
	szOID_BASIC_CONSTRAINTS2,
	szOID_SUBJECT_KEY_IDENTIFIER,
	szOID_KEY_USAGE,
	szOID_ENHANCED_KEY_USAGE,
    };
    DWORD i;
    DWORD NameId = MAKECANAMEID(iCert, iKey);
    DWORD cExtCommon = 0;
    CERT_EXTENSION *pext;
    DWORD cAttribute = 0;
    CRYPT_ATTR_BLOB *paAttribute = NULL;
    WCHAR *pwszTemplateName;
    WCHAR *pwszTemplateNameInf = NULL;
    DWORD cExtInf = 0;
    CERT_EXTENSION *rgExtInf = NULL;
    DWORD cExtMerged;
    CERT_EXTENSION *rgExtMerged = NULL;
    BOOL fVersionAttr = TRUE;

    ExtBlob.pbData = NULL;
    ExtBlobNT4.pbData = NULL;
    VersionBlob.pbData = NULL;

    if (!CryptExportPublicKeyInfo(
                hProv,
                AT_SIGNATURE,
                X509_ASN_ENCODING,
                NULL,
                &cbInfo))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptExportPublicKeyInfo");
    }

    pInfo = (CERT_PUBLIC_KEY_INFO *) LocalAlloc(LMEM_FIXED, cbInfo);
    if (NULL == pInfo)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if (!CryptExportPublicKeyInfo(
                    hProv,
                    AT_SIGNATURE,
                    X509_ASN_ENCODING,
                    pInfo,
                    &cbInfo))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptExportPublicKeyInfo");
    }

    CertRequestInfo.dwVersion = CERT_REQUEST_V1;
    CertRequestInfo.Subject.pbData = const_cast<BYTE *>(pbSubjectEncoded);
    CertRequestInfo.Subject.cbData = cbSubjectEncoded;
    CertRequestInfo.SubjectPublicKeyInfo = *pInfo;

    // Build the CA Version extension

    if (!myEncodeObject(
		X509_ASN_ENCODING,
		X509_INTEGER,
		&NameId,
		0,
		CERTLIB_USE_LOCALALLOC,
		&aext[cExtCommon].Value.pbData,
		&aext[cExtCommon].Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    aext[cExtCommon].pszObjId = szOID_CERTSRV_CA_VERSION;
    aext[cExtCommon].fCritical = FALSE;
    cExtCommon++;

    // Build the previous CA cert hash extension

    if (0 != iCert && NULL != pccPrevious)
    {
	hr = GetCertHashExtension(
			    pccPrevious,
			    &aext[cExtCommon].Value.pbData,
			    &aext[cExtCommon].Value.cbData);
	_JumpIfError(hr, error, "GetCertHashExtension");

	aext[cExtCommon].pszObjId = szOID_CERTSRV_PREVIOUS_CERT_HASH;
	aext[cExtCommon].fCritical = FALSE;
	cExtCommon++;
    }

    // Subject Key Identifier extension:
    // If we're reusing the old key, reuse the old SKI -- even if it's "wrong".

    pext = NULL;
    if (0 != iCert && NULL != pccPrevious && !fNewKey)
    {
	pext = CertFindExtension(
			szOID_SUBJECT_KEY_IDENTIFIER,
			pccPrevious->pCertInfo->cExtension,
			pccPrevious->pCertInfo->rgExtension);
    }
    if (NULL != pext)
    {
	aext[cExtCommon].Value.cbData = pext->Value.cbData;
	aext[cExtCommon].Value.pbData = (BYTE *) LocalAlloc(
						LMEM_FIXED,
						pext->Value.cbData);
	if (NULL == aext[cExtCommon].Value.pbData)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(
		aext[cExtCommon].Value.pbData,
		pext->Value.pbData,
		pext->Value.cbData);
    }
    else
    {
	hr = myCreateSubjectKeyIdentifierExtension(
					&CertRequestInfo.SubjectPublicKeyInfo,
					&aext[cExtCommon].Value.pbData,
					&aext[cExtCommon].Value.cbData);
	_JumpIfError(hr, error, "myCreateSubjectKeyIdentifierExtension");
    }

    aext[cExtCommon].pszObjId = szOID_SUBJECT_KEY_IDENTIFIER;
    aext[cExtCommon].fCritical = FALSE;
    cExtCommon++;

    hr = myInfGetPolicyStatementExtension(hInf, &aext[cExtCommon]);
    csiLogInfError(hInf, hr);
    _PrintIfError(hr, "myInfGetPolicyStatementExtension");
    if (S_OK == hr)
    {
	aext[cExtCommon].pszObjId = szOID_CERT_POLICIES;
	cExtCommon++;
    }

    hr = myInfGetCrossCertDistributionPointsExtension(hInf, &aext[cExtCommon]);
    csiLogInfError(hInf, hr);
    _PrintIfError(hr, "myInfGetCrossCertDistributionPointsExtension");
    if (S_OK == hr)
    {
	aext[cExtCommon].pszObjId = szOID_CROSS_CERT_DIST_POINTS;
	cExtCommon++;
    }

    hr = myInfGetRequestAttributes(
			hInf,
			&cAttribute,
			&paAttribute,
			&pwszTemplateNameInf);
    csiLogInfError(hInf, hr);
    _PrintIfError(hr, "myInfGetRequestAttributes");

    hr = myInfGetExtensions(hInf, &cExtInf, &rgExtInf);
    csiLogInfError(hInf, hr);
    _PrintIfError(hr, "myInfGetExtensions");

    pwszTemplateName = pwszTemplateNameInf;
    if (NULL == pwszTemplateName)
    {
	pwszTemplateName = wszCERTTYPE_SUBORDINATE_CA;
    }

    // Build the attribute containing the appropriate cert type info

    hr = CAFindCertTypeByName(
                pwszTemplateName,
                NULL,
                CT_FIND_LOCAL_SYSTEM |
		    CT_ENUM_MACHINE_TYPES |
		    CT_ENUM_USER_TYPES,
                &hCertType);
    if (S_OK == hr)
    {
        hr = CAGetCertTypeExtensions(hCertType, &pExtensions);
        _JumpIfError(hr, error, "CAGetCertTypeExtensions");

	paext = (CERT_EXTENSION *) LocalAlloc(
		    LMEM_FIXED,
		    (pExtensions->cExtension + cExtCommon) * sizeof(paext[0]));
	if (NULL == paext)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(&paext[0], &aext[0], cExtCommon * sizeof(paext[0]));
	CopyMemory(
		&paext[cExtCommon],
		pExtensions->rgExtension,
		pExtensions->cExtension * sizeof(paext[0]));

        Extensions.cExtension = cExtCommon + pExtensions->cExtension;
        Extensions.rgExtension = paext;
    }
    else
    {
        DBGERRORPRINTLINE("CAFindCertTypeByName", hr);

        // standard extensions are not available from CAGetCertTypeExtensions;
        // construct them manually.

	// Build the Cert Template extension

	hr = myBuildCertTypeExtension(pwszTemplateName, &aext[cExtCommon]);
	_JumpIfError(hr, error, "myBuildCertTypeExtension");

	cExtCommon++;

        if (!CreateKeyUsageExtension(
		myCASIGN_KEY_USAGE,
                &aext[cExtCommon].Value.pbData,
                &aext[cExtCommon].Value.cbData,
                hInstance,
                fUnattended,
                hwnd))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CreateKeyUsageExtension");
        }
	aext[cExtCommon].pszObjId = szOID_KEY_USAGE;
	aext[cExtCommon].fCritical = FALSE;
	cExtCommon++;

        hr = myInfGetBasicConstraints2CAExtensionOrDefault(
					hInf,
					&aext[cExtCommon]);
	csiLogInfError(hInf, hr);
	_JumpIfError(hr, error, "myInfGetBasicConstraints2CAExtensionOrDefault");
	cExtCommon++;

	CSASSERT(ARRAYSIZE(aext) >= cExtCommon);

        Extensions.cExtension = cExtCommon;
        Extensions.rgExtension = aext;
    }
    if (0 != cExtInf)
    {
	pext = CertFindExtension(
			    szOID_OS_VERSION,
			    cExtInf,
			    rgExtInf);
	if (NULL != pext && NULL == pext->Value.pbData)
	{
	    fVersionAttr = FALSE;
	}
	hr = myMergeExtensions(
			Extensions.cExtension,
			Extensions.rgExtension,
			cExtInf,
			rgExtInf,
			&cExtMerged,
			&rgExtMerged);
	_JumpIfError(hr, error, "myMergeExtensions");

        Extensions.cExtension = cExtMerged;
        Extensions.rgExtension = rgExtMerged;
    }

    if (0 != Extensions.cExtension)
    {
	if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_EXTENSIONS,
		    &Extensions,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &ExtBlob.pbData,
		    &ExtBlob.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
    }

    // To allow an NT4 SP6a cert server to recognize this request as
    // a subordinate CA request, put the basic constraints extension into
    // a request attribute tagged with the old OID (szOID_CERT_EXTENSIONS).
    // Do the same for subject key id (NT4 computed SKI incorrectly),
    // key usage and enhanced key usage.

    ExtensionsNT4.cExtension = 0;

    CSASSERT(CSExpr(ARRAYSIZE(apszOIDNT4) == ARRAYSIZE(aextNT4)));

    for (i = 0; i < ARRAYSIZE(apszOIDNT4); i++)
    {
	pext = CertFindExtension(
			    apszOIDNT4[i],
			    Extensions.cExtension,
			    Extensions.rgExtension);
	if (NULL != pext)
	{
	    aextNT4[ExtensionsNT4.cExtension] = *pext;
	    ExtensionsNT4.cExtension++;
	}
    }

    if (0 != ExtensionsNT4.cExtension)
    {
	ExtensionsNT4.rgExtension = aextNT4;

	if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_EXTENSIONS,
		    &ExtensionsNT4,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &ExtBlobNT4.pbData,
		    &ExtBlobNT4.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
    }

    // get the OS Version

    hr = myBuildOSVersionAttribute(&VersionBlob.pbData, &VersionBlob.cbData);
    _JumpIfError(hr, error, "myBuildOSVersionAttribute");

    CertRequestInfo.cAttribute = 0;
    CertRequestInfo.rgAttribute = aAttrib;

    if (NULL != ExtBlob.pbData)
    {
	aAttrib[CertRequestInfo.cAttribute].pszObjId = szOID_RSA_certExtensions;
	aAttrib[CertRequestInfo.cAttribute].cValue = 1;
	aAttrib[CertRequestInfo.cAttribute].rgValue = &ExtBlob;
	CertRequestInfo.cAttribute++;
    }
    if (fVersionAttr)
    {
	aAttrib[CertRequestInfo.cAttribute].pszObjId = szOID_OS_VERSION;
	aAttrib[CertRequestInfo.cAttribute].cValue = 1;
	aAttrib[CertRequestInfo.cAttribute].rgValue = &VersionBlob;
	CertRequestInfo.cAttribute++;
    }
    if (NULL != ExtBlobNT4.pbData)
    {
	aAttrib[CertRequestInfo.cAttribute].pszObjId = szOID_CERT_EXTENSIONS;
	aAttrib[CertRequestInfo.cAttribute].cValue = 1;
	aAttrib[CertRequestInfo.cAttribute].rgValue = &ExtBlobNT4;
	CertRequestInfo.cAttribute++;
    }

    CSASSERT(CertRequestInfo.cAttribute <= ARRAYSIZE(aAttrib));

    AlgId.pszObjId = const_cast<char *>(pszAlgId);
    AlgId.Parameters.cbData = 0;
    AlgId.Parameters.pbData = NULL;

    if (!CryptSignAndEncodeCertificate(
                    hProv,
                    AT_SIGNATURE,
                    X509_ASN_ENCODING,
                    X509_CERT_REQUEST_TO_BE_SIGNED,
                    &CertRequestInfo,
                    &AlgId,
                    NULL,
                    NULL,
                    &cbEncode))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptSignAndEncodeCertificate");
    }

    pbEncode = (BYTE *) LocalAlloc(LMEM_FIXED, cbEncode);
    if (NULL == pbEncode)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if (!CryptSignAndEncodeCertificate(
                hProv,
                AT_SIGNATURE,
                X509_ASN_ENCODING,
                X509_CERT_REQUEST_TO_BE_SIGNED,
                &CertRequestInfo,
                &AlgId,
                NULL,
                pbEncode,
                &cbEncode))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptSignAndEncodeCertificate");
    }

    // return value
    *ppbEncode = pbEncode;
    *pcbEncode = cbEncode;
    hr = S_OK;

error:
    if (NULL != pwszTemplateNameInf)
    {
        LocalFree(pwszTemplateNameInf);
    }
    if (NULL != paAttribute)
    {
	myInfFreeRequestAttributes(cAttribute, paAttribute);
    }
    for (i = 0; i < cExtCommon; i++)
    {
        if (NULL != aext[i].Value.pbData)
        {
            LocalFree(aext[i].Value.pbData);
        }
    }
    if (NULL != paext)
    {
        LocalFree(paext);
    }
    if (NULL != rgExtMerged)
    {
        LocalFree(rgExtMerged);
    }
    myInfFreeExtensions(cExtInf, rgExtInf);
    if (NULL != ExtBlob.pbData)
    {
        LocalFree(ExtBlob.pbData);
    }
    if (NULL != ExtBlobNT4.pbData)
    {
        LocalFree(ExtBlobNT4.pbData);
    }
    if (NULL != VersionBlob.pbData)
    {
        LocalFree(VersionBlob.pbData);
    }
    if (NULL != pInfo)
    {
        LocalFree(pInfo);
    }
    if (NULL != hCertType)
    {
        if (NULL != pExtensions && &Extensions != pExtensions)
        {
            CAFreeCertTypeExtensions(hCertType, pExtensions);
        }
        CACloseCertType(hCertType);
    }
    CSILOG(hr, IDS_ILOG_BUILDREQUEST, NULL, NULL, &NameId);
    return(hr);
}


//+-------------------------------------------------------------------------
// CertServerRequestCACertificateAndComplete -- implements the following:
//	MMC snapin's RenewCert and InstallCert verbs
//	certutil -InstallCert & -RenewCert
//+-------------------------------------------------------------------------

HRESULT
CertServerRequestCACertificateAndComplete(
    IN HINSTANCE             hInstance,
    IN HWND                  hwnd,
    IN DWORD                 Flags,
    IN WCHAR const          *pwszCAName,
    OPTIONAL IN WCHAR const *pwszParentMachine,
    OPTIONAL IN WCHAR const *pwszParentCA,
    OPTIONAL IN WCHAR const *pwszCAChainFile,
    OPTIONAL OUT WCHAR     **ppwszRequestFile)
{
    HRESULT hr;
    DWORD dwSetupStatus;
    WCHAR const *pwszFinalParentMachine = pwszParentMachine;
    WCHAR const *pwszFinalParentCA = pwszParentCA;
    WCHAR *pwszRequestFile = NULL;
    WCHAR *pwszCertFile = NULL;
    BYTE *pbRequest = NULL;
    DWORD cbRequest;
    BSTR strChain = NULL;
    BYTE *pbChain = NULL;
    DWORD cbChain;
    WCHAR *pwszKeyContainer = NULL;
    WCHAR *pwszServerName = NULL;
    CERTHIERINFO CertHierInfo;
    ENUM_CATYPES CAType;
    BOOL fUseDS;
    DWORD dwRevocationFlags;
    DWORD iCertNew;
    DWORD iKey;
    CERT_CONTEXT const *pccCertOld = NULL;
    HCRYPTPROV hProv = NULL;
    CRYPT_KEY_PROV_INFO KeyProvInfo;
    ALG_ID idAlg;
    BOOL fMachineKeyset;
    BOOL fKeyGenFailed;
    CHAR *pszAlgId = NULL;
    BOOL fUnattended = (CSRF_UNATTENDED & Flags)? TRUE : FALSE;
    BOOL fRenew = (CSRF_RENEWCACERT & Flags)? TRUE : FALSE;
    BOOL fNewKey = (CSRF_NEWKEYS & Flags)? TRUE : FALSE;
    UINT idMsg;
    WCHAR *pwszProvName = NULL;
    DWORD dwProvType;
    HINF hInf = INVALID_HANDLE_VALUE;
    DWORD ErrorLine;
    WCHAR *pwszzUnreferencedInfSections = NULL;
    BOOL fEnableKeyCounting = FALSE;
    
    idMsg = IDS_ILOG_INSTALLCERT;
    if (fRenew)
    {
        idMsg = fNewKey? IDS_ILOG_RENEWNEWKEY : IDS_ILOG_RENEWOLDKEY;
    }
    
    ZeroMemory(&CertHierInfo, sizeof(CertHierInfo));
    ZeroMemory(&KeyProvInfo, sizeof(KeyProvInfo));
    
    if (NULL != ppwszRequestFile)
    {
        *ppwszRequestFile = NULL;
    }
    
    if (NULL == pwszCAName)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL CA Name");
    }
    
    hr = mySanitizeName(pwszCAName, &CertHierInfo.pwszSanitizedCAName);
    _JumpIfError(hr, error, "mySanitizeName");
    
    hr = GetSetupStatus(CertHierInfo.pwszSanitizedCAName, &dwSetupStatus);
    _JumpIfError(hr, error, "GetSetupStatus");
    
    hr = myGetCertRegDWValue(
        CertHierInfo.pwszSanitizedCAName,
        NULL,
        NULL,
        wszREGCATYPE,
        (DWORD *) &CAType);
    _JumpIfErrorStr(hr, error, "myGetCertRegDWValue", wszREGCATYPE);
    
    // use DS or not
    hr = myGetCertRegDWValue(
        CertHierInfo.pwszSanitizedCAName,
        NULL,
        NULL,
        wszREGCAUSEDS,
        (DWORD *) &fUseDS);
    _JumpIfErrorStr(hr, error, "myGetCertRegDWValue", wszREGCAUSEDS);
    
    hr = myGetCertRegStrValue(
        CertHierInfo.pwszSanitizedCAName,
        NULL,
        NULL,
        wszREGCASERVERNAME,
        &pwszServerName);
    _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", wszREGCASERVERNAME);
    
    hr = myGetCertRegDWValue(
        CertHierInfo.pwszSanitizedCAName,
        wszREGKEYPOLICYMODULES,
        wszCLASS_CERTPOLICY,
        wszREGREVOCATIONTYPE,
        &dwRevocationFlags);
    if (S_OK != hr)
    {
        dwRevocationFlags = fUseDS? REVEXT_DEFAULT_DS : REVEXT_DEFAULT_NODS;
    }
    
    // Current Hash count is the same as the next iCert
    
    hr = myGetCARegHashCount(
			CertHierInfo.pwszSanitizedCAName,
			CSRH_CASIGCERT,
			&iCertNew);
    _JumpIfError(hr, error, "myGetCARegHashCount");
    
    cbChain = 0;
    cbRequest = 0;
    if (fRenew)
    {
        // We're renewing the CA cert, so the initial setup should be complete.
        
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
        if (0 == iCertNew || (SETUP_SUSPEND_FLAG & dwSetupStatus))
        {
            _JumpError(hr, error, "not fully installed");
        }
        if (SETUP_REQUEST_FLAG & dwSetupStatus)
        {
            if (0 == (CSRF_OVERWRITE & Flags))
            {
                _JumpError(hr, error, "Renewal already in progress");
            }
            _PrintError(hr, "Ignoring renewal already in progress");
        }

        hr = myGetCertSrvCSP(
		    FALSE,		// fEncryptionCSP
		    CertHierInfo.pwszSanitizedCAName,
		    &dwProvType,
		    &pwszProvName,
		    &idAlg,
		    &fMachineKeyset,
		    NULL);		// pdwKeySize
        _JumpIfError(hr, error, "myGetCertSrvCSP");

        hr = LoadCurrentCACertAndKeyInfo(
	    CertHierInfo.pwszSanitizedCAName,
            fNewKey,
            fUnattended,
            fMachineKeyset,
            iCertNew,
            &iKey,
            &pwszKeyContainer,
            &pccCertOld);
        _JumpIfError(hr, error, "LoadCurrentCACertAndKeyInfo");
        
        CSASSERT(MAXDWORD != iKey);
        
        hr = csiFillKeyProvInfo(
		    pwszKeyContainer,
		    pwszProvName,
		    dwProvType,
		    fMachineKeyset,
		    &KeyProvInfo);
        _JumpIfError(hr, error, "csiFillKeyProvInfo");

	hr = myInfOpenFile(NULL, &hInf, &ErrorLine);
	_PrintIfError2(
		hr,
		"myInfOpenFile",
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

        if (fNewKey)
        {
            CWaitCursor cwait;
            DWORD cbitKey;
            
            hr = myInfGetKeyLength(hInf, &cbitKey);
            if (S_OK != hr)
            {
                cbitKey = CertGetPublicKeyLength(
                    X509_ASN_ENCODING,
                    &pccCertOld->pCertInfo->SubjectPublicKeyInfo);
                if (0 == cbitKey || 512 == cbitKey)
                {
                    if (0 == cbitKey)
                    {
                        hr = myHLastError();
                        _PrintError(hr, "CertGetPublicKeyLength");
                    }
                    cbitKey = 1024;
                }
            }

            hr = myInfGetEnableKeyCounting(hInf, &fEnableKeyCounting);
            if (S_OK != hr)
            {
                fEnableKeyCounting = FALSE;
	    }

            hr = csiGenerateCAKeys(
                KeyProvInfo.pwszContainerName,
                KeyProvInfo.pwszProvName,
                KeyProvInfo.dwProvType,
                fMachineKeyset,
                cbitKey,	// dwKeyLength,
                hInstance,
                fUnattended,
                fEnableKeyCounting,
                hwnd,
                &fKeyGenFailed);
            _JumpIfError(hr, error, "csiGenerateCAKeys");
        }
        
        // get CSP handle
        
        if (!myCertSrvCryptAcquireContext(
            &hProv,
            KeyProvInfo.pwszContainerName,
            KeyProvInfo.pwszProvName,
            KeyProvInfo.dwProvType,
            fUnattended? CRYPT_SILENT : 0,
            fMachineKeyset))
        {
            hr = myHLastError();
            _JumpError(hr, error, "myCertSrvCryptAcquireContext");
        }
        if (hProv == NULL)
        {
            hr = E_HANDLE;
            _JumpError(hr, error, "myCertSrvCryptAcquireContext");
        }
        
        if (IsRootCA(CAType))
        {
            hr = CloneRootCert(
                hInf,
		pccCertOld,
                hProv,
                CertHierInfo.pwszSanitizedCAName,
                iCertNew,
                iKey,
                fUseDS,
                fNewKey,
                dwRevocationFlags,
                hInstance,
                fUnattended,
                hwnd,
                &pbChain,
                &cbChain);
            _JumpIfError(hr, error, "CloneRootCert");
        }
        else
        {
            // get request file name
            hr = csiGetCARequestFileName(
                hInstance,
                hwnd,
                CertHierInfo.pwszSanitizedCAName,
                iCertNew,
                iKey,
                &pwszRequestFile);
            _JumpIfError(hr, error, "csiGetCARequestFileName");
            
            
            hr = myGetSigningOID(
			    NULL,	// hProv
			    KeyProvInfo.pwszProvName,
			    KeyProvInfo.dwProvType,
			    idAlg,
			    &pszAlgId);
            _JumpIfError(hr, error, "myGetSigningOID");
            
            hr = csiBuildRequest(
			    hInf,
			    pccCertOld,
			    pccCertOld->pCertInfo->Subject.pbData,
			    pccCertOld->pCertInfo->Subject.cbData,
			    pszAlgId,
			    fNewKey,
			    iCertNew,
			    iKey,
			    hProv,
			    hwnd,
			    hInstance,
			    fUnattended,
			    &pbRequest,
			    &cbRequest);
            _JumpIfError(hr, error, "csiBuildRequest");
            
            hr = EncodeToFileW(
                pwszRequestFile,
                pbRequest,
                cbRequest,
                DECF_FORCEOVERWRITE | CRYPT_STRING_BASE64REQUESTHEADER);
            _JumpIfErrorStr(hr, error, "EncodeToFileW", pwszRequestFile);
            
            hr = mySetCertRegKeyIndexAndContainer(
                CertHierInfo.pwszSanitizedCAName,
                iKey,
                pwszKeyContainer);
            _JumpIfError(hr, error, "mySetCertRegKeyIndexAndContainer");
            
            hr = SetSetupStatus(
                CertHierInfo.pwszSanitizedCAName,
                SETUP_REQUEST_FLAG,
                TRUE);
            _JumpIfError(hr, error, "SetSetupStatus");
            
            if (NULL != ppwszRequestFile)
            {
                *ppwszRequestFile = pwszRequestFile;
                pwszRequestFile = NULL;
                CSASSERT(S_OK == hr);
            }
        }
	if (INVALID_HANDLE_VALUE != hInf)
	{
	    hr = myInfGetUnreferencedSectionNames(
			&pwszzUnreferencedInfSections);
	    _PrintIfError(hr, "myInfGetUnreferencedSectionNames");

	    if (NULL != pwszzUnreferencedInfSections)
	    {
		WCHAR *pwsz;

		pwsz = pwszzUnreferencedInfSections;
		while (L'\0' != *pwsz)
		{
		    pwsz += wcslen(pwsz);
		    *pwsz++ = L',';
		}
		if (pwsz > pwszzUnreferencedInfSections && *--pwsz == L',')
		{
		    *pwsz = L'\0';
		}
		CSILOG(
		    S_OK,
		    IDS_ILOG_UNREFERENCEDINFSECTIONS,
		    pwszzUnreferencedInfSections,
		    NULL,
		    NULL);
	    }
	    static WCHAR const * const s_apwszKeys[] =
	    {
		wszINFKEY_UTF8,
		wszINFKEY_RENEWALKEYLENGTH,
		wszINFKEY_RENEWALVALIDITYPERIODSTRING,
		wszINFKEY_RENEWALVALIDITYPERIODCOUNT,
		NULL
	    };

	    hr = myInfGetKeyList(
		    hInf,
		    wszINFSECTION_CERTSERVER,
		    NULL,		// pwszKey
		    s_apwszKeys,
		    NULL,		// pfCritical
		    NULL);		// ppwszzTemplateList
	    csiLogInfError(hInf, hr);
	    _PrintIfErrorStr(hr, "myInfGetKeyList", wszINFSECTION_CERTSERVER);
	}
    }
    else
    {
        // We're not renewing the CA cert, so this had better be an incomplete
        // renewal or initial setup; we're waiting for the new cert or chain.
        
        if (IsRootCA(CAType) || 0 == (SETUP_REQUEST_FLAG & dwSetupStatus))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
            _JumpIfError(hr, error, "no outstanding request");
        }
        
        hr = myGetCertRegKeyIndexAndContainer(
            CertHierInfo.pwszSanitizedCAName,
            &iKey,
            &pwszKeyContainer);
        _JumpIfError(hr, error, "myGetCertRegKeyIndexAndContainer");
        
        if (NULL == pwszCAChainFile)
        {
            // pop up open dlg
            hr = myGetOpenFileName(
                hwnd,
                hInstance,
                IDS_CAHIER_INSTALL_TITLE,
                IDS_CAHIER_CERTFILE_FILTER,
                0,		// no def ext
                OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY,
                NULL,	// no default file
                &pwszCertFile);
            if (S_OK == hr && NULL != pwszCertFile)
            {
                pwszCAChainFile = pwszCertFile;
            }
        }
        if (NULL != pwszCAChainFile)
        {
            hr = DecodeFileW(pwszCAChainFile, &pbChain, &cbChain, CRYPT_STRING_ANY);
            _JumpIfErrorStr(hr, error, "DecodeFileW", pwszCAChainFile);
        }
    }
    
    if (!IsRootCA(CAType) && NULL == pbChain)
    {
        // if we haven't created the request, grab it from a file for resubmission
        if (pbRequest == NULL)
        {
            hr = myGetCARegFileNameTemplate(
				    wszREGREQUESTFILENAME,
				    pwszServerName,
				    CertHierInfo.pwszSanitizedCAName,
				    iCertNew,
				    iKey,
				    &pwszRequestFile);
            _JumpIfError(hr, error, "myGetCARegFileNameTemplate");
            
            hr = DecodeFileW(pwszRequestFile, &pbRequest, &cbRequest, CRYPT_STRING_ANY);
            _JumpIfErrorStr(hr, error, "DecodeFileW", pwszRequestFile);
        }
        
        if (NULL == pwszParentMachine || NULL == pwszParentCA)
        {
            CertHierInfo.hInstance = hInstance;
            CertHierInfo.fUnattended = fUnattended;
            CertHierInfo.iCertNew = iCertNew;
            CertHierInfo.iKey = iKey;
            
            // get parent ca info
            hr = myGetCertRegStrValue(
				CertHierInfo.pwszSanitizedCAName,
				NULL,
				NULL,
				wszREGPARENTCAMACHINE,
				&CertHierInfo.pwszParentMachineDefault);
            _PrintIfErrorStr(hr, "myGetCertRegStrValue", wszREGPARENTCAMACHINE);
            
            hr = myGetCertRegStrValue(
				CertHierInfo.pwszSanitizedCAName,
				NULL,
				NULL,
				wszREGPARENTCANAME,
				&CertHierInfo.pwszParentCADefault);
            _PrintIfErrorStr(hr, "myGetCertRegStrValue", wszREGPARENTCANAME);
            
            // invoke parent ca dialog to select
            if (IDOK != (int) DialogBoxParam(
				    hInstance,
				    MAKEINTRESOURCE(IDD_COMPLETE_DIALOG),
				    hwnd,
				    CertHierProc,
				    (LPARAM) &CertHierInfo))
            {
                // cancel
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                _JumpError(hr, error, "cancel");
            }
            pwszFinalParentMachine = CertHierInfo.pwszParentMachine;
            pwszFinalParentCA = CertHierInfo.pwszParentCA;
        }
        
        BOOL fRetrievePending =
		!fRenew &&
		(SETUP_REQUEST_FLAG & dwSetupStatus) &&
		(SETUP_ONLINE_FLAG & dwSetupStatus) &&
		NULL != CertHierInfo.pwszParentMachineDefault &&
		NULL != CertHierInfo.pwszParentCADefault &&
		0 == mylstrcmpiL(
			pwszFinalParentMachine,
			CertHierInfo.pwszParentMachineDefault) &&
		0 == mylstrcmpiL(
			pwszFinalParentCA,
			CertHierInfo.pwszParentCADefault);
        
        // submit to parent ca
        hr = csiSubmitCARequest(
            hInstance,
            fUnattended,
            hwnd,
	    fRenew,
	    iCertNew,
            fRetrievePending,
            CertHierInfo.pwszSanitizedCAName,
            pwszFinalParentMachine,
            pwszFinalParentCA,
            pbRequest,
            cbRequest,
            &strChain);
        _JumpIfError(hr, error, "csiSubmitCARequest");
        
        cbChain = SysStringByteLen(strChain);
    }
    
    hr = FinishSuspendedSetupFromPKCS7(
        hInstance,
        fUnattended,
        hwnd,
        CertHierInfo.pwszSanitizedCAName,
        pwszKeyContainer,
        iKey,
	fRenew || 0 != iCertNew,
        NULL != pbChain? pbChain : (BYTE *) strChain,
        cbChain);
    _JumpIfError(hr, error, "FinishSuspendedSetupFromPKCS7");
    
    MarkSetupComplete(CertHierInfo.pwszSanitizedCAName);
    CSASSERT(S_OK == hr);
    
error:
    CSILOG(
	hr,
	idMsg,
	pwszCAName,
	NULL != pwszRequestFile? pwszRequestFile :
	    (NULL != ppwszRequestFile && NULL != *ppwszRequestFile)?
	    *ppwszRequestFile : pwszCertFile,
	NULL);
    if (INVALID_HANDLE_VALUE != hInf)
    {
	myInfCloseFile(hInf);
    }
    FreeCertHierInfo(&CertHierInfo);
    csiFreeKeyProvInfo(&KeyProvInfo);
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    if (NULL != pwszzUnreferencedInfSections)
    {
        LocalFree(pwszzUnreferencedInfSections);
    }
    if (NULL != pszAlgId)
    {
        LocalFree(pszAlgId);
    }
    if (NULL != pwszKeyContainer)
    {
        LocalFree(pwszKeyContainer);
    }
    if (NULL != pccCertOld)
    {
        CertFreeCertificateContext(pccCertOld);
    }
    if (NULL != pwszRequestFile)
    {
        LocalFree(pwszRequestFile);
    }
    if (NULL != pwszCertFile)
    {
        LocalFree(pwszCertFile);
    }
    if (NULL != pwszServerName)
    {
        LocalFree(pwszServerName);
    }
    if (NULL != pbRequest)
    {
        LocalFree(pbRequest);
    }
    if (NULL != pbChain)
    {
        LocalFree(pbChain);
    }
    if (NULL != pwszProvName)
    {
        LocalFree(pwszProvName);
    }
    if (NULL != strChain)
    {
        SysFreeString(strChain);
    }
    myInfClearError();
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\initlib\certhier.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certhier.h
//
//--------------------------------------------------------------------------

HRESULT
CreateRevocationExtension(
    IN HINF hInf,
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN DWORD iCRL,
    IN BOOL fUseDS,
    IN DWORD dwRevocationFlags,
    OUT BOOL *pfCritical,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

HRESULT
CreateAuthorityInformationAccessExtension(
    IN HINF hInf,
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN DWORD iCRL,
    IN BOOL fUseDS,
    OUT BOOL *pfCritical,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

HRESULT
EncodeCertAndSign(
    IN HCRYPTPROV hProv,
    IN CERT_INFO *pCert,
    IN char const *pszAlgId,
    OUT BYTE **ppbSigned,
    OUT DWORD *pcbSigned,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd);

BOOL
CreateKeyUsageExtension(
    IN BYTE bIntendedKeyUsage,
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\initlib\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------


#define __DIR__		"initlib"
#define VC_EXTRALEAN		// Exclude rarely-used stuff in Windows headers

#include <windows.h>

#include <setupapi.h>
#include "ocmanage.h"

#include <certsrv.h>
#include "certlib.h"
#include "initcert.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\browsedi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       browsedi.cpp
//
//--------------------------------------------------------------------------

//
// BrowseDir.cpp
//


#include "pch.cpp"
#pragma hdrstop

#include <shlobj.h>

#define __dwFILE__	__dwFILE_OCMSETUP_BROWSEDI_CPP__


int 
InitStartDir( 
    HWND hwnd, 
    UINT uMsg, 
    LPARAM, // lParam,
    LPARAM lpData)
{
    // we just capture Init Message
    if (BFFM_INITIALIZED == uMsg)
    {
        // we expect lpData to be our start path
        SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM)TRUE, lpData);
    }

    return 0;
}
 



BOOL BrowseForDirectory(
                HWND hwndParent,
                LPCTSTR pszInitialDir,
                LPTSTR pszBuf,
                int cchBuf,
                LPCTSTR pszDialogTitle)
{
    LPITEMIDLIST pItem = NULL;
    TCHAR szPath[MAX_PATH+1];
    BOOL bGotLocation = FALSE;

    BROWSEINFO bi;
    ZeroMemory(&bi, sizeof(bi));
    bi.hwndOwner = hwndParent;

    // initial folder
    if (pszInitialDir != NULL)
    {
        bi.lpfn = InitStartDir;
        bi.lParam = (LPARAM)pszInitialDir;
    }

    bi.pszDisplayName = szPath;   
    bi.lpszTitle = pszDialogTitle;
    bi.ulFlags = BIF_USENEWUI  |
                 BIF_SHAREABLE |
                 BIF_RETURNONLYFSDIRS;            // return only directories in the filesystem, not other folders


    pItem = SHBrowseForFolder(&bi);
    if (pItem == NULL)
        goto Ret;

    bGotLocation = SHGetPathFromIDList(pItem, szPath);
    if (!bGotLocation)
        goto Ret;
    
    CSASSERT((_tcslen(szPath)+1)*sizeof(TCHAR) <= (ULONG)cchBuf);
    if ((_tcslen(szPath)+1)*sizeof(TCHAR) > (ULONG)cchBuf)
        return FALSE;

    _tcscpy(pszBuf, szPath);
   
Ret:
    LPMALLOC pMalloc;
    if (SUCCEEDED(SHGetMalloc(&pMalloc))) 
    {
       if (pItem)
           pMalloc->Free(pItem);
       if (bi.pidlRoot)
           pMalloc->Free((ITEMIDLIST*)bi.pidlRoot);

       pMalloc->Release();
    }

    return bGotLocation;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\initlib\keyenum.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       keyenum.cpp
//
//--------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  File:       keyenum.cpp
// 
//  Contents:   key container and cert store operations
//
//  History:    08/97   xtan
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "cscsp.h"
#include "csdisp.h"

#define __dwFILE__	__dwFILE_INITLIB_KEYENUM_CPP__


// Key Enumeration
// move point to top
KEY_LIST* 
topKeyList(KEY_LIST *pKeyList)
{
    while (pKeyList->last)
    {
        pKeyList = pKeyList->last;
    }
    return pKeyList;
}


// move point to end
KEY_LIST* 
endKeyList(KEY_LIST *pKeyList)
{
    while (pKeyList->next)
    {
        pKeyList = pKeyList->next;
    }
    return pKeyList;
}


// add to end
void 
addKeyList(KEY_LIST **ppKeyList, KEY_LIST *pKey)
{
    KEY_LIST *pKeyList = *ppKeyList;

    if (NULL == pKeyList)
    {
	*ppKeyList = pKey;
    }
    else
    {
	// go to end
	pKeyList = endKeyList(pKeyList);
	// add
	pKeyList->next = pKey;
	pKey->last = pKeyList;
    }
}


KEY_LIST *
newKey(
    CHAR    *pszName)
{
    HRESULT hr = S_OK;
    KEY_LIST *pKey = NULL;

    if (NULL != pszName)
    {
        pKey = (KEY_LIST *) LocalAlloc(LMEM_FIXED, sizeof(*pKey));
        if (NULL == pKey)
        {
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
        }
	if (!myConvertSzToWsz(&pKey->pwszName, pszName, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "myConvertSzToWsz");
	}
	pKey->last = NULL;
	pKey->next = NULL;
    }

error:
    if (S_OK != hr)
    {
	if (NULL != pKey)
	{
	    LocalFree(pKey);
	    pKey = NULL;
	}
	SetLastError(hr);
    }
    return(pKey);
}


void 
freeKey(KEY_LIST *pKey)
{
    if (pKey)
    {
        if (pKey->pwszName)
        {
            LocalFree(pKey->pwszName);
        }
        LocalFree(pKey);
    }
}


VOID
csiFreeKeyList(
    IN OUT KEY_LIST *pKeyList)
{
    KEY_LIST *pNext;

    if (pKeyList)
    {
        // go top
        pKeyList = topKeyList(pKeyList);
        do
        {
            pNext = pKeyList->next;
            freeKey(pKeyList);
            pKeyList = pNext;
        } while (pKeyList);
    }
}

HRESULT
csiGetKeyList(
    IN DWORD        dwProvType,
    IN WCHAR const *pwszProvName,
    IN BOOL         fMachineKeySet,
    IN BOOL         fSilent,
    OUT KEY_LIST  **ppKeyList)
{
    HCRYPTPROV    hProv = NULL;
    BYTE          *pbData = NULL;
    DWORD         cbData;
    DWORD         cb;
    DWORD         dwFirstKeyFlag;
    HRESULT       hr;

    BOOL bRetVal;
    KEY_LIST * pklTravel;
    BOOL fFoundDefaultKey;
    DWORD dwSilent = fSilent? CRYPT_SILENT : 0;
    DWORD dwFlags;

    KEY_LIST      *pKeyList = NULL;
    KEY_LIST      *pKey = NULL;

    *ppKeyList = NULL;
    if (NULL == pwszProvName)
    {
        // explicitly disallowed because NULL is valid for CryptAcquireContext

        hr = E_INVALIDARG;
	_JumpError(hr, error, "NULL parm");
    }

    // get a prov handle for key enum

    dwFlags = CRYPT_VERIFYCONTEXT;

    for (;;)
    {
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "myCertSrvCryptAcquireContext(%ws, f=%x, m=%x)\n",
	    pwszProvName,
	    dwFlags | dwSilent,
	    fMachineKeySet));

	if (myCertSrvCryptAcquireContext(
				&hProv,
				NULL,
				pwszProvName,
				dwProvType,
				dwFlags | dwSilent,
				fMachineKeySet))
	{
	    break;		// Success!
	}

	hr = myHLastError();
	_PrintErrorStr2(hr, "myCertSrvCryptAcquireContext", pwszProvName, hr);

	// MITVcsp can't support a verify context, create a dummy container

	if ((CRYPT_VERIFYCONTEXT & dwFlags) &&
	    0 == LSTRCMPIS(pwszProvName, L"MITV Smartcard Crypto Provider V0.2"))
	{
	    dwFlags &= ~CRYPT_VERIFYCONTEXT;
	    dwFlags |= CRYPT_NEWKEYSET;
	    continue;

        }

	// Exchange can't handle fMachineKeySet or CRYPT_SILENT

	if ((fMachineKeySet || (CRYPT_SILENT & dwSilent)) &&
	    NTE_BAD_FLAGS == hr &&
	    0 == LSTRCMPIS(pwszProvName, L"Microsoft Exchange Cryptographic Provider v1.0"))
	{
	    dwSilent &= ~CRYPT_SILENT;
	    fMachineKeySet = FALSE;
	    continue;
	}
	_JumpErrorStr(hr, error, "myCertSrvCryptAcquireContext", pwszProvName);
    }

    // Enumerate a key so we can get the maximum buffer size required.
    // The first key may be a bad one, so we may have to assume a fixed buffer.

    hr = S_OK;
    cbData = 0;
    bRetVal = CryptGetProvParam(
			    hProv,
			    PP_ENUMCONTAINERS,
			    NULL,
			    &cbData,
			    CRYPT_FIRST);
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"CryptGetProvParam(%ws) -> cb=%d, bRet=%d\n",
	pwszProvName,
	cbData,
	bRetVal));
    if (!bRetVal)
    {
	// We'd like to skip the bad key (key container with long name?),
	// but we get stuck enumerating the same entry over and over again.
	// Guess at the maximum size...

	hr = myHLastError();
	_PrintErrorStr2(
		    hr,
		    "CryptGetProvParam(ignored: use 2 * MAX_PATH)",
		    pwszProvName,
		    HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
	if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) != hr)
	{
	    cbData = 0;
	    hr = S_OK;
	}
    }
    if (S_OK == hr)
    {
	if (0 == cbData)
	{
	    cbData = 2 * MAX_PATH * sizeof(CHAR);
	}

	// allocate the buffer
	pbData = (BYTE *) LocalAlloc(LMEM_FIXED, cbData);
	if (NULL == pbData)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}


	// enumerate all the keys for this container

	dwFirstKeyFlag = CRYPT_FIRST;
	for (;;)
	{
	    // get the key name

	    *pbData = '\0';
	    cb = cbData;

	    bRetVal = CryptGetProvParam(
				    hProv,
				    PP_ENUMCONTAINERS,
				    pbData,
				    &cb,
				    dwFirstKeyFlag);

	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"CryptGetProvParam(pb=%x, f=%d) -> cb=%d->%d, key=%hs, bRet=%d\n",
		pbData,
		dwFirstKeyFlag,
		cbData,
		cb,
		pbData,
		bRetVal));
	    DBGDUMPHEX((
		    DBG_SS_CERTLIBI,
		    0,
		    pbData,
		    strlen((char const *) pbData)));

	    dwFirstKeyFlag = 0;

	    if (!bRetVal)
	    {
		hr = myHLastError();
		if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr ||
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
		{
		    // no more keys to get
		    break;
		}
		else if (NTE_BAD_KEYSET == hr ||
			 HRESULT_FROM_WIN32(ERROR_MORE_DATA) == hr )
		{
		    // skip the bad key (key container with long name?)
		    _PrintError(hr, "bad key");
		    continue;
		}
		_JumpError(hr, error, "CryptGetProvParam");
	    }

	    pKey = newKey((CHAR *) pbData);
	    if (NULL == pKey)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    DBGDUMPHEX((
		    DBG_SS_CERTLIBI,
		    0,
		    (BYTE const *) pKey->pwszName,
		    sizeof(WCHAR) * wcslen(pKey->pwszName)));

	    addKeyList(&pKeyList, pKey);

	} // <- End of enumeration loop

	// clean up:
	// free the old buffer
	if (NULL != pbData)
	{
	    LocalFree(pbData);
	    pbData = NULL;
	}
    }

    // release the old context
    CryptReleaseContext(hProv, 0);
    hProv = NULL;

    // get the default key container and make sure it is in the key list

    if (!myCertSrvCryptAcquireContext(
			    &hProv,
			    NULL,
			    pwszProvName,
			    dwProvType,
			    dwSilent,
			    fMachineKeySet))
    {
        hr = myHLastError();
        _PrintError2(hr, "myCertSrvCryptAcquireContext", hr);
        goto done;
    }

    // find out its name
    cbData = 0;
    for (;;)
    {
        if (!CryptGetProvParam(hProv, PP_CONTAINER, pbData, &cbData, 0))
	{
            hr = myHLastError();
	    _PrintError2(hr, "CryptGetProvParam", hr);
	    goto done;
        }
        if (NULL != pbData)
        {
            // got it
            break;
        }
        pbData = (BYTE *) LocalAlloc(LMEM_FIXED, cbData);
	if (NULL == pbData)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }

    // create a (temporary) key structure
    pKey = newKey((CHAR *) pbData);
    if (NULL == pKey)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // walk the key list and see if this key is there
    fFoundDefaultKey = FALSE;
    for (pklTravel = pKeyList; NULL != pklTravel; pklTravel = pklTravel->next)
    {
        if (0 == wcscmp(pKey->pwszName, pklTravel->pwszName))
	{
            fFoundDefaultKey = TRUE;
            break;
        }
    }

    if (fFoundDefaultKey)
    {
        // we found it - delete the temp structure.

        freeKey(pKey);
    }
    else
    {
        // we didn't find it, so add the key to the list.

	addKeyList(&pKeyList, pKey);
    }

done:
    // pass list back to caller
    *ppKeyList = pKeyList;
    pKeyList = NULL;
    hr = S_OK;

error:
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    if (NULL != pKeyList)
    {
        csiFreeKeyList(pKeyList);
    }
    if (NULL != pbData)
    {
        LocalFree(pbData);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\config.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       config.cpp
//
//  Contents:   OC Manager component DLL for running the Certificate
//              Server setup.
//
//--------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <string.h>
#include "csdisp.h"
#include "csprop.h"
#include "wizpage.h"
#include "certmsg.h"


#define __dwFILE__      __dwFILE_OCMSETUP_CONFIG_CPP__

WCHAR const g_szCertSrvDotTxt[] = L"certsrv.txt";
WCHAR const g_szCertSrvDotBak[] = L"certsrv.bak";
WCHAR const g_szSlashCertSrvDotTmp[] = L"\\certsrv.tmp";

#define wszXEnrollDllFileForVer L"CertSrv\\CertControl\\x86\\xenroll.dll"
#define wszScrdEnrlDllFileForVer L"CertSrv\\CertControl\\x86\\scrdenrl.dll"
#define wszScrdW2KDllFileForVer L"CertSrv\\CertControl\\w2k\\scrdenrl.dll"


//+-------------------------------------------------------------------------
//
//  Function:   GetBaseFileNameFromFullPath()
//
//  Synopsis:   Takes a string representing a path of the form
//              "\foo\bar\shrd\lu\basefilename"
//              and extracts the "basefilename" from the end.
//
//  Effects:    Modifies the pointer in the second argument;
//              allocates memory.
//
//  Arguments:  [pszFullPath]           -- Path to operate on
//              [pszBaseFileName]       -- Buffer to receive base name
//
//  Returns:    BOOL success/failure code.
//
//  Requires:   Assumes that pszBaseFileName is a pre-allocated buffer of
//              size sufficient to hold the filename extracted from
//              pszFullPath---NO ERROR CHECKING IS DONE ON THIS ARGUMENT;
//              IN THE CURRENT CODE BUFFERS GIVEN TO THIS ARGUMENT ARE
//              STATICALLY ALLOCATED OF SIZE MAX_PATH (OR EQUIVALENTLY
//              STRBUF_SIZE).
//
//  Modifies:   [ppszBaseFileName]
//
//  History:    10/25/96        JerryK  Created
//              11/25/96        JerryK  Code Cleanup
//
//--------------------------------------------------------------------------
BOOL
GetBaseFileNameFromFullPath(
                            IN const LPTSTR pszFullPath,
                            OUT LPTSTR pszBaseFileName)
{
    LPTSTR      pszBaseName;
    BOOL        fRetVal;
    
    // Find the last '\' character in the full path string
    if (NULL == (pszBaseName = _tcsrchr(pszFullPath,TEXT('\\'))))
    {
        // Didn't find a '\' character at all so point to start of string
        pszBaseName = pszFullPath;
    }
    else
    {
        // Found the '\' character so move to point just past it
        pszBaseName++;
    }
    
    // Copy the base file name into the result buffer
    _tcscpy(pszBaseFileName,pszBaseName);
    
    // Set up return value
    fRetVal = TRUE;
    
    return fRetVal;
}

HRESULT myStringToAnsiFile(HANDLE hFile, LPCSTR psz, DWORD cch)
{
    DWORD dwWritten;

    if (cch == -1)
        cch = lstrlenA(psz);

    if (!WriteFile(
            hFile,
            psz,
            cch,
            &dwWritten,
            NULL))
        return myHLastError();

    CSASSERT(dwWritten == cch);
    return S_OK;
}

HRESULT myStringToAnsiFile(HANDLE hFile, LPCWSTR pwsz, DWORD cch)
{
    HRESULT hr;
    LPSTR psz = NULL;

    if (!ConvertWszToSz(&psz, pwsz, cch))
    {
        hr = myHLastError();
        goto Ret;
    }
    hr = myStringToAnsiFile(hFile, psz, cch);

Ret:
    if (psz)
        LocalFree(psz);

    return hr;
}

HRESULT myStringToAnsiFile(HANDLE hFile, CHAR ch)
{
    return myStringToAnsiFile(hFile, &ch, 1);
}


HRESULT
WriteEscapedString(
                   HANDLE hConfigFile, 
                   WCHAR const *pwszIn,
                   IN BOOL fEol)
{
    BOOL fQuote = FALSE;
    DWORD i;
    HRESULT hr;
    
    if (NULL == pwszIn)
    {
        hr = myStringToAnsiFile(hConfigFile, "\"\"", 2); // write ("")
        _JumpIfError(hr, error, "myStringToAnsiFile");
    }
    else
    {
        // Quote strings that have double quotes, commas, '#' or white space,
        // or that are empty.
        
        fQuote = L'\0' != pwszIn[wcscspn(pwszIn, L"\",# \t")] || L'\0' == *pwszIn;
        
        if (fQuote)
        {
            hr = myStringToAnsiFile(hConfigFile, '"');
            _JumpIfError(hr, error, "myStringToAnsiFile");
        }
        for (;;)
        {
            // Find a L'\0' or L'"', and print the string UP TO that character:
            i = wcscspn(pwszIn, L"\"");
            hr = myStringToAnsiFile(hConfigFile, pwszIn, i);
            _JumpIfError(hr, error, "myStringToAnsiFile");

            
            // Point to the L'\0' or L'"', and stop at the end of the string.
            
            pwszIn += i;
            if (L'\0' == *pwszIn)
            {
                break;
            }
            
            // Skip the L'"', and print two of them to escape the embedded quote.
            
            pwszIn++;
            hr = myStringToAnsiFile(hConfigFile, "\"\"", 2); // write ("")
            _JumpIfError(hr, error, "myStringToAnsiFile");
        }
        if (fQuote)
        {
            hr = myStringToAnsiFile(hConfigFile, '"');
            _JumpIfError(hr, error, "myStringToAnsiFile");
        }
    }
    
    hr = myStringToAnsiFile(hConfigFile, fEol ? "\r\n" : ", ", 2);  // each insert string is 2 chars
    _JumpIfError(hr, error, "myStringToAnsiFile");

error:
    return hr;
}


HRESULT
WriteNewConfigEntry(
    HANDLE      hConfigFile, 
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    WCHAR wszSelfSignFName[MAX_PATH];
    WCHAR *pwszConfig = NULL;
    CASERVERSETUPINFO *pServer = (pComp->CA).pServer;


    hr = myFormConfigString(pComp->pwszServerName,
                            pServer->pwszSanitizedName,
                            &pwszConfig);
    _JumpIfError(hr, error, "myFormConfigString");
    
    // Yank out the base filenames for the exchange and self-signed certs
    GetBaseFileNameFromFullPath(pServer->pwszCACertFile, wszSelfSignFName);
    
    hr = WriteEscapedString(hConfigFile, pServer->pwszSanitizedName, FALSE);
    _JumpIfError(hr, error, "WriteEscapedString");


// org, ou, country, state
        hr = WriteEscapedString(hConfigFile, L"", FALSE);
        _JumpIfError(hr, error, "WriteEscapedString");
        hr = WriteEscapedString(hConfigFile, L"", FALSE);
        _JumpIfError(hr, error, "WriteEscapedString");
        hr = WriteEscapedString(hConfigFile, L"", FALSE);
        _JumpIfError(hr, error, "WriteEscapedString");
        hr = WriteEscapedString(hConfigFile, L"", FALSE);
        _JumpIfError(hr, error, "WriteEscapedString");




    hr = WriteEscapedString(hConfigFile, L"", FALSE);
    _JumpIfError(hr, error, "WriteEscapedString");

    hr = WriteEscapedString(hConfigFile, pwszConfig, FALSE);
    _JumpIfError(hr, error, "WriteEscapedString");

    hr = WriteEscapedString(hConfigFile, L"", FALSE);   // dummy wszExchangeFName
    _JumpIfError(hr, error, "WriteEscapedString");

    hr = WriteEscapedString(hConfigFile, wszSelfSignFName, FALSE);
    _JumpIfError(hr, error, "WriteEscapedString");


// ca description
    hr = WriteEscapedString(hConfigFile, L"", TRUE);
    _JumpIfError(hr, error, "WriteEscapedString");

error:
    if (NULL != pwszConfig)
    {
        LocalFree(pwszConfig);
    }
    return(hr);
}

WCHAR *apwszFieldNames[] = {
        wszCONFIG_COMMONNAME,
        wszCONFIG_ORGUNIT,
        wszCONFIG_ORGANIZATION,
        wszCONFIG_LOCALITY,
        wszCONFIG_STATE,
        wszCONFIG_COUNTRY,
#define FN_CONFIG       6       // Index into apwszFieldNames & apstrFieldNames
        wszCONFIG_CONFIG,
        wszCONFIG_EXCHANGECERTIFICATE,
#define FN_CERTNAME     8       // Index into apwszFieldNames & apstrFieldNames
        wszCONFIG_SIGNATURECERTIFICATE,
#define FN_COMMENT      9       // Index into apwszFieldNames & apstrFieldNames
        wszCONFIG_DESCRIPTION,
};
#define CSTRING (sizeof(apwszFieldNames)/sizeof(apwszFieldNames[0]))

BSTR apstrFieldNames[CSTRING];


HRESULT
CopyConfigEntry(
    IN HANDLE hConfigFile, 
    IN ICertConfig *pConfig)
{
    HRESULT hr;
    BSTR strFieldValue = NULL;
    BSTR strComment = NULL;
    BSTR strCertName = NULL;
    DWORD i;
    
    for (i = 0; i < CSTRING; i++)
    {
        CSASSERT(NULL != apstrFieldNames[i]);
        hr = pConfig->GetField(apstrFieldNames[i], &strFieldValue);
        _JumpIfErrorNotSpecific(
            hr,
            error,
            "ICertConfig::GetField",
            CERTSRV_E_PROPERTY_EMPTY);
        
        hr = WriteEscapedString(hConfigFile, strFieldValue, ((CSTRING - 1) == i) );
        _JumpIfError(hr, error, "WriteEscapedString");
        
        switch (i)
        {
        case FN_CERTNAME:
            strCertName = strFieldValue;
            strFieldValue = NULL;
            break;
            
        case FN_COMMENT:
            strComment = strFieldValue;
            strFieldValue = NULL;
            break;
        }
    }
    
    hr = S_OK;
error:
    if (NULL != strFieldValue)
    {
        SysFreeString(strFieldValue);
    }
    if (NULL != strComment)
    {
        SysFreeString(strComment);
    }
    if (NULL != strCertName)
    {
        SysFreeString(strCertName);
    }
    return(hr);
}


HRESULT
WriteFilteredConfigEntries(
                           IN HANDLE hConfigFile, 
                           IN ICertConfig *pConfig,
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT hr = S_OK;
    LONG Count;
    LONG Index;
    BSTR strConfig = NULL;
    BSTR strFlags = NULL;
    LONG lConfigFlags;
    WCHAR *pwsz;
    WCHAR *pwszConfigServer = NULL;
    DWORD cwcConfigServer;
    DWORD cwc;
    DWORD i;
    BOOL fValidDigitString;
    BSTR strConfigFlags = NULL;
    
    for (i = 0; i < CSTRING; i++)
    {
        if (!ConvertWszToBstr(&apstrFieldNames[i], apwszFieldNames[i], -1))
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "ConvertWszToBstr");
        }
    }
    hr = pConfig->Reset(0, &Count);
    if (S_OK != hr)
    {
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_OK;
        }
        _JumpError2(hr, error, "Reset", S_FALSE);
    }

    strConfigFlags = SysAllocString(wszCONFIG_FLAGS);
    if (NULL == strConfigFlags)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "SysAllocString");
    }
    cwcConfigServer = 0;
    while (Count-- > 0)
    {
        hr = pConfig->Next(&Index);
        _JumpIfError(hr, error, "Next");
        
        hr = pConfig->GetField(apstrFieldNames[FN_CONFIG], &strConfig);
        _JumpIfError(hr, error, "GetField");
        
        pwsz = wcschr(strConfig, L'\\');
        if (NULL == pwsz)
        {
            cwc = wcslen(strConfig);
        }
        else
        {
            cwc = SAFE_SUBTRACT_POINTERS(pwsz, strConfig);
        }
        if (NULL == pwszConfigServer || cwc >= cwcConfigServer)
        {
            if (NULL != pwszConfigServer)
            {
                LocalFree(pwszConfigServer);
                pwszConfigServer = NULL;
            }
            cwcConfigServer = cwc + 1;
            if (2 * MAX_COMPUTERNAME_LENGTH > cwcConfigServer)
            {
                cwcConfigServer = 2 * MAX_COMPUTERNAME_LENGTH;
            }
            pwszConfigServer = (WCHAR *) LocalAlloc(
                LMEM_FIXED,
                cwcConfigServer * sizeof(WCHAR));
            _JumpIfOutOfMemory(hr, error, pwszConfigServer);
            
        }
        CSASSERT(cwc < cwcConfigServer);
        CopyMemory(pwszConfigServer, strConfig, cwc * sizeof(WCHAR));
        pwszConfigServer[cwc] = L'\0';
        
        hr = pConfig->GetField(strConfigFlags, &strFlags);
        _JumpIfError(hr, error, "GetField");

        lConfigFlags = myWtoI(strFlags, &fValidDigitString);
        
        // write everything _but_ current server
        if (0 != mylstrcmpiL(pwszConfigServer, pComp->pwszServerName) &&
            0 != mylstrcmpiL(pwszConfigServer, pComp->pwszServerNameOld) &&
            0 != (CAIF_SHAREDFOLDERENTRY & lConfigFlags) )
        {
            hr = CopyConfigEntry(hConfigFile, pConfig);
            _JumpIfError(hr, error, "CopyConfigEntry");
        }
    }
    
error:
    if (NULL != pwszConfigServer)
    {
        LocalFree(pwszConfigServer);
    }
    for (i = 0; i < CSTRING; i++)
    {
        if (NULL != apstrFieldNames[i])
        {
            SysFreeString(apstrFieldNames[i]);
            apstrFieldNames[i] = NULL;
        }
    }
    if (NULL != strConfigFlags)
    {
        SysFreeString(strConfigFlags);
    }
    if (NULL != strConfig)
    {
        SysFreeString(strConfig);
    }
    if (NULL != strFlags)
    {
        SysFreeString(strFlags);
    }
    return(hr);
}


HRESULT
CertReplaceFile(
    IN WCHAR const *pwszpath,
    IN WCHAR const *pwszFileNew,
    IN WCHAR const *pwszFileBackup)
{
    HRESULT hr;
    WCHAR *pwsz;
    WCHAR wszpathNew[MAX_PATH];
    WCHAR wszpathBackup[MAX_PATH];
    
    if (wcslen(pwszpath) >= ARRAYSIZE(wszpathNew))
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpErrorStr(hr, error, "wszpathNew", pwszpath);
    }
    wcscpy(wszpathNew, pwszpath);
    pwsz = wcsrchr(wszpathNew, L'\\');
    if (NULL == pwsz)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "pwsz");
    }
    pwsz[1] = L'\0';

    if (wcslen(wszpathNew) + wcslen(pwszFileBackup) >= ARRAYSIZE(wszpathBackup))
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpErrorStr(hr, error, "wszpathBackup", wszpathNew);
    }
    wcscpy(wszpathBackup, wszpathNew);
    wcscat(wszpathBackup, pwszFileBackup);

    if (wcslen(wszpathNew) + wcslen(pwszFileNew) >= ARRAYSIZE(wszpathNew))
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpErrorStr(hr, error, "wszpathBackup", wszpathNew);
    }
    wcscat(wszpathNew, pwszFileNew);
    
    if (!DeleteFile(wszpathBackup))
    {
        hr = myHLastError();
        _PrintErrorStr2(
                    hr,
                    "DeleteFile",
                    wszpathBackup,
                    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }
    if (!MoveFile(wszpathNew, wszpathBackup))
    {
        hr = myHLastError();
        _PrintErrorStr2(
                    hr,
                    "MoveFile",
                    wszpathNew,
                    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }
    if (!MoveFile(pwszpath, wszpathNew))
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "MoveFile", pwszpath);
    }

    hr = S_OK;
error:
    return(hr);
}


//--------------------------------------------------------------------
// Perform search and replace on the source string, using multiple
// replacee strings, and returns the result.
//   rgrgwszReplacement is an array of arrays of two strings:
//     rgrgwszReplacement[n][0] is the replacee,
//     rgrgwszReplacement[n][1] is the replacment.
//   No portion of any of the replacement strings is searched for a replacee string.
//   Replacement strings may be NULL.

#define REPLACEE	0
#define REPLACEMENT	1

WCHAR *
MultiStringReplace(
    const WCHAR * pwszSource,
    const WCHAR *(* rgrgpwszReplacements)[2],
    unsigned int nReplacements)
{
    // precondition
    CSASSERT(NULL!=pwszSource);
    CSASSERT(nReplacements>0);
    CSASSERT(NULL!=rgrgpwszReplacements);

    // common variables
    unsigned int nIndex;
    BOOL bSubstFound;
    unsigned int nChosenReplacement;
    const WCHAR * pwchSubstStart;
    const WCHAR * pwchSearchStart;
    WCHAR * pwszTarget=NULL;
    WCHAR * pwchTargetStart;

    // first, calculate the length of the result string
    unsigned int nFinalStringLen=wcslen(pwszSource)+1;
    pwchSearchStart=pwszSource;
    pwchSubstStart = NULL;
    nChosenReplacement = 0;
    for (;;)
    {
        // find the next substitution
        bSubstFound=FALSE;
        for (nIndex=0; nIndex<nReplacements; nIndex++) {
            WCHAR * pwchTempSubstStart=wcsstr(pwchSearchStart, rgrgpwszReplacements[nIndex][REPLACEE]);
            if (NULL==pwchTempSubstStart) {
                // we didn't find this replacee in the target
                //  so ignore it
            } else if (FALSE==bSubstFound) {
                // this is the first one we found
                pwchSubstStart=pwchTempSubstStart;
                bSubstFound=TRUE;
                nChosenReplacement=nIndex;
            } else if (pwchSubstStart>pwchTempSubstStart) {
                // this is one comes before the one we already found
                pwchSubstStart=pwchTempSubstStart;
                nChosenReplacement=nIndex;
            } else {
                // this is one comes after the one we already found
                //  so ignore it
            }
        } // <- end substitution finding loop

        // if no substitution has been found, exit the loop
        if (FALSE==bSubstFound) {
            break;
        }

        // update the statistics
        nFinalStringLen=nFinalStringLen
            + (NULL != rgrgpwszReplacements[nChosenReplacement][REPLACEMENT] ?
              wcslen(rgrgpwszReplacements[nChosenReplacement][REPLACEMENT]) : 0)
            -wcslen(rgrgpwszReplacements[nChosenReplacement][REPLACEE]);
        pwchSearchStart=pwchSubstStart+wcslen(rgrgpwszReplacements[nChosenReplacement][REPLACEE]);

    } // <- end length-calculating loop

    // allocate the new string
    pwszTarget=(WCHAR *)LocalAlloc(LMEM_FIXED, nFinalStringLen*sizeof(WCHAR));
    if (NULL==pwszTarget) {
        _JumpError(E_OUTOFMEMORY, error, "LocalAlloc");
    }

    // build the result
    pwchTargetStart=pwszTarget;
    pwchSearchStart=pwszSource;
    nChosenReplacement = 0;
    for (;;)
    {
        // find the next substitution
        bSubstFound=FALSE;
        for (nIndex=0; nIndex<nReplacements; nIndex++) {
            WCHAR * pwchTempSubstStart=wcsstr(pwchSearchStart, rgrgpwszReplacements[nIndex][REPLACEE]);
            if (NULL==pwchTempSubstStart) {
                // we didn't find this replacee in the target
                //  so ignore it
            } else if (FALSE==bSubstFound) {
                // this is the first one we found
                pwchSubstStart=pwchTempSubstStart;
                bSubstFound=TRUE;
                nChosenReplacement=nIndex;
            } else if (pwchSubstStart>pwchTempSubstStart) {
                // this is one comes before the one we already found
                pwchSubstStart=pwchTempSubstStart;
                nChosenReplacement=nIndex;
            } else {
                // this is one comes after the one we already found
                //  so ignore it
            }
        } // <- end substitution finding loop

        // if no substitution has been found, exit the loop
        if (FALSE==bSubstFound) {
            break;
        }

        // copy the source up to the replacee
        unsigned int nCopyLen=SAFE_SUBTRACT_POINTERS(pwchSubstStart, pwchSearchStart);
        wcsncpy(pwchTargetStart, pwchSearchStart, nCopyLen);
        pwchTargetStart+=nCopyLen;

        if (NULL != rgrgpwszReplacements[nChosenReplacement][REPLACEMENT])
        {
            // copy the replacement
            nCopyLen=wcslen(rgrgpwszReplacements[nChosenReplacement][REPLACEMENT]);
            wcsncpy(pwchTargetStart, rgrgpwszReplacements[nChosenReplacement][REPLACEMENT], nCopyLen);
            pwchTargetStart+=nCopyLen;
        }

        // skip over the replacee
        pwchSearchStart=pwchSubstStart+wcslen(rgrgpwszReplacements[nChosenReplacement][REPLACEE]);

    } // <- end target string building loop

    // finish copying whatever's left, which may be just '\0'.
    wcscpy(pwchTargetStart, pwchSearchStart);

    // postcondition
    CSASSERT(wcslen(pwszTarget)+1==nFinalStringLen);

    // all done
error:
    return pwszTarget;
}

//--------------------------------------------------------------------
// Escapes any characters unsuitable for plain HTML (or VBScript)
static const WCHAR * gc_rgrgpwszHTMLSafe[4][2]={
    {L"<", L"&lt;"}, {L">", L"&gt;"}, {L"\"", L"&quot;"},  {L"&", L"&amp;"}
};
WCHAR * MakeStringHTMLSafe(const WCHAR * pwszTarget) {
    return MultiStringReplace(pwszTarget, gc_rgrgpwszHTMLSafe, ARRAYSIZE(gc_rgrgpwszHTMLSafe));
}

//--------------------------------------------------------------------
// Escapes any characters unsuitable for plain HTML (or VBScript)
static const WCHAR * gc_rgrgpwszVBScriptSafe[2][2]={
    {L"\"", L"\"\""}, {L"%>", L"%\" & \">"}
};
WCHAR * MakeStringVBScriptSafe(const WCHAR * pwszTarget) {
    return MultiStringReplace(pwszTarget, gc_rgrgpwszVBScriptSafe, ARRAYSIZE(gc_rgrgpwszVBScriptSafe));
}

//--------------------------------------------------------------------
// Perform search and replace on the source string and return the result
//   No portion of the replacement string is searched for the replacee string.
//   Simple adapter for MultiStringReplace
WCHAR * SingleStringReplace(const WCHAR * pwszSource, const WCHAR * pwszReplacee, const WCHAR * pwszReplacement) {
    const WCHAR * rgrgpwszTemp[1][2]={{pwszReplacee, pwszReplacement}};
    return MultiStringReplace(pwszSource, rgrgpwszTemp, ARRAYSIZE(rgrgpwszTemp));
}

//--------------------------------------------------------------------
// write a string to a file
//   Mostly, this is a wrapper to do UNICODE->UTF8 conversion.
HRESULT WriteString(HANDLE hTarget, const WCHAR * pwszSource) {

    // precondition
    CSASSERT(NULL!=pwszSource);
    CSASSERT(NULL!=hTarget && INVALID_HANDLE_VALUE!=hTarget);

    // common variables
    HRESULT hr=S_OK;
    char * pszMbcsBuf=NULL;

    // perform UNICODE->MBCS

    // determine size of output buffer
    DWORD dwBufByteSize=WideCharToMultiByte(CP_UTF8/*code page*/, 0/*flags*/, pwszSource,
        -1/*null-terminated*/, NULL/*out-buf*/, 0/*size of out-buf, 0->calc*/, 
        NULL/*default char*/, NULL/*used default char*/);
    if (0==dwBufByteSize) {
        hr=myHLastError();
        _JumpError(hr, error, "WideCharToMultiByte(calc)");
    }

    // allocate output buffer
    pszMbcsBuf=(char *)LocalAlloc(LMEM_FIXED, dwBufByteSize);
    _JumpIfOutOfMemory(hr, error, pszMbcsBuf);

    // do the conversion
    if (0==WideCharToMultiByte(CP_UTF8/*code page*/, 0/*flags*/, pwszSource,
        -1/*null-terminated*/, pszMbcsBuf, dwBufByteSize,
        NULL/*default char*/, NULL/*used default char*/)) {

        hr=myHLastError();
        _JumpError(hr, error, "WideCharToMultiByte(convert)");
    }

    // write to file and free the string
    dwBufByteSize--; // minus one so we don't write the terminating null
    DWORD dwBytesWritten;
    if (FALSE==WriteFile(hTarget, pszMbcsBuf, dwBufByteSize, &dwBytesWritten, NULL /*overlapped*/)) {
        hr=myHLastError();
        _JumpError(hr, error, "WriteFile");
    }

    // all done
error:
    if (NULL!=pszMbcsBuf) {
        LocalFree(pszMbcsBuf);
    }
    return hr;
}

//--------------------------------------------------------------------
// return the version string for a file in the format for a web page (comma separated)
HRESULT
GetFileWebVersionString(
    IN WCHAR const * pwszFileName,
    OUT WCHAR ** ppwszVersion)
{
    // precondition
    CSASSERT(NULL!=pwszFileName);
    CSASSERT(NULL!=ppwszVersion);

    // common variables
    HRESULT hr;
    DWORD cbData;
    DWORD dwIgnored;
    UINT uLen;
    VS_FIXEDFILEINFO * pvs;
    WCHAR wszFileVersion[64];
    int  cch;

    // variables that must be cleaned up
    VOID * pvData=NULL;

    // reset the output parameter
    *ppwszVersion=NULL;

    // determine the size of the memory block needed to store the version info
    cbData=GetFileVersionInfoSize(const_cast<WCHAR *>(pwszFileName), &dwIgnored);
    if (0==cbData) {
        hr=myHLastError();
        if (S_OK==hr) {
            hr=HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
        }
        _JumpErrorStr(hr, error, "GetFileVersionInfoSize", pwszFileName);
    }

    // allocate the block
    pvData=LocalAlloc(LMEM_FIXED, cbData);
    _JumpIfOutOfMemory(hr, error, pvData);

    // load the file version info
    if (!GetFileVersionInfo(const_cast<WCHAR *>(pwszFileName), dwIgnored, cbData, pvData)) {
        hr=myHLastError();
        _JumpErrorStr(hr, error, "GetFileVersionInfo", pwszFileName);
    }

    // get a pointer to the root block
    if (!VerQueryValue(pvData, L"\\", (VOID **) &pvs, &uLen)) {
        hr=myHLastError();
        _JumpError(hr, error, "VerQueryValue");
    }

    cch = wsprintf(wszFileVersion, L"%d,%d,%d,%d",
                    HIWORD(pvs->dwFileVersionMS),
                    LOWORD(pvs->dwFileVersionMS),
                    HIWORD(pvs->dwFileVersionLS),
                    LOWORD(pvs->dwFileVersionLS));
    CSASSERT(cch < ARRAYSIZE(wszFileVersion));
    *ppwszVersion = (WCHAR*)LocalAlloc(LMEM_FIXED,
                            (wcslen(wszFileVersion)+1) * sizeof(WCHAR));
    if (NULL == *ppwszVersion)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(*ppwszVersion, wszFileVersion);

    hr=S_OK;

error:
    if (NULL != pvData) {
        LocalFree(pvData);
    }

    return hr;
}

//--------------------------------------------------------------------
// create the .inc file that has the basic configuration data
HRESULT CreateCertWebDatIncPage(IN PER_COMPONENT_DATA *pComp, IN BOOL bIsServer)
{
    // precondition
    CSASSERT(NULL!=pComp);

    // common variables
    HRESULT hr=S_OK;
    HANDLE hTarget=INVALID_HANDLE_VALUE;
    const WCHAR * rgrgpwszSubst[13][2];
    WCHAR wszTargetFileName[MAX_PATH];
    wszTargetFileName[0] = L'\0';

    // variables that must be cleaned up
    WCHAR * pwszTempA=NULL;
    WCHAR * pwszTempB=NULL;
    WCHAR * pwszTempC=NULL;
    WCHAR * pwszTempD=NULL;
    WCHAR * pwszTempE=NULL;
    WCHAR * pwszTempF=NULL; 
    ENUM_CATYPES CAType;

    // create the target file name
    wcscpy(wszTargetFileName, pComp->pwszSystem32);
    wcscat(wszTargetFileName, L"CertSrv\\certdat.inc");
    
    // get html lines from resource
    // Note, we don't have to free these strings.
    WCHAR const * pwszCWDat=myLoadResourceString(IDS_HTML_CERTWEBDAT);
    if (NULL==pwszCWDat) {
        hr=myHLastError();
        _JumpError(hr, error, "myLoadResourceString");
    }

    // open the file
    hTarget=CreateFileW(wszTargetFileName, GENERIC_WRITE, 0/*no sharing*/, NULL/*security*/, 
        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL/*template*/);
    if (INVALID_HANDLE_VALUE==hTarget) {
        hr=myHLastError();
        _JumpError(hr, error, "CreateFileW");
    }

    // prepare to write the file
    //   %0 - default company
    //   %1 - default OrgUnit
    //   %2 - default locality
    //   %3 - default state
    //   %4 - default country
    //   %5 - computer
    //   %6 - CA name (unsanitized, for config)
    //   %7 - server type
    //   %8 - opposite of %7
    //   %9 - XEnroll version
    //   %A - ScrdEnrl version
    //   %B - CA name (unsanitized, for display)
    //   %C - W2K ScrdEnrl version

    rgrgpwszSubst[0][REPLACEE]=L"%0";
    rgrgpwszSubst[1][REPLACEE]=L"%1";
    rgrgpwszSubst[2][REPLACEE]=L"%2";
    rgrgpwszSubst[3][REPLACEE]=L"%3";
    rgrgpwszSubst[4][REPLACEE]=L"%4";
    rgrgpwszSubst[5][REPLACEE]=L"%5";
    rgrgpwszSubst[6][REPLACEE]=L"%6";
    rgrgpwszSubst[7][REPLACEE]=L"%7";
    rgrgpwszSubst[8][REPLACEE]=L"%8";
    rgrgpwszSubst[9][REPLACEE]=L"%9";
    rgrgpwszSubst[10][REPLACEE]=L"%A";
    rgrgpwszSubst[11][REPLACEE]=L"%B";
    rgrgpwszSubst[12][REPLACEE]=L"%C";

        rgrgpwszSubst[0][REPLACEMENT]=L""; // company/org
        rgrgpwszSubst[1][REPLACEMENT]=L""; // ou
        rgrgpwszSubst[2][REPLACEMENT]=L""; // locality
        rgrgpwszSubst[3][REPLACEMENT]=L""; // state
        rgrgpwszSubst[4][REPLACEMENT]=L""; // country

    if (FALSE==bIsServer) {
        // This is a web-client only setup
        CAWEBCLIENTSETUPINFO *pClient=pComp->CA.pClient;

         // set the identity of the CA
        rgrgpwszSubst[5][REPLACEMENT]=pClient->pwszWebCAMachine;

        pwszTempE=MakeStringVBScriptSafe(pClient->pwszWebCAName);
        _JumpIfOutOfMemory(hr, error, pwszTempE);
        rgrgpwszSubst[6][REPLACEMENT]=pwszTempE;

        pwszTempD=MakeStringHTMLSafe(pClient->pwszWebCAName);
        _JumpIfOutOfMemory(hr, error, pwszTempD);
        rgrgpwszSubst[11][REPLACEMENT]=pwszTempD;

        CAType = pClient->WebCAType;

    } else {
        // This is a server + web-client setup
        CASERVERSETUPINFO *pServer=pComp->CA.pServer;

         // set the identity of the CA
        rgrgpwszSubst[5][REPLACEMENT]=pComp->pwszServerName;

        pwszTempE=MakeStringVBScriptSafe(pServer->pwszCACommonName);
        _JumpIfOutOfMemory(hr, error, pwszTempE);
        rgrgpwszSubst[6][REPLACEMENT]=pwszTempE;

        pwszTempD=MakeStringHTMLSafe(pServer->pwszCACommonName);
        _JumpIfOutOfMemory(hr, error, pwszTempD);
        rgrgpwszSubst[11][REPLACEMENT]=pwszTempD;

        CAType = pServer->CAType;
    }

    // set the CA type
    if (IsStandaloneCA(CAType)) {
        rgrgpwszSubst[7][REPLACEMENT]=L"StandAlone";
        rgrgpwszSubst[8][REPLACEMENT]=L"Enterprise";
    } else {
        rgrgpwszSubst[7][REPLACEMENT]=L"Enterprise";
        rgrgpwszSubst[8][REPLACEMENT]=L"StandAlone";
    }

    //   %9 - XEnroll version
    wcscpy(wszTargetFileName, pComp->pwszSystem32);
    wcscat(wszTargetFileName, wszXEnrollDllFileForVer);
    hr=GetFileWebVersionString(wszTargetFileName, &pwszTempB);
    _JumpIfError(hr, error, "GetFileWebVersionString");
    rgrgpwszSubst[9][REPLACEMENT]=pwszTempB;

    //   %A - ScrdEnrl version
    wcscpy(wszTargetFileName, pComp->pwszSystem32);
    wcscat(wszTargetFileName, wszScrdEnrlDllFileForVer);
    hr=GetFileWebVersionString(wszTargetFileName, &pwszTempC);
    _JumpIfError(hr, error, "GetFileWebVersionString");
    rgrgpwszSubst[10][REPLACEMENT]=pwszTempC;

    //   %C - W2K ScrdEnrl version
    wcscpy(wszTargetFileName, pComp->pwszSystem32);
    wcscat(wszTargetFileName, wszScrdW2KDllFileForVer);
    hr=GetFileWebVersionString(wszTargetFileName, &pwszTempF);
    _JumpIfError(hr, error, "GetFileWebVersionString");
    rgrgpwszSubst[12][REPLACEMENT]=pwszTempF;
    
    // do the replacements
    pwszTempA=MultiStringReplace(pwszCWDat, rgrgpwszSubst, ARRAYSIZE(rgrgpwszSubst));
    _JumpIfOutOfMemory(hr, error, pwszTempA);

    // write the text
    hr=WriteString(hTarget, pwszTempA);
    _JumpIfError(hr, error, "WriteString");

    // all done
error:
    if (INVALID_HANDLE_VALUE!=hTarget) {
        CloseHandle(hTarget);
    }
    if (NULL!=pwszTempA) {
        LocalFree(pwszTempA);
    }
    if (NULL!=pwszTempB) {
        LocalFree(pwszTempB);
    }
    if (NULL!=pwszTempC) {
        LocalFree(pwszTempC);
    }
    if (NULL!=pwszTempD) {
        LocalFree(pwszTempD);
    }
    if (NULL!=pwszTempE) {
        LocalFree(pwszTempE);
    }
    if (NULL!=pwszTempF) {
        LocalFree(pwszTempF);
    }
    return hr;
}


HRESULT
CreateConfigFiles(
    WCHAR *pwszDirectoryPath,
    PER_COMPONENT_DATA *pComp,
    BOOL fRemove)
{
    WCHAR wszpathConfig[MAX_PATH];
    HANDLE hConfigFile;
    DISPATCHINTERFACE di;
    ICertConfig *pConfig = NULL;
    BOOL fMustRelease = FALSE;
    HRESULT hr = S_OK;
    
    hr = DispatchSetup(
		DISPSETUP_COM,
		CLSCTX_INPROC_SERVER,
		wszCLASS_CERTCONFIG,
		&CLSID_CCertConfig, 
		&IID_ICertConfig, 
		0,		// cDispatch
		NULL,           // pDispatchTable
		&di);
    if (S_OK != hr)
    {
        pComp->iErrMsg = IDS_ERR_LOADICERTCONFIG;
        _JumpError(hr, error, "DispatchSetup");
    }
    fMustRelease = TRUE;
    pConfig = (ICertConfig *) di.pUnknown;
    
    if (wcslen(pwszDirectoryPath) +
	wcslen(g_szSlashCertSrvDotTmp) >= ARRAYSIZE(wszpathConfig))
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpErrorStr(hr, error, "wszpathConfig", pwszDirectoryPath);
    }
    wcscpy(wszpathConfig, pwszDirectoryPath);
    wcscat(wszpathConfig, g_szSlashCertSrvDotTmp);
    
    hConfigFile = CreateFile(
            wszpathConfig, 
            GENERIC_WRITE, 
            0,
            NULL,
            CREATE_ALWAYS,
            0,
            0);
    if (INVALID_HANDLE_VALUE == hConfigFile)
    {
        hr = HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
        _JumpErrorStr2(
		hr,
		error,
		"CreateFile",
		wszpathConfig,
		fRemove? hr : S_OK);
    }
    
    if (!fRemove)
    {
        // if installing, write our config entry first
        hr = WriteNewConfigEntry(hConfigFile, pComp);
        _PrintIfError(hr, "WriteNewConfigEntry");
    }
    
    if (S_OK == hr)
    {
        hr = WriteFilteredConfigEntries(
            hConfigFile,
            pConfig,
            pComp);
        _PrintIfError2(hr, "WriteFilteredConfigEntries", S_FALSE);
    }
    
    // must close here because the following call will move it
    if (NULL != hConfigFile)
    {
        CloseHandle(hConfigFile);
    }
    
    hr = CertReplaceFile(
		wszpathConfig,
		g_szCertSrvDotTxt,
		g_szCertSrvDotBak);
    _JumpIfErrorStr(hr, error, "CertReplaceFile", g_szCertSrvDotTxt);
    
    hr = S_OK;
    
error:
    if (S_OK != hr && 0 == pComp->iErrMsg)
    {
        pComp->iErrMsg = IDS_ERR_WRITECONFIGFILE;
    }
    if (fMustRelease)
    {
        Config_Release(&di);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\nsrevchk\nsrevchk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       nsrevchk.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>

extern "C" void __cdecl
wmain(
    int argc,
    WCHAR *argv[])
{
    char status[2];
    unsigned long bytesRead;
    HANDLE df;
    BOOL ret;

    if (argc != 2)
    {
        MessageBox(0, L"Usage: nsrevchk filename", L"Error", MB_OK);
        exit(-1);
    }

    df = CreateFile(
		argv[1],
		GENERIC_READ,
		FILE_SHARE_READ,
		0,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		0);
    if (INVALID_HANDLE_VALUE == df)
    {
	MessageBox(0, L"Unable to open file", L"Error", MB_OK);
	exit(-1);
    }

    ret = ReadFile(df, &status, 2, &bytesRead, 0);
    if (!ret)
    {
	MessageBox(0, L"Unable to read from file", L"Error", MB_OK);
	exit(-1);
    }

    if (bytesRead != 1)
    {
	MessageBox(0, L"Invalid file format", L"Error", MB_OK);
	exit(-1);
    }

    if (status[0] == '1')
    {
	MessageBox(0, L"Cert is Invalid", L"Certificate Status", MB_OK);
    }
    else if (status[0] == '0')
    {
	MessageBox(0, L"Cert is Valid", L"Certificate Status", MB_OK);
    }
    else
    {
	MessageBox(0, L"Unknown Certificate Status", L"Error", MB_OK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\csocm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       csocm.cpp
//
//  Contents:   OCM component DLL for running the Certificate
//              Server setup.
//
//  Functions:
//
//  History:    12/13/96        TedM    Created Original Version
//              04/07/97        JerryK  Rewrite for Cert Server
//              04/??/97        JerryK  Stopped updating these comments since
//                                      every other line changes every day.
//          08/98       XTan    Major structure change
//
//  Notes:
//
//      This sample OCM component DLL can be the component DLL
//      for multiple components.  It assumes that a companion sample INF
//      is being used as the per-component INF, with private data in the 
//      following form.
//
//      [<pwszComponent>,<pwszSubComponent>]
//      Bitmap = <bitmapresourcename>
//      VerifySelect = 0/1
//      VerifyDeselect = 0/1
//      ;
//      ; follow this with install stuff such as CopyFiles= sections, etc.
//
//------------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <common.ver>
#include "msg.h"
#include "certmsg.h"
#include "setuput.h"
#include "setupids.h"
#include "clibres.h"
#include "csresstr.h"

// defines
#define cwcMESSAGETEXT    250
#define cwcINFVALUE       250
#define wszSMALLICON      L"_SmallIcon"
#define wszUNINSTALL      L"_Uninstall"
#define wszUPGRADE        L"_Upgrade"
#define wszINSTALL        L"_Install"
#define wszVERIFYSELECT   L"_VerifySelect"
#define wszVERIFYDESELECT L"_VerifyDeselect"

#define wszCONFIGTITLE       L"Title"
#define wszCONFIGCOMMAND     L"ConfigCommand"
#define wszCONFIGARGS        L"ConfigArgs"
#define wszCONFIGTITLEVAL    L"Certificate Services"
#define wszCONFIGCOMMANDVAL  L"sysocmgr.exe"
#define wszCONFIGARGSVAL     L"/i:certmast.inf /x"

#define __dwFILE__	__dwFILE_OCMSETUP_CSOCM_CPP__


// globals
PER_COMPONENT_DATA g_Comp;              // Top Level component
HINSTANCE g_hInstance; // get rid of it????

// find out if certsrv post setup is finished by checking
// registry entries. ie. finish CYS?
HRESULT
CheckPostBaseInstallStatus(
    OUT BOOL *pfFinished)
{
    HRESULT hr;
    HKEY    hKey = NULL;
    DWORD   dwSize = 0;
    DWORD   dwType = REG_NONE;

    //init
    *pfFinished = TRUE;

    if (ERROR_SUCCESS ==  RegOpenKeyEx(
                              HKEY_LOCAL_MACHINE,
                              wszREGKEYCERTSRVTODOLIST,
                              0,
                              KEY_READ,
                              &hKey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(
                                 hKey,
                                 wszCONFIGCOMMAND,
                                 NULL,
                                 &dwType,
                                 NULL, // only query size
                                 &dwSize) &&
            REG_SZ == dwType)
        {
            dwType = REG_NONE;
            if (ERROR_SUCCESS == RegQueryValueEx(
                                     hKey,
                                     wszCONFIGARGS,
                                     NULL,
                                     &dwType,
                                     NULL, // only query size
                                     &dwSize) &&
                REG_SZ == dwType)
            {
                dwType = REG_NONE;
                if (ERROR_SUCCESS == RegQueryValueEx(
                                         hKey,
                                         wszCONFIGTITLE,
                                         NULL,
                                         &dwType,
                                         NULL, // only query size
                                         &dwSize) &&
                    REG_SZ == dwType)
                {
                    //all entries exist
                    *pfFinished = FALSE;
                }
            }
        }
    }

    hr = S_OK;
//error:
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return hr;
}


HRESULT
InitComponentAttributes(
    IN OUT PER_COMPONENT_DATA *pComp,
    IN     HINSTANCE           hDllHandle)
{
    HRESULT hr;

    ZeroMemory(pComp, sizeof(PER_COMPONENT_DATA));
    pComp->hInstance = hDllHandle;
    g_hInstance = hDllHandle; //get rid of it????
    pComp->hrContinue = S_OK;
    pComp->pwszCustomMessage = NULL;
    pComp->fUnattended = FALSE;
    pComp->pwszUnattendedFile = NULL;
    pComp->pwszServerName = NULL;
    pComp->pwszServerNameOld = NULL;
    pComp->dwInstallStatus = 0x0;
    pComp->fPostBase = FALSE;
    (pComp->CA).pServer = NULL;
    (pComp->CA).pClient = NULL;
    pComp->hinfCAPolicy = INVALID_HANDLE_VALUE;
    hr = S_OK;

//error:
    return hr;
}


//+------------------------------------------------------------------------
//
//  Function:   DllMain( . . . . )
//
//  Synopsis:   DLL Entry Point.
//
//  Arguments:  [DllHandle]     DLL module handle.
//              [Reason]        Reasons for entry into DLL.
//              [Reserved]      Reserved.
//
//  Returns:    BOOL
//
//  History:    04/07/97        JerryK  Created (again)
// 
//-------------------------------------------------------------------------
BOOL WINAPI
DllMain(
    IN HMODULE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved)
{
    BOOL b;

    UNREFERENCED_PARAMETER(Reserved);

    b = TRUE;
    switch(Reason) 
    {
        case DLL_PROCESS_ATTACH:
            DBGPRINT((DBG_SS_CERTOCMI, "Process Attach\n"));
            // component initialization
            InitComponentAttributes(&g_Comp, DllHandle);

            // Fall through to process first thread

        case DLL_THREAD_ATTACH:
            b = TRUE;
            break;

        case DLL_PROCESS_DETACH:
            DBGPRINT((DBG_SS_CERTOCMI, "Process Detach\n"));

            if(INVALID_HANDLE_VALUE != g_Comp.hinfCAPolicy)
                myInfCloseFile(g_Comp.hinfCAPolicy);

	    myInfClearError();
            myFreeResourceStrings("certocm.dll");
            myFreeColumnDisplayNames();
            myRegisterMemDump();
            csiLogClose();
            break;

        case DLL_THREAD_DETACH:
            break;
    }
    return b;
}

extern UNATTENDPARM aUnattendParmClient[];
extern UNATTENDPARM aUnattendParmServer[];

SUBCOMP g_aSubComp[] =
{
    {
        L"certsrv",             // pwszSubComponent
        cscTopLevel,            // cscSubComponent
        0,                      // InstallFlags
        0,                      // UninstallFlags
        0,                      // ChangeFlags
        0,                      // UpgradeFlags
        0,                      // EnabledFlags
        0,                      // SetupStatusFlags
        FALSE,                  // fDefaultInstallUnattend
        FALSE,                  // fInstallUnattend
        NULL                    // aUnattendParm
    },
    {
        wszSERVERSECTION,       // pwszSubComponent
        cscServer,              // cscSubComponent
        IS_SERVER_INSTALL,      // InstallFlags
        IS_SERVER_REMOVE,       // UninstallFlags
        IS_SERVER_CHANGE,       // ChangeFlags
        IS_SERVER_UPGRADE,	// UpgradeFlags
        IS_SERVER_ENABLED,	// EnabledFlags
	SETUP_SERVER_FLAG,	// SetupStatusFlags
        TRUE,                   // fDefaultInstallUnattend
        FALSE,                  // fInstallUnattend
        aUnattendParmServer     // aUnattendParm
    },
    {
        wszCLIENTSECTION,       // pwszSubComponent
        cscClient,              // cscSubComponent
        IS_CLIENT_INSTALL,      // InstallFlags
        IS_CLIENT_REMOVE,       // UninstallFlags
        IS_CLIENT_CHANGE,       // ChangeFlags
        IS_CLIENT_UPGRADE,	// UpgradeFlags
        IS_CLIENT_ENABLED,	// EnabledFlags
	SETUP_CLIENT_FLAG,	// SetupStatusFlags
        TRUE,                   // fDefaultInstallUnattend
        FALSE,                  // fInstallUnattend
        aUnattendParmClient     // aUnattendParm
    },
    {
        NULL,                   // pwszSubComponent
    }
};


SUBCOMP *
TranslateSubComponent(
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent)
{
    SUBCOMP *psc;

    if (NULL == pwszSubComponent)
    {
        pwszSubComponent = pwszComponent;
    }
    for (psc = g_aSubComp; NULL != psc->pwszSubComponent; psc++)
    {
        if (0 == mylstrcmpiL(psc->pwszSubComponent, pwszSubComponent)) 
        {
            break;
        }
    }
    if (NULL == psc->pwszSubComponent)
    {
        psc = NULL;
    }
    return(psc);
}


SUBCOMP const *
LookupSubComponent(
    IN CertSubComponent SubComp)
{
    SUBCOMP const *psc;

    for (psc = g_aSubComp; NULL != psc->pwszSubComponent; psc++)
    {
        if (psc->cscSubComponent == SubComp)
        {
            break;
        }
    }
    CSASSERT(NULL != psc);
    return(psc);
}


BOOL fDebugSupress = TRUE;

HRESULT
UpdateSubComponentInstallStatus(
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    BOOL fWasEnabled;
    BOOL fIsEnabled;
    DWORD InstallFlags;
    SUBCOMP const *psc;

    psc = TranslateSubComponent(pwszComponent, pwszSubComponent);
    if (NULL == psc)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal error: unsupported component");
    }

    fWasEnabled = certocmWasEnabled(pComp, psc->cscSubComponent);
    fIsEnabled = certocmIsEnabled(pComp, psc->cscSubComponent);
    CSILOGDWORD(IDS_LOG_WAS_ENABLED, fWasEnabled);
    CSILOGDWORD(IDS_LOG_IS_ENABLED, fIsEnabled);

    InstallFlags = psc->InstallFlags | psc->ChangeFlags | psc->EnabledFlags;
    if (!fWasEnabled)
    {
	if (fIsEnabled)
        {
	    // install case
	    pComp->dwInstallStatus |= InstallFlags;
        }
        else // !fIsEnabled
        {
	    // this is from check then uncheck, should remove the bit
	    // turn off both bits

	    pComp->dwInstallStatus &= ~InstallFlags;
        }
    }
    else // fWasEnabled
    {
        if (pComp->fPostBase &&
            (pComp->Flags & SETUPOP_STANDALONE) )
        {
            // was installed, invoke from post setup
            // this is install case

            pComp->dwInstallStatus |= InstallFlags;
        }
        else if (pComp->Flags & SETUPOP_NTUPGRADE)
        {
            // if was installed and now in upgrade mode, upgrade case

            pComp->dwInstallStatus |= psc->UpgradeFlags | psc->EnabledFlags;
        }
        else if (!fIsEnabled)
        {
            // uninstall case

	    pComp->dwInstallStatus &= ~psc->EnabledFlags;
            pComp->dwInstallStatus |= psc->UninstallFlags | psc->ChangeFlags;
        }
        else // fIsEnabled
        {
	    pComp->dwInstallStatus |= psc->EnabledFlags;
#if DBG_CERTSRV
            BOOL fUpgrade = FALSE;

            hr = myGetCertRegDWValue(
                            NULL,
                            NULL,
                            NULL,
                            L"EnforceUpgrade",
                            (DWORD *) &fUpgrade);
            if (S_OK == hr && fUpgrade)
            {
		pComp->dwInstallStatus |= psc->UpgradeFlags;
            }
#endif //DBG_CERTSRV
	}   // end fIsEnabled else
    } // end fWasEnabled else


    // after all of this, change upgrade->uninstall if not supported
    // detect illegal upgrade
    if (pComp->dwInstallStatus & IS_SERVER_UPGRADE)
    {
        hr = DetermineServerUpgradePath(pComp);
        _JumpIfError(hr, error, "DetermineServerUpgradePath");
    }
    else if (pComp->dwInstallStatus & IS_CLIENT_UPGRADE)
    {
        hr = DetermineClientUpgradePath(pComp);
        _JumpIfError(hr, error, "LoadAndDetermineClientUpgradeInfo");
    }
    if ((pComp->dwInstallStatus & IS_SERVER_UPGRADE) ||
        (pComp->dwInstallStatus & IS_CLIENT_UPGRADE))
    {
        CSASSERT(pComp->UpgradeFlag != CS_UPGRADE_UNKNOWN);
        if (CS_UPGRADE_UNSUPPORTED == pComp->UpgradeFlag)
        {
            pComp->dwInstallStatus &= ~InstallFlags;
            pComp->dwInstallStatus |= psc->UninstallFlags | psc->ChangeFlags;
        }
    }



    CSILOG(
	S_OK,
	IDS_LOG_INSTALL_STATE,
	pwszSubComponent,
	NULL,
	&pComp->dwInstallStatus);
    hr = S_OK;

error:
    return hr;
}


HRESULT
certocmOcPreInitialize(
    IN WCHAR const *DBGPARMREFERENCED(pwszComponent),
    IN UINT Flags,
    OUT ULONG_PTR *pulpRet)
{
    HRESULT hr;

    *pulpRet = 0;

    DBGPRINT((DBG_SS_CERTOCMI, "OC_PREINITIALIZE(%ws, %x)\n", pwszComponent, Flags));

    myVerifyResourceStrings(g_hInstance);

    // Return value is flag telling OCM which char width we want to run in.

#ifdef UNICODE
    *pulpRet = OCFLAG_UNICODE & Flags;
#else
    *pulpRet = OCFLAG_ANSI & Flags;
#endif

    hr = S_OK;
//error:
    return hr;
}


// Allocate and initialize a new component.
//
// Return code is Win32 error indicating outcome.  ERROR_CANCELLED tells OCM to
// cancel the installation.

HRESULT
certocmOcInitComponent(
    IN HWND                      hwnd,
    IN WCHAR const              *pwszComponent,
    IN OUT SETUP_INIT_COMPONENT *pInitComponent,
    IN OUT PER_COMPONENT_DATA   *pComp,
    OUT ULONG_PTR               *pulpRet)
{
    HRESULT hr;
    BOOL fCoInit = FALSE;
    HKEY hkey = NULL;
    WCHAR awc[30];
    WCHAR *pwc;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_INIT_COMPONENT(%ws, %p)\n",
            pwszComponent,
            pInitComponent));

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;
    *pulpRet = ERROR_CANCELLED;

    if (OCMANAGER_VERSION <= pInitComponent->OCManagerVersion)
    {
        pInitComponent->OCManagerVersion = OCMANAGER_VERSION;
    }

    // Allocate a new component string.
    pComp->pwszComponent = (WCHAR *) LocalAlloc(LPTR,
                        (wcslen(pwszComponent) + 1) * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pComp->pwszComponent);

    wcscpy(pComp->pwszComponent, pwszComponent);

    // OCM passes in some information that we want to save, like the open
    // handle to our per-component INF.  As long as we have a per-component INF,
    // append-open any layout file that is associated with it, in preparation
    // for later inf-based file queueing operations.
    //
    // We save away certain other stuff that gets passed to us now, since OCM
    // doesn't guarantee that the SETUP_INIT_COMPONENT will persist beyond the
    // processing of this one interface routine.

    if (INVALID_HANDLE_VALUE != pInitComponent->ComponentInfHandle &&
        NULL != pInitComponent->ComponentInfHandle)
    {
        pComp->MyInfHandle = pInitComponent->ComponentInfHandle;
    }
    else
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "invalid inf handle");
    }

    if (NULL != pComp->MyInfHandle)
    {
        if (!SetupOpenAppendInfFile(NULL, pComp->MyInfHandle, NULL))
        {
            // SetupOpenAppendInfFile:
            // If Filename (Param1) is NULL, the INF filename is 
            // retrieved from the LayoutFile value of the Version 
            // section in the existing INF file.
            //
            // If FileName was not specified and there was no 
            // LayoutFile value in the Version section of the 
            // existing INF File, GetLastError returns ERROR_INVALID_DATA.

            hr = myHLastError();
            _PrintErrorStr(hr, "SetupOpenAppendInfFile", pwszComponent);
        }
    }


    pComp->HelperRoutines = pInitComponent->HelperRoutines;

    pComp->Flags = pInitComponent->SetupData.OperationFlags;

    pwc = awc;
    pwc += wsprintf(pwc, L"0x");
    if (0 != (DWORD) (pComp->Flags >> 32))
    {
	pwc += wsprintf(pwc, L"%x:", (DWORD) (pComp->Flags >> 32));
    }
    wsprintf(pwc, L"%08x", (DWORD) pComp->Flags);
    CSILOG(S_OK, IDS_LOG_OPERATIONFLAGS, awc, NULL, NULL);
    CSILOGDWORD(IDS_LOG_POSTBASE, pComp->fPostBase);

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, wszREGKEYOCMSUBCOMPONENTS, &hkey);
    if (S_OK == hr)
    {
	DWORD dwType;
	DWORD dwValue;
	DWORD cb;
	DWORD const *pdw;
	
	cb = sizeof(dwValue);
	hr = RegQueryValueEx(
		        hkey,
		        wszSERVERSECTION,
		        0,
		        &dwType,
		        (BYTE *) &dwValue,
		        &cb);
	pdw = NULL;
	if (S_OK == hr && REG_DWORD == dwType && sizeof(dwValue) == cb)
	{
	    pdw = &dwValue;
	}
	CSILOG(hr, IDS_LOG_REGSTATE, wszSERVERSECTION, NULL, pdw);
	
	cb = sizeof(dwValue);
	hr = RegQueryValueEx(
		        hkey,
		        wszCLIENTSECTION,
		        0,
		        &dwType,
		        (BYTE *) &dwValue,
		        &cb);
	pdw = NULL;
	if (S_OK == hr && REG_DWORD == dwType && sizeof(dwValue) == cb)
	{
	    pdw = &dwValue;
	}
	CSILOG(hr, IDS_LOG_REGSTATE, wszCLIENTSECTION, NULL, pdw);
	
	cb = sizeof(dwValue);
	hr = RegQueryValueEx(
		        hkey,
			wszOLDDOCCOMPONENT,
		        0,
		        &dwType,
		        (BYTE *) &dwValue,
		        &cb);
	pdw = NULL;
	if (S_OK == hr && REG_DWORD == dwType && sizeof(dwValue) == cb)
	{
	    CSILOG(hr, IDS_LOG_REGSTATE, wszOLDDOCCOMPONENT, NULL, &dwValue);
	}
    }

    pComp->fUnattended = (pComp->Flags & SETUPOP_BATCH)? TRUE : FALSE;
    CSILOG(
	S_OK,
	IDS_LOG_UNATTENDED,
	pComp->fUnattended? pInitComponent->SetupData.UnattendFile : NULL,
	NULL,
	(DWORD const *) &pComp->fUnattended);

    if (pComp->fUnattended)
    {
        pComp->pwszUnattendedFile = (WCHAR *) LocalAlloc(
                        LMEM_FIXED,
                        (wcslen(pInitComponent->SetupData.UnattendFile) + 1) *
                            sizeof(WCHAR));
        _JumpIfOutOfMemory(hr, error, pComp->pwszUnattendedFile);

        wcscpy(
            pComp->pwszUnattendedFile,
            pInitComponent->SetupData.UnattendFile);
    }

    // initialize ca setup data
    hr = InitCASetup(hwnd, pComp);
    _JumpIfError(hr, error, "InitCASetup");


    hr = S_OK;
    *pulpRet = NO_ERROR;

error:
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return(hr);
}


HRESULT
certocmReadInfString(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszName,
    IN OUT WCHAR **ppwszValue)
{
    INFCONTEXT InfContext;
    HRESULT hr;
    WCHAR wszBuffer[cwcINFVALUE];
    WCHAR *pwsz;

    if (NULL != *ppwszValue)
    {
        // free old
        LocalFree(*ppwszValue);
        *ppwszValue = NULL;
    }

    if (!SetupFindFirstLine(hInf, pwszSection, pwszName, &InfContext))
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "SetupFindFirstLine", pwszSection);
    }
    
    if (!SetupGetStringField(
                        &InfContext,
                        1,
                        wszBuffer,
                        sizeof(wszBuffer)/sizeof(wszBuffer[0]),
                        NULL))
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "SetupGetStringField", pwszName);
    }

    pwsz = (WCHAR *) LocalAlloc(
                        LMEM_FIXED, 
                        (wcslen(wszBuffer) + 1) * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pwsz);

    wcscpy(pwsz, wszBuffer);
    *ppwszValue = pwsz;

    hr = S_OK;
error:
    return(hr);
}


HRESULT
certocmReadInfInteger(
    IN HINF hInf,
    OPTIONAL IN WCHAR const *DBGPARMREFERENCED(pwszFile),
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszName,
    OUT INT *pValue)
{
    INFCONTEXT InfContext;
    HRESULT hr = S_OK;

    *pValue = 0;
    if (!SetupFindFirstLine(hInf, pwszSection, pwszName, &InfContext))
    {
        hr = myHLastError();
        DBGPRINT((
            DBG_SS_CERTOCMI, 
            __FILE__ "(%u): %ws%wsSetupFindFirstLine([%ws] %ws) failed! -> %x\n",
            __LINE__,
            NULL != pwszFile? pwszFile : L"",
            NULL != pwszFile? L": " : L"",
            pwszSection,
            pwszName,
            hr));
        goto error;
    }

    if (!SetupGetIntField(&InfContext, 1, pValue))
    {
        hr = myHLastError();
        DBGPRINT((
            DBG_SS_CERTOCM,
            __FILE__ "(%u): %ws%wsSetupGetIntField([%ws] %ws) failed! -> %x\n",
            __LINE__,
            NULL != pwszFile? pwszFile : L"",
            NULL != pwszFile? L": " : L"",
            pwszSection,
            pwszName,
            hr));
        goto error;
    }
    
    DBGPRINT((
        DBG_SS_CERTOCMI,
        "%ws%ws[%ws] %ws = %u\n",
        NULL != pwszFile? pwszFile : L"",
        NULL != pwszFile? L": " : L"",
        pwszSection,
        pwszName,
        *pValue));
    
error:
    return(hr);
}


// Return the GDI handle of a small bitmap to be used.  NULL means an error
// occurred -- OCM will use a default bitmap.
//
// Demonstrates use of private data in a per-component inf.  We will look in
// our per-component inf to determine the resource name for the bitmap for this
// component, and then go fetch it from the resources.
//
// Other possibilities would be to simply return the same hbitmap for all
// cases, or to return NULL, in which case OCM uses a default.  Note that we
// ignore the requested width and height and our bitmaps are not language
// dependent.

HRESULT
certocmOcQueryImage(
    IN WCHAR const *DBGPARMREFERENCED(pwszComponent),
    OPTIONAL IN WCHAR const *DBGPARMREFERENCED(pwszSubComponent),
    IN SubComponentInfo wSubComp,
    IN UINT DBGPARMREFERENCED(wWidth),
    IN UINT DBGPARMREFERENCED(wHeight),
    IN OUT PER_COMPONENT_DATA *pComp,
    OUT HBITMAP *pulpRet)
{
    HBITMAP hRet = NULL;
    HRESULT hr;

    DBGPRINT((
        DBG_SS_CERTOCMI,
        "OC_QUERY_IMAGE(%ws, %ws, %hx, %x, %x)\n",
        pwszComponent,
        pwszSubComponent,
        wSubComp,
        wWidth,
        wHeight));

    if (SubCompInfoSmallIcon != wSubComp)
    {
        goto done;
    }

    hRet = LoadBitmap(pComp->hInstance, MAKEINTRESOURCE(IDB_APP));
    if (NULL == hRet)
    {
        hr = myHLastError();
        _JumpError(hr, error, "LoadBitmap");
    }

done:
    hr = S_OK;

error:
    *pulpRet = hRet;
    return hr;
}


// Return the number of wizard pages the current component places in the
// SETUP_REQUEST_PAGES structure.

HRESULT
certocmOcRequestPages(
    IN WCHAR const *DBGPARMREFERENCED(pwszComponent),
    IN WizardPagesType WizPagesType,
    IN OUT SETUP_REQUEST_PAGES *pRequestPages,
    IN PER_COMPONENT_DATA *pComp,
    OUT ULONG_PTR *pulpRet)
{
    HRESULT  hr;

    *pulpRet = 0;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_REQUEST_PAGES(%ws, %x, %p)\n",
            pwszComponent,
            WizPagesType,
            pRequestPages));

    // don't invoke wiz apge if unattended
    // or if running from base setup/upgrade setup
    if ((!pComp->fUnattended) && (SETUPOP_STANDALONE & pComp->Flags))
    {
        *pulpRet = myDoPageRequest(pComp,
                      WizPagesType, pRequestPages);
    }
    else
    {
            DBGPRINT((
                DBG_SS_CERTOCMI,
		"Not adding wizard pages, %ws\n",
		pComp->fUnattended? L"Unattended" : L"GUI Setup"));

    }
    hr = S_OK;
//error:
    return hr;
}


HRESULT
IsIA5DnsMachineName()
{
    WCHAR *pwszDnsName = NULL;
    CRL_DIST_POINTS_INFO CRLDistInfo;
    CRL_DIST_POINT       DistPoint;
    CERT_ALT_NAME_ENTRY  AltNameEntry;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    static HRESULT s_hr = S_FALSE;

    if (S_FALSE != s_hr)
    {
	goto error;
    }
    s_hr = myGetMachineDnsName(&pwszDnsName);
    _JumpIfError(s_hr, error, "myGetMachineDnsName");

    CRLDistInfo.cDistPoint = 1;
    CRLDistInfo.rgDistPoint = &DistPoint;

    ZeroMemory(&DistPoint, sizeof(DistPoint));
    DistPoint.DistPointName.dwDistPointNameChoice = CRL_DIST_POINT_FULL_NAME;
    DistPoint.DistPointName.FullName.cAltEntry = 1;
    DistPoint.DistPointName.FullName.rgAltEntry = &AltNameEntry;

    ZeroMemory(&AltNameEntry, sizeof(AltNameEntry));
    AltNameEntry.dwAltNameChoice = CERT_ALT_NAME_URL;
    AltNameEntry.pwszURL = pwszDnsName;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CRL_DIST_POINTS,
		    &CRLDistInfo,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbEncoded,
		    &cbEncoded))
    {
	s_hr = myHLastError();
	_JumpIfError(s_hr, error, "myEncodeObject");
    }
    CSASSERT(S_OK == s_hr);

error:
    if (NULL != pwszDnsName)
    {
        LocalFree(pwszDnsName);
    }
    if (NULL != pbEncoded)
    {
        LocalFree(pbEncoded);
    }
    return(s_hr);
}


// Return boolean to indicate whether to allow selection state change.  As
// demonstrated, again we'll go out to our per-component inf to see whether it
// wants us to validate.  Note that unattended mode must be respected.

HRESULT
certocmOcQueryChangeSelState(
    HWND            hwnd,
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent,
    IN BOOL fSelectedNew,
    IN DWORD Flags,
    IN OUT PER_COMPONENT_DATA *pComp,
    OUT ULONG_PTR *pulpRet)
{
    INT fVerify;
    TCHAR wszText[cwcMESSAGETEXT];
    const WCHAR* Args[2]; 
    SUBCOMP const *psc;
    HRESULT hr;
    WCHAR awc[cwcDWORDSPRINTF];
    WCHAR awc2[cwcDWORDSPRINTF];
    DWORD fRet;
    BOOL  fServerWasInstalled;
    BOOL  fWebClientWasInstalled;
    int iMsg = 0;
    static BOOL s_fWarned = FALSE;

    *pulpRet = FALSE;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_QUERY_CHANGE_SEL_STATE(%ws, %ws, %x, %x)\n",
            pwszComponent,
            pwszSubComponent,
            fSelectedNew,
            Flags));

    // disallow some selection changes
    fServerWasInstalled = certocmWasEnabled(pComp, cscServer);
    fWebClientWasInstalled = certocmWasEnabled(pComp, cscClient);

    if (fWebClientWasInstalled &&
        (OCQ_ACTUAL_SELECTION & Flags))
    {
        if (fSelectedNew)
        {
            // check
            if (!fServerWasInstalled &&
                (0 == LSTRCMPIS(pwszSubComponent, wszSERVERSECTION) ||
                 0 == LSTRCMPIS(pwszSubComponent, wszCERTSRVSECTION)) )
            {
                // case: web client installed and try install server
                iMsg = IDS_WRN_UNINSTALL_CLIENT;
            }
            if (fServerWasInstalled &&
                0 == LSTRCMPIS(pwszSubComponent, wszCLIENTSECTION))
            {
                // case: uncheck both then check web client
                iMsg = IDS_WRN_UNINSTALL_BOTH;
            }
        }
        else
        {
            // uncheck
            if (fServerWasInstalled &&
                0 == LSTRCMPIS(pwszSubComponent, wszSERVERSECTION))
            {
                // case: full certsrv installed and try leave only web client
                iMsg = IDS_WRN_UNINSTALL_BOTH;
            }
        }
    }

    // not a server sku
    if (!FIsServer())
    {
        iMsg = IDS_WRN_SERVER_ONLY;
    }

    if (0 != iMsg)
    {
        CertWarningMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hwnd,
                iMsg,
                0,
                NULL);
        goto done;
    }

    if (fSelectedNew)
    {
	hr = IsIA5DnsMachineName();
	if (S_OK != hr)
	{
	    CertMessageBox(
		    pComp->hInstance,
		    pComp->fUnattended,
		    hwnd,
		    IDS_ERR_NONIA5DNSNAME,
		    hr,
		    MB_OK | MB_ICONERROR,
		    NULL);
	    goto done;
	}
	if ((OCQ_ACTUAL_SELECTION & Flags) &&
	    0 != LSTRCMPIS(pwszSubComponent, wszCLIENTSECTION))
	{
	    if (!s_fWarned)
	    {
		DWORD dwSetupStatus;

		hr = GetSetupStatus(NULL, &dwSetupStatus);
		if (S_OK == hr)
		{
		    if ((SETUP_CLIENT_FLAG | SETUP_SERVER_FLAG) & dwSetupStatus)
		    {
			s_fWarned = TRUE;
		    }
		    CSILOG(
			hr,
			IDS_LOG_QUERYCHANGESELSTATE,
			NULL,
			NULL,
			&dwSetupStatus);
		}
	    }
	    if (!s_fWarned)
	    {
		if (IDYES != CertMessageBox(
				pComp->hInstance,
				pComp->fUnattended,
				hwnd,
				IDS_WRN_NONAMECHANGE,
				S_OK,
				MB_YESNO | MB_ICONWARNING  | CMB_NOERRFROMSYS,
				NULL))
		{
		    goto done;
		}
		s_fWarned = TRUE;
	    }
	}
    }

    *pulpRet = TRUE;

    if (pComp->fUnattended)
    {
        goto done;
    }

    psc = TranslateSubComponent(pwszComponent, pwszSubComponent);
    if (NULL == psc)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal error: unsupported component");
    }

    hr = certocmReadInfInteger(
                    pComp->MyInfHandle,
                    NULL,
                    psc->pwszSubComponent,
                        fSelectedNew? wszVERIFYSELECT : wszVERIFYDESELECT,
                    &fVerify);
    if (S_OK != hr || !fVerify) 
    {
        goto done;
    }

    // Don't pass specific lang id to FormatMessage, as it fails if there's no
    // msg in that language.  Instead, set the thread locale, which will get
    // FormatMessage to use a search algorithm to find a message of the 
    // appropriate language, or use a reasonable fallback msg if there's none.

    Args[0] = pwszComponent;
    Args[1] = pwszSubComponent;

    FormatMessage(
              FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
              pComp->hInstance,
              fSelectedNew? MSG_SURE_SELECT : MSG_SURE_DESELECT,
              0,
              wszText,
              sizeof(wszText)/sizeof(wszText[0]),
              (va_list *) Args);

    *pulpRet = (IDYES == CertMessageBox(
                                pComp->hInstance,
                                pComp->fUnattended,
                                hwnd,
                                0,
                                S_OK,
                                MB_YESNO |
                                    MB_ICONWARNING |
                                    MB_TASKMODAL |
                                    CMB_NOERRFROMSYS,
                                wszText));

done:
    hr = S_OK;

error:
    wsprintf(awc, L"%u", fSelectedNew);
    wsprintf(awc2, L"0x%08x", Flags);
    fRet = (DWORD) *pulpRet;
    CSILOG(hr, IDS_LOG_QUERYCHANGESELSTATE, awc, awc2, &fRet);
    return hr;
}


// Calculate disk space for the component being added or removed.  Return a
// Win32 error code indicating outcome.  In our case the private section for
// this component/subcomponent pair is a simple standard inf install section,
// so we can use high-level disk space list API to do what we want.

HRESULT
certocmOcCalcDiskSpace(
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent,
    IN BOOL fAddComponent,
    IN HDSKSPC hDiskSpace,
    IN OUT PER_COMPONENT_DATA *pComp,
    OUT ULONG_PTR *pulpRet)
{
    HRESULT hr;
    WCHAR *pwsz = NULL;
    SUBCOMP const *psc;
    static fServerFirstCall = TRUE;
    static fClientFirstCall = TRUE;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_CALC_DISK_SPACE(%ws, %ws, %x, %p)\n",
            pwszComponent,
            pwszSubComponent,
            fAddComponent,
            hDiskSpace));

    psc = TranslateSubComponent(pwszComponent, pwszSubComponent);
    if (NULL == psc)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal error: unsupported component");
    }

    // Being installed or uninstalled.  Fetch INSTALL section name,
    // so we can add or remove the files being INSTALLed from the disk
    // space list.

    hr = certocmReadInfString(
                        pComp->MyInfHandle,
                        psc->pwszSubComponent,
                        wszINSTALL,
                        &pwsz);
    _JumpIfError(hr, error, "certocmReadInfString");

    if (fAddComponent)  // Adding
    {
        if (!SetupAddInstallSectionToDiskSpaceList(
                                        hDiskSpace,
                                        pComp->MyInfHandle,
                                        NULL,
                                        pwsz,
                                        0,
                                        0))
        {
            hr = myHLastError();
            _JumpErrorStr(hr, error, "SetupAddInstallSectionToDiskSpaceList", pwsz);
        }
    } 
    else                // Removing
    {
        if (!SetupRemoveInstallSectionFromDiskSpaceList(
                                        hDiskSpace,
                                        pComp->MyInfHandle,
                                        NULL,
                                        pwsz,
                                        0,
                                        0))
        {
            hr = myHLastError();
            _JumpErrorStr(hr, error, "SetupRemoveInstallSectionFromDiskSpaceList", pwsz);
        }
    }
    hr = S_OK;

error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    *pulpRet = hr;
    return(hr);
}


// OCM calls this routine when ready for files to be copied to effect the
// changes the user requested. The component DLL must figure out whether it is
// being installed or uninstalled and take appropriate action.  For this
// sample, we look in the private data section for this component/subcomponent
// pair, and get the name of an uninstall section for the uninstall case.
//
// Note that OCM calls us once for the *entire* component and then once per
// subcomponent.  We ignore the first call.
//
// Return value is Win32 error code indicating outcome.

HRESULT
certocmOcQueueFileOps(
    IN HWND         hwnd,
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent,
    IN HSPFILEQ hFileQueue,
    IN OUT PER_COMPONENT_DATA *pComp,
    OUT ULONG_PTR *pulpRet)
{
    HRESULT hr;
    SUBCOMP const *psc;
    BOOL fRemoveFile = FALSE;  // TRUE for uninstall; FALSE for install/upgrade
    WCHAR *pwszAction;
    WCHAR *pwsz = NULL;
    static BOOL s_fPreUninstall = FALSE; // preuninstall once

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_QUEUE_FILE_OPS(%ws, %ws, %p)\n",
            pwszComponent,
            pwszSubComponent,
            hFileQueue));

    if (NULL == pwszSubComponent)
    {
        // Do no work for top level component
        goto done;
    }

    psc = TranslateSubComponent(pwszComponent, pwszSubComponent);
    if (NULL == psc)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal error: unsupported component");
    }


    // if unattended, not upgrade, & not uninstall, load
    if (pComp->fUnattended && !(pComp->Flags & SETUPOP_NTUPGRADE) )
    {
        // retrieve unattended attributes
        hr = certocmRetrieveUnattendedText(
                 pwszComponent,
                 pwszSubComponent,
                 pComp);
        if (S_OK != hr && 0x0 != (pComp->Flags & SETUPOP_STANDALONE))
        {
            // only error out if it is from add/remove or post because
            // it could fail regular ntbase in unattended mode without certsrv
            _JumpError(hr, error, "certocmRetrieveUnattendedText");
        }

        // Init install status (must be done after retrieving unattended text)
        hr = UpdateSubComponentInstallStatus(pwszComponent,
                                             pwszSubComponent, 
                                             pComp);

        _JumpIfError(hr, error, "UpdateSubComponentInstallStatus");

        if (psc->fInstallUnattend) // make sure ON
        {
            if (certocmWasEnabled(pComp, psc->cscSubComponent) &&
                !pComp->fPostBase)
            {
                // the case to run install with component ON twice or more
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
                _JumpError(hr, error, "You must uninstall before install");
            }
            if (SETUPOP_STANDALONE & pComp->Flags)
            {
                // only prepare and validate unattende attr in standalone mode
                // in other word, don't call following if NT base
                hr = PrepareUnattendedAttributes(
                         hwnd,
                         pwszComponent,
                         pwszSubComponent,
                         pComp);
                _JumpIfError(hr, error, "PrepareUnattendedAttributes");
            }
        }
    }
    else
    {
        // Initialize the install status
        hr = UpdateSubComponentInstallStatus(pwszComponent,
                                             pwszSubComponent, 
                                             pComp);

        _JumpIfError(hr, error, "UpdateSubComponentInstallStatus");
    }


    // If we're not doing base setup or an upgrade, check to see if we already
    // copied files during base setup, by checking to see if base setup
    // left an entry in the ToDo List.
    if(pComp->fPostBase)
    {

            DBGPRINT((
                DBG_SS_CERTOCMI,
                "File Queueing Skipped, files already installed by GUI setup"));
        goto done;

    }

/*
    //--- Talk with OCM guys and put this functionality into a notification routine
    //--- This will allow us to pop compatibility error to user before unattended upgrade begins

    // detect illegal upgrade
    if (pComp->dwInstallStatus & IS_SERVER_UPGRADE)
    {
        hr = DetermineServerUpgradePath(pComp);
        _JumpIfError(hr, error, "DetermineServerUpgradePath");
    }
    else if (pComp->dwInstallStatus & IS_CLIENT_UPGRADE)
    {
        hr = DetermineClientUpgradePath(pComp);
        _JumpIfError(hr, error, "LoadAndDetermineClientUpgradeInfo");
    }
    if ((pComp->dwInstallStatus & IS_SERVER_UPGRADE) ||
        (pComp->dwInstallStatus & IS_CLIENT_UPGRADE))
    {
        // block if attempting upgrade that is not Win2K or Whistler
        // lodge a complaint in the log; upgrade all bits and 
        if ((CS_UPGRADE_NO != pComp->UpgradeFlag) && 
            (CS_UPGRADE_WHISTLER != pComp->UpgradeFlag) && 
            (CS_UPGRADE_WIN2000 != pComp->UpgradeFlag)) 
        {
            hr = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
            CertErrorMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hwnd,
                IDS_ERR_UPGRADE_NOT_SUPPORTED,
                hr,
                NULL);
//            _JumpError(hr, error, "Unsupported upgrade");
            // continue uninstall/reinstall
        }
    }
*/

    if ((pComp->dwInstallStatus & psc->ChangeFlags) ||
        (pComp->dwInstallStatus & psc->UpgradeFlags) )
    {

        // for ChangeFlags, either install or uninstall
        // all cases, copy file or remove file

        if (pComp->dwInstallStatus & psc->UninstallFlags)
        {
            fRemoveFile = TRUE;
        }

        // Uninstall the core if:
        // this subcomponent is being uninstalled, and
        // this is a core subcomponent (client or server), and
        // this is the server subcomponent, or the server isn't being removed or
        // upgrade

        if (((pComp->dwInstallStatus & psc->UninstallFlags) ||
             (pComp->dwInstallStatus & psc->UpgradeFlags) ) &&
            (cscServer == psc->cscSubComponent ||
             !(IS_SERVER_REMOVE & pComp->dwInstallStatus) ) )
        {
            // if fall into here, either need to overwrite or
            // delete certsrv files so unreg all related dlls

            if (cscServer == psc->cscSubComponent &&
                (pComp->dwInstallStatus & psc->UpgradeFlags) )
            {
                // if this is server upgrade, determine upgrade path
                hr = DetermineServerUpgradePath(pComp);
                _JumpIfError(hr, error, "DetermineServerUpgradePath");

                // determine custom policy module
                hr = DetermineServerCustomModule(
                         pComp,
                         TRUE);  // policy
                _JumpIfError(hr, error, "DetermineServerCustomModule");

                // determine custom exit module
                hr = DetermineServerCustomModule(
                         pComp,
                         FALSE);  // exit
                _JumpIfError(hr, error, "DetermineServerCustomModule");
            }

            if (!s_fPreUninstall)
            {
                hr = PreUninstallCore(hwnd, pComp);
                _JumpIfError(hr, error, "PreUninstallCore");
                s_fPreUninstall = TRUE;
            }
        }

        if ((pComp->dwInstallStatus & psc->ChangeFlags) ||
            (pComp->dwInstallStatus & psc->UpgradeFlags) )
        {
            // Being installed or uninstalled.
            // Fetch [un]install/upgrade section name.
            if (pComp->dwInstallStatus & psc->InstallFlags)
            {
                pwszAction = wszINSTALL;
            }
            else if (pComp->dwInstallStatus & psc->UninstallFlags)
            {
                pwszAction = wszUNINSTALL;
            }
            else if (pComp->dwInstallStatus & psc->UpgradeFlags)
            {
                pwszAction = wszUPGRADE;
            }
            else
            {
                hr = E_INVALIDARG;
                _JumpError(hr, error, "Internal error");
            }
            hr = certocmReadInfString(
                            pComp->MyInfHandle,
                            psc->pwszSubComponent,
                            pwszAction,
                            &pwsz);
            _JumpIfError(hr, error, "certocmReadInfString");

            // If uninstalling, copy files without version checks.

            if (!SetupInstallFilesFromInfSection(
                                            pComp->MyInfHandle,
                                            NULL,
                                            hFileQueue,
                                            pwsz,
                                            NULL,
                                            fRemoveFile? 0 : SP_COPY_NEWER))
            {
                hr = myHLastError();
                _JumpIfError(hr, error, "SetupInstallFilesFromInfSection");
            }
        }
    }

done:
    hr = S_OK;
error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    if (S_OK != hr)
    {
        SetLastError(hr);
    }
    *pulpRet = hr;
    return(hr);
}


// OCM calls this routine when it wants to find out how much work the component
// wants to perform for nonfile operations to install/uninstall a component or
// subcomponent.  It is called once for the *entire* component and then once
// for each subcomponent in the component.  One could get arbitrarily fancy
// here but we simply return 1 step per subcomponent.  We ignore the "entire
// component" case.
//
// Return value is an arbitrary 'step' count or -1 if error.

HRESULT
certocmOcQueryStepCount(
    IN WCHAR const *DBGPARMREFERENCED(pwszComponent),
    OPTIONAL IN WCHAR const *pwszSubComponent,
    OUT ULONG_PTR *pulpRet)
{
    HRESULT  hr;

    *pulpRet = 0;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_QUERY_STEP_COUNT(%ws, %ws)\n",
            pwszComponent,
            pwszSubComponent));

    // Ignore all but "entire component" case.
    if (NULL != pwszSubComponent)
    {
        goto done;
    }
    *pulpRet = SERVERINSTALLTICKS;

done:
    hr = S_OK;
//error:
    return hr;
}


// OCM calls this routine when it wants the component dll to perform nonfile
// ops to install/uninstall a component/subcomponent.  It is called once for
// the *entire* component and then once for each subcomponent in the component.
// Our install and uninstall actions are based on simple standard inf install
// sections.  We ignore the "entire component" case.  Note how similar this
// code is to the OC_QUEUE_FILE_OPS case.

HRESULT
certocmOcCompleteInstallation(
    IN HWND hwnd,
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent,
    IN OUT PER_COMPONENT_DATA *pComp,
    OUT ULONG_PTR *pulpRet)
{
    HRESULT hr;
    TCHAR wszBuffer[cwcINFVALUE];
    SUBCOMP const *psc;
    DWORD dwSetupStatusFlags;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    WCHAR     *pwszActiveCA = NULL;
    static BOOL  fStoppedW3SVC = FALSE;

    *pulpRet = 0;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_COMPLETE_INSTALLATION(%ws, %ws)\n",
            pwszComponent,
            pwszSubComponent));

    // Do no work for top level component
    if (NULL == pwszSubComponent)
    {
        goto done;
    }

    psc = TranslateSubComponent(pwszComponent, pwszSubComponent);
    if (NULL == psc)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal error: unsupported component");
    }

    if (pComp->dwInstallStatus & IS_SERVER_REMOVE)
    {
        // for uninstall, check if active ca use DS
        hr = myGetCertRegStrValue(NULL, NULL, NULL,
                 wszREGACTIVE, &pwszActiveCA);
        if (S_OK == hr && NULL != pwszActiveCA)
        {
            hr = myGetCertRegDWValue(pwszActiveCA, NULL, NULL,
                     wszREGCAUSEDS, (DWORD*)&pServer->fUseDS);
            _PrintIfError(hr, "myGetCertRegDWValue");
        }
    }

    DBGPRINT((
	DBG_SS_CERTOCMI,
        "certocmOcCompleteInstallation: pComp->dwInstallStatus: %lx, pComp->Flags: %lx\n",
	pComp->dwInstallStatus,
	pComp->Flags));

    if ((pComp->dwInstallStatus & psc->ChangeFlags) ||
        (pComp->dwInstallStatus & psc->UpgradeFlags) )
    {
        // for unattended, make sure w3svc is stopped before file copy
        if (!fStoppedW3SVC &&
            pComp->fUnattended &&
            !(pComp->Flags & SETUPOP_NTUPGRADE) &&
            !(pComp->dwInstallStatus & psc->UninstallFlags) )
        {
            //fStoppedW3SVC makes stop only once
            //don't do this in upgrade
            // this happens for unattended
            // also not during uninstall
            hr = StartAndStopService(pComp->hInstance,
                     pComp->fUnattended,
                     hwnd,
                     wszW3SVCNAME,
                     TRUE,
                     FALSE,
                     0, // doesn't matter since no confirmation
                     &g_fW3SvcRunning);
            _PrintIfError(hr, "StartAndStopService");
            fStoppedW3SVC = TRUE;
        }

        // certsrv file copy
        if (!SetupInstallFromInfSection(
                                NULL,
                                pComp->MyInfHandle,
                                wszBuffer,
                                SPINST_INIFILES | SPINST_REGISTRY,
                                NULL,
                                NULL,
                                0,
                                NULL,
                                NULL,
                                NULL,
                                NULL))
        {
            hr = myHLastError();
            _JumpError(hr, error, "SetupInstallFromInfSection");
        }

        // Finish uninstalling the core if:
        // this subcomponent is being uninstalled, and
        // this is a core subcomponent (client or server), and
        // this is the server subcomponent, or the server isn't being removed.

        if ( (pComp->dwInstallStatus & psc->UninstallFlags) &&
             (cscServer == psc->cscSubComponent ||
              !(IS_SERVER_REMOVE & pComp->dwInstallStatus) ) )
        {
            // Do uninstall work 
            hr = UninstallCore(
                           hwnd,
                           pComp,
                           0,
                           100,
                           certocmPreserving(pComp, cscClient),
                           TRUE,
                           FALSE);
            _JumpIfError(hr, error, "UninstallCore");

            if (certocmPreserving(pComp, cscClient))
            {
                hr = SetSetupStatus(NULL, SETUP_CLIENT_FLAG, TRUE);
                _JumpIfError(hr, error, "SetSetupStatus");
            }
            else
            {
                // unmark all
                hr = SetSetupStatus(NULL, 0xFFFFFFFF, FALSE);
                _JumpIfError(hr, error, "SetSetupStatus");
            }
        }

        // Finish installing the core if:
        // this subcomponent is being installed, and
        // this is a core subcomponent (client or server), and
        // this is the server subcomponent, or the server isn't being installed.
        // and this is not base setup (we'll do it later if it is)

        else
        if ((pComp->dwInstallStatus & psc->InstallFlags) &&
            (cscServer == psc->cscSubComponent ||
             !(IS_SERVER_INSTALL & pComp->dwInstallStatus)) &&
             (0 != (pComp->Flags & SETUPOP_STANDALONE)))
        {
                DBGPRINT((
                    DBG_SS_CERTOCMI,
                "Performing standalone server installation\n"));

        
            hr = InstallCore(hwnd, pComp, cscServer == psc->cscSubComponent);
            _JumpIfError(hr, error, "InstallCore");

            // last enough to mark complete
            if (pComp->dwInstallStatus & IS_SERVER_INSTALL)
            {
                // machine
                hr = SetSetupStatus(NULL, SETUP_SERVER_FLAG, TRUE);
                _JumpIfError(hr, error, "SetSetupStatus");

                // ca
                hr = SetSetupStatus(
                                    pServer->pwszSanitizedName,
                                    SETUP_SERVER_FLAG,
                                    TRUE);
                _JumpIfError(hr, error, "SetSetupStatus");

                if(IsEnterpriseCA(pServer->CAType))
                {
                    hr = SetSetupStatus(
                                        pServer->pwszSanitizedName,
                                        SETUP_UPDATE_CAOBJECT_SVRTYPE,
                                        TRUE);
                    _JumpIfError(hr, error, "SetSetupStatus SETUP_UPDATE_CAOBJECT_SVRTYPE");
                }


                hr = GetSetupStatus(pServer->pwszSanitizedName, &dwSetupStatusFlags);
                _JumpIfError(hr, error, "SetSetupStatus");

                // Only start the server if:
                // 1: we're not waiting for the CA cert to be issued, and
                // 2: this is not base setup -- SETUP_STANDALONE means we're
                //    running from the Control Panel or were manually invoked.
                //    The server will not start during base setup due to an
                //    access denied error from JetInit during base setup.

                if (0 == (SETUP_SUSPEND_FLAG & dwSetupStatusFlags) &&
                    (0 != (SETUPOP_STANDALONE & pComp->Flags)))
                {
                    hr = StartCertsrvService(FALSE);
                    _PrintIfError(hr, "failed in starting cert server service");
                }

                // during base setup: f=0 sus=8
                DBGPRINT((
                        DBG_SS_CERTOCMI,
                        "InstallCore: f=%x sus=%x\n",
                        pComp->Flags,
                        dwSetupStatusFlags));

                hr = EnableVRootsAndShares(FALSE, FALSE, TRUE, pComp, hwnd);

                if(REGDB_E_CLASSNOTREG ==  hr ||
                   HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) == hr ||
                   HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
                {
                    CertWarningMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hwnd,
                        IDS_WRN_IIS_NOT_INSTALLED,
                        0,
                        NULL);
                    hr = S_OK;
                }
                _JumpIfError(hr, error, "failed creating VRoots/shares");
            }
            if (pComp->dwInstallStatus & IS_CLIENT_INSTALL)
            {
                hr = SetSetupStatus(NULL, SETUP_CLIENT_FLAG, TRUE);
                _JumpIfError(hr, error, "SetSetupStatus");
            }
            if ((pComp->dwInstallStatus & IS_SERVER_INSTALL) &&
                (pComp->dwInstallStatus & IS_CLIENT_INSTALL))
            {
                hr = SetSetupStatus(
                                    pServer->pwszSanitizedName,
                                    SETUP_CLIENT_FLAG,
                                    TRUE);
                _JumpIfError(hr, error, "SetSetupStatus");
            }

            // in case we're doing a post-base setup,
            // we always clear the post-base to-do list
            RegDeleteKey(HKEY_LOCAL_MACHINE, wszREGKEYCERTSRVTODOLIST);

        }
        else
        if ((pComp->dwInstallStatus & psc->InstallFlags) &&
            (cscServer == psc->cscSubComponent ||
             !(IS_SERVER_INSTALL & pComp->dwInstallStatus)) &&
             (0 == (pComp->Flags & (SETUPOP_STANDALONE |
                                    SETUPOP_WIN31UPGRADE |
                                    SETUPOP_WIN95UPGRADE |
                                    SETUPOP_NTUPGRADE) )))
        {
            HKEY   hkToDoList = NULL;
            WCHAR *pwszConfigTitleVal = NULL;
            WCHAR *pwszArgsValTemp = NULL;
            WCHAR *pwszArgsVal = wszCONFIGARGSVAL;
            BOOL   fFreeTitle = FALSE;
            DWORD  disp;
            DWORD  err;

	    DBGPRINT((
		DBG_SS_CERTOCMI,
                "Adding Certificate Services to ToDoList\n"));

            // We're installing base, so create
            // the ToDoList entry stating that we copied files.
            err = ::RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             wszREGKEYCERTSRVTODOLIST,
                             0,
                             NULL,
                             0,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hkToDoList,
                             &disp);
            hr = HRESULT_FROM_WIN32(err);
            _JumpIfError(hr, error, "RegCreateKeyEx");

            hr = myLoadRCString(
                         g_hInstance,
                         IDS_TODO_TITLE,
                         &pwszConfigTitleVal);
            if (S_OK == hr)
            {
                fFreeTitle = TRUE;
            }
            else
            {
                // If there was no resource, get something...
                pwszConfigTitleVal = wszCONFIGTITLEVAL;
            }

            // config title
            err = RegSetValueEx(hkToDoList, 
                                wszCONFIGTITLE,
                                0, 
                                REG_SZ, 
                                (PBYTE)pwszConfigTitleVal, 
                                sizeof(WCHAR)*(wcslen(pwszConfigTitleVal)+1));
            hr = HRESULT_FROM_WIN32(err);
            _PrintIfErrorStr(hr, "RegSetValueEx", wszCONFIGTITLE);

	    CSILOG(hr, IDS_LOG_TODOLIST, wszCONFIGTITLE, pwszConfigTitleVal, NULL);

            // config command
            err = RegSetValueEx(hkToDoList, 
                                wszCONFIGCOMMAND, 
                                0, 
                                REG_SZ,
                                (PBYTE)wszCONFIGCOMMANDVAL,
                                sizeof(WCHAR)*(wcslen(wszCONFIGCOMMANDVAL)+1));
            hr = HRESULT_FROM_WIN32(err);
            _PrintIfErrorStr(hr, "RegSetValueEx", wszCONFIGCOMMAND);

	    CSILOG(hr, IDS_LOG_TODOLIST, wszCONFIGCOMMAND, wszCONFIGCOMMANDVAL, NULL);

            // config args
            if (pComp->fUnattended && NULL != pComp->pwszUnattendedFile)
            {
                // if nt base is in unattended mode, expand args with
                // unattended answer file name

                pwszArgsValTemp = (WCHAR*)LocalAlloc(LMEM_FIXED,
                    (wcslen(pwszArgsVal) +
                     wcslen(pComp->pwszUnattendedFile) + 5) * sizeof(WCHAR));
                _JumpIfOutOfMemory(hr, error, pwszArgsValTemp);

                wcscpy(pwszArgsValTemp, pwszArgsVal);
                wcscat(pwszArgsValTemp, L" /u:");
                wcscat(pwszArgsValTemp, pComp->pwszUnattendedFile);
                pwszArgsVal = pwszArgsValTemp;
            }
            err = RegSetValueEx(hkToDoList, 
				    wszCONFIGARGS,
                                    0, 
                                    REG_SZ, 
                                    (PBYTE)pwszArgsVal,
                                    sizeof(WCHAR)*(wcslen(pwszArgsVal)+1));
            hr = HRESULT_FROM_WIN32(err);
            _PrintIfErrorStr(hr, "RegSetValueEx", wszCONFIGARGS);

	    CSILOG(hr, IDS_LOG_TODOLIST, wszCONFIGARGS, pwszArgsVal, NULL);


            // free stuff
            if (NULL != pwszConfigTitleVal && fFreeTitle)
            {
                LocalFree(pwszConfigTitleVal);
            }
            if (NULL != pwszArgsValTemp)
            {
                LocalFree(pwszArgsValTemp);
            }
            if (NULL != hkToDoList)
            {
                RegCloseKey(hkToDoList);
            }
        }
        else if (pComp->dwInstallStatus & psc->UpgradeFlags)
        {
            BOOL fFinishCYS;

            hr = CheckPostBaseInstallStatus(&fFinishCYS);
            _JumpIfError(hr, error, "CheckPostBaseInstallStatus");

            // if post mode is true, don't execute setup upgrade path
            if (fFinishCYS)
            {
                BOOL fServer = FALSE;
                // upgrade
                if (cscServer == psc->cscSubComponent)
                {
                    hr = UpgradeServer(hwnd, pComp);
                    _JumpIfError(hr, error, "UpgradeServer");
                    fServer = TRUE;
                }
                else if (cscClient == psc->cscSubComponent)
                {
                    hr = UpgradeClient(hwnd, pComp);
                    _JumpIfError(hr, error, "UpgradeClient");
                }

                // mark setup status
                hr = SetSetupStatus(NULL, psc->SetupStatusFlags, TRUE);
                _PrintIfError(hr, "SetSetupStatus");
                if (fServer)
                {
                    // ca level
                    hr = SetSetupStatus(
                             pServer->pwszSanitizedName,
                             psc->SetupStatusFlags, TRUE);
                    _PrintIfError(hr, "SetSetupStatus");

                    if(IsEnterpriseCA(pServer->CAType))
                    {
                        hr = SetSetupStatus(
                                pServer->pwszSanitizedName,
                                SETUP_UPDATE_CAOBJECT_SVRTYPE,
                                TRUE);
                        _JumpIfError(hr, error, 
                            "SetSetupStatus SETUP_UPDATE_CAOBJECT_SVRTYPE");
                    }
                }

                if (fServer && pServer->fCertSrvWasRunning)
                {
                    hr = StartCertsrvService(TRUE);
                    _PrintIfError(hr, "failed in starting cert server service");
                }
            }
        }
    }

done:
    hr = S_OK;

error:
    if (NULL != pwszActiveCA)
    {
        LocalFree(pwszActiveCA);
    }
    *pulpRet = hr;
    return(hr);
}


HRESULT
certocmOcCommitQueue(
    IN HWND                hwnd,
    IN WCHAR const        *pwszComponent,
    IN WCHAR const        *pwszSubComponent,
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    SUBCOMP  *pSub;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_ABOUT_TO_COMMIT_QUEUE(%ws, %ws)\n",
            pwszComponent,
            pwszSubComponent));

    pSub = TranslateSubComponent(pwszComponent, pwszSubComponent);
    if (NULL == pSub)
    {
        goto done;
    }

    // setup will satrt soon, mark it incomplete
    if ((pSub->InstallFlags & pComp->dwInstallStatus) &&
         cscServer == pSub->cscSubComponent)
    {
        hr = SetSetupStatus(NULL, pSub->SetupStatusFlags, FALSE);
        _PrintIfError(hr, "SetSetupStatus");
        hr = SetSetupStatus(
                 pServer->pwszSanitizedName, 
                 pSub->SetupStatusFlags,
                 FALSE);
        _PrintIfError(hr, "SetSetupStatus");
    }

    if ((cscServer == pSub->cscSubComponent) &&
        (pSub->UpgradeFlags & pComp->dwInstallStatus) )
    {
        // upgrade case, no UI, stop existing certsrv
        hr = StartAndStopService(pComp->hInstance,
                 pComp->fUnattended,
                 hwnd,
                 wszSERVICE_NAME,
                 TRUE,  // stop the service
                 FALSE, // no confirm
                 0,    //doesn't matter since no confirm
                 &pServer->fCertSrvWasRunning);
        _PrintIfError(hr, "ServiceExists");
    }

done:
    hr = S_OK;
//error:
    return hr;
}

// Component dll is being unloaded.

VOID
certocmOcCleanup(
    IN WCHAR const *pwszComponent,
    IN PER_COMPONENT_DATA *pComp)
{
    DBGPRINT((DBG_SS_CERTOCMI, "OC_CLEANUP(%ws)\n", pwszComponent));

    if (NULL != pComp->pwszComponent)
    {
        if (0 == mylstrcmpiL(pComp->pwszComponent, pwszComponent))
        {
            FreeCAComponentInfo(pComp);
        }
    }

    // also free some globals
    FreeCAGlobals();
}

/////////////////////////////////////////////////////////////////////////////
//++
//
// certocmOcQueryState
//
// Routine Description:
//    This funcion sets the original, current, and final selection states of the
//    CertSrv service optional component.
//
// Return Value:
//    SubcompOn - indicates that the checkbox should be set
//    SubcompOff - indicates that the checkbox should be clear
//    SubcompUseOCManagerDefault - OC Manager should set the state of the checkbox
//                                 according to state information that is maintained
//                                 internally by OC Manager itself.
//
// Note:
//    By the time this function gets called OnOcInitComponent has already determined
//    that Terminal Services is not installed. It is only necessary to determine
//    whether Terminal Services is selected for installation.
//--
/////////////////////////////////////////////////////////////////////////////

HRESULT
certocmOcQueryState(
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent,
    IN DWORD SelectionState,
    IN PER_COMPONENT_DATA *pComp,
    OUT ULONG_PTR *pulpRet)
{
    HRESULT hr;
    SubComponentState stateRet = SubcompUseOcManagerDefault;
    DWORD  status;
    WCHAR awc[cwcDWORDSPRINTF];
    BOOL  fFinished;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_QUERY_STATE(%ws, %ws, %x)\n",
            pwszComponent,
            pwszSubComponent,
            SelectionState));

    if (NULL == pwszSubComponent)
    {
        goto done;
    }

    switch(SelectionState)
    {
        case OCSELSTATETYPE_ORIGINAL:
        {
            // check to see if the post link exist
            hr = CheckPostBaseInstallStatus(&fFinished);
            _JumpIfError(hr, error, "CheckPostBaseInstallStatus");

            if (!pComp->fPostBase &&
                (SETUPOP_STANDALONE & pComp->Flags) )
            {
                // install through Components button
                if (!fFinished)
                {
                    // don't honor local reg SetupStatus
                    break;
                }
            }

            // Return the initial installation state of the subcomponent
            if (!pComp->fPostBase &&
                ((SETUPOP_STANDALONE & pComp->Flags) || 
                 (SETUPOP_NTUPGRADE & pComp->Flags)) )
            {
                //there is chance for user installed certsrv during base setup
                //and then upgrade without finishing CYS
                if (fFinished)
                {
                // If this is an upgrade or a standalone, query the registry to 
                // get the current installation status

                // XTAN, 7/99
                // currently certsrv_server has Needs relationship with
                // certsrv_client. OCM gathers success for certsrv_client before
                // certsrv_server is complete so we don't trust OCM state info
                // about certsrv_client and we check our reg SetupStatus here.
                // our certsrv_server Needs define is incorrect. If we take it
                // out, we probably don't need to reg SetupStatus at 
                // Configuration level at all and we can trust OCM state info

                hr = GetSetupStatus(NULL, &status);
                if (S_OK == hr)
                {
                    if (
                        (0 == LSTRCMPIS(pwszSubComponent, wszSERVERSECTION) &&
                         !(SETUP_SERVER_FLAG & status)) ||
                        (0 == LSTRCMPIS(pwszSubComponent, wszCLIENTSECTION) &&
                         !(SETUP_CLIENT_FLAG & status))
                       )
                    {
                        // overwrite OCM default
                        stateRet = SubcompOff;
                    }
                }
                }
            }
            break;
        }
        case OCSELSTATETYPE_CURRENT:
        {
            break;
        }

        case OCSELSTATETYPE_FINAL:
        {
            SUBCOMP const *psc;
            BOOL  fWasEnabled;

            if (S_OK != pComp->hrContinue && !pComp->fUnattended)
            {
                stateRet = SubcompOff;
            }

            //get component install info
            psc = TranslateSubComponent(pwszComponent, pwszSubComponent);
            if (NULL == psc)
            {
                hr = E_INVALIDARG;
                _JumpError(hr, error, "Internal error: unsupported component");
            }
            fWasEnabled = certocmWasEnabled(pComp, psc->cscSubComponent);

            // after all of this, change upgrade->uninstall if not supported
            if ((SETUPOP_NTUPGRADE & pComp->Flags) && fWasEnabled)
            {
               CSASSERT(pComp->UpgradeFlag != CS_UPGRADE_UNKNOWN);
               if (CS_UPGRADE_UNSUPPORTED == pComp->UpgradeFlag)
                  stateRet = SubcompOff;
            }


            break;
        }
    }

done:
    hr = S_OK;
error:
    wsprintf(awc, L"%u", SelectionState);
    CSILOG(S_OK, IDS_LOG_SELECTIONSTATE, awc, NULL, (DWORD const *) &stateRet);
    *pulpRet = stateRet;
    return(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CertSrvOCProc( . . . . )
//
//  Synopsis:   Service procedure for Cert Server OCM Setup.
//
//  Arguments:  [pwszComponent]
//              [pwszSubComponent]
//              [Function]
//              [Param1]              
//              [Param2]
//
//  Returns:    DWORD 
//
//  History:    04/07/97        JerryK  Created
// 
//-------------------------------------------------------------------------

ULONG_PTR
CertSrvOCProc(
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN UINT Function,
    IN UINT_PTR Param1,
    IN OUT VOID *Param2)
{
    ULONG_PTR ulpRet = 0;
    WCHAR const *pwszFunction = NULL;
    BOOL fReturnErrCode = TRUE;
    DWORD ErrorLine;

    __try
    {
	switch (Function) 
	{
	    // OC_PREINITIALIZE:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = CHAR top level component string
	    // Param1 = char width flags
	    // Param2 = unused
	    //
	    // Return code is char width allowed flags

	    case OC_PREINITIALIZE:
		csiLogOpen("+certocm.log");
		CSILOGFILEVERSION(0, L"certocm.dll", szCSVER_STR);

		pwszFunction = L"OC_PREINITIALIZE";
		fReturnErrCode = FALSE;

		// Make sure IDS_LOG_BEGIN & IDS_LOG_END see a Unicode string:

		pwszSubComponent = pwszComponent;

		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_PREINITIALIZE");

		g_Comp.hrContinue = myInfOpenFile(NULL, &g_Comp.hinfCAPolicy, &ErrorLine);
		if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == g_Comp.hrContinue)
		{
		    g_Comp.hrContinue = S_OK;
		}
		_LeaveIfError(g_Comp.hrContinue, "myInfOpenFile");

		g_Comp.hrContinue = certocmOcPreInitialize(
					pwszComponent,
					(UINT)Param1, //cast to UINT, use as flags
					&ulpRet);
		_PrintIfError(g_Comp.hrContinue, "certocmOcPreInitialize");
		break;


	    // OC_INIT_COMPONENT:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = unused
	    // Param1 = unused
	    // Param2 = points to IN OUT SETUP_INIT_COMPONENT structure
	    //
	    // Return code is Win32 error indicating outcome.

	    case OC_INIT_COMPONENT:
		pwszFunction = L"OC_INIT_COMPONENT";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_INIT_COMPONENT");

		g_Comp.hrContinue = certocmOcInitComponent(
					NULL, // probably have to pass null hwnd
					pwszComponent,
					(SETUP_INIT_COMPONENT *) Param2,
					&g_Comp,
					&ulpRet);
		_PrintIfError(g_Comp.hrContinue, "certocmOcInitComponent");
		break;

	    case OC_SET_LANGUAGE:
		pwszFunction = L"OC_SET_LANGUAGE";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_SET_LANGUAGE");
		DBGPRINT((
			DBG_SS_CERTOCMI,
			"OC_SET_LANGUAGE(%ws, %ws, %x, %x)\n",
			pwszComponent,
			pwszSubComponent,
			Param1,
			Param2));
		break;

	    // OC_QUERY_IMAGE:
            //
            // obsolete (only called on x86 if IMAGE_EX fails)
            // use OC_QUERY_IMAGE_EX instead
            //
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = low 16 bits specify image; only small icon supported
	    // Param2 = low 16 bits = desired width, high 16 bits = desired height
	    //
	    // Return value is the GDI handle of a small bitmap to be used.


	    case OC_QUERY_IMAGE:
		pwszFunction = L"OC_QUERY_IMAGE";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_QUERY_IMAGE");

		g_Comp.hrContinue = certocmOcQueryImage(
					pwszComponent,
					pwszSubComponent,
					(SubComponentInfo) LOWORD(Param1),
					LOWORD((ULONG_PTR) Param2),
					HIWORD((ULONG_PTR) Param2),
					&g_Comp,
					(HBITMAP*)&ulpRet);
		_PrintIfError(g_Comp.hrContinue, "certocmOcQueryImage");
		break;

            // OC_QUERY_IMAGE_EX:
            //
      	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
            // Param1 = [in] OC_QUERY_IMAGE_INFO*
            // Param2 = [in,out] HBITMAP* 
            //
            // Return value is S_OK or ERROR_CALL_COMPONENT
            
            case OC_QUERY_IMAGE_EX:
		pwszFunction = L"OC_QUERY_IMAGE_EX";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
                {
		    OC_QUERY_IMAGE_INFO *pocQueryImageInfo = (OC_QUERY_IMAGE_INFO *) Param1;
		    g_Comp.hrContinue = certocmOcQueryImage(
					    pwszComponent,
					    pwszSubComponent,
					    pocQueryImageInfo->ComponentInfo,
					    pocQueryImageInfo->DesiredWidth,
					    pocQueryImageInfo->DesiredHeight,
					    &g_Comp,
					    (HBITMAP *) Param2);
		    _PrintIfError(g_Comp.hrContinue, "certocmOcQueryImage");
		    ulpRet = (S_OK == g_Comp.hrContinue)? TRUE:FALSE;
                }
                break;

	    // OC_REQUEST_PAGES:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = unused
	    // Param1 = Type of wiz pages being requested (WizardPagesType enum)
	    // Param2 = points to IN OUT SETUP_REQUEST_PAGES structure
	    //
	    // Return value is number of pages the component places in the
	    // SETUP_REQUEST_PAGES structure.

	    case OC_REQUEST_PAGES:
		pwszFunction = L"OC_REQUEST_PAGES";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_REQUEST_PAGES");

		g_Comp.hrContinue = certocmOcRequestPages(
						pwszComponent,
						(WizardPagesType) Param1,
						(SETUP_REQUEST_PAGES *) Param2,
						&g_Comp,
						&ulpRet);
		_PrintIfError(g_Comp.hrContinue, "certocmOcRequestPages");
		break;

	    // OC_QUERY_CHANGE_SEL_STATE:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = proposed new sel state; 0 = unselected, non 0 = selected
	    // Param2 = flags -- OCQ_ACTUAL_SELECTION
	    //
	    // Return boolean to indicate whether to allow selection state change

	    case OC_QUERY_CHANGE_SEL_STATE:
		pwszFunction = L"OC_QUERY_CHANGE_SEL_STATE";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_QUERY_CHANGE_SEL_STATE");

		g_Comp.hrContinue = certocmOcQueryChangeSelState(
					g_Comp.HelperRoutines.QueryWizardDialogHandle(g_Comp.HelperRoutines.OcManagerContext),
					pwszComponent,
					pwszSubComponent,
					(BOOL) Param1,
					(DWORD) (ULONG_PTR) Param2,
					&g_Comp,
					&ulpRet);
		_PrintIfError(g_Comp.hrContinue, "certocmOcQueryChangeSelState");
		break;

	    // OC_CALC_DISK_SPACE:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = 0 for removing component or non 0 for adding component
	    // Param2 = HDSKSPC to operate on
	    //
	    // Return value is Win32 error code indicating outcome.

	    case OC_CALC_DISK_SPACE:
		pwszFunction = L"OC_CALC_DISK_SPACE";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_CALC_DISK_SPACE");

		g_Comp.hrContinue = certocmOcCalcDiskSpace(
					pwszComponent,
					pwszSubComponent,
					(BOOL) Param1,
					(HDSKSPC) Param2,
					&g_Comp,
					&ulpRet);
		_PrintIfError(g_Comp.hrContinue, "certocmOcCalcDiskSpace");
		break;

	    // OC_QUEUE_FILE_OPS:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = unused
	    // Param2 = HSPFILEQ to operate on
	    //
	    // Return value is Win32 error code indicating outcome.

	    case OC_QUEUE_FILE_OPS:
		pwszFunction = L"OC_QUEUE_FILE_OPS";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_QUEUE_FILE_OPS");

		g_Comp.hrContinue = certocmOcQueueFileOps(
					g_Comp.HelperRoutines.QueryWizardDialogHandle(g_Comp.HelperRoutines.OcManagerContext),
					pwszComponent,
					pwszSubComponent,
					(HSPFILEQ) Param2,
					&g_Comp,
					&ulpRet);
		_PrintIfError(g_Comp.hrContinue, "certocmOcQueueFileOps");
		break;

	    // Params? xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
	    // OC_NOTIFICATION_FROM_QUEUE:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = unused
	    // Param1 = unused
	    // Param2 = unused
	    //
	    // Return value is ???

	    case OC_NOTIFICATION_FROM_QUEUE:
		pwszFunction = L"OC_NOTIFICATION_FROM_QUEUE";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		DBGPRINT((
			DBG_SS_CERTOCMI,
			"OC_NOTIFICATION_FROM_QUEUE(%ws, %ws, %x, %x)\n",
			pwszComponent,
			pwszSubComponent,
			Param1,
			Param2));
		break;

	    // OC_QUERY_STEP_COUNT:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = unused
	    // Param2 = unused
	    //
	    // Return value is an arbitrary 'step' count or -1 if error.

	    case OC_QUERY_STEP_COUNT:
		pwszFunction = L"OC_QUERY_STEP_COUNT";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_QUERY_STEP_COUNT");

		g_Comp.hrContinue = (DWORD) certocmOcQueryStepCount(
						    pwszComponent,
						    pwszSubComponent,
						    &ulpRet);
		_PrintIfError(g_Comp.hrContinue, "certocmOcQueryStepCount");
		break;

	    // OC_COMPLETE_INSTALLATION:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = reserved for future expansion
	    // Param2 = unused
	    //
	    // Return value is Win32 error code indicating outcome.

	    case OC_COMPLETE_INSTALLATION:
		pwszFunction = L"OC_COMPLETE_INSTALLATION";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_COMPLETE_INSTALLATION");

		g_Comp.hrContinue = certocmOcCompleteInstallation(
				g_Comp.HelperRoutines.QueryWizardDialogHandle(g_Comp.HelperRoutines.OcManagerContext),
				pwszComponent,
				pwszSubComponent,
				&g_Comp,
				&ulpRet);
		_PrintIfError(g_Comp.hrContinue, "certocmOcCompleteInstallation");
		break;

	    // OC_CLEANUP:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = unused
	    // Param1 = unused
	    // Param2 = unused
	    //
	    // Return value is ignored

	    case OC_CLEANUP:
		// don't _LeaveIfError(g_Comp.hrContinue, "OC_CLEANUP");
		// avoid memory leaks

		pwszFunction = L"OC_CLEANUP";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		certocmOcCleanup(pwszComponent, &g_Comp);
		break;

	    // Params? xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
	    // OC_QUERY_STATE:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = unused? (but Index Server uses it for current state)!
	    // Param2 = unused
	    //
	    // Return value is from the SubComponentState enumerated type

	    case OC_QUERY_STATE:
		pwszFunction = L"OC_QUERY_STATE";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		//don't _LeaveIfError(g_Comp.hrContinue, "OC_QUERY_STATE");

		certocmOcQueryState(
			    pwszComponent,
			    pwszSubComponent,
			    (DWORD)Param1, //cast to DWORD, use as flags
			    &g_Comp,
			    &ulpRet);
		break;

	    // Params? xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
	    // OC_NEED_MEDIA:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = unused
	    // Param2 = unused
	    //
	    // Return value is ???

	    case OC_NEED_MEDIA:
		pwszFunction = L"OC_NEED_MEDIA";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		DBGPRINT((
			DBG_SS_CERTOCMI,
			"OC_NEED_MEDIA(%ws, %ws, %x, %x)\n",
			pwszComponent,
			pwszSubComponent,
			Param1,
			Param2));
		break;

	    // OC_ABOUT_TO_COMMIT_QUEUE:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = reserved for future expansion
	    // Param2 = unused
	    //
	    // Return value is Win32 error code indicating outcome.

	    case OC_ABOUT_TO_COMMIT_QUEUE:
		pwszFunction = L"OC_ABOUT_TO_COMMIT_QUEUE";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_ABOUT_TO_COMMIT_QUEUE");

		g_Comp.hrContinue = certocmOcCommitQueue(
				    g_Comp.HelperRoutines.QueryWizardDialogHandle(g_Comp.HelperRoutines.OcManagerContext),
				    pwszComponent,
				    pwszSubComponent,
				    &g_Comp);
		_PrintIfError(g_Comp.hrContinue, "certocmOcCommitQueue");
		break;

	    // OC_QUERY_SKIP_PAGE:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = unused
	    // Param1 = OcManagerPage page indicator
	    // Param2 = unused
	    //
	    // Return value is a boolean -- 0 for display or non 0 for skip

	    case OC_QUERY_SKIP_PAGE:
		pwszFunction = L"OC_QUERY_SKIP_PAGE";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		DBGPRINT((
			DBG_SS_CERTOCMI,
			"OC_QUERY_SKIP_PAGE(%ws, %x)\n",
			pwszComponent,
			(OcManagerPage) Param1));
		_LeaveIfError(g_Comp.hrContinue, "OC_QUERY_SKIP_PAGE");

		if (g_Comp.fPostBase &&
		    (WizardPagesType) Param1 == WizPagesWelcome)
		{
		    ulpRet = 1; // non 0 to skip wiz page
		}
		break;

	    // OC_WIZARD_CREATED:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = ???
	    // Param1 = ???
	    // Param2 = ???
	    //
	    // Return value is ???

	    case OC_WIZARD_CREATED:
		pwszFunction = L"OC_WIZARD_CREATED";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_WIZARD_CREATED");
		break;

	    // OC_EXTRA_ROUTINES:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = ???
	    // Param1 = ???
	    // Param2 = ???
	    //
	    // Return value is ???

	    case OC_EXTRA_ROUTINES:
		pwszFunction = L"OC_EXTRA_ROUTINES";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_EXTRA_ROUTINES");
		break;

	    // Some other notification:

	    default:
		fReturnErrCode = FALSE;
		CSILOG(
		    g_Comp.hrContinue,
		    IDS_LOG_BEGIN,
		    pwszFunction,
		    pwszSubComponent,
		    (DWORD const *) &Function);
		DBGPRINT((
			DBG_SS_CERTOCMI,
			"DEFAULT(0x%x: %ws, %ws, %x, %x)\n",
			Function,
			pwszComponent,
			pwszSubComponent,
			Param1,
			Param2));
		break;
	}
    }
    __except(ulpRet = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	if (S_OK == g_Comp.hrContinue)
	{
	    g_Comp.hrContinue = (HRESULT)ulpRet;
	}
	_PrintError((HRESULT)ulpRet, "Exception");
    }

    DBGPRINT((DBG_SS_CERTOCMI, "return %p\n", ulpRet));

    // make sure to get a pop up in case of fatal error
    if (S_OK != g_Comp.hrContinue)
    {
        if (!g_Comp.fShownErr)
        {
            int iMsgId = g_Comp.iErrMsg;
            if (0 == iMsgId)
            {
                // use generic one
                iMsgId = IDS_ERR_CERTSRV_SETUP_FAIL;
            }
            CertErrorMessageBox(
                    g_Comp.hInstance,
                    g_Comp.fUnattended,
                    NULL,  // null hwnd
                    iMsgId,
                    g_Comp.hrContinue,
                    g_Comp.pwszCustomMessage);
            g_Comp.fShownErr = TRUE;
        }
        // anything fails, cancel install
        HRESULT hr2 = CancelCertsrvInstallation(NULL, &g_Comp);
        _PrintIfError(hr2, "CancelCertsrvInstallation");
    }
    CSILOG(
	fReturnErrCode? (HRESULT) ulpRet : S_OK,
	IDS_LOG_END,
	pwszFunction,
	pwszSubComponent,
	fReturnErrCode? NULL : (DWORD const *) &ulpRet);
    return(ulpRet);
}


ULONG_PTR
CertSrvOCPostProc(
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN UINT Function,
    IN UINT Param1,
    IN OUT VOID *Param2)
{
    // post setup entry point
    // by going through this path, we know it is invoked in post setup
    g_Comp.fPostBase = TRUE;

    return CertSrvOCProc(
                pwszComponent,
                pwszSubComponent,
                Function,
                Param1,
                Param2);
}

VOID
certocmBumpGasGauge(
    OPTIONAL IN PER_COMPONENT_DATA *pComp,
    IN DWORD PerCentComplete
    DBGPARM(IN WCHAR const *pwszSource))
{
    static DWORD dwTickCount = 0;

    if (NULL != pComp)
    {
        DWORD NewCount;

        NewCount = (PerCentComplete * SERVERINSTALLTICKS)/100;
        DBGPRINT((
            DBG_SS_CERTOCMI,
            "certocmBumpGasGauge(%ws, %u%%) %d ticks: %d --> %d\n",
            pwszSource,
            PerCentComplete,
            NewCount - dwTickCount,
            dwTickCount,
            NewCount));

        if (SERVERINSTALLTICKS < NewCount)
        {
            NewCount = SERVERINSTALLTICKS;
        }
        while (dwTickCount < NewCount)
        {
            (*pComp->HelperRoutines.TickGauge)(
                                pComp->HelperRoutines.OcManagerContext);
            dwTickCount++;
        }
    }
}

BOOL
certocmEnabledSub(
    PER_COMPONENT_DATA *pComp,
    CertSubComponent SubComp,
    DWORD SelectionStateType)
{
    SUBCOMP const *psc;
    BOOL bRet = FALSE;
    
    psc = LookupSubComponent(SubComp);
    if (NULL != psc->pwszSubComponent)
    {
        if (pComp->fUnattended &&
            OCSELSTATETYPE_CURRENT == SelectionStateType &&
            0 == (pComp->Flags & SETUPOP_NTUPGRADE) )
        {
            // unattended case, flags from unattended file
            // upgrade is automatically in unattended mode and make sure
            // to exclude it
            bRet = psc->fInstallUnattend;
        }
        else
        {
            bRet = (*pComp->HelperRoutines.QuerySelectionState)(
                pComp->HelperRoutines.OcManagerContext,
                psc->pwszSubComponent,
                SelectionStateType);
        }
    }
    return(bRet);
}


BOOL
certocmIsEnabled(
    PER_COMPONENT_DATA *pComp,
    CertSubComponent SubComp)
{
    BOOL bRet;

    bRet = certocmEnabledSub(pComp, SubComp, OCSELSTATETYPE_CURRENT);
    if (!fDebugSupress)
    {
        DBGPRINT((
            DBG_SS_CERTOCMI,
            "certocmIsEnabled(%ws) Is %ws\n",
            LookupSubComponent(SubComp)->pwszSubComponent,
            bRet? L"Enabled" : L"Disabled"));
    }
    return(bRet);
}


BOOL
certocmWasEnabled(
    PER_COMPONENT_DATA *pComp,
    CertSubComponent SubComp)
{
    BOOL bRet;

    bRet = certocmEnabledSub(pComp, SubComp, OCSELSTATETYPE_ORIGINAL);
    if (!fDebugSupress)
    {
        DBGPRINT((
            DBG_SS_CERTOCMI,
            "certocmWasEnabled(%ws) Was %ws\n",
            LookupSubComponent(SubComp)->pwszSubComponent,
            bRet? L"Enabled" : L"Disabled"));
    }
    return(bRet);
}


BOOL
certocmUninstalling(
    PER_COMPONENT_DATA *pComp,
    CertSubComponent SubComp)
{
    BOOL bRet;

    fDebugSupress++;
    bRet = certocmWasEnabled(pComp, SubComp) && !certocmIsEnabled(pComp, SubComp);
    fDebugSupress--;
    if (!fDebugSupress)
    {
        DBGPRINT((
            DBG_SS_CERTOCMI,
            "certocmUninstalling(%ws) %ws\n",
            LookupSubComponent(SubComp)->pwszSubComponent,
            bRet? L"TRUE" : L"False"));
    }
    return(bRet);
}


BOOL
certocmInstalling(
    PER_COMPONENT_DATA *pComp,
    CertSubComponent SubComp)
{
    BOOL bRet;

    fDebugSupress++;
    bRet = !certocmWasEnabled(pComp, SubComp) && certocmIsEnabled(pComp, SubComp);
    fDebugSupress--;
    if (!fDebugSupress)
    {
        DBGPRINT((
            DBG_SS_CERTOCMI,
            "certocmInstalling(%ws) %ws\n",
            LookupSubComponent(SubComp)->pwszSubComponent,
            bRet? L"TRUE" : L"False"));
    }
    return(bRet);
}


BOOL
certocmPreserving(
    PER_COMPONENT_DATA *pComp,
    CertSubComponent SubComp)
{
    BOOL bRet;

    fDebugSupress++;
    bRet = certocmWasEnabled(pComp, SubComp) && certocmIsEnabled(pComp, SubComp);
    fDebugSupress--;
    if (!fDebugSupress)
    {
        DBGPRINT((
            DBG_SS_CERTOCMI,
            "certocmPreserving(%ws) %ws\n",
            LookupSubComponent(SubComp)->pwszSubComponent,
            bRet? L"TRUE" : L"False"));
    }
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\cryptfix.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cryptfix.cpp
//
//  Contents:   Crypto API, version 2. fix for certificate server
//
//              CryptDecodeObject/CryptEncodeObject structures added
//              after SP3.
//
//  Functions:  CryptFixDllMain
//
//  History:    13-Aug-96    kevinr   created
//
//--------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "crypttls.h"
#include "unicode.h"
extern "C" {
#include "..\..\pki\certstor\ossx509.h"
}


#define __dwFILE__	__dwFILE_OCMSETUP_CRYPTFIX_CPP__


//#include <dbgdef.h>

// The CRYPTIE_STATIC prefixed variables and functions are defined in
// ..\certstor\wincert.obj
#define CRYPTIE_STATIC extern

CRYPTIE_STATIC HCRYPTOSSGLOBAL hX509OssGlobal;
CRYPTIE_STATIC HCRYPTOIDFUNCSET hX509EncodeFuncSet;
CRYPTIE_STATIC HCRYPTOIDFUNCSET hX509DecodeFuncSet;

#if DBG
    extern BOOL WINAPI DebugDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
#endif

extern BOOL WINAPI UnicodeDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);


CRYPTIE_STATIC BOOL WINAPI OssX509KeygenRequestInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEYGEN_REQUEST_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509KeygenRequestInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_KEYGEN_REQUEST_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );

CRYPTIE_STATIC BOOL WINAPI OssX509IntegerEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509IntegerDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT int *pInfo,
        IN OUT DWORD *pcbInfo
        );
CRYPTIE_STATIC BOOL WINAPI OssX509ChoiceOfTimeEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN LPFILETIME pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509ChoiceOfTimeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT LPFILETIME pInfo,
        IN OUT DWORD *pcbInfo
        );
CRYPTIE_STATIC BOOL WINAPI OssX509SequenceOfAnyEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SEQUENCE_OF_ANY pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509SequenceOfAnyDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_SEQUENCE_OF_ANY pInfo,
        IN OUT DWORD *pcbInfo
        );

CRYPTIE_STATIC BOOL WINAPI OssX509CrlDistPointsEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_DIST_POINTS_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509CrlDistPointsDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRL_DIST_POINTS_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );

CRYPTIE_STATIC BOOL WINAPI OssX509AuthorityKeyId2Encode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509AuthorityKeyId2Decode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );

CRYPTIE_STATIC BOOL WINAPI OssX509OctetStringEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_DATA_BLOB pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509OctetStringDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT DWORD *pcbInfo
        );

CRYPTIE_STATIC BOOL WINAPI OssX509BitsEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509BitsDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT DWORD *pcbInfo
        );

CRYPTIE_STATIC BOOL WINAPI OssX509AuthorityInfoAccessEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_INFO_ACCESS pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509AuthorityInfoAccessDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_AUTHORITY_INFO_ACCESS pInfo,
        IN OUT DWORD *pcbInfo
        );

CRYPTIE_STATIC BOOL WINAPI OssX509CtlUsageEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509CtlUsageDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
        );


//+-------------------------------------------------------------------------
//  Encode / Decode the "UNICODE" Name Value
//
//  from certstr.cpp
//--------------------------------------------------------------------------
extern BOOL WINAPI UnicodeNameValueEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
extern BOOL WINAPI UnicodeNameValueDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_NAME_VALUE pInfo,
        IN OUT DWORD *pcbInfo
        );

BOOL WINAPI CertDllKeygenRequestInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEYGEN_REQUEST_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509KeygenRequestInfoEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllKeygenRequestInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_KEYGEN_REQUEST_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509KeygenRequestInfoDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllIntegerEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509IntegerEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllIntegerDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT int *pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509IntegerDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllChoiceOfTimeEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN LPFILETIME pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509ChoiceOfTimeEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllChoiceOfTimeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT LPFILETIME pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509ChoiceOfTimeDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllSequenceOfAnyEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SEQUENCE_OF_ANY pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509SequenceOfAnyEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllSequenceOfAnyDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_SEQUENCE_OF_ANY pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509SequenceOfAnyDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllCrlDistPointsEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_DIST_POINTS_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509CrlDistPointsEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllCrlDistPointsDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRL_DIST_POINTS_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509CrlDistPointsDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllUnicodeNameValueEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return UnicodeNameValueEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllUnicodeNameValueDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_NAME_VALUE pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return UnicodeNameValueDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllAuthorityKeyId2Encode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509AuthorityKeyId2Encode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllAuthorityKeyId2Decode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509AuthorityKeyId2Decode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllOctetStringEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_DATA_BLOB pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509OctetStringEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllOctetStringDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509OctetStringDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllBitsEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509BitsEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllBitsDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509BitsDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllAuthorityInfoAccessEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_INFO_ACCESS pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509AuthorityInfoAccessEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllAuthorityInfoAccessDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_AUTHORITY_INFO_ACCESS pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509AuthorityInfoAccessDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllCtlUsageEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509CtlUsageEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllCtlUsageDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509CtlUsageDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}


typedef struct _OID_REG_ENTRY {
    LPCSTR   pszOID;
    LPCSTR   pszOverrideFuncName;
} OID_REG_ENTRY, *POID_REG_ENTRY;

static const OID_REG_ENTRY RegEncodeTable[] = {
    X509_KEYGEN_REQUEST_TO_BE_SIGNED, "CertDllKeygenRequestInfoEncode",
    X509_UNICODE_NAME_VALUE, "CertDllUnicodeNameValueEncode",
    X509_INTEGER, "CertDllIntegerEncode",
    X509_CHOICE_OF_TIME, "CertDllChoiceOfTimeEncode",
    X509_SEQUENCE_OF_ANY, "CertDllSequenceOfAnyEncode",
    X509_CRL_DIST_POINTS, "CertDllCrlDistPointsEncode",
    X509_AUTHORITY_KEY_ID2, "CertDllAuthorityKeyId2Encode",
    szOID_CRL_DIST_POINTS, "CertDllCrlDistPointsEncode",
    szOID_AUTHORITY_KEY_IDENTIFIER2, "CertDllAuthorityKeyId2Encode",
    X509_OCTET_STRING, "CertDllOctetStringEncode",
    X509_BITS, "CertDllBitsEncode",
    X509_AUTHORITY_INFO_ACCESS, "CertDllAuthorityInfoAccessEncode",
    szOID_AUTHORITY_INFO_ACCESS, "CertDllAuthorityInfoAccessEncode",
    X509_ENHANCED_KEY_USAGE, "CertDllCtlUsageEncode",
    szOID_ENHANCED_KEY_USAGE, "CertDllCtlUsageEncode",
};
#define REG_ENCODE_COUNT (sizeof(RegEncodeTable) / sizeof(RegEncodeTable[0]))

static const OID_REG_ENTRY RegDecodeTable[] = {
    X509_KEYGEN_REQUEST_TO_BE_SIGNED, "CertDllKeygenRequestInfoDecode",
    X509_UNICODE_NAME_VALUE, "CertDllUnicodeNameValueDecode",
    X509_INTEGER, "CertDllIntegerDecode",
    X509_CHOICE_OF_TIME, "CertDllChoiceOfTimeDecode",
    X509_SEQUENCE_OF_ANY, "CertDllSequenceOfAnyDecode",
    X509_CRL_DIST_POINTS, "CertDllCrlDistPointsDecode",
    X509_AUTHORITY_KEY_ID2, "CertDllAuthorityKeyId2Decode",
    szOID_CRL_DIST_POINTS, "CertDllCrlDistPointsDecode",
    szOID_AUTHORITY_KEY_IDENTIFIER2, "CertDllAuthorityKeyId2Decode",
    X509_OCTET_STRING, "CertDllOctetStringDecode",
    X509_BITS, "CertDllBitsDecode",
    X509_AUTHORITY_INFO_ACCESS, "CertDllAuthorityInfoAccessDecode",
    szOID_AUTHORITY_INFO_ACCESS, "CertDllAuthorityInfoAccessDecode",
    X509_ENHANCED_KEY_USAGE, "CertDllCtlUsageDecode",
    szOID_ENHANCED_KEY_USAGE, "CertDllCtlUsageDecode",
};
#define REG_DECODE_COUNT (sizeof(RegDecodeTable) / sizeof(RegDecodeTable[0]))

static const CRYPT_OID_FUNC_ENTRY X509EncodeFuncTable[] = {
    X509_KEYGEN_REQUEST_TO_BE_SIGNED, CertDllKeygenRequestInfoEncode,
    X509_UNICODE_NAME_VALUE, CertDllUnicodeNameValueEncode,
    X509_INTEGER, CertDllIntegerEncode,
    X509_CHOICE_OF_TIME, CertDllChoiceOfTimeEncode,
    X509_SEQUENCE_OF_ANY, CertDllSequenceOfAnyEncode,
    X509_CRL_DIST_POINTS, CertDllCrlDistPointsEncode,
    X509_AUTHORITY_KEY_ID2, CertDllAuthorityKeyId2Encode,
    szOID_CRL_DIST_POINTS, CertDllCrlDistPointsEncode,
    szOID_AUTHORITY_KEY_IDENTIFIER2, CertDllAuthorityKeyId2Encode,
    X509_OCTET_STRING, CertDllOctetStringEncode,
    X509_BITS, CertDllBitsEncode,
    X509_AUTHORITY_INFO_ACCESS, CertDllAuthorityInfoAccessEncode,
    szOID_AUTHORITY_INFO_ACCESS, CertDllAuthorityInfoAccessEncode,
    X509_ENHANCED_KEY_USAGE, CertDllCtlUsageEncode,
    szOID_ENHANCED_KEY_USAGE, CertDllCtlUsageEncode,
};

#define X509_ENCODE_FUNC_COUNT (sizeof(X509EncodeFuncTable) / \
                                    sizeof(X509EncodeFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY X509DecodeFuncTable[] = {
    X509_KEYGEN_REQUEST_TO_BE_SIGNED, CertDllKeygenRequestInfoDecode,
    X509_UNICODE_NAME_VALUE, CertDllUnicodeNameValueDecode,
    X509_INTEGER, CertDllIntegerDecode,
    X509_CHOICE_OF_TIME, CertDllChoiceOfTimeDecode,
    X509_SEQUENCE_OF_ANY, CertDllSequenceOfAnyDecode,
    X509_CRL_DIST_POINTS, CertDllCrlDistPointsDecode,
    X509_AUTHORITY_KEY_ID2, CertDllAuthorityKeyId2Decode,
    szOID_CRL_DIST_POINTS, CertDllCrlDistPointsDecode,
    szOID_AUTHORITY_KEY_IDENTIFIER2, CertDllAuthorityKeyId2Decode,
    X509_OCTET_STRING, CertDllOctetStringDecode,
    X509_BITS, CertDllBitsDecode,
    X509_AUTHORITY_INFO_ACCESS, CertDllAuthorityInfoAccessDecode,
    szOID_AUTHORITY_INFO_ACCESS, CertDllAuthorityInfoAccessDecode,
    X509_ENHANCED_KEY_USAGE, CertDllCtlUsageDecode,
    szOID_ENHANCED_KEY_USAGE, CertDllCtlUsageDecode,
};

#define X509_DECODE_FUNC_COUNT (sizeof(X509DecodeFuncTable) / \
                                    sizeof(X509DecodeFuncTable[0]))

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL WINAPI CryptFixDllMain(HMODULE hInst, ULONG  ulReason, LPVOID lpReserved)
{
    BOOL    fRet;

#   if DBG
#if 0
        //
        // Due to an apparent bug in the Win95 loader, the CRT gets unloaded
        // too early in some circumstances. In particular, it can get unloaded
        // before this routine executes at process detach time. This can cause
        // faults when executing this routine, and also when executing the rest
        // of CRYPT32:CRT_INIT, after this initroutine returns. Ergo, we do an
        // extra load of the CRT, to be sure it stays around long enough.
        //
        if ((ulReason == DLL_PROCESS_ATTACH) && (!(FIsWinNT())))
        {
            LoadLibrary( L"MSVCRTD.DLL");
        }
#endif

        DebugDllMain(hInst, ulReason, lpReserved);

#   endif // DBG

    UnicodeDllMain(hInst, ulReason, lpReserved);

    switch (ulReason)
    {
        case DLL_PROCESS_ATTACH:
            if (0 == (hX509OssGlobal = I_CryptInstallOssGlobal(ossx509, 0, NULL)))
            {
                //goto CryptInstallOssGlobalError;
		goto ErrorReturn;
            }

            if (NULL == (hX509EncodeFuncSet = CryptInitOIDFunctionSet(
                                                CRYPT_OID_ENCODE_OBJECT_FUNC, 0)))
            {
                //goto CryptInitOIDFunctionSetError;
		goto ErrorReturn;
            }

            if (NULL == (hX509DecodeFuncSet = CryptInitOIDFunctionSet(
                                                CRYPT_OID_DECODE_OBJECT_FUNC, 0)))
            {
                //goto CryptInitOIDFunctionSetError;
		goto ErrorReturn;
            }

            if (!(CryptInstallOIDFunctionAddress(   hInst,
                                                    X509_ASN_ENCODING,
                                                    CRYPT_OID_ENCODE_OBJECT_FUNC,
                                                    X509_ENCODE_FUNC_COUNT,
                                                    X509EncodeFuncTable,
                                                    0)))
            {
                //goto CryptInstallOIDFunctionAddressError;
		goto ErrorReturn;
            }

            if (!(CryptInstallOIDFunctionAddress(   hInst,
                                                    X509_ASN_ENCODING,
                                                    CRYPT_OID_DECODE_OBJECT_FUNC,
                                                    X509_DECODE_FUNC_COUNT,
                                                    X509DecodeFuncTable,
                                                    0)))
            {
                //goto CryptInstallOIDFunctionAddressError;
		goto ErrorReturn;
            }


            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:
        default:
            break;
    }

    fRet = TRUE;

CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

//TRACE_ERROR(CryptInstallOssGlobalError)
//TRACE_ERROR(CryptInitOIDFunctionSetError)
//TRACE_ERROR(CryptInstallOIDFunctionAddressError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1997

Module Name:

    makefile.inc.

!ENDIF

RESDEPENDFILES = \
    res.hm \
    $(O)\msg.rc \
    $(O)\msg00001.bin

$(O)\csocm.res:	$(RESDEPENDFILES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\cspenum.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cspenum.h
//
//--------------------------------------------------------------------------

#ifndef _CSPENUM_H_
#define _CSPENUM_H_

HRESULT
SetCertSrvCSP(
    IN BOOL fEncryptionCSP,
    IN WCHAR const *pwszCAName,
    IN DWORD dwProvType,
    IN WCHAR const *pwszProvName,
    IN ALG_ID idAlg,
    IN BOOL fMachineKeyset,
    IN DWORD dwKeySize);

HRESULT GetCSPInfoList(CSP_INFO** pCSPInfoList);
void FreeCSPInfoList(CSP_INFO* pCSPInfoList);
CSP_INFO* topCSPInfoList(CSP_INFO *pCSPInfoList);
CSP_INFO* findCSPInfoFromList(
    CSP_INFO    *pCSPInfoList,
    WCHAR const *pwszProvName,
    const DWORD  dwProvType);

CSP_HASH *topHashInfoList(CSP_HASH *pHashInfoList);

CSP_INFO *
newCSPInfo(
    DWORD    dwProvType,
    WCHAR   *pwszProvName);

void 
freeCSPInfo(CSP_INFO *pCSPInfo);

CSP_INFO*
findCSPInfoFromList(
    CSP_INFO    *pCSPInfoList,
    WCHAR const *pwszProvName,
    const DWORD  dwProvType);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\dssetup.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dssetup.h
//
//--------------------------------------------------------------------------

#ifndef __DSSETUP_H__
#define __DSSETUP_H__

//+------------------------------------------------------------------------
//
//  File:	dssetup.h
// 
//  Contents:	Header file for DS setup utility functions.
//
//  Functions:
//
//  History:	1/98	xtan	Created
//
//-------------------------------------------------------------------------

BOOL IsDSAvailable(OPTIONAL bool* pfIsOldDSVersion);
HRESULT CreateCertDSHierarchy(VOID);
HRESULT InitializeCertificateTemplates(VOID);
HRESULT AddCAMachineToCertPublishers(VOID);
HRESULT RemoveCAMachineFromCertPublishers(VOID);

HRESULT
RemoveCAInDS(
    IN WCHAR const *pwszSanitizedName);

BOOL
IsCAExistInDS(
    IN WCHAR const *pwszSanitizedName);

HRESULT CurrentUserCanInstallCA(bool& fCanInstall);

#endif // __SETUPUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\dssetup.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        setup.cpp
//
// Contents:    
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include <accctrl.h>
#include <ntldap.h>
#include "certca.h"
#include "cainfop.h"
#include "csldap.h"
#include "dssetup.h"



#define __dwFILE__	__dwFILE_OCMSETUP_DSSETUP_CPP__


typedef HRESULT (* LPFNDLL_INSTALL)(BOOL bInstall, LPCWSTR pszCmdLine);


BOOL
IsCAExistInDS(
    IN WCHAR const *pwszSanitizedName)
{
    BOOL       exist = FALSE;
    HRESULT    hr;
    HCAINFO    hCAInfo = NULL;
    WCHAR *pwszDSName = NULL;

    hr = mySanitizedNameToDSName(pwszSanitizedName, &pwszDSName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    hr = CAFindByName(
		pwszDSName,
		NULL,
		CA_FIND_INCLUDE_UNTRUSTED | CA_FIND_INCLUDE_NON_TEMPLATE_CA,
		&hCAInfo);
    _JumpIfErrorStr(hr, error, "IsCAExistInDS:CAFindByName", pwszDSName);

    if (NULL == hCAInfo)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "invalid CA in DS");
    }
    exist = TRUE;

error:
    if (NULL != pwszDSName)
    {
        LocalFree(pwszDSName);
    }
    if (NULL != hCAInfo)
    {
        CACloseCA(hCAInfo);
    }
    return exist;
}




BOOL
IsDSAvailable(
    OPTIONAL OUT bool *pfIsOldDSVersion)
{
    HRESULT hr;
    BOOL available = FALSE;
    LDAP *pld = NULL;
    HMODULE hMod = NULL;

    if (NULL != pfIsOldDSVersion)
    {
        *pfIsOldDSVersion = false;
    }

    // fail out quickly if DS not present on domain

    hr = myDoesDSExist(FALSE);
    _JumpIfError(hr, error, "myDoesDSExist");

    hMod = LoadLibrary(L"wldap32.dll");
    if (NULL == hMod)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "LoadLibrary", L"wldap32.dll");
    }
    available = TRUE;

    // If the caller is checking for an old DS, turn on RLBF_REQUIRE_LDAP_INTEG
    // to test for the presence of a required DS bug fix:

    hr = myRobustLdapBindEx(
			0,			  // dwFlags1
			(NULL != pfIsOldDSVersion?
			    RLBF_REQUIRE_LDAP_INTEG : 0) |
			    RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
			LDAP_VERSION2,		  // uVersion
			NULL,			  // pwszDomainName
			&pld,
			NULL);			  // ppwszForestDNSName
    if (NULL != pfIsOldDSVersion &&
	CERTSRV_E_DOWNLEVEL_DC_SSL_OR_UPGRADE == hr)
    {
	*pfIsOldDSVersion = true;
    }
    _JumpIfError(hr, error, "myRobustLdapBindEx");

error:
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    if (NULL != hMod)
    {
        FreeLibrary(hMod);
    }
    return available;
}


HRESULT
RemoveCAInDS(
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT    hr;
    HCAINFO    hCAInfo = NULL;
    WCHAR *pwszDSName = NULL;

    hr = mySanitizedNameToDSName(pwszSanitizedName, &pwszDSName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    hr = CAFindByName(
		pwszDSName,
		NULL,
		CA_FIND_INCLUDE_UNTRUSTED | CA_FIND_INCLUDE_NON_TEMPLATE_CA,
		&hCAInfo);
    _JumpIfErrorStr(hr, error, "RemoveCAInDS:CAFindByName", pwszDSName);

    if (NULL == hCAInfo)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "invalid CA in DS");
    }
    hr = CADeleteCA(hCAInfo);
    _JumpIfError(hr, error, "CADeleteCA");

    hr = RemoveCAMachineFromCertPublishers();
    _JumpIfError(hr, error, "RemoveCAMachineFromCertPublishers");

    if(FIsAdvancedServer())
    {
        hr = RemoveCAMachineFromPreWin2kGroup();
        _JumpIfError(hr, error, "RemoveCAMachineFromPreWin2kGroup");
    }

error:
    if (NULL != pwszDSName)
    {
        LocalFree(pwszDSName);
    }
    if (NULL != hCAInfo)
    {
        CACloseCA(hCAInfo);
    }
    return hr;
}


HRESULT
CreateCertDSHierarchy(VOID)
{

    HRESULT hr = S_OK;
    ULONG   ldaperr;
    LDAP *pld = NULL;
    LDAPMod objectClass;

    WCHAR *objectClassVals[3];
    LDAPMod *mods[2];
    BSTR     bstrConfigDN = NULL;

    WCHAR * awszLocations[] = {
        L"CN=Public Key Services,CN=Services,",
        L"CN=Enrollment Services,CN=Public Key Services,CN=Services,",
        NULL,
    };

    WCHAR ** pwszCurLocation;
    DWORD                    cbBuffer;
    BSTR                     bstrBuffer = NULL;

    // bind to ds

    hr = myLdapOpen(
		NULL,		// pwszDomainName
		RLBF_REQUIRE_SECURE_LDAP, // dwFlags
		&pld,
		NULL,		// pstrDomainDN
		&bstrConfigDN);
    _JumpIfError(hr, error, "myLdapOpen");

    pwszCurLocation = awszLocations;
    // Build the Public Key Services container
    mods[0] = &objectClass;
    mods[1] = NULL;

    objectClass.mod_op = 0;
    objectClass.mod_type = TEXT("objectclass");
    objectClass.mod_values = objectClassVals;

    objectClassVals[0] = TEXT("top");
    objectClassVals[1] = TEXT("container");
    objectClassVals[2] = NULL;

    while(*pwszCurLocation)
    {
        cbBuffer = wcslen(*pwszCurLocation) + wcslen(bstrConfigDN) + 1;

        // Build a string containing the CA Location
        bstrBuffer = SysAllocStringLen(NULL, cbBuffer);
        if(bstrBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        wcscpy(bstrBuffer, *pwszCurLocation);
        wcscat(bstrBuffer, bstrConfigDN);

        ldaperr = ldap_add_s(pld, bstrBuffer, mods);
        SysFreeString(bstrBuffer);
        if(ldaperr != LDAP_SUCCESS && ldaperr != LDAP_ALREADY_EXISTS)
        {
	    hr = myHLdapError(pld, ldaperr, NULL);
            goto error;
        }
        pwszCurLocation++;
    }

error:
    myLdapClose(pld, NULL, bstrConfigDN);
    return(hr);
}


// 
HRESULT InitializeCertificateTemplates(VOID)
{
    HRESULT hr = S_OK;
    DWORD   err = ERROR_SUCCESS;

    HINSTANCE hCertCli = NULL;
    LPFNDLL_INSTALL lpfnDllInstall = NULL;

    hCertCli = LoadLibrary(L"certcli.dll");
    if(hCertCli == NULL)
    {
        hr = myHLastError();
        goto error;
    }
    lpfnDllInstall = (LPFNDLL_INSTALL)GetProcAddress(hCertCli, "DllInstall");
    if(lpfnDllInstall == NULL)
    {
        hr = myHLastError();
        goto error;
    }
    err = lpfnDllInstall(TRUE, L"i");
    hr = HRESULT_FROM_WIN32(err);


error:


    return hr;

}


HRESULT 
DNStoDirectoryName(IN LPWSTR wszDNSDomain, 
                   OUT LPWSTR *pwszDN)

{
    HRESULT hr = S_OK;
    DWORD cDN;
    LPWSTR wszResult = NULL;

    LPWSTR wszCurrent, wszNext;

    if (wszDNSDomain == NULL)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "DNStoDirectoryName");
    }

    if(0==wcsncmp(wszDNSDomain, L"\\\\", 2))
    {
        // this is a DC DNS name, skip the machine name
        wszDNSDomain = wcschr(wszDNSDomain, L'.');
        
        // no dot found?
        if(!wszDNSDomain)
        {
            hr =E_UNEXPECTED;
            _JumpError(hr, error, "DC DNS doesn't contain at least one dot");
        }
        
        // jump over the dot
        wszDNSDomain++;

        // no domain name following the DC name?
        if(L'\0'==*wszDNSDomain)
        {
            hr = E_UNEXPECTED;
            _JumpError(hr, error, "DC DNS name doesn't contain a domain name");
        }
    }

    // Estimate the size of the output string
    cDN = wcslen(wszDNSDomain) + 3;

    wszCurrent=wszDNSDomain;

    for (;;)
    {
	wszCurrent = wcschr(wszCurrent, L'.');
	if (NULL == wszCurrent)
	{
	    break;
	}
        cDN += 4;  // sizeof ,DC= 
        wszCurrent++;
    }
    cDN += 1; // NULL terminate

    wszResult = (LPWSTR)LocalAlloc(LMEM_FIXED, cDN * sizeof(WCHAR));
    
    if(wszResult == NULL)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    wszCurrent=wszDNSDomain;

    // prepend the first DC=
    wszNext = wszResult + 3;
    wcscpy(wszResult, L"DC=");
    while(*wszCurrent)
    {
        if(*wszCurrent != '.')
        {
            *wszNext++ = *wszCurrent++;
        }
        else
        {
            wszCurrent++;
            if(*wszCurrent)
            {
                wcscpy(wszNext, L",DC=");
                wszNext += 4;
            }
        }
    }
    *wszNext = 0;

    if(pwszDN)
    {
        *pwszDN = wszResult;
        wszResult = NULL;
    }
error:

    if(wszResult)
    {
        LocalFree(wszResult);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\cspenum.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cspenum.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <tchar.h>
#include <assert.h>

#include "initcert.h"
#include "cscsp.h"
#include "cspenum.h"
#include "certmsg.h"


#define __dwFILE__	__dwFILE_OCMSETUP_CSPENUM_CPP__


WCHAR const g_wszRegKeyCSP[] = wszREGKEYCSP;
WCHAR const g_wszRegKeyEncryptionCSP[] = wszREGKEYENCRYPTIONCSP;
WCHAR const g_wszRegProviderType[] = wszREGPROVIDERTYPE;
WCHAR const g_wszRegProvider[] = wszREGPROVIDER;
WCHAR const g_wszRegHashAlgorithm[] = wszHASHALGORITHM;
TCHAR const g_wszRegEncryptionAlgorithm[] = wszENCRYPTIONALGORITHM;
WCHAR const g_wszRegMachineKeyset[] = wszMACHINEKEYSET;
WCHAR const g_wszRegKeySize[] = wszREGKEYSIZE;


// Hash Enumeration code begins
// move point to link list top
CSP_HASH* 
topHashInfoList(CSP_HASH *pHashInfoList)
{
    while (pHashInfoList->last)
    {
        pHashInfoList = pHashInfoList->last;
    }
    return pHashInfoList;
}

// move point to link list end
CSP_HASH* 
endHashInfoList(CSP_HASH *pHashInfoList)
{
    while (pHashInfoList->next)
    {
        pHashInfoList = pHashInfoList->next;
    }
    return pHashInfoList;
}

// add one more CSP_INFO
void 
addHashInfo(CSP_HASH *pHashInfoList, CSP_HASH *pHashInfo)
{
    // add
    pHashInfoList->next = pHashInfo;
    pHashInfo->last = pHashInfoList;
}

// add one more CSP_INFO to end
void 
addHashInfoToEnd(CSP_HASH *pHashInfoList, CSP_HASH *pHashInfo)
{
    // go to end
    pHashInfoList = endHashInfoList(pHashInfoList);
    // add
    pHashInfoList->next = pHashInfo;
    pHashInfo->last = pHashInfoList;
}

CSP_HASH *
newHashInfo(
    ALG_ID idAlg,
    CHAR *pszName)
{
    CSP_HASH *pHashInfo = NULL;

    if (NULL != pszName)
    {
        pHashInfo = (CSP_HASH*)LocalAlloc(LMEM_FIXED, sizeof(CSP_HASH));
        if (NULL == pHashInfo)
        {
            SetLastError((DWORD) E_OUTOFMEMORY);
        }
        else
        {
            pHashInfo->pwszName = (WCHAR*)LocalAlloc(LMEM_FIXED,
                                    (strlen(pszName)+1)*sizeof(WCHAR));
            if (NULL == pHashInfo->pwszName)
            {
		LocalFree(pHashInfo);
                SetLastError((DWORD) E_OUTOFMEMORY);
		return NULL;
            }
            else
            {
                // create a new one
                pHashInfo->idAlg = idAlg;
                mbstowcs(pHashInfo->pwszName, pszName, strlen(pszName)+1);
                pHashInfo->last = NULL;
                pHashInfo->next = NULL;
            }
        }
    }
    return pHashInfo;
}


void 
freeHashInfo(CSP_HASH *pHashInfo)
{
    if (pHashInfo)
    {
        if (pHashInfo->pwszName)
        {
            LocalFree(pHashInfo->pwszName);
        }
        LocalFree(pHashInfo);
    }
}

void
freeHashInfoList(
    CSP_HASH *pHashInfoList)
{
    CSP_HASH *pNext;

    if (pHashInfoList)
    {
        // go top
        pHashInfoList = topHashInfoList(pHashInfoList);
        do
        {
			pNext = pHashInfoList->next;
            freeHashInfo(pHashInfoList);
            pHashInfoList = pNext;
        } while (pHashInfoList);
    }
}

HRESULT
GetHashList(
    DWORD dwProvType,
    WCHAR *pwszProvName,
    CSP_HASH **pHashInfoList)
{
    HRESULT       hr;
    HCRYPTPROV    hProv = NULL;
    CHAR          *pszName = NULL;
    DWORD         i;
    ALG_ID       *pidAlg;
    DWORD         cbData;
    BYTE         *pbData;
    DWORD         dwFlags;

    BOOL          fSupportSigningFlag = FALSE; // none-ms csp likely
    PROV_ENUMALGS_EX EnumAlgsEx;
    PROV_ENUMALGS    EnumAlgs;

    CSP_HASH      *pHashInfo = NULL;
    CSP_HASH      *pHashInfoNode;

    if (NULL == pwszProvName)
    {
        // the reason why I check this because
        // NULL is a valid input for CryptAcquireContext()
        hr = E_INVALIDARG;
	_JumpError(hr, error, "no provider name");
    }
    if (!myCertSrvCryptAcquireContext(
				&hProv,
				NULL,
				pwszProvName,
				dwProvType,
				CRYPT_VERIFYCONTEXT,
				FALSE))
    {
        hr = myHLastError();
        if (NULL != hProv)
        {
            hProv = NULL;
            _PrintError(hr, "CSP returns a non-null handle");
        }
	_JumpErrorStr(hr, error, "myCertSrvCryptAcquireContext", pwszProvName);
    }

    // check if csp support signing flag
    if (CryptGetProvParam(hProv, PP_ENUMEX_SIGNING_PROT, NULL, &cbData, 0))
    {
        fSupportSigningFlag = TRUE;
    }

    dwFlags = CRYPT_FIRST;
    for (i = 0; ; dwFlags = 0, i++)
    {
	DWORD const *pdwProtocols;

        if (fSupportSigningFlag)
        {
	    pdwProtocols = &EnumAlgsEx.dwProtocols;
	    pidAlg = &EnumAlgsEx.aiAlgid;
            cbData = sizeof(EnumAlgsEx);
	    pbData = (BYTE *) &EnumAlgsEx;
        }
        else
        {
	    pdwProtocols = NULL;
	    pidAlg = &EnumAlgs.aiAlgid;
	    cbData = sizeof(EnumAlgs);
	    pbData = (BYTE *) &EnumAlgs;
        }
	ZeroMemory(pbData, cbData);
	if (!CryptGetProvParam(
			    hProv,
			    fSupportSigningFlag?
				PP_ENUMALGS_EX : PP_ENUMALGS,
			    pbData,
			    &cbData,
			    dwFlags))
	{
	    hr = myHLastError();
	    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
	    {
		// out of for loop
		break;
	    }
	    _JumpError(hr, error, "CryptGetProvParam");
	}
	if (ALG_CLASS_HASH == GET_ALG_CLASS(*pidAlg))
	{
            if (fSupportSigningFlag)
            {
                if (0 == (CRYPT_FLAG_SIGNING & *pdwProtocols))
                {
                    // this means this hash doesn't support signing
                    continue; // skip
                }
                pszName = EnumAlgsEx.szLongName;
                pszName = EnumAlgsEx.szName;
            }
            else
            {
                pszName = EnumAlgs.szName;
            }

	    pHashInfoNode = newHashInfo(*pidAlg, pszName); // 2nd parm: name
	    if (NULL == pHashInfoNode)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "newHashInfo");
	    }

	    if (NULL == pHashInfo)
	    {
		pHashInfo = pHashInfoNode;
	    }
	    else
	    {
		// add to temp list
		addHashInfoToEnd(pHashInfo, pHashInfoNode);
	    }
        }
    }

    // pass it back to caller
    *pHashInfoList = pHashInfo;
    pHashInfo = NULL;
    hr = S_OK;

error:
    if (NULL != pHashInfo)
    {
	freeHashInfoList(pHashInfo);
    }
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    return hr;
}


// CSP Enumeration code begins
// move point to link list top
CSP_INFO* 
topCSPInfoList(CSP_INFO *pCSPInfoList)
{
    while (pCSPInfoList->last)
    {
        pCSPInfoList = pCSPInfoList->last;
    }
    return pCSPInfoList;
}


// move point to link list end
CSP_INFO* 
endCSPInfoList(CSP_INFO *pCSPInfoList)
{
    while (pCSPInfoList->next)
    {
        pCSPInfoList = pCSPInfoList->next;
    }
    return pCSPInfoList;
}

// find first matched csp info from the list
CSP_INFO*
findCSPInfoFromList(
    CSP_INFO    *pCSPInfoList,
    WCHAR const *pwszProvName,
    const DWORD  dwProvType)
{
    while (NULL != pCSPInfoList)
    {
        if (0 == mylstrcmpiL(pCSPInfoList->pwszProvName, pwszProvName) &&
            pCSPInfoList->dwProvType == dwProvType)
        {
            // found it
            break;
        }
        pCSPInfoList = pCSPInfoList->next;
    }
    return pCSPInfoList;
}

// add one more CSP_INFO
void 
addCSPInfo(CSP_INFO *pCSPInfoList, CSP_INFO *pCSPInfo)
{
    // add
    pCSPInfoList->next = pCSPInfo;
    pCSPInfo->last = pCSPInfoList;
}


// add one more CSP_INFO to end
void 
addCSPInfoToEnd(CSP_INFO *pCSPInfoList, CSP_INFO *pCSPInfo)
{
    // go to end
    pCSPInfoList = endCSPInfoList(pCSPInfoList);
    // add
    pCSPInfoList->next = pCSPInfo;
    pCSPInfo->last = pCSPInfoList;
}


void 
freeCSPInfo(CSP_INFO *pCSPInfo)
{
    if (pCSPInfo)
    {
        if (pCSPInfo->pwszProvName)
        {
            LocalFree(pCSPInfo->pwszProvName);
        }
        if (pCSPInfo->pHashList)
        {
            freeHashInfoList(pCSPInfo->pHashList);
        }
        LocalFree(pCSPInfo);
    }
}


CSP_INFO *
newCSPInfo(
    DWORD    dwProvType,
    WCHAR   *pwszProvName)
{
    CSP_INFO *pCSPInfo = NULL;
    CSP_HASH *pHashList = NULL;

    if (NULL != pwszProvName)
    {
        // get all hash algorithms under this csp
        if (S_OK != GetHashList(dwProvType, pwszProvName, &pHashList))
        {
            // certsrv needs csp with hash support
            goto done;
        }
        else
        {
            pCSPInfo = (CSP_INFO*)LocalAlloc(LMEM_FIXED, sizeof(CSP_INFO));
            if (NULL == pCSPInfo)
            {
                freeHashInfoList(pHashList);
                SetLastError((DWORD) E_OUTOFMEMORY);
            }
            else
            {
                pCSPInfo->pwszProvName = (WCHAR*)LocalAlloc(LMEM_FIXED,
                              (wcslen(pwszProvName) + 1) * sizeof(WCHAR));
                if (NULL == pCSPInfo->pwszProvName)
                {
                    freeHashInfoList(pHashList);
		    LocalFree(pCSPInfo);
                    pCSPInfo = NULL;
                    SetLastError((DWORD) E_OUTOFMEMORY);
		    goto done;
                }
                else
                {
                    // create a new one
                    pCSPInfo->dwProvType = dwProvType;
                    pCSPInfo->fMachineKeyset = TRUE; // assume???
                    wcscpy(pCSPInfo->pwszProvName, pwszProvName);
                    pCSPInfo->pHashList = pHashList;
                    pCSPInfo->last = NULL;
                    pCSPInfo->next = NULL;
                }
            }
        }
    }
done:
    return pCSPInfo;
}


void
FreeCSPInfoList(CSP_INFO *pCSPInfoList)
{
    CSP_INFO *pNext;

    if (pCSPInfoList)
    {
        // go top
        pCSPInfoList = topCSPInfoList(pCSPInfoList);
        do
        {
            pNext = pCSPInfoList->next;
            freeCSPInfo(pCSPInfoList);
            pCSPInfoList = pNext;
        } while (pCSPInfoList);
    }
}

HRESULT
GetCSPInfoList(CSP_INFO **pCSPInfoList)
{
    HRESULT hr;
    long i;
    DWORD dwProvType;
    WCHAR *pwszProvName = NULL;
    CSP_INFO *pCSPInfo = NULL;
    CSP_INFO *pCSPInfoNode;

    for (i = 0; ; i++)
    {
	// get provider name

	hr = myEnumProviders(
			i,
			NULL,
			0,
			&dwProvType,
			&pwszProvName);
	if (S_OK != hr)
	{
	    hr = myHLastError();
	    CSASSERT(
		HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr ||
		NTE_FAIL == hr);
	    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr ||
		NTE_FAIL == hr)
	    {
		// no more providers under type, terminate loop
		break;
	    }

	    // invalid CSP entry, skip it

	    continue;
	}
	
        if (PROV_RSA_FULL == dwProvType ||
	        PROV_RSA_SIG == dwProvType ||
	        PROV_DSS == dwProvType ||
	        PROV_MS_EXCHANGE == dwProvType ||
	        PROV_SSL == dwProvType)
	    {
	        if (NULL == pCSPInfo)
	        {
		    // first csp info
		    pCSPInfo = newCSPInfo(dwProvType, pwszProvName);
	        }
	        else
	        {
		    // create a node
		    pCSPInfoNode = newCSPInfo(dwProvType, pwszProvName);
		    if (NULL != pCSPInfoNode)
		    {
		        // add to list
		        addCSPInfoToEnd(pCSPInfo, pCSPInfoNode);
		    }
	        }
	    }
	LocalFree(pwszProvName);
	pwszProvName = NULL;
    }

    // pass back to caller

    *pCSPInfoList = pCSPInfo;
    hr = S_OK;

//error:
    if (NULL != pwszProvName)
    {
	LocalFree(pwszProvName);
    }
    return(hr);
}


HRESULT
SetCertSrvCSP(
    IN BOOL fEncryptionCSP,
    IN WCHAR const *pwszCAName,
    IN DWORD dwProvType,
    IN WCHAR const *pwszProvName,
    IN ALG_ID idAlg,
    IN BOOL fMachineKeyset,
    IN DWORD dwKeySize)
{
    HRESULT hr;
    HKEY hCertSrvKey = NULL;
    HKEY hCertSrvCAKey = NULL;
    HKEY hCertSrvCSPKey = NULL;
    DWORD dwDisposition;
    
    hr = RegCreateKeyEx(
		    HKEY_LOCAL_MACHINE,
		    wszREGKEYCONFIGPATH,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_ALL_ACCESS,
		    NULL,
		    &hCertSrvKey,
		    &dwDisposition);
    _JumpIfErrorStr(hr, error, "RegCreateKeyEx", wszREGKEYCONFIGPATH);

    hr = RegCreateKeyEx(
		    hCertSrvKey,
		    pwszCAName,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_ALL_ACCESS,
		    NULL,
		    &hCertSrvCAKey,
		    &dwDisposition);
    _JumpIfErrorStr(hr, error, "RegCreateKeyEx", pwszCAName);

    hr = RegCreateKeyEx(
		    hCertSrvCAKey,
		    fEncryptionCSP? g_wszRegKeyEncryptionCSP : g_wszRegKeyCSP,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_ALL_ACCESS,
		    NULL,
		    &hCertSrvCSPKey,
		    &dwDisposition);
    _JumpIfErrorStr(hr, error, "RegCreateKeyEx", g_wszRegKeyCSP);

    hr = RegSetValueEx(
		    hCertSrvCSPKey,
		    g_wszRegProviderType,
		    0,
		    REG_DWORD,
		    (BYTE const *) &dwProvType,
		    sizeof(dwProvType));
    _JumpIfErrorStr(hr, error, "RegSetValueEx", g_wszRegProviderType);

    hr = RegSetValueEx(
		    hCertSrvCSPKey,
		    g_wszRegProvider,
		    0,
		    REG_SZ,
		    (BYTE const *) pwszProvName,
		    wcslen(pwszProvName) * sizeof(WCHAR));
    _JumpIfErrorStr(hr, error, "RegSetValueEx", g_wszRegProvider);

    hr = RegSetValueEx(
		    hCertSrvCSPKey,
		    fEncryptionCSP? 
			g_wszRegEncryptionAlgorithm :
			g_wszRegHashAlgorithm,
		    0,
		    REG_DWORD,  // questionable???
		    (BYTE const *) &idAlg,
		    sizeof(idAlg));
    _JumpIfErrorStr(hr, error, "RegSetValueEx", g_wszRegHashAlgorithm);

    hr = RegSetValueEx(
		    hCertSrvCSPKey,
		    g_wszRegMachineKeyset,
		    0,
		    REG_DWORD,
		    (BYTE const *) &fMachineKeyset,
		    sizeof(fMachineKeyset));
    _JumpIfErrorStr(hr, error, "RegSetValueEx", g_wszRegMachineKeyset);

    if (0 != dwKeySize)
    {
	hr = RegSetValueEx(
		    hCertSrvCSPKey,
		    g_wszRegKeySize,
		    0,
		    REG_DWORD,
		    (BYTE const *) &dwKeySize,
		    sizeof(dwKeySize));
	_JumpIfErrorStr(hr, error, "RegSetValueEx", g_wszRegKeySize);
    }

error:
    if (NULL != hCertSrvCSPKey)
    {
        RegCloseKey(hCertSrvCSPKey);
    }
    if (NULL != hCertSrvCAKey)
    {
        RegCloseKey(hCertSrvCAKey);
    }
    if (NULL != hCertSrvKey)
    {
        RegCloseKey(hCertSrvKey);
    }
    return(myHError(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\pfximpt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pfximpt.cpp
//
//  Contents:   PFX import dialog
//
//  History:    06/98   xtan
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "cscsp.h"
#include "certmsg.h"
#include "initcert.h"
#include "setuput.h"
#include "cspenum.h"
#include "wizpage.h"
#include "usecert.h"


#define __dwFILE__      __dwFILE_OCMSETUP_PFXIMPT_CPP__


typedef struct _certpfximportinfo
{
    HINSTANCE hInstance;
    BOOL      fUnattended;
    WCHAR   *pwszFileName;
    DWORD    dwFileNameSize;
    WCHAR   *pwszPassword;
    DWORD    dwPasswordSize;
} CERTPFXIMPORTINFO;

HRESULT
CertBrowsePFX(HINSTANCE hInstance, HWND hDlg)
{
    HRESULT   hr;
    WCHAR    *pwszFileNameIn = NULL;
    WCHAR    *pwszFileNameOut = NULL;
    HWND      hCtrl = GetDlgItem(hDlg, IDC_PFX_FILENAME);

    hr = myUIGetWindowText(hCtrl, &pwszFileNameIn);
    _JumpIfError(hr, error, "myUIGetWindowText");

    hr = myGetOpenFileName(
             hDlg,
             hInstance,
             IDS_IMPORT_PFX_TITLE,
             IDS_PFX_FILE_FILTER,
             0, // no def ext
             OFN_PATHMUSTEXIST | OFN_HIDEREADONLY,
             pwszFileNameIn,
             &pwszFileNameOut);
    _JumpIfError(hr, error, "myGetOpenFileName");

    if (NULL != pwszFileNameOut)
    {
        SetWindowText(hCtrl, pwszFileNameOut);
    }

    hr = S_OK;
error:
    if (NULL != pwszFileNameOut)
    {
        LocalFree(pwszFileNameOut);
    }
    if (NULL != pwszFileNameIn)
    {
        LocalFree(pwszFileNameIn);
    }
    return hr;
}

HRESULT
GetPFXInfo(
    HWND               hDlg,
    CERTPFXIMPORTINFO* pCertPfxImportInfo)
{
    HRESULT hr;
    GetWindowText(GetDlgItem(hDlg, IDC_PFX_FILENAME),
                  pCertPfxImportInfo->pwszFileName,
                  pCertPfxImportInfo->dwFileNameSize);
    if (0x0 == pCertPfxImportInfo->pwszFileName[0])
    {
        // file can't empty
        hr = E_INVALIDARG;
        CertWarningMessageBox(
            pCertPfxImportInfo->hInstance,
            pCertPfxImportInfo->fUnattended,
            hDlg,
            IDS_ERR_EMPTYPFXFILE,
            0,
            NULL);
        SetFocus(GetDlgItem(hDlg, IDC_PFX_FILENAME));
        goto error;
    }
    GetWindowText(GetDlgItem(hDlg, IDC_PFX_PASSWORD),
                  pCertPfxImportInfo->pwszPassword,
                  pCertPfxImportInfo->dwPasswordSize);
    hr = S_OK;
error:
    return hr;
}

INT_PTR CALLBACK
CertPFXFilePasswordProc(
    HWND hDlg, 
    UINT iMsg, 
    WPARAM wParam, 
    LPARAM lParam) 
{
    HRESULT hr;
    BOOL  ret = FALSE;
    int   id = IDCANCEL;
    static CERTPFXIMPORTINFO *pCertPfxImportInfo = NULL;

    switch (iMsg)
    {
        case WM_INITDIALOG:
            pCertPfxImportInfo = (CERTPFXIMPORTINFO*)lParam;
            ret = TRUE;
        break;
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_PFX_FILENAME:
                break;
                case IDC_PFX_PASSWORD:
                break;
                case IDC_PFX_BROWSE:
                    CertBrowsePFX(pCertPfxImportInfo->hInstance, hDlg);
                    ret = TRUE;
                break;
                case IDOK:
                    hr = GetPFXInfo(hDlg, pCertPfxImportInfo);
                    if (S_OK != hr)
                    {
                        break;
                    }
                    id = IDOK;
                case IDCANCEL:
                    ret = EndDialog(hDlg, id);
                break;
            }
        break;
        default:
        ret = FALSE;
    }
    return ret;
}
 
int
CertGetPFXFileAndPassword(
    IN HWND       hwnd,
    IN HINSTANCE  hInstance,
    IN BOOL       fUnattended,
    IN OUT WCHAR *pwszFileName,
    IN DWORD      dwFileNameSize,
    IN OUT WCHAR *pwszPassword,
    IN DWORD      dwPasswordSize)
{
    CERTPFXIMPORTINFO    CertPfxImportInfo =
        {hInstance, fUnattended,
         pwszFileName, dwFileNameSize,
         pwszPassword, dwPasswordSize};

    return (int) DialogBoxParam(hInstance,
              MAKEINTRESOURCE(IDD_PFXIMPORT),
              hwnd,
              CertPFXFilePasswordProc,
              (LPARAM)&CertPfxImportInfo);
}

//--------------------------------------------------------------------
HRESULT
ImportPFXAndUpdateCSPInfo(
    IN const HWND    hDlg,
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    int nDlgRet;
    BOOL bRetVal;
    WCHAR wszName[MAX_PATH];
    WCHAR wszPassword[MAX_PATH];
    CSP_INFO * pCSPInfo;
    DWORD dwCSPInfoSize;
    CASERVERSETUPINFO * pServer=pComp->CA.pServer;

    // variables that must be cleaned up
    CRYPT_KEY_PROV_INFO *pCertKeyProvInfo = NULL;
    CERT_CONTEXT const *pSavedLeafCert = NULL;

    wszName[0] = L'\0';

    // get file name & password
    if(pComp->fUnattended)
    {
        CSASSERT(NULL!=pServer->pwszPFXFile);

        if(MAX_PATH<=wcslen(pServer->pwszPFXFile)||
           NULL!=pServer->pwszPFXPassword && 
           MAX_PATH<=wcslen(pServer->pwszPFXPassword))
        {
            hr = ERROR_BAD_PATHNAME;
            CertWarningMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_PFX_FILE_OR_PASSWORD_TOO_LONG,
                    0,
                    NULL);
            _JumpError(hr, error, "PFX file name or password is too long");
        }

        wcscpy(wszName, pServer->pwszPFXFile);
        wcscpy(wszPassword, 
            pServer->pwszPFXPassword?pServer->pwszPFXPassword:L"");

        if (NULL == pServer->pCSPInfoList)
        {
            hr = GetCSPInfoList(&pServer->pCSPInfoList);
            _JumpIfError(hr, error, "GetCSPInfoList");
        }
    }
    else{
        nDlgRet = CertGetPFXFileAndPassword(
                                    hDlg,
                                    pComp->hInstance,
                                    pComp->fUnattended,
                                    wszName,
                                    sizeof(wszName)/sizeof(WCHAR),
                                    wszPassword,
                                    sizeof(wszPassword)/sizeof(WCHAR));
        if (IDOK != nDlgRet)
        {
            // cancel
            hr=HRESULT_FROM_WIN32(ERROR_CANCELLED);
            _JumpError(hr, error, "CertGetPFXFileAndPassword canceled");
        }
    }

    // import pkcs12
    hr=myCertServerImportPFX(
               wszName,
               wszPassword,
               FALSE,
               NULL,
               NULL,
               &pSavedLeafCert);
    if (S_OK != hr)
    {
        if (HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD)==hr)
        {

            // tell the user that their password was invalid
            CertWarningMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_PFX_INVALID_PASSWORD,
                    0,
                    NULL);
            _JumpError(hr, error, "myCertServerImportPFX");

        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr)
        {

            if(pComp->fUnattended)
            {
                nDlgRet=IDYES;
            }
            else
            {
                // confirm from user that they want to overwrite
                // the existing key and cert
                nDlgRet=CertMessageBox(
                            pComp->hInstance,
                            pComp->fUnattended,
                            hDlg,
                            IDS_PFX_KEYANDCERTEXIST,
                            0,
                            MB_YESNO | MB_ICONWARNING | CMB_NOERRFROMSYS,
                            NULL);
            }
            if (IDYES==nDlgRet)
            {
                hr=myCertServerImportPFX(
                           wszName,
                           wszPassword,
                           TRUE,
                           NULL,
                           NULL, 
                           &pSavedLeafCert);
                _JumpIfError(hr, errorMsg, "myCertServerImportPFX");
            }
            else
            {
                // cancel
                hr=HRESULT_FROM_WIN32(ERROR_CANCELLED);
                _JumpError(hr, error, "myCertServerImportPFX canceled");
            }
        }
        else if (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
        {
            CertWarningMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_PFX_PATH_INVALID,
                    0,
                    wszName);
            _JumpError(hr, error, "myCertServerImportPFX");
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            CertWarningMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_PFX_FILE_NOT_FOUND,
                    0,
                    wszName);
            _JumpError(hr, error, "myCertServerImportPFX");
        }
        else if (HRESULT_FROM_WIN32(CRYPT_E_SELF_SIGNED) == hr)
        {
            // this cert is not appropriate for this CA type (no CA certs found at all)
            CertWarningMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hDlg,
                IDS_PFX_WRONG_SELFSIGN_TYPE,
                S_OK, // don't show an error number
                NULL);
            _JumpError(hr, error, "This cert is not appropriate for this CA type");
        }
        else
        {
            // import failed for some other reason
            _JumpError(hr, errorMsg, "myCertServerImportPFX");
        }
    }

    // PFX import was successful. The cert is in the machine's MY store.
    CSASSERT(NULL!=pSavedLeafCert);

    // The following things have been verified by myCertServerImportPFX
    //  * The cert has an AT_SIGNATURE key
    //  * The key in the store matches the one on the cer
    //  * The cert is not expired
    //
    // We still need to check:
    //  * self-signed or not
    //  * verify chain

    // Note: IT IS VERY IMPORTANT that pfx import maintains all the
    //   invariants about CSP, key container, hash, cert validity, etc.
    //   that the rest of the UI maintains.

    // get key prov info from cert
    bRetVal=myCertGetCertificateContextProperty(
        pSavedLeafCert,
        CERT_KEY_PROV_INFO_PROP_ID,
        CERTLIB_USE_LOCALALLOC,
        (void **)&pCertKeyProvInfo,
        &dwCSPInfoSize);
    if (FALSE==bRetVal) {
        hr=myHLastError();
        _JumpError(hr, errorMsg, "myCertGetCertificateContextProperty");
    }

    // find our description of the CSP
    pCSPInfo=findCSPInfoFromList(pServer->pCSPInfoList,
        pCertKeyProvInfo->pwszProvName,
        pCertKeyProvInfo->dwProvType);
    CSASSERT(NULL!=pCSPInfo);
    if (pCSPInfo == NULL) // we don't have this CSP enumerated in our UI
    {
        hr = CRYPT_E_NOT_FOUND;
        _JumpError(hr, errorMsg, "pCSPInfo NULL");
    }

    //
    // Looks like this key is good. Use it.
    //

    // Stop using the previous cert and key
    // delete previously created key container, if necessary.
    ClearKeyContainerName(pServer);

    // update the CSP
    //   note: CSP, key container, and hash must all be consistent!
    pServer->pCSPInfo=pCSPInfo;

    hr = DetermineDefaultHash(pServer);
    _JumpIfError(hr, error, "DetermineDefaultHash");
    
    // save the name of the key container
    hr=SetKeyContainerName(pServer, pCertKeyProvInfo->pwszContainerName);
    _JumpIfError(hr, error, "SetKeyContainerName");

    //  See if we can use the cert

    // verify to make sure no cert in chain is revoked, but don't kill yourself if offline
    hr=myVerifyCertContext(
        pSavedLeafCert,
        CA_VERIFY_FLAGS_IGNORE_OFFLINE,
        0,
        NULL,
        HCCE_LOCAL_MACHINE,
        NULL,
        NULL);
    _JumpIfError(hr, errorMsg, "myVerifyCertContext");

    // See if this cert appropriately is self-signed or not.
    // A root CA cert must be self-signed, while
    // a subordinate CA cert must not be self-signed.
    hr=IsCertSelfSignedForCAType(pServer, pSavedLeafCert, &bRetVal);
    _JumpIfError(hr, errorMsg, "IsCertSelfSignedForCAType");
    if (FALSE==bRetVal) {

        // this cert is not appropriate for this CA type
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg,
            IDS_PFX_WRONG_SELFSIGN_TYPE,
            S_OK, // don't show an error number
            NULL);

        hr=CRYPT_E_SELF_SIGNED;
        _JumpError(hr, error, "This cert is not appropriate for this CA type");
    }

    //
    // Looks like this cert is good. Use it.
    //

    // save the cert and update the hash algorithm
    hr=SetExistingCertToUse(pServer, pSavedLeafCert);
    _JumpIfError(hr, error, "SetExistingCertToUse");
    pSavedLeafCert=NULL;

    hr=S_OK;

errorMsg:
    if (FAILED(hr)) {
        // an error occurred while trying to import the PFX file
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg,
            IDS_ERR_IMPORTPFX,
            hr,
            NULL);
    }

error:
    SecureZeroMemory(wszPassword, wcslen(wszPassword)*sizeof(WCHAR));
    CSILOG(
        hr,
        IDS_LOG_IMPORTPFX,
        L'\0' == wszName[0]? NULL : wszName,
        NULL,
        NULL);
    if (NULL != pSavedLeafCert)
    {
        CertFreeCertificateContext(pSavedLeafCert);
    }
    if (NULL != pCertKeyProvInfo)
    {
        LocalFree(pCertKeyProvInfo);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#define __DIR__		"ocmsetup"

#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <setupapi.h>
#include <ocmanage.h>

#include <certsrv.h>
#include "certlib.h"
#include "initcert.h"
#include "res.h"
#include "setuput.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\reg.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        reg.cpp
//
// Contents:    certsrv setup reg apis
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <assert.h>
#include <shlwapi.h>

#define __dwFILE__	__dwFILE_OCMSETUP_REG_CPP__

DWORD
mySHCopyKey(
    IN HKEY hkeySrc,
    IN LPCWSTR wszSrcSubKey,
    IN HKEY hkeyDest,
    IN DWORD fReserved)
{
    DWORD err;

    err = S_OK;
    __try
    {
	err = SHCopyKey(hkeySrc, wszSrcSubKey, hkeyDest, fReserved);
	_LeaveIfError(err, "SHCopyKey");
    }
    __except(err = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    return(err);
}


DWORD
mySHDeleteKey(
    IN HKEY hkey,
    IN LPCWSTR pszSubKey)
{
    DWORD err;

    err = S_OK;
    __try
    {
	err = SHDeleteKey(hkey, pszSubKey);
	_LeaveIfError(err, "SHDeleteKey");
    }
    __except(err = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    return(err);
}


LONG
myRegRenameKey(
  HKEY hKey,        // handle to an open key
  LPCTSTR lpSrcKey, // address of old name of subkey
  LPCTSTR lpDesKey, // address of new name of subkey
  PHKEY phkResult)   // address of buffer for opened handle of new subkey
{
	LONG lerr;
	HKEY hDesKey = NULL;

	if (NULL == lpSrcKey || NULL == lpDesKey)
	{
		lerr = ERROR_INVALID_PARAMETER;
		goto error;
	}
	
	// open destination key sure it doesn't exist
	lerr = RegOpenKeyEx(
					hKey,
					lpDesKey,
					0,
					KEY_ALL_ACCESS,
					&hDesKey);
	if (ERROR_SUCCESS == lerr)
	{
		// destination exists, stop
		lerr = ERROR_FILE_EXISTS;
		goto error;
	}
	else if (ERROR_FILE_NOT_FOUND != lerr)
	{
		goto error;
	}
	assert(NULL == hDesKey);

	lerr = RegCreateKeyEx(
				hKey,
				lpDesKey,
				0,
				NULL,
				REG_OPTION_NON_VOLATILE,
				KEY_ALL_ACCESS,
				NULL,
				&hDesKey,
				NULL);
	if (ERROR_SUCCESS != lerr)
	{
		goto error;
	}

    lerr = mySHCopyKey(hKey, lpSrcKey, hDesKey, 0);
    if (ERROR_SUCCESS != lerr)
    {
        goto error;
    }

    lerr = mySHDeleteKey(hKey, lpSrcKey);
    if (ERROR_SUCCESS != lerr)
    {
        goto error;
    }

	if (NULL != phkResult)
	{
		*phkResult = hDesKey;
		hDesKey = NULL;
	}

	// done
	lerr = ERROR_SUCCESS;
error:
	if (NULL != hDesKey)
	{
		RegCloseKey(hDesKey);
	}
	return lerr;
}


HRESULT
myRenameCertRegKey(
    IN WCHAR const *pwszSrcCAName,
    IN WCHAR const *pwszDesCAName)
{
    HRESULT  hr;
    WCHAR *pwszSrcPath = NULL;
    WCHAR *pwszDesPath = NULL;

    if (0 == mylstrcmpiL(pwszSrcCAName, pwszDesCAName))
    {
        // destination is the same as source, done
        goto done;
    }

    hr = myFormCertRegPath(pwszSrcCAName, NULL, NULL, TRUE, &pwszSrcPath);
    _JumpIfError(hr, error, "formCertRegPath");

    hr = myFormCertRegPath(pwszDesCAName, NULL, NULL, TRUE, &pwszDesPath);
    _JumpIfError(hr, error, "formCertRegPath");

    hr = myRegRenameKey(
                HKEY_LOCAL_MACHINE,
                pwszSrcPath,
                pwszDesPath,
                NULL);
    if ((HRESULT) ERROR_SUCCESS != hr)
    {
        hr = HRESULT_FROM_WIN32(hr);
        _JumpError(hr, error, "myRegMoveKey");
    }

done:
    hr = S_OK;
error:
    if (NULL != pwszSrcPath)
    {
        LocalFree(pwszSrcPath);
    }
    if (NULL != pwszDesPath)
    {
        LocalFree(pwszDesPath);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\regd.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        regd.cpp
//
// Contents:    registry functions for DCOM services
//
// History:     July-97       xtan created
//
//---------------------------------------------------------------------------
#include <pch.cpp>
#pragma hdrstop

#include <objbase.h>

#include "regd.h"


#define __dwFILE__	__dwFILE_OCMSETUP_REGD_CPP__


extern WCHAR g_wszServicePath[MAX_PATH];

BYTE g_pNoOneLaunchPermission[] = {
  0x01,0x00,0x04,0x80,0x34,0x00,0x00,0x00,
  0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x14,0x00,0x00,0x00,0x02,0x00,0x20,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x3c,0x00,0xb9,0x00,0x07,0x00,0x03,0x00,
  0x00,0x23,0x10,0x00,0x01,0x05,0x00,0x00,
  0x00,0x00,0x00,0x05,0x01,0x05,0x00,0x00,
  0x00,0x00,0x00,0x05,0x15,0x00,0x00,0x00,
  0xa0,0x5f,0x84,0x1f,0x5e,0x2e,0x6b,0x49,
  0xce,0x12,0x03,0x03,0xf4,0x01,0x00,0x00,
  0x01,0x05,0x00,0x00,0x00,0x00,0x00,0x05,
  0x15,0x00,0x00,0x00,0xa0,0x5f,0x84,0x1f,
  0x5e,0x2e,0x6b,0x49,0xce,0x12,0x03,0x03,
  0xf4,0x01,0x00,0x00};

BYTE g_pEveryOneAccessPermission[] = {
  0x01,0x00,0x04,0x80,0x34,0x00,0x00,0x00,
  0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x14,0x00,0x00,0x00,0x02,0x00,0x20,0x00,
  0x01,0x00,0x00,0x00,0x00,0x00,0x18,0x00,
  0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,
  0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x01,0x05,0x00,0x00,
  0x00,0x00,0x00,0x05,0x15,0x00,0x00,0x00,
  0xa0,0x65,0xcf,0x7e,0x78,0x4b,0x9b,0x5f,
  0xe7,0x7c,0x87,0x70,0x36,0xbb,0x00,0x00,
  0x01,0x05,0x00,0x00,0x00,0x00,0x00,0x05,
  0x15,0x00,0x00,0x00,0xa0,0x65,0xcf,0x7e,
  0x78,0x4b,0x9b,0x5f,0xe7,0x7c,0x87,0x70,
  0x36,0xbb,0x00,0x00 };


//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//

HRESULT
setKeyAndValue(
    const WCHAR *wszKey,
    const WCHAR *wszSubkey,
    const WCHAR *wszValueName,
    const WCHAR *wszValue)
{
    HKEY hKey = NULL;
    HRESULT hr;
    WCHAR wszKeyBuf[MAX_PATH];

    // Copy keyname into buffer.
    if (wcslen(wszKey) >= ARRAYSIZE(wszKeyBuf))
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpErrorStr(hr, error, "wszKeyBuf", wszKey);
    }
    wcscpy(wszKeyBuf, wszKey);

    // Add subkey name to buffer.
    if (wszSubkey != NULL)
    {
	if (wcslen(wszKeyBuf) + 1 + wcslen(wszSubkey) >= ARRAYSIZE(wszKeyBuf))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    _JumpErrorStr(hr, error, "wszKeyBuf", wszKey);
	}
	wcscat(wszKeyBuf, L"\\");
	wcscat(wszKeyBuf, wszSubkey);
    }

    // Create and open key and subkey.
    hr = RegCreateKeyEx(
		    HKEY_CLASSES_ROOT,
		    wszKeyBuf,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_ALL_ACCESS,
		    NULL,
		    &hKey,
		    NULL);
    _JumpIfError(hr, error, "RegCreateKeyEx");

    // Set the Value.
    if (NULL != wszValue)
    {
	RegSetValueEx(
		    hKey,
		    wszValueName,
		    0,
		    REG_SZ,
		    (BYTE *) wszValue,
		    (wcslen(wszValue) + 1) * sizeof(WCHAR));
	_JumpIfError(hr, error, "RegSetValueEx");
    }

error:
    if (NULL != hKey)
    {
	RegCloseKey(hKey);
    }
    return(hr);
}


HRESULT
setCertSrvPermission(
    const WCHAR *wszKey)
{
    HKEY hKey = NULL;
    HRESULT hr;

    // create and open key
    hr = RegCreateKeyEx(
		    HKEY_CLASSES_ROOT,
		    wszKey,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_ALL_ACCESS,
		    NULL,
		    &hKey,
		    NULL);
    _JumpIfError(hr, error, "RegCreateKeyEx");

    // set access permission
    hr = RegSetValueEx(
		    hKey,
		    L"AccessPermission",
		    0,
		    REG_BINARY,
		    g_pEveryOneAccessPermission,
		    sizeof(g_pEveryOneAccessPermission));
    _JumpIfError(hr, error, "RegSetValueEx");

    // set access permission
    hr = RegSetValueEx(
		    hKey,
		    L"LaunchPermission",
		    0,
		    REG_BINARY,
		    g_pNoOneLaunchPermission,
		    sizeof(g_pNoOneLaunchPermission));
    _JumpIfError(hr, error, "RegSetValueEx");

error:
    if (NULL != hKey)
    {
	RegCloseKey(hKey);
    }
    return(hr);
}


// Convert a CLSID to a char string.

HRESULT
CLSIDtochar(
    IN const CLSID& clsid,
    OUT WCHAR *pwszOut,
    IN DWORD cwcOut)
{
    HRESULT hr;
    WCHAR *pwszTmp = NULL;

    if (1 <= cwcOut)
    {
	pwszOut[0] = L'\0';
    }
    hr = StringFromCLSID(clsid, &pwszTmp);
    _JumpIfError(hr, error, "StringFromCLSID");

    if (wcslen(pwszTmp) >= cwcOut)
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpError(hr, error, "pwszTmp");
    }
    wcscpy(pwszOut, pwszTmp);
    hr = S_OK;

error:
    if (NULL != pwszTmp)
    {
	CoTaskMemFree(pwszTmp);
    }
    return(hr);
}


// Determine if a particular subkey exists.
//
BOOL
SubkeyExists(
    const WCHAR *wszPath,	// Path of key to check
    const WCHAR *wszSubkey)	// Key to check
{
    HRESULT hr;
    HKEY hKey;
    WCHAR wszKeyBuf[MAX_PATH];

    // Copy keyname into buffer.
    if (wcslen(wszPath) >= ARRAYSIZE(wszKeyBuf))
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpErrorStr(hr, error, "wszKeyBuf", wszPath);
    }
    wcscpy(wszKeyBuf, wszPath);

    // Add subkey name to buffer.
    if (wszSubkey != NULL)
    {
	if (wcslen(wszKeyBuf) + 1 + wcslen(wszSubkey) >= ARRAYSIZE(wszKeyBuf))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    _JumpErrorStr(hr, error, "wszKeyBuf", wszPath);
	}
	wcscat(wszKeyBuf, L"\\");
	wcscat(wszKeyBuf, wszSubkey);
    }

    // Determine if key exists by trying to open it.
    hr = RegOpenKeyEx(
		    HKEY_CLASSES_ROOT,
		    wszKeyBuf,
		    0,
		    KEY_ALL_ACCESS,
		    &hKey);

    if (S_OK == hr)
    {
	RegCloseKey(hKey);
    }

error:
    return(S_OK == hr);
}


// Delete a key and all of its descendents.
//

HRESULT
recursiveDeleteKey(
    HKEY hKeyParent,           // Parent of key to delete
    const WCHAR *wszKeyChild)  // Key to delete
{
    HRESULT hr;
    FILETIME time;
    WCHAR wszBuffer[MAX_PATH];
    DWORD dwSize;

    HKEY hKeyChild = NULL;

    // Open the child.
    hr = RegOpenKeyEx(hKeyParent, wszKeyChild, 0, KEY_ALL_ACCESS, &hKeyChild);
    _JumpIfError2(hr, error, "RegOpenKeyEx", ERROR_FILE_NOT_FOUND);

    // Enumerate all of the decendents of this child.

    for (;;)
    {
	dwSize = sizeof(wszBuffer)/sizeof(wszBuffer[0]);
	hr = RegEnumKeyEx(
			hKeyChild,
			0,
			wszBuffer,
			&dwSize,
			NULL,
			NULL,
			NULL,
			&time);
	if (S_OK != hr)
	{
	    break;
	}

	// Delete the decendents of this child.
	hr = recursiveDeleteKey(hKeyChild, wszBuffer);
	_JumpIfError(hr, error, "recursiveDeleteKey");
    }

    // Delete this child.
    hr = RegDeleteKey(hKeyParent, wszKeyChild);
    _JumpIfError(hr, error, "RegDeleteKey");

error:
    if (NULL != hKeyChild)
    {
	// Close the child.
	RegCloseKey(hKeyChild);
    }
    return(myHError(hr));
}


///////////////////////////////////////////////////////
//
// RegisterDcomServer -- Register the component in the registry.
//

HRESULT
RegisterDcomServer(
    IN BOOL fCreateAppIdInfo,
    IN const CLSID& clsidAppId,		// AppId Class ID
    IN const CLSID& clsid,		// Class ID
    IN const WCHAR *wszFriendlyName,	// Friendly Name
    IN const WCHAR *wszVerIndProgID,	// Programmatic
    IN const WCHAR *wszProgID)      	// IDs
{
    HRESULT hr;

    // Convert the CLSID into a char.
    WCHAR wszCLSID[CLSID_STRING_SIZE];
    WCHAR wszCLSIDAppId[CLSID_STRING_SIZE];

    CLSIDtochar(clsid, wszCLSID, ARRAYSIZE(wszCLSID));
    CLSIDtochar(clsidAppId, wszCLSIDAppId, ARRAYSIZE(wszCLSIDAppId));

    // Build the key CLSID\\{...}
    WCHAR wszKey[64];

    if (fCreateAppIdInfo)
    {
	//--------------------------------------
	// AppID\{ClassIdAppId}\(Default) = wszFriendlyName
	// AppID\{ClassIdAppId}\LocalService = wszSERVICE_NAME
	// AppID\{ClassIdAppId}\AccessPermission = ???
	// AppID\{ClassIdAppId}\LaunchPermission = ???

	wcscpy(wszKey, L"AppID\\");
	wcscat(wszKey, wszCLSIDAppId);

	// Add App IDs
	hr = setKeyAndValue(wszKey, NULL, NULL, wszFriendlyName);
	_JumpIfError(hr, error, "setKeyAndValue");

	// run as a service
	hr = setKeyAndValue(wszKey, NULL, L"LocalService", wszSERVICE_NAME);
	_JumpIfError(hr, error, "setKeyAndValue");

	hr = setCertSrvPermission(wszKey);
	_JumpIfError(hr, error, "setCertSrvPermission");
    }

    //--------------------------------------
    // CLSID\{ClassId}\(Default) = wszFriendlyName
    // CLSID\{ClassId}\AppID = {ClassIdAppId}
    // CLSID\{ClassId}\ProgID = wszProgID
    // CLSID\{ClassId}\VersionIndependentProgID = wszVerIndProgID

    wcscpy(wszKey, L"CLSID\\");
    wcscat(wszKey, wszCLSID);

    // Add the CLSID to the registry.
    hr = setKeyAndValue(wszKey, NULL, NULL, wszFriendlyName);
    _JumpIfError(hr, error, "setKeyAndValue");

    // Add application ID
    hr = setKeyAndValue(wszKey, NULL, L"AppID", wszCLSIDAppId);
    _JumpIfError(hr, error, "setKeyAndValue");

    // Add the ProgID subkey under the CLSID key.
    hr = setKeyAndValue(wszKey, L"ProgID", NULL, wszProgID);
    _JumpIfError(hr, error, "setKeyAndValue");

    // Add the version-independent ProgID subkey under CLSID key.
    hr = setKeyAndValue(wszKey, L"VersionIndependentProgID", NULL, wszVerIndProgID);
    _JumpIfError(hr, error, "setKeyAndValue");

    //--------------------------------------
    // delete obsolete key: CLSID\{ClassId}\LocalServer32

    wcscat(wszKey, L"\\LocalServer32");

    hr = recursiveDeleteKey(HKEY_CLASSES_ROOT, L"LocalServer32");
    _PrintIfError(hr, "recursiveDeleteKey");

    //--------------------------------------
    // wszVerIndProgID\(Default) = wszFriendlyName
    // wszVerIndProgID\CLSID\(Default) = {ClassId}
    // wszVerIndProgID\CurVer\(Default) = wszProgID

    // Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
    hr = setKeyAndValue(wszVerIndProgID, NULL, NULL, wszFriendlyName);
    _JumpIfError(hr, error, "setKeyAndValue");

    hr = setKeyAndValue(wszVerIndProgID, L"CLSID", NULL, wszCLSID);
    _JumpIfError(hr, error, "setKeyAndValue");

    hr = setKeyAndValue(wszVerIndProgID, L"CurVer", NULL, wszProgID);
    _JumpIfError(hr, error, "setKeyAndValue");

    //--------------------------------------
    // wszProgID\(Default) = wszFriendlyName
    // wszProgID\CLSID\(Default) = {ClassId}

    // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
    hr = setKeyAndValue(wszProgID, NULL, NULL, wszFriendlyName);
    _JumpIfError(hr, error, "setKeyAndValue");

    hr = setKeyAndValue(wszProgID, L"CLSID", NULL, wszCLSID);
    _JumpIfError(hr, error, "setKeyAndValue");

error:
    return(hr);
}


//
// Remove the component from the registry.
//

HRESULT
UnregisterDcomServer(
    IN const CLSID& clsid,		// Class ID
    IN const WCHAR *wszVerIndProgID,	// Programmatic
    IN const WCHAR *wszProgID)		// IDs
{
    HRESULT hr;

    // Convert the CLSID into a char.
    WCHAR wszCLSID[CLSID_STRING_SIZE];
    CLSIDtochar(clsid, wszCLSID, ARRAYSIZE(wszCLSID));

    // Build the key CLSID\\{...}
    WCHAR wszKey[6 + ARRAYSIZE(wszCLSID)];
    wcscpy(wszKey, L"CLSID\\");
    wcscat(wszKey, wszCLSID);

    // Check for a another server for this component.
    if (SubkeyExists(wszKey, L"InprocServer32"))
    {
	// Delete only the path for this server.
	wcscat(wszKey, L"\\LocalServer32");
	hr = recursiveDeleteKey(HKEY_CLASSES_ROOT, wszKey);
	CSASSERT(hr == S_OK);
    }
    else
    {
	// Delete all related keys.
	// Delete the CLSID Key - CLSID\{...}
	hr = recursiveDeleteKey(HKEY_CLASSES_ROOT, wszKey);
	CSASSERT(S_OK == hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);

	// Delete the version-independent ProgID Key.
	hr = recursiveDeleteKey(HKEY_CLASSES_ROOT, wszVerIndProgID);
	CSASSERT(S_OK == hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);

	// Delete the ProgID key.
	hr = recursiveDeleteKey(HKEY_CLASSES_ROOT, wszProgID);
	CSASSERT(S_OK == hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);
    }
    wcscpy(wszKey, L"AppID\\");
    wcscat(wszKey, wszCLSID);
    hr = recursiveDeleteKey(HKEY_CLASSES_ROOT, wszKey);
    CSASSERT(S_OK == hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);

    return(hr);
}


HRESULT
RegisterDcomApp(
    IN const CLSID& clsid)
{
    HRESULT hr;

    // Convert the CLSID into a char.
    WCHAR wszCLSID[CLSID_STRING_SIZE];
    CLSIDtochar(clsid, wszCLSID, sizeof(wszCLSID)/sizeof(WCHAR));

    WCHAR wszKey[64];

    wcscpy(wszKey, L"AppID\\");
    wcscat(wszKey, wszCERTSRVEXENAME);

    // Add App IDs
    hr = setKeyAndValue(wszKey, NULL, NULL, NULL);
    _JumpIfError(hr, error, "setKeyAndValue");

    hr = setKeyAndValue(wszKey, NULL, L"AppId", wszCLSID);
    _JumpIfError(hr, error, "setKeyAndValue");

error:
    return(hr);
}


void
UnregisterDcomApp()
{
    HRESULT hr;
    WCHAR wszKey[MAX_PATH];

    wcscpy(wszKey, L"AppID\\");
    wcscat(wszKey, wszCERTSRVEXENAME);
    hr = recursiveDeleteKey(HKEY_CLASSES_ROOT, wszKey);
    CSASSERT(S_OK == hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\regd.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        regd.h
//
// Contents:    Helper functions registering and unregistering a component.
//
// History:     July-97       xtan created
//
//---------------------------------------------------------------------------
#ifndef __Regd_H__
#define __Regd_H__

// This function will register a component in the Registry.

// Size of a CLSID as a string
#define CLSID_STRING_SIZE 39


HRESULT
RegisterDcomServer(
    IN BOOL fCreateAppIdInfo,
    IN const CLSID& clsidAppId,		// AppId Class ID
    IN const CLSID& clsid, 
    IN const WCHAR *szFriendlyName,
    IN const WCHAR *szVerIndProgID,
    IN const WCHAR *szProgID);

// This function will unregister a component

HRESULT
UnregisterDcomServer(
    IN const CLSID& clsid,
    IN const WCHAR *szVerIndProgID,
    IN const WCHAR *szProgID);

HRESULT
RegisterDcomApp(
    IN const CLSID& clsid);

VOID
UnregisterDcomApp(VOID);

HRESULT
CLSIDtochar(
    IN const CLSID& clsid,
    OUT WCHAR *pwszOut,
    IN DWORD cwcOut);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\res.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       res.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by csocm.rc
//

// Important, reserve 900-999 for certlib.rc, 200-299 for setupids.h

#define IDI_APP                         201
#define IDB_APP                         221
#define IDB_PRODUCT                     222
#define IDB_WELCOME                     223

// strings from Cert Server 1.0:
#define IDS_STARTMENU_CERTHIER_LINKNAME 320
#define IDS_STARTMENU_CERTREQ_LINKNAME  321
#define IDS_STARTMENU_CERTSERVER        322
#define IDS_STARTMENU_NEWCRL_LINKNAME   323

#define IDS_ADVANCE_INVALIDKEYLENGTH    330
#define IDS_ADVANCE_KEYLENGTHOUTOFRANGE 331
#define IDS_ADVANCE_NEGATIVEKEYLENGTH   332
#define IDS_ADVANCE_SUBTITLE            333
#define IDS_ADVANCE_TITLE               334
#define IDS_ASK_CREATE_DIRECTORY        335
#define IDS_CALENSTRERR                 336
#define IDS_CANULLSTRERR                337
#define IDS_CAREQUEST_SUBTITLE          338
#define IDS_CAREQUEST_TITLE             339
#define IDS_CATYPE_DES_ENTERPRISE_ROOTCA 340
#define IDS_CATYPE_DES_ENTERPRISE_SUBCA  341
#define IDS_CATYPE_DES_STANDALONE_ROOTCA 342
#define IDS_CATYPE_DES_STANDALONE_SUBCA  343
#define IDS_CATYPE_SUBTITLE             344
#define IDS_CATYPE_TITLE                345
#define IDS_CA_SERVICEDESCRIPTION       346
#define IDS_CA_SERVICEDISPLAYNAME       347
#define IDS_CERTCONFIG_FOLDERDESCR      348
#define IDS_CLIENT_NOCA                 349
#define IDS_CLIENT_NOCOMPUTER           350
#define IDS_CLIENT_SUBTITLE             351
#define IDS_CLIENT_TITLE                352
#define IDS_COMPUTERLENSTRERR           354
#define IDS_COMPUTERNULLSTRERR          355
#define IDS_CONFIG_PICKER_PROMPT        356
#define IDS_CONFIG_PICKER_TITLE         357
#define IDS_ERR_ADDSOURCETOREGISTRY     358
#define IDS_ERR_ANALYSIS_CA             359
#define IDS_ERR_BUILDCERT               360
#define IDS_ERR_BUILDCERTREQUEST        361
#define IDS_FINAL_ERROR_TEXT            362
#define IDS_ERR_CERTSRV_SETUP_FAIL      363
#define IDS_ERR_CREATECERTSRVFILE       364
#define IDS_ERR_CREATELINK              365
#define IDS_ERR_CREATESERVICE           366
#define IDS_ERR_DELETESERVICE           367
#define IDS_ERR_DLLFUNCTION_CALL        368
#define IDS_ERR_EMPTYCANAME             369
#define IDS_ERR_EMPTYPFXFILE            370
#define IDS_ERR_FATAL_GENKEY            371
#define IDS_ERR_IMPORTPFX               372
#define IDS_ERR_INVALIDHASH             373
#define IDS_ERR_LOADICERTCONFIG         374
#define IDS_ERR_NETUSERMODALSGET        375
//#define IDS_UNUSED            	376
#define IDS_ERR_NOT_ADM                 377
#define IDS_ERR_UNSUPPORTEDHASH         378
#define IDS_ERR_WRITECONFIGFILE         379
#define IDS_IDINFO_CAEXISTINDS          380
#define IDS_IDINFO_DESCRIPTIONLENSTRERR     381
#define IDS_IDINFO_COUNTRYLENSTRERR     382
#define IDS_IDINFO_DETERMINEDBYPCA      383
#define IDS_IDINFO_EMAILLENSTRERR       384
#define IDS_IDINFO_INVALID_COUNTRYCODE  385
#define IDS_IDINFO_INVALID_COUNTRYCODE_LEN 386
#define IDS_IDINFO_INVALID_VALIDITY     387
#define IDS_IDINFO_LOCALITYLENSTRERR    388
#define IDS_IDINFO_NAMELENSTRERR        389
#define IDS_IDINFO_NAMENULLSTRERR       390
#define IDS_IDINFO_ORGLENSTRERR         391
#define IDS_IDINFO_ORGUNITLENSTRERR     392
#define IDS_IDINFO_STATELENSTRERR       393
#define IDS_IDINFO_SUBTITLE             394
#define IDS_IDINFO_TITLE                395
#define IDS_IDINFO_VALIDITYNULLSTRERR   396
#define IDS_IMPORT_PFX_TITLE            397
#define IDS_INCOMPLETE_REQUEST          398
#define IDS_KEYGEN_GENERATING           399
#define IDS_KEYGEN_PROTECTING           400
#define IDS_KEYGEN_SUBTITLE             401
#define IDS_KEYGEN_TESTINGHASHANDKEY    402
#define IDS_KEYGEN_TITLE                403
#define IDS_KEY_INVALID                 404
#define IDS_PATH_TOO_LONG_CANAME        405
#define IDS_PFX_FILE_FILTER             406
#define IDS_PFX_FILE_NOT_FOUND          407
#define IDS_PFX_INVALID_PASSWORD        408
#define IDS_PFX_KEYANDCERTEXIST         409
#define IDS_PFX_PATH_INVALID            410
#define IDS_REQUESTFILELENSTRERR        411
#define IDS_REQUESTFILENULLSTRERR       412
#define IDS_STOP_W3SVC                  413
#define IDS_STORELOC_PARENTDIRMUSTEXIST 414
#define IDS_STORELOC_PATHTOOLONG        415
#define IDS_STORELOC_UNCMUSTEXIST       416
#define IDS_STORE_SUBTITLE              417
#define IDS_STORE_TITLE                 418
#define IDS_TODO_TITLE                  419
#define IDS_VALIDITY_DAY                420
#define IDS_VALIDITY_MONTH              421
#define IDS_VALIDITY_WEEK               422
#define IDS_VALIDITY_YEAR               423
#define IDS_WRN_DBFILEINUSE             425
#define IDS_WRN_OVERWRITEEXISTINGKEY    426
#define IDS_WRN_STORELOC_DB_FULLPATH    427
#define IDS_WRN_STORELOC_EXISTINGDB     428
#define IDS_WRN_STORELOC_LOG_FULLPATH   429
#define IDS_WRN_STORELOC_SHAREDFOLDER_FULLPATH 430
#define IDS_WRN_UNICODESTRINGENCODING   431

#define IDS_LOG_BEGIN                   433
#define IDS_LOG_END                     434
#define IDS_LOG_WAS_ENABLED             435
#define IDS_LOG_IS_ENABLED              436
#define IDS_LOG_INSTALL_STATE           437
#define IDS_LOG_CREATE_REQUEST          438
#define IDS_LOG_CREATE_CERTIFICATE      439
#define IDS_LOG_START_SERVICE           440
#define IDS_LOG_WEB_INCLUDE             441
#define IDS_LOG_INSTALL_CLIENT          442
#define IDS_LOG_INSTALL_SERVER          443
#define IDS_LOG_UPGRADE_TYPE            444
#define IDS_LOG_UPGRADE_CERT_STORE      445
#define IDS_LOG_UPGRADE_KEY_SECURITY    446
#define IDS_LOG_UPGRADE_SERVER          447
#define IDS_LOG_UPGRADE_CLIENT          448
#define IDS_LOG_SERVICE_STOPPED         449
#define IDS_LOG_SERVICE_STARTED         450
#define IDS_LOG_CREATE_CLIENT_REG       451
#define IDS_LOG_CREATE_SERVER_REG       452
#define IDS_LOG_UPGRADE_SERVER_REG      453
#define IDS_LOG_DLLS_UNREGISTERED       454
#define IDS_LOG_DLLS_REGISTERED         455
#define IDS_LOG_PROGRAM_GROUPS          456
#define IDS_LOG_CREATE_SERVICE          457
#define IDS_LOG_CANCEL_INSTALL          458
#define IDS_LOG_FUNCTION                459
#define IDS_LOG_UNATTENDED_ATTRIBUTE    460
#define IDS_LOG_CLIENT_UNATTENDED_ATTRIBUTES    461
#define IDS_LOG_SERVER_UNATTENDED_ATTRIBUTES    462
#define IDS_LOG_OPERATIONFLAGS          463
#define IDS_LOG_TODOLIST                464
#define IDS_LOG_POSTBASE                465
#define IDS_LOG_UNATTENDED              466
#define IDS_LOG_REGSTATE                467
#define IDS_LOG_SELECTIONSTATE          468
#define IDS_WELCOME_TITLE               469
#define IDS_FINAL_TITLE                 470
#define IDS_LOG_IMPORTPFX               471
#define IDS_ERR_CREATE_DIR              473
#define IDS_WRN_UNINSTALL_BOTH          474
#define IDS_WRN_UNINSTALL_CLIENT        475
#define IDS_PFX_WRONG_SELFSIGN_TYPE     476
#define IDS_CAREQUEST_REQUESTFILEPATH_MUSTEXIST     477
#define IDS_LOG_IGNORE_KEYLENGTH        478
#define IDS_CAREQUEST_REQUESTFILEPATH_DIREXISTS     479
#define IDS_PFX_FILE_OR_PASSWORD_TOO_LONG 480
#define IDS_ERR_UPGRADE_NOT_SUPPORTED   481
#define IDS_WRN_SERVER_ONLY             482
#define IDS_IDINFO_VALIDITYLENSTRERR    483
#define IDS_WRN_IDINFO_INVALIDDN        484

// HTML strings
#define IDS_HTML_CERTWEBDAT             510
#define IDS_HTML_NSREV                  511

#define IDS_IDINFO_DELETECERTIFICATES   512


#define IDC_CERTOUT_EXCHANGEEDIT        1000
#define IDC_CATYPE_DESCRIPTION_PROXY    1000
#define IDC_CERTOUT_SELFSIGNEDEDIT      1001
#define IDC_EXISTING_KEYS               1050
#define IDC_KEY_LIST                    1051

#define IDC_NOEDIT_COUNTRY              1100
#define IDC_NOEDIT_ORGANIZATION         1101
#define IDC_NOEDIT_ORGANIZATION_UNIT    1102
#define IDC_NOEDIT_CA_NAME              1103
#define IDC_NOEDIT_STATE                1104
#define IDC_NOEDIT_LOCALITY             1105
#define IDC_NOEDIT_CSP_NAME             1106
#define IDC_NOEDIT_HASH_ALGORITHM       1107
#define IDC_NOEDIT_CONTAINER_NAME       1108
#define IDC_NOEDIT_MACHINE_KEYSET       1109
#define IDC_NOEDIT_SHARED_FOLDER        1110
#define IDC_NOEDIT_SIGNATURE_CERT_NAME  1111
#define IDC_NOEDIT_EXCHANGE_CERT_NAME   1112
#define IDC_LIST_CAS                    1150
#define IDC_EXISTING_CA_NAME            1151
#define IDC_EXISTING_CSP_NAME           1152
#define IDC_EXISTING_HASH_ALGORITHM     1153
#define IDC_EXISTING_KEY_CONTAINER_NAME 1154
#define IDC_USE_EXISTING_CA             1155
#define IDC_USE_MODIFY_EXISTING_CA      1156

#define IDC_CHECK_USE_EXISTING_KEY      1200
#define IDC_LIST_EXISTING_KEY           1201

#define IDD_WIZIDINFOPAGE               1250
#define IDD_WIZKEYGENPAGE               1251
#define IDD_WIZADVANCEDPAGE             1252
#define IDD_WIZCATYPEPAGE               1254
#define IDD_WIZCAREQUESTPAGE            1257
#define IDD_WIZSTOREPAGE                1258
#define IDD_WIZCLIENTPAGE               1259
#define IDD_PFXIMPORT                   1260
#define IDD_WIZWELCOMEPAGE              1261
#define IDD_WIZFINALPAGE                1262

#define IDC_IDINFO_NAMEEDIT             1300
#define IDC_CERTSRV_BITMAP              1309
#define IDC_IDINFO_COMBO_VALIDITYSTRING 1310
#define IDC_IDINFO_EDIT_VALIDITYCOUNT   1311
#define IDC_IDINFO_EXPIRATION           1312
#define IDC_IDINFO_DETERMINEDBYPCA      1313
#define IDC_IDINFO_EXPIRATION_LABEL     1314
#define IDC_IDINFO_VPLABEL              1315

#define IDC_IDINFO_NAMEPREVIEW          1317
#define IDC_IDINFO_DNSUFFIXEDIT         1319


#define IDC_CATYPE_ENT_ROOT_CA          1350
#define IDC_CATYPE_ENT_SUB_CA           1351
#define IDC_CATYPE_STAND_ROOT_CA        1353
#define IDC_CATYPE_STAND_SUB_CA         1354
#define IDC_CATYPE_CA_DESCRIPTION       1355
#define IDC_CATYPE_CHECK_ADVANCE        1360
#define IDC_CATYPE_DESCRIPTION_ENTERPRISE 1366

#define IDC_ADVANCE_CSPLIST             1400
#define IDC_ADVANCE_HASHLIST            1401
#define IDC_ADVANCE_USEKEYCHECK         1402
#define IDC_ADVANCE_KEYLIST             1403
#define IDC_ADVANCE_KEY_LENGTH          1404
#define IDC_ADVANCE_IMPORT              1405
#define IDC_ADVANCE_USECERTCHECK        1406
#define IDC_ADVANCE_VIEWCERT            1407
#define IDC_ADVANCE_INTERACTIVECHECK    1408

#define IDC_CAREQUEST_SUBMITTOCA        1500
#define IDC_CAREQUEST_SAVETOFILE        1501
#define IDC_CAREQUEST_COMPUTERNAME      1502
#define IDC_CAREQUEST_CANAME            1503
#define IDC_CAREQUEST_CA_BROWSE         1504
#define IDC_CAREQUEST_FILE_BROWSE       1505
#define IDC_CAREQUEST_FILE              1506
#define IDC_CAREQUEST_CNLABEL           1507
#define IDC_CAREQUEST_PCALABEL          1508
#define IDC_CAREQUEST_FILELABEL         1509

#define IDC_COMPLETE_INFO               1550
#define IDC_FINAL_STATUS                1551

#define IDC_STORE_EDIT_SHAREDFOLDER     1600
#define IDC_STORE_EDIT_DB               1601
#define IDC_STORE_EDIT_LOG              1602
#define IDC_STORE_SHAREDBROWSE          1603
#define IDC_STORE_DBBROWSE              1604
#define IDC_STORE_LOGBROWSE             1605
#define IDC_STORE_KEEPDB                1607
#define IDC_STORE_USE_SHAREDFOLDER      1608

#define IDC_CLIENT_CANAME               1653
#define IDC_CLIENT_COMPUTERNAME         1654
#define IDC_CLIENT_BROWSECNFG           1655

#define IDC_PFX_FILENAME                1750
#define IDC_PFX_BROWSE                  1751
#define IDC_PFX_PASSWORD                1752

#define IDC_KEYGEN_PROGRESS_TEXT        1780
#define IDC_KEYGEN_PROGRESS             1781
#define IDS_LOG_CANAME                  1782
#define IDS_LOG_ORG                     1783
#define IDS_LOG_ORGUNIT                 1784
#define IDS_LOG_LOCALITY                1785
#define IDS_LOG_STATE                   1786
#define IDS_LOG_EMAIL                   1787
#define IDS_LOG_COUNTRY                 1788
#define IDS_LOG_DESCRIPTION             1789
#define IDS_LOG_SHAREDFOLDER            1790
#define IDS_LOG_DBDIR                   1791
#define IDS_LOG_DBLOGDIR                1792
#define IDS_LOG_COMPUTER                1793
#define IDS_LOG_REQUESTFILE             1794
#define IDS_LOG_VALIDITY                1795
#define IDS_LOG_CATYPE                  1796
#define IDS_LOG_KEYNAME                 1797
#define IDS_ERR_NONIA5DNSNAME           1798
#define IDS_WRN_DBSPECIALCHARACTERS     1799
#define IDS_WRN_NONAMECHANGE            1800
#define IDS_WRN_KEYNAMETOOLONG          1801
#define IDS_LOG_QUERYCHANGESELSTATE     1802
#define IDS_PATH_TOO_LONG_DIRECTORY     1803
#define IDS_LOG_BAD_CATYPE              1804
#define IDS_LOG_BAD_OR_MISSING_CANAME   1805
#define IDS_LOG_BAD_VALIDITY_PERIOD_STRING 1806
#define IDS_LOG_CA_MACHINE_REQUIRED     1807
#define IDS_LOG_CA_NAME_REQUIRED        1808
#define IDS_LOG_PING_PARENT_FAIL        1809
#define IDS_LOG_EMPTY_UNATTENDED_ATTRIBUTE 1810
#define IDS_LOG_PATH_CAFILE_BUILD_FAIL  1811
#define IDS_LOG_ENTERPRISE_NO_DS        1812
#define IDS_LOG_BAD_COUNTRY_LENGTH      1813
#define IDS_LOG_NO_CERT                 1814
#define IDS_LOG_REUSE_CERT_NO_REUSE_KEY 1815
#define IDS_LOG_REUSE_DB_WITHOUT_REUSE_CERT 1816
#define IDS_LOG_BAD_VALIDITY_PERIOD_COUNT 1817
#define IDS_LOG_REQUEST_FILE_TOO_LONG   1818
#define IDS_LOG_CANAME_TOO_LONG         1819
#define IDS_LOG_PATH_TOO_LONG_CANAME    1820
#define IDS_LOG_BAD_COUNTRY_CODE        1821
#define IDS_LOG_KEY_NOT_FOUND_IN_LIST   1822
#define IDS_LOG_DISABLE_WIZ_PAGE        1823
#define IDS_LOG_WIZ_PAGE_ERROR  	1824
#define IDS_LOG_UPGRADE_UNSUPPORTED    	1825
#define IDS_LOG_UPGRADE_WIN2000      	1826
#define IDS_LOG_UPGRADE_B2B     	1827
#define IDS_LARGEFONTSIZE       	1828
#define IDS_LARGEFONTNAME       	1829
#define IDC_TEXT_BIGBOLD        	1830
#define IDS_ILOG_SANITIZEDNAME		1831
#define IDS_ILOG_KEYCONTAINERNAME	1832
#define IDS_WRN_CANNOT_ADD_CA_TO_CERTPUBLISHERS 1833
#define IDS_WRN_CANNOT_ADD_CA_TO_PREWIN2K 1834
#define IDS_WRN_ASP_NOT_ENABLED         1835
#define IDS_WRN_IIS_NOT_INSTALLED       1836
#define IDS_WRN_OLD_DS_VERSION          1837
#define IDS_ENTERPRISE_UNAVAIL_REASON   1838
#define IDS_HELP_EXECUTE		1839
#define IDS_SHARE_VERIFY_ERROR		1840
#define IDS_LOG_SHARE_DISP		1841
#define IDS_LOG_VROOT_DISP		1842

#define IDC_STATIC                      (-1)

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\usecert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       usecert.h
//
//--------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  File:	usecert.h
// 
//  Contents:	Header file for certificate store and file operations
//
//  History:	10/97	xtan	Created
//
//-------------------------------------------------------------------------


#ifndef __USECERT_H__
#define __USECERT_H__

HRESULT
DetermineExistingCAIdInfo(
    IN OUT CASERVERSETUPINFO       *pServer,
    OPTIONAL IN CERT_CONTEXT const *pUpgradeCert);

HRESULT
FindCertificateByKey(
    IN CASERVERSETUPINFO * pServer,
    OUT CERT_CONTEXT const ** ppccCertificateCtx);

HRESULT
SetExistingCertToUse(
    IN CASERVERSETUPINFO * pServer,
    IN CERT_CONTEXT const * pccCertCtx);

void
ClearExistingCertToUse(
    IN CASERVERSETUPINFO * pServer);

HRESULT
FindHashAlgorithm(
    IN CERT_CONTEXT const * pccCert,
    IN CSP_INFO * pCSPInfo,
    OUT CSP_HASH ** ppHash);

HRESULT
IsCertSelfSignedForCAType(
    IN CASERVERSETUPINFO * pServer,
    IN CERT_CONTEXT const * pccCert,
    OUT BOOL * pbOK);

#endif // #ifndef __USECERT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\unattend.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       unattend.cpp
//
//  Contents:   handling unattended attributes
//
//  History:    8/97      XTan
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// includes
#include <assert.h>

#include "cscsp.h"
#include "certmsg.h"
#include "usecert.h"
#include "dssetup.h"
#include "wizpage.h"

//defines

#define __dwFILE__      __dwFILE_OCMSETUP_UNATTEND_CPP__

#define wszCOMPONENTS              L"Components"

#define wszAttrCAMACHINE           L"camachine" //L"CAMachine"
#define wszAttrCANAME              L"caname" //L"CAName"
#define wszAttrPARENTCAMACHINE     L"parentcamachine" //L"ParentCAMachine"
#define wszAttrPARENTCANAME        L"parentcaname" //L"ParentCAName"

#define wszAttrCATYPE              L"catype" //L"CAType"
#define wszAttrNAME                L"name" //L"Name"
#define wszAttrCADISTINGUISHEDNAME L"cadistinguishedname" //L"CADistinguishedName"
#define wszAttrORGANIZATION        L"organization" //L"Organization" // dead
#define wszAttrORGANIZATIONUNIT    L"organizationalunit" //L"OrganizationalUnit" // dead
#define wszAttrLOCALITY            L"locality" //L"Locality" // dead
#define wszAttrSTATE               L"state" //L"State" // dead
#define wszAttrCOUNTRY             L"country" //L"Country" // dead
#define wszAttrDESCRIPTION         L"description" //L"Description" // dead
#define wszAttrEMAIL               L"email" //L"Email" // dead
#define wszAttrVALIDITYPERIODSTRING L"validityperiod" //L"ValidityPeriod"
#define wszAttrVALIDITYPERIODCOUNT L"validityperiodunits" //L"ValidityPeriodUnits"
#define wszAttrSHAREDFOLDER        L"sharedfolder" //L"SharedFolder"
#define wszAttrREQUESTFILE         L"requestfile" //L"RequestFile"
#define wszAttrCSPPROVIDER         L"cspprovider" //L"CSPProvider"
#define wszAttrHASHALGORITHM       L"hashalgorithm" //L"HashAlgorithm"
#define wszAttrKEYLENGTH           L"keylength" //L"KeyLength"
#define wszAttrEXISTINGKEY         L"existingkey" //L"ExistingKey"
#define wszAttrUSEEXISTINGCERT     L"useexistingcert" //L"UseExistingCert"
#define wszAttrPRESERVEDB          L"preservedb" //L"PreserveDB"
#define wszAttrDBDIR               L"dbdir" //L"DBDir"
#define wszAttrLOGDIR              L"logdir" //L"LogDir"
#define wszAttrINTERACTIVESERVICE  L"interactive" //L"Interactive"

#define wszValueENTERPRISEROOT           L"enterpriseroot"
#define wszValueENTERPRISESUBORDINATE    L"enterprisesubordinate"
#define wszValueSTANDALONEROOT           L"standaloneroot"
#define wszValueSTANDALONESUBORDINATE    L"standalonesubordinate"
#define wszValueYES                      L"yes"
#define wszValueNO                       L"no"
#define wszValueSHA1                     L"sha1"
#define wszValueMD2                      L"md2"
#define wszValueMD4                      L"md4"
#define wszValueMD5                      L"md5"

//typedefs

// globals

UNATTENDPARM aUnattendParmClient[] =
{
    { wszAttrCAMACHINE,    NULL/*pClient->pwszWebCAMachine*/ },
    { wszAttrCANAME,       NULL/*pClient->pwszWebCAName*/ },
// add more code in HookUnattendedClientAttributes if you add
    { NULL,                NULL/*end*/ },
};


UNATTENDPARM aUnattendParmServer[] =
{
    { wszAttrCATYPE,             NULL/*pServer->pwszCAType*/ },
    { wszAttrNAME,               NULL/*pServer->pwszCACommonName*/ },
    { wszAttrCADISTINGUISHEDNAME,NULL/*pServer->pwszCADistinguishedName*/ },

/*  dead params
    { wszAttrORGANIZATION,       NULL },
    { wszAttrORGANIZATIONUNIT,   NULL },
    { wszAttrLOCALITY,           NULL },
    { wszAttrSTATE,              NULL },
    { wszAttrCOUNTRY,            NULL },
    { wszAttrDESCRIPTION,        NULL },
    { wszAttrEMAIL,              NULL },*/

    { wszAttrVALIDITYPERIODCOUNT,  NULL/*pServer->pwszValidityPeriodCount*/ },
    { wszAttrVALIDITYPERIODSTRING, NULL/*pServer->pwszValidityPeriodString*/ },
    { wszAttrSHAREDFOLDER,       NULL/*pServer->pwszSharedFolder*/ },
    { wszAttrREQUESTFILE,        NULL/*pServer->pwszRequestFile*/ },
    { wszAttrCSPPROVIDER,        NULL/*pServer->pwszProvName*/ },
    { wszAttrHASHALGORITHM,      NULL/*pServer->pwszHashAlgorithm*/ },
    { wszAttrKEYLENGTH,          NULL/*pServer->pwszKeyLength*/ },
    { wszAttrEXISTINGKEY,        NULL/*pServer->pwszKeyContainerName*/ },
    { wszAttrUSEEXISTINGCERT,    NULL/*pServer->pwszUseExistingCert*/ },
    { wszAttrPRESERVEDB,         NULL/*pServer->pwszPreserveDB*/ },
    { wszAttrPARENTCAMACHINE,    NULL/*pServer->pwszParentCAMachine*/ },
    { wszAttrPARENTCANAME,       NULL/*pServer->pwszParentCAName*/ },
    { wszAttrDBDIR,              NULL/*pServer->pwszDBDirectory*/ },
    { wszAttrLOGDIR,             NULL/*pServer->pwszLogDirectory*/ },
    { wszAttrINTERACTIVESERVICE, NULL/*pServer->pwszInteractiveService*/ },
// add more code in HookUnattendedServerAttributes if you add
    { NULL,                      NULL/*end*/ },
};


HRESULT
HookUnattendedClientAttributes(
    IN OUT PER_COMPONENT_DATA *pComp,
    IN OUT const SUBCOMP      *pClientComp)
{
    HRESULT  hr;
    DWORD    i;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;

    for (i = 0; NULL != pClientComp->aUnattendParm[i].pwszName; ++i)
    {
        if (0 == LSTRCMPIS(
                        pClientComp->aUnattendParm[i].pwszName,
			wszAttrCAMACHINE))
        {
            pClientComp->aUnattendParm[i].ppwszValue =
                &pClient->pwszWebCAMachine;
        }
        else if (0 == LSTRCMPIS(
                            pClientComp->aUnattendParm[i].pwszName,
			    wszAttrCANAME))
        {
            pClientComp->aUnattendParm[i].ppwszValue =
                &pClient->pwszWebCAName;
        }
        else
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "Internal error, incorrect attr.");
        }
    }

    hr = S_OK;
error:
    return hr;
}

HRESULT
HookUnattendedServerAttributes(
    IN OUT PER_COMPONENT_DATA *pComp,
    IN OUT const SUBCOMP      *pServerComp)
{
    HRESULT  hr;
    DWORD    i;
    CASERVERSETUPINFO *pServer = (pComp->CA).pServer;

    for (i = 0; NULL != pServerComp->aUnattendParm[i].pwszName; ++i)
    {
        if (0 == LSTRCMPIS(
                        pServerComp->aUnattendParm[i].pwszName,
			wszAttrCATYPE))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszCAType;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrNAME))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszCACommonName;
        }
        else if (0 == LSTRCMPIS(
			    pServerComp->aUnattendParm[i].pwszName,
			    wszAttrCADISTINGUISHEDNAME))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszFullCADN;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrORGANIZATION))
        {
            // dead
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrORGANIZATIONUNIT))
        {
            // dead
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrLOCALITY))
        {
            // dead
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrSTATE))
        {
            // dead
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrCOUNTRY))
        {
            // dead
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrDESCRIPTION))
        {
            // dead
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrEMAIL))
        {
            // dead
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrVALIDITYPERIODCOUNT))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszValidityPeriodCount;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrVALIDITYPERIODSTRING))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszValidityPeriodString;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrSHAREDFOLDER))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszSharedFolder;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrREQUESTFILE))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszRequestFile;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrCSPPROVIDER))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pCSPInfo->pwszProvName;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrHASHALGORITHM))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszHashAlgorithm;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrKEYLENGTH))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszKeyLength;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrEXISTINGKEY))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszKeyContainerName;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrUSEEXISTINGCERT))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszUseExistingCert;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrPRESERVEDB))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszPreserveDB;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrPARENTCAMACHINE))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszParentCAMachine;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrPARENTCANAME))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszParentCAName;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrDBDIR))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszDBDirectory;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrLOGDIR))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszLogDirectory;
        }
        else if (0 == LSTRCMPIS(
                            pServerComp->aUnattendParm[i].pwszName,
			    wszAttrINTERACTIVESERVICE))
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszInteractiveService;
        }
        else
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "Internal error, incorrect attr.");
        }
    }

    hr = S_OK;
error:
    return hr;
}


HRESULT
certocmRetrieveUnattendedText(
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    SUBCOMP *psc;
    WCHAR *pwsz = NULL;
    WCHAR   *pwszLoad;
    HANDLE hUnattendedFile = (*pComp->HelperRoutines.GetInfHandle)(
                                INFINDEX_UNATTENDED,
                                pComp->HelperRoutines.OcManagerContext);

    psc = TranslateSubComponent(pwszComponent, pwszSubComponent);
    if (NULL == psc)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal error, unsupported component");
    }

    psc->fInstallUnattend = FALSE;

    hr = certocmReadInfString(
                        hUnattendedFile,
                        wszCOMPONENTS,
                        pwszSubComponent,
                        &pwsz);
    CSILOG(hr, IDS_LOG_UNATTENDED_ATTRIBUTE, pwszSubComponent, pwsz, NULL);
    _JumpIfError(hr, error, "certocmReadInfString");

    if (0 == LSTRCMPIS(pwsz, L"DEFAULT"))
    {
        psc->fInstallUnattend = psc->fDefaultInstallUnattend;
    }
    else
    {
        psc->fInstallUnattend = 0 == LSTRCMPIS(pwsz, L"ON");
    }

    if (psc->fInstallUnattend)
    {
        DWORD i;

        for (i = 0; NULL != psc->aUnattendParm[i].pwszName; i++)
        {
            pwszLoad = NULL;
            hr = certocmReadInfString(
                                hUnattendedFile,
                                psc->pwszSubComponent,
                                psc->aUnattendParm[i].pwszName,
                                &pwszLoad);
            if (S_OK != hr || NULL == pwszLoad)
            {
                // allow missing attributes
                _PrintErrorStr(
                        hr,
                        "Ignoring certocmReadInfString",
                        psc->aUnattendParm[i].pwszName);
                continue;
            }

            if (0x0 == pwszLoad[0])
            {
                // if a attribute is given as empty, put it in log
                CSILOG(
                    hr,
                    IDS_LOG_EMPTY_UNATTENDED_ATTRIBUTE,
                    psc->aUnattendParm[i].pwszName,
                    NULL,
                    NULL);

                // continue to take default
                LocalFree(pwszLoad);
                continue;
            }

            if (NULL != psc->aUnattendParm[i].ppwszValue &&
                NULL != *(psc->aUnattendParm[i].ppwszValue) )
            {
                // free old or default attributes
                LocalFree(*(psc->aUnattendParm[i].ppwszValue));
            }
            // get new
            *(psc->aUnattendParm[i].ppwszValue) = pwszLoad;

            CSILOG(
                S_OK,
                IDS_LOG_UNATTENDED_ATTRIBUTE,
                psc->aUnattendParm[i].pwszName,
                pwszLoad,
                NULL);
        }
    }

    hr = S_OK;
error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    return hr;
}

HRESULT BuildDistinguishedName(
    LPCWSTR pcwszCN,
    LPWSTR *ppwszDN)
{
    HRESULT hr = S_OK;
    LPWSTR pwszDN = NULL;
    LPWSTR pwszMachineDN = NULL;
    LPCWSTR pcwszCNEqual = L"CN=";
    DWORD dwLen = 0;

    CSASSERT(pcwszCN);
    CSASSERT(ppwszDN);

    myGetComputerObjectName(NameFullyQualifiedDN, &pwszMachineDN);
    //ignore failure

    dwLen = wcslen(pcwszCNEqual)+wcslen(pcwszCN)+1;
    if(pwszMachineDN)
    {
        dwLen += wcslen(pwszMachineDN)+1; // add 1 for comma
    }
    dwLen *= sizeof(WCHAR);

    pwszDN = (LPWSTR)LocalAlloc(LMEM_FIXED, dwLen);
    _JumpIfAllocFailed(pwszDN, error);

    wcscpy(pwszDN, pcwszCNEqual);
    wcscat(pwszDN, pcwszCN);
    
    if (pwszMachineDN)
    {
        _wcsupr(pwszMachineDN);

        WCHAR *pwszFirstDCComponent = wcsstr(pwszMachineDN, L"DC=");
        if (pwszFirstDCComponent != NULL)
        {
           wcscat(pwszDN, L",");
           wcscat(pwszDN, pwszFirstDCComponent);
        }
    }

    *ppwszDN = pwszDN;

error:

    LOCAL_FREE(pwszMachineDN);
    return hr;
}

HRESULT
PrepareServerUnattendedAttributes(
    HWND                hwnd,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT            hr;
    CASERVERSETUPINFO *pServer = (pComp->CA).pServer;
    BOOL fCoInit = FALSE;
    BOOL fNotContinue = FALSE;
    BOOL fValidDigitString;

    WCHAR *pwszConfig = NULL;

    // determine CA type
    if (NULL != pServer->pwszCAType)
    {
        // case insensitive
        if (0 == LSTRCMPIS(pServer->pwszCAType, wszValueENTERPRISEROOT))
        {
            pServer->CAType = ENUM_ENTERPRISE_ROOTCA;
        }
        else if (0 == LSTRCMPIS(pServer->pwszCAType, wszValueENTERPRISESUBORDINATE))
        {
            pServer->CAType = ENUM_ENTERPRISE_SUBCA;
        }
        else if (0 == LSTRCMPIS(pServer->pwszCAType, wszValueSTANDALONEROOT))
        {
            pServer->CAType = ENUM_STANDALONE_ROOTCA;
        }
        else if (0 == LSTRCMPIS(pServer->pwszCAType, wszValueSTANDALONESUBORDINATE))
        {
            pServer->CAType = ENUM_STANDALONE_SUBCA;
        }
        else
        {
            // unknown ca type in unattended file
            hr = E_INVALIDARG;
            CSILOG(hr, IDS_LOG_BAD_CATYPE, pServer->pwszCAType, NULL, NULL);
            _JumpError(hr, error, "unknown ca type in unattended file");
        }
    }

    // determine if ca type and DS combination is legal
    if (IsEnterpriseCA(pServer->CAType))
    {
        // enterprise cas require DS
        if (!pServer->fUseDS)
        {
            // no ds, let it failure
            hr = E_INVALIDARG;
            CSILOG(hr, IDS_LOG_ENTERPRISE_NO_DS, NULL, NULL, NULL);
            _JumpError(hr, error, "No DS is available for enterprise CA. Either select standalone or install DS first");
        }
    }

    // build full CA DN 

    if(EmptyString(pServer->pwszCACommonName))
    {
        hr = E_INVALIDARG;
        CSILOG(hr, IDS_LOG_CA_NAME_REQUIRED, NULL, NULL, NULL);
        _JumpError(hr, error, "CA name not specified");
    }

    if(!EmptyString(pServer->pwszFullCADN))
    {
        LPWSTR pwszTempFullName;
        hr = BuildFullDN(
            pServer->pwszCACommonName,
            pServer->pwszFullCADN,
            &pwszTempFullName);
        _JumpIfError(hr, error, "BuildFullDN");

        LocalFree(pServer->pwszFullCADN);
        pServer->pwszFullCADN = pwszTempFullName;
    }
    else
    {
        hr = BuildDistinguishedName(
            pServer->pwszCACommonName,
            &pServer->pwszFullCADN);
        _JumpIfError(hr, error, "BuildDistinguishedName");
    }

    // determine advance attributes
    hr = csiGetProviderTypeFromProviderName(
                    pServer->pCSPInfo->pwszProvName,
                    &pServer->pCSPInfo->dwProvType);
    _JumpIfError(hr, error, "csiGetProviderTypeFromProviderName");

    if (NULL != pServer->pwszHashAlgorithm)
    {
        // case insensitive
        if (0 == LSTRCMPIS(pServer->pwszHashAlgorithm, wszValueSHA1))
        {
            pServer->pHashInfo->idAlg = CALG_SHA1;
        }
        else if (0 == LSTRCMPIS(pServer->pwszHashAlgorithm, wszValueMD2))
        {
            pServer->pHashInfo->idAlg = CALG_MD2;
        }
        else if (0 == LSTRCMPIS(pServer->pwszHashAlgorithm, wszValueMD4))
        {
            pServer->pHashInfo->idAlg = CALG_MD4;
        }
        else if (0 == LSTRCMPIS(pServer->pwszHashAlgorithm, wszValueMD5))
        {
            pServer->pHashInfo->idAlg = CALG_MD5;
        }
        else
        {
            // undone, support oid ???

            // otherwise convert to calg id
            pServer->pHashInfo->idAlg = myWtoI(
					    pServer->pwszHashAlgorithm,
					    &fValidDigitString);
        }
    }
    // update algorithm oid anyway (for any changes from csp name, type, hash)
    if (NULL != pServer->pszAlgId)
    {
        // free old
        LocalFree(pServer->pszAlgId);
    }
    hr = myGetSigningOID(
		     NULL,	// hProv
		     pServer->pCSPInfo->pwszProvName,
		     pServer->pCSPInfo->dwProvType,
		     pServer->pHashInfo->idAlg,
		     &pServer->pszAlgId);
    _JumpIfError(hr, error, "myGetSigningOID");

    if (NULL != pServer->pwszKeyLength)
    {
        pServer->dwKeyLength = myWtoI(
				    pServer->pwszKeyLength,
				    &fValidDigitString);
    }

    // Import from PFX file?
    if(NULL != pServer->pwszPFXFile)
    {
        hr = ImportPFXAndUpdateCSPInfo(
                hwnd,
                pComp);
        _JumpIfError(hr, error, "ImportPFXAndUpdateCSPInfo");
    }

    if (NULL != pServer->pwszKeyContainerName)
    {
        if (NULL != pServer->pwszKeyLength)
        {
            CSILOG(hr, IDS_LOG_IGNORE_KEYLENGTH, NULL, NULL, NULL);
            _PrintError(0, "Defined key length is ignored because of reusing key");
        }
        // to revert key container name to common name
        if (NULL != pServer->pwszCACommonName)
        {
            LocalFree(pServer->pwszCACommonName);
            pServer->pwszCACommonName = NULL;
        }
        hr = myRevertSanitizeName(pServer->pwszKeyContainerName,
                 &pServer->pwszCACommonName);
        _JumpIfError(hr, error, "myRevertSanitizeName");
    }

    // set preserveDB flag
    pServer->fPreserveDB = FALSE;
    if (NULL != pServer->pwszPreserveDB)
    {
        // case insensitive
        if (0 == LSTRCMPIS(pServer->pwszPreserveDB, wszValueYES))
        {
            pServer->fPreserveDB = TRUE;
        }
    }

    // set fInteractiveService flag
    pServer->fInteractiveService = FALSE;
    if (NULL != pServer->pwszInteractiveService)
    {
        // case insensitive
        if (0 == LSTRCMPIS(pServer->pwszInteractiveService, wszValueYES))
        {
            pServer->fInteractiveService = TRUE;
        }
    }

    // ca idinfo attributes

    // Reuse cert?
    if (NULL!=pServer->pwszUseExistingCert &&
        0==LSTRCMPIS(pServer->pwszUseExistingCert, wszValueYES))
    {
        //
        // User wants to reuse an existing cert
        //

        // must have a key container name to reuse a cert
        if (NULL==pServer->pwszKeyContainerName) {
            hr=E_INVALIDARG;
            CSILOG(hr, IDS_LOG_REUSE_CERT_NO_REUSE_KEY, NULL, NULL, NULL);
            _JumpError(hr, error, "cannot reuse ca cert without reuse key");
        }

        // see if a matching certificate exists
        CERT_CONTEXT const * pccExistingCert;
        hr = FindCertificateByKey(pServer, &pccExistingCert);
        if (S_OK != hr)
        {
            CSILOG(hr, IDS_LOG_NO_CERT, NULL, NULL, NULL);
            _JumpError(hr, error, "FindCertificateByKey");
        }

        // use the matching cert
        hr = SetExistingCertToUse(pServer, pccExistingCert);
        _JumpIfError(hr, error, "SetExistingCertToUse");

    } else {
        //
        // User does not want to reuse an existing cert
        //   Get the information that we would have pulled from the cert
        //

        // must reuse an existing cert to preserve the DB
        if (pServer->fPreserveDB){
            hr = E_INVALIDARG;
            CSILOG(hr, IDS_LOG_REUSE_DB_WITHOUT_REUSE_CERT, NULL, NULL, NULL);
            _JumpError(hr, error, "cannot preserve DB if don't reuse both key and ca cert");
        }

        // determine extended idinfo attributes

        // validity period
        DWORD       dwValidityPeriodCount;
        ENUM_PERIOD enumValidityPeriod = ENUM_PERIOD_INVALID;
        BOOL fSwap = FALSE;

        if (NULL != pServer->pwszValidityPeriodCount ||
            NULL != pServer->pwszValidityPeriodString)
        {
            hr = myInfGetValidityPeriod(
                                 NULL,		// hInf
				 pServer->pwszValidityPeriodCount,
                                 pServer->pwszValidityPeriodString,
                                 &dwValidityPeriodCount,
                                 &enumValidityPeriod,
                                 &fSwap);
            _JumpIfError(hr, error, "myGetValidityPeriod");

            if (ENUM_PERIOD_INVALID != enumValidityPeriod)
            {
                pServer->enumValidityPeriod = enumValidityPeriod;
            }
            if (0 != dwValidityPeriodCount)
            {
                pServer->dwValidityPeriodCount = dwValidityPeriodCount;
            }
        }

	if (!IsValidPeriod(pServer))
        {
	    hr = E_INVALIDARG;
	    CSILOG(
		hr,
		IDS_LOG_BAD_VALIDITY_PERIOD_COUNT,
		pServer->pwszValidityPeriodCount,
		NULL,
		&pServer->dwValidityPeriodCount);
	    _JumpError(hr, error, "validity period count");
        }

        pServer->NotAfter = pServer->NotBefore;
        myMakeExprDateTime(
			&pServer->NotAfter,
			pServer->dwValidityPeriodCount,
			pServer->enumValidityPeriod);

        //if swap, swap pointer before validation
        if (fSwap)
        {
            WCHAR *pwszTemp = pServer->pwszValidityPeriodCount;
            pServer->pwszValidityPeriodCount = pServer->pwszValidityPeriodString;
            pServer->pwszValidityPeriodString = pwszTemp;
        }

        //the following WizardPageValidation requires
        //pServer->pwszValidityPeriodCount so load from count before validation
        if (NULL == pServer->pwszValidityPeriodCount)
        {
            WCHAR wszCount[10]; //should be enough
            wsprintf(wszCount, L"%d", pServer->dwValidityPeriodCount);
            pServer->pwszValidityPeriodCount = (WCHAR*)LocalAlloc(LMEM_FIXED,
                        (wcslen(wszCount) + 1) * sizeof(WCHAR));
            _JumpIfOutOfMemory(hr, error, pServer->pwszValidityPeriodCount);
            wcscpy(pServer->pwszValidityPeriodCount, wszCount);
        }

        // hook with g_aIdPageString
        hr = HookIdInfoPageStrings(g_aIdPageString, pServer);
        _JumpIfError(hr, error, "HookIdInfoPageStrings");

        hr = WizardPageValidation(
                 pComp->hInstance,
                 pComp->fUnattended,
                 NULL,
                 g_aIdPageString);
        _JumpIfError(hr, error, "WizardPageValidation");

        // make sure no invalid rdn characters
        if (IsAnyInvalidRDN(NULL, pComp))
        {
            hr = E_INVALIDARG;
            CSILOG(
                hr,
                IDS_LOG_BAD_OR_MISSING_CANAME,
                pServer->pwszCACommonName,
                NULL,
                NULL);
            _JumpError(hr, error, "Invalid RDN characters");
        }

    } // <- End if reuse/not-reuse cert

    // determine CA name
    if (NULL != pServer->pwszSanitizedName)
    {
        // free old
        LocalFree(pServer->pwszSanitizedName);
        pServer->pwszSanitizedName = NULL;
    }
    // derive ca name from common name
    hr = mySanitizeName(
             pServer->pwszCACommonName,
             &(pServer->pwszSanitizedName) );
    _JumpIfError(hr, error, "mySanitizeName");

    if (MAX_PATH <= wcslen(pServer->pwszSanitizedName) + cwcSUFFIXMAX)
    {
        hr = CO_E_PATHTOOLONG;
        CSILOG(
            hr,
            IDS_LOG_CANAME_TOO_LONG,
            pServer->pwszSanitizedName,
            NULL,
            NULL);
        _JumpErrorStr(hr, error, "CA Name", pServer->pwszSanitizedName);
    }

    // store attributes
    hr = StorePageValidation(NULL, pComp, &fNotContinue);
    _JumpIfError(hr, error, "StorePageValidation");

    if (fNotContinue)
    {
        hr = S_FALSE;
        _JumpError(hr, error, "StorePageValidation failed");
    }

    // ca cert file name
    if (NULL != pServer->pwszCACertFile)
    {
        // free old one
        LocalFree(pServer->pwszCACertFile);
    }
    hr = csiBuildCACertFileName(
                 pComp->hInstance,
                 hwnd,
                 pComp->fUnattended,
                 pServer->pwszSharedFolder,
                 pServer->pwszSanitizedName,
                 L".crt",
                 0, // CANAMEIDTOICERT(pServer->dwCertNameId),
                 &pServer->pwszCACertFile);
    if (S_OK != hr)
    {
        CSILOG(
            hr,
            IDS_LOG_PATH_CAFILE_BUILD_FAIL,
            pServer->pwszSharedFolder, //likely by invalid shared folder path
            NULL,
            NULL);
        _JumpError(hr, error, "csiBuildFileName");
    }

    // validate path length
    if (MAX_PATH <= wcslen(pServer->pwszCACertFile) + cwcSUFFIXMAX)
    {
            hr = CO_E_PATHTOOLONG;
            CSILOG(
                hr,
                IDS_LOG_PATH_TOO_LONG_CANAME,
                pServer->pwszCACertFile,
                NULL,
                NULL);
            _JumpErrorStr(hr, error, "csiBuildFileName", pServer->pwszCACertFile);
    }

    // request attributes
    // if subordinate ca, determine online or request file
    if (IsSubordinateCA(pServer->CAType))
    {
        // default
        pServer->fSaveRequestAsFile = TRUE;
        if (NULL != pServer->pwszParentCAMachine)
        {
            // online case
            pServer->fSaveRequestAsFile = FALSE;

            hr = CoInitialize(NULL);
            if (S_OK != hr && S_FALSE != hr)
            {
                _JumpError(hr, error, "CoInitialize");
            }
            fCoInit = TRUE;

            if (NULL != pServer->pwszParentCAName)
            {
                // answer file provides both machine and ca names
                hr = myFormConfigString(
                             pServer->pwszParentCAMachine,
                             pServer->pwszParentCAName,
                             &pwszConfig);
                _JumpIfError(hr, error, "myFormConfigString");

                // answer file has complete config string, try to ping it
                hr = myPingCertSrv(pwszConfig, NULL, NULL, NULL, NULL, NULL, NULL);
                if (S_OK != hr)
                {
                    // can't finish without pingable ca
                    CSILOG(
                            hr,
                            IDS_LOG_PING_PARENT_FAIL,
                            pwszConfig,
                            NULL,
                            NULL);
                    _JumpErrorStr(hr, error, "myPingCertSrv", pwszConfig);
                }
            }
            else
            {
                WCHAR *pwszzCAList = NULL;
                // answer file only has machine name, try to get ca name
                hr = myPingCertSrv(
                             pServer->pwszParentCAMachine,
                             NULL,
                             &pwszzCAList,
                             NULL,
                             NULL,
                             NULL,
                             NULL);
                if (S_OK != hr)
                {
                    // can't finish without pingable ca
                    CSILOG(
                            hr,
                            IDS_LOG_PING_PARENT_FAIL,
                            pServer->pwszParentCAMachine,
                            NULL,
                            NULL);
                    _JumpErrorStr(hr, error, "myPingCertSrv",
                                  pServer->pwszParentCAMachine);
                }
                // pick the first one as the choice
                pServer->pwszParentCAName = pwszzCAList;
            }
        }

        if (NULL == pServer->pwszRequestFile)
        {
            // in any case, construct request file name if not defined
            hr = BuildRequestFileName(
                         pServer->pwszCACertFile,
                         &pServer->pwszRequestFile);
            _JumpIfError(hr, error, "BuildRequestFileName");
            // make sure in limit
            if (MAX_PATH <= wcslen(pServer->pwszRequestFile) + cwcSUFFIXMAX)
            {
                hr = CO_E_PATHTOOLONG;
                            CSILOG(
                            hr,
                            IDS_LOG_REQUEST_FILE_TOO_LONG,
                            pServer->pwszRequestFile,
                            NULL,
                            NULL);
                _JumpErrorStr(hr, error, "Request File", pServer->pwszRequestFile);
            }
        }
    }

    // other attributes

    if(pServer->fUseDS)
    {
        pServer->dwRevocationFlags = REVEXT_DEFAULT_DS;
    }
    else
    {
        pServer->dwRevocationFlags = REVEXT_DEFAULT_NODS;
    }

    hr = S_OK;
error:
    if (fCoInit)
    {
        CoUninitialize();
    }
    if (NULL!=pwszConfig) {
        LocalFree(pwszConfig);
    }

    CSILOG(hr, IDS_LOG_SERVER_UNATTENDED_ATTRIBUTES, NULL, NULL, NULL);
    return hr;
}


HRESULT
PrepareClientUnattendedAttributes(
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;

    WCHAR *pwszConfig = NULL;
    CAINFO *pCAInfo = NULL;
    BOOL fCoInit = FALSE;
    WCHAR * pwszDnsName = NULL;

    if ((IS_CLIENT_INSTALL & pComp->dwInstallStatus) &&
        !(IS_SERVER_INSTALL & pComp->dwInstallStatus))
    {
        // no extra setting and converting
        if (NULL == pClient->pwszWebCAMachine)
        {
            hr = E_INVALIDARG;
            CSILOG(hr, IDS_LOG_CA_MACHINE_REQUIRED, NULL, NULL, NULL);
            _JumpError(hr, error, "ca machine name is required");
        }

        hr = CoInitialize(NULL);
        if (S_OK != hr && S_FALSE != hr)
        {
            _JumpError(hr, error, "CoInitialize");
        }
        fCoInit = TRUE;

        if (NULL == pClient->pwszWebCAName)
        {
                WCHAR *pwszzCAList = NULL;
                // answer file only has machine name, try to get ca name
                hr = myPingCertSrv(
                             pClient->pwszWebCAMachine,
                             NULL,
                             &pwszzCAList,
                             NULL,
                             NULL,
                             NULL,
                             NULL);
                if (S_OK != hr)
                {
                    // can't finish without pingable ca
                    CSILOG(
                            hr,
                            IDS_LOG_PING_PARENT_FAIL,
                            pClient->pwszWebCAMachine,
                            NULL,
                            NULL);
                    _JumpErrorStr(hr, error, "myPingCertSrv",
                                  pClient->pwszWebCAMachine);
                }
                // pick the first one as the choice
                pClient->pwszWebCAName = pwszzCAList;
        }

        hr = mySanitizeName(pClient->pwszWebCAName, &pClient->pwszSanitizedWebCAName);
        _JumpIfError(hr, error, "mySanitizeName");

        // build the config string so we can ping the parent CA
        hr = myFormConfigString(
                     pClient->pwszWebCAMachine,
                     pClient->pwszWebCAName,
                     &pwszConfig);
        _JumpIfError(hr, error, "myFormConfigString");

        // ping the CA to retrieve the CA type and DNS name.
        hr = myPingCertSrv(pwszConfig, NULL, NULL, NULL, &pCAInfo, NULL, &pwszDnsName);
        if (S_OK != hr)
        {
            // can't finish without pingable ca
            CSILOG(
                    hr,
                    IDS_LOG_PING_PARENT_FAIL,
                    pwszConfig,
                    NULL,
                    NULL);
            _JumpErrorStr(hr, error, "myPingCertSrv", pwszConfig);
        }
        pClient->WebCAType = pCAInfo->CAType;

        // use the FQDN if available
        if (NULL!=pwszDnsName) {
            LocalFree(pClient->pwszWebCAMachine);
            pClient->pwszWebCAMachine=pwszDnsName;
        }
    }

    hr = S_OK;
error:
    if (NULL!=pwszConfig)
    {
        LocalFree(pwszConfig);
    }

    if (NULL != pCAInfo)
    {
        LocalFree(pCAInfo);
    }

    if (fCoInit)
    {
        CoUninitialize();
    }

    CSILOG(hr, IDS_LOG_CLIENT_UNATTENDED_ATTRIBUTES, NULL, NULL, NULL);
    return hr;
}


HRESULT
PrepareUnattendedAttributes(
    IN HWND         hwnd,
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    SUBCOMP *psc = TranslateSubComponent(pwszComponent, pwszSubComponent);

    if (NULL == psc)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal error, unsupported component");
    }

    switch (psc->cscSubComponent)
    {
        case cscServer:
            hr = PrepareServerUnattendedAttributes(hwnd, pComp);
            _JumpIfError(hr, error, "PrepareServerUnattendedAttributes");
	    break;

        case cscClient:
            hr = PrepareClientUnattendedAttributes(pComp);
            _JumpIfError(hr, error, "PrepareClientUnattendedAttributes");
	    break;

        default:
            hr = E_INVALIDARG;
            _JumpError(hr, error, "Internal error, unsupported component");
    }
    hr = S_OK;

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\usecert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       usecert.cpp
//
//  Contents:   cert store and file operations
//
//--------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <wincrypt.h>

#include "initcert.h"
#include "cscsp.h"
#include "cspenum.h"
#include "wizpage.h"
#include "usecert.h"

#define __dwFILE__      __dwFILE_OCMSETUP_USECERT_CPP__

typedef struct _EXISTING_CA_IDINFO {
    LPSTR       pszObjId;
    WCHAR     **ppwszIdInfo;
} EXISTING_CA_IDINFO;


/*
EXISTING_CA_IDINFO   g_ExistingCAIdInfo[] = {
            {szOID_COMMON_NAME,              NULL},
            {szOID_ORGANIZATION_NAME,        NULL},
            {szOID_ORGANIZATIONAL_UNIT_NAME, NULL},
            {szOID_LOCALITY_NAME,            NULL},
            {szOID_STATE_OR_PROVINCE_NAME,   NULL},
            {szOID_RSA_emailAddr,            NULL},
            {szOID_COUNTRY_NAME,             NULL},
            {NULL, NULL},
                     };
*/

HRESULT
myMakeExprValidity(
    IN FILETIME const *pft,
    OUT LONG *plDayCount)
{
    HRESULT hr;
    FILETIME ft;
    LONGLONG llDelta;

    *plDayCount = 0;

    // get current time

    GetSystemTimeAsFileTime(&ft);

    llDelta = mySubtractFileTimes(pft, &ft);
    llDelta /= 1000 * 1000 * 10;
    llDelta += 12 * 60 * 60; // half day more to avoid truncation
    llDelta /= 24 * 60 * 60;

    *plDayCount = (LONG) llDelta;
    if (0 > *plDayCount)
    {
        *plDayCount = 0;
    }
    hr = S_OK;

//error:
    return hr;
}

//--------------------------------------------------------------------
// returns true if the CA type is root and the cert is self-signed,
// or the CA type is subordinate and the cert is no self-signed
HRESULT
IsCertSelfSignedForCAType(
    IN CASERVERSETUPINFO * pServer,
    IN CERT_CONTEXT const * pccCert,
    OUT BOOL * pbOK)
{
    CSASSERT(NULL!=pccCert);
    CSASSERT(NULL!=pServer);
    CSASSERT(NULL!=pbOK);

    HRESULT hr;
    DWORD dwVerificationFlags;
    BOOL bRetVal;

    // See if this cert is self-signed or not.
    // First, we flag what we want to check: "Use the public 
    //   key in the issuer's certificate to verify the signature on 
    //   the subject certificate." 
    // We use the same certificate as issuer and subject
    dwVerificationFlags=CERT_STORE_SIGNATURE_FLAG;
    // perform the checks
    bRetVal=CertVerifySubjectCertificateContext(
        pccCert,
        pccCert, // issuer same as subject
        &dwVerificationFlags);
    if (FALSE==bRetVal) {
        hr=myHLastError();
        _JumpError(hr, error, "CertVerifySubjectCertificateContext");
    }
    // Every check that passed had its flag zeroed. See if our check passed
    if (CERT_STORE_SIGNATURE_FLAG&dwVerificationFlags){
        // This cert is not self-signed.
        if (IsRootCA(pServer->CAType)) {
            // A root CA cert must be self-signed.
            *pbOK=FALSE;
        } else {
            // A subordinate CA cert must not be self-signed.
            *pbOK=TRUE;
        }
    } else {
        // This cert is self-signed.
        if (IsSubordinateCA(pServer->CAType)) {
            // A subordinate CA cert must not be self-signed.
            *pbOK=FALSE;
        } else {
            // A root CA cert must be self-signed.
            *pbOK=TRUE;
        }
    }

    hr=S_OK;

error:
    return hr;
}

//--------------------------------------------------------------------
// find a certificate's hash algorithm in a CSP's list of hash algorithms
HRESULT
FindHashAlgorithm(
    IN CERT_CONTEXT const * pccCert,
    IN CSP_INFO * pCSPInfo,
    OUT CSP_HASH ** ppHash)
{
    CSASSERT(NULL!=pccCert);
    CSASSERT(NULL!=pCSPInfo);
    CSASSERT(NULL!=ppHash);

    HRESULT hr;
    CSP_HASH * phTravel;
    const CRYPT_OID_INFO * pOIDInfo;

    // Initialize out param
    *ppHash=NULL;

    // get the AlgID from the hash algorithm OID
    // (returned pointer must not be freed)
    pOIDInfo=CryptFindOIDInfo(
        CRYPT_OID_INFO_OID_KEY,
        pccCert->pCertInfo->SignatureAlgorithm.pszObjId,
        CRYPT_SIGN_ALG_OID_GROUP_ID
        );
    if (NULL==pOIDInfo) {
        // function is not doc'd to set GetLastError()
        hr=CRYPT_E_NOT_FOUND;
        _JumpError(hr, error, "Signature algorithm not found");
    }

    // find the hash algorithm in the list of hash algorithms the CSP supports
    for (phTravel=pCSPInfo->pHashList; NULL!=phTravel; phTravel=phTravel->next) {
        if (pOIDInfo->Algid==phTravel->idAlg) {
            *ppHash=phTravel;
            break;
        }
    }
    if (NULL==phTravel) {
        hr=CRYPT_E_NOT_FOUND;
        _JumpError(hr, error, "CSP does not support hash algorithm");
    }

    hr=S_OK;

error:
    return hr;
}

/*

HRESULT
HookExistingIdInfoData(
    CASERVERSETUPINFO    *pServer)
{
    HRESULT  hr;
    int      i = 0;

    while (NULL != g_ExistingCAIdInfo[i].pszObjId)
    {
        if (0 == strcmp(szOID_COMMON_NAME,
                        g_ExistingCAIdInfo[i].pszObjId))
        {
            g_ExistingCAIdInfo[i].ppwszIdInfo = &pServer->pwszCACommonName;
        }
        else if (0 == strcmp(szOID_ORGANIZATION_NAME,
                             g_ExistingCAIdInfo[i].pszObjId))
        {
           // dead
        }
        else if (0 == strcmp(szOID_ORGANIZATIONAL_UNIT_NAME,
                             g_ExistingCAIdInfo[i].pszObjId))
        {
           // dead
        }
        else if (0 == strcmp(szOID_LOCALITY_NAME,
                             g_ExistingCAIdInfo[i].pszObjId))
        {
           // dead
        }
        else if (0 == strcmp(szOID_STATE_OR_PROVINCE_NAME,
                             g_ExistingCAIdInfo[i].pszObjId))
        {
           // dead
        }
        else if (0 == strcmp(szOID_COUNTRY_NAME,
                             g_ExistingCAIdInfo[i].pszObjId))
        {
           // dead
        }
        else if (0 == strcmp(szOID_RSA_emailAddr,
                             g_ExistingCAIdInfo[i].pszObjId))
        {
           // dead
        }
        else
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "unsupported name");
        }

        ++i;
    }

    hr = S_OK;
error:
    return hr;
}
*/

HRESULT
DetermineExistingCAIdInfo(
IN OUT CASERVERSETUPINFO       *pServer,
OPTIONAL IN CERT_CONTEXT const *pUpgradeCert)
{
    CERT_NAME_INFO    *pCertNameInfo = NULL;
    DWORD              cbCertNameInfo;
    WCHAR const       *pwszNameProp;
    HRESULT            hr = E_FAIL;
    CERT_CONTEXT const *pCert = pServer->pccExistingCert;

    CSASSERT(NULL!=pServer->pccExistingCert ||
             NULL != pUpgradeCert);

    if (NULL == pUpgradeCert)
    {
        myMakeExprValidity(
            &pServer->pccExistingCert->pCertInfo->NotAfter,
            &pServer->lExistingValidity);

        pServer->NotBefore = pServer->pccExistingCert->pCertInfo->NotBefore;
        pServer->NotAfter  = pServer->pccExistingCert->pCertInfo->NotAfter;
    }
   
    if (NULL != pUpgradeCert)
    {
        pCert = pUpgradeCert;
    }

    if (!myDecodeName(X509_ASN_ENCODING,
              X509_UNICODE_NAME,
              pCert->pCertInfo->Subject.pbData,
              pCert->pCertInfo->Subject.cbData,
              CERTLIB_USE_LOCALALLOC,
              &pCertNameInfo,
              &cbCertNameInfo))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myDecodeName");
    }

/*
    // fill a data structure for existing key id info
    hr = HookExistingIdInfoData(pServer);
    _JumpIfError(hr, error, "HookExistingIdInfoData");

    // load names from cert to the the data structure
    i = 0;

    while (NULL != g_ExistingCAIdInfo[i].pszObjId)
    {
        if (S_OK == myGetCertNameProperty(
                                 pCertNameInfo,
                                 g_ExistingCAIdInfo[i].pszObjId,
                                 &pwszNameProp))
        {
            pwszExisting = (WCHAR*)LocalAlloc(LPTR,
                (wcslen(pwszNameProp) + 1) * sizeof(WCHAR));
            _JumpIfOutOfMemory(hr, error, pwszExisting);

            // get name
            wcscpy(pwszExisting, pwszNameProp);

            // make sure free old
            if (NULL != *(g_ExistingCAIdInfo[i].ppwszIdInfo))
            {
                LocalFree(*(g_ExistingCAIdInfo[i].ppwszIdInfo));
            }
            *(g_ExistingCAIdInfo[i].ppwszIdInfo) = pwszExisting;
        }
        ++i;
    }
*/
    hr = myGetCertNameProperty(
			FALSE,
			pCertNameInfo,
			szOID_COMMON_NAME,
			&pwszNameProp);
    if (hr == S_OK)
    {
        if(pServer->pwszCACommonName)
        {
            LocalFree(pServer->pwszCACommonName);
            pServer->pwszCACommonName = NULL;
        }
        
        // Common name exists, copy it out
        hr = myDupString(pwszNameProp, &(pServer->pwszCACommonName));
        _JumpIfError(hr, error, "myDupString");
    }

    if(pServer->pwszFullCADN)
    {
        LocalFree(pServer->pwszFullCADN);
        pServer->pwszFullCADN = NULL;
    }

    // now get everything else
    hr = myCertNameToStr(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                &pCert->pCertInfo->Subject,
                CERT_X500_NAME_STR | CERT_NAME_STR_COMMA_FLAG | CERT_NAME_STR_REVERSE_FLAG, 
                &pServer->pwszFullCADN);
    _JumpIfError(hr, error, "myCertNameToStr");

    // No need for a DN suffix, the full DN is already in the cert
    
    if(pServer->pwszDNSuffix)
    {
        LocalFree(pServer->pwszDNSuffix);
        pServer->pwszDNSuffix = NULL;
    }

    hr = myDupString(L"", &(pServer->pwszDNSuffix));
    _JumpIfError(hr, error, "myDupString");
 
    hr = S_OK;

error:
    if (NULL != pCertNameInfo)
    {
        LocalFree(pCertNameInfo);
    }
    return hr;
}

//--------------------------------------------------------------------
// find a cert that matches the currently selected CSP and key container name
// returns CRYPT_E_NOT_FOUND if no certificate. Caller MUST free the returned
// context.
// Note: IT IS VERY IMPORTANT that pfx import maintains all the
//   invariants about CSP, key container, hash, cert validity, etc.
//   that the rest of the UI (including this function) maintains.
HRESULT
FindCertificateByKey(
    IN CASERVERSETUPINFO * pServer,
    OUT CERT_CONTEXT const ** ppccCertificateCtx)
{
    CSASSERT(NULL!=pServer);
    CSASSERT(NULL!=ppccCertificateCtx);

    HRESULT hr;
    DWORD dwPublicKeySize;
    BOOL bRetVal;
    DWORD dwVerificationFlags;
    CERT_CONTEXT const *pccFound = NULL;

    // variables that must be cleaned up
    HCRYPTPROV hProv=NULL;
    CERT_PUBLIC_KEY_INFO * pcpkiKeyInfo=NULL;
    CERT_CONTEXT const * pccCurrentCert=NULL;

    // initialize out param
    *ppccCertificateCtx=NULL;

    // open certificate store if it is not already open
    if (NULL==pServer->hMyStore) {
        pServer->hMyStore=CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            X509_ASN_ENCODING,
            NULL,           // hProv
            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_ENUM_ARCHIVED_FLAG,
            wszMY_CERTSTORE);
        if (NULL==pServer->hMyStore) {
            hr=myHLastError();
            _JumpError(hr, error, "CertOpenStore");
        }
    }

    //
    // Get public key blob from key container
    //   Note: This may fail if key is not 
    //   AT_SIGNATURE, but we will never actually use the key in 
    //   this case anyway so it's ok to not find any certs
    //

    DBGPRINT((
        DBG_SS_CERTOCM,
        "FindCertificateByKey: key=%ws\n",
        pServer->pwszKeyContainerName));

    // first, open the key container
    bRetVal=myCertSrvCryptAcquireContext(
        &hProv,
        pServer->pwszKeyContainerName,
        pServer->pCSPInfo->pwszProvName,
        pServer->pCSPInfo->dwProvType,
        CRYPT_SILENT,   // we should never have to ask anything to get this info
        pServer->pCSPInfo->fMachineKeyset);
    if (FALSE==bRetVal) {
        hr=myHLastError();
        _JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }

    // get the size of the blob
    bRetVal=CryptExportPublicKeyInfo(
        hProv,
        AT_SIGNATURE,
        X509_ASN_ENCODING,
        NULL, //determine size
        &dwPublicKeySize);
    if (FALSE==bRetVal) {
        hr=myHLastError();
        _JumpError(hr, error, "CryptExportPublicKeyInfo (get data size)");
    }

    // allocate the blob
    pcpkiKeyInfo=(CERT_PUBLIC_KEY_INFO *)LocalAlloc(LMEM_FIXED, dwPublicKeySize);
    _JumpIfOutOfMemory(hr, error, pcpkiKeyInfo);

    // get the public key info blob
    bRetVal=CryptExportPublicKeyInfo(
            hProv,
            AT_SIGNATURE,
            X509_ASN_ENCODING,
            pcpkiKeyInfo,
            &dwPublicKeySize);
    if (FALSE==bRetVal) {
        hr=myHLastError();
        _JumpError(hr, error, "CryptExportPublicKeyInfo (get data)");
    }

    //
    // Find a certificate that has a matching key, has not expired,
    //   and is self-signed or not self-signed depending upon 
    //   the CA type we are trying to install
    //

    for (;;)
    {
        // find the next cert that has this public key
        //   Note: the function will free the previously 
        //   used context when we pass it back
        pccCurrentCert=CertFindCertificateInStore(
            pServer->hMyStore,
            X509_ASN_ENCODING,
            0, // flags
            CERT_FIND_PUBLIC_KEY,
            pcpkiKeyInfo,
            pccCurrentCert);

        // exit the loop when we can find no more matching certs

        if (NULL == pccCurrentCert)
        {
            hr = myHLastError();
            if (NULL != pccFound)
            {
                break;
            }
            _JumpError(hr, error, "CertFindCertificateInStore");
        }

        // check to make sure that the cert has not expired
        // first, we flag what we want to check

        dwVerificationFlags = CERT_STORE_TIME_VALIDITY_FLAG;

        // perform the checks

        bRetVal=CertVerifySubjectCertificateContext(
            pccCurrentCert,
            NULL, // issuer; not needed
            &dwVerificationFlags);
        if (FALSE==bRetVal) {
            _PrintError(myHLastError(), "CertVerifySubjectCertificateContext");
            // this should not fail, but maybe we got a bad cert. Keep looking.
            continue;
        }
        // Every check that passed had its flag zeroed. See if our check passed
        if (CERT_STORE_TIME_VALIDITY_FLAG&dwVerificationFlags){
            // This cert is expired and we can't use it. Keep looking.
            continue;
        }

        // verify to make sure no cert in chain is revoked, but don't kill
	// yourself if can't connect
	// allow untrusted cert if installing a root

        hr = myVerifyCertContext(
		pccCurrentCert,
		CA_VERIFY_FLAGS_IGNORE_OFFLINE |
		    (IsRootCA(pServer->CAType)?
			CA_VERIFY_FLAGS_ALLOW_UNTRUSTED_ROOT : 0),
		0,
		NULL,
		HCCE_LOCAL_MACHINE,
		NULL,
		NULL);
        if (S_OK != hr)
        {
            // At least one cert is revoked in chain
            _PrintError(hr, "myVerifyCertContext");
            continue;
        }

        // See if this cert appropriately is self-signed or not.
        // A root CA cert must be self-signed, while
        // a subordinate CA cert must not be self-signed.
        hr=IsCertSelfSignedForCAType(pServer, pccCurrentCert, &bRetVal);
        if (FAILED(hr)) {
            // this should not fail, but maybe we got a bad cert. Keep looking.
            _PrintError(hr, "IsCertSelfSignedForCAType");
            continue;
        }
        if (FALSE==bRetVal) {
            // this cert is not appropriate for this CA type
            _PrintError(S_FALSE, "bad CA Type");
            continue;
        }

        // If we got here, the cert we have is a good one.
        // If we already found a good cert and this one expires later,
        // toss the old one and save this one.

        if (NULL != pccFound)
        {
            if (0 > CompareFileTime(
                         &pccCurrentCert->pCertInfo->NotAfter,
                         &pccFound->pCertInfo->NotAfter))
            {
                continue;               // old one is newer -- keep it
            }
            CertFreeCertificateContext(pccFound);
            pccFound = NULL;
        }
        pccFound = CertDuplicateCertificateContext(pccCurrentCert);
        if (NULL == pccFound)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CertDuplicateCertificateContext");
        }

    } // <- End certificate finding loop

    CSASSERT(NULL != pccFound);
    *ppccCertificateCtx = pccFound;
    pccFound = NULL;
    hr = S_OK;

error:
    if (NULL!=hProv) {
        CryptReleaseContext(hProv, 0);
    }
    if (NULL!=pcpkiKeyInfo) {
        LocalFree(pcpkiKeyInfo);
    }
    if (NULL != pccFound)
    {
        CertFreeCertificateContext(pccFound);
    }
    if (NULL!=pccCurrentCert) {
        CertFreeCertificateContext(pccCurrentCert);
    }
    if (S_OK!=hr && CRYPT_E_NOT_FOUND!=hr) {
        _PrintError(hr, "Ignoring error in FindCertificateByKey, returning CRYPT_E_NOT_FOUND")
        hr=CRYPT_E_NOT_FOUND;
    }

    return hr;
}

//--------------------------------------------------------------------
// Set which existing certificate we want to use
HRESULT
SetExistingCertToUse(
    IN CASERVERSETUPINFO * pServer,
    IN CERT_CONTEXT const * pccCertCtx)
{
    CSASSERT(NULL!=pServer);
    CSASSERT(NULL!=pccCertCtx);

    HRESULT hr;
    CSP_HASH * pHash;

    // to use an existing cert, we must use an existing key
    CSASSERT(NULL!=pServer->pwszKeyContainerName);

    // find the hash algorithm that matches this cert, and use it if possible
    // otherwise, stick with what we are currently using.
    hr=FindHashAlgorithm(pccCertCtx, pServer->pCSPInfo, &pHash);
    if (S_OK==hr) {
        pServer->pHashInfo = pHash;
    }

    hr = myGetNameId(pccCertCtx, &pServer->dwCertNameId);
    _PrintIfError(hr, "myGetNameId");

    if (MAXDWORD == pServer->dwCertNameId)
    {
        pServer->dwCertNameId = 0;
    }

    ClearExistingCertToUse(pServer);
    pServer->pccExistingCert=pccCertCtx;


    // We could assume that everything will work, but it doesn't take long to check
    //pServer->fValidatedHashAndKey=TRUE;

    hr=S_OK;

//error:
    return hr;
}

//--------------------------------------------------------------------
// stop using an existing certificate
void
ClearExistingCertToUse(
    IN CASERVERSETUPINFO * pServer)
{
    CSASSERT(NULL!=pServer);

    if (NULL!=pServer->pccExistingCert) {
        CertFreeCertificateContext(pServer->pccExistingCert);
        pServer->pccExistingCert=NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\setuput.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       setuput.h
//
//--------------------------------------------------------------------------

#ifndef __SETUPUT_H__
#define __SETUPUT_H__

//+------------------------------------------------------------------------
//
//  File:	setuput.h
// 
//  Contents:	Header file for setup utility functions.
//
//  Functions:
//
//  History:	04/20/97	JerryK	Created
//
//-------------------------------------------------------------------------

#define SERVERINSTALLTICKS	50
#define CA_DEFAULT_KEY_LENGTH_ROOT	2048
#define CA_DEFAULT_KEY_LENGTH_SUB	1024
#define wszCERTSRVEXENAME   L"certsrv.exe"

#define wszCERTSRVSECTION  L"certsrv"
#define wszSERVERSECTION  L"certsrv_server"
#define wszCLIENTSECTION  L"certsrv_client"

#define wszOLDDOCCOMPONENT  L"certsrv_doc"

#define wszREGKEYOCMSUBCOMPONENTS L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents"

#define wszREGKEYCERTSRVTODOLIST L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\OCManager\\ToDoList\\CertSrv"

#define wszW3SVCNAME    L"W3Svc"

#define _JumpIfOutOfMemory(hr, label, pMem) \
    { \
        if (NULL == (pMem)) \
        { \
            (hr) = E_OUTOFMEMORY; \
            _JumpError((hr), label, "Out of Memory"); \
        } \
    }


#define IS_CLIENT_INSTALL	0x00000001
#define IS_CLIENT_REMOVE	0x00000002
#define IS_CLIENT_CHANGE	0x00000004
#define IS_CLIENT_UPGRADE	0x00000008
#define IS_CLIENT_ENABLED	0x00000010

#define IS_SERVER_INSTALL	0x00000100
#define IS_SERVER_REMOVE	0x00000200
#define IS_SERVER_CHANGE	0x00000400
#define IS_SERVER_UPGRADE	0x00000800
#define IS_SERVER_ENABLED	0x00001000

#define VP_MIN                  1
#define VP_MAX                  1000
#define VP_MAX_DAYS_WEEKS_MONTHS    9999

// count the number of bytes needed to fully store the WSZ
#define WSZ_BYTECOUNT(__z__)   \
    ( (__z__ == NULL) ? 0 : (wcslen(__z__)+1)*sizeof(WCHAR) )


typedef enum {
    cscInvalid,
    cscTopLevel,
    cscServer,
    cscClient,
} CertSubComponent;


typedef struct _UNATTENDPARM
{
    WCHAR const  *pwszName;
    WCHAR	**ppwszValue;
} UNATTENDPARM;

typedef struct _SUBCOMP
{
    WCHAR const *pwszSubComponent;
    CertSubComponent cscSubComponent;
    DWORD InstallFlags;
    DWORD UninstallFlags;
    DWORD ChangeFlags;
    DWORD UpgradeFlags;
    DWORD EnabledFlags;
    DWORD SetupStatusFlags;
    BOOL  fDefaultInstallUnattend;
    BOOL  fInstallUnattend;
    UNATTENDPARM *aUnattendParm;
} SUBCOMP;

HRESULT InitCASetup(HWND, PER_COMPONENT_DATA *pComp);

DWORD
myDoPageRequest(
    IN PER_COMPONENT_DATA *pComp,
    IN WizardPagesType WhichOnes,
    IN OUT PSETUP_REQUEST_PAGES SetupPages);

VOID
FreeCAComponentInfo(PER_COMPONENT_DATA *pComp);

HRESULT
PrepareUnattendedAttributes(
    IN HWND         hwnd,
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN PER_COMPONENT_DATA *pComp);

VOID
FreeCAGlobals(VOID);

HRESULT
HookUnattendedServerAttributes(
    IN OUT PER_COMPONENT_DATA *pComp,
    IN OUT const SUBCOMP      *pServerComp);

HRESULT
HookUnattendedClientAttributes(
    IN OUT PER_COMPONENT_DATA *pComp,
    IN OUT const SUBCOMP      *pClientComp);

SUBCOMP const *
LookupSubComponent(
    IN CertSubComponent SubComp);

HRESULT
EnableVRootsAndShares(
    IN BOOL fFileSharesOnly,
    IN BOOL fUpgrade,
    IN BOOL fServer,
    IN OUT PER_COMPONENT_DATA *pComp,
    IN HWND hwnd);

HRESULT
DisableVRootsAndShares(
    IN BOOL fFileSharesOnly);

HRESULT
InstallCore(
    IN HWND hwnd,
    IN PER_COMPONENT_DATA *pComp,
    IN BOOL fServer);

HRESULT
PreUninstallCore(
    IN HWND hwnd,
    IN PER_COMPONENT_DATA *pComp);

HRESULT
UninstallCore(
    IN HWND hwnd,
    OPTIONAL IN PER_COMPONENT_DATA *pComp,
    IN DWORD PerCentCompleteBase,
    IN DWORD PerCentCompleteMax,
    IN BOOL fPreserveClient,
    IN BOOL fRemoveVD,
    IN BOOL fPreserveToDoList);

HRESULT
UpgradeServer(
    IN HWND                hwnd,
    IN PER_COMPONENT_DATA *pComp);

HRESULT
UpgradeClient(
    IN HWND                hwnd,
    IN PER_COMPONENT_DATA *pComp);

HRESULT CreateConfigFiles(
    WCHAR *pwszDirectoryPath,
    PER_COMPONENT_DATA *pComp,
    BOOL fRemove);

HRESULT myStringToAnsiFile(HANDLE hFile, LPCSTR psz, DWORD cch);
HRESULT myStringToAnsiFile(HANDLE hFile, LPCWSTR pwsz, DWORD cch);
HRESULT myStringToAnsiFile(HANDLE hFile, CHAR ch);

HRESULT
myGetEnvString(
    WCHAR **ppwszOut,
    WCHAR const *pwszVariable);

VOID
certocmBumpGasGauge(
    IN PER_COMPONENT_DATA *pComp,
    IN DWORD PerCentComplete
    DBGPARM(IN WCHAR const *pwszSource));

HRESULT
UpdateSubComponentInstallStatus(
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN OUT PER_COMPONENT_DATA *pComp);

HRESULT StartCertsrvService(BOOL fSilent);

BOOL certocmIsEnabled(PER_COMPONENT_DATA *pComp, CertSubComponent SubComp);
BOOL certocmWasEnabled(PER_COMPONENT_DATA *pComp, CertSubComponent SubComp);
BOOL certocmInstalling(PER_COMPONENT_DATA *pComp, CertSubComponent SubComp);
BOOL certocmUninstalling(PER_COMPONENT_DATA *pComp, CertSubComponent SubComp);
BOOL certocmPreserving(PER_COMPONENT_DATA *pComp, CertSubComponent SubComp);
HRESULT certocmRetrieveUnattendedText(
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN PER_COMPONENT_DATA *pComp);

SUBCOMP *
TranslateSubComponent(
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent);

HRESULT
certocmReadInfString(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszName,
    IN OUT WCHAR **ppwszValue);

HRESULT
ImportPFXAndUpdateCSPInfo(
    IN const HWND    hDlg,
    IN OUT PER_COMPONENT_DATA *pComp);

HRESULT CreateProgramGroups(BOOL fClient,
                            PER_COMPONENT_DATA *pComp,
                            HWND hwnd);

HRESULT
LoadDefaultCAIDAttributes(
    IN OUT PER_COMPONENT_DATA *pComp);

HRESULT
LoadDefaultAdvanceAttributes(
    IN OUT CASERVERSETUPINFO* pServer);

HRESULT
BuildDBFileName(
    IN WCHAR const *pwszCAName,
    IN WCHAR const *pwszDBDirectory,
    OUT WCHAR **ppwszDBFile);

VOID
BuildPath(
    OUT WCHAR *pwszOut,
    IN DWORD cwcOut,
    IN WCHAR const *pwszDir,
    IN WCHAR const *pwszFile);

HRESULT
GetDefaultDBDirectory(
    IN PER_COMPONENT_DATA *pComp,
    OUT WCHAR            **ppwszDir);

HRESULT
GetDefaultSharedFolder(
    OUT WCHAR **ppwszSharedFolder);

HRESULT 
StartAndStopService(
    IN HINSTANCE    hInstance,
    IN BOOL         fUnattended,
    IN HWND const   hwnd,
    IN WCHAR const *pwszServiceName,
    IN BOOL const   fStopService,
    IN BOOL const   fConfirm,
    IN int          iMsg,
    OUT BOOL       *pfServiceWasRunning);

HRESULT
FixCertsvcService(
    IN PER_COMPONENT_DATA *pComp);

HRESULT
DetermineServerCustomModule(
    IN OUT PER_COMPONENT_DATA *pComp,
    IN BOOL  fPolicy);

HRESULT
DetermineServerUpgradePath(
    IN OUT PER_COMPONENT_DATA *pComp);

HRESULT
DetermineClientUpgradePath(
    IN OUT PER_COMPONENT_DATA *pComp);


HRESULT CreateCertWebDatIncPage(IN PER_COMPONENT_DATA *pComp, IN BOOL bIsServer);


HRESULT
CancelCertsrvInstallation(
    HWND                hwnd,
    PER_COMPONENT_DATA *pComp);

HRESULT
BuildCACertFileName(
    IN HINSTANCE        hInstance,
    IN HWND             hwnd,
    IN BOOL             fUnattended,
    OPTIONAL IN WCHAR   *pwszSharedFolder,
    IN WCHAR           *pwszSanitizedName,
    OUT WCHAR         **ppwszCACertFile);

HRESULT
myRenameCertRegKey(
    IN WCHAR const *pwszSrcCAName,
    IN WCHAR const *pwszDesCAName);

bool IsValidPeriod(const CASERVERSETUPINFO *pServer);

HRESULT
CheckPostBaseInstallStatus(
    OUT BOOL *pfFinished);

// externals

extern BOOL   g_fShowErrMsg;
extern HINSTANCE g_hInstance;
extern BOOL g_fW3SvcRunning;
extern WCHAR *g_pwszArgvPath;
extern WCHAR *g_pwszNoService;
#if DBG_CERTSRV
extern WCHAR *g_pwszDumpStrings;
#endif

extern UNATTENDPARM aUnattendParmClient[];
extern UNATTENDPARM aUnattendParmServer[];

#endif // __SETUPUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\resstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------

    RESSTR(IDS_STARTMENU_CERTHIER_LINKNAME),
    RESSTR(IDS_STARTMENU_CERTREQ_LINKNAME),
    RESSTR(IDS_STARTMENU_CERTSERVER),
    RESSTR(IDS_STARTMENU_NEWCRL_LINKNAME),
    RESSTR(IDS_ADVANCE_INVALIDKEYLENGTH),
    RESSTR(IDS_ADVANCE_KEYLENGTHOUTOFRANGE),
    RESSTR(IDS_ADVANCE_NEGATIVEKEYLENGTH),
    RESSTR(IDS_ADVANCE_SUBTITLE),
    RESSTR(IDS_ADVANCE_TITLE),
    RESSTR(IDS_ASK_CREATE_DIRECTORY),
    RESSTR(IDS_CALENSTRERR),
    RESSTR(IDS_CANULLSTRERR),
    RESSTR(IDS_CAREQUEST_SUBTITLE),
    RESSTR(IDS_CAREQUEST_TITLE),
    RESSTR(IDS_CATYPE_DES_ENTERPRISE_ROOTCA),
    RESSTR(IDS_CATYPE_DES_ENTERPRISE_SUBCA),
    RESSTR(IDS_CATYPE_DES_STANDALONE_ROOTCA),
    RESSTR(IDS_CATYPE_DES_STANDALONE_SUBCA),
    RESSTR(IDS_CATYPE_SUBTITLE),
    RESSTR(IDS_CATYPE_TITLE),
    RESSTR(IDS_CA_SERVICEDESCRIPTION),
    RESSTR(IDS_CA_SERVICEDISPLAYNAME),
    RESSTR(IDS_CERTCONFIG_FOLDERDESCR),
    RESSTR(IDS_CLIENT_NOCA),
    RESSTR(IDS_CLIENT_NOCOMPUTER),
    RESSTR(IDS_CLIENT_SUBTITLE),
    RESSTR(IDS_CLIENT_TITLE),
    RESSTR(IDS_COMPUTERLENSTRERR),
    RESSTR(IDS_COMPUTERNULLSTRERR),
    RESSTR(IDS_CONFIG_PICKER_PROMPT),
    RESSTR(IDS_CONFIG_PICKER_TITLE),
    RESSTR(IDS_ERR_ADDSOURCETOREGISTRY),
    RESSTR(IDS_ERR_ANALYSIS_CA),
    RESSTR(IDS_ERR_BUILDCERT),
    RESSTR(IDS_ERR_BUILDCERTREQUEST),
    RESSTR(IDS_FINAL_ERROR_TEXT),
    RESSTR(IDS_ERR_CERTSRV_SETUP_FAIL),
    RESSTR(IDS_ERR_CREATECERTSRVFILE),
    RESSTR(IDS_ERR_CREATELINK),
    RESSTR(IDS_ERR_CREATESERVICE),
    RESSTR(IDS_ERR_DELETESERVICE),
    RESSTR(IDS_ERR_DLLFUNCTION_CALL),
    RESSTR(IDS_ERR_EMPTYCANAME),
    RESSTR(IDS_ERR_EMPTYPFXFILE),
    RESSTR(IDS_ERR_FATAL_GENKEY),
    RESSTR(IDS_ERR_IMPORTPFX),
    RESSTR(IDS_ERR_INVALIDHASH),
    RESSTR(IDS_ERR_LOADICERTCONFIG),
    RESSTR(IDS_ERR_NETUSERMODALSGET),
    RESSTR(IDS_ERR_NOT_ADM),
    RESSTR(IDS_ERR_UNSUPPORTEDHASH),
    RESSTR(IDS_ERR_WRITECONFIGFILE),
    RESSTR(IDS_IDINFO_CAEXISTINDS),
    RESSTR(IDS_IDINFO_DESCRIPTIONLENSTRERR),
    RESSTR(IDS_IDINFO_COUNTRYLENSTRERR),
    RESSTR(IDS_IDINFO_DETERMINEDBYPCA),
    RESSTR(IDS_IDINFO_EMAILLENSTRERR),
    RESSTR(IDS_IDINFO_INVALID_COUNTRYCODE),
    RESSTR(IDS_IDINFO_INVALID_COUNTRYCODE_LEN),
    RESSTR(IDS_IDINFO_INVALID_VALIDITY),
    RESSTR(IDS_IDINFO_LOCALITYLENSTRERR),
    RESSTR(IDS_IDINFO_NAMELENSTRERR),
    RESSTR(IDS_IDINFO_NAMENULLSTRERR),
    RESSTR(IDS_IDINFO_ORGLENSTRERR),
    RESSTR(IDS_IDINFO_ORGUNITLENSTRERR),
    RESSTR(IDS_IDINFO_STATELENSTRERR),
    RESSTR(IDS_IDINFO_SUBTITLE),
    RESSTR(IDS_IDINFO_TITLE),
    RESSTR(IDS_IDINFO_VALIDITYNULLSTRERR),
    RESSTR(IDS_IMPORT_PFX_TITLE),
    RESSTR(IDS_INCOMPLETE_REQUEST),
    RESSTR(IDS_KEYGEN_GENERATING),
    RESSTR(IDS_KEYGEN_PROTECTING),
    RESSTR(IDS_KEYGEN_SUBTITLE),
    RESSTR(IDS_KEYGEN_TESTINGHASHANDKEY),
    RESSTR(IDS_KEYGEN_TITLE),
    RESSTR(IDS_KEY_INVALID),
    RESSTR(IDS_PATH_TOO_LONG_CANAME),
    RESSTR(IDS_PFX_FILE_FILTER),
    RESSTR(IDS_PFX_FILE_NOT_FOUND),
    RESSTR(IDS_PFX_INVALID_PASSWORD),
    RESSTR(IDS_PFX_KEYANDCERTEXIST),
    RESSTR(IDS_PFX_PATH_INVALID),
    RESSTR(IDS_REQUESTFILELENSTRERR),
    RESSTR(IDS_REQUESTFILENULLSTRERR),
    RESSTR(IDS_STOP_W3SVC),
    RESSTR(IDS_STORELOC_PARENTDIRMUSTEXIST),
    RESSTR(IDS_STORELOC_PATHTOOLONG),
    RESSTR(IDS_STORELOC_UNCMUSTEXIST),
    RESSTR(IDS_STORE_SUBTITLE),
    RESSTR(IDS_STORE_TITLE),
    RESSTR(IDS_TODO_TITLE),
    RESSTR(IDS_VALIDITY_DAY),
    RESSTR(IDS_VALIDITY_MONTH),
    RESSTR(IDS_VALIDITY_WEEK),
    RESSTR(IDS_VALIDITY_YEAR),
    RESSTR(IDS_WRN_DBFILEINUSE),
    RESSTR(IDS_WRN_OVERWRITEEXISTINGKEY),
    RESSTR(IDS_WRN_STORELOC_DB_FULLPATH),
    RESSTR(IDS_WRN_STORELOC_EXISTINGDB),
    RESSTR(IDS_WRN_STORELOC_LOG_FULLPATH),
    RESSTR(IDS_WRN_STORELOC_SHAREDFOLDER_FULLPATH),
    RESSTR(IDS_WRN_UNICODESTRINGENCODING),
    RESSTR(IDS_LOG_BEGIN),
    RESSTR(IDS_LOG_END),
    RESSTR(IDS_LOG_WAS_ENABLED),
    RESSTR(IDS_LOG_IS_ENABLED),
    RESSTR(IDS_LOG_INSTALL_STATE),
    RESSTR(IDS_LOG_CREATE_REQUEST),
    RESSTR(IDS_LOG_CREATE_CERTIFICATE),
    RESSTR(IDS_LOG_START_SERVICE),
    RESSTR(IDS_LOG_WEB_INCLUDE),
    RESSTR(IDS_LOG_INSTALL_CLIENT),
    RESSTR(IDS_LOG_INSTALL_SERVER),
    RESSTR(IDS_LOG_UPGRADE_TYPE),
    RESSTR(IDS_LOG_UPGRADE_CERT_STORE),
    RESSTR(IDS_LOG_UPGRADE_KEY_SECURITY),
    RESSTR(IDS_LOG_UPGRADE_SERVER),
    RESSTR(IDS_LOG_UPGRADE_CLIENT),
    RESSTR(IDS_LOG_SERVICE_STOPPED),
    RESSTR(IDS_LOG_SERVICE_STARTED),
    RESSTR(IDS_LOG_CREATE_CLIENT_REG),
    RESSTR(IDS_LOG_CREATE_SERVER_REG),
    RESSTR(IDS_LOG_UPGRADE_SERVER_REG),
    RESSTR(IDS_LOG_DLLS_UNREGISTERED),
    RESSTR(IDS_LOG_DLLS_REGISTERED),
    RESSTR(IDS_LOG_PROGRAM_GROUPS),
    RESSTR(IDS_LOG_CREATE_SERVICE),
    RESSTR(IDS_LOG_CANCEL_INSTALL),
    RESSTR(IDS_LOG_FUNCTION),
    RESSTR(IDS_LOG_UNATTENDED_ATTRIBUTE),
    RESSTR(IDS_LOG_CLIENT_UNATTENDED_ATTRIBUTES),
    RESSTR(IDS_LOG_SERVER_UNATTENDED_ATTRIBUTES),
    RESSTR(IDS_LOG_OPERATIONFLAGS),
    RESSTR(IDS_LOG_TODOLIST),
    RESSTR(IDS_LOG_POSTBASE),
    RESSTR(IDS_LOG_UNATTENDED),
    RESSTR(IDS_LOG_REGSTATE),
    RESSTR(IDS_LOG_SELECTIONSTATE),
    RESSTR(IDS_WELCOME_TITLE),
    RESSTR(IDS_FINAL_TITLE),
    RESSTR(IDS_LOG_IMPORTPFX),
    RESSTR(IDS_ERR_CREATE_DIR),
    RESSTR(IDS_WRN_UNINSTALL_BOTH),
    RESSTR(IDS_WRN_UNINSTALL_CLIENT),
    RESSTR(IDS_PFX_WRONG_SELFSIGN_TYPE),
    RESSTR(IDS_CAREQUEST_REQUESTFILEPATH_MUSTEXIST),
    RESSTR(IDS_LOG_IGNORE_KEYLENGTH),
    RESSTR(IDS_CAREQUEST_REQUESTFILEPATH_DIREXISTS),
    RESSTR(IDS_PFX_FILE_OR_PASSWORD_TOO_LONG),
    RESSTR(IDS_ERR_UPGRADE_NOT_SUPPORTED),
    RESSTR(IDS_WRN_SERVER_ONLY),
    RESSTR(IDS_IDINFO_VALIDITYLENSTRERR),
    RESSTR(IDS_WRN_IDINFO_INVALIDDN),
    RESSTR(IDS_HTML_CERTWEBDAT),
    RESSTR(IDS_HTML_NSREV),
    RESSTR(IDS_IDINFO_DELETECERTIFICATES),
    RESSTR(IDS_LOG_CANAME),
    RESSTR(IDS_LOG_ORG),
    RESSTR(IDS_LOG_ORGUNIT),
    RESSTR(IDS_LOG_LOCALITY),
    RESSTR(IDS_LOG_STATE),
    RESSTR(IDS_LOG_EMAIL),
    RESSTR(IDS_LOG_COUNTRY),
    RESSTR(IDS_LOG_DESCRIPTION),
    RESSTR(IDS_LOG_SHAREDFOLDER),
    RESSTR(IDS_LOG_DBDIR),
    RESSTR(IDS_LOG_DBLOGDIR),
    RESSTR(IDS_LOG_COMPUTER),
    RESSTR(IDS_LOG_REQUESTFILE),
    RESSTR(IDS_LOG_VALIDITY),
    RESSTR(IDS_LOG_CATYPE),
    RESSTR(IDS_LOG_KEYNAME),
    RESSTR(IDS_ERR_NONIA5DNSNAME),
    RESSTR(IDS_WRN_DBSPECIALCHARACTERS),
    RESSTR(IDS_WRN_NONAMECHANGE),
    RESSTR(IDS_WRN_KEYNAMETOOLONG),
    RESSTR(IDS_LOG_QUERYCHANGESELSTATE),
    RESSTR(IDS_PATH_TOO_LONG_DIRECTORY),
    RESSTR(IDS_LOG_BAD_CATYPE),
    RESSTR(IDS_LOG_BAD_OR_MISSING_CANAME),
    RESSTR(IDS_LOG_BAD_VALIDITY_PERIOD_STRING),
    RESSTR(IDS_LOG_CA_MACHINE_REQUIRED),
    RESSTR(IDS_LOG_CA_NAME_REQUIRED),
    RESSTR(IDS_LOG_PING_PARENT_FAIL),
    RESSTR(IDS_LOG_EMPTY_UNATTENDED_ATTRIBUTE),
    RESSTR(IDS_LOG_PATH_CAFILE_BUILD_FAIL),
    RESSTR(IDS_LOG_ENTERPRISE_NO_DS),
    RESSTR(IDS_LOG_BAD_COUNTRY_LENGTH),
    RESSTR(IDS_LOG_NO_CERT),
    RESSTR(IDS_LOG_REUSE_CERT_NO_REUSE_KEY),
    RESSTR(IDS_LOG_REUSE_DB_WITHOUT_REUSE_CERT),
    RESSTR(IDS_LOG_BAD_VALIDITY_PERIOD_COUNT),
    RESSTR(IDS_LOG_REQUEST_FILE_TOO_LONG),
    RESSTR(IDS_LOG_CANAME_TOO_LONG),
    RESSTR(IDS_LOG_PATH_TOO_LONG_CANAME),
    RESSTR(IDS_LOG_BAD_COUNTRY_CODE),
    RESSTR(IDS_LOG_KEY_NOT_FOUND_IN_LIST),
    RESSTR(IDS_LOG_DISABLE_WIZ_PAGE),
    RESSTR(IDS_LOG_WIZ_PAGE_ERROR),
    RESSTR(IDS_LOG_UPGRADE_UNSUPPORTED),
    RESSTR(IDS_LOG_UPGRADE_WIN2000),
    RESSTR(IDS_LOG_UPGRADE_B2B),
    RESSTR(IDS_LARGEFONTSIZE),
    RESSTR(IDS_LARGEFONTNAME),
    RESSTR(IDS_ILOG_SANITIZEDNAME),
    RESSTR(IDS_ILOG_KEYCONTAINERNAME),
    RESSTR(IDS_WRN_CANNOT_ADD_CA_TO_CERTPUBLISHERS),
    RESSTR(IDS_WRN_CANNOT_ADD_CA_TO_PREWIN2K),
    RESSTR(IDS_WRN_ASP_NOT_ENABLED),
    RESSTR(IDS_WRN_IIS_NOT_INSTALLED),
    RESSTR(IDS_WRN_OLD_DS_VERSION),
    RESSTR(IDS_ENTERPRISE_UNAVAIL_REASON),
    RESSTR(IDS_HELP_EXECUTE),
    RESSTR(IDS_SHARE_VERIFY_ERROR),
    RESSTR(IDS_LOG_SHARE_DISP),
    RESSTR(IDS_LOG_VROOT_DISP),
    RESSTR(IDS_CAHIER_CERTFILE_FILTER),
    RESSTR(IDS_CAHIER_INSTALL_TITLE),
    RESSTR(IDS_ILOG_MISSING_PROVIDER),
    RESSTR(IDS_ERR_INCOMPLETECHAIN),
    RESSTR(IDS_ERR_INVALIDCHAIN),
    RESSTR(IDS_ERR_RETRIEVE_PENDING),
    RESSTR(IDS_ILOG_GETCANAME),
    RESSTR(IDS_ILOG_SELECTCA),
    RESSTR(IDS_ILOG_SAVECERTANDKEYS),
    RESSTR(IDS_ILOG_RETRIEVECERT),
    RESSTR(IDS_ILOG_FINISHSUSPENDEDSETUP),
    RESSTR(IDS_ERR_NOTCACERT),
    RESSTR(IDS_ILOG_SETUPCOMPLETE),
    RESSTR(IDS_ILOG_RETRIEVEPENDING),
    RESSTR(IDS_ILOG_KEYINDEX),
    RESSTR(IDS_ILOG_LOADOLDCERT),
    RESSTR(IDS_ILOG_CLONECERT),
    RESSTR(IDS_ILOG_BUILDREQUEST),
    RESSTR(IDS_ILOG_RENEWOLDKEY),
    RESSTR(IDS_ILOG_INSTALLCERT),
    RESSTR(IDS_ILOG_RENEWNEWKEY),
    RESSTR(IDS_ILOG_BUILDCERT),
    RESSTR(IDS_ILOG_SAVECHAINANDKEYS),
    RESSTR(IDS_REQUEST_HELPTEXT),
    RESSTR(IDS_ILOG_CREATECDP),
    RESSTR(IDS_ILOG_CREATENTAUTHTRUST),
    RESSTR(IDS_ILOG_CREATEROOTTRUST),
    RESSTR(IDS_ILOG_PUBLISHCA),
    RESSTR(IDS_ILOG_SUBMITREQUEST),
    RESSTR(IDS_ERR_BADCSP),
    RESSTR(IDS_ERR_BAD_CA_CERT_7F),
    RESSTR(IDS_ERR_RENEWEDCERTCAVERSION),
    RESSTR(IDS_ERR_UNTRUSTEDROOT),
    RESSTR(IDS_ERR_CERTADDCERTIFICATECONTEXTTOSTORE),
    RESSTR(IDS_ERR_CERTCREATECERTIFICATECONTEXT),
    RESSTR(IDS_ILOG_UNREFERENCEDINFSECTIONS),
    RESSTR(IDS_ILOG_SETSECURITY),
    RESSTR(IDS_ERR_CREATEFILE),
    RESSTR(IDS_ERR_DELETEKEY),
    RESSTR(IDS_ERR_ENCODEKEYATTR),
    RESSTR(IDS_ERR_ENCODETOBESIGNED),
    RESSTR(IDS_ERR_ENV_NOT_SET),
    RESSTR(IDS_ERR_FULL_TOKEN),
    RESSTR(IDS_ERR_GENKEYFAIL),
    RESSTR(IDS_ERR_GETCOMPUTERNAME),
    RESSTR(IDS_ERR_KEYSECURITY),
    RESSTR(IDS_ERR_MYDECODENAME),
    RESSTR(IDS_ERR_NOT_ENTERPRISE_USER),
    RESSTR(IDS_ERR_NOT_MATCH_COMMONNAME),
    RESSTR(IDS_ILOG_GENERATEKEYS),
    RESSTR(IDS_ERR_REPEATWIZPREFIX),
    RESSTR(IDS_ERR_REQUEST_DENIED),
    RESSTR(IDS_ERR_REQUEST_ERROR),
    RESSTR(IDS_ERR_REQUEST_INCOMPLETE),
    RESSTR(IDS_ERR_REQUEST_OUTOFBAND),
    RESSTR(IDS_ERR_REQUEST_PENDING),
    RESSTR(IDS_ERR_REQUEST_REVOKED),
    RESSTR(IDS_ERR_SETKEYPROVIDER),
    RESSTR(IDS_ERR_SUBMIT_REQUEST),
    RESSTR(IDS_ERR_SUBMIT_REQUEST_FAIL),
    RESSTR(IDS_ERR_NOT_MATCH_BINARYNAME),
    RESSTR(IDS_ERR_NOT_MATCH_KEY),
    RESSTR(IDS_CAHIER_INSTALL_MISIINGCERT_TITLE),
    RESSTR(IDS_ERR_WRITEDERTOFILE),
    RESSTR(IDS_ERR_WRITEFILE),
    RESSTR(IDS_ILOG_INFERROR),
    RESSTR(IDS_ILOG_SETKEYSECURITY),
    RESSTR(IDS_MSG_PARENTCA_CONFIG),
    RESSTR(IDS_MSG_REQUEST_ID),
    RESSTR(IDS_MSG_TITLE),
    RESSTR(IDS_ILOG_SETADMINONLYFOLDERSECURITY),
    RESSTR(IDS_ERR_NO_KEY_ACCESS),
    RESSTR(IDS_CA_PICKER_TITLE),
    RESSTR(IDS_CA_PICKER_PROMPT),
    RESSTR(IDS_CERTTYPE_USER),
    RESSTR(IDS_CERTTYPE_USER_AS),
    RESSTR(IDS_CERTTYPE_USER_SMARTCARD_LOGON),
    RESSTR(IDS_CERTTYPE_EFS),
    RESSTR(IDS_CERTTYPE_ADMIN),
    RESSTR(IDS_CERTTYPE_EFS_RECOVERY),
    RESSTR(IDS_CERTTYPE_CODE_SIGNING),
    RESSTR(IDS_CERTTYPE_CTL_SIGNING),
    RESSTR(IDS_CERTTYPE_MACHINE),
    RESSTR(IDS_CERTTYPE_DC),
    RESSTR(IDS_CERTTYPE_WEBSERVER),
    RESSTR(IDS_CERTTYPE_KDC),
    RESSTR(IDS_CERTTYPE_ROOT_CA),
    RESSTR(IDS_CERTTYPE_SUBORDINATE_CA),
    RESSTR(IDS_CERTTYPE_ENROLLMENT_AGENT),
    RESSTR(IDS_CERTTYPE_SMARTCARD_USER),
    RESSTR(IDS_CERTTYPE_USER_SIGNATURE),
    RESSTR(IDS_ILOG_BAD_NUMERICFIELD),
    RESSTR(IDS_CERTTYPE_IPSEC_INTERMEDIATE_ONLINE),
    RESSTR(IDS_ILOG_BAD_VALIDITY_COUNT),
    RESSTR(IDS_CERTTYPE_IPSEC_INTERMEDIATE_OFFLINE),
    RESSTR(IDS_ILOG_BAD_VALIDITY_STRING),
    RESSTR(IDS_CERTTYPE_ROUTER_OFFLINE),
    RESSTR(IDS_REQUEST_FILE_DEFEXT),
    RESSTR(IDS_REQUEST_OPEN_TITLE),
    RESSTR(IDS_REQUEST_FILE_FILTER),
    RESSTR(IDS_WRN_COMPUTERNAME_EMPTY),
    RESSTR(IDS_WRN_CANAME_EMPTY),
    RESSTR(IDS_WRN_CANAME_NOT_MATCH),
    RESSTR(IDS_WRN_PINGCA_FAIL),
    RESSTR(IDS_CERTTYPE_ENROLLMENT_AGENT_OFFLINE),
    RESSTR(IDS_CERTTYPE_EXCHANGE_USER),
    RESSTR(IDS_CERTTYPE_EXCHANGE_USER_SIGNATURE),
    RESSTR(IDS_WRN_CALIST_EMPTY),
    RESSTR(IDS_CERTTYPE_MACHINE_ENROLLMENT_AGENT),
    RESSTR(IDS_REQUEST_SAVE_TITLE),
    RESSTR(IDS_CERTTYPE_CEP_ENCRYPTION),
    RESSTR(IDS_ILOG_CAPOLICY_BUILD),
    RESSTR(IDS_ILOG_CAPOLICY_ELEMENT),
    RESSTR(IDS_ILOG_CAPOLICY_EXTENSION),
    RESSTR(IDS_ILOG_CAPOLICY_NOKEY),
    RESSTR(IDS_ILOG_CAPOLICY_OPEN),
    RESSTR(IDS_ILOG_CAPOLICY_OPEN_FAILED),
    RESSTR(IDS_ILOG_BEGIN),
    RESSTR(IDS_ILOG_END),
    RESSTR(IDS_ACTRL_CAADMIN),
    RESSTR(IDS_ACTRL_OFFICER),
    RESSTR(IDS_ACTRL_AUDITOR),
    RESSTR(IDS_ACTRL_OPERATOR),
    RESSTR(IDS_ACTRL_CAREAD),
    RESSTR(IDS_ACTRL_ENROLL),
    RESSTR(IDS_ILOG_CAPOLICY_CLOSE),
    RESSTR(IDS_ILOG_MESSAGEBOX),
    RESSTR(IDS_ILOG_BAD_VALIDITY_STRING_UNATTEND),
    RESSTR(IDS_CERTTYPE_KEY_RECOVERY_AGENT),
    RESSTR(IDS_CERTTYPE_CA_EXCHANGE),
    RESSTR(IDS_EMPTY_FRIENDLY_NAME),
    RESSTR(IDS_CERTTYPE_CROSS_CA),
    RESSTR(IDS_CERTTYPE_DC_AUTH),
    RESSTR(IDS_CERTTYPE_DS_EMAIL_REPLICATION),
    RESSTR(IDS_WARN_ENTERPRISE_REQUIREMENTS),
    RESSTR(IDS_WRN_OLD_CA),
    RESSTR(IDS_ILOG_BAD_BOOLEAN),
    RESSTR(IDS_CERTTYPE_WORKSTATION),
    RESSTR(IDS_CERTTYPE_RASIASSERVER),
    RESSTR(IDS_LOW_ASSURANCE_DISPLAY_NAME),
    RESSTR(IDS_MEDIUM_ASSURANCE_DISPLAY_NAME),
    RESSTR(IDS_HIGH_ASSURANCE_DISPLAY_NAME),
    RESSTR(IDS_KRA_DESCRIPTION),
    RESSTR(IDS_EMAIL_REPLICATION_DESCRIPTION),
    RESSTR(IDS_CROSS_CA_DESCRIPTION),
    RESSTR(IDS_CA_DESCRIPTION),
    RESSTR(IDS_MACHINE_DESCRIPTION),
    RESSTR(IDS_END_USER_DESCRIPTION),
    RESSTR(IDS_UNKNOWN_DESCRIPTION),
    RESSTR(IDS_STORENAME_DS_KRA),
    RESSTR(IDS_STORENAME_DS_AIA),
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\setuput.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       setuput.cpp
//
//  Contents:   Utility functions for OCM based setup.
//
//  History:    04/20/97        JerryK  Created
//
//-------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// ** C Runtime Includes
#include <sys/types.h>
#include <sys/stat.h>

// ** System Includes **
#include <lmaccess.h>
#include <lmapibuf.h>
#include "csdisp.h"
#include <shlobj.h>
#include <userenv.h>
#include <dsgetdc.h>
#include <sddl.h>
#include <winldap.h>
#include <autoenr.h>
#include <userenvp.h>   // CreateLinkFile API

// ** security includes **
#include <aclapi.h>


// ** Application Includes **
#include "initcert.h"
#include "cscsp.h"
#include "cspenum.h"
#include "csldap.h"

#include "wizpage.h"
#include "websetup.h"

#include "certsrvd.h"
#include "regd.h"
#include "usecert.h"
#include "certmsg.h"
#include "dssetup.h"
#include "progress.h"
#include <certca.h>
#include "cainfop.h"
#include "csprop.h"
#include "setupids.h"
#include "multisz.h"

#define __dwFILE__	__dwFILE_OCMSETUP_SETUPUT_CPP__

EXTERN_C const IID IID_IGPEInformation;
EXTERN_C const CLSID CLSID_GPESnapIn;

#define CERT_HALF_SECOND  500          // # of milliseconds in half second
#define CERT_MAX_ATTEMPT   2 * 60 * 2   // # of half seconds in 2 minutes

#define wszREQUESTVERINDPROGID  L"CertSrv.Request"
#define wszREQUESTPROGID        L"CertSrv.Request.1"
#define wszADMINVERINDPROGID    L"CertSrv.Admin"
#define wszADMINPROGID          L"CertSrv.Admin.1"
#define wszREQUESTFRIENDLYNAME  L"CertSrv Request"
#define wszADMINFRIENDLYNAME    L"CertSrv Admin"

#define wszCERTSRV              L"CertSrv"

#define wszREGW3SCRIPTMAP L"System\\CurrentControlSet\\Services\\W3SVC\\Parameters\\Script Map"



#define wszHTTPS         L"https://"
#define wszASPEXT        L".asp"
#define wszHTTP          L"http://"
#define wszDOTCERTEXT    L".cer"
#define wszNEWLINE       L"\n"
#define wszFILESC        L"file://\\\\"

#define SZ_REGSVR32 L"regsvr32.exe"
#define SZ_REGSVR32_CERTCLI L"/i:i /n /s certcli.dll"
#define SZ_VERB_OPEN L"open"


// hardcoded shares
#define wszCERTENROLLURLPATH    L"/CertEnroll/"


#define wszzREGSUBJECTTEMPLATEVALUE \
    wszPROPEMAIL L"\0" \
    wszPROPCOMMONNAME L"\0" \
    wszATTRORGUNIT4 L"\0" \
    wszPROPORGANIZATION L"\0" \
    wszPROPLOCALITY L"\0" \
    wszPROPSTATE L"\0" \
    wszPROPDOMAINCOMPONENT L"\0" \
    wszPROPCOUNTRY L"\0"


// Whistler SMIME extension (or any other CSP):
// SMIME Capabilities
//     [1]SMIME Capability
//          Object ID=1.2.840.113549.3.2       szOID_RSA_RC2CBC, 128 bit
//          Parameters=02 02 00 80
//     [2]SMIME Capability
//          Object ID=1.2.840.113549.3.4       szOID_RSA_RC4, 128 bit
//          Parameters=02 02 00 80
//     [3]SMIME Capability
//          Object ID=1.3.14.3.2.7             szOID_OIWSEC_desCBC
//     [4]SMIME Capability
//          Object ID=1.2.840.113549.3.7       szOID_RSA_DES_EDE3_CBC
//

#define wszzREGVALUEDEFAULTSMIME \
    TEXT(szOID_RSA_RC2CBC) L",128" L"\0" \
    TEXT(szOID_RSA_RC4) L",128" L"\0" \
    TEXT(szOID_OIWSEC_desCBC) L"\0" \
    TEXT(szOID_RSA_DES_EDE3_CBC) L"\0"


#ifdef CERTSRV_ENABLE_ALL_REGISTRY_DEFAULTS
# define wszREGSUBJECTALTNAMEVALUE L"EMail"
# define wszREGSUBJECTALTNAME2VALUE L"EMail"
#else
# define wszREGSUBJECTALTNAMEVALUE \
    L"DISABLED: Set to EMail to set SubjectAltName extension to the email address"

# define wszREGSUBJECTALTNAME2VALUE \
    L"DISABLED: Set to EMail to set SubjectAltName2 extension to the email address"

#endif

#define szNULL_SESSION_REG_LOCATION "System\\CurrentControlSet\\Services\\LanmanServer\\Parameters"
#define szNULL_SESSION_VALUE "NullSessionPipes"

#define wszDEFAULTSHAREDFOLDER  L"\\CAConfig"


// globals
WCHAR *g_pwszArgvPath = NULL;          // for installing from local directory
WCHAR *g_pwszNoService = NULL;         // skip CreateService
WCHAR *g_pwszSanitizedChar = NULL;     // take first char for sanitizing test
#if DBG_CERTSRV
WCHAR *g_pwszDumpStrings = NULL;       // dump resource strings
#endif

BOOL            g_fW3SvcRunning = FALSE;
WCHAR           g_wszServicePath[MAX_PATH];



// Version-independent ProgID
// ProgID


WCHAR const g_wszCertAdmDotDll[]      = L"certadm.dll";
WCHAR const g_wszCertCliDotDll[]      = L"certcli.dll";
WCHAR const g_wszcertEncDotDll[]      = L"certenc.dll";
WCHAR const g_wszCertXDSDotDll[]      = L"certxds.dll";
WCHAR const g_wszCertIfDotDll[]       = L"certif.dll";
WCHAR const g_wszCertPDefDotDll[]     = L"certpdef.dll";
WCHAR const g_wszCertMMCDotDll[]      = L"certmmc.dll";
WCHAR const g_wszCertSrvDotMsc[]      = L"certsrv.msc";

WCHAR const g_wszSCrdEnrlDotDll[]     = L"scrdenrl.dll";

WCHAR const g_wszCertReqDotExe[]      = L"certreq.exe";
WCHAR const g_wszCertUtilDotExe[]     = L"certutil.exe";

WCHAR const g_wszCertDBDotDll[]       = L"certdb.dll";
WCHAR const g_wszCertViewDotDll[]     = L"certview.dll";

WCHAR const g_wszCSBullDotGif[]    = L"csbull.gif";
WCHAR const g_wszCSBackDotGif[]    = L"csback.gif";
WCHAR const g_wszCSLogoDotGif[]    = L"cslogo.gif";

CHAR const * const aszRegisterServer[] = {
    "DllRegisterServer",
    "DllUnregisterServer",
};

typedef struct _REGISTERDLL
{
    WCHAR const *pwszDllName;
    DWORD        Flags;
} REGISTERDLL;

#define RD_SERVER       0x00000001  // Register on server
#define RD_CLIENT       0x00000002  // Register on client
#define RD_UNREGISTER   0x00000004  // Unegister on client & server
#define RD_WHISTLER     0x00000008  // Register must succeed on Whistler only
#define RD_SKIPUNREGPOLICY 0x00000010  // not unreg custom policy during upgrade
#define RD_SKIPUNREGEXIT   0x00000020  // not unreg custom exit during upgrade

REGISTERDLL const g_aRegisterDll[] = {
  { g_wszCertAdmDotDll,  RD_SERVER | RD_CLIENT },
  { g_wszCertCliDotDll,  RD_SERVER | RD_CLIENT },
  { g_wszcertEncDotDll,  RD_SERVER | RD_CLIENT | RD_UNREGISTER },
  { g_wszCertXDSDotDll,  RD_SERVER },
  { g_wszCertIfDotDll,                           RD_UNREGISTER },
  { g_wszCertPDefDotDll, RD_SERVER },
  { g_wszCertMMCDotDll,  RD_SERVER },
  { g_wszSCrdEnrlDotDll, RD_SERVER | RD_CLIENT | RD_UNREGISTER | RD_WHISTLER },
  { g_wszCertDBDotDll,   RD_SERVER |             RD_UNREGISTER },
  { g_wszCertViewDotDll,                         RD_UNREGISTER },
  { NULL,                     0 }
};


typedef struct _PROGRAMENTRY
{
    UINT        uiLinkName;
    UINT        uiGroupName;
    UINT        uiDescription;
    DWORD       csidl;          // special folder index
    WCHAR const *pwszExeName;
    WCHAR const *pwszClientArgs;
    WCHAR const *pwszServerArgs;
    DWORD        Flags;
} PROGRAMENTRY;

#define PE_SERVER               0x00000001  // Install on server
#define PE_CLIENT               0x00000002  // Install on client
#define PE_DELETEONLY           0x00000004  // Always delete

PROGRAMENTRY const g_aProgramEntry[] = {
    {
        IDS_STARTMENU_NEWCRL_LINKNAME,          // uiLinkName
        IDS_STARTMENU_CERTSERVER,               // uiGroupName
        0,                                      // uiDescription
        CSIDL_COMMON_PROGRAMS,                  // "All Users\Start Menu\Programs"
        g_wszCertUtilDotExe,                    // pwszExeName
        NULL,                                   // pwszClientArgs
        L"-crl -",                              // pwszServerArgs
        PE_DELETEONLY | PE_SERVER,              // Flags
    },
    {
        IDS_STARTMENU_CERTHIER_LINKNAME,        // uiLinkName
        IDS_STARTMENU_CERTSERVER,               // uiGroupName
        0,                                      // uiDescription
        CSIDL_COMMON_PROGRAMS,                  // "All Users\Start Menu\Programs"
        L"certhier.exe",                        // pwszExeName
        NULL,                                   // pwszClientArgs
        NULL,                                   // pwszServerArgs
        PE_DELETEONLY | PE_SERVER,              // Flags
    },
    {
        IDS_STARTMENU_CERTREQ_LINKNAME,          // uiLinkName
        IDS_STARTMENU_CERTSERVER,               // uiGroupName
        0,                                      // uiDescription
        CSIDL_COMMON_PROGRAMS,                  // "All Users\Start Menu\Programs"
        g_wszCertReqDotExe,                     // pwszExeName
        NULL,                                   // pwszClientArgs
        NULL,                                   // pwszServerArgs
        PE_DELETEONLY | PE_CLIENT | PE_SERVER,  // Flags
    },
};
#define CPROGRAMENTRY   ARRAYSIZE(g_aProgramEntry)

static char rgcCERT_NULL_SESSION[] = {0x43, 0x45, 0x52, 0x54, 0x00, 0x00};

// ** Prototypes **

HRESULT
UpgradeServerRegEntries(
    IN PER_COMPONENT_DATA *pComp);

HRESULT
CreateServerRegEntries(
    IN BOOL fUpgrade,
    IN PER_COMPONENT_DATA *pComp);

HRESULT
CreateWebClientRegEntries(
    BOOL                fUpgrade,
    PER_COMPONENT_DATA *pComp);

HRESULT
UpgradeWebClientRegEntries(
    PER_COMPONENT_DATA *pComp);

HRESULT
GetServerNames(
    IN HWND hwnd,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    OUT WCHAR **ppwszServerName,
    OUT WCHAR **ppwszServerNameOld);

HRESULT
UpdateDomainAndUserName(
    IN HWND hwnd,
    IN OUT PER_COMPONENT_DATA *pComp);

HRESULT
RegisterAndUnRegisterDLLs(
    IN DWORD Flags,
    IN PER_COMPONENT_DATA *pComp,
    IN HWND hwnd);


HRESULT RenameMiscTargets(HWND hwnd, PER_COMPONENT_DATA *pComp, BOOL fServer);
HRESULT DeleteProgramGroups(IN BOOL fAll);

HRESULT CreateCertificateService(PER_COMPONENT_DATA *pComp, HWND hwnd);

//endproto


#ifdef DBG_OCM_TRACE
VOID
CaptureStackBackTrace(
    EXCEPTION_POINTERS *pep,
    ULONG cSkip,
    ULONG cFrames,
    ULONG *aeip)
{
    ZeroMemory(aeip, cFrames * sizeof(aeip[0]));

#if i386 == 1
    ULONG ieip, *pebp;
    ULONG *pebpMax = (ULONG *) MAXLONG; // 2 * 1024 * 1024 * 1024; // 2 gig - 1
    ULONG *pebpMin = (ULONG *) (64 * 1024);     // 64k

    if (pep == NULL)
    {
        ieip = 0;
        cSkip++;                    // always skip current frame
        pebp = ((ULONG *) &pep) - 2;
    }
    else
    {
        ieip = 1;
        CSASSERT(cSkip == 0);
        aeip[0] = pep->ContextRecord->Eip;
        pebp = (ULONG *) pep->ContextRecord->Ebp;
    }
    if (pebp >= pebpMin && pebp < pebpMax)
    {
        __try
        {
            for ( ; ieip < cSkip + cFrames; ieip++)
            {
                if (ieip >= cSkip)
                {
                    aeip[ieip - cSkip] = *(pebp + 1);  // save an eip
                }

                ULONG *pebpNext = (ULONG *) *pebp;
                if (pebpNext < pebp + 2 || pebpNext >= pebpMax - 1)
                {
                    break;
                }
                pebp = pebpNext;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            ;
        }
    }
#endif // i386 == 1
}
#endif // DBG_OCM_TRACE


VOID
DumpBackTrace(
    char const *
#ifdef DBG_OCM_TRACE
    pszName
#endif // DBG_OCM_TRACE
    )
{
#ifdef DBG_OCM_TRACE
    ULONG aeip[10];

    DBGPRINT((MAXDWORD, "%hs: BackTrace:\n", pszName));
    CaptureStackBackTrace(NULL, 1, ARRAYSIZE(aeip), aeip);

    for (int i = 0; i < ARRAYSIZE(aeip); i++)
    {
        if (NULL == aeip[i])
        {
            break;
        }
        DBGPRINT((MAXDWORD, "ln %x;", aeip[i]));
    }
    DBGPRINT((MAXDWORD, "\n"));
#endif // DBG_OCM_TRACE
}

__inline VOID
AppendBackSlash(
    IN OUT WCHAR *pwszOut)
{
    DWORD cwc = wcslen(pwszOut);

    if (0 == cwc || L'\\' != pwszOut[cwc - 1])
    {
        pwszOut[cwc++] = L'\\';
        pwszOut[cwc] = L'\0';
    }
}


__inline VOID
StripBackSlash(
    IN OUT WCHAR *pwszOut)
{
    DWORD cwc = wcslen(pwszOut);

    if (0 < cwc && L'\\' == pwszOut[cwc - 1])
    {
        pwszOut[cwc] = L'\0';
    }
}

VOID
BuildPath(
    OUT WCHAR *pwszOut,
    IN DWORD DBGPARMREFERENCED(cwcOut),
    IN WCHAR const *pwszDir,
    IN WCHAR const *pwszFile)
{
    wcscpy(pwszOut, pwszDir);
    AppendBackSlash(pwszOut);
    wcscat(pwszOut, pwszFile);
    StripBackSlash(pwszOut);

    CSASSERT(wcslen(pwszOut) < cwcOut);

    DBGPRINT((DBG_SS_CERTOCMI, "BuildPath(%ws, %ws) -> %ws\n", pwszDir, pwszFile, pwszOut));
}


VOID
FreeCARequestInfo(CASERVERSETUPINFO *pServer)
{
    if (NULL != pServer->pwszRequestFile)
    {
        LocalFree(pServer->pwszRequestFile);
    }
    if (NULL != pServer->pwszParentCAMachine)
    {
        LocalFree(pServer->pwszParentCAMachine);
    }
    if (NULL != pServer->pwszParentCAName)
    {
        LocalFree(pServer->pwszParentCAName);
    }
}


VOID
FreeCAStoreInfo(CASERVERSETUPINFO *pServer)
{
    if (NULL != pServer->pwszSharedFolder)
    {
        LocalFree(pServer->pwszSharedFolder);
    }
    if (NULL != pServer->pwszDBDirectory)
    {
        LocalFree(pServer->pwszDBDirectory);
    }
    if (NULL != pServer->pwszLogDirectory)
    {
        LocalFree(pServer->pwszLogDirectory);
    }
}


VOID
FreeCAServerAdvanceInfo(CASERVERSETUPINFO *pServer)
{
    if (NULL != pServer->pCSPInfoList)
    {
        FreeCSPInfoList(pServer->pCSPInfoList);
    }
    if (NULL != pServer->pKeyList)
    {
        csiFreeKeyList(pServer->pKeyList);
    }
    if (NULL != pServer->pDefaultCSPInfo)
    {
        freeCSPInfo(pServer->pDefaultCSPInfo);
    }
    if (NULL != pServer->pwszDesanitizedKeyContainerName)
    {
        LocalFree(pServer->pwszDesanitizedKeyContainerName);
    }
    if (NULL != pServer->pccExistingCert)
    {
        ClearExistingCertToUse(pServer);
    }
    if (NULL != pServer->pccUpgradeCert)
    {
        CertFreeCertificateContext(pServer->pccUpgradeCert);
    }
    if (NULL != pServer->pwszValidityPeriodCount)
    {
        LocalFree(pServer->pwszValidityPeriodCount);
    }
    if (NULL != pServer->pszAlgId)
    {
        LocalFree(pServer->pszAlgId);
    }
    if (NULL != pServer->hMyStore)
    {
        CertCloseStore(pServer->hMyStore, 0);
    }

    // don't free following because they are just pointers
    // pServer->pCSPInfo
    // pServer->pHashInfo
}


VOID
FreeCAServerIdInfo(
    CASERVERSETUPINFO *pServer)
{
    if (NULL != pServer->pwszCACommonName)
    {
        LocalFree(pServer->pwszCACommonName);
        pServer->pwszCACommonName = NULL;
    }
}


VOID
FreeCAServerInfo(CASERVERSETUPINFO *pServer)
{
    FreeCAServerIdInfo(pServer);

    FreeCAServerAdvanceInfo(pServer);

    FreeCAStoreInfo(pServer);

    FreeCARequestInfo(pServer);

    if (NULL != pServer->pwszSanitizedName)
    {
        LocalFree(pServer->pwszSanitizedName);
    }

    if (NULL != pServer->pwszDNSuffix)
    {
        LocalFree(pServer->pwszDNSuffix);
    }

    if (NULL != pServer->pwszFullCADN)
    {
        LocalFree(pServer->pwszFullCADN);
    }

    if (NULL != pServer->pwszKeyContainerName)
    {
        LocalFree(pServer->pwszKeyContainerName);
    }

    if (NULL != pServer->pwszCACertFile)
    {
        LocalFree(pServer->pwszCACertFile);
    }

    if (NULL != pServer->pwszUseExistingCert)
    {
        LocalFree(pServer->pwszUseExistingCert);
    }

    if (NULL != pServer->pwszPreserveDB)
    {
        LocalFree(pServer->pwszPreserveDB);
    }


    if (NULL != pServer->pwszCustomPolicy)
    {
        LocalFree(pServer->pwszCustomPolicy);
    }

    if (NULL != pServer->pwszzCustomExit)
    {
        LocalFree(pServer->pwszzCustomExit);
    }
}


VOID
FreeCAClientInfo(CAWEBCLIENTSETUPINFO *pClient)
{
    if (NULL != pClient)
    {
        if (NULL != pClient->pwszWebCAMachine)
        {
            LocalFree(pClient->pwszWebCAMachine);
        }
        if (NULL != pClient->pwszWebCAName)
        {
            LocalFree(pClient->pwszWebCAName);
        }
        if (NULL != pClient->pwszSanitizedWebCAName)
        {
            LocalFree(pClient->pwszSanitizedWebCAName);
        }
        if (NULL != pClient->pwszSharedFolder)
        {
            LocalFree(pClient->pwszSharedFolder);
        }
    }
}


VOID
FreeCAInfo(CASETUPINFO *pCA)
{
    if (NULL != pCA->pServer)
    {
        FreeCAServerInfo(pCA->pServer);
        LocalFree(pCA->pServer);
        pCA->pServer = NULL;
    }
    if (NULL != pCA->pClient)
    {
        FreeCAClientInfo(pCA->pClient);
        LocalFree(pCA->pClient);
        pCA->pClient = NULL;
    }
}


VOID
FreeCAComponentInfo(PER_COMPONENT_DATA *pComp)
{
    if (NULL != pComp->pwszCustomMessage)
    {
	LocalFree(pComp->pwszCustomMessage);
    }
    if (NULL != pComp->pwszComponent)
    {
        LocalFree(pComp->pwszComponent);
    }
    if (NULL != pComp->pwszUnattendedFile)
    {
        LocalFree(pComp->pwszUnattendedFile);
    }
    if (NULL != pComp->pwszServerName)
    {
        LocalFree(pComp->pwszServerName);
    }
    if (NULL != pComp->pwszServerNameOld)
    {
        LocalFree(pComp->pwszServerNameOld);
    }
    if (NULL != pComp->pwszSystem32)
    {
        LocalFree(pComp->pwszSystem32);
    }
    FreeCAInfo(&(pComp->CA));
}


VOID
FreeCAGlobals(VOID)
{
    if (NULL != g_pwszArgvPath)
    {
        LocalFree(g_pwszArgvPath);
    }
    if (NULL != g_pwszNoService)
    {
        LocalFree(g_pwszNoService);
    }
    if (NULL != g_pwszSanitizedChar)
    {
        LocalFree(g_pwszSanitizedChar);
    }
#if DBG_CERTSRV
    if (NULL != g_pwszDumpStrings)
    {
        LocalFree(g_pwszDumpStrings);
    }
#endif
}


VOID
SaveCustomMessage(
    IN OUT PER_COMPONENT_DATA *pComp,
    OPTIONAL IN WCHAR const *pwszCustomMessage)
{
    HRESULT hr;

    if (NULL != pwszCustomMessage)
    {
	if (NULL != pComp->pwszCustomMessage)
	{
	    LocalFree(pComp->pwszCustomMessage);
	    pComp->pwszCustomMessage = NULL;
	}
	hr = myDupString(pwszCustomMessage, &pComp->pwszCustomMessage);
	_JumpIfError(hr, error, "myDupString");
    }
error:
    ;
}



HRESULT
LoadDefaultCAIDAttributes(
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    // free existing Id info before load default
    FreeCAServerIdInfo(pServer);

    // load default from resource
    if (NULL != g_pwszSanitizedChar)
    {
        if (NULL != pServer->pwszCACommonName)
        {
            LocalFree(pServer->pwszCACommonName);
        }
        // replace with the env var
        pServer->pwszCACommonName = (WCHAR*)LocalAlloc(LMEM_FIXED,
                    (wcslen(g_pwszSanitizedChar) + 1) * sizeof(WCHAR));
        _JumpIfOutOfMemory(hr, error, pServer->pwszCACommonName);
        wcscpy(pServer->pwszCACommonName, g_pwszSanitizedChar);
    }


    // default validity
    pServer->enumValidityPeriod = dwVALIDITYPERIODENUMDEFAULT;
    pServer->dwValidityPeriodCount = dwVALIDITYPERIODCOUNTDEFAULT_ROOT;
    GetSystemTimeAsFileTime(&pServer->NotBefore);
    pServer->NotAfter = pServer->NotBefore;
    myMakeExprDateTime(
		&pServer->NotAfter,
		pServer->dwValidityPeriodCount,
		pServer->enumValidityPeriod);

    hr = S_OK;
error:
    return(hr);
}


HRESULT
GetDefaultDBDirectory(
    IN PER_COMPONENT_DATA *pComp,
    OUT WCHAR            **ppwszDir)
{
    HRESULT hr;
    DWORD cwc;

    *ppwszDir = NULL;
    cwc = wcslen(pComp->pwszSystem32) +
        wcslen(wszLOGPATH) +
        1;

    *ppwszDir = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, *ppwszDir);

    // default
    wcscpy(*ppwszDir, pComp->pwszSystem32);
    wcscat(*ppwszDir, wszLOGPATH);

    CSASSERT(cwc == (DWORD) (wcslen(*ppwszDir) + 1));
    hr = S_OK;

error:
    return(hr);
}


HRESULT
LoadDefaultDBDirAttributes(
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT    hr;
    CASERVERSETUPINFO  *pServer = pComp->CA.pServer;

    if (NULL != pServer->pwszDBDirectory)
    {
        LocalFree(pServer->pwszDBDirectory);
        pServer->pwszDBDirectory = NULL;
    }
    hr = GetDefaultDBDirectory(pComp, &pServer->pwszDBDirectory);
    _JumpIfError(hr, error, "GetDefaultDBDirectory");

    // default log dir is the same as db
    if (NULL != pServer->pwszLogDirectory)
    {
        LocalFree(pServer->pwszLogDirectory);
    }
    pServer->pwszLogDirectory = (WCHAR *) LocalAlloc(
                LMEM_FIXED,
                (wcslen(pServer->pwszDBDirectory) + 1) * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pServer->pwszLogDirectory);

    wcscpy(pServer->pwszLogDirectory, pServer->pwszDBDirectory);

    pServer->fPreserveDB = FALSE;

    hr = S_OK;
error:
    return(hr);
}


HRESULT
LoadDefaultAdvanceAttributes(
    IN OUT CASERVERSETUPINFO* pServer)
{
    HRESULT  hr;

    // load default csp, ms base csp
    pServer->fAdvance = FALSE;
    if (NULL == pServer->pDefaultCSPInfo)
    {
        pServer->pDefaultCSPInfo = newCSPInfo(PROV_RSA_FULL, wszBASECSP);
	if (NULL == pServer->pDefaultCSPInfo && !IsWhistler())
	{
	    pServer->pDefaultCSPInfo = newCSPInfo(PROV_RSA_FULL, MS_DEF_PROV_W);
	}
        _JumpIfOutOfMemory(hr, error, pServer->pDefaultCSPInfo);
    }

    // determine default hash, sha1
    pServer->pDefaultHashInfo = pServer->pDefaultCSPInfo->pHashList;
    while (NULL != pServer->pDefaultHashInfo)
    {
        if (pServer->pDefaultHashInfo->idAlg == CALG_SHA1)
        {
            //got default
            break;
        }
        pServer->pDefaultHashInfo = pServer->pDefaultHashInfo->next;
    }

    // If we have not just created a default key, reset the key container name.
    if (pServer->pCSPInfo != pServer->pDefaultCSPInfo || 
        (pServer->dwKeyLength != CA_DEFAULT_KEY_LENGTH_ROOT &&
         pServer->dwKeyLength != CA_DEFAULT_KEY_LENGTH_SUB) ||
        !pServer->fDeletableNewKey) {

        ClearKeyContainerName(pServer);
    }

    // ok, point to defaults
    pServer->pCSPInfo = pServer->pDefaultCSPInfo;
    pServer->pHashInfo = pServer->pDefaultHashInfo;

    // some other related defaults
    pServer->dwKeyLength = IsRootCA(pServer->CAType)?
        CA_DEFAULT_KEY_LENGTH_ROOT:
        CA_DEFAULT_KEY_LENGTH_SUB;
    pServer->dwKeyLenMin = 0;
    pServer->dwKeyLenMax = 0;

    // update hash oid
    if (NULL != pServer->pszAlgId)
    {
        // free old
        LocalFree(pServer->pszAlgId);
    }

    hr = myGetSigningOID(
		     NULL,	// hProv
		     pServer->pCSPInfo->pwszProvName,
		     pServer->pCSPInfo->dwProvType,
		     pServer->pHashInfo->idAlg,
		     &(pServer->pszAlgId));
    _JumpIfError(hr, error, "myGetSigningOID");

error:
    return(hr);
}


HRESULT
LoadDefaultCAClientAttributes(
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;

    if (NULL != pClient)
    {
        // free existing client setup info
        FreeCAClientInfo(pClient);
        LocalFree(pClient);
        pComp->CA.pClient = NULL;
    }
    pComp->CA.pClient = (CAWEBCLIENTSETUPINFO *) LocalAlloc(
                                                LMEM_FIXED | LMEM_ZEROINIT,
                                                sizeof(CAWEBCLIENTSETUPINFO));
    _JumpIfOutOfMemory(hr, error, pComp->CA.pClient);

    pComp->CA.pClient->WebCAType = ENUM_UNKNOWN_CA;

    hr = S_OK;

error:
    return(hr);
}


HRESULT
GetDefaultSharedFolder(
    OUT WCHAR **ppwszSharedFolder)
{
    HRESULT  hr = S_OK;
    WCHAR   *pwszSysDrive = NULL;

    *ppwszSharedFolder = NULL;

    hr = myGetEnvString(&pwszSysDrive, L"SystemDrive");
    if (S_OK == hr)
    {
        *ppwszSharedFolder = (WCHAR *) LocalAlloc(
            LMEM_FIXED,
            (wcslen(pwszSysDrive) + wcslen(wszDEFAULTSHAREDFOLDER) + 1) *
             sizeof(WCHAR));
        _JumpIfOutOfMemory(hr, error, *ppwszSharedFolder);

        wcscpy(*ppwszSharedFolder, pwszSysDrive);
        wcscat(*ppwszSharedFolder, wszDEFAULTSHAREDFOLDER);
    }

error:
    if (NULL != pwszSysDrive)
    {
        LocalFree(pwszSysDrive);
    }
    return hr;
}


HRESULT
LoadDefaultCAServerAttributes(
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT    hr;
    BOOL       fDSCA = FALSE;
    bool fIsDomainMember;
    bool fUserCanInstallCA;
    bool fIsOldDSVersion;

    if (NULL != pComp->CA.pServer)
    {
        // free existing server setup info
        FreeCAServerInfo(pComp->CA.pServer);
        LocalFree(pComp->CA.pServer);
    }
    // allocate server info buffer
    pComp->CA.pServer = (CASERVERSETUPINFO *) LocalAlloc(
                            LMEM_FIXED | LMEM_ZEROINIT,
                            sizeof(CASERVERSETUPINFO));
    _JumpIfOutOfMemory(hr, error, pComp->CA.pServer);

    hr = LoadDefaultCAIDAttributes(pComp);
    _JumpIfError(hr, error, "LoadDefaultCAIDAttributes");

    hr = LoadDefaultAdvanceAttributes(pComp->CA.pServer);
    _JumpIfError(hr, error, "LoadDefaultAdvanceAttributes");

    hr = LoadDefaultDBDirAttributes(pComp);
    _JumpIfError(hr, error, "LoadDefaultDBDirAttributes");

    // decide default using DS
    // xtan, the following call should be replaced with HasDSWritePermission()
    //       remove DisableEnterpriseCAs()

    pComp->CA.pServer->fUseDS = FALSE;

    
    hr = myLocalMachineIsDomainMember(&fIsDomainMember);
    _JumpIfError(hr, error, "myLocalMachineIsDomainMember");

    if (fIsDomainMember)
    {
        if(IsDSAvailable(&fIsOldDSVersion))
        {
            if(fIsOldDSVersion)
            {
                pComp->CA.pServer->EnterpriseUnavailReason = 
                    ENUM_ENTERPRISE_UNAVAIL_REASON_OLD_DS_VERSION;
            }
            else
            {
                hr = CurrentUserCanInstallCA(fUserCanInstallCA);
                _JumpIfError(hr, error, "CurrentUserCanInstallCA");
            
                if(fUserCanInstallCA)
                {
                    pComp->CA.pServer->fUseDS = TRUE;
                    fDSCA = csiIsAnyDSCAAvailable();
                    pComp->CA.pServer->EnterpriseUnavailReason = 
                        ENUM_ENTERPRISE_UNAVAIL_REASON_AVAILABLE;
                }
                else
                {
                    pComp->CA.pServer->EnterpriseUnavailReason = 
                        ENUM_ENTERPRISE_UNAVAIL_REASON_NO_INSTALL_RIGHTS;
                }
            }
        }
        else
        {
            pComp->CA.pServer->EnterpriseUnavailReason = 
                ENUM_ENTERPRISE_UNAVAIL_REASON_DS_UNAVAILABLE;
        }
    } 
    else
    {
        pComp->CA.pServer->EnterpriseUnavailReason = 
            ENUM_ENTERPRISE_UNAVAIL_REASON_DOMAIN_NOT_JOINED;
    }

    // alway free and null old shared folder
    if (NULL != pComp->CA.pServer->pwszSharedFolder)
    {
        LocalFree(pComp->CA.pServer->pwszSharedFolder);
        pComp->CA.pServer->pwszSharedFolder = NULL;
    }

    // decide default CA type and default shared folder
    pComp->CA.pServer->CAType = ENUM_STANDALONE_ROOTCA;
    if (pComp->CA.pServer->fUseDS)
    {
        if (fDSCA)
        {
            pComp->CA.pServer->CAType = ENUM_ENTERPRISE_SUBCA;
        }
        else
        {
            pComp->CA.pServer->CAType = ENUM_ENTERPRISE_ROOTCA;
        }
    }

    if (pComp->fUnattended || !pComp->CA.pServer->fUseDS)
    {
        BOOL fChangeToDefault = FALSE;

        // try reg load first
        hr = myGetCertRegStrValue(
                     NULL,
                     NULL,
                     NULL,
                     wszREGDIRECTORY,
                     &pComp->CA.pServer->pwszSharedFolder);
        if (S_OK != hr && HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
        {
            _JumpErrorStr(hr, error, "myGetCertRegStrValue", wszREGDIRECTORY);
        }
        if (S_OK == hr)
        {
            if (L'\0' == *pComp->CA.pServer->pwszSharedFolder)
            {
                // this mast be empty string
                fChangeToDefault = TRUE;
            }
            else
            {
                //got something, make sure unc path exist
                DWORD dwPathFlag;
                if (!myIsFullPath(pComp->CA.pServer->pwszSharedFolder,
                                  &dwPathFlag))
                {
                    // somehow register an invalid path, don't use it
                    fChangeToDefault = TRUE;
                }
                else
                {
                    if (UNC_PATH == dwPathFlag &&
                        DE_DIREXISTS != DirExists(pComp->CA.pServer->pwszSharedFolder))
                    {
                        // this unc path doesn't exist any more
                        // not making any sense to use it
                        fChangeToDefault = TRUE;
                        pComp->CA.pServer->fUNCPathNotFound = TRUE;
                    }
                }
            }
        }
        else
        {
            //must be not found
            fChangeToDefault = TRUE;
        }

        if (fChangeToDefault)
        {
            //free 1st
            if (NULL != pComp->CA.pServer->pwszSharedFolder)
            {
                LocalFree(pComp->CA.pServer->pwszSharedFolder);
            }
            // load default
            hr = GetDefaultSharedFolder(&pComp->CA.pServer->pwszSharedFolder);
            _JumpIfError(hr, error, "GetDefaultSharedFolder");
        }
    }

    pComp->CA.pServer->fSaveRequestAsFile = FALSE;
    pComp->CA.pServer->pwszRequestFile = NULL;
    pComp->CA.pServer->pwszParentCAMachine = NULL;
    pComp->CA.pServer->pwszParentCAName = NULL;
    hr = S_OK;

error:
    return hr;
}

HRESULT
InitCASetup(
    IN HWND hwnd,
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT       hr;
    UINT ui;
    bool fIsAdmin = false;

    hr = GetServerNames(
		    hwnd,
		    pComp->hInstance,
		    pComp->fUnattended,
		    &pComp->pwszServerName,
		    &pComp->pwszServerNameOld);
    _JumpIfError(hr, error, "GetServerNames");

    DBGPRINT((
	DBG_SS_CERTOCMI,
	"InitCASetup:GetServerNames:%ws,%ws\n",
	pComp->pwszServerName,
	pComp->pwszServerNameOld));

    DumpBackTrace("InitCASetup");

    hr = myIsCurrentUserBuiltinAdmin(&fIsAdmin);
    _JumpIfError(hr, error, "myIsCurrentUserBuiltinAdmin");

    if (!fIsAdmin)
    {
        hr = E_ACCESSDENIED;
        CertErrorMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hwnd,
            IDS_ERR_NOT_ADM,
            hr,
            NULL);
        _JumpError(hr, error, "myIsCurrentUserBuiltinAdmin");
    }

    // load some of environment variables
    hr = myGetEnvString(&g_pwszArgvPath, L"CertSrv_BinDir");
    hr = myGetEnvString(&g_pwszNoService, L"CertSrv_NoService");
    hr = myGetEnvString(&g_pwszSanitizedChar, L"CertSrv_Sanitize");
#if DBG_CERTSRV
    myGetEnvString(&g_pwszDumpStrings, L"CertSrv_DumpStrings");
#endif


    // figure out where the system root directory is (build path to x:\\winnt\system32\)
    ui = GetSystemDirectory(NULL, 0);   // returns chars neccessary to hold path (incl null)
    if (ui == 0)
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSystemDirectory");
    }
    pComp->pwszSystem32 = (LPWSTR)LocalAlloc(LMEM_FIXED, (ui+1)*sizeof(WCHAR));
    if (NULL == pComp->pwszSystem32)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    if (0 == GetSystemDirectory(pComp->pwszSystem32, ui))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSystemDirectory");
    }
    wcscat(pComp->pwszSystem32, L"\\");

    // load default atrributes anyway
    hr = LoadDefaultCAServerAttributes(pComp);
    _JumpIfError(hr, error, "LoadDefaultCAServerAttributes");

    hr = LoadDefaultCAClientAttributes(pComp);
    _JumpIfError(hr, error, "LoadDefaultCAClientAttributes");

    if (pComp->fUnattended)
    {
        // hook unattended data
        hr = HookUnattendedServerAttributes(pComp,
                 LookupSubComponent(cscServer));
        _JumpIfError(hr, error, "HookUnattendedServerAttributes");

        hr = HookUnattendedClientAttributes(pComp,
                 LookupSubComponent(cscClient));
        _JumpIfError(hr, error, "HookUnattendedClientAttributes");
    }


    hr = S_OK;
error:
    return(hr);
}


HRESULT
CreateInitialCertificateRequest(
    IN HCRYPTPROV hProv,
    IN CASERVERSETUPINFO *pServer,
    IN PER_COMPONENT_DATA *pComp,
    IN HWND hwnd,
    OUT BYTE **ppbEncode,
    OUT DWORD *pcbEncode)
{
    HRESULT hr;
    BYTE *pbSubjectEncoded = NULL;
    DWORD cbSubjectEncoded;
    HINF hInf = INVALID_HANDLE_VALUE;
    DWORD ErrorLine;

    hr = AddCNAndEncode(
        pServer->pwszCACommonName,
        pServer->pwszDNSuffix,
        &pbSubjectEncoded,
        &cbSubjectEncoded);
    _JumpIfError(hr, error, "AddCNAndEncodeCertStrToName");

    hr = myInfOpenFile(NULL, &hInf, &ErrorLine);
    _PrintIfError2(
	    hr,
	    "myInfOpenFile",
	    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    hr = csiBuildRequest(
		hInf,
		NULL,
		pbSubjectEncoded,
		cbSubjectEncoded,
		pServer->pszAlgId,
		TRUE,			// fNewKey
		CANAMEIDTOICERT(pServer->dwCertNameId),
		CANAMEIDTOIKEY(pServer->dwCertNameId),
		hProv,
		hwnd,
                pComp->hInstance,
                pComp->fUnattended,
		ppbEncode,
		pcbEncode);
    _JumpIfError(hr, error, "csiBuildRequest");

error:
    if (INVALID_HANDLE_VALUE != hInf)
    {
	myInfCloseFile(hInf);
    }
    if (NULL != pbSubjectEncoded)
    {
        myFree(pbSubjectEncoded, CERTLIB_USE_LOCALALLOC);
    }
    CSILOG(hr, IDS_LOG_CREATE_REQUEST, NULL, NULL, NULL);
    return(hr);
}


HRESULT
BuildCAHierarchy(
    HCRYPTPROV hProv,
    PER_COMPONENT_DATA *pComp,
    CRYPT_KEY_PROV_INFO const *pKeyProvInfo,
    HWND hwnd)
{
    HRESULT    hr;
    BYTE      *pbRequest = NULL;
    DWORD      cbRequest;
    CASERVERSETUPINFO    *pServer = pComp->CA.pServer;
    BSTR       bStrChain = NULL;

    if (!pServer->fSaveRequestAsFile)
    {
        // online case
        if (NULL == pServer->pwszParentCAMachine ||
            NULL == pServer->pwszParentCAName)
        {
            hr = E_POINTER;
            _JumpError(hr, error, "Empty machine name or parent ca name");
        }
    }

    // create request 1st

    hr = CreateInitialCertificateRequest(
				hProv,
				pServer,
				pComp,
				hwnd,
				&pbRequest,
				&cbRequest);
    if (S_OK != hr)
    {
        pComp->iErrMsg = IDS_ERR_BUILDCERTREQUEST;
        _JumpError(hr, error, "CreateInitialCertificateRequest");
    }

    // save it to a file always
    hr = EncodeToFileW(
		pServer->pwszRequestFile,
		pbRequest,
		cbRequest,
		DECF_FORCEOVERWRITE | CRYPT_STRING_BASE64REQUESTHEADER);
    _JumpIfError(hr, error, "EncodeToFileW");

    // register request file name always

    hr = mySetCARegFileNameTemplate(
			    wszREGREQUESTFILENAME,
			    pComp->pwszServerName,
			    pServer->pwszSanitizedName,
			    pServer->pwszRequestFile);
    _JumpIfErrorStr(hr, error, "mySetCARegFileNameTemplate", wszREGREQUESTFILENAME);

    if (pServer->fSaveRequestAsFile)
    {
        // mark it as request file
        hr = SetSetupStatus(
                        pServer->pwszSanitizedName,
                        SETUP_SUSPEND_FLAG | SETUP_REQUEST_FLAG,
                        TRUE);
        _JumpIfError(hr, error, "SetSetupStatus");

        // done if save as request file
        goto done;
    }

    hr = csiSubmitCARequest(
		 pComp->hInstance,
		 pComp->fUnattended,
		 hwnd,
		 FALSE,		// fRenew
		 0,		// ICert
		 FALSE,		// fRetrievePending
		 pServer->pwszSanitizedName,
		 pServer->pwszParentCAMachine,
		 pServer->pwszParentCAName,
		 pbRequest,
		 cbRequest,
		 &bStrChain);
    // in any case, you can finish setup from mmc

    _JumpIfError(hr, done, "csiSubmitCARequest");

    hr = csiFinishInstallationFromPKCS7(
				pComp->hInstance,
				pComp->fUnattended,
				hwnd,
				pServer->pwszSanitizedName,
				pServer->pwszCACommonName,
				pKeyProvInfo,
				pServer->CAType,
				CANAMEIDTOICERT(pServer->dwCertNameId),
				CANAMEIDTOIKEY(pServer->dwCertNameId),
				pServer->fUseDS,
				FALSE,		// fRenew
				pComp->pwszServerName,
				(BYTE *) bStrChain,
				SysStringByteLen(bStrChain),
				pServer->pwszCACertFile);
    _JumpIfError(hr, error, "csiFinishInstallationFromPKCS7");

done:
    hr = S_OK;

error:
    if (NULL != pbRequest)
    {
        myFree(pbRequest, CERTLIB_USE_LOCALALLOC);
    }
    if (NULL != bStrChain)
    {
        SysFreeString(bStrChain);
    }
    return(hr);
}


// Find the newest CA cert that:
//  - matches the passed Subject CN,
//  - matches the passed cert index,
//  - expires prior the next newer cert (compare to pNotAfter)
//  - expires latest of all that match the above
//  - has KeyProvInfo
//  - key and cert can be used together to sign

HRESULT
SetCARegOldCertHashByIndex(
    IN WCHAR const *pwszSanitizedName,
    IN HCERTSTORE hStore,
    IN WCHAR const *pwszCN,
    IN DWORD iCert,
    IN OUT FILETIME *pNotAfter)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    CERT_CONTEXT const *pCertNewest = NULL;
    WCHAR *pwszCNT = NULL;
    DWORD dwProvType;
    WCHAR *pwszProvName = NULL;
    ALG_ID idAlg;
    BOOL fMachineKeyset;
    DWORD dwNameId;
    DWORD cbKey;
    CRYPT_KEY_PROV_INFO *pKey = NULL;

    hr = myGetCertSrvCSP(
		FALSE,		// fEncryptionCSP
                pwszSanitizedName,
                &dwProvType,
                &pwszProvName,
                &idAlg,
                &fMachineKeyset,
		NULL);		// pdwKeySize
    _JumpIfError(hr, error, "myGetCertSrvCSP");

    for (;;)
    {
	if (NULL != pKey)
	{
	    LocalFree(pKey);
	    pKey = NULL;
	}
	if (NULL != pwszCNT)
	{
	    LocalFree(pwszCNT);
	    pwszCNT = NULL;
	}
	pCert = CertEnumCertificatesInStore(hStore, pCert);
	if (NULL == pCert)
	{
	    break;
	}

	hr = myGetCommonName(
		    &pCert->pCertInfo->Subject,
		    FALSE,	// fAllowDefault
		    &pwszCNT);
	if (S_OK != hr)
	{
	    _PrintError(hr, "myGetCommonName");
	    continue;
	}
	if (0 != lstrcmp(pwszCN, pwszCNT))
	{
	    DBGPRINT((DBG_SS_CERTOCM, "Skipping cert: %ws\n", pwszCNT));
	    continue;
	}
	hr = myGetNameId(pCert, &dwNameId);
	if (S_OK != hr ||
	    MAXDWORD == dwNameId ||
	    CANAMEIDTOICERT(dwNameId) != iCert)
	{
	    DBGPRINT((DBG_SS_CERTOCM, "Skipping cert: NameId=%x\n", dwNameId));
	    continue;
	}
	DBGPRINT((DBG_SS_CERTOCM, "NameId=%x\n", dwNameId));

	if (0 < CompareFileTime(&pCert->pCertInfo->NotAfter, pNotAfter))
	{
	    DBGPRINT((DBG_SS_CERTOCM, "Skipping cert: too new\n"));
	    continue;
	}

	if (!myCertGetCertificateContextProperty(
					pCert,
					CERT_KEY_PROV_INFO_PROP_ID,
					CERTLIB_USE_LOCALALLOC,
					(VOID **) &pKey,
					&cbKey))
	{
	    hr = myHLastError();
	    _PrintError(hr, "CertGetCertificateContextProperty");
	    continue;
	}
        hr = myValidateSigningKey(
				pKey->pwszContainerName,
				pwszProvName,
				dwProvType,
				FALSE,		// fCryptSilent
				fMachineKeyset,
				TRUE,		// fForceSignatureTest
				pCert,
				NULL,		// pPublicKeyInfo
				idAlg,
				NULL,		// pfSigningTestAttempted
				NULL);		// phProv
        if (S_OK != hr)
	{
	    _PrintError(hr, "myValidateSigningKey");
	    continue;
	}

	if (NULL != pCertNewest)
	{
            if (0 > CompareFileTime(
			&pCert->pCertInfo->NotAfter,
			&pCertNewest->pCertInfo->NotAfter))
	    {
		DBGPRINT((DBG_SS_CERTOCM, "Skipping cert: not newest\n"));
		continue;
	    }
	    CertFreeCertificateContext(pCertNewest);
	    pCertNewest = NULL;
	}
	pCertNewest = CertDuplicateCertificateContext(pCert);
	if (NULL == pCertNewest)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertDuplicateCertificate");
	}
    }
    if (NULL == pCertNewest)
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "CertEnumCertificatesInStore");
    }

    // mark as unarchived:

    CertSetCertificateContextProperty(
				pCertNewest,
				CERT_ARCHIVED_PROP_ID,
				0,
				NULL);

    hr = mySetCARegHash(pwszSanitizedName, CSRH_CASIGCERT, iCert, pCertNewest);
    _JumpIfError(hr, error, "mySetCARegHash");

    *pNotAfter = pCertNewest->pCertInfo->NotAfter;

error:
    if (NULL != pKey)
    {
	LocalFree(pKey);
    }
    if (NULL != pwszCNT)
    {
	LocalFree(pwszCNT);
    }
    if (NULL != pwszProvName)
    {
        LocalFree(pwszProvName);
    }
    if (NULL != pCertNewest)
    {
        CertFreeCertificateContext(pCertNewest);
    }
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    return(hr);
}


HRESULT
SetCARegOldCertHashes(
    IN WCHAR const *pwszSanitizedName,
    IN DWORD cCertOld,
    IN CERT_CONTEXT const *pccCA)
{
    HRESULT hr;
    HCERTSTORE hMyStore = NULL;
    DWORD i;
    WCHAR *pwszCN = NULL;
    FILETIME NotAfter;

    if (0 != cCertOld)
    {
	hr = myGetCommonName(
		    &pccCA->pCertInfo->Subject,
		    FALSE,		// fAllowDefault
		    &pwszCN);
	_JumpIfError(hr, error, "myGetCommonName");

	// open my store

	hMyStore = CertOpenStore(
		        CERT_STORE_PROV_SYSTEM_W,
		        X509_ASN_ENCODING,
		        NULL,                        // hProv
			CERT_SYSTEM_STORE_LOCAL_MACHINE |
			    CERT_STORE_ENUM_ARCHIVED_FLAG | 
			    CERT_STORE_READONLY_FLAG,
		        wszMY_CERTSTORE);
	if (NULL == hMyStore)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertOpenStore");
	}

	NotAfter = pccCA->pCertInfo->NotAfter;

	for (i = cCertOld; i > 0; i--)
	{
	    hr = SetCARegOldCertHashByIndex(
				pwszSanitizedName,
				hMyStore,
				pwszCN,
				i - 1,
				&NotAfter);
	    _PrintIfError(hr, "SetCARegOldCertHashByIndex");
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszCN)
    {
        LocalFree(pwszCN);
    }
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, 0);
    }
    return(hr);
}


HRESULT
CreateCertificates(
    IN OUT PER_COMPONENT_DATA *pComp,
    IN HWND hwnd)
{
    HRESULT hr;
    HCRYPTPROV hCryptProv = NULL;
    CRYPT_KEY_PROV_INFO keyProvInfo;
    WCHAR wszEnrollPath[MAX_PATH];
    CERT_CONTEXT const *pccCA = NULL;
    BYTE *pbEncoded = NULL;
    WCHAR *pwszEnrollPath = NULL;
    WCHAR *pwszDir = NULL;
    WCHAR *pwszFolderPath = NULL;
    BOOL fEnableKeyCounting = FALSE;

    wszEnrollPath[0] = L'\0';
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    ZeroMemory(&keyProvInfo, sizeof(keyProvInfo));

    if (NULL == pServer->pwszKeyContainerName && pComp->fUnattended)
    {
        hr = myInfGetEnableKeyCounting(
			    pComp->hinfCAPolicy,
			    &fEnableKeyCounting);
	if (S_OK != hr)
	{
	    fEnableKeyCounting = FALSE;
	}

        // create a new key if unattended

        hr = csiGenerateCAKeys(
                        pServer->pwszSanitizedName,
                        pServer->pCSPInfo->pwszProvName,
                        pServer->pCSPInfo->dwProvType,
                        pServer->pCSPInfo->fMachineKeyset,
                        pServer->dwKeyLength,
                        pComp->hInstance,
                        pComp->fUnattended,
                        fEnableKeyCounting,
                        hwnd,
                        &pComp->CA.pServer->fKeyGenFailed);
        if (S_OK != hr)
        {
            CertErrorMessageBox(
                           pComp->hInstance,
                           pComp->fUnattended,
                           hwnd,
                           IDS_ERR_FATAL_GENKEY,
                           hr,
                           pServer->pwszSanitizedName);
            _JumpIfError(hr, error, "csiGenerateCAKeys");
        }

        // now set this as the existing key
        hr = SetKeyContainerName(pServer, pServer->pwszSanitizedName);
        _JumpIfError(hr, error, "SetKeyContainerName");
    }

    hr = csiFillKeyProvInfo(
                    pServer->pwszKeyContainerName,
                    pServer->pCSPInfo->pwszProvName,
                    pServer->pCSPInfo->dwProvType,
                    pServer->pCSPInfo->fMachineKeyset,
                    &keyProvInfo);
    _JumpIfError(hr, error, "csiFillKeyProvInfo");

    // get csp handle
    if (!myCertSrvCryptAcquireContext(
                            &hCryptProv,
                            pServer->pwszKeyContainerName,
                            pServer->pCSPInfo->pwszProvName,
                            pServer->pCSPInfo->dwProvType,
                            pComp->fUnattended? CRYPT_SILENT : 0, // query
                            pServer->pCSPInfo->fMachineKeyset))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }
    if (hCryptProv == NULL)
    {
        hr = E_HANDLE;
        _JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }

    // open certificate store
    if (NULL == pServer->hMyStore)
    {
        pServer->hMyStore = CertOpenStore(
                                CERT_STORE_PROV_SYSTEM_W,
                                X509_ASN_ENCODING,
                                NULL,           // hProv
                                CERT_SYSTEM_STORE_LOCAL_MACHINE |
                                    CERT_STORE_ENUM_ARCHIVED_FLAG,
                                wszMY_CERTSTORE);
        if (NULL == pServer->hMyStore)
        {
            // no store exists, done
            hr = myHLastError();
            _JumpIfError(hr, error, "CertOpenStore");
        }
    }

    if (NULL != pServer->pccExistingCert)
    {
        // reuse cert, mark unarchived
        CertSetCertificateContextProperty(
                                pServer->pccExistingCert,
                                CERT_ARCHIVED_PROP_ID,
                                0,
                                NULL);
    }

    if (IsSubordinateCA(pServer->CAType) && NULL == pServer->pccExistingCert)
    {
        hr = BuildCAHierarchy(hCryptProv, pComp, &keyProvInfo, hwnd);
        _JumpIfError(hr, error, "BuildCAHierarchy");
    }
    else
    {
        WCHAR const *pwszCertName;
	DWORD cwc;

        BuildPath(
            wszEnrollPath,
            ARRAYSIZE(wszEnrollPath),
            pComp->pwszSystem32,
            wszCERTENROLLSHAREPATH);

	hr = csiBuildFileName(
		    wszEnrollPath,
		    pServer->pwszSanitizedName,
		    L".crt",
		    CANAMEIDTOICERT(pServer->dwCertNameId),
		    &pwszEnrollPath, 
		    pComp->hInstance,
		    pComp->fUnattended,
		    NULL);
	_JumpIfError(hr, error, "csiBuildFileName");

        CSASSERT(NULL != pServer->pwszCACertFile);
        pwszCertName = wcsrchr(pServer->pwszCACertFile, L'\\');
        CSASSERT(NULL != pwszCertName);

        cwc = SAFE_SUBTRACT_POINTERS(pwszCertName, pServer->pwszCACertFile);
	pwszDir = (WCHAR *) LocalAlloc(LMEM_FIXED,  (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszDir)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(pwszDir, pServer->pwszCACertFile, cwc * sizeof(WCHAR));
	pwszDir[cwc] = L'\0';

	hr = csiBuildFileName(
		    pwszDir,
		    pServer->pwszSanitizedName,
		    L".crt",
		    CANAMEIDTOICERT(pServer->dwCertNameId),
		    &pwszFolderPath, 
		    pComp->hInstance,
		    pComp->fUnattended,
		    NULL);
	_JumpIfError(hr, error, "csiBuildFileName");

        // create and save a selfsigned root cert

        hr = csiBuildAndWriteCert(
            hCryptProv,
            pServer,
	    pwszFolderPath, 
            pwszEnrollPath,
            pServer->pccExistingCert, // if NULL, we will build a new cert
            &pccCA,
            wszCERTTYPE_CA,
            pComp->hInstance,
            pComp->fUnattended,
            hwnd);
        if (S_OK != hr)
        {
            CertErrorMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hwnd,
                IDS_ERR_BUILDCERT,
                hr,
                NULL);
            _JumpError(hr, error, "csiBuildAndWriteCert");
        }

	hr = SetCARegOldCertHashes(
		    pServer->pwszSanitizedName,
		    CANAMEIDTOICERT(pServer->dwCertNameId),
		    pccCA);
        _JumpIfError(hr, error, "SetCARegOldCertHashes");

        hr = mySetCARegHash(
                        pServer->pwszSanitizedName,
			CSRH_CASIGCERT,
			CANAMEIDTOICERT(pServer->dwCertNameId),
                        pccCA);
        _JumpIfError(hr, error, "mySetCARegHash");

	hr = csiSaveCertAndKeys(pccCA, NULL, &keyProvInfo, pServer->CAType);
	_JumpIfError(hr, error, "csiSaveCertAndKeys");

        if (pServer->fUseDS)
        {

            BOOL fLoadDefaultTemplates = TRUE;
            DWORD ErrorLine;
            HINF hInf = INVALID_HANDLE_VALUE;

            hr = myInfOpenFile(NULL, &hInf, &ErrorLine);
            _PrintIfError2(
                    hr,
                    "myInfOpenFile",
                    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

            if (INVALID_HANDLE_VALUE != hInf)
            {
                hr = myInfGetBooleanValue(
				    hInf,
				    wszINFSECTION_CERTSERVER,
				    wszINFKEY_LOADDEFAULTTEMPLATES,
				    TRUE,
				    &fLoadDefaultTemplates);
		if (S_OK != hr)
		{
		    _PrintErrorStr(
				hr,
				"myInfGetBooleanValue",
				wszINFKEY_LOADDEFAULTTEMPLATES);
		    fLoadDefaultTemplates = TRUE;
		}
                myInfCloseFile(hInf);
            }

            hr = csiSetupCAInDS(
                        pComp->pwszServerName,
                        pServer->pwszSanitizedName,
                        pServer->pwszCACommonName,
                        fLoadDefaultTemplates,
                        pServer->CAType,
                        CANAMEIDTOICERT(pServer->dwCertNameId),
                        CANAMEIDTOIKEY(pServer->dwCertNameId),
                        FALSE,		// fRenew
                        pccCA);
            _PrintIfError(hr, "csiSetupCAInDS");
     
            if (hr == S_OK)
                 pServer->fSavedCAInDS = TRUE;
        }
    }
    hr = S_OK;

error:
    csiFreeKeyProvInfo(&keyProvInfo);
    if (NULL != pbEncoded)
    {
        LocalFree(pbEncoded);
    }
    if (NULL != pwszDir)
    {
        LocalFree(pwszDir);
    }
    if (NULL != pwszFolderPath)
    {
        LocalFree(pwszFolderPath);
    }
    if (NULL != pwszEnrollPath)
    {
        LocalFree(pwszEnrollPath);
    }
    if (NULL != pccCA)
    {
        CertFreeCertificateContext(pccCA);
    }
    if (NULL != hCryptProv)
    {
        CryptReleaseContext(hCryptProv, 0);
    }
    CSILOG(hr, IDS_LOG_CREATE_CERTIFICATE, NULL, NULL, NULL);
    return(hr);
}


HRESULT
StartCertsrvService(BOOL fSilent)
{
    HRESULT hr;
    SC_HANDLE hSCManager = NULL;
    SC_HANDLE hSCCertsvc = NULL;
    SERVICE_STATUS status;
    DWORD dwAttempt;
    BOOL fSawPending;
    WCHAR const *apwszSilentArg[1] = {L"-s"};

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (NULL == hSCManager)
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenSCManager");
    }
    hSCCertsvc = OpenService(
        hSCManager,
        wszSERVICE_NAME,
        SERVICE_ALL_ACCESS);
    if (NULL == hSCCertsvc)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "OpenService", wszSERVICE_NAME);
    }

    // START the service
    if (!StartService(hSCCertsvc,
                      fSilent ? 1 : 0,
                      fSilent ? apwszSilentArg : NULL))
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "StartService", wszSERVICE_NAME);
    }

    // get out after it is really started

    fSawPending = FALSE;
    DBGCODE(status.dwCurrentState = MAXDWORD);
    for (dwAttempt = 0; dwAttempt < CERT_MAX_ATTEMPT; dwAttempt++)
    {
        DBGCODE(status.dwCurrentState = MAXDWORD);
        if (!QueryServiceStatus(hSCCertsvc, &status))
        {
            // query failed, ignore error
            hr = S_OK;

            _JumpErrorStr(
                        myHLastError(),     // Display ignored error
                        error,
                        "QueryServiceStatus",
                        wszSERVICE_NAME);
        }
        if (SERVICE_START_PENDING != status.dwCurrentState &&
                        SERVICE_STOPPED != status.dwCurrentState)
        {
            // it was started already
            break;
        }
        DBGPRINT((
                DBG_SS_CERTOCM,
                "Starting %ws service: current state=%d\n",
                wszSERVICE_NAME,
                status.dwCurrentState));
        if (fSawPending && SERVICE_STOPPED == status.dwCurrentState)
        {
            hr = HRESULT_FROM_WIN32(ERROR_SERVICE_NEVER_STARTED);
            _JumpErrorStr(
                    hr,
                    error,
                    "Service won't start",
                    wszSERVICE_NAME);
        }
        if (SERVICE_START_PENDING == status.dwCurrentState)
        {
            fSawPending = TRUE;
        }
        Sleep(CERT_HALF_SECOND);
    }
    if (dwAttempt >= CERT_MAX_ATTEMPT)
    {
        DBGPRINT((
                DBG_SS_CERTOCM,
                "Timeout starting %ws service: current state=%d\n",
                wszSERVICE_NAME,
                status.dwCurrentState));
    }
    else
    {
        DBGPRINT((
                DBG_SS_CERTOCM,
                "Started %ws service\n",
                wszSERVICE_NAME));
    }
    hr = S_OK;

error:
    if (NULL != hSCCertsvc)
    {
        CloseServiceHandle(hSCCertsvc);
    }
    if (NULL != hSCManager)
    {
        CloseServiceHandle(hSCManager);
    }
    CSILOG(hr, IDS_LOG_START_SERVICE, NULL, NULL, NULL);
    return(hr);
}


HRESULT
EnforceCertFileExtensions(
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    WCHAR *pwszTmp = NULL;
    WCHAR *pwszSuffix;
    BOOL fAppendExtension = TRUE;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    if (NULL == pServer->pwszCACertFile)
    {
        // no ca cert file
        goto done;
    }

    // make enough to hold extra extension crt
    pwszTmp = (WCHAR *) LocalAlloc(
                    LMEM_FIXED,
                    (wcslen(pServer->pwszCACertFile) + 5) * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pwszTmp);

    wcscpy(pwszTmp, pServer->pwszCACertFile);

    // check to make sure our self-signed file has the right extension
    // Is there an extension?

    pwszSuffix = wcsrchr(pwszTmp, L'.');

    if (NULL != pwszSuffix)
    {
        // Is the stuff after the '.' already a 'crt' extension?

        if (0 == LSTRCMPIS(pwszSuffix, L".crt"))
        {
            fAppendExtension = FALSE;
        }
        else if (pwszSuffix[1] == L'\0')  // Is '.' last character?
        {
            while (pwszSuffix >= pwszTmp && *pwszSuffix == L'.')
            {
                *pwszSuffix-- = L'\0';
            }
        }
    }
    if (fAppendExtension)
    {
        // Apply the extension
        wcscat(pwszTmp, L".crt");
        // free old one
        LocalFree(pServer->pwszCACertFile);
        pServer->pwszCACertFile = pwszTmp;
        pwszTmp = NULL;
    }

done:
    hr = S_OK;

error:
    if (NULL != pwszTmp)
    {
        LocalFree(pwszTmp);
    }
    return(hr);
}

HRESULT
PrepareEDBDirectory(
    HWND hwnd,
    PER_COMPONENT_DATA *pComp,
    WCHAR const *pwszDir)
{
    HRESULT hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    DWORD dwAttr = GetFileAttributes(pwszDir);

    if (MAXDWORD == dwAttr)
    {
        // file not found or other error

        hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
        {
            _JumpError(hr, error, "GetFileAttributes");
        }
        if (!CreateDirectory(pwszDir, NULL))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CreateDirectory");
        }
    }
    else if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
    {
	// file already exists but it's not a directory

	hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
	_JumpError(hr, error, "GetFileAttributes");
    }
    if (!pServer->fPreserveDB)
    {
        hr = myDeleteDBFilesInDir(pwszDir);
        _JumpIfError(hr, error, "myDeleteDBFilesInDir");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
        CertErrorMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hwnd,
            0,
            hr,
            L""); // only message is the system error message
    }
    return(hr);
}


//--------------------------------------------------------------------
// Create the web configuration files
HRESULT 
CreateCertWebIncPages(
    IN PER_COMPONENT_DATA *pComp, 
    IN BOOL bIsServer)
{
    HRESULT hr;
    
    CSASSERT(NULL != pComp);

    // create the web configuration file
    hr = CreateCertWebDatIncPage(pComp, bIsServer);
    _JumpIfError(hr, error, "CreateCertWebDatIncPage");

error:
    CSILOG(hr, IDS_LOG_WEB_INCLUDE, NULL, NULL, NULL);
    return hr;
}


//--------------------------------------------------------------------

HRESULT
EnableVRootsAndShares(
    IN BOOL fFileSharesOnly,
    IN BOOL fUpgrade,
    IN BOOL fServer,
    IN PER_COMPONENT_DATA *pComp,
    IN HWND hwnd)
{
    HRESULT hr;
    DWORD Flags = VFF_CREATEFILESHARES |
                    VFF_SETREGFLAGFIRST |
                    VFF_SETRUNONCEIFERROR |
                    VFF_CLEARREGFLAGIFOK;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    int ret;
    bool fASPEnabled = false;
    DWORD dwShareDisposition = 0;
    DWORD dwVRootDisposition = 0;

    CSASSERT(!fServer || NULL != pServer);
    CSASSERT(fServer || NULL != pComp->CA.pClient);

    if (!fFileSharesOnly)
    {
        Flags |= VFF_CREATEVROOTS;

        hr = IsASPEnabledInIIS_New(fASPEnabled);
        _JumpIfError(hr, error, "IsASPEnabledInIIS_New");

        if(!fASPEnabled)
        {
            ret = CertMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hwnd,
                IDS_WRN_ASP_NOT_ENABLED,
                0,
                MB_YESNO |
                MB_ICONWARNING |
                CMB_NOERRFROMSYS |
                MB_DEFBUTTON2,
                NULL);
            if (IDYES == ret)
            {
                Flags |= VFF_ENABLEASP;
            }
        }
    }

    // if NT GUI mode (base setup) VRoot creation will fail during setup
    // because IIS is not yet operational.  Make a mark in the registry
    // to try this on NEXT service startup or via runonce.

    hr = myModifyVirtualRootsAndFileShares(
            Flags, 
            fServer? pServer->CAType : pComp->CA.pClient->WebCAType,
            FALSE,             // synchronous -- blocking call
            VFCSEC_TIMEOUT, 
            &dwVRootDisposition, 
            &dwShareDisposition);
    _JumpIfError(hr, error, "myModifyVirtualRootsAndFileShares");

	if(VFD_VERIFYERROR == dwShareDisposition)
	{
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hwnd,
            IDS_SHARE_VERIFY_ERROR,
            0,
            NULL);
	}

    if (!fUpgrade)
    {
        pServer->fCreatedShare = TRUE;
        if (!fFileSharesOnly)
        {
            pComp->fCreatedVRoot = TRUE;
        }
    }

error:
    CSILOGDWORD(IDS_LOG_SHARE_DISP, dwShareDisposition);
    CSILOGDWORD(IDS_LOG_VROOT_DISP, dwVRootDisposition);
    CSILOG(hr, IDS_LOG_VROOT_DISP, NULL, NULL, NULL);
    return(hr);
}


HRESULT
DisableVRootsAndShares(
    IN BOOL fVRoot,
    IN BOOL fFileShares)
{
    HRESULT hr;
    DWORD Flags = 0;

    if (fVRoot)
    {
        Flags |= VFF_DELETEVROOTS;
    }
    if (fFileShares)
    {
        Flags |= VFF_DELETEFILESHARES;
    }
    if (0 == Flags)
    {
        goto done;
    }
    hr = myModifyVirtualRootsAndFileShares(
             Flags, 
             ENUM_UNKNOWN_CA,
             FALSE, // synchronous -- blocking call
             VFCSEC_TIMEOUT, 
             NULL, 
             NULL);
    _JumpIfError(hr, error, "myModifyVirtualRootsAndFileShares");

done:
    hr = S_OK;
error:
    return(hr);
}


HRESULT
InstallClient(
    HWND hwnd,
    PER_COMPONENT_DATA *pComp)
{
    BOOL fCoInit = FALSE;
    HRESULT hr;

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;
    certocmBumpGasGauge(pComp, 10 DBGPARM(L"InstallClient"));

    hr = CreateWebClientRegEntries(FALSE, pComp);
    _JumpIfError(hr, error, "CreateWebClientRegEntries");
    certocmBumpGasGauge(pComp, 30 DBGPARM(L"InstallClient"));

    hr = RegisterAndUnRegisterDLLs(RD_CLIENT, pComp, hwnd);
    _JumpIfError(hr, error, "RegisterAndUnRegisterDLLs");
    certocmBumpGasGauge(pComp, 50 DBGPARM(L"InstallClient"));

    DeleteProgramGroups(FALSE);

    hr = CreateProgramGroups(TRUE, pComp, hwnd);
    _JumpIfError(hr, error, "CreateProgramGroups");
    certocmBumpGasGauge(pComp, 70 DBGPARM(L"InstallClient"));

    hr = CreateCertWebIncPages(pComp, FALSE /* IsServer */ );
    _JumpIfError(hr, error, "CreateCertWebIncPages");

    hr = RenameMiscTargets(hwnd, pComp, FALSE);
    _JumpIfError(hr, error, "RenameMiscTargets");
    certocmBumpGasGauge(pComp, 80 DBGPARM(L"InstallClient"));

    hr = EnableVRootsAndShares(FALSE, FALSE, FALSE, pComp, hwnd);
    if(REGDB_E_CLASSNOTREG ==  hr ||
       HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) == hr ||
       HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
    {
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hwnd,
            IDS_WRN_IIS_NOT_INSTALLED,
            0,
            NULL);        
        hr = S_OK;
    }
    _JumpIfError(hr, error, "EnableVRootsAndShares");

    certocmBumpGasGauge(pComp, 100 DBGPARM(L"InstallClient"));

    hr = S_OK;

error:
    if (fCoInit)
    {
        CoUninitialize();
    }
    CSILOG(hr, IDS_LOG_INSTALL_CLIENT, NULL, NULL, NULL);
    return(hr);
}


HRESULT
RemoveWebClientRegEntries(VOID)
{
    HRESULT hr;

    hr = myDeleteCertRegValue(NULL, NULL, NULL, wszREGWEBCLIENTCAMACHINE);
    _PrintIfError(hr, "myDeleteCertRegValue");

    hr = myDeleteCertRegValue(NULL, NULL, NULL, wszREGWEBCLIENTCANAME);
    _PrintIfError(hr, "myDeleteCertRegValue");

    hr = myDeleteCertRegValue(NULL, NULL, NULL, wszREGWEBCLIENTCATYPE);
    _PrintIfError(hr, "myDeleteCertRegValue");

    hr = S_OK;
//error:
    return hr;
}


HRESULT
InstallServer(
    HWND hwnd,
    PER_COMPONENT_DATA *pComp)
{
    BOOL fCoInit = FALSE;
    WCHAR  *pwszDBFile = NULL;
    DWORD   dwSetupStatus;
    HRESULT hr = pComp->hrContinue;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    WCHAR  *pwszConfig = NULL;
    BOOL    fSetDSSecurity;

    _JumpIfError(hr, error, "can't continue");

    hr = UpdateDomainAndUserName(hwnd, pComp);
    _JumpIfError(hr, error, "UpdateDomainAndUserName");

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    hr = EnforceCertFileExtensions(pComp);
    _JumpIfError(hr, error, "EnforceCertFileExtensions");

    hr = PrepareEDBDirectory(hwnd, pComp, pServer->pwszDBDirectory);
    _JumpIfError(hr, error, "PrepareEDBDirectory");

    hr = PrepareEDBDirectory(hwnd, pComp, pServer->pwszLogDirectory);
    _JumpIfError(hr, error, "PrepareEDBDirectory");

    certocmBumpGasGauge(pComp, 10 DBGPARM(L"InstallServer"));

    // alway uninstall before install
    PreUninstallCore(hwnd, pComp);
    UninstallCore(hwnd, pComp, 10, 30, FALSE, FALSE, FALSE);

    hr = CreateServerRegEntries(FALSE, pComp);
    _JumpIfError(hr, error, "CreateServerRegEntries");

    if ((IS_SERVER_INSTALL & pComp->dwInstallStatus) &&
        (IS_CLIENT_UPGRADE & pComp->dwInstallStatus))
    {
        // case of install server only and keep web client
        // remove parent ca config info of the old web client
        hr = RemoveWebClientRegEntries();
        _PrintIfError(hr, "RemoveWebClientRegEntries");
    }

    certocmBumpGasGauge(pComp, 35 DBGPARM(L"InstallServer"));

    hr = RegisterAndUnRegisterDLLs(RD_SERVER, pComp, hwnd);
    _JumpIfError(hr, error, "RegisterAndUnRegisterDLLs");

    certocmBumpGasGauge(pComp, 40 DBGPARM(L"InstallServer"));

    hr = CreateCertificateService(pComp, hwnd);
    _JumpIfError(hr, error, "CreateCertificateService");

    certocmBumpGasGauge(pComp, 45 DBGPARM(L"InstallServer"));

    hr = CreateCertificates(pComp, hwnd);
    _JumpIfError(hr, error, "CreateCertificates");

    certocmBumpGasGauge(pComp, 50 DBGPARM(L"InstallServer"));

    hr = CreateProgramGroups(FALSE, pComp, hwnd);
    _JumpIfError(hr, error, "CreateProgramGroups");

    certocmBumpGasGauge(pComp, 60 DBGPARM(L"InstallServer"));

    hr = CreateCertWebIncPages(pComp, TRUE /* IsServer */ );
    _JumpIfError(hr, error, "CreateCertWebIncPages");

    hr = RenameMiscTargets(hwnd, pComp, TRUE);
    _JumpIfError(hr, error, "RenameMiscTargets");
    certocmBumpGasGauge(pComp, 70 DBGPARM(L"InstallServer"));

    hr = RegisterDcomServer(
                        TRUE,
			CLSID_CCertRequestD,	// AppId
                        CLSID_CCertRequestD,
                        wszREQUESTFRIENDLYNAME,
                        wszREQUESTVERINDPROGID,
                        wszREQUESTPROGID);
    _JumpIfError(hr, error, "RegisterDcomServer");

    hr = RegisterDcomServer(
                        FALSE,
                        CLSID_CCertRequestD,	// AppId
                        CLSID_CCertAdminD,
                        wszADMINFRIENDLYNAME,
                        wszADMINVERINDPROGID,
                        wszADMINPROGID);
    _JumpIfError(hr, error, "RegisterDcomServer");
    certocmBumpGasGauge(pComp, 80 DBGPARM(L"InstallServer"));

    hr = RegisterDcomApp(CLSID_CCertRequestD);
    _JumpIfError(hr, error, "RegisterDcomApp");
    certocmBumpGasGauge(pComp, 90 DBGPARM(L"InstallServer"));

    if (pServer->fUseDS)
    {
        hr = AddCAMachineToCertPublishers();
        if(S_OK != hr)
        {
            // put out a warning dlg
           CertWarningMessageBox(
               pComp->hInstance,
               pComp->fUnattended,
               hwnd,
               IDS_WRN_CANNOT_ADD_CA_TO_CERTPUBLISHERS,
               hr,
               NULL);
        }
        _PrintIfError(hr, "AddCAMachineToCertPublishers");

        // For restricted officers feature to work the CA needs access to 
        // group membership info in DS. Give it rights by adding it to
        // Pre-Win2k group. Feature is enabled on advanced server only.
        if(FIsAdvancedServer())
        {
            hr = AddCAMachineToPreWin2kGroup();
            if(S_OK != hr)
            {
                // put out a warning dlg
               CertWarningMessageBox(
                   pComp->hInstance,
                   pComp->fUnattended,
                   hwnd,
                   IDS_WRN_CANNOT_ADD_CA_TO_PREWIN2K,
                   hr,
                   NULL);
            }
            _PrintIfError(hr, "AddCAMachineToPreWin2kGroup");
        }


        hr = InitializeCertificateTemplates();
        _JumpIfError(hr, error, "InitializeCertificateTemplates");
    }
    certocmBumpGasGauge(pComp, 95 DBGPARM(L"InstallServer"));


    // Set the security locally.
    // A SubCA sets security when it receives its certificate from
    // its parent. ALL OTHER CA installs (Root & reuse of existing certs)
    // need to have security set now.

    // On a SubCA the DS object security will have been set
    // by a previous call in initlib if we already got our cert, or it will
    // be set later when we install our cert.
    // However, root certs install doesn't run completefrompkcs7(), so 
    // ds security on ent roots is never set. We must set it here.

    // TODO: set security properly at DS object creation time!
    fSetDSSecurity = (IsRootCA(pServer->CAType) || pServer->pccExistingCert);

    hr = csiInitializeCertSrvSecurity(
			pServer->pwszSanitizedName, 
			pServer->fUseDS,
			fSetDSSecurity? pServer->fUseDS : FALSE); // clean SUBCA: happens during cert install, ROOT & reuse cert: apply now
    if (S_OK != hr)
    {
	_PrintError(hr, "csiInitializeCertSrvSecurity");
	if (IsWhistler())
	{
	    goto error;
	}
    }

    hr = GetSetupStatus(pServer->pwszSanitizedName, &dwSetupStatus);
    if (S_OK == hr)
    {
        if (IsSubordinateCA(pServer->CAType) &&
            (SETUP_SUSPEND_FLAG & dwSetupStatus) &&
            (SETUP_REQUEST_FLAG & dwSetupStatus))
        {
            // put out an info dlg
            CertInfoMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hwnd,
                        IDS_INCOMPLETE_REQUEST,
                        pServer->pwszRequestFile);
        }
    }
    else
    {
        _PrintError(hr, "GetSetupStatus");
    }

    certocmBumpGasGauge(pComp, 100 DBGPARM(L"InstallServer"));

    hr = S_OK;
error:
    if (NULL != pwszConfig)
    {
        LocalFree(pwszConfig);
    }
    if (NULL != pwszDBFile)
    {
        LocalFree(pwszDBFile);
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    CSILOG(hr, IDS_LOG_INSTALL_SERVER, NULL, NULL, NULL);
    return(hr);
}


HRESULT
CreateCertsrvDirectories(
    IN PER_COMPONENT_DATA *pComp,
    IN BOOL fUpgrade,
    IN BOOL fServer)
{
    HRESULT hr;
    WCHAR wszCertEnroll[MAX_PATH];
    wszCertEnroll[0] = L'\0';

    BuildPath(
            wszCertEnroll,
            ARRAYSIZE(wszCertEnroll),
            pComp->pwszSystem32,
            wszCERTENROLLSHAREPATH);
    if (0 == CreateDirectory(wszCertEnroll, NULL))
    {
        hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr)
        {
            _JumpErrorStr(hr, error, "CreateDirectory", wszCertEnroll);
        }
    }

    if (fServer && NULL != pComp->CA.pServer->pwszSharedFolder)
    {
	if (pComp->fUnattended && !fUpgrade)
	{
	    // make sure shared folder is created
	    if (!CreateDirectory(pComp->CA.pServer->pwszSharedFolder, NULL))
	    {
		hr = myHLastError();
		if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr)
		{
		    _JumpErrorStr(hr, error, "CreateDirectory",
			pComp->CA.pServer->pwszSharedFolder);
		}
	    }
	}

        if (!fUpgrade)
        {
            // set security on shared folder to 
            // FULL: Admins, LocalSystem, DomainAdmins
            // READ: Everyone
            // NOTE: in upgrade path, the system doesn't enable file share yet
            //       so skip the call
            hr = csiSetAdminOnlyFolderSecurity(
                      pComp->CA.pServer->pwszSharedFolder,
                      TRUE,     // apply Everyone:READ
                      pComp->CA.pServer->fUseDS);
            _JumpIfError(hr, error, "csiSetAdminOnlyFolderSecurity");
        }
    }

    hr = S_OK;

error:
    return hr;
}


// following remove unused file/directory/registry

#define wszOLDHELP          L"..\\help\\"
#define wszOLDCERTADM       L"\\certadm"
#define wszOLDCERTQUE       L"\\certque"

VOID
DeleteOldFilesAndDirectories(
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    WCHAR    wszPath[MAX_PATH];
    WCHAR   *pwszCertsrv;
    wszPath[0] = L'\0';

    // old help dir path
    wcscpy(wszPath, pComp->pwszSystem32);
    wcscat(wszPath, wszOLDHELP);
    wcscat(wszPath, wszCERTSRV);
    // remove old help files
    hr = myRemoveFilesAndDirectory(wszPath, TRUE);
    _PrintIfErrorStr(hr, "myRemoveFilesAndDirectory", wszPath);

    // point to system32\certsrv
    wcscpy(wszPath, pComp->pwszSystem32);
    wcscat(wszPath, wszCERTSRV);
    pwszCertsrv = &wszPath[wcslen(wszPath)];

    // old vroot dir path
    wcscpy(pwszCertsrv, wszOLDCERTADM);
    hr = myRemoveFilesAndDirectory(wszPath, TRUE);
    _PrintIfErrorStr(hr, "myRemoveFilesAndDirectory", wszPath);

    wcscpy(pwszCertsrv, wszOLDCERTQUE);
    hr = myRemoveFilesAndDirectory(wszPath, TRUE);
    _PrintIfErrorStr(hr, "myRemoveFilesAndDirectory", wszPath);

    // delete some obsolete registry keys and values

    // old doc sub-component
    hr = myDeleteCertRegValueEx(wszREGKEYOCMSUBCOMPONENTS,
                                NULL,
                                NULL,
                                wszOLDDOCCOMPONENT,
                                TRUE); //absolute path,
    _PrintIfErrorStr2(hr, "myDeleteCertRegValueEx", wszOLDDOCCOMPONENT, hr);

    // old CA cert serial number

    if (NULL != pComp->CA.pServer &&
	NULL != pComp->CA.pServer->pwszSanitizedName)
    {
	hr = myDeleteCertRegValue(
			    pComp->CA.pServer->pwszSanitizedName,
			    NULL,
			    NULL,
			    wszREGCASERIALNUMBER);
	_PrintIfErrorStr2(hr, "myDeleteCertRegValue", wszREGCASERIALNUMBER, hr);
    }
}


VOID
DeleteObsoleteResidue()
{
    HRESULT  hr;

    hr = myDeleteCertRegValueEx(wszREGKEYKEYSNOTTORESTORE,
                                NULL,
                                NULL,
                                wszREGRESTORECERTIFICATEAUTHORITY,
                                TRUE); //absolute path,
    _PrintIfErrorStr(hr, "myDeleteCertRegValueEx",
                     wszREGRESTORECERTIFICATEAUTHORITY);

    hr = myDeleteCertRegValueEx(wszREGKEYFILESNOTTOBACKUP,
                                NULL,
                                NULL,
                                wszREGRESTORECERTIFICATEAUTHORITY,
                                TRUE); //absolute path,
    _PrintIfErrorStr(hr, "myDeleteCertRegValueEx",
                     wszREGRESTORECERTIFICATEAUTHORITY);

}


HRESULT
TriggerAutoenrollment() 
{
    HRESULT hr = S_OK;

    // must be cleaned up
    CAutoHANDLE hEvent;

    hEvent = OpenEvent(
		    EVENT_MODIFY_STATE, 
		    FALSE, 
		    L"Global\\" MACHINE_AUTOENROLLMENT_TRIGGER_EVENT);
    if (!hEvent) 
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenEvent");
    }
    if (!SetEvent(hEvent)) 
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenEvent");
    }

error:
    return(hr);
}


HRESULT
InstallCore(
    IN HWND hwnd,
    IN PER_COMPONENT_DATA *pComp,
    IN BOOL fServer)
{
    HRESULT hr = pComp->hrContinue;

    _JumpIfError(hr, error, "can't continue");

    hr = CreateCertsrvDirectories(pComp, FALSE, fServer);
    _JumpIfError(hr, error, "CreateCertsrvDirectories");

    // Trigger an autoenroll to download root certs (see bug# 341568)
    // Might fail in a brand new domain...

    if (IsEnterpriseCA(pComp->CA.pServer->CAType))
    {
        hr = TriggerAutoenrollment();
        _PrintIfError(hr, "TriggerAutoenrollment");
    }

    if (fServer)
    {
        hr = InstallServer(hwnd, pComp);
        _JumpIfError(hr, error, "InstallServer");
    }
    else
    {
        hr = InstallClient(hwnd, pComp);
        _JumpIfError(hr, error, "InstallClient");
    }
    if (g_fW3SvcRunning)
    {
        hr = StartAndStopService(
			pComp->hInstance,
			pComp->fUnattended,
			hwnd,
			wszW3SVCNAME,
			FALSE,
			FALSE,
			0,	// doesn't matter since no confirm
			&g_fW3SvcRunning);
        _PrintIfError(hr, "StartAndStopService");
    }
    DeleteOldFilesAndDirectories(pComp);
    hr = S_OK;

error:
    return(hr);
}


HRESULT
BuildMultiStringList(
    IN WCHAR const * const *apwsz,
    IN DWORD cpwsz,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;
    DWORD i;
    DWORD cwc;
    WCHAR *pwc;
    WCHAR *apwszEmpty[] = { L"", };

    if (0 == cpwsz)
    {
        cpwsz = ARRAYSIZE(apwszEmpty);
        apwsz = apwszEmpty;
    }
    cwc = 1;
    for (i = 0; i < cpwsz; i++)
    {
        cwc += wcslen(apwsz[i]) + 1;
    }
    *ppwszz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, *ppwszz);

    pwc = *ppwszz;
    for (i = 0; i < cpwsz; i++)
    {
        wcscpy(pwc, apwsz[i]);
        pwc += wcslen(pwc) + 1;
    }
    *pwc = L'\0';
    CSASSERT(SAFE_SUBTRACT_POINTERS(pwc, *ppwszz) + 1 == cwc);

    hr = S_OK;

error:
    return(hr);
}


VOID
helperDeleteTrashedDisableList(
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr;
    WCHAR *pwszzGet = NULL;
    WCHAR const *pwsz;

    hr = myGetCertRegMultiStrValue(
                            pwszSanitizedName,
                            wszREGKEYPOLICYMODULES,
                            wszCLASS_CERTPOLICY,
                            wszREGDISABLEEXTENSIONLIST,
                            &pwszzGet);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGDISABLEEXTENSIONLIST);

    if (NULL != pwszzGet)
    {
	for (pwsz = pwszzGet; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    hr = myVerifyObjId(pwsz);
	    if (S_OK != hr)
	    {
		hr = myDeleteCertRegValue(
				    pwszSanitizedName,
				    wszREGKEYPOLICYMODULES,
				    wszCLASS_CERTPOLICY,
				    wszREGDISABLEEXTENSIONLIST);
		_JumpIfError(hr, error, "myDeleteCertRegValue");

		break;
	    }
	}
    }

error:
    if (NULL != pwszzGet)
    {
	LocalFree(pwszzGet);
    }
}


HRESULT
helperGetDisableExtensionList(
    OUT WCHAR **ppwszz)
{
    HRESULT hr;
    WCHAR *apwszExt[] = {
        L"",            // C compiler won't allow empty list
	//TEXT(szOID_ENROLL_CERTTYPE_EXTENSION), // 1.3.6.1.4.1.311.20.2
    };

    hr = BuildMultiStringList(apwszExt, ARRAYSIZE(apwszExt), ppwszz);
    _JumpIfError(hr, error, "BuildMultiStringList");

error:
    return(hr);
}


HRESULT
helperGetRequestExtensionList(
    OUT WCHAR **ppwszz)
{
    HRESULT hr;
    WCHAR *apwszExt[] = {
	TEXT(szOID_RSA_SMIMECapabilities),	    // 1.2.840.113549.1.9.15
	TEXT(szOID_CERTSRV_CA_VERSION),		    // 1.3.6.1.4.1.311.21.1
	TEXT(szOID_CERTSRV_PREVIOUS_CERT_HASH),	    // 1.3.6.1.4.1.311.21.2
        TEXT(szOID_KEY_USAGE),			    // 2.5.29.15
    };

    hr = BuildMultiStringList(apwszExt, ARRAYSIZE(apwszExt), ppwszz);
    _JumpIfError(hr, error, "BuildMultiStringList");

error:
    return(hr);
}


HRESULT
helperGetEnrolleeRequestExtensionList(
    OUT WCHAR **ppwszz)
{
    HRESULT hr;
    WCHAR *apwszExt[] = {
	TEXT(szOID_CROSS_CERT_DIST_POINTS),	    // 1.3.6.1.4.1.311.10.9.1
	TEXT(szOID_ENROLL_CERTTYPE_EXTENSION),	    // 1.3.6.1.4.1.311.20.2
	TEXT(szOID_CERTIFICATE_TEMPLATE),	    // 1.3.6.1.4.1.311.21.7
	TEXT(szOID_APPLICATION_CERT_POLICIES),	    // 1.3.6.1.4.1.311.21.10
	TEXT(szOID_APPLICATION_POLICY_MAPPINGS),    // 1.3.6.1.4.1.311.21.11
	TEXT(szOID_APPLICATION_POLICY_CONSTRAINTS), // 1.3.6.1.4.1.311.21.12
        TEXT(szOID_SUBJECT_ALT_NAME2),		    // 2.5.29.17
	TEXT(szOID_NAME_CONSTRAINTS),		    // 2.5.29.30
	TEXT(szOID_CERT_POLICIES),		    // 2.5.29.32
	TEXT(szOID_POLICY_MAPPINGS),		    // 2.5.29.33
	TEXT(szOID_POLICY_CONSTRAINTS),		    // 2.5.29.36
        TEXT(szOID_ENHANCED_KEY_USAGE),		    // 2.5.29.37
    };

    hr = BuildMultiStringList(apwszExt, ARRAYSIZE(apwszExt), ppwszz);
    _JumpIfError(hr, error, "BuildMultiStringList");

error:
    return(hr);
}


HRESULT
FindCACertByCommonNameAndSerialNumber(
    IN HCERTSTORE   hCAStore,
    IN WCHAR const *pwszCommonName,
    IN BYTE const  *pbSerialNumber,
    IN DWORD        cbSerialNumber,
    CERT_CONTEXT const **ppCACert)
{
    HRESULT  hr;
    CERT_RDN_ATTR  rdnAttr = { szOID_COMMON_NAME, CERT_RDN_ANY_TYPE,};
    CERT_RDN       rdn = { 1, &rdnAttr };
    CRYPT_INTEGER_BLOB SerialNumber;
    CERT_CONTEXT const *pCACert = NULL;

    CSASSERT(NULL != hCAStore &&
             NULL != pwszCommonName &&
             NULL != pbSerialNumber &&
             NULL != ppCACert);

    *ppCACert = NULL;

    rdnAttr.Value.pbData = (BYTE *) pwszCommonName;
    rdnAttr.Value.cbData = 0;
    pCACert = NULL;
    SerialNumber.pbData = const_cast<BYTE *>(pbSerialNumber);
    SerialNumber.cbData = cbSerialNumber;
    for (;;)
    {
        pCACert = CertFindCertificateInStore(
                                hCAStore,
                                X509_ASN_ENCODING,
                                CERT_UNICODE_IS_RDN_ATTRS_FLAG |
                                    CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG,
                                CERT_FIND_SUBJECT_ATTR,
                                &rdn,
                                pCACert);
        if (NULL == pCACert)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CertFindCertificateInStore");
        }
        if (myAreSerialNumberBlobsSame(
                            &SerialNumber,
                            &pCACert->pCertInfo->SerialNumber))
        {
            break;      // found correct one
        }
    }

    *ppCACert = pCACert;
     pCACert = NULL;
    hr = S_OK;

error:
    if (NULL != pCACert)
    {
        CertFreeCertificateContext(pCACert);
    }
    return hr;
}


HRESULT
GetCARegSerialNumber(
    IN  WCHAR const *pwszSanitizedCAName,
    OUT BYTE       **ppbSerialNumber,
    OUT DWORD       *pcbSerialNumber)
{
    HRESULT hr;
    WCHAR  *pwszSerialNumber = NULL;
    BYTE   *pbSN = NULL;
    DWORD   cbSN;

    hr = myGetCertRegStrValue(
               pwszSanitizedCAName,
               NULL,
               NULL,
               wszREGCASERIALNUMBER,
               &pwszSerialNumber);
    _JumpIfErrorStr2(
		hr,
		error,
		"myGetCertRegStrValue",
		wszREGCASERIALNUMBER,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    hr = WszToMultiByteInteger(FALSE, pwszSerialNumber, &cbSN, &pbSN);
    _JumpIfError(hr, error, "WszToMultiByteInteger");

    *ppbSerialNumber = pbSN;
    pbSN = NULL;
    *pcbSerialNumber = cbSN;

error:
    if (NULL != pwszSerialNumber)
    {
        LocalFree(pwszSerialNumber);
    }
    if (NULL != pbSN)
    {
        LocalFree(pbSN);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
LoadCurrentCACert(
    IN WCHAR const *pwszCommonName,
    IN WCHAR const *pwszSanitizedName,
    IN BOOL         fSignTest,
    OUT CERT_CONTEXT const **ppcc,
    OUT DWORD *pdwNameId)
{
    HRESULT hr;
    DWORD Count;
    HCERTSTORE hMyStore = NULL;
    BYTE *pbSerialNumber = NULL;
    DWORD cbSerialNumber;
    CRYPT_KEY_PROV_INFO *pKey = NULL;
    DWORD cbKey;
    CERT_CONTEXT const *pcc = NULL;
    WCHAR *pwszProvName = NULL;
    DWORD dwProvType;
    ALG_ID idAlg;
    BOOL fMachineKeyset;

    *ppcc = NULL;
    
    // get prov name

    hr = myGetCertSrvCSP(
		FALSE,		// fEncryptionCSP
                pwszSanitizedName,
                &dwProvType,
                &pwszProvName,
                &idAlg,
                &fMachineKeyset,
		NULL);		// pdwKeySize
    _JumpIfError(hr, error, "myGetCertSrvCSP");

    // open my store

    hMyStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_W,
                    X509_ASN_ENCODING,
                    NULL,                        // hProv
		    CERT_SYSTEM_STORE_LOCAL_MACHINE |
			CERT_STORE_ENUM_ARCHIVED_FLAG,
                   wszMY_CERTSTORE);
    if (NULL == hMyStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    hr = myGetCARegHashCount(pwszSanitizedName, CSRH_CASIGCERT, &Count);
    _JumpIfError(hr, error, "myGetCARegHashCount");

    if (0 == Count)
    {
	*pdwNameId = 0;		// renewal wasn't implemented yet

	// find current CA cert by serial number -- the old fashioned way

	hr = GetCARegSerialNumber(
			    pwszSanitizedName,
			    &pbSerialNumber,
			    &cbSerialNumber);
	_JumpIfError(hr, error, "GetCARegSerialNumber");

	hr = FindCACertByCommonNameAndSerialNumber(
					hMyStore,
					pwszCommonName,
					pbSerialNumber,
					cbSerialNumber,
					&pcc);
	_JumpIfError(hr, error, "FindCACertByCommonNameAndSerialNumber");
    }
    else
    {
	hr = myFindCACertByHashIndex(
			    hMyStore,
			    pwszSanitizedName,
			    CSRH_CASIGCERT,
			    Count - 1,
			    pdwNameId,
			    &pcc);
	_JumpIfError(hr, error, "myFindCACertByHashIndex");
    }

    // get the private key provider info

    if (!myCertGetCertificateContextProperty(
				    pcc,
				    CERT_KEY_PROV_INFO_PROP_ID,
				    CERTLIB_USE_LOCALALLOC,
				    (VOID **) &pKey,
				    &cbKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }

    if (fSignTest)
    {
        // test signing key

        hr = myValidateSigningKey(
				pKey->pwszContainerName,
				pwszProvName,
				dwProvType,
				FALSE,		// fCryptSilent
				fMachineKeyset,
				TRUE,		// fForceSignatureTest
				pcc,
				NULL,		// pPublicKeyInfo
				idAlg,
				NULL,		// pfSigningTestAttempted
				NULL);		// phProv
        _JumpIfError(hr, error, "myValidateSigningKey");
    }

    *ppcc = pcc;
    pcc = NULL;
    hr = S_OK;

error:
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pbSerialNumber)
    {
        LocalFree(pbSerialNumber);
    }
    if (NULL != pKey)
    {
        LocalFree(pKey);
    }
    if (NULL != pwszProvName)
    {
        LocalFree(pwszProvName);
    }
    if (NULL != pcc)
    {
        CertFreeCertificateContext(pcc);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
ArchiveCACertificate(
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr;
    HCERTSTORE hMyStore = NULL;
    DWORD Count;
    DWORD i;
    CERT_CONTEXT const *pCert = NULL;
    DWORD dwNameId;
    CRYPT_DATA_BLOB Archived;

    // open my store

    hMyStore = CertOpenStore(
                   CERT_STORE_PROV_SYSTEM_W,
                   X509_ASN_ENCODING,
                   NULL,                        // hProv
                   CERT_SYSTEM_STORE_LOCAL_MACHINE,
                   wszMY_CERTSTORE);
    if (NULL == hMyStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    hr = myGetCARegHashCount(pwszSanitizedName, CSRH_CASIGCERT, &Count);
    _JumpIfError(hr, error, "myGetCARegHashCount");

    for (i = 0; i < Count; i++)
    {
	hr = myFindCACertByHashIndex(
			    hMyStore,
			    pwszSanitizedName,
			    CSRH_CASIGCERT,
			    i,
			    &dwNameId,
			    &pCert);
	_PrintIfError2(hr, "myFindCACertByHashIndex", S_FALSE);
	if (S_OK == hr)
	{
	    Archived.cbData = 0;
	    Archived.pbData = NULL;

	    // We force an archive on the old cert and close it.

	    CertSetCertificateContextProperty(
					    pCert,
					    CERT_ARCHIVED_PROP_ID,
					    0,
					    &Archived);
	    CertFreeCertificateContext(pCert);
	    pCert = NULL;
	}
    }
    hr = S_OK;

error:
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// determine CA info, from build to build upgrade

HRESULT
DetermineCAInfoAndType(
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    ENUM_CATYPES CATypeDummy;
    WCHAR *pwszCommonName = NULL;
    CERT_CONTEXT const *pCACert = NULL;

    // ca type
    hr = myGetCertRegDWValue(
                     pServer->pwszSanitizedName,
                     NULL,
                     NULL,
                     wszREGCATYPE,
                     (DWORD *) &CATypeDummy);
    if (S_OK == hr)
    {
        pServer->CAType = CATypeDummy;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpErrorStr(hr, error, "myGetCertRegDWValue", wszREGCATYPE);
    }
    // else keep default CAType flag

    // get current ca common name

    hr = myGetCertRegStrValue(
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCOMMONNAME,
			&pwszCommonName);
    _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", wszREGCOMMONNAME);

    hr = LoadCurrentCACert(
		    pwszCommonName,
		    pServer->pwszSanitizedName,
		    FALSE,  // don't do signing test during upgrade
		    &pCACert,
		    &pServer->dwCertNameId);
    _JumpIfError(hr, error, "LoadCurrentCACert");

    // now ready to load DN info

    hr = DetermineExistingCAIdInfo(pServer, pCACert);
    _JumpIfError(hr, error, "DetermineExistingCAIdInfo");

    if (NULL != pServer->pccUpgradeCert)
    {
        CertFreeCertificateContext(pServer->pccUpgradeCert);
    }
    pServer->pccUpgradeCert = pCACert;
    pCACert = NULL;

error:
    if (NULL != pwszCommonName)
    {
        LocalFree(pwszCommonName);
    }
    if (NULL != pCACert)
    {
        CertFreeCertificateContext(pCACert);
    }
    return(hr);
}


// the following will determine ca sanitized name and upgrade path
HRESULT
DetermineServerUpgradePath(
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    WCHAR   *pwszDummy = NULL;
    WCHAR   *pwszSanitizedCAName = NULL;
    LPWSTR pwszB2PolicyGuid = NULL;
    DWORD dwVersion;

    if (CS_UPGRADE_UNKNOWN != pComp->UpgradeFlag)
    {
        // already know upgrade type
        CSASSERT(pServer->pwszSanitizedName); // this is a side-effect of this fxn, better have been set already
        return S_OK;
    }
    
    // get active ca name
    hr = myGetCertRegStrValue(
        NULL,
        NULL,
        NULL,
        wszREGACTIVE,
        &pwszSanitizedCAName);
    if (hr != S_OK)
    {
        BOOL fFinishCYS;

        //for W2K after, it is possible to be in post mode
        hr = CheckPostBaseInstallStatus(&fFinishCYS);
        if (S_OK == hr && !fFinishCYS)
        {
            //this could be either w2k or whistler
            //treat as whistler since upgrade path won't execute
            pComp->UpgradeFlag = CS_UPGRADE_WHISTLER;
            goto done;
        }

        // wszREGACTIVE used in Win2k product and after. If not found, this is way before our time
        
        // make sure by grabbing wszREGSP4DEFAULTCONFIGURATION
        LPWSTR pwszTmp = NULL;
        hr = myGetCertRegStrValue(
            NULL,
            NULL,
            NULL,
            wszREGSP4DEFAULTCONFIGURATION,
            &pwszTmp);
        if (pwszTmp)
            LocalFree(pwszTmp);
        
        // error! bail, we have no idea what we're seeing
        _JumpIfError(hr, error, "myGetCertRegStrValue wszREGSP4DEFAULTCONFIGURATION");
        
        // hr == S_OK: yep, looks like valid NT4 installation
        pComp->UpgradeFlag = CS_UPGRADE_UNSUPPORTED;	
        CSILOG(S_OK, IDS_LOG_UPGRADE_UNSUPPORTED, NULL, NULL, NULL);
        _JumpError(hr, error, "myGetCertRegStrValue");
    }
    
    // check wszREGVERSION to get current version
    hr = myGetCertRegDWValue(
        NULL,
        NULL,
        NULL,
        wszREGVERSION,
        &dwVersion);
    if (S_OK != hr && HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)!= hr)
    {
        _JumpErrorStr(hr, error, "myGetCertRegDWValue", wszREGVERSION);
    }
    // now either OK or FILE_NOT_FOUND
    
    if (S_OK == hr)
    {
        // pComp->UpgradeFlag = SOME_FUNCTION(dwVersion);		// CS_UPGRADE_WHISTLER already set as default; in future, key off of this
        pComp->UpgradeFlag = CS_UPGRADE_WHISTLER;
        pComp->dwVersion = dwVersion;
        
        CSILOG(S_OK, IDS_LOG_UPGRADE_B2B, NULL, NULL, NULL);
    }
    else
    {
        // FILE_NOT_FOUND: now we know it's (NT5 Beta 2 <= X < Whistler)

        pComp->dwVersion = CSVER_BUILD_VERSION(CSVER_MAJOR_WIN2K, CSVER_MINOR_WIN2K); 
        
        // is this Win2k, or NT5 Beta? Test for active policy module to have "ICertManageModule" entry
        // check nt5 beta 2 and get active policy name
        hr = myGetCertRegStrValue(
            pwszSanitizedCAName,
            wszREGKEYPOLICYMODULES,
            NULL,
            wszREGACTIVE,
            &pwszB2PolicyGuid);
        if (S_OK == hr)
        {
            hr = myGetCertRegStrValue(
                wszREGKEYPOLICYMODULES,
                pwszB2PolicyGuid,
                NULL,
                wszREGB2ICERTMANAGEMODULE,
                &pwszDummy);
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                // this doesn't exist on Win2k
                pComp->UpgradeFlag = CS_UPGRADE_WIN2000;
                CSILOG(S_OK, IDS_LOG_UPGRADE_WIN2000, NULL, NULL, NULL);
            }
            else
            {
                // this is definitely beta 2
                pComp->UpgradeFlag = CS_UPGRADE_UNSUPPORTED;
                CSILOG(S_OK, IDS_LOG_UPGRADE_UNSUPPORTED, NULL, NULL, NULL);
            }
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            // strange, maybe no active module. Assume OK, latest bits.
            pComp->UpgradeFlag = CS_UPGRADE_WIN2000;
            CSILOG(S_OK, IDS_LOG_UPGRADE_WIN2000, NULL, NULL, NULL);
        }
        else
        {
            // other failure, just bail
            _JumpErrorStr(hr, error, "myGetCertRegStrValue",
                wszREGKEYPOLICYMODULES);
        }
    }	// wszREGVERSION: FILE_NOT_FOUND
    
    // take sanitized name
    if (NULL != pServer->pwszSanitizedName)
    {
        // this will free the default name
        LocalFree(pServer->pwszSanitizedName);
    }
    pServer->pwszSanitizedName = pwszSanitizedCAName;
    pwszSanitizedCAName = NULL;
    
done:
    hr = S_OK;
    
error:

    if (NULL != pwszDummy)
    {
        LocalFree(pwszDummy);
    }
    if (NULL != pwszSanitizedCAName)
    {
        LocalFree(pwszSanitizedCAName);
    }

    CSILOG(hr, IDS_LOG_UPGRADE_TYPE, NULL, NULL, (DWORD const *) &pComp->UpgradeFlag);
    return hr;
}


// Description: load and determine necessary information for upgrade
//              upgrade won't continue if any error
HRESULT
LoadAndDetermineServerUpgradeInfo(
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    WCHAR   *pwszRevocationType = NULL;
    BOOL     fDummy;
    ALG_ID   idAlgDummy;
    CSP_INFO CSPInfoDummy;
    WCHAR       *pwszCommonName = NULL;

    // initialize
    ZeroMemory(&CSPInfoDummy, sizeof(CSPInfoDummy));

    // load information for all upgrade scenarios

    // csp

    hr = myGetCertRegStrValue(
                     pServer->pwszSanitizedName,
                     wszREGKEYCSP,
                     NULL,
                     wszREGPROVIDER,
                     &CSPInfoDummy.pwszProvName);
    if (S_OK == hr && NULL != CSPInfoDummy.pwszProvName)
    {
        if (NULL != pServer->pCSPInfo->pwszProvName)
        {
            // free default csp
            LocalFree(pServer->pCSPInfo->pwszProvName);
        }
        // use reg one as default for upgrade
        pServer->pCSPInfo->pwszProvName = CSPInfoDummy.pwszProvName;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpErrorStr(hr, error, "myGetCertRegStrValue", wszREGPROVIDER);
    }
    
    hr = myGetCertRegDWValue(
                     pServer->pwszSanitizedName,
                     wszREGKEYCSP,
                     NULL,
                     wszREGPROVIDERTYPE,
                     &CSPInfoDummy.dwProvType);
    if (S_OK == hr)
    { 
        pServer->pCSPInfo->dwProvType = CSPInfoDummy.dwProvType;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpErrorStr(hr, error, "myGetCertRegDWValue", wszREGPROVIDERTYPE);
    }

    hr = myGetCertRegDWValue(
                     pServer->pwszSanitizedName,
                     wszREGKEYCSP,
                     NULL,
                     wszMACHINEKEYSET,
                     (DWORD*)&CSPInfoDummy.fMachineKeyset);
    if (S_OK == hr)
    {
         pServer->pCSPInfo->fMachineKeyset = CSPInfoDummy.fMachineKeyset;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpErrorStr(hr, error, "myGetCertRegDWValue", wszMACHINEKEYSET);
    }

    hr = myGetCertRegDWValue(
                     pServer->pwszSanitizedName,
                     wszREGKEYCSP,
                     NULL,
                     wszHASHALGORITHM,
                     (DWORD*)&idAlgDummy);
    if (S_OK == hr)
    { 
        pServer->pHashInfo->idAlg = idAlgDummy;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpIfErrorStr(hr, error, "myGetCertRegDWValue", wszHASHALGORITHM);
    }

    if (NULL != pServer->pCSPInfoList)
    {
        // BUG, this will never happen because csp info list is not loaded yet
        // one more checking, make sure csp is installed
        if (NULL == findCSPInfoFromList(
                         pServer->pCSPInfoList,
                         pServer->pCSPInfo->pwszProvName,
                         pServer->pCSPInfo->dwProvType))
        {
            // if not, this is a broken ca
            hr = E_INVALIDARG;
            _JumpErrorStr(hr, error, "findCSPInfoFromList",
                pServer->pCSPInfo->pwszProvName);
        }
    }

    // UseDS flag
    hr = myGetCertRegDWValue(
                 pServer->pwszSanitizedName,
                 NULL,
                 NULL,
                 wszREGCAUSEDS,
                 (DWORD*)&fDummy);
    if (S_OK == hr)
    {
        // use from reg
        pServer->fUseDS = fDummy;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpErrorStr(hr, error, "myGetCertRegDWValue", wszREGCAUSEDS);
    }

    // CACommonName
    // this will be used for looking cert in store to determine ca DN info
    hr = myGetCertRegStrValue(
                pServer->pwszSanitizedName,
                NULL,
                NULL,
                wszREGCOMMONNAME,
                &pwszCommonName);
    if (S_OK != hr && HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpError(hr, error, "myGetCertRegStrValue");
    }
    else if ((HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ||
             (S_OK == hr && L'\0' == pwszCommonName[0]))
    {
        if (S_OK == hr && L'\0' == pwszCommonName[0])
        {
            // empty string, use snaitized name instead
            LocalFree(pwszCommonName);
        }
        // in case empty or not found, use sanitized
        pwszCommonName = (WCHAR*)LocalAlloc(LMEM_FIXED,
            (wcslen(pServer->pwszSanitizedName) + 1) * sizeof(WCHAR));
        _JumpIfOutOfMemory(hr, error, pwszCommonName);
        wcscpy(pwszCommonName, pServer->pwszSanitizedName);
    }
    if (NULL != pServer->pwszCACommonName)
    {
        LocalFree(pServer->pwszCACommonName);
    }
    pServer->pwszCACommonName = pwszCommonName;
    pwszCommonName = NULL;


    // Collect CAType, DN info, dwCertNameId and upgrade ca cert
    hr = DetermineCAInfoAndType(pComp);
    _JumpIfError(hr, error, "DetermineCAInfoAndType");


    // load following values for later

    // check revocation type

    hr = myGetCertRegDWValue(
                    pServer->pwszSanitizedName,
                    wszREGKEYPOLICYMODULES,
                    wszCLASS_CERTPOLICY,
                    wszREGREVOCATIONTYPE,
                    &pServer->dwRevocationFlags);
    if(hr != S_OK)
    {
        pServer->dwRevocationFlags = pServer->fUseDS?
                                    REVEXT_DEFAULT_DS : REVEXT_DEFAULT_NODS;
    }

    // following for web page creation

    // load shared folder for ca cert file name creation
    if (NULL != pServer->pwszSharedFolder)
    {
        // shouldn't happen but in case
        LocalFree(pServer->pwszSharedFolder);
        pServer->pwszSharedFolder = NULL;
    }
    hr = myGetCertRegStrValue(
                    NULL,
                    NULL,
                    NULL,
                    wszREGDIRECTORY,
                    &pServer->pwszSharedFolder);
    if (S_OK == hr && L'\0' == pServer->pwszSharedFolder[0])
    {
        // in case of empty, set to null
        LocalFree(pServer->pwszSharedFolder);
        pServer->pwszSharedFolder = NULL;
    }
    else if (S_OK != hr && HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpError(hr, error, "myGetCertRegStrValue");
    }
        
    // build ca cert file name for web install and ca cert saving
    if (NULL != pServer->pwszCACertFile)
    {
        // free old one
        LocalFree(pServer->pwszCACertFile);
    }
    hr = csiBuildCACertFileName(
			pComp->hInstance,
			NULL,  //hwnd, ok for upgrade
			pComp->fUnattended,
			pServer->pwszSharedFolder,
			pServer->pwszSanitizedName,
			L".crt",
			0,	// iCert
			&pServer->pwszCACertFile);
    _JumpIfError(hr, error, "BuildCACertFileName");

    hr = S_OK;

error:
    if (NULL != pwszRevocationType)
    {
        LocalFree(pwszRevocationType);
    }
    if (NULL != pwszCommonName)
    {
        LocalFree(pwszCommonName);
    }
    return hr;
}


HRESULT
GetConfigInSharedFolderWithCert(
    WCHAR const *pwszSharedFolder,
    OUT WCHAR  **ppwszConfig)
{
    HRESULT  hr;
    ICertConfig * pICertConfig = NULL;
    BSTR bstrConfig = NULL;
    BOOL fCoInit = FALSE;
    WCHAR *pwszCAMachine;
    WCHAR *pwszCAName;
    WCHAR wszCertFileInSharedFolder[MAX_PATH];
    LONG i;
    LONG lCount;
    LONG Index;
    BSTR strConfigConfig = NULL;

    CSASSERT(NULL != ppwszConfig);
    *ppwszConfig = NULL;

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    hr = CoCreateInstance(
                    CLSID_CCertConfig,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_ICertConfig,
                    (VOID**) &pICertConfig);
    _JumpIfError(hr, error, "CoCreateInstance");

    // get local
    hr = pICertConfig->Reset(0, &lCount);
    _JumpIfError(hr, error, "ICertConfig->Reset");

    strConfigConfig = SysAllocString(wszCONFIG_CONFIG);
    if (NULL == strConfigConfig)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "SysAllocString");
    }

    for (i = 0; i < lCount; ++i)
    {
        hr = pICertConfig->Next(&Index);
        if (S_OK != hr && S_FALSE != hr)
        {
            _JumpError(hr, error, "ICertConfig->Next");
        }
        if (-1 == Index)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            _JumpError(hr, error, "No CA cert file");
        }
        hr = pICertConfig->GetField(strConfigConfig, &bstrConfig);
        _JumpIfError(hr, error, "ICertConfig->GetField(Config)");

        pwszCAMachine = (WCHAR*)bstrConfig;
        pwszCAName = wcschr(pwszCAMachine, L'\\');
        if (NULL == pwszCAName)
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "Invalid config string");
        }
        pwszCAName[0] = '\0'; // make pwszCAMachine
        ++pwszCAName;

	if (wcslen(pwszSharedFolder) +
	    1 +
	    wcslen(pwszCAMachine) +
	    1 +
	    wcslen(pwszCAName) +
	    WSZARRAYSIZE(wszCRTFILENAMEEXT) >= ARRAYSIZE(wszCertFileInSharedFolder))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    _JumpErrorStr(hr, error, "wszCertFileInSharedFolder", pwszSharedFolder);
	}
        // form NT4 ca cert file path in shared folder
        wcscpy(wszCertFileInSharedFolder, pwszSharedFolder);
        wcscat(wszCertFileInSharedFolder, L"\\");
        wcscat(wszCertFileInSharedFolder, pwszCAMachine);
        wcscat(wszCertFileInSharedFolder, L"_");
        wcscat(wszCertFileInSharedFolder, pwszCAName);
        wcscat(wszCertFileInSharedFolder, wszCRTFILENAMEEXT);

	DBGPRINT((
	    DBG_SS_CERTOCM,
	    "wszCertFileInSharedFolder: %ws\n",
	    wszCertFileInSharedFolder));

        if (myDoesFileExist(wszCertFileInSharedFolder))
        {
            //done
            break;
        }
        SysFreeString(bstrConfig);
        bstrConfig = NULL;
    }
    if (i >= lCount)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        _JumpError(hr, error, "No CA cert file");
    }

    *ppwszConfig = (WCHAR*)LocalAlloc(LMEM_FIXED,
                        SysStringByteLen(bstrConfig) + sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, *ppwszConfig);
    wcscpy(*ppwszConfig, bstrConfig);

    hr = S_OK;
error:
    if (NULL != pICertConfig)
    {
        pICertConfig->Release();
    }
    if (NULL != strConfigConfig)
    {
        SysFreeString(strConfigConfig);
    }
    if (NULL != bstrConfig)
    {
        SysFreeString(bstrConfig);
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return hr;
}


HRESULT
DetermineClientUpgradePath(
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;
    DWORD       dwVersion;

    if (CS_UPGRADE_UNKNOWN != pComp->UpgradeFlag)
    {
        // already know upgrade type
        CSASSERT(pClient->pwszWebCAMachine); // this is a side-effect of this fxn, better have been set already
        CSASSERT(pClient->pwszWebCAName);    // this is a side-effect of this fxn, better have been set already
        return S_OK;
    }

    //get ca info from registry here
    if (NULL != pClient->pwszWebCAMachine)
    {
        // shouldn't happen, just in case
        LocalFree(pClient->pwszWebCAMachine);
        pClient->pwszWebCAMachine = NULL;
    }
    if (NULL != pClient->pwszWebCAName)
    {
        // shouldn't happen, just in case
        LocalFree(pClient->pwszWebCAName);
        pClient->pwszWebCAName = NULL;
    }

    // get ca machine
    hr = myGetCertRegStrValue(
        NULL, 
        NULL, 
        NULL, 
        wszREGWEBCLIENTCAMACHINE,
        &pClient->pwszWebCAMachine);
    if (S_OK != hr || L'\0' == pClient->pwszWebCAMachine[0])
    {
        BOOL fFinishCYS;

        //for W2K after, it is possible to be in post mode
        hr = CheckPostBaseInstallStatus(&fFinishCYS);
        if (S_OK == hr && !fFinishCYS)
        {
            //this could be either w2k or whistler
            //treat as whistler since upgrade path won't execute
            pComp->UpgradeFlag = CS_UPGRADE_WHISTLER;
            goto done;
        }

        // incorrect reg state,
        // either not found entry or empty string: NT4
        pComp->UpgradeFlag = CS_UPGRADE_UNSUPPORTED;
        hr = S_OK;

        CSILOG(S_OK, IDS_LOG_UPGRADE_UNSUPPORTED, NULL, NULL, NULL);
        _JumpErrorStr(hr, error, "myGetCertRegStrValue", wszREGWEBCLIENTCAMACHINE);
    }

    // get ca
    hr = myGetCertRegStrValue(
        NULL, 
        NULL, 
        NULL, 
        wszREGWEBCLIENTCANAME,
        &pClient->pwszWebCAName);
    if (S_OK != hr || L'\0' == pClient->pwszWebCAName[0])
	{
        // incorrect reg state,
        // either not found entry or empty string: NT4
        if (pClient->pwszWebCAMachine)
            LocalFree(pClient->pwszWebCAMachine);

        pComp->UpgradeFlag = CS_UPGRADE_UNSUPPORTED;
        hr = S_OK;

        CSILOG(S_OK, IDS_LOG_UPGRADE_UNSUPPORTED, NULL, NULL, NULL);
        _JumpErrorStr(hr, error, "myGetCertRegStrValue", wszREGWEBCLIENTCANAME);
    }

    // Now either W2k or Whistler

    // check wszREGVERSION to get current version on Whistler++
    hr = myGetCertRegDWValue(
             NULL,
             NULL,
             NULL,
             wszREGVERSION,
             &dwVersion);
    if (S_OK != hr && HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)!= hr)
    {
        _JumpErrorStr(hr, error, "myGetCertRegDWValue", wszREGVERSION);
    }
    // now either OK or FILE_NOT_FOUND

    if (S_OK == hr)
    {
	    // pComp->UpgradeFlag = SOME_FUNCTION(dwVersion);		// CS_UPGRADE_WHISTLER already set as default; in future, key off of this
        pComp->UpgradeFlag = CS_UPGRADE_WHISTLER;
        pComp->dwVersion = dwVersion;

	    CSILOG(S_OK, IDS_LOG_UPGRADE_B2B, NULL, NULL, NULL);
    }
    else
    {
		pComp->UpgradeFlag = CS_UPGRADE_WIN2000;
        pComp->dwVersion = CSVER_BUILD_VERSION(CSVER_MAJOR_WIN2K, CSVER_MINOR_WIN2K);

        CSILOG(S_OK, IDS_LOG_UPGRADE_WIN2000, NULL, NULL, NULL);
    }

done:
    hr = S_OK;

error:
    CSILOG(hr, IDS_LOG_UPGRADE_TYPE, NULL, NULL, (DWORD const *) &pComp->UpgradeFlag);
    return hr;
}



HRESULT
LoadAndDetermineClientUpgradeInfo(
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;

    //get ca info from registry here
    if (NULL != pClient->pwszSanitizedWebCAName)
    {
        // shouldn't happen, just in case
        LocalFree(pClient->pwszSanitizedWebCAName);
        pClient->pwszSanitizedWebCAName = NULL;
    }

    hr = DetermineClientUpgradePath(pComp);
    _JumpIfError(hr, error, "DetermineClientUpgradePath");


	// get ca
	hr = myGetCertRegDWValue(
			 NULL,
			 NULL,
			 NULL,
			 wszREGWEBCLIENTCATYPE,
			 (DWORD *) &pClient->WebCAType);
	_PrintIfErrorStr(hr, "myGetCertRegDWValue", wszREGWEBCLIENTCATYPE);


    hr = mySanitizeName(pClient->pwszWebCAName,
                        &pClient->pwszSanitizedWebCAName);
    _JumpIfError(hr, error, "mySanitizeName");

    hr = S_OK;

error:
    CSILOG(hr, IDS_LOG_UPGRADE_TYPE, NULL, NULL, (DWORD const *) &pComp->UpgradeFlag);
    return hr;
}



// apply ACL to key container for all upgrade scenarios

HRESULT
UpgradeKeyContainerSecurity(
    PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    HCRYPTPROV hProv = NULL;
    WCHAR *pwszProvName = NULL;
    DWORD dwProvType;
    ALG_ID idAlg;
    BOOL fMachineKeyset;

    // get prov name

    hr = myGetCertSrvCSP(
		FALSE,		// fEncryptionCSP
                pComp->CA.pServer->pwszSanitizedName,
                &dwProvType,
                &pwszProvName,
                &idAlg,
                &fMachineKeyset,
		NULL);		// pdwKeySize
    _JumpIfError(hr, error, "myGetCertSrvCSP");

    if (!myCertSrvCryptAcquireContext(&hProv,
                                    pComp->CA.pServer->pwszSanitizedName,
                                    pwszProvName,
                                    dwProvType,
                                    CRYPT_SILENT,  // get key, upgrade, no UI
                                    fMachineKeyset))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }

    // set acl on it

    hr = csiSetKeyContainerSecurity(hProv);
    _JumpIfError(hr, error, "csiSetKeyContainerSecurity");

error:
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    if (NULL != pwszProvName)
    {
        LocalFree(pwszProvName);
    }
    CSILOG(hr, IDS_LOG_UPGRADE_KEY_SECURITY, NULL, NULL, NULL);
    return hr;
}

    
HRESULT
InstallNewTemplates(HWND hwnd)
{
    HRESULT hr = S_OK;
    SHELLEXECUTEINFO shi;

    ZeroMemory(&shi, sizeof(shi));
    shi.cbSize = sizeof(shi);
    shi.hwnd = hwnd;
    shi.lpVerb = SZ_VERB_OPEN;
    shi.lpFile = SZ_REGSVR32;
    shi.lpParameters = SZ_REGSVR32_CERTCLI;
    shi.fMask = SEE_MASK_FLAG_NO_UI |
                SEE_MASK_NOCLOSEPROCESS;

    if(!ShellExecuteEx(&shi))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ShellExecuteEx");
    }

    if(WAIT_FAILED == WaitForSingleObject(shi.hProcess, INFINITE))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WaitForSingleObject");
    }

error:
    if(shi.hProcess)
    {
        CloseHandle(shi.hProcess);
    }
    return hr;
}


HRESULT
UpgradeServer(
    IN HWND                hwnd,
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    hr = RegisterAndUnRegisterDLLs(RD_SERVER, pComp, hwnd);
    _JumpIfError(hr, error, "RegisterAndUnRegisterDLLs");

    hr = LoadAndDetermineServerUpgradeInfo(pComp);
    _JumpIfError(hr, error, "LoadAndDetermineServerUpgradeInfo");

    // create enroll dir
    hr = CreateCertsrvDirectories(pComp, TRUE, TRUE);
    _JumpIfError(hr, error, "CreateCertsrvDirectories");

    hr = EnableVRootsAndShares(FALSE, TRUE, TRUE, pComp, hwnd);
    _PrintIfError(hr, "EnableVRootsAndShares(share only)");

    hr = UpgradeServerRegEntries(pComp);
    _JumpIfError(hr, error, "UpgradeServerRegEntries");

    hr = CreateCertWebIncPages(pComp, TRUE /* IsServer */ );
    _JumpIfError(hr, error, "CreateCertWebIncPages");

    hr = RenameMiscTargets(hwnd, pComp, TRUE);
    _JumpIfError(hr, error, "RenameMiscTargets");

    hr = UpgradeKeyContainerSecurity(pComp);
    // ignore new acl failure
    _PrintIfError(hr, "UpgradeKeyContainerSecurity");

    // always register dcom
    hr = RegisterDcomServer(
                        TRUE,
			CLSID_CCertRequestD,	// AppId
                        CLSID_CCertRequestD,
                        wszREQUESTFRIENDLYNAME,
                        wszREQUESTVERINDPROGID,
                        wszREQUESTPROGID);
    _JumpIfError(hr, error, "RegisterDcomServer");

    hr = RegisterDcomServer(
                        FALSE,
                        CLSID_CCertRequestD,	// AppId
                        CLSID_CCertAdminD,
                        wszADMINFRIENDLYNAME,
                        wszADMINVERINDPROGID,
                        wszADMINPROGID);
    _JumpIfError(hr, error, "RegisterDcomServer");

    hr = RegisterDcomApp(CLSID_CCertRequestD);
    _JumpIfError(hr, error, "RegisterDcomApp");

    // bug 446444: remove CLSID_CCertAdminD AppId

    {
        WCHAR wszCLSIDAppId[CLSID_STRING_SIZE];
        WCHAR wszKey[CLSID_STRING_SIZE+7] = L"AppID\\";

        CLSIDtochar(CLSID_CCertAdminD, wszCLSIDAppId, ARRAYSIZE(wszCLSIDAppId));

        wcscat(wszKey, wszCLSIDAppId);

        hr = RegDeleteKey(
            HKEY_CLASSES_ROOT,
            wszKey);
        _PrintIfErrorStr(hr, "Cannot delete ICertAdminD AppID", wszKey);
    }

    // fix for 155772	Certsrv: After upgrading a 2195 Enterprise Root CA 
    //                  to 2254.01VBL03 the CA will no longer issue Certs
    hr = InstallNewTemplates(hwnd);
    _JumpIfError(hr, error, "InstallNewTemplates");

    // always fix certsvc in upgrade
    hr = FixCertsvcService(pComp);
    _PrintIfError(hr, "FixCertsvcService");

    // delete any old program groups
    DeleteProgramGroups(TRUE);

    hr = CreateProgramGroups(FALSE, pComp, hwnd);
    _PrintIfError(hr, "CreateProgramGroups");

    // delete old stuff
    DeleteOldFilesAndDirectories(pComp);

    DBGPRINT((DBG_SS_CERTOCM, "UpgradeServer: setting SETUP_SERVER_UPGRADED_FLAG\n"));

    hr = SetSetupStatus(NULL, SETUP_SERVER_UPGRADED_FLAG, TRUE);
    _JumpIfError(hr, error, "SetSetupStatus");

    // Force new CRL generation on startup when upgrading from Win2k
    
    if(CS_UPGRADE_WIN2000 == pComp->UpgradeFlag)
    {
        DBGPRINT((DBG_SS_CERTOCM, "UpgradeServer: setting SETUP_FORCECRL_FLAG\n"));

        hr = SetSetupStatus(pServer->pwszSanitizedName, SETUP_FORCECRL_FLAG, TRUE);
        _PrintIfError(hr, "SetSetupStatus");
    }

    hr = csiUpgradeCertSrvSecurity(
            pServer->pwszSanitizedName,
            IsEnterpriseCA(pServer->CAType)?true:false,
            pServer->fUseDS?true:false,
            pComp->UpgradeFlag);
    if (hr == HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE))
    { 
        _PrintError(hr, "csiUpgradeCertSrvSecurity marked for later fixup; error ignored");
        hr = S_OK;
    }
    _JumpIfError(hr, error, "csiUpgradeCertSrvSecurity");

    hr = S_OK;
error:
    CSILOG(hr, IDS_LOG_UPGRADE_SERVER, NULL, NULL, NULL);
    return hr;
}


HRESULT
UpgradeClient(
    IN HWND                hwnd,
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;

    if ((IS_CLIENT_UPGRADE & pComp->dwInstallStatus) &&
        (IS_SERVER_UPGRADE & pComp->dwInstallStatus))
    {
        // upgrade server will also hit here so skip it
        goto done;
    }

    // unset client
    hr = SetSetupStatus(NULL, SETUP_CLIENT_FLAG, FALSE);
    _JumpIfError(hr, error, "SetSetupStatus");

    hr = RegisterAndUnRegisterDLLs(RD_CLIENT, pComp, hwnd);
    _JumpIfError(hr, error, "RegisterAndUnRegisterDLLs");

    hr = LoadAndDetermineClientUpgradeInfo(pComp);
    _JumpIfError(hr, error, "LoadAndDetermineClientUpgradeInfo");

    hr = UpgradeWebClientRegEntries(pComp);
    _JumpIfError(hr, error, "UpgradeWebClientRegEntries");

    hr = CreateCertWebIncPages(pComp, FALSE /* IsServer */ );
    _JumpIfError(hr, error, "CreateCertWebIncPages");

    hr = RenameMiscTargets(hwnd, pComp, FALSE);
    _JumpIfError(hr, error, "RenameMiscTargets");

    // delete any old program groups
    DeleteProgramGroups(FALSE);

    hr = CreateProgramGroups(TRUE, pComp, hwnd);
    _PrintIfError(hr, "CreateProgramGroups");

    hr = SetSetupStatus(NULL, SETUP_CLIENT_FLAG, TRUE);
    _JumpIfError(hr, error, "SetSetupStatus");

    DeleteOldFilesAndDirectories(pComp);

done:
    hr = S_OK;
error:
    CSILOG(hr, IDS_LOG_UPGRADE_CLIENT, NULL, NULL, NULL);
    return hr;
}


HRESULT
GetServerNames(
    IN HWND hwnd,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    OUT WCHAR **ppwszServerName,
    OUT WCHAR **ppwszServerNameOld)
{
    HRESULT hr;

    // Retrieve computer name strings.

    hr = myGetComputerNames(ppwszServerName, ppwszServerNameOld);
    if (S_OK != hr)
    {
        CertErrorMessageBox(
           hInstance,
           fUnattended,
           hwnd,
           IDS_ERR_GETCOMPUTERNAME,
           hr,
           NULL);
        _JumpError(hr, error, "myGetComputerNames");
    }

error:
    return(hr);
}


HRESULT
UpdateDomainAndUserName(
    IN HWND hwnd,
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;

    // free old server and installer info because we might get them in nt base

    if (NULL != pComp->pwszServerName)
    {
        LocalFree(pComp->pwszServerName);
        pComp->pwszServerName = NULL;
    }
    if (NULL != pComp->pwszServerNameOld)
    {
        LocalFree(pComp->pwszServerNameOld);
        pComp->pwszServerNameOld = NULL;
    }
    hr = GetServerNames(
		    hwnd,
		    pComp->hInstance,
		    pComp->fUnattended,
		    &pComp->pwszServerName,
		    &pComp->pwszServerNameOld);
    _JumpIfError(hr, error, "GetServerNames");

    DBGPRINT((DBG_SS_CERTOCM, "UpdateDomainAndUserName:%ws,%ws\n", pComp->pwszServerName, pComp->pwszServerNameOld));
    DumpBackTrace("UpdateDomainAndUserName");

error:
    return(hr);
}


HRESULT
StopCertService(
    IN SC_HANDLE hSC,
    IN WCHAR const *pwszServiceName)
{
    HRESULT hr;
    SERVICE_STATUS status;
    DWORD dwAttempt;

    if (!ControlService(hSC, SERVICE_CONTROL_STOP, &status))
    {
        hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE) != hr)
        {
            _JumpErrorStr(hr, error, "ControlService(Stop)", pwszServiceName);
        }
    }

    // get out after it is really stopped

    for (dwAttempt = 0; dwAttempt < CERT_MAX_ATTEMPT; dwAttempt++)
    {
        DBGCODE(status.dwCurrentState = MAXDWORD);
        if (!QueryServiceStatus(hSC, &status))
        {
            // query failed, ignore error
            hr = S_OK;

            _JumpErrorStr(
                    myHLastError(),             // Display ignored error
                    error,
                    "QueryServiceStatus",
                    pwszServiceName);
        }
        if (status.dwCurrentState != SERVICE_STOP_PENDING &&
            status.dwCurrentState != SERVICE_RUNNING)
        {
            // it was stopped already
            break;
        }
        DBGPRINT((
                DBG_SS_CERTOCM,
                "Stopping %ws service: current state=%d\n",
                pwszServiceName,
                status.dwCurrentState));
        Sleep(CERT_HALF_SECOND);
    }
    if (dwAttempt >= CERT_MAX_ATTEMPT)
    {
        DBGPRINT((
                DBG_SS_CERTOCM,
                "Timeout stopping %ws service: current state=%d\n",
                pwszServiceName,
                status.dwCurrentState));
    }
    else
    {
        DBGPRINT((
                DBG_SS_CERTOCM,
                "Stopped %ws service\n",
                pwszServiceName));
    }
    hr = S_OK;

error:
    CSILOG(hr, IDS_LOG_SERVICE_STOPPED, pwszServiceName, NULL, NULL);
    return(hr);
}


HRESULT
GetServiceControl(
    WCHAR const   *pwszServiceName,
    OUT SC_HANDLE *phService)
{
    HRESULT hr;
    SC_HANDLE hSCManager = NULL;

    *phService = NULL;
    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (NULL == hSCManager)
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenSCManager");
    }
    *phService = OpenService(hSCManager, pwszServiceName, SERVICE_ALL_ACCESS);
    if (NULL == *phService)
    {
        hr = myHLastError();
        _JumpErrorStr2(
                    hr,
                    error,
                    "OpenService",
                    pwszServiceName,
                    HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST));
    }

    hr = S_OK;
error:
    if (NULL != hSCManager)
    {
        CloseServiceHandle(hSCManager);
    }
    return hr;
}


HRESULT
IsServiceRunning(
    IN SC_HANDLE const hSCService,
    OUT BOOL *pfRun)
{
    HRESULT hr;
    SERVICE_STATUS status;

    *pfRun = FALSE;
    if (!QueryServiceStatus(hSCService, &status))
    {
        hr = myHLastError();
        _JumpError(hr, error, "QueryServiceStatus");
    }
    if (SERVICE_STOPPED != status.dwCurrentState &&
        SERVICE_STOP_PENDING != status.dwCurrentState)
    {
        *pfRun = TRUE;
    }

    hr = S_OK;
error:
    return hr;
}


HRESULT
StartAndStopService(
    IN HINSTANCE    hInstance,
    IN BOOL         fUnattended,
    IN HWND const   hwnd,
    IN WCHAR const *pwszServiceName,
    IN BOOL const   fStopService,
    IN BOOL const   fConfirm,
    IN int          iMsg,
    OUT BOOL       *pfServiceWasRunning)
{
    HRESULT hr;
    SC_HANDLE hService = NULL;

    *pfServiceWasRunning = FALSE;

    hr = GetServiceControl(pwszServiceName, &hService);
    if (S_OK != hr)
    {
        _PrintError2(
                hr,
                "GetServiceControl",
                HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST));
        if (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) == hr)
        {
            hr = S_OK;
        }
        goto error;
    }

    // to get status if the service is running
    hr = IsServiceRunning(hService, pfServiceWasRunning);
    _JumpIfError(hr, error, "IsServiceRunning");

    if (fStopService)
    {
        if (*pfServiceWasRunning)
        {
            // stop the service
            if (fConfirm)
            {
                // confirmation dialog
                int ret = CertMessageBox(
                            hInstance,
                            fUnattended,
                            hwnd,
                            iMsg,
                            0,
                            MB_YESNO |
				MB_ICONWARNING |
				CMB_NOERRFROMSYS,
                            NULL);
                if (IDYES != ret)
                {
                    hr = E_ABORT;
                    _JumpError(hr, error, "Cancel it");
                }
            }
            hr = StopCertService(hService, pwszServiceName);
            _JumpIfErrorStr(hr, error, "StopCertService", pwszServiceName);
        }
    }
    else
    {
        // START the service
        if (!*pfServiceWasRunning)
        {
            if (!StartService(hService, 0, NULL))
            {
                hr = myHLastError();
                _JumpErrorStr(hr, error, "StartService", pwszServiceName);
            }
        }
    }
    hr = S_OK;

error:
    if (NULL != hService)
    {
        CloseServiceHandle(hService);
    }
    CSILOG(
	    hr,
	    fStopService? IDS_LOG_SERVICE_STOPPED : IDS_LOG_SERVICE_STARTED,
	    pwszServiceName,
	    NULL,
	    NULL);
    return hr;
}

// fix existing certsvc service to add/use new service description
HRESULT
FixCertsvcService(PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    SC_HANDLE hService = NULL;
    QUERY_SERVICE_CONFIG *pServiceConfig = NULL;
    WCHAR     *pwszServiceDesc = NULL;
    WCHAR const *pwszDisplayName;
    SERVICE_DESCRIPTION sd;
    DWORD      dwSize;

    hr = GetServiceControl(wszSERVICE_NAME, &hService);
    _JumpIfError(hr, error, "GetServiceControl");

    // get size
    if (!QueryServiceConfig(hService,
                            NULL,
                            0,
                            &dwSize))
    {
        hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
        {
            _JumpError(hr, fix_desc, "QueryServiceConfig");
        }
    }
    else
    {
        // impossible???
        hr = E_INVALIDARG;
        _JumpError(hr, fix_desc, "QueryServiceConfig");
    }

    CSASSERT(0 < dwSize);

    // allocate config buffer
    pServiceConfig = (QUERY_SERVICE_CONFIG*)LocalAlloc(
                      LMEM_FIXED | LMEM_ZEROINIT,
                      dwSize);
    _JumpIfOutOfMemory(hr, error, pServiceConfig);

    // get config
    if (!QueryServiceConfig(hService,
                           pServiceConfig,
                           dwSize,
                           &dwSize))
    {
        hr = myHLastError();
        _JumpError(hr, fix_desc, "QueryServiceConfig");
    }

    // use new display name
    pwszDisplayName = myLoadResourceString(IDS_CA_SERVICEDISPLAYNAME);
    if (NULL == pwszDisplayName)
    {
        hr = myHLastError();
        _JumpError(hr, error, "myLoadResourceString");
    }

    if (!ChangeServiceConfig(hService,
                             pServiceConfig->dwServiceType, //dwServiceType
                             SERVICE_NO_CHANGE,    //dwStartType
                             SERVICE_NO_CHANGE,    //dwErrorControl
                             NULL,                 //lpBinaryPathName
                             NULL,                 //lpLoadOrderGroup
                             NULL,                 //lpdwTagId
                             NULL,                 //lpDependences
                             NULL,                 //lpServiceStartName
                             NULL,                 //lpPassword
                             pwszDisplayName))
    {
        hr = myHLastError();
        _JumpIfError(hr, fix_desc, "ChangeServiceConfig");
    }

fix_desc:
    // add description
    hr = myLoadRCString(pComp->hInstance, IDS_CA_SERVICEDESCRIPTION, &pwszServiceDesc);
    _JumpIfError(hr, error, "myLoadRCString");
    sd.lpDescription = pwszServiceDesc;

    if (!ChangeServiceConfig2(hService,
                                SERVICE_CONFIG_DESCRIPTION,
                                (VOID*)&sd))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ChangeServiceConfig2");
    }

    hr = S_OK;
error:
    if (NULL != hService)
    {
        CloseServiceHandle(hService);
    }
    if (NULL != pwszServiceDesc)
    {
        LocalFree(pwszServiceDesc);
    }
    if (NULL != pServiceConfig)
    {
        LocalFree(pServiceConfig);
    }
    return hr;
}


HRESULT
PreUninstallCore(
    IN HWND hwnd,
    IN PER_COMPONENT_DATA *pComp)
{
    BOOL fDummy;
    HRESULT hr;
    DWORD   dwFlags = RD_UNREGISTER;

    hr = StartAndStopService(pComp->hInstance,
                 pComp->fUnattended,
                 hwnd,
                 wszSERVICE_NAME,
                 TRUE,  // stop the service
                 FALSE, // no confirm
                 0,    //doesn't matter since no confirm
                 &fDummy);
    _PrintIfError(hr, "StartAndStopService");

    hr = RegisterAndUnRegisterDLLs(dwFlags, pComp, hwnd);
    _PrintIfError(hr, "RegisterAndUnRegisterDLLs");

    hr = S_OK;

    return(hr);
}


VOID
DeleteServiceAndGroups(
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd)
{
    SC_HANDLE hSCManager = NULL;
    SC_HANDLE hSC = NULL;
    HRESULT hr;

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (NULL == hSCManager)
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenSCManager");
    }

    hSC = OpenService(hSCManager, wszSERVICE_NAME, SERVICE_ALL_ACCESS);
    if (NULL != hSC)
    {
        if (!DeleteService(hSC))
        {
            hr = myHLastError();
            CertErrorMessageBox(
                hInstance,
                fUnattended,
                hwnd,
                IDS_ERR_DELETESERVICE,
                hr,
                wszSERVICE_NAME);
            _PrintError(hr, "DeleteService");
        }
        CloseServiceHandle(hSC);
    }

error:
    if (NULL != hSCManager)
    {
        CloseServiceHandle(hSCManager);
    }
}


HRESULT
SetCertSrvInstallVersion()
{
    HRESULT hr;

    hr = mySetCertRegDWValueEx(
			FALSE,
			NULL,
			NULL,
			NULL,
			wszREGVERSION,
            CSVER_BUILD_VERSION(CSVER_MAJOR, CSVER_MINOR));
    _PrintIfErrorStr(hr, "mySetCertRegDWValueEx", wszREGVERSION);

    return hr;
}


HRESULT
CreateWebClientRegEntries(
    BOOL                fUpgrade,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;

    hr = mySetCertRegStrValueEx(fUpgrade, NULL, NULL, NULL,
             wszREGWEBCLIENTCAMACHINE, pClient->pwszWebCAMachine);
    _JumpIfError(hr, error, "mySetCertRegStrValueEx");

    hr = mySetCertRegStrValueEx(fUpgrade, NULL, NULL, NULL,
             wszREGWEBCLIENTCANAME, pClient->pwszWebCAName);
    _JumpIfError(hr, error, "mySetCertRegStrValueEx");

    hr = mySetCertRegDWValueEx(fUpgrade, NULL, NULL, NULL,
             wszREGWEBCLIENTCATYPE, pClient->WebCAType);
    _JumpIfError(hr, error, "mySetCertRegDWValueEx");

    hr = mySetCertRegDWValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGLDAPFLAGS,
			0);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGLDAPFLAGS);

    hr = SetCertSrvInstallVersion();
    _JumpIfError(hr, error, "SetCertSrvInstallVersion");
     

    if (NULL != pClient->pwszSharedFolder)
    {
        hr = mySetCertRegStrValueEx(fUpgrade, NULL, NULL, NULL,
                 wszREGDIRECTORY, pClient->pwszSharedFolder);
        _JumpIfError(hr, error, "mySetCertRegStrValue");
    }

    hr = S_OK;
error:
    CSILOG(hr, IDS_LOG_CREATE_CLIENT_REG, NULL, NULL, NULL);
    return hr;
}


HRESULT
UpgradeWebClientRegEntries(
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;

    hr = CreateWebClientRegEntries(TRUE, pComp);
    _JumpIfError(hr, error, "CreateWebClientRegEntries");


//    hr = S_OK;
error:
    return hr;
}


HRESULT
DeleteCertificates(
    IN WCHAR const *pwszSanitizedCAName,
    IN BOOL fRoot)
{
    HRESULT hr;
    DWORD cCACerts;
    DWORD cCACert;
    DWORD dwNameId;
    HCERTSTORE hStore = NULL;
    CERT_CONTEXT const *pCACert = NULL;

    hr = myGetCARegHashCount(pwszSanitizedCAName, CSRH_CASIGCERT, &cCACerts);
    _JumpIfError(hr, error, "myGetCARegHashCount CSRH_CASIGCERT");

    hStore = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM_REGISTRY,
                        X509_ASN_ENCODING,
                        NULL,           // hProv
                        CERT_SYSTEM_STORE_LOCAL_MACHINE,
                        fRoot?wszROOT_CERTSTORE:wszCA_CERTSTORE);
    
    for (cCACert = 0; cCACert < cCACerts; cCACert++)
    {
	HRESULT hr2;

        hr2 = myFindCACertByHashIndex(
                            hStore,
                            pwszSanitizedCAName,
                            CSRH_CASIGCERT,
                            cCACert,
                            &dwNameId,
                            &pCACert);
        if (S_OK != hr2)
        {
            _PrintIfError2(hr2, "myFindCACertByHashIndex", S_FALSE);
            if (S_FALSE != hr2 &&
                CRYPT_E_NOT_FOUND != hr2)
            {
                hr = hr2;
            }
            continue;
        }

        if (!CertDeleteCertificateFromStore(pCACert))
        {
            hr = myHLastError();
            _PrintError(hr, "CertDeleteCertificateFromStore");
        }
        pCACert = NULL;
    }

error:
    CSASSERT(NULL == pCACert);

    if (NULL != hStore)
    {
        CertCloseStore(hStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }
    return hr;
}


HRESULT
UninstallCore(
    IN HWND hwnd,
    IN PER_COMPONENT_DATA *pComp,
    IN DWORD PerCentCompleteBase,
    IN DWORD PerCentCompleteMax,
    IN BOOL fPreserveClient,
    IN BOOL fRemoveVD,
    IN BOOL fPreserveToDoList)
{
    BOOL fCoInit = FALSE;
    HRESULT hr;
    WCHAR    *pwszSharedFolder = NULL;
    WCHAR    *pwszSanitizedCAName = NULL;
    ENUM_CATYPES  caType = ENUM_UNKNOWN_CA;
    BOOL     fUseDS = FALSE;
    WCHAR    *pwszDBDirectory = NULL;
    WCHAR    *pwszLogDirectory = NULL;
    WCHAR    *pwszSysDirectory = NULL;
    WCHAR    *pwszTmpDirectory = NULL;
    DWORD DBSessionCount = 0;
    DWORD PerCentCompleteDelta;

    PerCentCompleteDelta = (PerCentCompleteMax - PerCentCompleteBase) / 10;
#define _UNINSTALLPERCENT(tenths) \
            (PerCentCompleteBase + (tenths) * PerCentCompleteDelta)

    // get current active CA info
    hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGACTIVE, &pwszSanitizedCAName);
    _PrintIfError(hr, "UninstallCore(no active CA)");
    if (S_OK == hr)
    {
        hr = ArchiveCACertificate(pwszSanitizedCAName);
        _PrintIfError2(hr, "ArchiveCACertificate", HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

        hr = myGetCertRegDWValue(pwszSanitizedCAName, NULL, NULL, wszREGCATYPE, (DWORD*)&caType);
        _PrintIfError(hr, "no reg ca type");
        hr = myGetCertRegDWValue(pwszSanitizedCAName, NULL, NULL, wszREGCAUSEDS, (DWORD*)&fUseDS);
        _PrintIfError(hr, "no reg use ds");

        hr = DeleteCertificates(pwszSanitizedCAName, IsRootCA(caType));
        if(S_OK != hr)
        {
            CertWarningMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hwnd,
                        IDS_IDINFO_DELETECERTIFICATES,
                        hr,
                        NULL);
        }
    }
    hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGDIRECTORY, &pwszSharedFolder);
    _PrintIfError(hr, "no shared folder");

    hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGDBDIRECTORY, &pwszDBDirectory);
    _PrintIfError(hr, "no db directory");

    hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGDBLOGDIRECTORY, &pwszLogDirectory);
    _PrintIfError(hr, "no log directory");

    hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGDBSYSDIRECTORY, &pwszSysDirectory);
    _PrintIfError(hr, "no sys directory");

    hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGDBTEMPDIRECTORY, &pwszTmpDirectory);
    _PrintIfError(hr, "no tmp directory");

    hr = myGetCertRegDWValue(NULL, NULL, NULL, wszREGDBSESSIONCOUNT, &DBSessionCount);
    _PrintIfError(hr, "no session count");

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    DeleteServiceAndGroups(pComp->hInstance, pComp->fUnattended, hwnd);
    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(1) DBGPARM(L"UninstallCore"));

    if (!fPreserveToDoList)
    {
        // if we're uninstalling, always clear post-base ToDo list
        RegDeleteKey(HKEY_LOCAL_MACHINE, wszREGKEYCERTSRVTODOLIST);
    }

    if (fPreserveClient)
    {
        hr = RegisterAndUnRegisterDLLs(RD_CLIENT, pComp, hwnd);
        _JumpIfError(hr, error, "RegisterAndUnRegisterDLLs");

	hr = CreateCertWebIncPages(pComp, FALSE /* IsServer */ );
	_JumpIfError(hr, error, "CreateCertWebIncPages");
    }
    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(2) DBGPARM(L"UninstallCore"));

    DeleteProgramGroups(TRUE);

    if (fPreserveClient)
    {
        hr = CreateProgramGroups(TRUE, pComp, hwnd);
        _JumpIfError(hr, error, "CreateProgramGroups");
    }
    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(3) DBGPARM(L"UninstallCore"));

    UnregisterDcomServer(
                    CLSID_CCertRequestD,
                    wszREQUESTVERINDPROGID,
                    wszREQUESTPROGID);
    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(4) DBGPARM(L"UninstallCore"));

    UnregisterDcomServer(
                    CLSID_CCertAdminD,
                    wszADMINVERINDPROGID,
                    wszADMINPROGID);
    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(5) DBGPARM(L"UninstallCore"));

    UnregisterDcomApp();
    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(6) DBGPARM(L"UninstallCore"));

    if (fRemoveVD && !fPreserveClient)
    {
        DisableVRootsAndShares(TRUE, TRUE);
        myDeleteFilePattern(pComp->pwszSystem32, wszCERTSRV, TRUE);
    }

    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(7) DBGPARM(L"UninstallCore"));

    if (NULL != pwszSharedFolder)
    {
        // this must be restore before CreateConfigFiles()
        hr = mySetCertRegStrValue(NULL, NULL, NULL,
                 wszREGDIRECTORY, pwszSharedFolder);
        _PrintIfError(hr, "mySetCertRegStrValue");

        //remove entry
        hr = CreateConfigFiles(pwszSharedFolder, pComp, TRUE);
        _PrintIfError2(hr, "CreateConfigFiles(Remove old entry)", hr);
    }
    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(8) DBGPARM(L"UninstallCore"));

    // restore db path
    if (NULL != pwszDBDirectory)
    {
        hr = mySetCertRegStrValue(NULL, NULL, NULL,
                 wszREGDBDIRECTORY, pwszDBDirectory);
        _PrintIfError(hr, "mySetCertRegStrValue");
    }
    if (NULL != pwszLogDirectory)
    {
        hr = mySetCertRegStrValue(NULL, NULL, NULL,
                 wszREGDBLOGDIRECTORY, pwszLogDirectory);
        _PrintIfError(hr, "mySetCertRegStrValue");
    }
    if (NULL != pwszSysDirectory)
    {
        hr = mySetCertRegStrValue(NULL, NULL, NULL,
                 wszREGDBSYSDIRECTORY, pwszSysDirectory);
        _PrintIfError(hr, "mySetCertRegStrValue");
    }
    if (NULL != pwszTmpDirectory)
    {
        hr = mySetCertRegStrValue(NULL, NULL, NULL,
                 wszREGDBTEMPDIRECTORY, pwszTmpDirectory);
        _PrintIfError(hr, "mySetCertRegStrValue");
    }
    if (0 != DBSessionCount)
    {
        hr = mySetCertRegDWValue(NULL, NULL, NULL,
                 wszREGDBSESSIONCOUNT, DBSessionCount);
        _PrintIfError(hr, "mySetCertRegDWValueEx");
    }

    if (fPreserveClient)
    {
        // this means uninstall server component and keep web client
        hr = CreateWebClientRegEntries(FALSE, pComp);
        _JumpIfError(hr, error, "CreateWebClientRegEntries");
    }

    DeleteObsoleteResidue();
    DeleteOldFilesAndDirectories(pComp);

    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(9) DBGPARM(L"UninstallCore"));

    if (fUseDS)
    {
        hr = RemoveCAInDS(pwszSanitizedCAName);
        _PrintIfError2(hr, "RemoveCAInDS", hr);
    }
    certocmBumpGasGauge(pComp, PerCentCompleteMax DBGPARM(L"UninstallCore"));

    hr = S_OK;

error:
    if (NULL != pwszSanitizedCAName)
    {
        LocalFree(pwszSanitizedCAName);
    }
    if (NULL != pwszSharedFolder)
    {
        LocalFree(pwszSharedFolder);
    }
    if (NULL != pwszDBDirectory)
    {
        LocalFree(pwszDBDirectory);
    }
    if (NULL != pwszLogDirectory)
    {
        LocalFree(pwszLogDirectory);
    }
    if (NULL != pwszSysDirectory)
    {
        LocalFree(pwszSysDirectory);
    }
    if (NULL != pwszTmpDirectory)
    {
        LocalFree(pwszTmpDirectory);
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return(hr);
}


HRESULT
AddCAToRPCNullSessions()
{
    HRESULT hr;
    HKEY hRegKey = NULL;
    char *pszOriginal = NULL;
    char *psz;
    DWORD cb;
    DWORD cbTmp;
    DWORD cbSum;
    DWORD dwType;

    hr = RegOpenKeyExA(
                HKEY_LOCAL_MACHINE,
                szNULL_SESSION_REG_LOCATION,
                0,              // dwOptions
                KEY_READ | KEY_WRITE,
                &hRegKey);
    _JumpIfError(hr, error, "RegOpenKeyExA");

    // Need to get the size of the value first

    hr = RegQueryValueExA(hRegKey, szNULL_SESSION_VALUE, 0, &dwType, NULL, &cb);
    _JumpIfError(hr, error, "RegQueryValueExA");

    if (REG_MULTI_SZ != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "RegQueryValueExA: Type");
    }

    cb += sizeof(rgcCERT_NULL_SESSION) - 1;
    pszOriginal = (char *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb);

    if (NULL == pszOriginal)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    // get the multi string of RPC null session pipes
    hr = RegQueryValueExA(
                        hRegKey,
                        szNULL_SESSION_VALUE,
                        0,
                        &dwType,
                        (BYTE *) pszOriginal,
                        &cb);
    _JumpIfError(hr, error, "RegQueryValueExA");

    psz = pszOriginal;

    // look for CERT in the list

    cbSum = 0;
    for (;;)
    {
        if (0 == strcmp(rgcCERT_NULL_SESSION, psz))
        {
            break;
        }
        cbTmp = strlen(psz) + 1;
        psz += cbTmp;
        cbSum += cbTmp;
        if (cb < cbSum + 1)
        {
            break;
        }

        if ('\0' == psz[0])
        {
            // add the CA pipe to the multi string

            CopyMemory(psz, rgcCERT_NULL_SESSION, sizeof(rgcCERT_NULL_SESSION));

            // set the new multi string in the reg value
            hr = RegSetValueExA(
                            hRegKey,
                            szNULL_SESSION_VALUE,
                            0,
                            REG_MULTI_SZ,
                            (BYTE *) pszOriginal,
                            cbSum + sizeof(rgcCERT_NULL_SESSION));
            _JumpIfError(hr, error, "RegSetValueExA");

            break;
        }
    }
    hr = S_OK;

error:
    if (NULL != pszOriginal)
    {
        LocalFree(pszOriginal);
    }
    if (NULL != hRegKey)
    {
        RegCloseKey(hRegKey);
    }
    return(hr);
}


HRESULT
AddCARegKeyToRegConnectExemptions()
{
    // add ourselves to list of people that take ACLs seriously
    // and should be allowed to reveal our key to outsiders.

    HRESULT hr;
    LPWSTR pszExempt = NULL;
    HKEY hkeyWinReg = NULL, hkeyAllowedPaths = NULL;
    LPWSTR pszTmp;
    DWORD dwDisposition, dwType;
    DWORD cb=0, cbRegKeyCertSrvPath = (wcslen(wszREGKEYCERTSVCPATH)+1) *sizeof(WCHAR);

    // carefully query this -- if it doesn't exist, we don't have to apply workaround
    hr = RegOpenKeyEx(
       HKEY_LOCAL_MACHINE,
       L"SYSTEM\\CurrentControlSet\\Control\\SecurePipeServers\\Winreg",
       0,
       KEY_ALL_ACCESS,
       &hkeyWinReg);
    _JumpIfError(hr, Ret, "RegOpenKeyEx");
 
    // creation of this optional key is always ok if above key exists
    hr = RegCreateKeyEx(
        hkeyWinReg,
        L"AllowedPaths",
        NULL,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hkeyAllowedPaths,
        &dwDisposition);
    _JumpIfError(hr, Ret, "RegCreateKeyEx exempt regkey");

    hr = RegQueryValueEx(
      hkeyAllowedPaths,
      L"Machine",
      NULL, // reserved
      &dwType, // type
      NULL, // pb
      &cb);
    _PrintIfError(hr, "RegQueryValueEx exempt regkey 1");

    if ((hr == S_OK) && (dwType != REG_MULTI_SZ))
    {
       hr = HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
       _JumpError(hr, Ret, "RegQueryValueEx invalid type");
    }

    // always include at least a terminator
    if (cb < sizeof(WCHAR)) 
        cb = sizeof(WCHAR);

    pszExempt = (LPWSTR)LocalAlloc(LMEM_FIXED, cb + cbRegKeyCertSrvPath );
    _JumpIfOutOfMemory(hr, Ret, pszExempt);
    
    // start with double null for safety
    pszExempt[0] = L'\0';
    pszExempt[1] = L'\0';

    hr = RegQueryValueEx(
      hkeyAllowedPaths,
      L"Machine",
      NULL, // reserved
      NULL, // type
      (PBYTE)pszExempt, // pb
      &cb);
    _PrintIfError(hr, "RegQueryValueEx exempt regkey 2");

    pszTmp = pszExempt;
    while(pszTmp[0] != L'\0')        // skip all existing strings
    {
        // if entry already exists, bail
        if (0 == LSTRCMPIS(pszTmp, wszREGKEYCERTSVCPATH))
        {
            hr = S_OK;
            goto Ret;
        }
        pszTmp += wcslen(pszTmp)+1;
    }
    wcscpy(&pszTmp[0], wszREGKEYCERTSVCPATH);
    pszTmp[wcslen(wszREGKEYCERTSVCPATH)+1] = L'\0'; // double NULL

    hr = RegSetValueEx(
        hkeyAllowedPaths,
        L"Machine",
        NULL,
        REG_MULTI_SZ,
        (PBYTE)pszExempt,
        cb + cbRegKeyCertSrvPath);
    _JumpIfError(hr, Ret, "RegSetValueEx exempt regkey");
 

Ret:
    if (hkeyAllowedPaths)
        RegCloseKey(hkeyAllowedPaths);

    if (hkeyWinReg)
        RegCloseKey(hkeyWinReg);

    if (pszExempt)
        LocalFree(pszExempt);
    
    return hr;
}

HRESULT
helperGetFilesNotToRestore(
    PER_COMPONENT_DATA *pComp,
    OUT WCHAR          **ppwszz)
{
    HRESULT hr;
    WCHAR *pwsz;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    DWORD cwc;
    WCHAR const wszDBDIRPATTERN[] = L"\\*.edb";
    WCHAR const wszDBLOGDIRPATTERN[] = L"\\*";

    *ppwszz = NULL;

    cwc = wcslen(pServer->pwszDBDirectory) +
            WSZARRAYSIZE(wszDBDIRPATTERN) +
            1 +
            wcslen(pServer->pwszLogDirectory) +
            WSZARRAYSIZE(wszDBLOGDIRPATTERN) +
            1 +
            1;

    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pwsz);

    *ppwszz = pwsz;

    wcscpy(pwsz, pServer->pwszDBDirectory);
    wcscat(pwsz, wszDBDIRPATTERN);
    pwsz += wcslen(pwsz) + 1;

    wcscpy(pwsz, pServer->pwszLogDirectory);
    wcscat(pwsz, wszDBLOGDIRPATTERN);
    pwsz += wcslen(pwsz) + 1;

    *pwsz = L'\0';

    CSASSERT(cwc == (DWORD) (pwsz - *ppwszz + 1));
    hr = S_OK;

error:
    return(hr);
}


#define wszURLPREFIXFORMAT   L"%u:"

HRESULT 
RemoveDuplicatesIgnoreAndClearFlags(
    IN LPCWSTR pcwszSanitizedName,
    IN BOOL fCDP,
    IN LPCWSTR pcwszURLRegLocation,
    IN OUT LPWSTR pwszzNewURLs)
{
    HRESULT hr;
    CMultiSz szzOrig, szzNew, szzNewUpdated;
    WCHAR *pOrig = NULL;
    DWORD dwLen;
    void *pNewUpdated = NULL;
    CString *pStrNew;

    
    // read old URL list from registry
    hr = myGetCertRegMultiStrValue(
        pcwszSanitizedName,
        NULL,
        NULL,
        pcwszURLRegLocation,
        &pOrig);
    if (S_OK != hr)
    {
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
	{
	    _JumpErrorStr(
		    hr,
		    error,
		    "myGetCertRegMultiStrValue",
		    pcwszURLRegLocation);
	}
    }
    else if (NULL != pOrig)
    {
	hr = szzOrig.Unmarshal(pOrig);
	_JumpIfError(hr, error, "CMultiSz::Unmarshal");
    }
    hr = szzNew.Unmarshal(pwszzNewURLs);
    _JumpIfError(hr, error, "CMultiSz::Unmarshal");

    {
	CMultiSzEnum szzNewEnum(szzNew);

	// Compare the lists ignoring flags
	// (ie jump over "64:" in "64:http://foo.crl")
	// If match found, ignore the new URL

	for(pStrNew = szzNewEnum.Next();
	    pStrNew;
	    pStrNew = szzNewEnum.Next())
	{
	    WCHAR *pchNewSkipFlags = wcschr(*pStrNew, L':');
	    bool fDuplicate = false;

	    if(!pchNewSkipFlags)
		pchNewSkipFlags = pStrNew->GetBuffer();

	    if (!szzOrig.IsEmpty())
	    {
		CMultiSzEnum szzOrigEnum(szzOrig);
		CString *pStrOrig;

		for(pStrOrig = szzOrigEnum.Next();
		    pStrOrig;
		    pStrOrig = szzOrigEnum.Next())
		{
		    WCHAR *pchOrigSkipFlags =  wcschr(*pStrOrig, L':');

		    if(!pchOrigSkipFlags)
			pchOrigSkipFlags = pStrOrig->GetBuffer();

		    if(!mylstrcmpiL(pchOrigSkipFlags, pchNewSkipFlags))
		    {
			fDuplicate = true;
			break;
		    }
		}
	    }

	    if(!fDuplicate)
	    {
		WCHAR awcPrefix[cwcDWORDSPRINTF + 1];
		DWORD dwPrefixFlags = 0;

		if (fCDP)
		{
		    dwPrefixFlags = _wtoi(*pStrNew) & CSURL_ADDTOCRLCDP;
		}
		wsprintf(awcPrefix, wszURLPREFIXFORMAT, dwPrefixFlags);

		CString *pstrAdd = new CString(awcPrefix);
		_JumpIfAllocFailed(pstrAdd, error);

		*pstrAdd += &pchNewSkipFlags[1];
		DBGPRINT((DBG_SS_CERTOCM, "OLD URL: %ws\n", *pStrNew));
		DBGPRINT((DBG_SS_CERTOCM, "NEW URL: %ws\n", *pstrAdd));

		if(!szzNewUpdated.AddTail(pstrAdd))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "AddTail");
		}
	    }
	}
    }
    hr = szzNewUpdated.Marshal(pNewUpdated, dwLen);
    _JumpIfError(hr, error, "CMultiSz::Marshal");

    memcpy(pwszzNewURLs, pNewUpdated, dwLen);
    hr = S_OK;

error:
    LOCAL_FREE(pOrig);
    LOCAL_FREE(pNewUpdated);
    return hr;
}


HRESULT
CreateServerRegEntries(
    BOOL fUpgrade,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    HKEY hKeyBase = NULL;

    WCHAR *pwszCLSIDCertGetConfig = NULL;
    WCHAR *pwszCLSIDCertRequest = NULL;
    WCHAR *pwszCRLPeriodString = NULL;
    WCHAR *pwszCRLDeltaPeriodString = NULL;

    WCHAR *pwszzCRLPublicationValue = NULL;
    WCHAR *pwszzCACertPublicationValue = NULL;
    WCHAR *pwszzRequestExtensionList = NULL;
    WCHAR *pwszzEnrolleeRequestExtensionList = NULL;
    WCHAR *pwszzDisableExtensionList = NULL;
    WCHAR *pwszzFilesNotToRestore = NULL;

    WCHAR *pwszProvNameReg = NULL;
    CASERVERSETUPINFO  *pServer = pComp->CA.pServer;
    DWORD dwUpgradeFlags = fUpgrade ? CSREG_UPGRADE : 0x0;

    DWORD dwCRLPeriodCount, dwCRLDeltaPeriodCount;

    LDAP *pld = NULL;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;

    // no error checking?
    hr = AddCAToRPCNullSessions();
    _PrintIfError(hr, "AddCAToRPCNullSessions");
    
    hr = AddCARegKeyToRegConnectExemptions();
    _PrintIfError(hr, "AddCARegKeyToRegConnectExemptions");

    // create the CA key, so we can set security on it.
    hr = myCreateCertRegKey(pServer->pwszSanitizedName, NULL, NULL);
    _JumpIfError(hr, error, "myCreateCertRegKey");


    // configuration level

    // active ca
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGACTIVE,
			pServer->pwszSanitizedName);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGACTIVE);

    if (NULL != pServer->pwszSharedFolder)
    {
        // shared folder
        hr = mySetCertRegStrValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGDIRECTORY,
			pServer->pwszSharedFolder);
        _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGDIRECTORY);
    }

    // db dir
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGDBDIRECTORY,
			pServer->pwszDBDirectory);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGDBDIRECTORY);

    // log dir
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGDBLOGDIRECTORY,
			pServer->pwszLogDirectory);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGDBLOGDIRECTORY);

    // db tmp dir
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGDBTEMPDIRECTORY,
			pServer->pwszLogDirectory);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGDBTEMPDIRECTORY);

    // db sys dir
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGDBSYSDIRECTORY,
			pServer->pwszLogDirectory);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGDBSYSDIRECTORY);

    hr = mySetCertRegDWValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGDBSESSIONCOUNT,
			DBSESSIONCOUNTDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGDBSESSIONCOUNT);

    hr = mySetCertRegDWValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGLDAPFLAGS,
			0);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGLDAPFLAGS);

    hr = mySetCertRegDWValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGDBFLAGS,
			DBFLAGS_DEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGDBFLAGS);
   
    hr = SetCertSrvInstallVersion();
    _JumpIfError(hr, error, "SetCertSrvInstallVersion");

    if (!fUpgrade)
    {
        // preserve db
        hr = SetSetupStatus(NULL, SETUP_CREATEDB_FLAG, !pServer->fPreserveDB);
        _JumpIfError(hr, error, "SetSetupStatus");
    }

    // ca level

    if (!fUpgrade && pServer->fUseDS)
    {
	hr = myLdapOpen(
		    NULL,
		    RLBF_REQUIRE_SECURE_LDAP,
		    &pld,
		    &strDomainDN,
		    &strConfigDN);
	_JumpIfError(hr, error, "myLdapOpen");

	// Config DN

	hr = mySetCertRegStrValueEx(
			FALSE,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGDSCONFIGDN,
			strConfigDN);
	_JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGDSCONFIGDN);

	// Domain DN

	hr = mySetCertRegStrValueEx(
			FALSE,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGDSDOMAINDN,
			strDomainDN);
	_JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGDSDOMAINDN);
    }

    // (hard code) view age, idle minutes
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGVIEWAGEMINUTES,
			CVIEWAGEMINUTESDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGVIEWAGEMINUTES);

    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGVIEWIDLEMINUTES,
			CVIEWIDLEMINUTESDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGVIEWIDLEMINUTES);


    // ca type

    CSASSERT(IsEnterpriseCA(pServer->CAType) || IsStandaloneCA(pServer->CAType));
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCATYPE,
			pServer->CAType);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCATYPE);

    // use DS flag
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCAUSEDS,
			pServer->fUseDS);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCAUSEDS);

    // teletex flag
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGFORCETELETEX,
			ENUM_TELETEX_AUTO | ENUM_TELETEX_UTF8);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGFORCETELETEX);


    hr = mySetCertRegMultiStrValueEx(
		       dwUpgradeFlags,
		       pServer->pwszSanitizedName, 
		       NULL, 
		       NULL,
		       wszSECUREDATTRIBUTES, 
		       wszzDEFAULTSIGNEDATTRIBUTES);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszSECUREDATTRIBUTES);

    // common name
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCOMMONNAME,
			pServer->pwszCACommonName);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCOMMONNAME);

    // enable reg
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGENABLED,
			TRUE);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGENABLED);

    // policy flag
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGPOLICYFLAGS,
			0);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGPOLICYFLAGS);

    // enroll compatible flag, always turn it off
    // BUG, consider use mySetCertRegDWValueEx with fUpgrade
    //      after W2K to support CertEnrollCompatible upgrade

    hr = mySetCertRegDWValue(
                        pServer->pwszSanitizedName,
                        NULL,
                        NULL,
                        wszREGCERTENROLLCOMPATIBLE,
                        FALSE);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValue", wszREGCERTENROLLCOMPATIBLE);

    // Cert Server CRL Edit Flags

    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        NULL,
                        NULL,
                        wszREGCRLEDITFLAGS,
                        EDITF_ENABLEAKIKEYID);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLEDITFLAGS);


    // Cert Server CRL Flags

    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        NULL,
                        NULL,
                        wszREGCRLFLAGS,
			CRLF_DELETE_EXPIRED_CRLS);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLFLAGS);

    // Cert Server Interface Flags

    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        NULL,
                        NULL,
			wszREGINTERFACEFLAGS,
			IF_DEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGINTERFACEFLAGS);

    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        NULL,
                        NULL,
                        wszREGENFORCEX500NAMELENGTHS,
                        TRUE);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGENFORCEX500NAMELENGTHS);

    // set subject template; if upgrading, fix the template only if it's win2k upgrade

    if (!fUpgrade ||
        (fUpgrade && (pComp->UpgradeFlag == CS_UPGRADE_WIN2000)))
    {
        hr = mySetCertRegMultiStrValueEx(
			0,		// dwUpgradeFlags: always overwrite!
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGSUBJECTTEMPLATE,
            wszzREGSUBJECTTEMPLATEVALUE);
        _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGSUBJECTTEMPLATE);
    }

    // (hard code) clock skew minutes
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCLOCKSKEWMINUTES,
			CCLOCKSKEWMINUTESDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCLOCKSKEWMINUTES);

    // (hard code) log level
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGLOGLEVEL,
			CERTLOG_WARNING);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGLOGLEVEL);

    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGHIGHSERIAL,
			0);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGLOGLEVEL);

    // register server name
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCASERVERNAME,
			pComp->pwszServerName);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCASERVERNAME);

    // default validity period string and count for issued certs
    // use years for string

    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGVALIDITYPERIODSTRING,
			wszVALIDITYPERIODSTRINGDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGVALIDITYPERIODSTRING);

    // validity period count
    // use 1 year for standalone and 2 years for enterprise

    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGVALIDITYPERIODCOUNT,
			IsEnterpriseCA(pServer->CAType)?
			    dwVALIDITYPERIODCOUNTDEFAULT_ENTERPRISE :
			    dwVALIDITYPERIODCOUNTDEFAULT_STANDALONE);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGVALIDITYPERIODCOUNT);

    hr = mySetCertRegMultiStrValueEx(
                            dwUpgradeFlags,
                            pServer->pwszSanitizedName,
                            NULL,
                            NULL,
			    wszREGCAXCHGCERTHASH,
                            NULL);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGCAXCHGCERTHASH);

    hr = mySetCertRegMultiStrValueEx(
                            dwUpgradeFlags,
                            pServer->pwszSanitizedName,
                            NULL,
                            NULL,
			    wszREGKRACERTHASH,
                            NULL);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGKRACERTHASH);

    hr = mySetCertRegDWValueEx(
                            dwUpgradeFlags,
                            pServer->pwszSanitizedName,
                            NULL,
                            NULL,
                            wszREGKRACERTCOUNT,
                            0);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGKRACERTCOUNT);

    hr = mySetCertRegDWValueEx(
                            dwUpgradeFlags,
                            pServer->pwszSanitizedName,
                            NULL,
                            NULL,
                            wszREGKRAFLAGS,
                            0);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGKRAFLAGS);

    // CRL Publication URLs:

    hr = csiGetCRLPublicationURLTemplates(
			pServer->fUseDS,
			pComp->pwszSystem32,
			&pwszzCRLPublicationValue);
    _JumpIfError(hr, error, "csiGetCRLPublicationURLTemplates");

    // bug 489467 - NTDEV CAs after upgrade have duplicated http: & file: URLs

    if (fUpgrade)
    {
	hr = RemoveDuplicatesIgnoreAndClearFlags(
			pServer->pwszSanitizedName,
			TRUE,
			wszREGCRLPUBLICATIONURLS,
			pwszzCRLPublicationValue);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "RemoveDuplicatesIgnoreAndClearFlags",
		    wszREGCRLPUBLICATIONURLS);
    }
    
    hr = mySetCertRegMultiStrValueEx(
                        dwUpgradeFlags | (fUpgrade? CSREG_MERGE : 0),
                        pServer->pwszSanitizedName,
                        NULL,
                        NULL,
			wszREGCRLPUBLICATIONURLS,
			pwszzCRLPublicationValue);
    _JumpIfErrorStr(
		hr,
		error,
		"mySetCertRegMultiStrValueEx",
		wszREGCRLPUBLICATIONURLS);


    // if this API returns non-null strings, it's got good data
    hr = csiGetCRLPublicationParams(
                        TRUE,
                        &pwszCRLPeriodString,
                        &dwCRLPeriodCount);
    _PrintIfError(hr, "csiGetCRLPublicationParams");

    // crl period string
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLPERIODSTRING,
			(pwszCRLPeriodString == NULL) ? wszCRLPERIODSTRINGDEFAULT : pwszCRLPeriodString);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLPERIODSTRING);

    // crl period count
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLPERIODCOUNT,
			(pwszCRLPeriodString == NULL) ? dwCRLPERIODCOUNTDEFAULT : dwCRLPeriodCount);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCRLPERIODCOUNT);

    // crl overlap period string
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLOVERLAPPERIODSTRING,
			wszCRLOVERLAPPERIODSTRINGDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLOVERLAPPERIODSTRING);

    // crl overlap period count
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLOVERLAPPERIODCOUNT,
			dwCRLOVERLAPPERIODCOUNTDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCRLOVERLAPPERIODCOUNT);

    // if this API returns non-null strings, it's got good data
    hr = csiGetCRLPublicationParams(
                        FALSE,	// delta
                        &pwszCRLDeltaPeriodString,
                        &dwCRLDeltaPeriodCount);
    _PrintIfError(hr, "csiGetCRLPublicationParams");

    // delta crl period string
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLDELTAPERIODSTRING,
			(pwszCRLDeltaPeriodString == NULL) ? wszCRLDELTAPERIODSTRINGDEFAULT : pwszCRLDeltaPeriodString);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLDELTAPERIODSTRING);

    {
        DWORD dwCRLDeltaPeriodCountEffective = 
            (pwszCRLDeltaPeriodString == NULL) ? 
            dwCRLPERIODCOUNTDEFAULT : 
            dwCRLDeltaPeriodCount;

        // 435575: disable delta CRL on standalone root CAs
        // 498370: unless delta CRL validity is defined in capolicy.inf
	// 751244: upgrade logic same as clean install (if no registry value)

        if (!IsEnterpriseCA(pServer->CAType) &&
            IsRootCA(pServer->CAType) &&
            !pwszCRLDeltaPeriodString)
        {
            dwCRLDeltaPeriodCountEffective = 0;
        }

        // delta crl period count
        hr = mySetCertRegDWValueEx(
			    fUpgrade,
			    pServer->pwszSanitizedName,
			    NULL,
			    NULL,
			    wszREGCRLDELTAPERIODCOUNT,
			    dwCRLDeltaPeriodCountEffective);
        _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCRLDELTAPERIODCOUNT);
    }

    // delta crl overlap period string
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLDELTAOVERLAPPERIODSTRING,
			wszCRLDELTAOVERLAPPERIODSTRINGDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLDELTAOVERLAPPERIODSTRING);

    // delta crl overlap period count
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLDELTAOVERLAPPERIODCOUNT,
			dwCRLDELTAOVERLAPPERIODCOUNTDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCRLDELTAOVERLAPPERIODCOUNT);

    // CA xchg cert validity period string
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCAXCHGVALIDITYPERIODSTRING,
			wszCAXCHGVALIDITYPERIODSTRINGDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLDELTAOVERLAPPERIODSTRING);

    // CA xchg cert validity period count
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCAXCHGVALIDITYPERIODCOUNT,
			dwCAXCHGVALIDITYPERIODCOUNTDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCRLDELTAOVERLAPPERIODCOUNT);

    // CA xchg cert overlap period string
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCAXCHGOVERLAPPERIODSTRING,
			wszCAXCHGOVERLAPPERIODSTRINGDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLDELTAOVERLAPPERIODSTRING);

    // CA xchg cert overlap period count
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCAXCHGOVERLAPPERIODCOUNT,
			dwCAXCHGOVERLAPPERIODCOUNTDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCRLDELTAOVERLAPPERIODCOUNT);

    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGMAXINCOMINGMESSAGESIZE,
			MAXINCOMINGMESSAGESIZEDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGMAXINCOMINGMESSAGESIZE);

    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGMAXINCOMINGALLOCSIZE,
			MAXINCOMINGALLOCSIZEDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGMAXINCOMINGALLOCSIZE);

    if (NULL != pServer->pwszSharedFolder)
    {
        // register CA file name for certhier and renewal

	hr = mySetCARegFileNameTemplate(
			wszREGCACERTFILENAME,
			pComp->pwszServerName,
			pServer->pwszSanitizedName,
			pServer->pwszCACertFile);
	_JumpIfError(hr, error, "SetRegCertFileName");
    }

    // policy

    // create default policy entry explicitly to get correct acl if upgrade
    hr = myCreateCertRegKeyEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			wszREGKEYPOLICYMODULES,
			wszCLASS_CERTPOLICY);
    _JumpIfErrorStr(hr, error, "myCreateCertRegKeyEx", wszCLASS_CERTPOLICY);

    // if customized policy, create a new entry with correct acl
    if (fUpgrade &&
        NULL != pServer->pwszCustomPolicy &&
        0 != wcscmp(wszCLASS_CERTPOLICY, pServer->pwszCustomPolicy) )
    {
        hr = myCreateCertRegKeyEx(
			    TRUE, // upgrade
			    pServer->pwszSanitizedName,
			    wszREGKEYPOLICYMODULES,
			    pServer->pwszCustomPolicy);
        _JumpIfError(hr, error, "myCreateCertRegKey");
    }

    // set default policy
    hr = mySetCertRegStrValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        NULL,
                        wszREGACTIVE,
                        (fUpgrade && (NULL != pServer->pwszCustomPolicy)) ?
                                     pServer->pwszCustomPolicy :
                                     wszCLASS_CERTPOLICY);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGACTIVE);


    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        wszCLASS_CERTPOLICY,
                        wszREGREVOCATIONTYPE,
                        pServer->dwRevocationFlags);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGREVOCATIONTYPE);

    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        wszCLASS_CERTPOLICY,
                        wszREGCAPATHLENGTH,
                        CAPATHLENGTH_INFINITE);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCAPATHLENGTH);

    // revocation url

    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			wszREGKEYPOLICYMODULES,
			wszCLASS_CERTPOLICY,
			wszREGREVOCATIONURL,
			g_wszASPRevocationURLTemplate);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGREVOCATIONURL);

    // Exit module publish flags
    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        wszREGKEYEXITMODULES,
                        wszCLASS_CERTEXIT,
                        wszREGCERTPUBLISHFLAGS,
                        pServer->fUseDS ?
                            EXITPUB_DEFAULT_ENTERPRISE :
                            EXITPUB_DEFAULT_STANDALONE);
    _JumpIfErrorStr(
                hr,
                error,
                "mySetCertRegStrValueEx",
                wszREGCERTPUBLISHFLAGS);

    // Enable Request Extensions:

    hr = helperGetRequestExtensionList(&pwszzRequestExtensionList);
    _JumpIfError(hr, error, "helperGetRequestExtensionList");

    hr = mySetCertRegMultiStrValueEx(
                            dwUpgradeFlags | CSREG_MERGE,
                            pServer->pwszSanitizedName,
                            wszREGKEYPOLICYMODULES,
                            wszCLASS_CERTPOLICY,
                            wszREGENABLEREQUESTEXTENSIONLIST,
                            pwszzRequestExtensionList);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGENABLEREQUESTEXTENSIONLIST);

    hr = helperGetEnrolleeRequestExtensionList(
			&pwszzEnrolleeRequestExtensionList);
    _JumpIfError(hr, error, "helperGetRequestExtensionList");

    hr = mySetCertRegMultiStrValueEx(
                            dwUpgradeFlags | CSREG_MERGE,
                            pServer->pwszSanitizedName,
                            wszREGKEYPOLICYMODULES,
                            wszCLASS_CERTPOLICY,
                            wszREGENABLEENROLLEEREQUESTEXTENSIONLIST,
                            pwszzEnrolleeRequestExtensionList);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGENABLEENROLLEEREQUESTEXTENSIONLIST);

    hr = helperGetDisableExtensionList(&pwszzDisableExtensionList);
    _JumpIfError(hr, error, "helperGetDisableExtensionList");

    if (fUpgrade)
    {
	helperDeleteTrashedDisableList(pServer->pwszSanitizedName);
    }

    // Disables Template Extensions:

    hr = mySetCertRegMultiStrValueEx(
                            dwUpgradeFlags | CSREG_MERGE,
                            pServer->pwszSanitizedName,
                            wszREGKEYPOLICYMODULES,
                            wszCLASS_CERTPOLICY,
                            wszREGDISABLEEXTENSIONLIST,
                            pwszzDisableExtensionList);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGDISABLEEXTENSIONLIST);

    // Subject Alt Name Extension

    hr = mySetCertRegStrValueEx(
                              fUpgrade,
                              pServer->pwszSanitizedName,
                              wszREGKEYPOLICYMODULES,
                              wszCLASS_CERTPOLICY,
                              wszREGSUBJECTALTNAME,
                              wszREGSUBJECTALTNAMEVALUE);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGSUBJECTALTNAME);

    // Subject Alt Name 2 Extension

    hr = mySetCertRegStrValueEx(
                              fUpgrade,
                              pServer->pwszSanitizedName,
                              wszREGKEYPOLICYMODULES,
                              wszCLASS_CERTPOLICY,
                              wszREGSUBJECTALTNAME2,
                              wszREGSUBJECTALTNAME2VALUE);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGSUBJECTALTNAME2);

    // Request Disposition

    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        wszCLASS_CERTPOLICY,
                        wszREGREQUESTDISPOSITION,
                        IsEnterpriseCA(pServer->CAType)?
                            REQDISP_DEFAULT_ENTERPRISE :
                            REQDISP_DEFAULT_STANDALONE);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx",
            wszREGREQUESTDISPOSITION);

    // Edit Flags

    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        wszCLASS_CERTPOLICY,
                        wszREGEDITFLAGS,
                        IsEnterpriseCA(pServer->CAType)?
                            (EDITF_DEFAULT_ENTERPRISE | pServer->dwUpgradeEditFlags) :
                            (EDITF_DEFAULT_STANDALONE | pServer->dwUpgradeEditFlags));
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGEDITFLAGS);
   

    // add new flags if this is EntCA W2k or Whistler beta2 upgrade 
    if (fUpgrade && 
        ((pComp->UpgradeFlag == CS_UPGRADE_WIN2000) ||
        ((pComp->UpgradeFlag == CS_UPGRADE_WHISTLER) &&
          CSVER_MINOR_WHISTLER_BETA2 == CSVER_EXTRACT_MINOR(pComp->dwVersion))) &&
        IsEnterpriseCA(pServer->CAType))
    {
        DWORD dwEditFlags=0;
        hr = myGetCertRegDWValue(
                        pServer->pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        wszCLASS_CERTPOLICY,
                        wszREGEDITFLAGS,
                        (DWORD *) &dwEditFlags);
        _JumpIfError(hr, error, "myGetCertRegDWValue");

        dwEditFlags |= EDITF_ENABLEDEFAULTSMIME;
        
        // bug 446444: remove these flags on upgrade:
        dwEditFlags &= ~(EDITF_ENABLEAKIISSUERNAME |
                         EDITF_ENABLEAKIISSUERSERIAL);

        hr = mySetCertRegDWValue(
                        pServer->pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        wszCLASS_CERTPOLICY,
                        wszREGEDITFLAGS,
                        dwEditFlags);
        _JumpIfError(hr, error, "mySetCertRegDWValue");
    }

    // bug 446444: don't set IssuerCertURLFlags on fresh install
    //
    // ...code removed

    hr = mySetCertRegMultiStrValueEx(
                        dwUpgradeFlags,
                        pServer->pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        wszCLASS_CERTPOLICY,
			wszREGDEFAULTSMIME,
			wszzREGVALUEDEFAULTSMIME);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGDEFAULTSMIME);
    hr = csiGetCACertPublicationURLTemplates(
			pServer->fUseDS,
			pComp->pwszSystem32,
			&pwszzCACertPublicationValue);
    _JumpIfError(hr, error, "csiGetCACertPublicationURLTemplates");

    // bug 489467 - NTDEV CAs after upgrade have duplicated http: & file: URLs

    if (fUpgrade)
    {
	hr = RemoveDuplicatesIgnoreAndClearFlags(
			pServer->pwszSanitizedName,
			FALSE,
			wszREGCACERTPUBLICATIONURLS,
			pwszzCACertPublicationValue);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "RemoveDuplicatesIgnoreAndClearFlags",
		    wszREGCACERTPUBLICATIONURLS);
    }
    
    hr = mySetCertRegMultiStrValueEx(
                        dwUpgradeFlags | (fUpgrade? CSREG_MERGE : 0),
                        pServer->pwszSanitizedName,
                        NULL,
                        NULL,
			wszREGCACERTPUBLICATIONURLS,
			pwszzCACertPublicationValue);
    _JumpIfErrorStr(
		hr,
		error,
		"mySetCertRegMultiStrValueEx",
		wszREGCACERTPUBLICATIONURLS);

    // exit

    // create default exit entry to get correct acl if upgrade
    hr = myCreateCertRegKeyEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			wszREGKEYEXITMODULES,
			wszCLASS_CERTEXIT);
    _JumpIfErrorStr(hr, error, "myCreateCertRegKeyEx", wszCLASS_CERTPOLICY);

    // if customized exit, create a new entry with correct acl
    if (fUpgrade &&
        NULL != pServer->pwszzCustomExit &&
        0 != wcscmp(wszCLASS_CERTEXIT, pServer->pwszzCustomExit) )
    {
        // create a new entry for custom exit
        hr = myCreateCertRegKeyEx(
			TRUE,  // upgrade
			pServer->pwszSanitizedName,
			wszREGKEYEXITMODULES,
			pServer->pwszzCustomExit);
        _JumpIfError(hr, error, "myCreateCertRegKey");
    }

    // set default exit
    hr = mySetCertRegMultiStrValueEx(
                        dwUpgradeFlags,
                        pServer->pwszSanitizedName,
                        wszREGKEYEXITMODULES,
                        NULL,
                        wszREGACTIVE,
                        (fUpgrade && (NULL != pServer->pwszzCustomExit)) ?
                                     pServer->pwszzCustomExit :
                                     wszCLASS_CERTEXIT L"\0");
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGACTIVE);


    // set some absolute keys and values

    hr = mySetAbsRegMultiStrValue(
                        wszREGKEYKEYSNOTTORESTORE,
                        wszREGRESTORECERTIFICATEAUTHORITY,
                        wszzREGVALUERESTORECERTIFICATEAUTHORITY);
    _JumpIfError(hr, error, "mySetAbsRegMultiStrValue");

    hr = helperGetFilesNotToRestore(pComp, &pwszzFilesNotToRestore);
    _JumpIfError(hr, error, "helperGetFilesNotToRestore");

    hr = mySetAbsRegMultiStrValue(
                        wszREGKEYFILESNOTTOBACKUP,
                        wszREGRESTORECERTIFICATEAUTHORITY,
                        pwszzFilesNotToRestore);
    _JumpIfError(hr, error, "mySetAbsRegMultiStrValue");


    // ICertGetConfig
    hr = StringFromCLSID(CLSID_CCertGetConfig, &pwszCLSIDCertGetConfig);
    _JumpIfError(hr, error, "StringFromCLSID(CCertGetConfig)");

    hr = mySetAbsRegStrValue(
                        wszREGKEYKEYRING,
                        wszREGCERTGETCONFIG,
                        pwszCLSIDCertGetConfig);
    _JumpIfError(hr, error, "mySetAbsRegStrValue");

    // ICertCertRequest
    hr = StringFromCLSID(CLSID_CCertRequest, &pwszCLSIDCertRequest);
    _JumpIfError(hr, error, "StringFromCLSID(CCertRequest)");

    hr = mySetAbsRegStrValue(
                        wszREGKEYKEYRING,
                        wszREGCERTREQUEST,
                        pwszCLSIDCertRequest);
    _JumpIfError(hr, error, "mySetAbsRegStrValue");

    if (NULL != pServer->pCSPInfo &&
        NULL != pServer->pHashInfo)
    {
        WCHAR const *pwszProvName = pServer->pCSPInfo->pwszProvName;
	DWORD dwProvType;
	ALG_ID idAlg;
	BOOL fMachineKeyset;
	DWORD dwKeySize;

	if (0 == LSTRCMPIS(pwszProvName, MS_DEF_PROV_W) && IsWhistler())
	{
	    pwszProvName = MS_STRONG_PROV_W;
	}
	hr = SetCertSrvCSP(
			FALSE,			// fEncryptionCSP
			pServer->pwszSanitizedName,
                        pServer->pCSPInfo->dwProvType,
			pwszProvName,
                        pServer->pHashInfo->idAlg,
                        pServer->pCSPInfo->fMachineKeyset,
			0);			// dwKeySize
        _JumpIfError(hr, error, "SetCertSrvCSP");

	hr = myGetCertSrvCSP(
			TRUE,			// fEncryptionCSP
			pServer->pwszSanitizedName,
			&dwProvType,
			&pwszProvNameReg,
			&idAlg,
			&fMachineKeyset,
			&dwKeySize);		// pdwKeySize
	if (S_OK != hr)
	{
	    _PrintError(hr, "myGetCertSrvCSP");
	    dwProvType = pServer->pCSPInfo->dwProvType;
	    idAlg = CALG_3DES;
	    fMachineKeyset = pServer->pCSPInfo->fMachineKeyset;
	    dwKeySize = 1024;
	}
	else if (NULL != pwszProvNameReg && L'\0' != *pwszProvNameReg)
	{
	    pwszProvName = pwszProvNameReg;
	    if (0 == LSTRCMPIS(pwszProvName, MS_DEF_PROV_W) && IsWhistler())
	    {
		pwszProvName = MS_STRONG_PROV_W;
	    }
	}
        hr = SetCertSrvCSP(
			TRUE,			// fEncryptionCSP
			pServer->pwszSanitizedName,
                        dwProvType,
			pwszProvName,
                        idAlg,
                        fMachineKeyset,
			dwKeySize);		// dwKeySize
        _JumpIfError(hr, error, "SetCertSrvCSP");
    }
    hr = S_OK;

error:
    if (NULL != pwszProvNameReg)
    {
	LocalFree(pwszProvNameReg);
    }
    myLdapClose(pld, strDomainDN, strConfigDN);
    if (NULL != pwszCLSIDCertGetConfig)
    {
        CoTaskMemFree(pwszCLSIDCertGetConfig);
    }
    if (NULL != pwszCRLPeriodString)
    {
        LocalFree(pwszCRLPeriodString);
    }
    if (NULL != pwszCRLDeltaPeriodString)
    {
        LocalFree(pwszCRLDeltaPeriodString);
    }
    if (NULL != pwszCLSIDCertRequest)
    {
        CoTaskMemFree(pwszCLSIDCertRequest);
    }
    if (NULL != pwszzCRLPublicationValue)
    {
        LocalFree(pwszzCRLPublicationValue);
    }
    if (NULL != pwszzCACertPublicationValue)
    {
	LocalFree(pwszzCACertPublicationValue);
    }
    if (NULL != pwszzRequestExtensionList)
    {
        LocalFree(pwszzRequestExtensionList);
    }
    if (NULL != pwszzEnrolleeRequestExtensionList)
    {
        LocalFree(pwszzEnrolleeRequestExtensionList);
    }
    if (NULL != pwszzDisableExtensionList)
    {
        LocalFree(pwszzDisableExtensionList);
    }
    if (NULL != pwszzFilesNotToRestore)
    {
        LocalFree(pwszzFilesNotToRestore);
    }
    if (NULL != hKeyBase)
    {
        RegCloseKey(hKeyBase);
    }
    CSILOG(hr, IDS_LOG_CREATE_SERVER_REG, NULL, NULL, NULL);
    return(hr);
}


HRESULT
UpgradeRevocationURLReplaceParam(
	IN BOOL fPolicy,
    IN BOOL fMultiString,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszValueName)
{
    HRESULT hr;
    WCHAR *pwszzValue = NULL;
    WCHAR *pwsz;
    BOOL fModified = FALSE;

    CSASSERT(
        WSZARRAYSIZE(wszFCSAPARM_CERTFILENAMESUFFIX) ==
        WSZARRAYSIZE(wszFCSAPARM_CRLFILENAMESUFFIX));

    // getMultiStr will read REG_SZs as well and double-terminate
    hr = myGetCertRegMultiStrValue(
                            pwszSanitizedName,
                            fPolicy ? wszREGKEYPOLICYMODULES : wszREGKEYEXITMODULES,
                            fPolicy ? wszCLASS_CERTPOLICY : wszCLASS_CERTEXIT,
                            pwszValueName,
                            &pwszzValue);
    _JumpIfErrorStr2(hr, error, "myGetCertRegMultiStrValue", pwszValueName, hr);

    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        WCHAR *pwszT = pwsz;
        
	// Replace wszFCSAPARM_CERTFILENAMESUFFIX with
	// wszFCSAPARM_CRLFILENAMESUFFIX.  Beta 3's registry values incorrectly
	// used a Cert Suffix instead of CRL Suffix.

        for (;;)
        {
            DWORD i;
            
            pwszT = wcschr(pwszT, wszFCSAPARM_CERTFILENAMESUFFIX[0]);
            if (NULL == pwszT)
            {
                break;
            }
            for (i = 1; ; i++)
            {
                if (i == WSZARRAYSIZE(wszFCSAPARM_CERTFILENAMESUFFIX))
                {
                    CopyMemory(
                            pwszT,
                            wszFCSAPARM_CRLFILENAMESUFFIX,
                            i * sizeof(WCHAR));
                    pwszT += i;
                    fModified = TRUE;
                    break;
                }
                if (pwszT[i] != wszFCSAPARM_CERTFILENAMESUFFIX[i])
                {
                    pwszT++;
                    break;
                }
            }
        }
    }
    if (fModified)
    {
        if (fMultiString)
        {
            // set as REG_MULTI_SZ
            hr = mySetCertRegMultiStrValue(
                                    pwszSanitizedName,
                                    fPolicy ? wszREGKEYPOLICYMODULES : wszREGKEYEXITMODULES,
                                    fPolicy ? wszCLASS_CERTPOLICY : wszCLASS_CERTEXIT,
                                    pwszValueName,
                                    pwszzValue);
            _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValue", pwszValueName);
        }
        else
        {
            // set as REG_SZ
            hr = mySetCertRegStrValue(
                                    pwszSanitizedName,
                                    fPolicy ? wszREGKEYPOLICYMODULES : wszREGKEYEXITMODULES,
                                    fPolicy ? wszCLASS_CERTPOLICY : wszCLASS_CERTEXIT,
                                    pwszValueName,
                                    pwszzValue);
            _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", pwszValueName);
        }
    }

error:
    if (NULL != pwszzValue)
    {
        LocalFree(pwszzValue);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
UpgradeRevocationURLRemoveParam(
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszValueName)
{
    HRESULT hr;
    WCHAR *pwszValue = NULL;
    BOOL fModified = FALSE;
    WCHAR *pwszT;

    hr = myGetCertRegStrValue(
                        pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        wszCLASS_CERTPOLICY,
                        pwszValueName,
                        &pwszValue);
    _JumpIfErrorStr2(hr, error, "myGetCertRegStrValue", pwszValueName, hr);

    pwszT = pwszValue;
        
    // Remove wszFCSAPARM_CERTFILENAMESUFFIX from the Netscape Revocaton URL
    // It should never have been written out in Beta 3's registry value.

    for (;;)
    {
        DWORD i;
        
        pwszT = wcschr(pwszT, wszFCSAPARM_CERTFILENAMESUFFIX[0]);
        if (NULL == pwszT)
        {
            break;
        }
        for (i = 1; ; i++)
        {
            if (i == WSZARRAYSIZE(wszFCSAPARM_CERTFILENAMESUFFIX))
            {
                MoveMemory(
                        pwszT,
                        &pwszT[i],
                        (wcslen(&pwszT[i]) + 1) * sizeof(WCHAR));
                pwszT += i;
                fModified = TRUE;
                break;
            }
            if (pwszT[i] != wszFCSAPARM_CERTFILENAMESUFFIX[i])
            {
                pwszT++;
                break;
            }
        }
    }

    if (fModified)
    {
        hr = mySetCertRegStrValue(
                                pwszSanitizedName,
                                wszREGKEYPOLICYMODULES,
                                wszCLASS_CERTPOLICY,
                                pwszValueName,
                                pwszValue);
        _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", pwszValueName);
    }

error:
    if (NULL != pwszValue)
    {
        LocalFree(pwszValue);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


WCHAR const *apwszB3ExitEntriesToFix[] =
{
    wszREGLDAPREVOCATIONDNTEMPLATE_OLD,
    NULL
};

HRESULT
UpgradeCRLPath(
    WCHAR const *pwszSanitizedName)
{
    HRESULT  hr;
    WCHAR *pwszzCRLPath = NULL;
    WCHAR *pwszzFixedCRLPath = NULL;
    WCHAR *pwsz;
    BOOL   fRenewReady = TRUE;
    DWORD  dwSize = 0;

    // get current crl path
    hr = myGetCertRegMultiStrValue(
                        pwszSanitizedName,
                        NULL,
                        NULL,
                        wszREGCRLPATH_OLD,
                        &pwszzCRLPath);
    _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", wszREGCRLPATH_OLD);

    // to see if it is in renew ready format
    for (pwsz = pwszzCRLPath; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        dwSize += wcslen(pwsz) + 1;
        if (NULL == wcsstr(pwsz, wszFCSAPARM_CRLFILENAMESUFFIX))
        {
            // found one without suffix
            fRenewReady = FALSE;
            // add suffix len
            dwSize += WSZARRAYSIZE(wszFCSAPARM_CRLFILENAMESUFFIX);
        }
        if (NULL == wcsstr(pwsz, wszFCSAPARM_CRLDELTAFILENAMESUFFIX))
        {
            // found one without suffix
            fRenewReady = FALSE;
            // add suffix len
            dwSize += WSZARRAYSIZE(wszFCSAPARM_CRLDELTAFILENAMESUFFIX);
        }
    }

    if (!fRenewReady)
    {
        ++dwSize; // multi string
        // at least one of crl path missed suffix
        pwszzFixedCRLPath = (WCHAR*)LocalAlloc(LMEM_FIXED,
                                               dwSize * sizeof(WCHAR));
        _JumpIfOutOfMemory(hr, error, pwszzFixedCRLPath);

        WCHAR *pwszPt = pwszzFixedCRLPath;
        for (pwsz = pwszzCRLPath; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
        {
            BOOL fCRLFileName;
            BOOL fCRLDeltaSuffix;
	    
	    // copy over whole path 1st
            wcscpy(pwszPt, pwsz);

            fCRLFileName = NULL != wcsstr(pwszPt, wszFCSAPARM_CRLFILENAMESUFFIX);
            fCRLDeltaSuffix = NULL != wcsstr(pwszPt, wszFCSAPARM_CRLDELTAFILENAMESUFFIX);

            if (!fCRLFileName || !fCRLDeltaSuffix)
            {
                // miss suffix, find file portion
                WCHAR *pwszFile = wcsrchr(pwszPt, L'\\');
                if (NULL == pwszFile)
                {
                    // may be relative path, point to begin
                    pwszFile = pwszPt;
                }
                // find crl extension portion
                WCHAR *pwszCRLExt = wcsrchr(pwszFile, L'.');
                if (NULL != pwszCRLExt)
                {
		    *pwszCRLExt = L'\0';
		    if (!fCRLFileName)
		    {
			wcscat(pwszCRLExt, wszFCSAPARM_CRLFILENAMESUFFIX);
		    }
		    if (!fCRLDeltaSuffix)
		    {
			wcscat(pwszPt, wszFCSAPARM_CRLDELTAFILENAMESUFFIX);
		    }
                    // add extension portion from original buffer
                    wcscat(pwszCRLExt,
                           pwsz + SAFE_SUBTRACT_POINTERS(pwszCRLExt, pwszPt));
                }
                else
                {
                    // no crl file extension, append suffix at end
		    if (!fCRLFileName)
		    {
			wcscat(pwszPt, wszFCSAPARM_CRLFILENAMESUFFIX);
		    }
		    if (!fCRLDeltaSuffix)
		    {
			wcscat(pwszPt, wszFCSAPARM_CRLDELTAFILENAMESUFFIX);
		    }
                }
            }
            // update pointer
            pwszPt += wcslen(pwszPt) + 1;
        }
        // mutil string
        *pwszPt = L'\0';
        CSASSERT(dwSize == SAFE_SUBTRACT_POINTERS(pwszPt, pwszzFixedCRLPath) + 1);

        // reset crl path with the fixed crl path
        hr = mySetCertRegMultiStrValue(
                            pwszSanitizedName,
                            NULL,
                            NULL,
                            wszREGCRLPATH_OLD,
                            pwszzFixedCRLPath);
        _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValue", wszREGCRLPATH_OLD);
    }

    hr = S_OK;
error:
    if (NULL != pwszzCRLPath)
    {
        LocalFree(pwszzCRLPath);
    }
    if (NULL != pwszzFixedCRLPath)
    {
        LocalFree(pwszzFixedCRLPath);
    }
    return hr;
}


HRESULT
MergeCRLPath(
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr;
    WCHAR *pwszzCRLPath = NULL;
    WCHAR *pwszzFixedCRLPath = NULL;
    WCHAR *pwsz;
    DWORD cwc;
    WCHAR awcPrefix[cwcDWORDSPRINTF + 1];
    DWORD cwcPrefix;

    // get current crl path
    hr = myGetCertRegMultiStrValue(
                        pwszSanitizedName,
                        NULL,
                        NULL,
                        wszREGCRLPATH_OLD,
                        &pwszzCRLPath);
    _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", wszREGCRLPATH_OLD);

    wsprintf(
	awcPrefix,
	wszURLPREFIXFORMAT,
	CSURL_SERVERPUBLISH | CSURL_SERVERPUBLISHDELTA);
    cwcPrefix = wcslen(awcPrefix);

    cwc = 1;
    for (pwsz = pwszzCRLPath; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        cwc += cwcPrefix + wcslen(pwsz) + 1;
    }
    if (1 < cwc)
    {
        WCHAR *pwszT;

        pwszzFixedCRLPath = (WCHAR *) LocalAlloc(
					    LMEM_FIXED,
					    cwc * sizeof(WCHAR));
        _JumpIfOutOfMemory(hr, error, pwszzFixedCRLPath);

        pwszT = pwszzFixedCRLPath;
        for (pwsz = pwszzCRLPath; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
        {
            wcscpy(pwszT, awcPrefix);
            wcscat(pwszT, pwsz);
            pwszT += wcslen(pwszT) + 1;
        }
        *pwszT = L'\0';
        CSASSERT(cwc == SAFE_SUBTRACT_POINTERS(pwszT, pwszzFixedCRLPath) + 1);

	hr = mySetCertRegMultiStrValueEx(
		    CSREG_UPGRADE | CSREG_MERGE,
		    pwszSanitizedName,
		    NULL,
		    NULL,
		    wszREGCRLPUBLICATIONURLS,
		    pwszzFixedCRLPath);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "mySetCertRegMultiStrValue",
		    wszREGCRLPUBLICATIONURLS);

	hr = myDeleteCertRegValue(
				pwszSanitizedName,
				NULL,
				NULL,
				wszREGCRLPATH_OLD);
	_PrintIfErrorStr(hr, "myGetCertRegMultiStrValue", wszREGCRLPATH_OLD);
    }
    hr = S_OK;

error:
    if (NULL != pwszzCRLPath)
    {
        LocalFree(pwszzCRLPath);
    }
    if (NULL != pwszzFixedCRLPath)
    {
        LocalFree(pwszzFixedCRLPath);
    }
    return(hr);
}


typedef struct _URLPREFIXSTRUCT
{
    WCHAR const *pwszURLPrefix;
    DWORD        dwURLFlags;
} URLPREFIXSTRUCT;

//array of cdp url type and its default usage which is prefix of url
URLPREFIXSTRUCT aCDPURLPrefixList[] =
{
    {L"file:", CSURL_ADDTOCERTCDP | CSURL_ADDTOFRESHESTCRL },

    {L"http:", CSURL_ADDTOCERTCDP | CSURL_ADDTOFRESHESTCRL },

    {L"ldap:", CSURL_SERVERPUBLISH | CSURL_SERVERPUBLISHDELTA | CSURL_ADDTOCERTCDP | CSURL_ADDTOFRESHESTCRL | CSURL_ADDTOCRLCDP},

    {NULL, 0}
};

//array of aia url type and its default usage which is prefix of url
URLPREFIXSTRUCT aAIAURLPrefixList[] =
{
    {L"file:", CSURL_ADDTOCERTCDP},

    {L"http:", CSURL_ADDTOCERTCDP},

    {L"ldap:", CSURL_ADDTOCERTCDP | CSURL_SERVERPUBLISH},

    {NULL, 0}
};


//pass an old url, determine what is prefix in a format of "XX:"
HRESULT
DetermineURLPrefixFlags(
    IN BOOL         fDisabled,
    IN BOOL         fCDP,
    IN WCHAR const *pwszURL,
    IN WCHAR       *pwszPrefixFlags)
{
    HRESULT hr;
    URLPREFIXSTRUCT *pURLPrefix;
    DWORD dwPathFlags;
    WCHAR *pwszT;
    WCHAR *pwszLower = NULL;
    DWORD dwPrefixFlags = 0;	 // default to disable

    if (myIsFullPath(pwszURL, &dwPathFlags))
    {
        //local path, easy
	dwPrefixFlags = fCDP? 
			    (CSURL_SERVERPUBLISH | CSURL_SERVERPUBLISHDELTA) :
			    CSURL_SERVERPUBLISH;
        goto done;
    }

    //make lower case url string
    pwszLower = (WCHAR*)LocalAlloc(LMEM_FIXED,
                            (wcslen(pwszURL) + 1) * sizeof(WCHAR));
    if (NULL == pwszLower)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszLower, pwszURL);
    CharLower(pwszLower);

    //loop through to find out url type
    for (pURLPrefix = fCDP ? aCDPURLPrefixList : aAIAURLPrefixList;
         NULL != pURLPrefix->pwszURLPrefix; ++pURLPrefix)
    {
        pwszT = wcsstr(pwszLower, pURLPrefix->pwszURLPrefix);
        if (0 == _wcsnicmp(pwszLower, pURLPrefix->pwszURLPrefix,
                         wcslen(pURLPrefix->pwszURLPrefix)))
        {
	    dwPrefixFlags = pURLPrefix->dwURLFlags;
            goto done;
        }
    }
    // if nothing matches, keep 0 flag

done:
    if (fDisabled)
    {
	if (fCDP)
	{
	    dwPrefixFlags &= CSURL_ADDTOCRLCDP;
	}
	else
	{
	    dwPrefixFlags = 0;
	}
    }
    wsprintf(pwszPrefixFlags, wszURLPREFIXFORMAT, dwPrefixFlags);
    hr = S_OK;

error:
    if (NULL != pwszLower)
    {
        LocalFree(pwszLower);
    }
    return hr;
}

//move old cdp or aia url from policy to a new location under ca
HRESULT
UpgradeMoveURLsLocation(
    IN BOOL fCDP,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszValueName,
    IN DWORD dwEnableFlagsBits)
{
    HRESULT hr;
    WCHAR *pwszzValue = NULL;
    WCHAR *pwszzURLs = NULL;
    BOOL   fDisabled;
    DWORD  cURLs = 0;  //count of url from multi_sz
    DWORD  dwLen = 0;
    DWORD  dwSize = 0; //total size of chars in multi_sz url exluding '-'
    WCHAR *pwsz;
    WCHAR *pwszT;
    WCHAR *pwszNoMinus;
    WCHAR wszPrefixFlags[cwcDWORDSPRINTF + 1];
    DWORD dwRegFlags;

    // get urls in the old location
    hr = myGetCertRegMultiStrValue(
                            pwszSanitizedName,
                            wszREGKEYPOLICYMODULES,
                            wszCLASS_CERTPOLICY,
                            pwszValueName,
                            &pwszzValue);
    _JumpIfErrorStr2(hr, error, "myGetCertRegMultiStrValue", pwszValueName, hr);

    hr = myGetCertRegDWValue(
                    pwszSanitizedName,
                    wszREGKEYPOLICYMODULES,
                    wszCLASS_CERTPOLICY,
                    fCDP? wszREGREVOCATIONTYPE : wszREGISSUERCERTURLFLAGS,
                    &dwRegFlags);
    if (S_OK != hr)
    {
	dwRegFlags = MAXDWORD;	// Enable all URL types
    }

    // fix "-" prefix for disable and count size
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += dwLen)
    {
        //current url length
        dwLen = wcslen(pwsz) + 1;
        //update size
        dwSize += dwLen;
        ++cURLs;

        pwszNoMinus = pwsz;
        while (L'-' == *pwszNoMinus)
        {
            //exclude prefix '-'s
            --dwSize;
            ++pwszNoMinus;
        }
    }

    //allocate buffer in "XX:URL" format
    pwszzURLs = (WCHAR*)LocalAlloc(LMEM_FIXED,
        (dwSize + cURLs * ARRAYSIZE(wszPrefixFlags) + 1) * sizeof(WCHAR));
    if (NULL == pwszzURLs)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    pwszT = pwszzURLs;
    //form string in new url format
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        fDisabled = FALSE;
        pwszNoMinus = pwsz;
        while (L'-' == *pwszNoMinus)
        {
            //exclude prefix '-'s
            ++pwszNoMinus;
            fDisabled = !fDisabled;
        }
	if ((dwEnableFlagsBits & dwRegFlags) != dwEnableFlagsBits)
	{
            fDisabled = TRUE;
	}
        hr = DetermineURLPrefixFlags(fDisabled, fCDP, pwszNoMinus, wszPrefixFlags);
        _JumpIfErrorStr(hr, error, "DetermineURLPrefixFlags", pwszNoMinus);

        //format "xx:url"
        wcscpy(pwszT, wszPrefixFlags);
        wcscat(pwszT, pwszNoMinus);
        //ready for next url
        pwszT += wcslen(pwszT) + 1;
    }
    //zz
    *pwszT = L'\0';

    pwszT = fCDP ? wszREGCRLPUBLICATIONURLS : wszREGCACERTPUBLICATIONURLS,
    //move or merge to ca
    hr = mySetCertRegMultiStrValueEx(
                CSREG_UPGRADE | CSREG_MERGE,
                pwszSanitizedName,
                NULL,
                NULL,
                pwszT,
                pwszzURLs);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValue", pwszT);

    //remove url under policy
    hr = myDeleteCertRegValue(
                            pwszSanitizedName,
                            wszREGKEYPOLICYMODULES,
                            wszCLASS_CERTPOLICY,
                            pwszValueName);
    _PrintIfErrorStr(hr, "myGetCertRegMultiStrValue", pwszValueName);

    hr = S_OK;
error:
    if (NULL != pwszzValue)
    {
        LocalFree(pwszzValue);
    }
    if (NULL != pwszzURLs)
    {
        LocalFree(pwszzURLs);
    }
    return(hr);
}


// Order MUST be the same as adwPolicyCDPEntriesToFix
WCHAR const *apwszPolicyCDPEntriesToFix[] =
{
    wszREGLDAPREVOCATIONCRLURL_OLD, //"LDAPRevocationCRLURL"
    wszREGREVOCATIONCRLURL_OLD,     //"RevocationCRLURL"
    wszREGFTPREVOCATIONCRLURL_OLD,  //"FTPRevocationCRLURL"
    wszREGFILEREVOCATIONCRLURL_OLD, //"FileRevocationCRLURL"
    NULL
};


// Order MUST be the same as apwszPolicyCDPEntriesToFix
DWORD adwPolicyCDPEntriesToFix[] =
{
    REVEXT_CDPLDAPURL_OLD,
    REVEXT_CDPHTTPURL_OLD,
    REVEXT_CDPFTPURL_OLD,
    REVEXT_CDPFILEURL_OLD,
    0
};


HRESULT
myPrintIfError(
    IN HRESULT               hrNew,
    IN HRESULT               hrOld,
    IN CHAR const           *DBGCODE(psz),
    IN OPTIONAL WCHAR const *pwsz)
{
    if (S_OK != hrNew)
    {
        if (NULL != pwsz)
        {
            _PrintErrorStr(hrNew, psz, pwsz);
        }
        else
        {
            _PrintError(hrNew, psz);
        }
        if (S_OK == hrOld)
        {
            //save only oldest err
            hrOld = hrNew;
        }
    }
    return hrOld;
}

// This function only replaces suffixes!!!
HRESULT ReplaceStringsInURLs(
    LPCWSTR pcwszSanitizedName,
    LPCWSTR pcwszRegEntry,
    LPCWSTR pcwszReplaced,
    LPCWSTR pcwszReplacement)
{
    HRESULT hr;
    LPWSTR pOrig = NULL;
    void * pMod = NULL;
    DWORD dwLen;
    CMultiSz szzValue;
    
    hr = myGetCertRegMultiStrValue(
        pcwszSanitizedName,
        NULL,
        NULL,
        pcwszRegEntry,
        &pOrig);
    _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", pcwszRegEntry);

    hr = szzValue.Unmarshal(pOrig);
    _JumpIfError(hr, error, "CMultiSz::Unmarshal");
    
    if (!szzValue.IsEmpty())
    {
        // walk through the list and replace
        CMultiSzEnum szzValueEnum(szzValue);
        CString *pStr;

        for(pStr = szzValueEnum.Next();
            pStr;
            pStr = szzValueEnum.Next())
        {
            WCHAR *pchFound = wcsstr((LPCWSTR)*pStr, pcwszReplaced);

            if(pchFound)
            {
                DBGPRINT((DBG_SS_CERTOCMI, 
                    "Inserting %9 in %s", (LPCWSTR)*pStr));
                LPWSTR pwszOld = pStr->Detach();
                *pchFound = L'\0';
                *pStr = pwszOld;
                *pStr += pcwszReplacement;
                LocalFree(pwszOld);
            }
        }

        hr = szzValue.Marshal(pMod, dwLen);
        _JumpIfError(hr, error, "CMultiSz::Marshal");

        hr = mySetCertRegMultiStrValue(
            pcwszSanitizedName,
            NULL,
            NULL,
            pcwszRegEntry,
            (LPCWSTR)pMod);
        _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValue", pcwszRegEntry);
    }

error:
    LOCAL_FREE(pOrig);
    LOCAL_FREE(pMod);
    return hr;
}


HRESULT
UpgradePolicyCDPURLs(
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    WCHAR const **ppwsz;
    DWORD const *pdw;

    pdw = adwPolicyCDPEntriesToFix;
    for (ppwsz = apwszPolicyCDPEntriesToFix; NULL != *ppwsz; ppwsz++, pdw++)
    {
        // all entries are multi-valued
        hr2 = UpgradeRevocationURLReplaceParam(
				    TRUE,
				    TRUE,
				    pwszSanitizedName,
				    *ppwsz);
        hr = myPrintIfError(hr2, hr, "UpgradeRevocationURLReplaceParam", *ppwsz);

        hr2 = UpgradeMoveURLsLocation(
				TRUE,
				pwszSanitizedName,
				*ppwsz,
				REVEXT_CDPENABLE | *pdw);
        hr = myPrintIfError(hr2, hr, "UpgradeMoveURLsLocation", *ppwsz);
    }

    hr2 = UpgradeRevocationURLRemoveParam(pwszSanitizedName, wszREGREVOCATIONURL);
    hr = myPrintIfError(hr2, hr, "UpgradeRevocationURLRemoveParam", wszREGREVOCATIONURL);
    hr2 = UpgradeCRLPath(pwszSanitizedName);
    hr = myPrintIfError(hr2, hr, "UpgradeCRLPath", NULL);

    hr2 = MergeCRLPath(pwszSanitizedName);
    hr = myPrintIfError(hr2, hr, "MergeCRLPath", NULL);

    {
        // bug 446444: replace CDP attributes in LDAP format strings:
        // ?certificateRevocationList?base?objectclass=cRLDistributionPoint -> %10

        LPCWSTR pcwszReplacedCDPString = 
            L"?certificateRevocationList?base?objectclass=cRLDistributionPoint";
        LPCWSTR pcwszReplacementCDPString = 
            L"%10";

        hr2 = ReplaceStringsInURLs(
            pwszSanitizedName,
            wszREGCRLPUBLICATIONURLS,
            pcwszReplacedCDPString,
            pcwszReplacementCDPString);
        hr = myPrintIfError(hr2, hr, "ReplaceStringsInURLs", NULL);
    }

    {
        // bug 450583: insert %9 after %8 in "...%8.crl"
        // ?certificateRevocationList?base?objectclass=cRLDistributionPoint -> %10

        LPCWSTR pcwszReplacedCDPString = 
            L"%8.crl";
        LPCWSTR pcwszReplacementCDPString = 
            L"%8%9.crl";

        hr2 = ReplaceStringsInURLs(
            pwszSanitizedName,
            wszREGCRLPUBLICATIONURLS,
            pcwszReplacedCDPString,
            pcwszReplacementCDPString);
        hr = myPrintIfError(hr2, hr, "ReplaceStringsInURLs", NULL);
    }

    return(hr);
}


// Order MUST be the same as adwPolicyAIAEntriesToFix
WCHAR const *apwszPolicyAIAEntriesToFix[] =
{
    wszREGLDAPISSUERCERTURL_OLD, //"LDAPIssuerCertURL"
    wszREGISSUERCERTURL_OLD,     //"IssuerCertURL"
    wszREGFTPISSUERCERTURL_OLD,  //"FTPIssuerCertURL"
    wszREGFILEISSUERCERTURL_OLD, //"FileIssuerCertURL"
    NULL
};


// Order MUST be the same as apwszPolicyAIAEntriesToFix
DWORD adwPolicyAIAEntriesToFix[] =
{
    ISSCERT_LDAPURL_OLD,
    ISSCERT_HTTPURL_OLD,
    ISSCERT_FTPURL_OLD,
    ISSCERT_FILEURL_OLD,
    0
};


HRESULT
UpgradePolicyAIAURLs(
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    WCHAR const **ppwsz;
    DWORD const *pdw;

    pdw = adwPolicyAIAEntriesToFix;
    for (ppwsz = apwszPolicyAIAEntriesToFix; NULL != *ppwsz; ppwsz++, pdw++)
    {
        // all entries are multi-valued
        hr2 = UpgradeMoveURLsLocation(
				FALSE,
				pwszSanitizedName,
				*ppwsz,
				ISSCERT_ENABLE | *pdw);
        hr = myPrintIfError(hr2, hr, "UpgradeMoveURLsLocation", *ppwsz);
    }

    {
        // bug 446444: replace AIA attributes in LDAP format strings:
        // ?cACertificate?base?objectclass=certificationAuthority -> %11

        LPCWSTR pcwszReplacedCDPString = 
            L"?cACertificate?base?objectclass=certificationAuthority";
        LPCWSTR pcwszReplacementCDPString = 
            L"%11";

        hr2 = ReplaceStringsInURLs(
            pwszSanitizedName,
            wszREGCACERTPUBLICATIONURLS,
            pcwszReplacedCDPString,
            pcwszReplacementCDPString);
        hr = myPrintIfError(hr2, hr, "ReplaceStringsInURLs", NULL);
    }

    return(hr);
}

HRESULT
UpgradeExitRevocationURLs(
    IN WCHAR const *pwszSanitizedName)
{
    WCHAR const **ppwsz;

    for (ppwsz = apwszB3ExitEntriesToFix; NULL != *ppwsz; ppwsz++)
    {
        // all entries are single-valued
        UpgradeRevocationURLReplaceParam(FALSE, FALSE, pwszSanitizedName, *ppwsz);
    }
    return(S_OK);
}


// following code to determine if current policy/exit modules are custom
// if find any custom module and assign it to
// pServer->pwszCustomPolicy/Exit
// otherwise pServer->pwszCustomPolicy/Exit = NULL means default as active

#define wszCERTSRV10POLICYPROGID  L"CertificateAuthority.Policy"
#define wszCERTSRV10EXITPROGID    L"CertificateAuthority.Exit"
#define wszCLSID                  L"ClsID\\"
#define wszINPROCSERVER32         L"\\InprocServer32"

HRESULT
DetermineServerCustomModule(
    PER_COMPONENT_DATA *pComp,
    IN BOOL  fPolicy)
{
    HRESULT  hr;
    CASERVERSETUPINFO  *pServer = pComp->CA.pServer;

    // init
    if (fPolicy)
    {
        if (NULL != pServer->pwszCustomPolicy)
        {
            LocalFree(pServer->pwszCustomPolicy);
            pServer->pwszCustomPolicy = NULL;
        }
    }
    else
    {
        if (NULL != pServer->pwszzCustomExit)
        {
            LocalFree(pServer->pwszzCustomExit);
            pServer->pwszzCustomExit = NULL;
        }
    }

    // build to build
    // to pass what is the current active policy
    if (fPolicy)
    {
        // policy module
        hr = myGetCertRegStrValue(
                    pServer->pwszSanitizedName,
                    wszREGKEYPOLICYMODULES,
                    NULL,
                    wszREGACTIVE,
                    &pServer->pwszCustomPolicy);
        _JumpIfError(hr, done, "myGetCertRegStrValue");
    }
    else
    {
        // exit module
        hr = myGetCertRegMultiStrValue(
                    pServer->pwszSanitizedName,
                    wszREGKEYEXITMODULES,
                    NULL,
                    wszREGACTIVE,
                    &pServer->pwszzCustomExit);
        _JumpIfError(hr, done, "myGetCertRegStrValue");
    }


done:
    hr = S_OK;

//error:

    return hr;
}

HRESULT
UpgradeServerRegEntries(
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CASERVERSETUPINFO  *pServer = pComp->CA.pServer;
    WCHAR   *pwszCRLPeriodString = NULL;
    DWORD    Count;

    CSASSERT(
        NULL != pServer->pwszSanitizedName &&
        NULL != pServer->pccUpgradeCert);

    // Description:
    // - if upgrade and get this point, all necessary data structure
    //   should be loaded and created in LoadAndDetermineServerUpgradeInfo()
    // - in this module, check all different upgrade cases,
    //   upgrade (move) reg entries
    // - remove old unused reg entries if upgrade
    //   Note: each of above steps applys from config level down to ca then
    //         to policy, etc.
    // - lastly call CreateServerRegEntries with upgrade flag

    // CONFIGURATION LEVEL


    // CA LEVEL
    hr = myGetCARegHashCount(
			pServer->pwszSanitizedName,
			CSRH_CASIGCERT,
			&Count);
    _JumpIfError(hr, error, "myGetCARegHashCount");

    if (0 == Count)
    {
	    hr = mySetCARegHash(
			    pServer->pwszSanitizedName,
			    CSRH_CASIGCERT,
			    0,	// iCert
			    pServer->pccUpgradeCert);
	    _JumpIfError(hr, error, "mySetCARegHash");
    }

    // bug 446444: add ENUM_TELETEXT_UTF8 on upgrade

    {
    DWORD dwForceTeletex;
    hr = myGetCertRegDWValue(
        pServer->pwszSanitizedName,
        NULL,
        NULL,
        wszREGFORCETELETEX,
        (DWORD *) &dwForceTeletex);
    if(S_OK==hr)
    {
        dwForceTeletex |= ENUM_TELETEX_UTF8;

        hr = mySetCertRegDWValue(
            pServer->pwszSanitizedName,
            NULL,
            NULL,
            wszREGFORCETELETEX,
            dwForceTeletex);
        _JumpIfErrorStr(hr, error, "mySetCertRegDWValue", wszREGFORCETELETEX);
    }
    }


    // POLICY LEVEL

    {
        //could fix two things, 1) W2K from B3 needs fixing token plus 2) or
        //                      2) W2K needs fix CDP location

        hr = UpgradePolicyCDPURLs(pServer->pwszSanitizedName);
        _PrintIfError(hr, "UpgradePolicyCDPURLs");

        hr = UpgradePolicyAIAURLs(pServer->pwszSanitizedName);
        _PrintIfError(hr, "UpgradePolicyAIAURLs");

        hr = UpgradeExitRevocationURLs(pServer->pwszSanitizedName);
        _PrintIfError(hr, "UpgradeExitRevocationURLs");

        //UNDONE, we need move url for cdp and aia under policy to ca level
    }


    // EXIT LEVEL

    // DELETE OLD AND UNUSED ENTRIES
        
    hr = CreateServerRegEntries(TRUE, pComp);
    _JumpIfError(hr, error, "CreateServerRegEntries");

//    hr = S_OK;
error:
    if (NULL != pwszCRLPeriodString)
    {
        LocalFree(pwszCRLPeriodString);
    }
    CSILOG(hr, IDS_LOG_UPGRADE_SERVER_REG, NULL, NULL, NULL);
    return(hr);
}


HRESULT
RegisterAndUnRegisterDLLs(
    IN DWORD Flags,
    IN PER_COMPONENT_DATA *pComp,
    IN HWND hwnd)
{
    HRESULT hr;
    HMODULE hMod = NULL;
    typedef HRESULT (STDAPICALLTYPE FNDLLREGISTERSERVER)(VOID);
    FNDLLREGISTERSERVER *pfnRegister;
    CHAR const *pszFuncName;
    REGISTERDLL const *prd;
    WCHAR wszString[MAX_PATH];
    UINT errmode = 0;
    BOOL fCoInit = FALSE;

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    errmode = SetErrorMode(SEM_FAILCRITICALERRORS);
    pszFuncName = 0 == (RD_UNREGISTER & Flags)?
                        aszRegisterServer[0] : aszRegisterServer[1];

    for (prd = g_aRegisterDll; NULL != prd->pwszDllName; prd++)
    {
        if ((Flags & RD_UNREGISTER) &&
            ((Flags & RD_SKIPUNREGPOLICY) && (prd->Flags & RD_SKIPUNREGPOLICY) ||
             (Flags & RD_SKIPUNREGEXIT) && (prd->Flags & RD_SKIPUNREGEXIT)))
        {
            // case of upgrade path & this dll doesn't want to unreg
            continue;
        }

        if (Flags & prd->Flags)
        {
            if (NULL != g_pwszArgvPath)
            {
                wcscpy(wszString, g_pwszArgvPath);
                if (L'\0' != wszString[0] &&
                    L'\\' != wszString[wcslen(wszString) - 1])
                {
                    wcscat(wszString, L"\\");
                }
            }
            else
            {
                wcscpy(wszString, pComp->pwszSystem32);
            }
            wcscat(wszString, prd->pwszDllName);

            hMod = LoadLibrary(wszString);
            if (NULL == hMod)
            {
                hr = myHLastError();
                if (0 == (RD_UNREGISTER & Flags) &&
                    (!(RD_WHISTLER & prd->Flags) || IsWhistler()))
                {
		    SaveCustomMessage(pComp, wszString);
                    CertErrorMessageBox(
                                    pComp->hInstance,
                                    pComp->fUnattended,
                                    hwnd,
                                    IDS_ERR_DLLFUNCTION_CALL,
                                    hr,
                                    wszString);
		    CSILOG(hr, IDS_LOG_DLLS_REGISTERED, wszString, NULL, NULL);
                    _JumpErrorStr(hr, error, "LoadLibrary", wszString);
                }
                hr = S_OK;
                continue;
            }

            pfnRegister = (FNDLLREGISTERSERVER *) GetProcAddress(
                                                            hMod,
                                                            pszFuncName);
            if (NULL == pfnRegister)
            {
                hr = myHLastError();
                _JumpErrorStr(hr, error, "GetProcAddress", wszString);
            }

            __try
            {
                hr = (*pfnRegister)();
            }
            __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
            {
            }

            FreeLibrary(hMod);
            hMod = NULL;

            if (S_OK != hr)
            {
		CSILOG(
		    hr,
		    (RD_UNREGISTER & Flags)?
			IDS_LOG_DLLS_UNREGISTERED : IDS_LOG_DLLS_REGISTERED,
		    wszString,
		    NULL,
		    NULL);
                if (0 == (RD_UNREGISTER & Flags))
                {
                    CertErrorMessageBox(
                                    pComp->hInstance,
                                    pComp->fUnattended,
                                    hwnd,
                                    IDS_ERR_DLLFUNCTION_CALL,
                                    hr,
                                    wszString);
                    _JumpErrorStr(hr, error, "DllRegisterServer", wszString);
                }
                else
                {
                    _PrintErrorStr(hr, "DllUnregisterServer", wszString);
                }
            }
        }
    }
    hr = S_OK;

error:
    if (NULL != hMod)
    {
        FreeLibrary(hMod);
    }
    SetErrorMode(errmode);
    if (fCoInit)
    {
        CoUninitialize();
    }
    if (S_OK == hr)
    {
	CSILOG(
	    hr,
	    (RD_UNREGISTER & Flags)?
		IDS_LOG_DLLS_UNREGISTERED : IDS_LOG_DLLS_REGISTERED,
	    NULL,
	    NULL,
	    NULL);
    }
    return(hr);
}


HRESULT
CreateProgramGroups(
    BOOL fClient,
    PER_COMPONENT_DATA *pComp,
    HWND hwnd)
{
    HRESULT hr;
    PROGRAMENTRY const *ppe;
    WCHAR const *pwszLinkName = NULL;
    DWORD Flags = fClient? PE_CLIENT : PE_SERVER;

    DBGPRINT((
        DBG_SS_CERTOCMI,
        "CreateProgramGroups: %ws\n",
        fClient? L"Client" : L"Server"));

    for (ppe = g_aProgramEntry; ppe < &g_aProgramEntry[CPROGRAMENTRY]; ppe++)
    {
        if ((Flags & ppe->Flags) && 0 == (PE_DELETEONLY & ppe->Flags))
        {
            WCHAR const *pwszGroupName;
            WCHAR const *pwszDescription;
            WCHAR awc[MAX_PATH];
            WCHAR const *pwszArgs;

            wcscpy(awc, pComp->pwszSystem32);
            wcscat(awc, ppe->pwszExeName);
            pwszArgs = fClient? ppe->pwszClientArgs : ppe->pwszServerArgs;
            if (NULL != pwszArgs)
            {
                wcscat(awc, L" ");
                wcscat(awc, pwszArgs);
            }

            pwszLinkName = myLoadResourceString(ppe->uiLinkName);
            if (NULL == pwszLinkName)
            {
                hr = myHLastError();
                _JumpError(hr, error, "myLoadResourceString");
            }

            pwszGroupName = NULL;
            if (0 != ppe->uiGroupName)
            {
                pwszGroupName = myLoadResourceString(ppe->uiGroupName);
                if (NULL == pwszGroupName)
                {
                    hr = myHLastError();
                    _JumpError(hr, error, "myLoadResourceString");
                }
            }

            pwszDescription = NULL;
            if (0 != ppe->uiDescription)
            {
                pwszDescription = myLoadResourceString(ppe->uiDescription);
                if (NULL == pwszDescription)
                {
                    hr = myHLastError();
                    _JumpError(hr, error, "myLoadResourceString");
                }
            }

	    if (!CreateLinkFile(
			ppe->csidl,         // CSIDL_*
			pwszGroupName,      // IN LPCSTR lpSubDirectory
			pwszLinkName,       // IN LPCSTR lpFileName
			awc,                // IN LPCSTR lpCommandLine
			NULL,               // IN LPCSTR lpIconPath
			0,                  // IN INT    iIconIndex
			NULL,               // IN LPCSTR lpWorkingDirectory
			0,                  // IN WORD   wHotKey
			SW_SHOWNORMAL,      // IN INT    iShowCmd
			pwszDescription))           // IN LPCSTR lpDescription
	    {
		hr = myHLastError();
		_PrintErrorStr(hr, "CreateLinkFile", awc);
		_JumpErrorStr(hr, error, "CreateLinkFile", pwszLinkName);
            }
        }
    }

    hr = S_OK;
error:
    if (S_OK != hr)
    {
        CertErrorMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hwnd,
                        IDS_ERR_CREATELINK,
                        hr,
                        pwszLinkName);
        pComp->fShownErr = TRUE;
    }
    CSILOG(hr, IDS_LOG_PROGRAM_GROUPS, NULL, NULL, NULL);
    return(hr);
}


HRESULT
MakeRevocationPage(
    PER_COMPONENT_DATA *pComp,
    IN WCHAR const *pwszFile)
{
    HRESULT hr;
    WCHAR *pwszASP = NULL;
    WCHAR *pwszConfig = NULL;
    HANDLE hFile = NULL;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

#define wszASP1 \
    L"<%\r\n" \
    L"Response.ContentType = \"application/x-netscape-revocation\"\r\n" \
    L"serialnumber = Request.QueryString\r\n" \
    L"set Admin = Server.CreateObject(\"CertificateAuthority.Admin\")\r\n" \
    L"\r\n" \
    L"stat = Admin.IsValidCertificate(\""

#define wszASP2 \
    L"\", serialnumber)\r\n" \
    L"\r\n" \
    L"if stat = 3 then Response.Write(\"0\") else Response.Write(\"1\") end if\r\n" \
    L"%>\r\n"

    hr = myFormConfigString(pComp->pwszServerName,
                            pServer->pwszSanitizedName,
                            &pwszConfig);
    _JumpIfError(hr, error, "myFormConfigString");

    pwszASP = (WCHAR *) LocalAlloc(
                            LMEM_FIXED,
                            (WSZARRAYSIZE(wszASP1) +
                             wcslen(pwszConfig) +
                             WSZARRAYSIZE(wszASP2) + 1) * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pwszASP);

    wcscpy(pwszASP, wszASP1);
    wcscat(pwszASP, pwszConfig);
    wcscat(pwszASP, wszASP2);

    hFile = CreateFile(
                    pwszFile,           // lpFileName
                    GENERIC_WRITE,      // dwDesiredAccess
                    0,                  // dwShareMode
                    NULL,               // lpSecurityAttributes
                    CREATE_ALWAYS,      // dwCreationDisposition
                    0,                  // dwFlagsAndAttributes
                    0);                 // hTemplateFile
    if (INVALID_HANDLE_VALUE == hFile)
    {
       hr = HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
       _JumpError(hr, error, "CreateFile");
    }
    hr = myStringToAnsiFile(hFile, pwszASP, MAXDWORD);

error:
    if (hFile)
        CloseHandle(hFile);

    if (NULL != pwszASP)
    {
        LocalFree(pwszASP);
    }
    if (NULL != pwszConfig)
    {
        LocalFree(pwszConfig);
    }
    return(hr);
}


VOID
setupDeleteFile(
    IN WCHAR const *pwszDir,
    IN WCHAR const *pwszFile)
{
    HRESULT hr;
    WCHAR *pwszFilePath = NULL;

    hr = myBuildPathAndExt(pwszDir, pwszFile, NULL, &pwszFilePath);
    _JumpIfError(hr, error, "myBuildPathAndExt");
    
    if (!DeleteFile(pwszFilePath))
    {
        hr = myHLastError();
        _PrintErrorStr2(hr, "DeleteFile", pwszFilePath, hr);
    }

error:
    if (NULL != pwszFilePath)
    {
       LocalFree(pwszFilePath);
    }
}


//+------------------------------------------------------------------------
//  Function:   RenameMiscTargets(. . . .)
//
//  Synopsis:   Handles various renaming jobs from the names that things
//              are given at installation time to the names that they need
//              in their new homes to run properly.
//
//  Arguments:  None
//
//  Returns:    DWORD error code.
//
//  History:    3/21/97 JerryK  Created
//-------------------------------------------------------------------------

HRESULT
RenameMiscTargets(
    HWND hwnd,
    PER_COMPONENT_DATA *pComp,
    BOOL fServer)
{
    HRESULT hr = S_OK;
    WCHAR wszAspPath[MAX_PATH]; wszAspPath[0] = L'\0';
    WCHAR wszCertSrv[MAX_PATH]; wszCertSrv[0] = L'\0';
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    if (fServer)
    {
        // Create nsrev_<CA Name>.asp
        BuildPath(
                wszCertSrv,
                ARRAYSIZE(wszCertSrv),
                pComp->pwszSystem32,
		wszCERTENROLLSHAREPATH);
        BuildPath(
                wszAspPath,
                ARRAYSIZE(wszAspPath),
                wszCertSrv,
                L"nsrev_");
        wcscat(wszAspPath, pServer->pwszSanitizedName);
        wcscat(wszAspPath, TEXT(".asp"));
        CSASSERT(wcslen(wszAspPath) < ARRAYSIZE(wszAspPath));

        hr = MakeRevocationPage(pComp, wszAspPath);
        if (S_OK != hr)
        {
            CertErrorMessageBox(
                            pComp->hInstance,
                            pComp->fUnattended,
                            hwnd,
                            IDS_ERR_CREATEFILE,
                            hr,
                            wszAspPath);
            _JumpError(hr, error, "MakeRevocationPage");
        }

    }

error:
    return(hr);
}



HRESULT
CreateCertificateService(
    PER_COMPONENT_DATA *pComp,
    HWND hwnd)
{
    HRESULT hr;
    WCHAR const *pwszDisplayName;
    SERVICE_DESCRIPTION sd;
    SC_HANDLE hSCManager = NULL;
    SC_HANDLE hSC = NULL;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    if (NULL != pServer->pwszSharedFolder)
    {
        // add entry
        hr = CreateConfigFiles(pServer->pwszSharedFolder, pComp, FALSE);
        if (S_OK != hr)
        {
            CertErrorMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hwnd,
                IDS_ERR_CREATECERTSRVFILE,
                hr,
                pServer->pwszSharedFolder);
            _JumpError(hr, error, "CreateConfigFiles");
        }
    }


    if (NULL != g_pwszArgvPath)
    {
        wcscpy(g_wszServicePath, g_pwszArgvPath);
        if (L'\0' != g_wszServicePath[0] &&
            L'\\' != g_wszServicePath[wcslen(g_wszServicePath) - 1])
        {
            wcscat(g_wszServicePath, L"\\");
        }
    }
    else
    {
        wcscpy(g_wszServicePath, pComp->pwszSystem32);
    }
    wcscat(g_wszServicePath, wszCERTSRVEXENAME);

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (NULL == hSCManager)
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenSCManager");
    }

    if (NULL == g_pwszNoService)
    {
        pwszDisplayName = myLoadResourceString(IDS_CA_SERVICEDISPLAYNAME);
        if (NULL == pwszDisplayName)
        {
            hr = myHLastError();
            _JumpError(hr, error, "myLoadResourceString");
        }

        sd.lpDescription = const_cast<WCHAR *>(myLoadResourceString(
                                                IDS_CA_SERVICEDESCRIPTION));
        if (NULL == sd.lpDescription)
        {
            hr = myHLastError();
            _JumpError(hr, error, "myLoadResourceString");
        }

        hSC = CreateService(
                        hSCManager,                     // hSCManager
                        wszSERVICE_NAME,                // lpServiceName
                        pwszDisplayName,                // lpDisplayName
                        SERVICE_ALL_ACCESS,             // dwDesiredAccess
                        SERVICE_WIN32_OWN_PROCESS|      // dwServiceType
                        (pServer->fInteractiveService?
                        SERVICE_INTERACTIVE_PROCESS:0),
                        SERVICE_AUTO_START,             // dwStartType
                        SERVICE_ERROR_NORMAL,           // dwErrorControl
                        g_wszServicePath,               // lpBinaryPathName
                        NULL,                           // lpLoadOrderGroup
                        NULL,                           // lplpdwTagId
                        NULL,                           // lpDependencies
                        NULL,                           // lpServiceStartName
                        NULL);                          // lpPassword
        if (NULL == hSC)
        {
            hr = myHLastError();
            if (HRESULT_FROM_WIN32(ERROR_DUPLICATE_SERVICE_NAME) != hr &&
                HRESULT_FROM_WIN32(ERROR_SERVICE_EXISTS) != hr)
            {
                CertErrorMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hwnd,
                        IDS_ERR_CREATESERVICE,
                        hr,
                        wszSERVICE_NAME);
                _JumpError(hr, error, "CreateService");
            }
        }
        if (!ChangeServiceConfig2(
                            hSC,                        // hService
                            SERVICE_CONFIG_DESCRIPTION, // dwInfoLevel
                            (VOID *) &sd))              // lpInfo
        {
            // This error is not critical.

            hr = myHLastError();
            _PrintError(hr, "ChangeServiceConfig2");
        }
    }

    // add event log message DLL (ok, it's really an EXE) as a message source

    hr = myAddLogSourceToRegistry(g_wszServicePath, wszSERVICE_NAME);
    if (S_OK != hr)
    {
        CertErrorMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hwnd,
                    IDS_ERR_ADDSOURCETOREGISTRY,
                    hr,
                    NULL);
        _JumpError(hr, error, "AddLogSourceToRegistry");
    }

error:
    if (NULL != hSC)
    {
        CloseServiceHandle(hSC);
    }
    if (NULL != hSCManager)
    {
        CloseServiceHandle(hSCManager);
    }
    CSILOG(hr, IDS_LOG_CREATE_SERVICE, NULL, NULL, NULL);
    return(hr);
}


HRESULT
DeleteProgramGroups(
    IN BOOL fAll)
{
    HRESULT hr;
    PROGRAMENTRY const *ppe;
    WCHAR const *pwszLinkName;
    WCHAR const *pwszGroupName;

    for (ppe = g_aProgramEntry; ppe < &g_aProgramEntry[CPROGRAMENTRY]; ppe++)
    {
        if (fAll || (PE_DELETEONLY & ppe->Flags))
        {
            pwszLinkName = myLoadResourceString(ppe->uiLinkName);
            if (NULL == pwszLinkName)
            {
                hr = myHLastError();
                _PrintError(hr, "myLoadResourceString");
                continue;
            }

            pwszGroupName = NULL;
            if (0 != ppe->uiGroupName)
            {
                pwszGroupName = myLoadResourceString(ppe->uiGroupName);
                if (NULL == pwszGroupName)
                {
                    hr = myHLastError();
                    _PrintError(hr, "myLoadResourceString");
                    continue;
                }
            }
	    if (!DeleteLinkFile(
		    ppe->csidl,             // CSIDL_*
		    pwszGroupName,          // IN LPCSTR lpSubDirectory
		    pwszLinkName,           // IN LPCSTR lpFileName
		    FALSE))                 // IN BOOL fDeleteSubDirectory
	    {
		hr = myHLastError();
		_PrintError3(
			hr,
			"DeleteLinkFile",
			HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND),
			HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND));
            }
        }
    }
    pwszGroupName = myLoadResourceString(IDS_STARTMENU_CERTSERVER);
    if (NULL == pwszGroupName)
    {
        hr = myHLastError();
        _PrintError(hr, "myLoadResourceString");
    }
    else if (!DeleteGroup(pwszGroupName, TRUE))
    {
	hr = myHLastError();
	_PrintError(hr, "DeleteGroup");
    }
    hr = S_OK;

//error:
    return(hr);
}


HRESULT
CancelCertsrvInstallation(
    HWND                hwnd,
    PER_COMPONENT_DATA *pComp)
{
    static BOOL s_fCancelled = FALSE;
    HRESULT  hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    if (s_fCancelled)
    {
        goto done;
    }

    if (IS_SERVER_INSTALL & pComp->dwInstallStatus)
    {
        // uninstall will remove reg entries and others
        PreUninstallCore(hwnd, pComp);

        // Note, GUI mode, we allow re-try post setup in case of cancel or failure
        //       but unattended mode, only allow once
        UninstallCore(hwnd, pComp, 0, 0, FALSE, FALSE, !pComp->fUnattended);

        if (pComp->fUnattended)
        {
            hr = SetSetupStatus(
                NULL,
                SETUP_CLIENT_FLAG | SETUP_SERVER_FLAG,
                FALSE);
        }
    }

    if (NULL != pServer)
    {
        if (NULL == pServer->pccExistingCert)
        {
            if (pServer->fSavedCAInDS)
            {
                // remove ca entry from ds
                hr = RemoveCAInDS(pServer->pwszSanitizedName);
                if (S_OK == hr)
                {
                    pServer->fSavedCAInDS = FALSE;
                }
                else
                {
                    _PrintError(hr, "RemoveCAInDS");
                }
            }
        }

        // delete the new key container, if necessary.
        ClearKeyContainerName(pServer);

        DisableVRootsAndShares(pComp->fCreatedVRoot, pServer->fCreatedShare);
    }

    DBGPRINT((DBG_SS_CERTOCM, "Certsrv setup is cancelled.\n"));

    s_fCancelled = TRUE; // only once
done:
    hr = S_OK;
//error:
    CSILOG(hr, IDS_LOG_CANCEL_INSTALL, NULL, NULL, NULL);
    return hr;
}


// Returns true if the specified period is valid. For year it 
// should be in the VP_MIN,VP_MAX range. For days/weeks/months,
// we define a separate upper limit to be consistent with the
// attended setup which restricts the edit box to 4 digits.

bool IsValidPeriod(const CASERVERSETUPINFO *pServer)
{
    return VP_MIN <= pServer->dwValidityPeriodCount &&
       !(ENUM_PERIOD_YEARS == pServer->enumValidityPeriod &&
       VP_MAX < pServer->dwValidityPeriodCount) &&
       !(ENUM_PERIOD_YEARS != pServer->enumValidityPeriod &&
       VP_MAX_DAYS_WEEKS_MONTHS < pServer->dwValidityPeriodCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\websetup.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       websetup.h
//
//--------------------------------------------------------------------------

#ifndef __WEBSETUP_H__
#define __WEBSETUP_H__

//+------------------------------------------------------------------------
//
//  File:	websetup.h
// 
//  Contents:	Header file for CertInit's web setup functions.
//
//  History:	3/19/97	JerryK	Created
//
//-------------------------------------------------------------------------




// Function Prototypes
void StartAndStopW3SVC();

HRESULT 
StartAndStopW3Svc(
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND const hwnd,
    IN BOOL const fStopService,
    IN BOOL const fConfirm,
    OUT BOOL     *pfServiceWasRunning);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\wizpage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       wizpage.cpp
//
//  Contents:   Wizard page construction and presentation functions to be used
//              by the OCM driver code.
//
//  History:    04/16/97    JerryK    Fixed/Changed/Unmangled
//                0/8/97      XTan    major structure change
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// ** System Includes **
#include <prsht.h>
#include <commdlg.h>
#include <sddl.h>

// ** Application Includes **
#include "cryptui.h"
#include "csdisp.h"
#include "csprop.h"
#include "cspenum.h"
#include "usecert.h"
#include "wizpage.h"

#include "cscsp.h"
#include "clibres.h"
#include "certmsg.h"
#include "websetup.h"
#include "dssetup.h"
#include "setupids.h"
#include "tfc.h"
#include "certacl.h"

//defines

#define __dwFILE__      __dwFILE_OCMSETUP_WIZPAGE_CPP__

#define dwWIZDISABLE    (DWORD) -2
#define dwWIZBACK       (DWORD) -1
#define dwWIZACTIVE     0
#define dwWIZNEXT       1

#define C_CSPHASNOKEYMINMAX  (DWORD) -1
#define MAX_KEYLENGTHEDIT     128
#define MAX_KEYLENGTHDIGIT    5

#define wszOLDCASTOREPREFIX L"CA_"

#define _ReturnIfWizError(hr) \
    { \
        if (S_OK != (hr)) \
        { \
            CSILOG((hr), IDS_LOG_WIZ_PAGE_ERROR, NULL, NULL, NULL); \
            _PrintError(hr, "CertSrv Wizard error"); \
            return TRUE; \
        } \
    }

#define _GetCompDataOrReturnIfError(pComp, hDlg) \
           (PER_COMPONENT_DATA*)GetWindowLongPtr((hDlg), DWLP_USER); \
           if (NULL == (pComp) || S_OK != (pComp)->hrContinue) \
           { \
                return TRUE; \
           }

#define _GetCompDataOrReturn(pComp, hDlg) \
           (PER_COMPONENT_DATA*)GetWindowLongPtr((hDlg), DWLP_USER); \
           if (NULL == (pComp)) \
           { \
                return TRUE; \
           }

#define _DisableWizDisplayIfError(pComp, hDlg) \
    if (S_OK != (pComp)->hrContinue) \
    { \
        CSILOG((pComp)->hrContinue, IDS_LOG_DISABLE_WIZ_PAGE, NULL, NULL, NULL); \
        SetWindowLongPtr((hDlg), DWLP_MSGRESULT, -1); \
    }

//--------------------------------------------------------------------
struct FAKEPROGRESSINFO {
    HANDLE hStopEvent;
    CRITICAL_SECTION csTimeSync;
    BOOL fCSInit;
    DWORD dwSecsRemaining;
    HWND hwndProgBar;
};

struct KEYGENPROGRESSINFO {
    HWND hDlg;                      // wizard page window
    PER_COMPONENT_DATA * pComp;     // setup data
};


KEYGENPROGRESSINFO  g_KeyGenInfo = {
    NULL,    //hDlg
    NULL,    //pComp
    };
BOOL g_fAllowUnicodeStrEncoding = FALSE;

// ** Prototypes/Forward Declarations **
LRESULT CALLBACK
IdInfoNameEditFilterHook(HWND, UINT, WPARAM, LPARAM);

INT_PTR
DefaultPageDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);


__inline VOID
SetEditFocusAndSelect(
    IN HWND  hwnd,
    IN DWORD indexStart,
    IN DWORD indexEnd)
{
    SetFocus(hwnd);
    SendMessage(hwnd, EM_SETSEL, indexStart, indexEnd);
}


// fix for 160324 - NT4->Whistler upgrade: 
// cannot reinstall CA w/ same cert as instructions tell us to do
//
// Upgrade NT4->Whistler is not supported but old CA key and cert can be reused
// But NT4 used to install CA certs in a separate store (CA_MACHINENAME) so we
// need to move the cert to root store so it can be validated.
HRESULT CopyNT4CACertToRootStore(CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    WCHAR          wszOldCAStore[MAX_PATH];
    HCERTSTORE     hOldStore = NULL;
    HCERTSTORE     hRootStore = NULL;
    CERT_RDN_ATTR  rdnAttr = { szOID_COMMON_NAME, CERT_RDN_ANY_TYPE,};
    CERT_RDN       rdn = { 1, &rdnAttr };
    DWORD          cCA = 0;
    CERT_CONTEXT const *pCACert;
    CERT_CONTEXT const *pCACertKeep = NULL; // needn't free
    CERT_CONTEXT const **ppCACertKeep = NULL;
    CRYPT_KEY_PROV_INFO  keyProvInfo;
    DWORD               *pIndex = NULL;
    DWORD i = 0;

    ZeroMemory(&keyProvInfo, sizeof(keyProvInfo));

    // form old ca store name
    // !!! NT4 uses different sanitize, how do we build it correctly?
    wcscpy(wszOldCAStore, wszOLDCASTOREPREFIX);
    wcscat(wszOldCAStore, pServer->pwszSanitizedName);

    // open old CA store
    hOldStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            X509_ASN_ENCODING,
            NULL,           // hProv
            CERT_STORE_OPEN_EXISTING_FLAG |
            CERT_STORE_READONLY_FLAG |
            CERT_SYSTEM_STORE_LOCAL_MACHINE,
            wszOldCAStore);
    if (NULL == hOldStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    // find CA cert, old ca common name always same as ca name
    rdnAttr.Value.pbData = (BYTE *) pServer->pwszCACommonName;
    rdnAttr.Value.cbData = 0;
    pCACert = NULL;
    do
    {
        pCACert = CertFindCertificateInStore(
                                hOldStore,
                                X509_ASN_ENCODING,
                                CERT_UNICODE_IS_RDN_ATTRS_FLAG |
                                    CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG,
                                CERT_FIND_SUBJECT_ATTR,
                                &rdn,
                                pCACert);
        if (NULL != pCACert)
        {
            // find one
            if (NULL == ppCACertKeep)
            {
                ppCACertKeep = (CERT_CONTEXT const **)LocalAlloc(LMEM_FIXED,
                                  (cCA + 1) * sizeof(CERT_CONTEXT const *));
                _JumpIfOutOfMemory(hr, error, ppCACertKeep);
            }
            else
            {
                CERT_CONTEXT const ** ppTemp;
                ppTemp = (CERT_CONTEXT const **)LocalReAlloc(
                                  ppCACertKeep,
                                  (cCA + 1) * sizeof(CERT_CONTEXT const *),
                                  LMEM_MOVEABLE);
                _JumpIfOutOfMemory(hr, error, ppTemp);
                ppCACertKeep = ppTemp;
               
            }
            // keep current
            ppCACertKeep[cCA] = CertDuplicateCertificateContext(pCACert);
            if (NULL == ppCACertKeep[cCA])
            {
                hr = myHLastError();
                _JumpError(hr, error, "CertDuplicateCertificate");
            }
            ++cCA;
        }
    } while (NULL != pCACert);

    if (1 > cCA)
    {
        // no ca cert
        hr = E_INVALIDARG;
        _JumpError(hr, error, "no ca cert");
    }

    // assume 1st one
    pCACertKeep = ppCACertKeep[0];

    if (1 < cCA)
    {
        DWORD  cCA2 = cCA;
        BOOL   fMatch;

        // have multi ca certs with the same cn
        // because sp4 doesn't reg ca serial # so need to decide which one
        // once the correct one is found, reg its serial #

        // build an index
        pIndex = (DWORD*)LocalAlloc(LMEM_FIXED, cCA * sizeof(DWORD));
        _JumpIfOutOfMemory(hr, error, pIndex);
        i = 0;
        for (pIndex[i] = i; i < cCA; ++i);

        // try to compare with public key

        // in case ca cert doesn't have kpi which is the case for v10
        // so try base rsa
        hr = csiFillKeyProvInfo(
                    pServer->pwszSanitizedName,
                    pServer->pCSPInfo->pwszProvName,
                    pServer->pCSPInfo->dwProvType,
                    TRUE,                       // always machine keyset
                    &keyProvInfo);
        if (S_OK == hr)
        {

            cCA2 = 0;
            for (i = 0; i < cCA; ++i)
            {
                hr = myVerifyPublicKey(
				ppCACertKeep[i],
				FALSE,
				&keyProvInfo,
				NULL,
				&fMatch);
                if (S_OK != hr)
                {
                    continue;
                }
                if (fMatch)
                {
                    // found one match with current public key from container
                    pIndex[cCA2] = i;
                    ++cCA2;
                }
            }
        }

        // compare all ca certs and pick one has most recent NotAfter
        pCACertKeep = ppCACertKeep[pIndex[0]];
        for (i = 1; i < cCA2; ++i)
        {
            if (0 < CompareFileTime(
                         &ppCACertKeep[pIndex[i]]->pCertInfo->NotAfter,
                         &pCACertKeep->pCertInfo->NotAfter))
            {
                // update
                pCACertKeep = ppCACertKeep[pIndex[i]];
            }
        }
    }

    // if get here, must find ca cert
    CSASSERT(NULL != pCACertKeep);

    // add cert to root store
    hRootStore = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                        X509_ASN_ENCODING,
                        NULL,           // hProv
                        CERT_SYSTEM_STORE_LOCAL_MACHINE,
                        wszROOT_CERTSTORE);
    if (NULL == hRootStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    if(!CertAddCertificateContextToStore(
            hRootStore,
            pCACertKeep,
            CERT_STORE_ADD_NEW,
            NULL))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertAddCertificateContextToStore");
    }
    hr = S_OK;
  
error:
    csiFreeKeyProvInfo(&keyProvInfo);
    for (i = 0; i < cCA; ++i)
    {
        CertFreeCertificateContext(ppCACertKeep[i]);
    }
    if (NULL != hOldStore)
    {
        CertCloseStore(hOldStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != hRootStore)
    {
        CertCloseStore(hRootStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return hr;
}


//--------------------------------------------------------------------
// Clear the key container name to indicate that we must generate a new key.
void
ClearKeyContainerName(CASERVERSETUPINFO *pServer)
{
    if (NULL!=pServer->pwszKeyContainerName) {
        // Delete the key container if this is a new one
        if (pServer->fDeletableNewKey) {

            // Delete the key container. Ignore any errors.
            HCRYPTPROV hProv=NULL;
            myCertSrvCryptAcquireContext(
                    &hProv,
                    pServer->pwszKeyContainerName,
                    pServer->pCSPInfo->pwszProvName,
                    pServer->pCSPInfo->dwProvType,
                    CRYPT_DELETEKEYSET,
                    pServer->pCSPInfo->fMachineKeyset);
            if (NULL!=hProv) {
                CryptReleaseContext(hProv, 0);
            }
            pServer->fDeletableNewKey=FALSE;
        }

        // Clear the key container name, to indicate that we must generate a new key.
        LocalFree(pServer->pwszKeyContainerName);
        LocalFree(pServer->pwszDesanitizedKeyContainerName);
        pServer->pwszKeyContainerName=NULL;
        pServer->pwszDesanitizedKeyContainerName=NULL;

        // if we were using an existing cert, we are not anymore
        ClearExistingCertToUse(pServer);

    } else {

        // if there was no key, there couldn't be a existing cert.
        CSASSERT(NULL==pServer->pccExistingCert);

        // key container name is already clear
    }
}

//--------------------------------------------------------------------
// Set both the real key container name and the display key container name
HRESULT
SetKeyContainerName(
    CASERVERSETUPINFO *pServer,
    const WCHAR * pwszKeyContainerName)
{
    HRESULT hr;

    // get rid of any previous names
    ClearKeyContainerName(pServer);

    // set the real key container name
    pServer->pwszKeyContainerName = (WCHAR *) LocalAlloc(
			LMEM_FIXED,
			sizeof(WCHAR) * (wcslen(pwszKeyContainerName) + 1));
    _JumpIfOutOfMemory(hr, error, pServer->pwszKeyContainerName);

    wcscpy(pServer->pwszKeyContainerName, pwszKeyContainerName);

    // set the display key container name
    hr = myRevertSanitizeName(
			pServer->pwszKeyContainerName,
			&pServer->pwszDesanitizedKeyContainerName);
    _JumpIfError(hr, error, "myRevertSanitizeName");

    // Must validate the key again when the selected key changes
    pServer->fValidatedHashAndKey = FALSE;

    CSILOG(
	hr,
	IDS_ILOG_KEYCONTAINERNAME,
	pServer->pwszKeyContainerName,
	pServer->pwszDesanitizedKeyContainerName,
	NULL);

error:
    return hr;
}

HRESULT
UpdateDomainAndUserName(
    IN HWND hwnd,
    IN OUT PER_COMPONENT_DATA *pComp);





BOOL
CertConfirmCancel(
    HWND                hwnd,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;

    CSASSERT(NULL != pComp);

    if (!(*pComp->HelperRoutines.ConfirmCancelRoutine)(hwnd))
    {
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
        return TRUE;
    }
    hr = CancelCertsrvInstallation(hwnd, pComp);
    _PrintIfError(hr, "CancelCertsrvInstallation");

    return FALSE;
}

HRESULT
StartWizardPageEditControls(
    IN HWND hDlg,
    IN OUT PAGESTRINGS *pPageStrings)
{
    HRESULT hr;

    for ( ; NULL != pPageStrings->ppwszString; pPageStrings++)
    {
        SendMessage(
            GetDlgItem(hDlg, pPageStrings->idControl),
            WM_SETTEXT,
            0,
            (LPARAM) *pPageStrings->ppwszString);
    }

    hr = S_OK;
//error:
    return hr;
}


HRESULT
FinishWizardPageEditControls(
    IN HWND hDlg,
    IN OUT PAGESTRINGS *pPageStrings)
{
    HRESULT hr;
    
    for ( ; NULL != pPageStrings->ppwszString; pPageStrings++)
    {
        WCHAR *pwszString = NULL;

        hr = myUIGetWindowText(
                        GetDlgItem(hDlg, pPageStrings->idControl),
                        &pwszString);
        _JumpIfError(hr, error, "myUIGetWindowText");

        if (NULL != *pPageStrings->ppwszString)
        {
            // free old one
            LocalFree(*pPageStrings->ppwszString);
            *pPageStrings->ppwszString = NULL;
        }
        *pPageStrings->ppwszString = pwszString;
        CSILOG(S_OK, pPageStrings->idLog, pwszString, NULL, NULL);
    }

    hr = S_OK;
error:
    return hr;
}


//+------------------------------------------------------------------------
//  Function:   WizPageSetTextLimits
//
//  Synopsis:   Sets text input limits for the text controls of a dlg page.
//-------------------------------------------------------------------------

HRESULT
WizPageSetTextLimits(
    HWND hDlg,
    IN OUT PAGESTRINGS *pPageStrings)
{
    HRESULT hr;

    for ( ; NULL != pPageStrings->ppwszString; pPageStrings++)
    {
        SendDlgItemMessage(
                hDlg,
                pPageStrings->idControl,
                EM_SETLIMITTEXT,
                (WPARAM) pPageStrings->cchMax,
                (LPARAM) 0);
    }

    hr = S_OK;
//error:
    return hr;
}


// check optional or mac length in edit field
// if any invalid, focus on the edit field, select all
HRESULT
ValidateTextField(
    HINSTANCE hInstance,
    BOOL fUnattended,
    HWND hDlg,
    LPTSTR pszTestString,
    DWORD nUBValue,
    int nMsgBoxNullStringErrID,
    int nMsgBoxLenStringErrID,
    int nControlID)
{
    HRESULT  hr = E_INVALIDARG;
    HWND hwndCtrl = NULL;
    BOOL fIsEmpty;

    fIsEmpty = (NULL == pszTestString) || (L'\0' == pszTestString[0]);

    if (fIsEmpty)
    {
        if (0 != nMsgBoxNullStringErrID) // non optional
        {
            // edit field can't be empty

            CertWarningMessageBox(
                        hInstance,
                        fUnattended,
                        hDlg,
                        nMsgBoxNullStringErrID,
                        0,
                        NULL);
            if (!fUnattended)
            {
                hwndCtrl = GetDlgItem(hDlg, nControlID);  // Get offending ctrl
            }
            goto error;
        }
        goto done;
    }

    // the following may not be necessary because edit field set to max limit
#pragma prefast(disable:11, "PREfast bug 648")
    if (wcslen(pszTestString) > nUBValue)        // Make sure it's not too long
#pragma prefast(enable:11, "re-enable")
    {
        CertWarningMessageBox(
                hInstance,
                fUnattended,
                hDlg,
                nMsgBoxLenStringErrID,
                0,
                NULL);
        if (!fUnattended)
        {
            hwndCtrl = GetDlgItem(hDlg, nControlID);
        }
        goto error;
    }

done:
    hr = S_OK;
error:
    if (!fUnattended && NULL != hwndCtrl)
    {
        SetEditFocusAndSelect(hwndCtrl, 0, MAXDWORD);
    }
    return hr;
}

HRESULT
WizardPageValidation(
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hDlg,
    IN PAGESTRINGS *pPageStrings)
{
    HRESULT  hr;

    for ( ; NULL != pPageStrings->ppwszString; pPageStrings++)
    {
        hr = ValidateTextField(
                        hInstance,
                        fUnattended,
                        hDlg,
                        *pPageStrings->ppwszString,
                        pPageStrings->cchMax,
                        pPageStrings->idMsgBoxNullString,
                        pPageStrings->idMsgBoxLenString,
                        pPageStrings->idControl);
        _JumpIfError(hr, error, "invalid edit field");
    }

    hr = S_OK;
error:
    return hr;
}





#define KEYGEN_GENERATE_KEY     60 // estimated seconds to gen key
#define KEYGEN_PROTECT_KEY      60 // estimated seconds to acl key
#define KEYGEN_TEST_HASH        2 // estimated seconds to acl key


//--------------------------------------------------------------------
// Fake progress by incrementing a progress bar every second

DWORD WINAPI
KeyGenFakeProgressThread(
    LPVOID lpParameter)
{
    FAKEPROGRESSINFO * pFakeProgressInfo=(FAKEPROGRESSINFO *)lpParameter;

    // Wait for the stop signal for 1 second.
    while (WAIT_TIMEOUT==WaitForSingleObject(pFakeProgressInfo->hStopEvent, 1000)) {

        // See if we can send another tick to the progress bar
        if(pFakeProgressInfo->fCSInit)
        {
            EnterCriticalSection(&pFakeProgressInfo->csTimeSync);
            if (pFakeProgressInfo->dwSecsRemaining>0) {

                // move one step (one second)
                SendMessage(pFakeProgressInfo->hwndProgBar, PBM_DELTAPOS, 1, 0);
                pFakeProgressInfo->dwSecsRemaining--;
            }
            LeaveCriticalSection(&pFakeProgressInfo->csTimeSync);
        }
    }

    // We were signaled, so stop.
    return 0; // return value ignored
}


//--------------------------------------------------------------------
// Generate a new key and test the hash algorithm

DWORD WINAPI
GenerateKeyThread(
    LPVOID lpParameter)
{
    HRESULT hr = S_OK;
    WCHAR * pwszMsg;
    FAKEPROGRESSINFO fpi;
    KEYGENPROGRESSINFO * pKeyGenInfo=(KEYGENPROGRESSINFO *)lpParameter;
    PER_COMPONENT_DATA * pComp=pKeyGenInfo->pComp;
    CASERVERSETUPINFO * pServer=pComp->CA.pServer;
    HWND hwndProgBar=GetDlgItem(pKeyGenInfo->hDlg, IDC_KEYGEN_PROGRESS);
    HWND hwndText=GetDlgItem(pKeyGenInfo->hDlg, IDC_KEYGEN_PROGRESS_TEXT);
    int iErrMsg=0; // error msg id
    const WCHAR * pwszErrMsgData = L"";
    BOOL fEnableKeyCounting;

    // variables that must be cleaned up

    fpi.hStopEvent=NULL;
    HANDLE hFakeProgressThread=NULL;
    HCRYPTPROV hProv=NULL;
    fpi.fCSInit = FALSE;
    __try
    {
        InitializeCriticalSection(&fpi.csTimeSync);
        fpi.fCSInit = TRUE;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "InitializeCriticalSection");

    // STEP 0:
    // initialize the fake-progress thread

    // set up the structure for the fake-progress thread
    fpi.hStopEvent=CreateEvent(
        NULL,   // security
        FALSE,  // manual reset? 
        FALSE,  // signaled?
        NULL);  // name
    if (NULL==fpi.hStopEvent) {
        hr = myHLastError();
        _JumpError(hr, error, "CreateEvent");
    }
    fpi.hwndProgBar=hwndProgBar;
    fpi.dwSecsRemaining=0; // Initially, the thread has no work to do.

    // start the fake-progress thread
    DWORD dwThreadID; // ignored
    hFakeProgressThread=CreateThread(
        NULL,                       // security
        0,                          // stack
        KeyGenFakeProgressThread,
        (void *)&fpi,
        0,                          // flags
        &dwThreadID);
    if (NULL==hFakeProgressThread) {
        hr = myHLastError();
        _JumpError(hr, error, "CreateThread");
    }

    if (NULL==pServer->pwszKeyContainerName) {
        // STEP 1:
        // Generate a key

        // set the status
        hr = myLoadRCString(pComp->hInstance, IDS_KEYGEN_GENERATING, &pwszMsg);
        _JumpIfError(hr, error, "myLoadRCString");

        SetWindowText(hwndText, pwszMsg);
        LocalFree(pwszMsg);
        SendMessage(hwndProgBar, PBM_SETPOS, (WPARAM)0, 0);

        if(fpi.fCSInit)
        {
            EnterCriticalSection(&fpi.csTimeSync);
            fpi.dwSecsRemaining = KEYGEN_GENERATE_KEY;
            LeaveCriticalSection(&fpi.csTimeSync);
        }

        hr = myInfGetEnableKeyCounting(
			    pComp->hinfCAPolicy,
			    &fEnableKeyCounting);
	if (S_OK != hr)
	{
	    fEnableKeyCounting = FALSE;
	}

        // generate key
        hr = csiGenerateKeysOnly(
                        pServer->pwszSanitizedName,
                        pServer->pCSPInfo->pwszProvName,
                        pServer->pCSPInfo->dwProvType,
                        pServer->pCSPInfo->fMachineKeyset,
                        pServer->dwKeyLength,
                        pComp->fUnattended,
                        fEnableKeyCounting,
                        &hProv,
                        &iErrMsg);
        if (S_OK != hr)
        {
            pwszErrMsgData=pServer->pwszSanitizedName;
            pServer->fKeyGenFailed = TRUE;
            _JumpError(hr, error, "csiGenerateKeysOnly");
        }
        pServer->fKeyGenFailed = FALSE;

        // now set this as the existing key
        SetKeyContainerName(pServer, pServer->pwszSanitizedName);
        pServer->fDeletableNewKey=TRUE;

        // STEP 2:
        // Set the ACLs

        // set the status
        hr = myLoadRCString(pComp->hInstance, IDS_KEYGEN_PROTECTING, &pwszMsg);
        _JumpIfError(hr, error, "myLoadRCString");

        SetWindowText(hwndText, pwszMsg);
        LocalFree(pwszMsg);
        if(fpi.fCSInit)
        {
            EnterCriticalSection(&fpi.csTimeSync);
            SendMessage(hwndProgBar, PBM_SETPOS, (WPARAM)KEYGEN_GENERATE_KEY, 0);
            fpi.dwSecsRemaining=KEYGEN_PROTECT_KEY;
            LeaveCriticalSection(&fpi.csTimeSync);
        }

        // set the ACLs
        hr = csiSetKeyContainerSecurity(hProv);
        if (S_OK!=hr) {
            iErrMsg=IDS_ERR_KEYSECURITY;
            pwszErrMsgData=pServer->pwszKeyContainerName;
            _JumpError(hr, error, "csiSetKeyContainerSecurity");
        }

    } // <- end if (NULL==pServer->pwszKeyContainerName)

    if (FALSE==pServer->fValidatedHashAndKey) {

        // STEP 3:
        // Test the hash algorithm and key set

        // set the status
        hr = myLoadRCString(pComp->hInstance, IDS_KEYGEN_TESTINGHASHANDKEY, &pwszMsg);
        _JumpIfError(hr, error, "myLoadRCString");
        SetWindowText(hwndText, pwszMsg);
        LocalFree(pwszMsg);
        if(fpi.fCSInit)
        {
            EnterCriticalSection(&fpi.csTimeSync);
            SendMessage(hwndProgBar, PBM_SETPOS, (WPARAM)KEYGEN_GENERATE_KEY+KEYGEN_PROTECT_KEY, 0);
            fpi.dwSecsRemaining=KEYGEN_TEST_HASH;
            LeaveCriticalSection(&fpi.csTimeSync);
        }

        // test the hash and keyset

        hr = myValidateSigningKey(
                            pServer->pwszKeyContainerName,
                            pServer->pCSPInfo->pwszProvName,
                            pServer->pCSPInfo->dwProvType,
			    FALSE,		// fCryptSilent
                            pServer->pCSPInfo->fMachineKeyset,
			    TRUE,		// fForceSignatureTest
			    NULL,		// pcc
			    NULL,		// pPublicKeyInfo
                            pServer->pHashInfo->idAlg,
			    NULL,		// pfSigningTestAttempted
			    NULL);		// phProv
        if (S_OK!=hr) {
            if (NTE_BAD_KEY_STATE==hr ||   //all the errors with KEY in them
                NTE_NO_KEY==hr ||
                NTE_BAD_PUBLIC_KEY==hr ||
                NTE_BAD_KEYSET==hr ||
                NTE_KEYSET_NOT_DEF==hr ||  
                NTE_KEYSET_ENTRY_BAD==hr ||
                NTE_BAD_KEYSET_PARAM==hr) {
                // Bad keyset (eg, not AT_SIGNATURE) - force user to pick another
                iErrMsg=IDS_KEY_INVALID;
                pwszErrMsgData=pServer->pwszKeyContainerName;
            } else {
                // Bad hash algorithm - force user to pick another
                iErrMsg=IDS_ERR_INVALIDHASH;
                pwszErrMsgData=pServer->pHashInfo->pwszName;
            }
           _JumpError(hr, error, "myValidateSigningKey");
        }
        
        // mark this hash as validated
        pServer->fValidatedHashAndKey=TRUE;
    }

    // STEP 3:
    // Go to the next page

    // set the status, so the user sees the bar go all the way.
    if(fpi.fCSInit)
    {
        EnterCriticalSection(&fpi.csTimeSync);
        SendMessage(hwndProgBar, PBM_SETPOS, (WPARAM)KEYGEN_GENERATE_KEY+KEYGEN_PROTECT_KEY+KEYGEN_TEST_HASH, 0);
        fpi.dwSecsRemaining=0;
        LeaveCriticalSection(&fpi.csTimeSync);
    }

error:

    // clean up after the false-progress thread
    if (NULL!=hFakeProgressThread) {
        CSASSERT(NULL!=fpi.hStopEvent);
        // tell the progress thread to stop
        if (FALSE==SetEvent(fpi.hStopEvent)) {
            _PrintError(myHLastError(), "SetEvent");
        } else {
            // wait for it to stop
            WaitForSingleObject(hFakeProgressThread, INFINITE);
        }
        CloseHandle(hFakeProgressThread);
    }
    
    if(fpi.fCSInit)
    {
        DeleteCriticalSection(&fpi.csTimeSync);
    }
    
    if (NULL!=fpi.hStopEvent) {
        CloseHandle(fpi.hStopEvent);
    }

    if (NULL!=hProv) {
        CryptReleaseContext(hProv, 0);
    }

    // show an error message if we need to
    if (0!=iErrMsg) {
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            pKeyGenInfo->hDlg,
            iErrMsg,
            hr,
            pwszErrMsgData);
    }

    pServer->LastWiz=ENUM_WIZ_KEYGEN;
    if (S_OK==hr) {
        // go to next page 
        PropSheet_PressButton(GetParent(pKeyGenInfo->hDlg), PSBTN_NEXT);
    } else {
        // go back
        PropSheet_PressButton(GetParent(pKeyGenInfo->hDlg), PSBTN_BACK);
    }

    return 0; // return value ignored
}


//--------------------------------------------------------------------
// Start the KeyGen wizard page

HRESULT
HandleKeyGenWizActive(
    HWND    hDlg,
    PER_COMPONENT_DATA *pComp,
    KEYGENPROGRESSINFO *pKeyGenInfo)
{
    HRESULT hr = S_OK;

    // Suppress this wizard page if
    // we are going backwards, or
    // we've already seen an error, or
    // we are not installing the server,
    // or the key exists and the hash has been checked.

    if (ENUM_WIZ_STORE == pComp->CA.pServer->LastWiz ||
        !(IS_SERVER_INSTALL & pComp->dwInstallStatus) ||
        (NULL != pComp->CA.pServer->pwszKeyContainerName &&
         pComp->CA.pServer->fValidatedHashAndKey)) {

        // skip/disable page
        CSILOGDWORD(IDS_KEYGEN_TITLE, dwWIZDISABLE);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
    }
    else
    {
        // set progress bar parameters: range, step, and position
        // set them now so the user will never see a full bar if this is the second visit.

        HWND hwndProgBar=GetDlgItem(hDlg, IDC_KEYGEN_PROGRESS);
        SendMessage(hwndProgBar, PBM_SETRANGE, 0,
            MAKELPARAM(0, KEYGEN_GENERATE_KEY+KEYGEN_PROTECT_KEY+KEYGEN_TEST_HASH));
        SendMessage(hwndProgBar, PBM_SETSTEP, (WPARAM)1, 0);
        SendMessage(hwndProgBar, PBM_SETPOS, (WPARAM)0, 0);

         // init info for keygen thread
        pKeyGenInfo->hDlg=hDlg;
        pKeyGenInfo->pComp=pComp;

        // start the key gen thread
        DWORD dwThreadID; // ignored
        HANDLE hKeyGenThread=CreateThread(
            NULL,                   // security
            0,                      // stack
            GenerateKeyThread,
            (void *)pKeyGenInfo,
            0,                      // flags
            &dwThreadID);
        if (NULL==hKeyGenThread) {
            hr = myHLastError();
            _JumpError(hr, error, "CreateThread");
        }
        CloseHandle(hKeyGenThread);
    }

error:
    return hr;
}

//+------------------------------------------------------------------------
//  Function:   WizKeyGenPageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure for keygen wiz-page
//-------------------------------------------------------------------------

INT_PTR
WizKeyGenPageDlgProc(
    HWND hDlg,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PER_COMPONENT_DATA *pComp = NULL;

    switch(iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            (ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)(ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam;
        _ReturnIfWizError(pComp->hrContinue);
        break;

    case WM_COMMAND:
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_KILLACTIVE:
            break;

        case PSN_RESET:
            break;
        case PSN_QUERYCANCEL:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            return CertConfirmCancel(hDlg, pComp);
            break;

        case PSN_SETACTIVE:
            CSILOGDWORD(IDS_KEYGEN_TITLE, dwWIZACTIVE);
            PropSheet_SetWizButtons(GetParent(hDlg), 0);
            pComp = _GetCompDataOrReturn(pComp, hDlg);
            _DisableWizDisplayIfError(pComp, hDlg);
            _ReturnIfWizError(pComp->hrContinue);
            pComp->hrContinue=HandleKeyGenWizActive(hDlg, pComp, &g_KeyGenInfo);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZBACK:
            CSILOGDWORD(IDS_KEYGEN_TITLE, dwWIZBACK);
            break;

        case PSN_WIZNEXT:
            CSILOGDWORD(IDS_KEYGEN_TITLE, dwWIZNEXT);
            break;

        default:
            return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);
        }
        break;

    default:
        return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);

    }
    return TRUE;
}


HRESULT
ValidateESERestrictions(
    IN WCHAR const *pwszDirectory)
{
    HRESULT hr;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hFileA = INVALID_HANDLE_VALUE;
    WCHAR *pwszPath = NULL;
    char *pszPath = NULL;
    WCHAR *pwsz;
    char *psz;
    DWORD cwcbs;
    DWORD cchbs;
    
    hr = myBuildPathAndExt(pwszDirectory, L"certocm.tmp", NULL, &pwszPath);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    if (!ConvertWszToSz(&pszPath, pwszPath, -1))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "ConvertWszToSz")
    }

    pwsz = pwszPath;
    cwcbs = 0;
    for (;;)
    {
        pwsz = wcschr(pwsz, L'\\');
        if (NULL == pwsz)
        {
            break;
        }
        pwsz++;
        cwcbs++;
    }

    psz = pszPath;
    cchbs = 0;
    for (;;)
    {
        psz = strchr(psz, '\\');
        if (NULL == psz)
        {
            break;
        }
        psz++;
        cchbs++;
    }
    if (cchbs != cwcbs)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "backslash count")
    }

    hFile = CreateFile(
                    pwszPath,
                    GENERIC_WRITE,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,               // security
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);              // template
    if (INVALID_HANDLE_VALUE == hFile)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "CreateFile", pwszPath);
    }

    hFileA = CreateFileA(
                    pszPath,
                    GENERIC_READ,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,               // security
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);              // template
    if (INVALID_HANDLE_VALUE == hFileA)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, pszPath, L"CreateFileA");
    }
    CSASSERT(S_OK == hr);

error:
    if (INVALID_HANDLE_VALUE != hFileA)
    {
        CloseHandle(hFileA);            // close before below delete
    }
    if (NULL != pszPath)
    {
        LocalFree(pszPath);
    }
    if (NULL != pwszPath)
    {
        if (INVALID_HANDLE_VALUE != hFile)
        {
            CloseHandle(hFile);         // close before delete
            DeleteFile(pwszPath);
        }
        LocalFree(pwszPath);
    }
    return(hr);
}


//+-------------------------------------------------------------------------
//  Function:   check if a database edit field
//--------------------------------------------------------------------------
BOOL
ValidateAndCreateDirField(
    HINSTANCE hInstance,
    BOOL    fUnattended,
    HWND    hDlg,
    WCHAR   *pwszDirectory,
    BOOL    fDefaultDir,
    int     iMsgNotFullPath,
    BOOL    *pfExist, 
    BOOL    *pfIsUNC)
{
    BOOL fRet = FALSE;
    DWORD dwPathFlag = 0;
    HRESULT hr;

    *pfExist = TRUE;

    // check edit field
    if (!myIsFullPath(pwszDirectory, &dwPathFlag))
    {
        CertWarningMessageBox(
                    hInstance,
                    fUnattended,
                    hDlg,
                    iMsgNotFullPath,
                    0,
                    pwszDirectory);
        goto error;
    }

    // set the UNC check
    *pfIsUNC = (dwPathFlag == UNC_PATH);

    if (MAX_PATH - 1 < wcslen(pwszDirectory))
    {
        WCHAR  wszMsg[256 + MAX_PATH];
        WCHAR *pwszFormat = NULL;

        hr = myLoadRCString(hInstance,
                    IDS_STORELOC_PATHTOOLONG,
                    &pwszFormat);
        _JumpIfError(hr, error, "myLoadRCString");

        swprintf(wszMsg, pwszFormat, pwszDirectory, MAX_PATH-1);
        CertWarningMessageBox(
                    hInstance,
                    fUnattended,
                    hDlg,
                    0,
                    0,
                    wszMsg);
        LocalFree(pwszFormat);
        goto error;
    }

    if (DE_DIREXISTS != DirExists(pwszDirectory))
    {
        if (*pfIsUNC)
        {
            CertWarningMessageBox(
                        hInstance,
                        fUnattended,
                        hDlg,
                        IDS_STORELOC_UNCMUSTEXIST,
                        0,
                        pwszDirectory);
            goto error;
        }
        else
        {
            if (!fDefaultDir)
            {
                // confirm and create outside
                *pfExist = FALSE;
                goto done;
            }

            // try to create default dir
            hr = myCreateNestedDirectories(pwszDirectory);
            _JumpIfError(hr, error, "myCreateNestedDirectories");
        }
    }

done:
    fRet = TRUE;

error:
    return fRet;
}

//+---------------------------------------------------------------------------
//  Description:    set MS Base CSP as default csp otherwise 1st one
//----------------------------------------------------------------------------
HRESULT
DetermineDefaultCSP(CASERVERSETUPINFO *pServer)
{
    HRESULT   hr;
    CSP_INFO *pCSPInfo = NULL;

    // select 1st if no MSBase
    pServer->pCSPInfo = pServer->pCSPInfoList;

    if (NULL == pServer->pDefaultCSPInfo)
    {
        goto done;
    }
    
    // check all csps
    pCSPInfo = pServer->pCSPInfoList;
    while (NULL != pCSPInfo)
    {
        if (NULL != pCSPInfo->pwszProvName)
        {
            if (0 == mylstrcmpiL(pCSPInfo->pwszProvName,
                         pServer->pDefaultCSPInfo->pwszProvName) &&
                pCSPInfo->dwProvType == pServer->pDefaultCSPInfo->dwProvType)
            {
                // change to default
                pServer->pCSPInfo = pCSPInfo;
                break;
            }
        }
        pCSPInfo = pCSPInfo->next;
    }

done:
    hr = S_OK;
//error:
    return hr;
}

//+---------------------------------------------------------------------------
//  Description:    set SHA as default hash alg. otherwise 1st one
//----------------------------------------------------------------------------
HRESULT
DetermineDefaultHash(CASERVERSETUPINFO *pServer)
{
    CSP_HASH *pHashInfo = NULL;
    HRESULT   hr;

    if ((NULL == pServer) || (NULL == pServer->pCSPInfo))
        return E_POINTER;

    // select 1st if no default match
    pServer->pHashInfo = pServer->pCSPInfo->pHashList;

    // search list
    pHashInfo = pServer->pCSPInfo->pHashList;
    while (NULL != pHashInfo)
    {
        if (pHashInfo->idAlg == pServer->pDefaultHashInfo->idAlg)
        {
            //change to default
            pServer->pHashInfo = pHashInfo;
            break;
        }
        pHashInfo = pHashInfo->next;
    }

    // Must validate the hash again when the selected hash changes
    pServer->fValidatedHashAndKey = FALSE;

    hr = S_OK;
//error:
    return hr;
}


HRESULT
UpdateCADescription(
    HWND hDlg,
    PER_COMPONENT_DATA *pComp)
{
    int      ids;
    WCHAR   *pwszDesc = NULL;
    HRESULT  hr;

    ids = 0;
    switch (pComp->CA.pServer->CAType)
    {
	case ENUM_STANDALONE_ROOTCA:
            ids = IDS_CATYPE_DES_STANDALONE_ROOTCA;
	    break;

        case ENUM_STANDALONE_SUBCA:
            ids = IDS_CATYPE_DES_STANDALONE_SUBCA;
	    break;

        case ENUM_ENTERPRISE_ROOTCA:
            ids = IDS_CATYPE_DES_ENTERPRISE_ROOTCA;
	    break;

        case ENUM_ENTERPRISE_SUBCA:
            ids = IDS_CATYPE_DES_ENTERPRISE_SUBCA;
	    break;
    }

    // load description from resource
    hr = myLoadRCString(pComp->hInstance, ids, &pwszDesc);
    _JumpIfError(hr, error, "myLoadRCString");

    // change text
    SetWindowText(GetDlgItem(hDlg, IDC_CATYPE_CA_DESCRIPTION), pwszDesc);

    hr = S_OK;
error:
    if (NULL != pwszDesc)
    {
        LocalFree(pwszDesc);
    }
    return hr;
}


HRESULT
InitCATypeWizControls(
    HWND    hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT    hr;
    int        idc;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    EnableWindow(GetDlgItem(hDlg, IDC_CATYPE_ENT_ROOT_CA), pServer->fUseDS);
    EnableWindow(GetDlgItem(hDlg, IDC_CATYPE_ENT_SUB_CA), pServer->fUseDS);
    ShowWindow(GetDlgItem(hDlg, IDC_CATYPE_DESCRIPTION_ENTERPRISE),
        !pServer->fUseDS);
    EnableWindow(GetDlgItem(hDlg, IDC_CATYPE_STAND_ROOT_CA), TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_CATYPE_STAND_SUB_CA), TRUE);
    if (pServer->fUseDS)
    {
        if (ENUM_ENTERPRISE_SUBCA == pServer->CAType)
        {
            idc = IDC_CATYPE_ENT_SUB_CA;
        }
        else
        {
            idc = IDC_CATYPE_ENT_ROOT_CA;
        }
    }
    else
    {
        idc = IDC_CATYPE_STAND_ROOT_CA;
    }
    SendMessage(GetDlgItem(hDlg, idc), BM_CLICK, (WPARAM)0, (LPARAM)0);

    hr = UpdateCADescription(hDlg, pComp);
    _JumpIfError(hr, error, "UpdateCADescription");

error:
    return hr;
}

BOOL
IsRadioControlChecked(HWND hwnd)
{
    BOOL checked = FALSE;
    if (BST_CHECKED == SendMessage(hwnd, BM_GETCHECK, (WPARAM)0, (LPARAM)0))
    {
        checked = TRUE;
    }
    return checked;
}

HRESULT
HandleAdvanceChange(CASERVERSETUPINFO *pServer)
{
    HRESULT  hr;

    if (!pServer->fAdvance)
    {
        // if not advance, clear all advance flags
        pServer->fPreserveDB = FALSE;
        ClearExistingCertToUse(pServer);
    }

    hr = S_OK;
//error:
    return hr;
}

HRESULT
HandleCATypeChange(
    IN HWND hDlg, 
    IN PER_COMPONENT_DATA *pComp,
    IN ENUM_CATYPES eNewType)
{
    HRESULT  hr;
    BOOL bCertOK;
    CASERVERSETUPINFO * pServer=pComp->CA.pServer;

    pServer->CAType = eNewType;

    pServer->dwKeyLength = IsRootCA(pServer->CAType)?
        CA_DEFAULT_KEY_LENGTH_ROOT:
        CA_DEFAULT_KEY_LENGTH_SUB;

    hr = UpdateCADescription(hDlg, pComp);
    _JumpIfError(hr, error, "UpdateCADescription");

    // make sure that if we are using an existing cert, we didn't make it invalid.
    if (NULL!=pServer->pccExistingCert) {
        hr = IsCertSelfSignedForCAType(pServer, pServer->pccExistingCert, &bCertOK);
        _JumpIfError(hr, error, "UpdateCADescription");
        if (FALSE==bCertOK) {
            // can't use this cert with this CA type.
            ClearExistingCertToUse(pServer);
        }
    }

    hr = S_OK;

error:
    return hr;
}

HRESULT
HandleCATypeWizActive(
    HWND hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;

    // first of all, get install status
    hr = UpdateSubComponentInstallStatus(wszCERTSRVSECTION, wszSERVERSECTION, pComp);
    _JumpIfError(hr, error, "UpdateSubComponentInstallStatus");
    hr = UpdateSubComponentInstallStatus(wszCERTSRVSECTION, wszCLIENTSECTION, pComp);
    _JumpIfError(hr, error, "UpdateSubComponentInstallStatus");

    // Suppress this wizard page if
    // we've already seen an error, or
    // we are not installing the server.

    if (!(IS_SERVER_INSTALL & pComp->dwInstallStatus) )
    {
        // disable page
        CSILOGDWORD(IDS_CATYPE_TITLE, dwWIZDISABLE);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
        goto done;
    }
done:
    hr = S_OK;
error:
    return hr;
}

//+------------------------------------------------------------------------
//  Function:   WizCATypePageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure for CA Type wiz-page
//-------------------------------------------------------------------------

INT_PTR
WizCATypePageDlgProc(
    HWND hDlg,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PER_COMPONENT_DATA *pComp = NULL;
    static fDisplayed = false;

    switch (iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            (ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)(ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam;
        _ReturnIfWizError(pComp->hrContinue);
        pComp->hrContinue = InitCATypeWizControls(hDlg, pComp);
        _ReturnIfWizError(pComp->hrContinue);

        CSILOGDWORD(IDS_ENTERPRISE_UNAVAIL_REASON, 
            pComp->CA.pServer->EnterpriseUnavailReason);
        break;

    case WM_SHOWWINDOW:
        pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
        if(!fDisplayed &&
           ENUM_ENTERPRISE_UNAVAIL_REASON_OLD_DS_VERSION == 
           pComp->CA.pServer->EnterpriseUnavailReason)
        {
            fDisplayed = true;
            CertWarningMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hDlg,
                IDS_WRN_OLD_DS_VERSION,
                0,
                NULL);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CATYPE_STAND_ROOT_CA:
            if (IsRadioControlChecked((HWND)lParam))
            {
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleCATypeChange(hDlg,
                                        pComp, ENUM_STANDALONE_ROOTCA);
                _ReturnIfWizError(pComp->hrContinue);
            }
            break;

        case IDC_CATYPE_STAND_SUB_CA:
            if (IsRadioControlChecked((HWND)lParam))
            {
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleCATypeChange(hDlg,
                                        pComp, ENUM_STANDALONE_SUBCA);
                _ReturnIfWizError(pComp->hrContinue);
            }
            break;

        case IDC_CATYPE_ENT_ROOT_CA:
            if (IsRadioControlChecked((HWND)lParam))
            {
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleCATypeChange(hDlg,
                                        pComp, ENUM_ENTERPRISE_ROOTCA);
                _ReturnIfWizError(pComp->hrContinue);
            }
            break;

        case IDC_CATYPE_ENT_SUB_CA:
            if (IsRadioControlChecked((HWND)lParam))
            {
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleCATypeChange(hDlg,
                                        pComp, ENUM_ENTERPRISE_SUBCA);
                _ReturnIfWizError(pComp->hrContinue);
            }
            break;

        case IDC_CATYPE_CHECK_ADVANCE:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->CA.pServer->fAdvance = !pComp->CA.pServer->fAdvance;
            pComp->hrContinue = HandleAdvanceChange(pComp->CA.pServer);
            _ReturnIfWizError(pComp->hrContinue);
            break;
        }
        break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
            case PSN_KILLACTIVE:
                break;

            case PSN_RESET:
                break;
            case PSN_QUERYCANCEL:
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                return CertConfirmCancel(hDlg, pComp);
                break;

            case PSN_SETACTIVE:
                CSILOGDWORD(IDS_CATYPE_TITLE, dwWIZACTIVE);
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
                pComp = _GetCompDataOrReturn(pComp, hDlg);
                _DisableWizDisplayIfError(pComp, hDlg);
                _ReturnIfWizError(pComp->hrContinue);
                pComp->hrContinue = HandleCATypeWizActive(hDlg, pComp);
                _ReturnIfWizError(pComp->hrContinue);
                break;

            case PSN_WIZBACK:
                CSILOGDWORD(IDS_CATYPE_TITLE, dwWIZBACK);
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->CA.pServer->LastWiz = ENUM_WIZ_CATYPE;
                break;

            case PSN_WIZNEXT:
                CSILOGDWORD(IDS_CATYPE_TITLE, dwWIZNEXT);
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->CA.pServer->LastWiz = ENUM_WIZ_CATYPE;
                CSILOGDWORD(IDS_LOG_CATYPE, pComp->CA.pServer->CAType);
                pComp->hrContinue = InitNameFields(pComp->CA.pServer);
                _ReturnIfWizError(pComp->hrContinue);
                break;
            default:
                return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);
            }
            break;

    default:
        return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);
    }
    return TRUE;
}


//+---------------------------------------------------------------------------
//  Description:    display existing keys from list
//----------------------------------------------------------------------------

HRESULT
ShowExistingKey(
    IN HWND      hDlg,
    KEY_LIST    *pKeyList)
{
    HRESULT   hr;
    KEY_LIST *pKey = pKeyList;
    HWND hKeyList = GetDlgItem(hDlg, IDC_ADVANCE_KEYLIST);
    LRESULT nItem;
    LRESULT lr;
    WCHAR   *pwszDeSanitize = NULL;

    while (NULL != pKey)
    {
        if (NULL != pKey->pwszName)
        {
            if (NULL != pwszDeSanitize)
            {
                LocalFree(pwszDeSanitize);
                pwszDeSanitize = NULL;
            }
            hr = myRevertSanitizeName(pKey->pwszName, &pwszDeSanitize);
            _JumpIfError(hr, error, "myRevertSanitizeName");

            nItem = (INT)SendMessage(
                hKeyList,
                LB_ADDSTRING,
                (WPARAM) 0,
                (LPARAM) pwszDeSanitize);
            if (LB_ERR == nItem)
            {
                hr = myHLastError();
                _JumpError(hr, error, "SendMessage");
            }
            lr = (INT)SendMessage(
                hKeyList,
                LB_SETITEMDATA,
                (WPARAM) nItem,
                (LPARAM) pKey->pwszName);
            if (LB_ERR == lr)
            {
                hr = myHLastError();
                _JumpError(hr, error, "SendMessage");
            }
        }
        pKey = pKey->next;
    }
    if (NULL != pKeyList)
    {
        // choose the 1st one as default
        lr = (INT)SendMessage(hKeyList, LB_SETCURSEL, (WPARAM) 0, (LPARAM) 0);
        if (LB_ERR == lr)
        {
            hr = myHLastError();
            _JumpError(hr, error, "SendMessage");
        }
    }

    hr = S_OK;
error:
    if (NULL != pwszDeSanitize)
    {
        LocalFree(pwszDeSanitize);
    }
    return hr;
}


//+---------------------------------------------------------------------------
//  Description:    hilight an item by matched data
//----------------------------------------------------------------------------
HRESULT
HilightItemInList(HWND hDlg, int id, VOID const *pData, BOOL fString)
{
    HWND     hListCtrl = GetDlgItem(hDlg, id);
    LRESULT  iItem;
    LRESULT  count;
    VOID    *pItemData;
    HRESULT  hr = NTE_NOT_FOUND;

    // find item
    if (fString)
    {
        iItem = (INT)SendMessage(
                hListCtrl,
                LB_FINDSTRING,
                (WPARAM) 0,
                (LPARAM) pData);
        if (LB_ERR == iItem)
        {
            _JumpError(hr, error, "SendMessage");
        }
        hr = S_OK;
    }
    else
    {
        count = (INT)SendMessage(hListCtrl, LB_GETCOUNT, (WPARAM)0, (LPARAM)0);
        for (iItem = 0; iItem < count; ++iItem)
        {
            pItemData = (VOID*)SendMessage(hListCtrl, LB_GETITEMDATA,
                                   (WPARAM)iItem, (LPARAM)0);
            if (pItemData == pData)
            {
                hr = S_OK;
                break;
            }
        }
    }
    if (S_OK != hr)
    {
        _JumpError(hr, error, "not found");
    }

    // hilight it
    SendMessage(hListCtrl, LB_SETCURSEL, (WPARAM)iItem, (LPARAM)0);

    hr = S_OK;
error:
    return hr;
}

HRESULT
ShowAllCSP(
    HWND        hDlg,
    CSP_INFO   *pCSPInfo)
{
    HWND     hCSPList = GetDlgItem(hDlg, IDC_ADVANCE_CSPLIST);
    LRESULT  nItem;

    // list all of csps
    while (pCSPInfo)
    {
        if (pCSPInfo->pwszProvName)
        {
            nItem = (INT)SendMessage(hCSPList, LB_ADDSTRING, 
                (WPARAM)0, (LPARAM)pCSPInfo->pwszProvName);
            SendMessage(hCSPList, LB_SETITEMDATA, 
                (WPARAM)nItem, (LPARAM)pCSPInfo);
        }
        pCSPInfo = pCSPInfo->next;
    }

    return S_OK;
}

HRESULT
ShowAllHash(
    HWND      hDlg,
    CSP_HASH *pHashInfo)
{
    HWND     hHashList = GetDlgItem(hDlg, IDC_ADVANCE_HASHLIST);
    LRESULT  nItem;

    // remove hash of previous csp from list
    while (SendMessage(hHashList, LB_GETCOUNT, 
                     (WPARAM)0, (LPARAM)0))
    {
        SendMessage(hHashList, LB_DELETESTRING, 
                             (WPARAM)0, (LPARAM)0);
    }

    // list all hash
    while (NULL != pHashInfo)
    {
        if (NULL != pHashInfo->pwszName)
        {
            nItem = (INT)SendMessage(hHashList, LB_ADDSTRING,
                (WPARAM)0, (LPARAM)pHashInfo->pwszName);
            SendMessage(hHashList, LB_SETITEMDATA,
                (WPARAM)nItem, (LPARAM)pHashInfo);
        }
        pHashInfo = pHashInfo->next;
    }

    return S_OK;
}

//--------------------------------------------------------------------
HRESULT
UpdateUseCertCheckbox(
    HWND               hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    BOOL bUsingExistingCert;

    if (NULL==pServer->pccExistingCert) {
        bUsingExistingCert=FALSE;
    } else {
        bUsingExistingCert=TRUE;
    }

    // check "use cert" control
    SendMessage(GetDlgItem(hDlg, IDC_ADVANCE_USECERTCHECK),
                BM_SETCHECK,
                (WPARAM)(bUsingExistingCert?BST_CHECKED:BST_UNCHECKED),
                (LPARAM)0);

    // enable the "View Cert" button if necessary
    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCE_VIEWCERT), bUsingExistingCert);

    // we will match the hash alg used by the cert, if possible
    hr = HilightItemInList(hDlg, IDC_ADVANCE_HASHLIST,
             pServer->pHashInfo, FALSE);
    _JumpIfError(hr, error, "HilightItemInList");

error:
    return hr;
}


HRESULT
FindCertificateByKeyWithWaitCursor(
    IN CASERVERSETUPINFO *pServer,
    OUT CERT_CONTEXT const **ppccCert)
{
    HRESULT hr;
    HCURSOR hPrevCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    hr = FindCertificateByKey(pServer, ppccCert);
    SetCursor(hPrevCur);
    _JumpIfError(hr, error, "FindCertificateByKey");

error:
    return(hr);
}


//--------------------------------------------------------------------
// handle the "Use existing Cert" checkbox
HRESULT
HandleUseCertCheckboxChange(
    HWND               hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    CERT_CONTEXT const * pccCert;

    if(pServer->pwszFullCADN)
    {
        LocalFree(pServer->pwszFullCADN);
        pServer->pwszFullCADN = NULL;
    }

    // is the checkbox checked or unchecked?
    if (BST_CHECKED==IsDlgButtonChecked(hDlg, IDC_ADVANCE_USECERTCHECK)) {

        // checkbox was just checked, so we previously were not using an existing cert
        CSASSERT(NULL==pServer->pccExistingCert);

        // Find the existing cert for this key
        hr = FindCertificateByKeyWithWaitCursor(pServer, &pccCert);
        _JumpIfError(hr, error, "FindCertificateByKeyWithWaitCursor");

        // use it
        hr = SetExistingCertToUse(pServer, pccCert);
        _JumpIfError(hr, error, "SetExistingCertToUse");

    } else {

        // checkbox was just unchecked, so we previously were using an existing cert.
        CSASSERT(NULL!=pServer->pccExistingCert);

        // stop using the cert
        ClearExistingCertToUse(pServer);
    }

    hr = UpdateUseCertCheckbox(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateUseCertCheckbox");

error:
    return hr;
}


//----------------------------------------------------------------------------
// Hilight the current key - don't use HilightItemInList because we
// must use string-compare on the data portion, and HilightItemInList does not
// support this.
HRESULT
HilightKeyInList(HWND hDlg, CASERVERSETUPINFO * pServer)
{
    HWND hListCtrl=GetDlgItem(hDlg, IDC_ADVANCE_KEYLIST);
    LRESULT nIndex;
    LRESULT nTotNames;
    WCHAR * pwszKeyContainerName;
    HRESULT  hr = NTE_NOT_FOUND;

    nTotNames=(INT)SendMessage(hListCtrl, LB_GETCOUNT, (WPARAM)0, (LPARAM)0);
    for (nIndex=0; nIndex<nTotNames; nIndex++) {
        pwszKeyContainerName=(WCHAR *)SendMessage(hListCtrl, LB_GETITEMDATA, (WPARAM)nIndex, (LPARAM)0);
        if (0==wcscmp(pwszKeyContainerName, pServer->pwszKeyContainerName)) {
            SendMessage(hListCtrl, LB_SETCURSEL, (WPARAM)nIndex, (LPARAM)0);
            hr = S_OK;
            break;
        }
    }

    if (S_OK != hr)
    {
        // can lead to dead wiz pages
        CSILOG(
                hr,
                IDS_LOG_KEY_NOT_FOUND_IN_LIST,
                pServer->pwszKeyContainerName,
                NULL,
                NULL);
        _PrintErrorStr(hr, "not found", pServer->pwszKeyContainerName);
    }

    hr = S_OK;
//error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT
UpdateKeySelection(
    HWND            hDlg,
    CASERVERSETUPINFO  *pServer)
{
    HRESULT hr;
    BOOL bAvailableExistingCert = FALSE;
    CERT_CONTEXT const * pccCert;

    // if we have an existing key, make sure it is the one hilighted
    // in the list and check for coresponding certs.
    if (NULL!=pServer->pwszKeyContainerName) {

        // hilight key
        hr = HilightKeyInList(hDlg, pServer);
        _JumpIfError(hr, error, "HilightKeyInList");

        if (NULL!=pServer->pccExistingCert) {
            // we are using an existing cert, so it better exist!
            bAvailableExistingCert = TRUE;
        } else {
            // see if there is an existing cert for this key
            hr = FindCertificateByKeyWithWaitCursor(pServer, &pccCert);
            if (S_OK==hr) {
                CertFreeCertificateContext(pccCert);
                bAvailableExistingCert = TRUE;
            } else {
                // only other return is 'not found'
                CSASSERT(CRYPT_E_NOT_FOUND==hr);
            }
        }

    } else {
        // no key selected, can't have an existing cert
    }

    // enable/disable reuse cert...
    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCE_USECERTCHECK), bAvailableExistingCert);

    hr = UpdateUseCertCheckbox(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateUseCertCheckbox");

error:
    return hr;
}


//--------------------------------------------------------------------
HRESULT
UpdateUseKeyCheckbox(
    HWND               hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    BOOL bReuseKey;

    if (NULL==pServer->pwszKeyContainerName) {
        // we are creating a new key
        bReuseKey=FALSE;
    } else {
        // we are using an existing key
        bReuseKey=TRUE;
    }

    // check/uncheck the checkbox depending upon whether we are reusing a key
    SendDlgItemMessage(hDlg,
        IDC_ADVANCE_USEKEYCHECK,
        BM_SETCHECK,
        (WPARAM)(bReuseKey?BST_CHECKED:BST_UNCHECKED),
        (LPARAM)0);

    // enable the key list if we are reusing a key
    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCE_KEYLIST), bReuseKey);

    // disable the key length box if we are reusing a key
    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCE_KEY_LENGTH), !bReuseKey);

    hr = UpdateKeySelection(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateKeySelection");

error:
    return hr;
}

//+---------------------------------------------------------------------------
//  Description:    update hash alg. list if csp selection changes
//----------------------------------------------------------------------------
HRESULT
UpdateHashList(
    HWND                hDlg,
    CASERVERSETUPINFO  *pServer)
{
    HRESULT  hr;

    // load new hash list
    hr = ShowAllHash(hDlg, pServer->pCSPInfo->pHashList);
    _JumpIfError(hr, error, "ShowAllHash");

    hr = HilightItemInList(hDlg, IDC_ADVANCE_HASHLIST,
             pServer->pHashInfo, FALSE);
    _JumpIfError(hr, error, "HilightItemInList");

    hr = S_OK;
error:
    return hr;
}

//+---------------------------------------------------------------------------
//  Description:    update key list if csp selection changes
//----------------------------------------------------------------------------
HRESULT
UpdateKeyList(
    HWND           hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    HWND hKeyList;
    HCURSOR hPrevCur;

    // remove keys of previous csp from list

    hKeyList = GetDlgItem(hDlg, IDC_ADVANCE_KEYLIST);
    while (SendMessage(hKeyList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0))
    {
        SendMessage(hKeyList, LB_DELETESTRING, (WPARAM) 0, (LPARAM) 0);
    }

    // update key list with new CSP

    if (NULL != pServer->pKeyList)
    {
        csiFreeKeyList(pServer->pKeyList);
    }

    hPrevCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    hr = csiGetKeyList(
                pServer->pCSPInfo->dwProvType,
                pServer->pCSPInfo->pwszProvName,
                pServer->pCSPInfo->fMachineKeyset,
                TRUE,                  // fSilent
                &pServer->pKeyList);
    SetCursor(hPrevCur);
    if (S_OK != hr)
    {
        _PrintError(hr, "csiGetKeyList");
        // don't fail setup if only no key update
        //goto done;
    }

    // show keys
    if (NULL != pServer->pKeyList)
    {
        hr = ShowExistingKey(hDlg, pServer->pKeyList);
        _JumpIfError(hr, error, "ShowExistingKey");
    }

    if (NULL == pServer->pKeyList) {
        // no existing key for the csp, so disable "use existing key" checkbox
        EnableWindow(GetDlgItem(hDlg, IDC_ADVANCE_USEKEYCHECK), FALSE);
        CSASSERT(NULL==pServer->pwszKeyContainerName);
    } else {
        EnableWindow(GetDlgItem(hDlg, IDC_ADVANCE_USEKEYCHECK), TRUE);
    }

    hr = UpdateUseKeyCheckbox(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateUseKeyCheckbox");

//done:
    hr = S_OK;
error:
    return(hr);
}


DWORD g_adwKeyLengths[] =
{
    512,
    1024,
    2048,
    4096,
};

DWORD g_adwKeyLengthsSmall[] =
{
    128,
    256,
    512,
    1024,
};

HRESULT
AddPredefinedKeyLength
(
    HWND   hwnd,
    DWORD  dwKeyLength)
{
    HRESULT    hr;
    WCHAR  wszKeyLength[MAX_KEYLENGTHDIGIT + 1];
    WCHAR  const *pwszKeyLength;
    LRESULT nIndex;

    CSASSERT(0 != dwKeyLength);
    wsprintf(wszKeyLength, L"%u", dwKeyLength);
    pwszKeyLength = wszKeyLength;

    nIndex = (INT)SendMessage(hwnd, CB_ADDSTRING, (WPARAM)0, (LPARAM)pwszKeyLength);
    if (CB_ERR == nIndex)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "SendMessage(CB_ADDSTRING)");
    }
    SendMessage(hwnd, CB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)dwKeyLength);

    hr = S_OK;
error:
    return hr;
}

HRESULT
ShowAllKeyLength(
    HWND            hDlg,
    CASERVERSETUPINFO  *pServer)
{
    HRESULT hr;
    HWND hwndCtrl = GetDlgItem(hDlg, IDC_ADVANCE_KEY_LENGTH);
    WCHAR  wszKeyLength[MAX_KEYLENGTHDIGIT + 1];
    DWORD *pdw;
    DWORD *pdwEnd;

    // remove existing key length list
    while (SendMessage(hwndCtrl, CB_GETCOUNT, (WPARAM) 0, (LPARAM) 0))
    {
        SendMessage(hwndCtrl, CB_DELETESTRING, (WPARAM) 0, (LPARAM) 0);
    }

    CSASSERT(0 != pServer->dwKeyLength);

    if(pServer->dwKeyLength > pServer->dwKeyLenMax)
    {
        pServer->dwKeyLength=pServer->dwKeyLenMax;
    }

    wsprintf(wszKeyLength, L"%u", pServer->dwKeyLength);
    SetWindowText(hwndCtrl, wszKeyLength);

    pdw = g_adwKeyLengths;
    pdwEnd = &g_adwKeyLengths[ARRAYSIZE(g_adwKeyLengths)];

    if (C_CSPHASNOKEYMINMAX != pServer->dwKeyLenMin &&
        C_CSPHASNOKEYMINMAX != pServer->dwKeyLenMax &&
        g_adwKeyLengthsSmall[ARRAYSIZE(g_adwKeyLengthsSmall) - 1] >=
        pServer->dwKeyLenMax)
    {
        pdw = g_adwKeyLengthsSmall;
        pdwEnd = &g_adwKeyLengthsSmall[ARRAYSIZE(g_adwKeyLengthsSmall)];
    }

    // show new key length list
    for ( ; pdw < pdwEnd; pdw++)
    {
        if (0 == *pdw ||
            ((C_CSPHASNOKEYMINMAX != pServer->dwKeyLenMin &&
              *pdw >= pServer->dwKeyLenMin) && 
             (C_CSPHASNOKEYMINMAX != pServer->dwKeyLenMax &&
              *pdw <= pServer->dwKeyLenMax)) )
        {
            hr = AddPredefinedKeyLength(hwndCtrl, *pdw);
            _JumpIfError(hr, error, "AddPredefinedKeyLength");
        }
    }
    hr = S_OK;

error:
    return hr;
}


HRESULT
UpdateKeyLengthMinMax(
    HWND                hDlg,
    CASERVERSETUPINFO  *pServer)
{
    HRESULT     hr;
    HCRYPTPROV  hProv = NULL;
    CSP_INFO   *pCSPInfo = pServer->pCSPInfo;
    PROV_ENUMALGS_EX paramData;
    DWORD       cbData;
    DWORD       dwFlags;

    // default that csp doesn't support PP_ENUMALGS_EX
    pServer->dwKeyLenMin = C_CSPHASNOKEYMINMAX;
    pServer->dwKeyLenMax = C_CSPHASNOKEYMINMAX;

    // determine the min and max key length for selected csp
    if (!myCertSrvCryptAcquireContext(
                &hProv,
                NULL,
                pCSPInfo->pwszProvName,
                pCSPInfo->dwProvType,
                CRYPT_VERIFYCONTEXT,
                FALSE))
    {
        hr = myHLastError();
        if (NULL != hProv)
        {
            hProv = NULL;
            _PrintError(hr, "CSP returns a non-null handle");
        }
        _JumpErrorStr(hr, error, "myCertSrvCryptAcquireContext", pCSPInfo->pwszProvName);
    }

    dwFlags = CRYPT_FIRST;
    for (;;)
    {
        cbData = sizeof(paramData);
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMALGS_EX,
                (BYTE *) &paramData,
                &cbData,
                dwFlags))
        {
            hr = myHLastError();
            if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
            {
                // out of for loop
                break;
            }
            _JumpError(hr, error, "CryptGetProvParam");
        }
        if (ALG_CLASS_SIGNATURE == GET_ALG_CLASS(paramData.aiAlgid))
        {
            pServer->dwKeyLenMin = paramData.dwMinLen;
            pServer->dwKeyLenMax = paramData.dwMaxLen;
            break;
        }
	dwFlags = 0;
    }

error:
    hr = ShowAllKeyLength(hDlg, pServer);
    _PrintIfError(hr, "ShowAllKeyLength");

    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    return(S_OK);
}


HRESULT
InitializeKeyLengthControl(HWND hDlg)
{
    HWND hwndCtrl = GetDlgItem(hDlg, IDC_ADVANCE_KEY_LENGTH);

    // set digit length

    SendMessage(
            hwndCtrl,
            CB_LIMITTEXT,
            (WPARAM) MAX_KEYLENGTHDIGIT,
            (LPARAM) 0);

    return S_OK;
}



//--------------------------------------------------------------------
HRESULT
HandleKeySelectionChange(
    HWND                hDlg,
    CASERVERSETUPINFO  *pServer,
    BOOL                fUpdate)
{
    HRESULT  hr;
    HWND     hKeyList = GetDlgItem(hDlg, IDC_ADVANCE_KEYLIST);
    WCHAR * pwszKeyContainerName;
    CERT_CONTEXT const * pccCert;

    LRESULT nItem = (INT)SendMessage(
                         hKeyList,
                         LB_GETCURSEL,
                         (WPARAM) 0,
                         (LPARAM) 0);
   CSASSERT(LB_ERR!=nItem);

    pwszKeyContainerName = (WCHAR *) SendMessage(
        hKeyList, 
        LB_GETITEMDATA,
        (WPARAM) nItem,
        (LPARAM) 0);
    CSASSERT(NULL!=pwszKeyContainerName);

    // Only change is this is a different selection
    if (NULL==pServer->pwszKeyContainerName ||
        0!=wcscmp(pwszKeyContainerName, pServer->pwszKeyContainerName)) {

        // Set the container name to match what the user picked.
        BOOL fKeyListChange=pServer->fDeletableNewKey;
        hr = SetKeyContainerName(pServer, pwszKeyContainerName);
        _JumpIfError(hr, error, "SetKeyContainerName");

        // see if there is an existing cert for this key
        hr = FindCertificateByKeyWithWaitCursor(pServer, &pccCert);
        if (S_OK==hr) {
            // Yes there is. By default, use it.
            hr = SetExistingCertToUse(pServer, pccCert);
            _JumpIfError(hr, error, "SetExistingCertToUse");
        } else {
            // only other return is 'not found'
            CSASSERT(CRYPT_E_NOT_FOUND==hr);
        }

        // check to see if our caller wants us to update.
        // our caller may want to do the update himself.
        if (fUpdate) {
            // perform the minimum necessary update
            if (fKeyListChange) {
                hr = UpdateKeyList(hDlg, pServer);
                _JumpIfError(hr, error, "UpdateKeyList");
            } else {
                hr = UpdateKeySelection(hDlg, pServer);
                _JumpIfError(hr, error, "UpdateKeySelection");
            }
        }
    }
    hr = S_OK;

error:
    return hr;
}

//--------------------------------------------------------------------
// handle the "Use existing Key" checkbox
HRESULT
HandleUseKeyCheckboxChange(
    HWND               hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    static bool fNT4CertCopiedAlready = false;

    if(pServer->pwszFullCADN)
    {
        LocalFree(pServer->pwszFullCADN);
        pServer->pwszFullCADN = NULL;
    }

    if(pServer->pwszCACommonName)
    {
        LocalFree(pServer->pwszCACommonName);
        pServer->pwszCACommonName = NULL;
    }

    if(pServer->pwszDNSuffix)
    {
        LocalFree(pServer->pwszDNSuffix);
        pServer->pwszDNSuffix = NULL;
    }

    // is the checkbox checked or unchecked?
    if (BST_CHECKED==IsDlgButtonChecked(hDlg, IDC_ADVANCE_USEKEYCHECK)) {

        // checkbox was just checked, so we previously did not have a chosen key.
        CSASSERT(NULL==pServer->pwszKeyContainerName);

        hr = HandleKeySelectionChange(hDlg, pServer, FALSE); // don't update, because we need to update too.
        _JumpIfError(hr, error, "HandleKeySelectionChange");

        hr = UpdateUseKeyCheckbox(hDlg, pServer);
        _JumpIfError(hr, error, "UpdateUseKeyCheckbox");

    } else {

        // checkbox was just unchecked, so we previously had a chosen key..
        CSASSERT(NULL!=pServer->pwszKeyContainerName);

        BOOL fKeyListChange=pServer->fDeletableNewKey;
        ClearKeyContainerName(pServer);

        // perform the minimum necessary update
        if (fKeyListChange) {
            hr = UpdateKeyList(hDlg, pServer);
            _JumpIfError(hr, error, "UpdateKeyList");
        } else {
            hr = UpdateUseKeyCheckbox(hDlg, pServer);
            _JumpIfError(hr, error, "UpdateUseKeyCheckbox");
        }
        
        hr = InitNameFields(pServer);
        _JumpIfError(hr, error, "InitNameFields");
    }


error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT
UpdateCSPSelection(
    HWND                hDlg,
    CASERVERSETUPINFO  *pServer)
{
    HRESULT hr;
    bool fInteractiveOff;

    if (NULL == pServer->pCSPInfo)
    {
       hr = E_POINTER;
       _JumpError(hr, error, "NULL pCSPInfo");
    }

    // hilight current CSP
    hr = HilightItemInList(hDlg,
                    IDC_ADVANCE_CSPLIST,
                    pServer->pCSPInfo->pwszProvName,
                    TRUE);
    _JumpIfError(hr, error, "HilightItemInList");

    hr = UpdateHashList(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateHashList");

    hr = UpdateKeyLengthMinMax(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateKeyLengthMinMax");

    hr = UpdateKeyList(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateKeyList");

    // Update "interact with desktop" flag. For default CSP
    // we turn it off, otherwise turn it on.
    CSASSERT(pServer->pCSPInfo &&
        pServer->pDefaultCSPInfo&&
        pServer->pCSPInfo->pwszProvName &&
        pServer->pDefaultCSPInfo->pwszProvName);
    
    fInteractiveOff =
        (0 == mylstrcmpiL(pServer->pCSPInfo->pwszProvName,
                     pServer->pDefaultCSPInfo->pwszProvName) &&
        (pServer->pCSPInfo->dwProvType == pServer->pDefaultCSPInfo->dwProvType));

    SendMessage(
            GetDlgItem(hDlg, IDC_ADVANCE_INTERACTIVECHECK),
            BM_SETCHECK,
            (WPARAM)(fInteractiveOff?BST_UNCHECKED:BST_CHECKED),
            (LPARAM)0);

    if(fInteractiveOff)
    {
        WCHAR  wszKeyLength[MAX_KEYLENGTHDIGIT + 1];

        wsprintf(wszKeyLength, L"%u", 
                IsRootCA(pServer->CAType)?
                CA_DEFAULT_KEY_LENGTH_ROOT:
                CA_DEFAULT_KEY_LENGTH_SUB);

        SetWindowText(
            GetDlgItem(hDlg, IDC_ADVANCE_KEY_LENGTH), 
            wszKeyLength);
    }

    hr = S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT
HandleCSPSelectionChange(
    HWND                hDlg,
    CASERVERSETUPINFO  *pServer)
{
    HRESULT hr = S_OK;
    HWND     hCSPList;
    LRESULT  nItem;
    CSP_INFO * pCSPInfo;

    // get current csp
    hCSPList = GetDlgItem(hDlg, IDC_ADVANCE_CSPLIST);
    nItem = (INT)SendMessage(hCSPList, LB_GETCURSEL, 
                          (WPARAM)0, (LPARAM)0);
    pCSPInfo = (CSP_INFO *)SendMessage(hCSPList, 
           LB_GETITEMDATA, (WPARAM)nItem, (LPARAM)0);

    // only change if this is a different selection
    if (pCSPInfo->dwProvType!=pServer->pCSPInfo->dwProvType ||
        0!=wcscmp(pCSPInfo->pwszProvName, pServer->pCSPInfo->pwszProvName)) {

        // Must create a new key if the CSP changes
        ClearKeyContainerName(pServer);

        pServer->pCSPInfo=pCSPInfo;

        hr = DetermineDefaultHash(pServer);
        _JumpIfError(hr, error, "DetermineDefaultHash");

        hr = UpdateCSPSelection(hDlg, pServer);
        _JumpIfError(hr, error, "UpdateCSPSelection");
    }

error:
    return hr;
}

// Update cascade:
//
// UpdateCSPSelection
// |-UpdateHashList
// |-UpdateKeyLengthMinMax
// \-UpdateKeyList
//   \-UpdateUseKeyCheckbox
//     \-UpdateKeySelection
//       \-UpdateUseCertCheckbox

HRESULT
InitAdvanceWizPageControls(
    HWND                hDlg)
{
    HRESULT  hr;

    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCE_INTERACTIVECHECK), TRUE);

    hr = S_OK;
//error:
    return hr;
}

HRESULT
HandleHashSelectionChange(
    HWND           hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT  hr;
    HWND hHashList = GetDlgItem(hDlg, IDC_ADVANCE_HASHLIST);
 
    LRESULT nItem = (INT)SendMessage(
                        hHashList,
                        LB_GETCURSEL, 
                        (WPARAM) 0,
                        (LPARAM) 0);

    pServer->pHashInfo = (CSP_HASH*)SendMessage(
        hHashList,
        LB_GETITEMDATA,
        (WPARAM) nItem,
        (LPARAM) 0);

    // Must validate the hash again when the selected hash changes
    pServer->fValidatedHashAndKey = FALSE;

    hr = S_OK;
//error:
    return hr;
}

HRESULT
HandleKeyLengthSelectionChange(
    HWND               hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT  hr;
    HWND hwndCtrl = GetDlgItem(hDlg, IDC_ADVANCE_KEY_LENGTH);

    LRESULT nItem = (INT)SendMessage(hwndCtrl, CB_GETCURSEL,
                                (WPARAM)0, (LPARAM)0);
    pServer->dwKeyLength = (DWORD)SendMessage(hwndCtrl,
                                      CB_GETITEMDATA,
                                      (WPARAM)nItem, (LPARAM)0);

    // If key length chenges, we must not have created a key yet.
    CSASSERT(NULL==pServer->pwszKeyContainerName);

    hr = S_OK;
//error:
    return hr;
}

// remove any non-numeric chars except default string
HRESULT
HandleKeyLengthEditChange(
    HWND               hwndComboBox)
{
    HRESULT  hr;
    WCHAR    wszKeyLength[MAX_KEYLENGTHEDIT];
    int      index = 0; // index for new #
    int      posi = 0;  // current position

    wszKeyLength[0] = L'\0'; // PREFIX says initialize 
    GetWindowText(hwndComboBox, wszKeyLength, ARRAYSIZE(wszKeyLength));

    // remove non-numeric chars
    while (L'\0' != wszKeyLength[posi])
    {
        if (iswdigit(wszKeyLength[posi]))
        {
            // take digit
            wszKeyLength[index] = wszKeyLength[posi];
            ++index;
        }
        ++posi;
    }
    if (index != posi)
    {
        // null terminator
        wszKeyLength[index] = L'\0';
        // update
        SetWindowText(hwndComboBox, wszKeyLength);
        // point to end
        SendMessage(hwndComboBox, CB_SETEDITSEL, (WPARAM)0,
                MAKELPARAM((index), (index)) );
    }

    hr = S_OK;
//error:
    return hr;
}

HRESULT
HandleImportPFXButton(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    hr = ImportPFXAndUpdateCSPInfo(hDlg, pComp);
    _PrintIfError(hr, "ImportPFXAndUpdateCSPInfo");

    // ignore error and force update anyway.
    hr = UpdateCSPSelection(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateCSPSelection");

    hr = S_OK;
error:
    return hr;
}

HRESULT
HandleAdvanceWizNext(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    WCHAR    wszKeyLength[MAX_KEYLENGTHEDIT] = L"";
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    HWND hwndCtrl = GetDlgItem(hDlg, IDC_ADVANCE_KEY_LENGTH);
    BOOL     fDontNext = FALSE;
    WCHAR    wszKeyRange[2*MAX_KEYLENGTHDIGIT + 5]; //"(xxxx, xxxx)" format
    WCHAR   *pwszKeyRange = NULL; //don't free just a pointer
    int    dwKeyLength;
    int      idMsg;
    BOOL fValidDigitString;

    if (NULL == pServer->pwszKeyContainerName)
    {
        if(!GetWindowText(hwndCtrl, wszKeyLength, ARRAYSIZE(wszKeyLength)))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetWindowText");
        }

        dwKeyLength = myWtoI(wszKeyLength, &fValidDigitString);
	idMsg = 0;
        if (0 > dwKeyLength)
        {
            idMsg = IDS_ADVANCE_NEGATIVEKEYLENGTH;
            fDontNext = TRUE;
        }
        else if (!fValidDigitString)
        {
            idMsg = IDS_ADVANCE_INVALIDKEYLENGTH;
            fDontNext = TRUE;
        }
        else if ( (C_CSPHASNOKEYMINMAX != pServer->dwKeyLenMin &&
                   (DWORD)dwKeyLength < pServer->dwKeyLenMin) ||
                  (C_CSPHASNOKEYMINMAX != pServer->dwKeyLenMax &&
                   (DWORD)dwKeyLength > pServer->dwKeyLenMax) )
        {
            swprintf(wszKeyRange, L"(%ld, %ld)",
                     pServer->dwKeyLenMin, pServer->dwKeyLenMax);
            pwszKeyRange = wszKeyRange;
            idMsg = IDS_ADVANCE_KEYLENGTHOUTOFRANGE;
            fDontNext = TRUE;
        }
        if (fDontNext)
        {
            CertWarningMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hDlg,
                        idMsg,
                        0,
                        pwszKeyRange);
            SetEditFocusAndSelect(hwndCtrl, 0, MAXDWORD);
            goto done;
        }
        // take the length
        pServer->dwKeyLength = dwKeyLength;
    }
    else
    {
        // use existing key

        if (NULL==pServer->pccExistingCert)
        {
            // If reusing a key but not a cert, make the common name match the key name
            if (NULL != pServer->pwszCACommonName)
            {
                // free old
                LocalFree(pServer->pwszCACommonName);
                pServer->pwszCACommonName = NULL;
            }
            pServer->pwszCACommonName = (WCHAR*) LocalAlloc(LPTR,
                (wcslen(pServer->pwszDesanitizedKeyContainerName) + 1) * sizeof(WCHAR));
            _JumpIfOutOfMemory(hr, error, pServer->pwszCACommonName);
            wcscpy(pServer->pwszCACommonName, pServer->pwszDesanitizedKeyContainerName);

            hr = InitNameFields(pServer);
            _JumpIfError(hr, error, "InitNameFields");

        } else {

            // If reusing a cert, make all the ID fields match the cert
            // use idinfo from signing cert
            hr = DetermineExistingCAIdInfo(pServer, NULL);
            if (S_OK != hr)
            {
                CertWarningMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_ERR_ANALYSIS_CA,
                    hr,
                    NULL);
                _PrintError(hr, "DetermineExistingCAIdInfo");
                fDontNext = TRUE;
                goto done;
            }
        }
    }

    // get "interactive service" check box state
    pServer->fInteractiveService = 
        (BST_CHECKED == 
         SendMessage(GetDlgItem(hDlg, IDC_ADVANCE_INTERACTIVECHECK), 
         BM_GETCHECK, (WPARAM)0, (LPARAM)0))?
        TRUE:FALSE;

    // update hash oid
    if (NULL != pServer->pszAlgId)
    {
        // free old
        LocalFree(pServer->pszAlgId);
    }
    hr = myGetSigningOID(
		     NULL,	// hProv
		     pServer->pCSPInfo->pwszProvName,
		     pServer->pCSPInfo->dwProvType,
		     pServer->pHashInfo->idAlg,
		     &(pServer->pszAlgId));
    if (S_OK != hr)
    {
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg,
            IDS_ERR_UNSUPPORTEDHASH,
            hr,
            NULL);
        fDontNext = TRUE;
        goto done;
    }

done:
    if (fDontNext)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE); // forbid
    }
    else
    {
        pServer->LastWiz = ENUM_WIZ_ADVANCE;
    }
    hr = S_OK;
error:
    return hr;
}

HRESULT
HandleAdvanceWizActive(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    // Suppress this wizard page if
    // we've already seen an error, or
    // the advanced option was not selected, or
    // we are not installing the server.

    if (!pServer->fAdvance ||
        !(IS_SERVER_INSTALL & pComp->dwInstallStatus) )
    {
        // disable page
        CSILOGDWORD(IDS_ADVANCE_TITLE, dwWIZDISABLE);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
        goto done;
    }

    if (NULL == pServer->pCSPInfoList)
    {
        // construct CSP info list
        HCURSOR hPrevCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
        hr = GetCSPInfoList(&pServer->pCSPInfoList);
        SetCursor(hPrevCur);
        _JumpIfError(hr, error, "GetCSPInfoList");

        // show all csps
        hr = ShowAllCSP(hDlg, pServer->pCSPInfoList);
        _JumpIfError(hr, error, "ShowAllCSP");

        // determine default csp
        hr = DetermineDefaultCSP(pServer);
        _JumpIfError(hr, error, "DetermineDefaultCSP");

        hr = DetermineDefaultHash(pServer);
        _JumpIfError(hr, error, "DetermineDefaultHash");

        hr = InitializeKeyLengthControl(hDlg);
        _JumpIfError(hr, error, "InitializeKeyLengthControl");
    }

    hr = UpdateCSPSelection(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateCSPSelection");

done:
    hr = S_OK;

error:
    return hr;
}

HRESULT
HandleViewCertButton(
    HWND                hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    CRYPTUI_VIEWCERTIFICATE_STRUCTW viewCert;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    CSASSERT(NULL!=pServer->pwszKeyContainerName &&
             NULL!=pServer->pccExistingCert);

    ZeroMemory(&viewCert, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCTW));
    viewCert.hwndParent = hDlg;
    viewCert.dwSize = sizeof(viewCert);
    viewCert.pCertContext = CertDuplicateCertificateContext(pServer->pccExistingCert);
    if (NULL == viewCert.pCertContext)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertDuplicateCertificateContext");
    }
//    viewCert.rghStores = &pServer->hMyStore;
//    viewCert.cStores = 1;
    viewCert.dwFlags = CRYPTUI_DONT_OPEN_STORES;

    if (!CryptUIDlgViewCertificateW(&viewCert, NULL))
    {
        hr = myHLastError();
        _PrintError(hr, "CryptUIDlgViewCertificate");
    }

    hr = S_OK;
error:
    if (NULL != viewCert.pCertContext)
    {
        CertFreeCertificateContext(viewCert.pCertContext);
    }
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   WizAdvancedPageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure for advanced configuration OCM wizard.
//
//  Arguments:  [hDlg]
//              [iMsg]
//              [wParam]
//              [lParam]    ... the usual.
//
//  Returns:    BOOL dlg proc result.
//
//-------------------------------------------------------------------------
INT_PTR
WizAdvancedPageDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    PER_COMPONENT_DATA *pComp = NULL;

    switch (iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            ((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)((PROPSHEETPAGE*)lParam)->lParam;
        _ReturnIfWizError(pComp->hrContinue);
        pComp->hrContinue = InitAdvanceWizPageControls(hDlg);
        _ReturnIfWizError(pComp->hrContinue);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_ADVANCE_CSPLIST:
            switch (HIWORD(wParam))
            {
            case LBN_SELCHANGE:
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleCSPSelectionChange(hDlg,
                                         pComp->CA.pServer);
                _ReturnIfWizError(pComp->hrContinue);
                break;

            default:
                break;
            }
            break;

        case IDC_ADVANCE_HASHLIST:
            switch (HIWORD(wParam))
            {
            case LBN_SELCHANGE:
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleHashSelectionChange(hDlg,
                                         pComp->CA.pServer);
                _ReturnIfWizError(pComp->hrContinue);
                break;
            }
            break;

        case IDC_ADVANCE_KEYLIST:
            switch (HIWORD(wParam))
            {
            case LBN_SELCHANGE:
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleKeySelectionChange(hDlg,
                                        pComp->CA.pServer, TRUE);
                _ReturnIfWizError(pComp->hrContinue);
                break;
            }
            break;

        case IDC_ADVANCE_USEKEYCHECK:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleUseKeyCheckboxChange(hDlg,
                                        pComp->CA.pServer);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_ADVANCE_USECERTCHECK:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleUseCertCheckboxChange(hDlg,
                                        pComp->CA.pServer);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_ADVANCE_KEY_LENGTH:
            switch (HIWORD(wParam))
            {
            case CBN_SELCHANGE:
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleKeyLengthSelectionChange(hDlg,
                                        pComp->CA.pServer);
                _ReturnIfWizError(pComp->hrContinue);
                break;
            case CBN_EDITCHANGE:
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleKeyLengthEditChange(
                        (HWND)lParam);
                _ReturnIfWizError(pComp->hrContinue);
                break;
            }
            break;

        case IDC_ADVANCE_IMPORT:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleImportPFXButton(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_ADVANCE_VIEWCERT:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleViewCertButton(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        default:
            return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR*) lParam)->code)
        {
        case PSN_KILLACTIVE:
            break;

        case PSN_RESET:
            break;

        case PSN_QUERYCANCEL:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            return CertConfirmCancel(hDlg, pComp);
            break;

        case PSN_SETACTIVE:
            CSILOGDWORD(IDS_ADVANCE_TITLE, dwWIZACTIVE);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
            pComp = _GetCompDataOrReturn(pComp, hDlg);
            _DisableWizDisplayIfError(pComp, hDlg);
            _ReturnIfWizError(pComp->hrContinue);
            pComp->hrContinue = HandleAdvanceWizActive(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZBACK:
            CSILOGDWORD(IDS_ADVANCE_TITLE, dwWIZBACK);
            break;

        case PSN_WIZNEXT:
            DWORD fReuseCert;

            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            fReuseCert = NULL != pComp->CA.pServer->pccExistingCert;
            CSILOG(
                S_OK,
                IDS_LOG_KEYNAME,
                pComp->CA.pServer->pwszKeyContainerName,
		pComp->CA.pServer->pwszDesanitizedKeyContainerName,
                &fReuseCert);
            CSILOGDWORD(IDS_ADVANCE_TITLE, dwWIZNEXT);
            pComp->hrContinue = HandleAdvanceWizNext(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        default:
            return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);
        }
        break;

    default:
        return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);
    }

    return TRUE;
}


HRESULT
EnableSharedFolderControls(HWND hDlg, BOOL fUseSharedFolder)
{
    EnableWindow(GetDlgItem(hDlg, IDC_STORE_EDIT_SHAREDFOLDER), fUseSharedFolder);
    EnableWindow(GetDlgItem(hDlg, IDC_STORE_SHAREDBROWSE), fUseSharedFolder);
    if (fUseSharedFolder)
    {
        SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_STORE_EDIT_SHAREDFOLDER), 0, MAXDWORD);
    }
    return S_OK;
}


HRESULT
StorePageValidation(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp,
    BOOL              *pfDontNext)
{
    HRESULT hr;
    UINT    uiFocus = 0;
    WCHAR   *pwszDefaultDBDir = NULL;
    WCHAR   *pwszDefaultSF = NULL;

    LPWSTR  pwszPrompt = NULL;
    LPWSTR  pwszComputerName = NULL;

    BOOL    fExistSF = TRUE;
    BOOL    fExistDB = TRUE;
    BOOL    fExistLog = TRUE;
    BOOL    fDefaultDir;
    BOOL    fIsUNC;
    BOOL    fIsSharedFolderUNC;
    WCHAR   wszNotExistingDir[3 * MAX_PATH];
    BOOL    fUseSharedFolder;
    
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    
    *pfDontNext = FALSE;

    // get shared folder check state
    if (pComp->fUnattended)
    {
        CSASSERT(NULL != pServer->pwszSharedFolder);
        fUseSharedFolder = TRUE;  // unattended always use shared folder
    }
    else
    {
        fUseSharedFolder = (BST_CHECKED == SendMessage(
                        GetDlgItem(hDlg, IDC_STORE_USE_SHAREDFOLDER),
                        BM_GETCHECK, 0, 0));
    }

    fIsSharedFolderUNC = FALSE;
    if (NULL != pServer->pwszSharedFolder)
    {
        fDefaultDir = TRUE;
        hr = GetDefaultSharedFolder(&pwszDefaultSF);
        _JumpIfError(hr, error, "GetDefaultSharedFolder");
        
        // make sure case insensitive
        if (0 != mylstrcmpiL(pwszDefaultSF, pServer->pwszSharedFolder))
        {
            fDefaultDir = FALSE;
        }
        if (!ValidateAndCreateDirField(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg, 
            pServer->pwszSharedFolder,
            fDefaultDir,
            IDS_WRN_STORELOC_SHAREDFOLDER_FULLPATH,
            &fExistSF,
            &fIsSharedFolderUNC))
        {
            uiFocus = IDC_STORE_EDIT_SHAREDFOLDER;
            *pfDontNext = TRUE;
            goto done;
        }
    }
    else if (fUseSharedFolder)
    {
        // the case to enforce shared folder but edit field is empty
        CertWarningMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_WRN_STORELOC_SHAREDFOLDER_FULLPATH,
                    0,
                    L"");
        uiFocus = IDC_STORE_EDIT_SHAREDFOLDER;
        *pfDontNext = TRUE;
        goto done;
    }
    
    fDefaultDir = TRUE;
    hr = GetDefaultDBDirectory(pComp, &pwszDefaultDBDir);
    _JumpIfError(hr, error, "GetDefaultDBDirectory");
    
    // make sure case insensitive
    if (0 != mylstrcmpiL(pwszDefaultDBDir, pServer->pwszDBDirectory))
    {
        fDefaultDir = FALSE;
    }
    if (!ValidateAndCreateDirField(
        pComp->hInstance,
        pComp->fUnattended,
        hDlg, 
        pServer->pwszDBDirectory,
        fDefaultDir,
        IDS_WRN_STORELOC_DB_FULLPATH,
        &fExistDB,
        &fIsUNC))
    {
        uiFocus = IDC_STORE_EDIT_DB;
        *pfDontNext = TRUE;
        goto done;
    }
    
    fDefaultDir = TRUE;
    
    // remember default log dir is the same as db
    if (0 != mylstrcmpiL(pwszDefaultDBDir, pServer->pwszLogDirectory))
    {
        fDefaultDir = FALSE;
    }
    if (!ValidateAndCreateDirField(
        pComp->hInstance,
        pComp->fUnattended,
        hDlg, 
        pServer->pwszLogDirectory,
        fDefaultDir,
        IDS_WRN_STORELOC_LOG_FULLPATH,
        &fExistLog,
        &fIsUNC))
    {
        uiFocus = IDC_STORE_EDIT_LOG;
        *pfDontNext = TRUE;
        goto done;
    }
    
    wszNotExistingDir[0] = '\0'; // empty string
    if (!fExistSF)
    {
        wcscat(wszNotExistingDir, pServer->pwszSharedFolder);
    }
    if (!fExistDB)
    {
        if ('\0' != wszNotExistingDir[0])
        {
            wcscat(wszNotExistingDir, L"\n");
        }
        wcscat(wszNotExistingDir, pServer->pwszDBDirectory);
    }
    if (!fExistLog)
    {
        if ('\0' != wszNotExistingDir[0])
        {
            wcscat(wszNotExistingDir, L"\n");
        }
        wcscat(wszNotExistingDir, pServer->pwszLogDirectory);
    }
    if ('\0' != wszNotExistingDir[0])
    {
        // skip confirm in unattended mode
        if (!pComp->fUnattended)
        {
            // confirm all here
            if (IDYES != CertMessageBox(
                            pComp->hInstance,
                            pComp->fUnattended,
                            hDlg,
                            IDS_ASK_CREATE_DIRECTORY,
                            0,
                            MB_YESNO |
                            MB_ICONWARNING |
                            CMB_NOERRFROMSYS,
                            wszNotExistingDir) )
            {
                if (!fExistSF)
                {
                    uiFocus = IDC_STORE_EDIT_SHAREDFOLDER;
                }
                else if (!fExistDB)
                {
                    uiFocus = IDC_STORE_EDIT_DB;
                }
                else if (!fExistLog)
                {
                    uiFocus = IDC_STORE_EDIT_LOG;
                }
                *pfDontNext = TRUE;
                goto done;
            }
        }
        if (!fExistSF)
        {
            hr = myCreateNestedDirectories(pServer->pwszSharedFolder);
            if (S_OK != hr)
            {
                CertWarningMessageBox(pComp->hInstance,
                               pComp->fUnattended,
                               hDlg,
                               IDS_ERR_CREATE_DIR,
                               hr,
                               pServer->pwszSharedFolder);
                uiFocus = IDC_STORE_EDIT_SHAREDFOLDER;
                *pfDontNext = TRUE;
                goto done;
            }
        }
        if (!fExistDB)
        {
            hr = myCreateNestedDirectories(pServer->pwszDBDirectory);
            if (S_OK != hr)
            {
                CertWarningMessageBox(pComp->hInstance,
                               pComp->fUnattended,
                               hDlg,
                               IDS_ERR_CREATE_DIR,
                               hr,
                               pServer->pwszDBDirectory);
                uiFocus = IDC_STORE_EDIT_DB;
                *pfDontNext = TRUE;
                goto done;
            }

        }

        if (!fExistLog)
        {
            hr = myCreateNestedDirectories(pServer->pwszLogDirectory);
            if (S_OK != hr)
            {
                CertWarningMessageBox(pComp->hInstance,
                               pComp->fUnattended,
                               hDlg,
                               IDS_ERR_CREATE_DIR,
                               hr,
                               pServer->pwszLogDirectory);
                uiFocus = IDC_STORE_EDIT_LOG;
                *pfDontNext = TRUE;
                goto done;
            }
        }
    }

    hr = SetFolderDacl(
        pServer->pwszDBDirectory, 
        WSZ_DEFAULT_DB_DIR_SECURITY);
    _JumpIfErrorStr(hr, error, "SetFolderDacl", pServer->pwszDBDirectory);

    hr = SetFolderDacl(
        pServer->pwszLogDirectory, 
        WSZ_DEFAULT_LOG_DIR_SECURITY);
    _JumpIfErrorStr(hr, error, "SetFolderDacl", pServer->pwszLogDirectory);

    hr = ValidateESERestrictions(pServer->pwszDBDirectory);
    if (S_OK != hr)
    {
        CertWarningMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hDlg,
                        IDS_WRN_DBSPECIALCHARACTERS,
                        hr,
                        pServer->pwszDBDirectory);
        uiFocus = IDC_STORE_EDIT_DB;
        *pfDontNext = TRUE;
        goto done;
    }

    hr = ValidateESERestrictions(pServer->pwszLogDirectory);
    if (S_OK != hr)
    {
        CertWarningMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hDlg,
                        IDS_WRN_DBSPECIALCHARACTERS,
                        hr,
                        pServer->pwszLogDirectory);
        uiFocus = IDC_STORE_EDIT_LOG;
        *pfDontNext = TRUE;
        goto done;
    }

    CSASSERT(!*pfDontNext);

    // directory creation done; now analyze for UNC, sharepath
    if (NULL != pServer->pwszSharedFolder)
    {
        // if not UNC, prompt to change to UNC
        if (!fIsSharedFolderUNC)
        {
#define UNCPATH_TEMPLATE     L"\\\\%ws\\" wszCERTCONFIGSHARENAME
                
            hr = myAddShare(
                wszCERTCONFIGSHARENAME, 
                myLoadResourceString(IDS_CERTCONFIG_FOLDERDESCR), 
                pServer->pwszSharedFolder, 
                TRUE, // overwrite
                NULL);
            _JumpIfError(hr, done, "myAddShare");
            
            // get the local machine name
            WCHAR wszUNCPath[MAX_PATH + ARRAYSIZE(UNCPATH_TEMPLATE)];   // "machine" + UNCPATH_TEMPLATE
            
            hr = myGetMachineDnsName(&pwszComputerName);
            _JumpIfError(hr, done, "myGetMachineDnsName");
            
            // create UNC path
            swprintf(wszUNCPath, UNCPATH_TEMPLATE, pwszComputerName);
            
            // only convert to UNC if this thing is shared
            LocalFree(pServer->pwszSharedFolder);
            pServer->pwszSharedFolder = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                         WSZ_BYTECOUNT(wszUNCPath));
            _JumpIfOutOfMemory(hr, error, pServer->pwszSharedFolder);
            wcscpy(pServer->pwszSharedFolder, wszUNCPath);
        }  // else, user typed in an already-shared UNC path
    }

    
done:
    hr = S_OK;
error:
    if (NULL != pwszDefaultDBDir)
        LocalFree(pwszDefaultDBDir);

    if (NULL != pwszDefaultSF)
        LocalFree(pwszDefaultSF);

    if (NULL != pwszPrompt)
        LocalFree(pwszPrompt);

    if (NULL != pwszComputerName)
        LocalFree(pwszComputerName);

    if (!pComp->fUnattended && uiFocus != 0 && *pfDontNext)
    {
        SetEditFocusAndSelect(GetDlgItem(hDlg, uiFocus), 0, MAXDWORD);
    }
    return hr;
}


HRESULT
StoreDBShareValidation(
    IN HWND               hDlg,
    IN PER_COMPONENT_DATA *pComp,
    IN WCHAR const        *pwszDir,
    IN BOOL                fDB,  //db dir vs. log dir
    OUT BOOL              *pfDontNext)
{
    HRESULT hr;
    WCHAR *pwszDefaultLogDir = NULL;
    BOOL fDefaultLogPath;
    WCHAR *pwszFileInUse = NULL;
    BOOL fFilesExist;

    static BOOL s_fOverwriteDB = FALSE;
    static BOOL s_fOverwriteLog = FALSE;
    BOOL *pfOverwrite = fDB ? &s_fOverwriteDB : &s_fOverwriteLog;

    // init
    *pfDontNext = FALSE;

    // get default log path which is the same as db

    hr = GetDefaultDBDirectory(pComp, &pwszDefaultLogDir);
    _JumpIfError(hr, error, "GetDefaultDBDirectory");

    fDefaultLogPath = (0 == mylstrcmpiL(pwszDir, pwszDefaultLogDir));

    hr = myDoDBFilesExistInDir(pwszDir, &fFilesExist, &pwszFileInUse);
    _JumpIfError(hr, error, "myDoDBFilesExistInDir");

    if (NULL != pwszFileInUse)
    {
        CertWarningMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hDlg,
                IDS_WRN_DBFILEINUSE,
                0,
                pwszFileInUse);
        *pfDontNext = TRUE;
        goto done;
    }

    if (!pComp->CA.pServer->fPreserveDB &&
        fFilesExist &&
        !*pfOverwrite &&
        !fDefaultLogPath)
    {
        // log file exists in non-default dir

        if (IDYES != CertMessageBox(
                            pComp->hInstance,
                            pComp->fUnattended,
                            hDlg,
                            IDS_WRN_STORELOC_EXISTINGDB,
                            0,
                            MB_YESNO |
                                MB_DEFBUTTON2 |
                                MB_ICONWARNING |
                                CMB_NOERRFROMSYS,
                            pwszDir))
        {
            *pfDontNext = TRUE;
            goto done;
        }

        // warn only once

        *pfOverwrite = TRUE;
    }

done:
    if (*pfDontNext)
    {
        // set focus
        SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_STORE_EDIT_LOG), 0, MAXDWORD);
    }
    hr = S_OK;

error:
    if (NULL != pwszFileInUse)
    {
        LocalFree(pwszFileInUse);
    }
    if (NULL != pwszDefaultLogDir)
    {
        LocalFree(pwszDefaultLogDir);
    }
    return hr;
}


HRESULT
FinishDirectoryBrowse(
    HWND    hDlg,
    int     idEdit)
{
    HRESULT  hr = S_FALSE;
    WCHAR dirInitName[MAX_PATH] = L"";
    WCHAR dirName[MAX_PATH] = L"";

    if(!GetWindowText(GetDlgItem(hDlg, idEdit), dirInitName, MAX_PATH))
    {
        hr = myHLastError();
        if(S_OK != hr)
        {
            return hr;
        }
    }

    if (BrowseForDirectory(
        GetParent(hDlg),
        dirInitName,
        dirName,
        MAX_PATH,
        NULL))
    {
        SetDlgItemText(hDlg, idEdit, dirName);
        hr = S_OK;
    }
    return hr;
}

HRESULT
HookStorePageStrings(
    PAGESTRINGS       *pPageString,
    CASERVERSETUPINFO *pServer)
{
    HRESULT    hr;

    for ( ; 0 != pPageString->idControl; pPageString++)
    {
        switch (pPageString->idControl)
        {
            case IDC_STORE_EDIT_SHAREDFOLDER:
                pPageString->ppwszString = &(pServer->pwszSharedFolder);
            break;
            case IDC_STORE_EDIT_DB:
                pPageString->ppwszString = &(pServer->pwszDBDirectory);
            break;
            case IDC_STORE_EDIT_LOG:
                pPageString->ppwszString = &(pServer->pwszLogDirectory);
            break;
            default:
                hr = E_INVALIDARG;
                _JumpError(hr, error, "Internal error");
            break;
        }
    }
    hr = S_OK;
error:
    return hr;
}

HRESULT
InitStoreWizControls(
    HWND               hDlg,
    PAGESTRINGS       *pPageString,
    CASERVERSETUPINFO *pServer)
{
    HRESULT  hr;

    // now make page strings complete
    hr = HookStorePageStrings(pPageString, pServer);
    _JumpIfError(hr, error, "HookStorePageStrings");

    SendDlgItemMessage(hDlg,
        IDC_STORE_USE_SHAREDFOLDER,
        BM_SETCHECK,
        (WPARAM)((NULL != pServer->pwszSharedFolder) ?
                 BST_CHECKED : BST_UNCHECKED),
        (LPARAM)0);

    if (!pServer->fUseDS && (NULL != pServer->pwszSharedFolder))
    {
        // no DS, disable shared folder check to force it
        EnableWindow(GetDlgItem(hDlg, IDC_STORE_USE_SHAREDFOLDER), FALSE);
    }

    hr = StartWizardPageEditControls(hDlg, pPageString);
    _JumpIfError(hr, error, "StartWizardPageEditControls");

    hr = S_OK;
error:
    return hr;
}

HRESULT
HandlePreservingDB(
    HWND                hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    HWND hwndSF = GetDlgItem(hDlg, IDC_STORE_EDIT_SHAREDFOLDER);
    HWND hwndDB = GetDlgItem(hDlg, IDC_STORE_EDIT_DB);
    HWND hwndLog = GetDlgItem(hDlg, IDC_STORE_EDIT_LOG);
    BOOL    fEnable = TRUE;
    BOOL    fEnableSharedFolder = TRUE;
    WCHAR    *pwszExistingSharedFolder = NULL;
    WCHAR    *pwszExistingDBDirectory = NULL;
    WCHAR    *pwszExistingLogDirectory = NULL;


    if (pServer->fPreserveDB)
    {
        if (!pServer->fUNCPathNotFound)
        {
            // get shared folder path
            hr = myGetCertRegStrValue(NULL, NULL, NULL,
                     wszREGDIRECTORY, &pwszExistingSharedFolder);
            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                // optional value
                hr = S_OK;
                pwszExistingSharedFolder = NULL;
            }
            _JumpIfError(hr, error, "myGetCertRegStrValue");
            fEnableSharedFolder = FALSE;
        }
        else
        {
            pwszExistingSharedFolder = pServer->pwszSharedFolder;
        }

        // get existing db path
        hr = myGetCertRegStrValue(NULL, NULL, NULL,
                 wszREGDBDIRECTORY, &pwszExistingDBDirectory);
        _JumpIfError(hr, error, "myGetCertRegStrValue");

        hr = myGetCertRegStrValue(NULL, NULL, NULL,
                 wszREGDBLOGDIRECTORY, &pwszExistingLogDirectory);
        _JumpIfError(hr, error, "myGetCertRegStrValue");

        // fill edit fields
        SetWindowText(hwndSF, pwszExistingSharedFolder);
        SetWindowText(hwndDB, pwszExistingDBDirectory);
        SetWindowText(hwndLog, pwszExistingLogDirectory);

        // disable them
        fEnable = FALSE;
    }
    EnableWindow(hwndSF, fEnableSharedFolder);
    EnableWindow(hwndDB, fEnable);
    EnableWindow(hwndLog, fEnable);

    hr = S_OK;
error:
    if (NULL != pwszExistingSharedFolder &&
        pwszExistingSharedFolder != pServer->pwszSharedFolder)
    {
        LocalFree(pwszExistingSharedFolder);
    }
    if (NULL != pwszExistingDBDirectory)
    {
        LocalFree(pwszExistingDBDirectory);
    }
    if (NULL != pwszExistingLogDirectory)
    {
        LocalFree(pwszExistingLogDirectory);
    }
    return hr;
}

HRESULT
HandleStoreWizActive(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    HWND    hwndDB;
    BOOL fEnableKeepDB = FALSE;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    // Suppress this wizard page if
    // we've already seen an error, or
    // we are not installing the server.

    if (!(IS_SERVER_INSTALL & pComp->dwInstallStatus) )
    {
        // disable page
        CSILOGDWORD(IDS_STORE_TITLE, dwWIZDISABLE);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
        goto done;
    }

    CSASSERT(NULL != pServer->pwszKeyContainerName);

    hwndDB = GetDlgItem(hDlg, IDC_STORE_KEEPDB);

    if (NULL != pServer->pccExistingCert)
    {
        // determine existing db status

        hr = myDoDBFilesExist(
                        pServer->pwszSanitizedName,
                        &fEnableKeepDB,
                        NULL);
        _JumpIfError(hr, error, "myDoDBFilesExist");
    }
    else
    {
        // can't use db
        pServer->fPreserveDB = FALSE;
        SendMessage(hwndDB, BM_SETCHECK, (WPARAM)BST_UNCHECKED, (LPARAM)0);
        HandlePreservingDB(hDlg, pComp);
    }
    // enable/disable the control
    EnableSharedFolderControls(hDlg, NULL != pServer->pwszSharedFolder);
    EnableWindow(hwndDB, fEnableKeepDB);

done:
    hr = S_OK;
error:
    return hr;
}

HRESULT
HandleStoreWizNextOrBack(
    HWND               hDlg,
    PAGESTRINGS       *pPageString,
    PER_COMPONENT_DATA *pComp,
    int                 iWizBN)
{
    HRESULT hr;
    WCHAR  *pwszFile = NULL;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    BOOL     fDontNext = FALSE;
    BOOL     fGoBack = FALSE;
    BOOL     fUseSharedFolder;
    HCURSOR hPrevCur;

    hr = FinishWizardPageEditControls(hDlg, pPageString);
    _JumpIfError(hr, error, "FinishWizardPageEditControls");

    if (PSN_WIZBACK == iWizBN)
    {
        goto done;
    }

    // make sure at least one way to publish ca
    CSASSERT(NULL != pServer->pwszSharedFolder || pComp->CA.pServer->fUseDS);

    // get shared folder check state
    fUseSharedFolder = (BST_CHECKED == SendMessage(
                        GetDlgItem(hDlg, IDC_STORE_USE_SHAREDFOLDER),
                        BM_GETCHECK, 0, 0));

    if (!fUseSharedFolder && NULL != pServer->pwszSharedFolder)
    {
        //don't collect shared folder from edit control
        LocalFree(pServer->pwszSharedFolder);
        pServer->pwszSharedFolder = NULL;
    }

    hPrevCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    hr = StorePageValidation(hDlg, pComp, &fDontNext);
    SetCursor(hPrevCur);
    _JumpIfError(hr, error, "StorePageValidation");

    if (fDontNext)
    {
        goto done;
    }

    // validate existing db sharing here

    hr = StoreDBShareValidation(
                        hDlg,
                        pComp,
                        pComp->CA.pServer->pwszDBDirectory,
                        TRUE,  //db dir
                        &fDontNext);
    _JumpIfError(hr, error, "StoreDBShareValidation");

    if (fDontNext)
    {
        goto done;
    }

    if (0 != mylstrcmpiL(
                pComp->CA.pServer->pwszDBDirectory,
                pComp->CA.pServer->pwszLogDirectory))
    {
        hr = StoreDBShareValidation(
                            hDlg,
                            pComp,
                            pComp->CA.pServer->pwszLogDirectory,
                            FALSE, //log dir
                            &fDontNext);
        _JumpIfError(hr, error, "StoreDBShareValidation");

        if (fDontNext)
        {
            goto done;
        }
    }

    hr = myBuildPathAndExt(
                    pComp->CA.pServer->pwszDBDirectory,
                    pServer->pwszSanitizedName,
                    wszDBFILENAMEEXT,
                    &pwszFile);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    // make sure path fits

    if (MAX_PATH <= wcslen(pwszFile))
    {
        // pop up warning
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg,
            IDS_PATH_TOO_LONG_CANAME,
            S_OK,
            pwszFile);
        // make it go back
        fGoBack = TRUE;
        fDontNext = TRUE;
        goto done;
    }
    LocalFree(pwszFile);
    pwszFile = NULL;

    hr = myBuildPathAndExt(
                    pComp->CA.pServer->pwszLogDirectory,
                    TEXT(szDBBASENAMEPARM) L"00000",
                    wszLOGFILENAMEEXT,
                    &pwszFile);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    // make sure path fits

    if (MAX_PATH <= wcslen(pwszFile))
    {
        // pop up warning
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg,
            IDS_PATH_TOO_LONG_DIRECTORY,
            S_OK,
            pwszFile);

        SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_STORE_EDIT_LOG), 0, MAXDWORD);
        fDontNext = TRUE;
        goto done;
    }
    LocalFree(pwszFile);
    pwszFile = NULL;

    hr = csiBuildCACertFileName(
                        pComp->hInstance,
                        hDlg,
                        pComp->fUnattended,
                        pServer->pwszSharedFolder,
                        pServer->pwszSanitizedName,
                        L".crt",
                        0, // CANAMEIDTOICERT(pServer->dwCertNameId),
                        &pwszFile);
    _JumpIfError(hr, error, "csiBuildCACertFileName");

    // make sure path fit
    if (MAX_PATH <= wcslen(pwszFile) + cwcSUFFIXMAX)
    {
        // pop up warning
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg,
            IDS_PATH_TOO_LONG_CANAME,
            S_OK,
            pwszFile);
        // make it go back
        fGoBack = TRUE;
        fDontNext = TRUE;
        goto done;
    }
    if (NULL != pServer->pwszCACertFile)
    {
        // free old one
        LocalFree(pServer->pwszCACertFile);
    }
    pServer->pwszCACertFile = pwszFile;
    pwszFile = NULL;

    if (IsRootCA(pServer->CAType))
    {
        hPrevCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
        hr = StartAndStopService(pComp->hInstance,
                 pComp->fUnattended,
                 hDlg, 
                 wszW3SVCNAME,
                 TRUE,
                 TRUE, // confirmation
                 IDS_STOP_W3SVC,
                 &g_fW3SvcRunning);
        SetCursor(hPrevCur);
        if (S_OK != hr)
        {
            if (E_ABORT == hr)
            {
                fDontNext = TRUE;
                goto done;
            }
            _JumpError(hr, error, "StartAndStopService");
        }
    }

done:
    if (fDontNext)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE); // forbid
        if (fGoBack)
        {
            PropSheet_PressButton(GetParent(hDlg), PSBTN_BACK);
            pServer->LastWiz = ENUM_WIZ_STORE;
        }
    }
    else
    {
        // continue to next
        pServer->LastWiz = ENUM_WIZ_STORE;
    }
    hr = S_OK;

error:
    if (NULL != pwszFile)
    {
        LocalFree(pwszFile);
    }
    return hr;
}

HRESULT
HandleUseSharedFolder(
    IN HWND    hDlg,
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    // get shared folder check state
    BOOL fUseSharedFolder = (BST_CHECKED == SendMessage(
                             GetDlgItem(hDlg, IDC_STORE_USE_SHAREDFOLDER),
                             BM_GETCHECK, 0, 0));

    if (!fUseSharedFolder && !pComp->CA.pServer->fUseDS)
    {
        // must check at least one, force unchange
        fUseSharedFolder = TRUE;
        SendDlgItemMessage(hDlg, IDC_STORE_USE_SHAREDFOLDER,
            BM_SETCHECK, (WPARAM)BST_CHECKED, (LPARAM)0);
    }
    hr = EnableSharedFolderControls(hDlg, fUseSharedFolder);
//    _JumpIfError(hr, error, "EnableSharedFolderControls");
    _PrintIfError(hr, "EnableSharedFolderControls");

//    hr = S_OK;
//error:
    return hr;
}

//+------------------------------------------------------------------------
//  Function:   WizStorePageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure for storage location
//-------------------------------------------------------------------------

INT_PTR
WizStorePageDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    PER_COMPONENT_DATA *pComp = NULL;

    // keep scope of following array inside
    static PAGESTRINGS saStoreString[] =
    {
        {
            IDC_STORE_EDIT_SHAREDFOLDER,
            IDS_LOG_SHAREDFOLDER,
            0,
            0,
            MAX_PATH,
            NULL,
        },
        {
            IDC_STORE_EDIT_DB,
            IDS_LOG_DBDIR,
            0,
            0,
            MAX_PATH,
            NULL,
        },
        {
            IDC_STORE_EDIT_LOG,
            IDS_LOG_DBLOGDIR,
            0,
            0,
            MAX_PATH,
            NULL,
        },
// you need to add code in HookStoreStrings if adding more...
        {
            0,
            0,
            0,
            0,
            0,
            NULL,
        }
    };

    switch(iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            ((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)((PROPSHEETPAGE*)lParam)->lParam;
        _ReturnIfWizError(pComp->hrContinue);
        pComp->hrContinue = InitStoreWizControls(hDlg, saStoreString, pComp->CA.pServer);
        _ReturnIfWizError(pComp->hrContinue);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_STORE_USE_SHAREDFOLDER:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleUseSharedFolder(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_STORE_KEEPDB:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->CA.pServer->fPreserveDB = !pComp->CA.pServer->fPreserveDB;
            pComp->hrContinue = HandlePreservingDB(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_STORE_SHAREDBROWSE:
            FinishDirectoryBrowse(hDlg, IDC_STORE_EDIT_SHAREDFOLDER);
            break;

        case IDC_STORE_DBBROWSE:
            FinishDirectoryBrowse(hDlg, IDC_STORE_EDIT_DB);
            break;

        case IDC_STORE_LOGBROWSE:
            FinishDirectoryBrowse(hDlg, IDC_STORE_EDIT_LOG);
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_KILLACTIVE:
            break;

        case PSN_RESET:
            break;

        case PSN_QUERYCANCEL:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            return CertConfirmCancel(hDlg, pComp);
            break;

        case PSN_SETACTIVE:
            CSILOGDWORD(IDS_STORE_TITLE, dwWIZACTIVE);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
            pComp = _GetCompDataOrReturn(pComp, hDlg);
            _DisableWizDisplayIfError(pComp, hDlg);
            _ReturnIfWizError(pComp->hrContinue);
            pComp->hrContinue = HandleStoreWizActive(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZBACK:
            CSILOGDWORD(IDS_STORE_TITLE, dwWIZBACK);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleStoreWizNextOrBack(hDlg,
                saStoreString, pComp, PSN_WIZBACK);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZNEXT:
            CSILOGDWORD(IDS_STORE_TITLE, dwWIZNEXT);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleStoreWizNextOrBack(hDlg,
                saStoreString, pComp, PSN_WIZNEXT);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        default:
            return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);
        }
        break;

    default:
        return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);
    }
    return TRUE;
}

HRESULT
EnableCARequestControls(
    HWND hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    // Online req
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_CANAME),
        !pServer->fSaveRequestAsFile);
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_COMPUTERNAME),
        !pServer->fSaveRequestAsFile);
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_CA_BROWSE),
        !pServer->fSaveRequestAsFile && pServer->fCAsExist);
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_CNLABEL),
        !pServer->fSaveRequestAsFile);
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_PCALABEL),
        !pServer->fSaveRequestAsFile);

    // File req
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_FILE),
        pServer->fSaveRequestAsFile);
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_FILE_BROWSE),
        pServer->fSaveRequestAsFile);
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_FILELABEL),
        pServer->fSaveRequestAsFile);

    if (pServer->fSaveRequestAsFile)
    {
        SetFocus(GetDlgItem(hDlg, IDC_CAREQUEST_FILE));
    }
    else
    {
        SetFocus(GetDlgItem(hDlg, IDC_CAREQUEST_CANAME));
    }


    hr = S_OK;
//error:
    return hr;
}

HRESULT
BuildRequestFileName(
    IN WCHAR const *pwszCACertFile,
    OUT WCHAR     **ppwszRequestFile)
{
#define wszREQEXT  L".req"

    HRESULT hr;
    WCHAR const *pwszStart;
    WCHAR const *pwszEnd;
    WCHAR *pwszRequestFile = NULL;

    CSASSERT(NULL != pwszCACertFile);

    // derive request file name
    pwszStart = pwszCACertFile;
    pwszEnd = wcsrchr(pwszStart, L'.');
    if (pwszEnd == NULL)
    {
        // set to end of entire string -- no '.' found
        pwszEnd = &pwszStart[wcslen(pwszStart)];
    }

    pwszRequestFile = (WCHAR*)LocalAlloc(LMEM_FIXED,
        (SAFE_SUBTRACT_POINTERS(pwszEnd, pwszStart) + 
         wcslen(wszREQEXT) + 1) * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pwszRequestFile);

    CopyMemory(pwszRequestFile, pwszStart,
            SAFE_SUBTRACT_POINTERS(pwszEnd, pwszStart) * sizeof(WCHAR));
    wcscpy(pwszRequestFile + SAFE_SUBTRACT_POINTERS(pwszEnd, pwszStart), wszREQEXT);

    // return
    *ppwszRequestFile = pwszRequestFile;
    pwszRequestFile = NULL;

    hr = S_OK;
error:
    if (NULL != pwszRequestFile)
    {
        LocalFree(pwszRequestFile);
    }
    return hr;
}

HRESULT
StartCARequestPage(
    HWND               hDlg,
    PAGESTRINGS       *pPageString,
    CASERVERSETUPINFO *pServer)
{

    HRESULT hr;

    if (NULL == pServer->pwszRequestFile)
    {
    hr = BuildRequestFileName(
             pServer->pwszCACertFile,
             &pServer->pwszRequestFile);
    _JumpIfError(hr, error, "BuildRequestFileName");
    }

    hr = StartWizardPageEditControls(hDlg, pPageString);
    _JumpIfError(hr, error, "StartWizardPageEditControls");

    hr = S_OK;
error:
    return hr;
}


HRESULT
GetRequestFileName(
    HWND hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT    hr;
    WCHAR     *pwszFileIn = NULL;
    WCHAR     *pwszFileOut = NULL;
    HWND       hCtrl = GetDlgItem(hDlg, IDC_CAREQUEST_FILE);

    hr = myUIGetWindowText(hCtrl, &pwszFileIn);
    _JumpIfError(hr, error, "myUIGetWindowText");

    hr = myGetSaveFileName(
             hDlg,
             pComp->hInstance,
             IDS_REQUEST_SAVE_TITLE,
             IDS_REQUEST_FILE_FILTER,
             IDS_REQUEST_FILE_DEFEXT,
             OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT,
             pwszFileIn,
             &pwszFileOut);
    _JumpIfError(hr, error, "myGetSaveFileName");

    if (NULL != pwszFileOut)
    {
        SetWindowText(hCtrl, pwszFileOut);
    }

    hr = S_OK;
error:
    if (NULL != pwszFileOut)
    {
        LocalFree(pwszFileOut);
    }
    if (NULL != pwszFileIn)
    {
        LocalFree(pwszFileIn);
    }
    return hr;
}

HRESULT
HookCARequestPageStrings(
    PAGESTRINGS       *pPageString,
    CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    for ( ; 0 != pPageString->idControl; pPageString++)
    {
        switch (pPageString->idControl)
        {
            case IDC_CAREQUEST_CANAME:
                pPageString->ppwszString = &(pServer->pwszParentCAName);
            break;
            case IDC_CAREQUEST_COMPUTERNAME:
                pPageString->ppwszString = &(pServer->pwszParentCAMachine);
            break;
            case IDC_CAREQUEST_FILE:
                pPageString->ppwszString = &(pServer->pwszRequestFile);
            break;
            default:
                hr = E_INVALIDARG;
                _JumpError(hr, error, "Internal error");
            break;
        }
    }
    hr = S_OK;
error:
    return hr;
}

CERTSRVUICASELECTION g_CARequestUICASelection =
    { NULL, NULL, NULL, NULL, NULL, ENUM_UNKNOWN_CA, false, true };

HRESULT
InitCARequestWizControls(
    HWND               hDlg,
    PAGESTRINGS       *pSubmitPageString,
    PAGESTRINGS       *pFilePageString,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    // now make page strings complete
    hr = HookCARequestPageStrings(pSubmitPageString, pServer);
    _JumpIfError(hr, error, "HookCARequestPageStrings");

    hr = HookCARequestPageStrings(pFilePageString, pServer);
    _JumpIfError(hr, error, "HookCARequestPageStrings");

    if (!(SETUPOP_STANDALONE & pComp->Flags))
    {
        // nt base setup
        // disable online submit
        EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_SUBMITTOCA), FALSE);
        SendMessage(GetDlgItem(hDlg, IDC_CAREQUEST_SUBMITTOCA),
            BM_SETCHECK,
            (WPARAM) BST_UNCHECKED,
            (LPARAM) 0);
        // only save as file
        pServer->fSaveRequestAsFile = TRUE;
        SendMessage(GetDlgItem(hDlg, IDC_CAREQUEST_SAVETOFILE),
            BM_SETCHECK,
            (WPARAM) BST_CHECKED,
            (LPARAM) 0);
    }
    else
    {
        // set online submit as default
        pServer->fSaveRequestAsFile = FALSE;
        SendMessage(GetDlgItem(hDlg, IDC_CAREQUEST_SUBMITTOCA),
            BM_CLICK,
            (WPARAM) 0,
            (LPARAM) 0);

        hr = myInitUICASelectionControls(
				&g_CARequestUICASelection,
				pComp->hInstance,
				hDlg,
				GetDlgItem(hDlg, IDC_CAREQUEST_CA_BROWSE),
				GetDlgItem(hDlg, IDC_CAREQUEST_COMPUTERNAME),
				GetDlgItem(hDlg, IDC_CAREQUEST_CANAME),
				csiIsAnyDSCAAvailable(),
				&pServer->fCAsExist);
        _JumpIfError(hr, error, "myInitUICASelectionControls");

    }

    hr = S_OK;
error:
    return hr;
}

HRESULT
HandleCARequestWizActive(
    HWND                hDlg,
    PAGESTRINGS        *pPageString,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT                   hr;
    CRYPTUI_CA_CONTEXT const *pCAContext = NULL;
    CASERVERSETUPINFO        *pServer = pComp->CA.pServer;
    BOOL                      fMatchAll = IsEverythingMatched(pServer);

    // Suppress this wizard page if
    // we've already seen an error, or
    // we are not installing the server, or
    // we are not installing a subordinate, or
    // the advanced page already selected a matching key and cert

    if (!(IS_SERVER_INSTALL & pComp->dwInstallStatus) ||
        IsRootCA(pServer->CAType) ||
        fMatchAll)
    {
        // disable page
        CSILOGDWORD(IDS_CAREQUEST_TITLE, dwWIZDISABLE);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
        goto done;
    }

    EnableCARequestControls(hDlg, pComp);

    hr = StartCARequestPage(hDlg, pPageString, pServer);
    _JumpIfError(hr, error, "StartCARequestPage");

done:
    hr = S_OK;
error:
    if (NULL != pCAContext)
    {
        CryptUIDlgFreeCAContext(pCAContext);
    }
    return hr;
}

HRESULT
ConvertEditControlFullFilePath(
    HWND                hEdtCtrl)
{
    HRESULT  hr;
    WCHAR    *pwszPath = NULL;
    WCHAR    wszFullPath[MAX_PATH];
    WCHAR    *pwszNotUsed;
    DWORD    dwSize = 0;

    hr = myUIGetWindowText(hEdtCtrl, &pwszPath);
    _JumpIfError(hr, error, "myUIGetWindowText");

    if (NULL == pwszPath)
    {
        // empty path, done
        goto done;
    }

    dwSize = GetFullPathName(pwszPath,
                     ARRAYSIZE(wszFullPath),
                     wszFullPath,
                     &pwszNotUsed);
    CSASSERT(ARRAYSIZE(wszFullPath) > dwSize);

    if (0 == dwSize)
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetFullPathName");
    }

    // get full path, set it back to edit control
    SetWindowText(hEdtCtrl, wszFullPath);

done:
    hr = S_OK;
error:
    if (NULL != pwszPath)
    {
        LocalFree(pwszPath);
    }
    return hr;
}

HRESULT
HandleCARequestWizNextOrBack(
    HWND                hDlg,
    PAGESTRINGS        *pPageString,
    PER_COMPONENT_DATA  *pComp,
    int                 iWizBN)
{
    HRESULT  hr;
    CASERVERSETUPINFO  *pServer = pComp->CA.pServer;
    BOOL     fDontNext = FALSE;
    BOOL     fValid;

    if (pServer->fSaveRequestAsFile)
    {
        // convert request file to full path
        hr = ConvertEditControlFullFilePath(
                 GetDlgItem(hDlg, IDC_CAREQUEST_FILE));
        _JumpIfError(hr, error, "ConvertEditControlFullFilePath");

        CSASSERT(pServer->pwszSanitizedName);
        CSASSERT(pServer->pwszKeyContainerName);
        
        hr = mySetCertRegStrValue(
            pServer->pwszSanitizedName,
            NULL,
            NULL,
            wszREGREQUESTKEYCONTAINER,
            pServer->pwszKeyContainerName);
        _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", wszREGREQUESTKEYCONTAINER);
    }

    hr = FinishWizardPageEditControls(hDlg, pPageString);
    _JumpIfError(hr, error, "FinishWizardPageEditControls");

    if (PSN_WIZBACK == iWizBN)
    {
        goto done;
    }

    if (!pServer->fSaveRequestAsFile && NULL==pServer->pccExistingCert)
    {
        // online case
        hr = myUICASelectionValidation(&g_CARequestUICASelection, &fValid);
        _JumpIfError(hr, error, "myUICASelectionValidation");
        if (!fValid)
        {
            fDontNext = TRUE;
            goto done;
        }
    }

    hr = WizardPageValidation(pComp->hInstance, pComp->fUnattended,
             hDlg, pPageString);
    if (S_OK != hr)
    {
        fDontNext = TRUE;
        goto done;
    }

    if (pServer->fSaveRequestAsFile)
    {
        // validate dir path existance of the request file
        WCHAR *pwszLastSlash = wcsrchr(pServer->pwszRequestFile, L'\\');
        CSASSERT(NULL != pwszLastSlash);
        if (NULL != pwszLastSlash)
        {
            // make request file path into a dir path
            pwszLastSlash[0] = L'\0';
            if (DE_DIREXISTS != DirExists(pServer->pwszRequestFile) ||
                L'\0' == pwszLastSlash[1])
            {
                // bring request file path back
                pwszLastSlash[0] = L'\\';
                CertWarningMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hDlg,
                        IDS_CAREQUEST_REQUESTFILEPATH_MUSTEXIST,
                        0,
                        pServer->pwszRequestFile);
                SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_CAREQUEST_FILE), 0, MAXDWORD);
                fDontNext = TRUE;
                goto done;
            }    
            // bring request file path back
            pwszLastSlash[0] = L'\\';
        }

        // Fail if a directory with the same name already exists
        if(DE_DIREXISTS == DirExists(pServer->pwszRequestFile))
        {
                CertWarningMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hDlg,
                        IDS_CAREQUEST_REQUESTFILEPATH_DIREXISTS,
                        0,
                        pServer->pwszRequestFile);
                SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_CAREQUEST_FILE), 0, MAXDWORD);
                fDontNext = TRUE;
                goto done;
        }

    }

    hr = StartAndStopService(pComp->hInstance,
                 pComp->fUnattended,
                 hDlg, 
                 wszW3SVCNAME,
                 TRUE,
                 TRUE,
                 IDS_STOP_W3SVC,
                 &g_fW3SvcRunning);
    if (S_OK != hr)
    {
        if (E_ABORT == hr)
        {
            fDontNext = TRUE;
            goto done;
        }
        _JumpError(hr, error, "StartAndStopService");
    }

done:
    if (fDontNext)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE); // forbid
    }
    else
    {
        pServer->LastWiz = ENUM_WIZ_REQUEST;
    }
    hr = S_OK;
error:
    return hr;
}

//+------------------------------------------------------------------------
//  Function:   WizCARequestPageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure for CA Request wiz-page
//-------------------------------------------------------------------------

INT_PTR
WizCARequestPageDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    PAGESTRINGS       *pPageString;
    PER_COMPONENT_DATA *pComp = NULL;

    static BOOL  s_fComputerChange = FALSE;

    // keep the following in local scope
    static PAGESTRINGS saCARequestSubmit[] =
    {
        {
            IDC_CAREQUEST_COMPUTERNAME,
            IDS_LOG_COMPUTER,
            IDS_COMPUTERNULLSTRERR,
            IDS_COMPUTERLENSTRERR,
            MAX_PATH,
            NULL,
        },
        {
            IDC_CAREQUEST_CANAME,
            IDS_LOG_CANAME,
            IDS_CANULLSTRERR,
            IDS_CALENSTRERR,
            cchCOMMONNAMEMAX,
            NULL,
        },
// add more code in HookCARequestPageStrings if you add
        {
            0,
            0,
            0,
            0,
            0,
            NULL
        }
    };

    static PAGESTRINGS saCARequestFile[] =
    {
        {
            IDC_CAREQUEST_FILE,
            IDS_LOG_REQUESTFILE,
            IDS_REQUESTFILENULLSTRERR,
            IDS_REQUESTFILELENSTRERR,
            MAX_PATH,
            NULL,
        },
// add more code in HookCARequestPageStrings if you add
        {
            0,
            0,
            0,
            0,
            0,
            NULL,
        }
    };

    switch(iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            (ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)(ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam;
        _ReturnIfWizError(pComp->hrContinue);
        pComp->hrContinue = InitCARequestWizControls(hDlg,
                                 saCARequestSubmit,
                                 saCARequestFile,
                                 pComp);
        _ReturnIfWizError(pComp->hrContinue);
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CAREQUEST_SAVETOFILE:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->CA.pServer->fSaveRequestAsFile = TRUE;
            pComp->hrContinue = EnableCARequestControls(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_CAREQUEST_SUBMITTOCA:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->CA.pServer->fSaveRequestAsFile = FALSE;
            pComp->hrContinue = EnableCARequestControls(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_CAREQUEST_CA_BROWSE:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = myUICAHandleCABrowseButton(
                      &g_CARequestUICASelection,
                      csiIsAnyDSCAAvailable(),
                      IDS_CA_PICKER_TITLE,
                      IDS_CA_PICKER_PROMPT,
                      NULL);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_CAREQUEST_FILE_BROWSE:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = GetRequestFileName(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_CAREQUEST_CANAME:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = myUICAHandleCAListDropdown(
                                    (int)HIWORD(wParam), // notification
                                    &g_CARequestUICASelection,
                                    &s_fComputerChange);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_CAREQUEST_COMPUTERNAME:
            switch ((int)HIWORD(wParam))
            {
                case EN_CHANGE: // edit changed
                    s_fComputerChange = TRUE;
                    break;
            }
            break;

        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_KILLACTIVE:
            break;

        case PSN_RESET:
            break;

        case PSN_QUERYCANCEL:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            return CertConfirmCancel(hDlg, pComp);
            break;

        case PSN_SETACTIVE:
            CSILOGDWORD(IDS_CAREQUEST_TITLE, dwWIZACTIVE);
            pComp = _GetCompDataOrReturn(pComp, hDlg);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
            _DisableWizDisplayIfError(pComp, hDlg);
            _ReturnIfWizError(pComp->hrContinue);
            pComp->hrContinue = HandleCARequestWizActive(hDlg,
                saCARequestFile, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZBACK:
            CSILOGDWORD(IDS_CAREQUEST_TITLE, dwWIZBACK);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pPageString = saCARequestSubmit;
            if (pComp->CA.pServer->fSaveRequestAsFile)
            {
                pPageString = saCARequestFile;
            }
            pComp->hrContinue = HandleCARequestWizNextOrBack(hDlg,
                pPageString, pComp, PSN_WIZBACK);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZNEXT:
            CSILOGDWORD(IDS_CAREQUEST_TITLE, dwWIZNEXT);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pPageString = saCARequestSubmit;
            if (pComp->CA.pServer->fSaveRequestAsFile)
            {
                pPageString = saCARequestFile;
            }
            pComp->hrContinue = HandleCARequestWizNextOrBack(hDlg,
                pPageString, pComp, PSN_WIZNEXT);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        default:
            return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);
        }
        break;

    default:
        return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);

    }
    return TRUE;
}

HRESULT
HookClientPageStrings(
    PAGESTRINGS       *pPageString,
    CAWEBCLIENTSETUPINFO *pClient)
{
    HRESULT    hr;

    for ( ; 0 != pPageString->idControl; pPageString++)
    {
        switch (pPageString->idControl)
        {
            case IDC_CLIENT_COMPUTERNAME:
                pPageString->ppwszString = &(pClient->pwszWebCAMachine);
            break;
            default:
                hr = E_INVALIDARG;
                _JumpError(hr, error, "Internal error");
            break;
        }
    }
    hr = S_OK;
error:
    return hr;
}

CERTSRVUICASELECTION g_WebClientUICASelection =
    { NULL, NULL, NULL, NULL, NULL, ENUM_UNKNOWN_CA, true, false };

HRESULT
InitClientWizControls(
    HWND               hDlg,
    PAGESTRINGS       *pPageString,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    BOOL fCAsExist;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;

    hr = HookClientPageStrings(pPageString, pClient);
    _JumpIfError(hr, error, "HookClientPageStrings");

    hr = WizPageSetTextLimits(hDlg, pPageString);
    _JumpIfError(hr, error, "WizPageSetTextLimits");

    pClient->fUseDS = FALSE;
    if (IsDSAvailable(NULL))
    {
        pClient->fUseDS = csiIsAnyDSCAAvailable();
    }

    hr = myInitUICASelectionControls(
			    &g_WebClientUICASelection,
			    pComp->hInstance,
			    hDlg,
			    GetDlgItem(hDlg, IDC_CLIENT_BROWSECNFG),
			    GetDlgItem(hDlg, IDC_CLIENT_COMPUTERNAME),
			    GetDlgItem(hDlg, IDC_CLIENT_CANAME),
			    pClient->fUseDS,
			    &fCAsExist);
    _JumpIfError(hr, error, "myInitUICASelectionControls");

    hr = S_OK;
error:
    return hr;
}

HRESULT
GetCAConfigInfo(
    PER_COMPONENT_DATA *pComp)
{
    HRESULT   hr = S_OK;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;

    // free old shared folder always
    if (NULL != pClient->pwszSharedFolder)
    {
        // free old
        LocalFree(pClient->pwszSharedFolder);
        pClient->pwszSharedFolder = NULL;
    }

    hr = myUICAHandleCABrowseButton(
             &g_WebClientUICASelection,
             pClient->fUseDS,
             IDS_CONFIG_PICKER_TITLE,
             IDS_CONFIG_PICKER_PROMPT,
             &pClient->pwszSharedFolder);
    _JumpIfError(hr, error, "myUICAHandleCABrowseButton");

error:
    return hr;
}

HRESULT
HandleClientWizNextOrBack(
    HWND               hDlg,
    PAGESTRINGS       *pPageString,
    PER_COMPONENT_DATA *pComp,
    int                iWizBN)
{
    HRESULT  hr;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;
    BOOL     fDontNext = FALSE;
    WCHAR   *pwszCAName = NULL;
    WCHAR   *pwszSanitizedCAName;
    BOOL     fValid;
    BOOL     fCoInit = FALSE;

    hr = FinishWizardPageEditControls(hDlg, pPageString);
    _JumpIfError(hr, error, "FinishWizardPageEditControls");

    if (PSN_WIZBACK == iWizBN)
    {
        goto done;
    }

    hr = myUICASelectionValidation(&g_WebClientUICASelection, &fValid);
    _JumpIfError(hr, error, "myUICASelectionValidation");
    if (!fValid)
    {
        fDontNext = TRUE;
        goto done;
    }

    // at this point, g_WebClientUICASelection.CAType is guaranteed to be filled in     
    hr = WizardPageValidation(pComp->hInstance, pComp->fUnattended,
             hDlg, pPageString);
    if (S_OK != hr)
    {
        fDontNext = TRUE;
        goto done;
    }

    hr = myUIGetWindowText(GetDlgItem(hDlg, IDC_CLIENT_CANAME), &pwszCAName);
    _JumpIfError(hr, error, "myUIGetWindowText");
    CSASSERT(NULL != pwszCAName);


    if (NULL != pClient->pwszWebCAName)
    {
        // free old one
        LocalFree(pClient->pwszWebCAName);
    }
    pClient->pwszWebCAName = pwszCAName;
    pwszCAName = NULL;
    hr = mySanitizeName(pClient->pwszWebCAName, &pwszSanitizedCAName);
    _JumpIfError(hr, error, "mySanitizeName");
    if (NULL != pClient->pwszSanitizedWebCAName)
    {
        // free old one
        LocalFree(pClient->pwszSanitizedWebCAName);
    }
    pClient->pwszSanitizedWebCAName = pwszSanitizedCAName;
//    pClient->WebCAType = pCAInfo->CAType;
    pClient->WebCAType = g_WebClientUICASelection.CAType;

    hr = StartAndStopService(pComp->hInstance,
                 pComp->fUnattended,
                 hDlg, 
                 wszW3SVCNAME,
                 TRUE,
                 TRUE,
                 IDS_STOP_W3SVC,
                 &g_fW3SvcRunning);
    if (S_OK != hr)
    {
        if (E_ABORT == hr)
        {
            fDontNext = TRUE;
            goto done;
        }
        _JumpError(hr, error, "StartAndStopService");
    }

done:
    hr = S_OK;
error:
    if (fCoInit)
    {
        CoUninitialize();
    }
    if (fDontNext)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE); // forbid
    }
    if (NULL != pwszCAName)
    {
        LocalFree(pwszCAName);
    }
//    if (NULL != pCAInfo)
    {
//        LocalFree(pCAInfo);
    }
    return hr;
}

HRESULT
HandleClientWizActive(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp,
    PAGESTRINGS       *pPageString)
{
    HRESULT hr;

    // Suppress this wizard page if
    // we've already seen an error, or
    // the server is or will be installed, or
    // the client isn't or won't be installed, or
    // ther will be no change in client and server install states.

    if ((IS_SERVER_ENABLED & pComp->dwInstallStatus) ||
        !(IS_CLIENT_ENABLED & pComp->dwInstallStatus) ||
        !((IS_CLIENT_CHANGE | IS_SERVER_CHANGE) & pComp->dwInstallStatus))
    {
        // disable page
        CSILOGDWORD(IDS_CLIENT_TITLE, dwWIZDISABLE);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
        goto done;
    }

    // load id info
    hr = StartWizardPageEditControls(hDlg, pPageString);
    _JumpIfError(hr, error, "StartWizardPageEditControls");

done:
    hr = S_OK;
error:
    return hr;
}

//+------------------------------------------------------------------------
//  Function:   WizClientPageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure for CA Client wiz-page
//-------------------------------------------------------------------------

INT_PTR
WizClientPageDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    PER_COMPONENT_DATA *pComp = NULL;

    static BOOL  s_fComputerChange = FALSE;

    static PAGESTRINGS saClientPageString[] =
    {
        {
            IDC_CLIENT_COMPUTERNAME,
            IDS_LOG_COMPUTER,
            IDS_CLIENT_NOCOMPUTER,
            IDS_COMPUTERLENSTRERR,
            MAX_PATH,
            NULL,
        },
// you need to add code in HookClientPageStrings if adding more...
        {
            0,
            0,
            0,
            0,
            0,
            NULL
        }
    };

    switch(iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            ((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)((PROPSHEETPAGE*)lParam)->lParam;
        _ReturnIfWizError(pComp->hrContinue);
        pComp->hrContinue = InitClientWizControls(hDlg,
            saClientPageString, pComp);
        _ReturnIfWizError(pComp->hrContinue);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CLIENT_BROWSECNFG:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = GetCAConfigInfo(pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;
        case IDC_CLIENT_CANAME:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = myUICAHandleCAListDropdown(
                                    (int)HIWORD(wParam),
                                    &g_WebClientUICASelection,
                                    &s_fComputerChange);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_CLIENT_COMPUTERNAME:
            switch ((int)HIWORD(wParam))
            {
                case EN_CHANGE: // edit change
                    s_fComputerChange = TRUE;
                    break;
            }
            break;

        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {

        case PSN_KILLACTIVE:
            break;

        case PSN_RESET:
            break;

        case PSN_QUERYCANCEL:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            return CertConfirmCancel(hDlg, pComp);
            break;

        case PSN_SETACTIVE:
            CSILOGDWORD(IDS_CLIENT_TITLE, dwWIZACTIVE);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
            pComp = _GetCompDataOrReturn(pComp, hDlg);
            _DisableWizDisplayIfError(pComp, hDlg);
            _ReturnIfWizError(pComp->hrContinue);
            pComp->hrContinue = HandleClientWizActive(hDlg, pComp, saClientPageString);
             _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZBACK:
            CSILOGDWORD(IDS_CLIENT_TITLE, dwWIZBACK);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            // enable back     
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);
            pComp->hrContinue = HandleClientWizNextOrBack(hDlg,
                saClientPageString, pComp, PSN_WIZBACK);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZNEXT:
            CSILOGDWORD(IDS_CLIENT_TITLE, dwWIZNEXT);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleClientWizNextOrBack(hDlg,
                saClientPageString, pComp, PSN_WIZNEXT);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        default:
            return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);
        }
        break;

    default:
        return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);

    }
    return TRUE;
}

static CFont s_cBigBoldFont;
static BOOL s_fBigBoldFont;

BOOL ocmWiz97SetupFonts(HWND hwnd)
{
    BOOL        bReturn = FALSE;
    //
    // Create the fonts we need based on the dialog font
    //
    NONCLIENTMETRICS ncm = {0};
    ncm.cbSize = sizeof (ncm);
    SystemParametersInfo (SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

    LOGFONT BigBoldLogFont  = ncm.lfMessageFont;

    //
    // Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;

    WCHAR       largeFontSizeString[24];
    INT         largeFontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    if ( !::LoadString (g_hInstance, IDS_LARGEFONTNAME,
                        BigBoldLogFont.lfFaceName, LF_FACESIZE) ) 
    {
        CSASSERT(CSExpr(FALSE));
        lstrcpy(BigBoldLogFont.lfFaceName, L"MS Shell Dlg");
    }

    if ( ::LoadStringW (g_hInstance, IDS_LARGEFONTSIZE,
                        largeFontSizeString, ARRAYSIZE(largeFontSizeString)) ) 
    {
        largeFontSize = wcstoul (largeFontSizeString, NULL, 10);
    } 
    else 
    {
        CSASSERT(CSExpr(FALSE));
        largeFontSize = 12;
    }

    HDC hdc = GetDC(hwnd);

    if (hdc)
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc, LOGPIXELSY) * largeFontSize / 72);
        BOOL    bBigBold = s_cBigBoldFont.CreateFontIndirect (&BigBoldLogFont);

        ReleaseDC(hwnd, hdc);

        if ( bBigBold )
             bReturn = TRUE;
    }

    return bReturn;
}

HFONT ocmWiz97GetBigBoldFont(HWND hwnd)
{
   if (FALSE == s_fBigBoldFont)
   {
       if (!ocmWiz97SetupFonts(hwnd))
           return NULL;

       s_fBigBoldFont = TRUE;
   }

   return s_cBigBoldFont;
}

//+------------------------------------------------------------------------
//  Function:   WizWelcomePageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure welcome wiz-page
//-------------------------------------------------------------------------

INT_PTR
WizWelcomePageDlgProc(
    HWND hDlg,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PER_COMPONENT_DATA *pComp = NULL;
    HFONT hf;

    switch(iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            ((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)((PROPSHEETPAGE*)lParam)->lParam;

        // set wizard 97 fonts
        hf = ocmWiz97GetBigBoldFont(hDlg);
        if (NULL != hf)
            SendMessage(GetDlgItem(hDlg, IDC_TEXT_BIGBOLD), WM_SETFONT, (WPARAM)hf, MAKELPARAM(TRUE, 0));

        _ReturnIfWizError(pComp->hrContinue);

        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
            case PSN_SETACTIVE:
                // disable back button
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                pComp = _GetCompDataOrReturn(pComp, hDlg);
                _DisableWizDisplayIfError(pComp, hDlg);
                _ReturnIfWizError(pComp->hrContinue);
                break;
            default:
                return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);
        }
        break;

    default:
        return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);
    }

    return TRUE;
}

//+------------------------------------------------------------------------
//  Function:   WizFinalPageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure final wiz-page
//-------------------------------------------------------------------------

INT_PTR
WizFinalPageDlgProc(
    HWND hDlg,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PER_COMPONENT_DATA *pComp = NULL;
    HFONT hf;

    switch(iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            ((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)((PROPSHEETPAGE*)lParam)->lParam;

        hf = ocmWiz97GetBigBoldFont(hDlg);
        if (NULL != hf)
            SendMessage(GetDlgItem(hDlg,IDC_TEXT_BIGBOLD), WM_SETFONT, (WPARAM)hf, MAKELPARAM(TRUE, 0));

        _ReturnIfWizError(pComp->hrContinue);
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
            case PSN_SETACTIVE:
                // enable finish button
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH);
                pComp = _GetCompDataOrReturn(pComp, hDlg);
                // always display final wiz page
                if (S_OK != pComp->hrContinue)
                {
                    WCHAR *pwszFail = NULL;
                    HRESULT hr2 = myLoadRCString(
                                pComp->hInstance,
                                IDS_FINAL_ERROR_TEXT,
                                &pwszFail);
                    if (S_OK == hr2)
                    {
                        SetWindowText(GetDlgItem(hDlg, IDC_FINAL_STATUS),
                                      pwszFail);
                        LocalFree(pwszFail);
                    }
                    else
                    {
                        // well, use hard code string
                        SetWindowText(GetDlgItem(hDlg, IDC_FINAL_STATUS),
                                      L"Certificate Services Installation failed");
                        _PrintError(hr2, "myLoadRCString");
                    }
                }
                _ReturnIfWizError(pComp->hrContinue);
                break;
            default:
                return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);
        }
        break;

    default:
        return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);
    }

    return TRUE;
}

// Map table for dialog template resource IDs and dialog proc pointers
WIZPAGERESENTRY aWizPageResources[] = 
{
    IDD_WIZCATYPEPAGE,       WizCATypePageDlgProc,
        IDS_CATYPE_TITLE,       IDS_CATYPE_SUBTITLE,
    IDD_WIZADVANCEDPAGE,     WizAdvancedPageDlgProc,
        IDS_ADVANCE_TITLE,      IDS_ADVANCE_SUBTITLE,
    IDD_WIZIDINFOPAGE,       WizIdInfoPageDlgProc,
        IDS_IDINFO_TITLE,       IDS_IDINFO_SUBTITLE,
    IDD_WIZKEYGENPAGE,       WizKeyGenPageDlgProc,
        IDS_KEYGEN_TITLE,       IDS_KEYGEN_SUBTITLE,
    IDD_WIZSTOREPAGE,        WizStorePageDlgProc,
        IDS_STORE_TITLE,        IDS_STORE_SUBTITLE,
    IDD_WIZCAREQUESTPAGE,    WizCARequestPageDlgProc,
        IDS_CAREQUEST_TITLE,    IDS_CAREQUEST_SUBTITLE,
    IDD_WIZCLIENTPAGE,       WizClientPageDlgProc,
        IDS_CLIENT_TITLE,    IDS_CLIENT_SUBTITLE,
};
#define NUM_SERVERWIZPAGES  sizeof(aWizPageResources)/sizeof(WIZPAGERESENTRY)


HRESULT
CreateCertsrvWizPage(
    IN PER_COMPONENT_DATA      *pComp,
    IN int                      idTitle,
    IN int                      idSubTitle,
    IN int                      idDlgResource,
    IN DLGPROC                  fnDlgProc,
    IN BOOL                     fWelcomeFinal,
    OUT HPROPSHEETPAGE         *phPage)
{
    HRESULT  hr;
    PROPSHEETPAGE   Page;
    WCHAR          *pwszTitle = NULL;
    WCHAR          *pwszSubTitle = NULL;

    // init
    ZeroMemory(&Page, sizeof(PROPSHEETPAGE));

    // construct page info
    // Set titles
    Page.dwFlags = PSP_DEFAULT | PSP_HASHELP;

    if (fWelcomeFinal)
        Page.dwFlags |= PSP_HIDEHEADER;

    if (-1 != idTitle)
    {
        hr = myLoadRCString(pComp->hInstance,
                            idTitle,
                            &pwszTitle);
        _JumpIfError(hr, error, "Internal Error");
        Page.pszHeaderTitle = pwszTitle;
        Page.dwFlags |= PSP_USEHEADERTITLE;
    }
    if (-1 != idSubTitle)
    {
        hr = myLoadRCString(pComp->hInstance,
                            idSubTitle,
                            &pwszSubTitle);
        _JumpIfError(hr, error, "Internal Error");
        Page.pszHeaderSubTitle = pwszSubTitle;
        Page.dwFlags |= PSP_USEHEADERSUBTITLE;
    }

    // Set the basic property sheet data
    Page.dwSize = sizeof(PROPSHEETPAGE); // + sizeof(MYWIZPAGE);

    // Set up module and resource dependent data
    Page.hInstance = pComp->hInstance;
    Page.pszTemplate = MAKEINTRESOURCE(idDlgResource);
    Page.pfnDlgProc = fnDlgProc;
    Page.pfnCallback = NULL;
    Page.pcRefParent = NULL;
    Page.pszIcon = NULL;
    Page.pszTitle = NULL;
    Page.lParam = (LPARAM)pComp;  // pass this to wizpage handlers

    // Create the page
    *phPage = CreatePropertySheetPage(&Page);
    _JumpIfOutOfMemory(hr, error, *phPage);

    hr = S_OK;
error:
    if (NULL != pwszTitle)
    {
        LocalFree(pwszTitle);
    }
    if (NULL != pwszSubTitle)
    {
        LocalFree(pwszSubTitle);
    }
    return hr;
}


//+------------------------------------------------------------------------
//
//  Function:   DoPageRequest(. . . .)
//
//  Synopsis:   Handler for the OC_REQUEST_PAGES notification.
//
//  Effects:    Ponies up the pages for the OCM driven wizard to display.
//
//  Arguments:  [ComponentId]   ID String for the component.
//              [WhichOnes]     Type specifier for requested pages.
//              [SetupPages]    Structure to receive page handles.
//
//  Returns:    DWORD count of pages returned or -1 (MAXDWORD) in case of
//              failure; in this case SetLastError() will provide extended
//              error information.
//
//  History:    04/16/97    JerryK    Unmangled
//                08/97       XTan    major structure change
//
//-------------------------------------------------------------------------
DWORD
DoPageRequest(
    IN PER_COMPONENT_DATA      *pComp,
    IN WIZPAGERESENTRY         *pWizPageResources,
    IN DWORD                    dwWizPageNum,
    IN WizardPagesType          WhichOnes,
    IN OUT PSETUP_REQUEST_PAGES SetupPages)
{
    DWORD               dwPageNum = MAXDWORD;
    HRESULT             hr;
    DWORD               i;

    if (pComp->fUnattended)
    {
        // don't create wiz page if unattended
        return 0;
    }

    // handle welcome page
    if (pComp->fPostBase && WizPagesWelcome == WhichOnes)
    {
        if (1 > SetupPages->MaxPages)
        {
            // ask ocm allocate enough pages
            return 1; // only welcome, 1 page
        }
        hr = CreateCertsrvWizPage(
                     pComp,
                     IDS_WELCOME_TITLE,    // title,
                     -1,                   // no sub-title
                     IDD_WIZWELCOMEPAGE,
                     WizWelcomePageDlgProc,
                     TRUE,
                     &SetupPages->Pages[0]);
        _JumpIfError(hr, error, "CreateCertsrvWizPage");
        return 1; // create 1 page
    }

    // handle final page
    if (pComp->fPostBase && WizPagesFinal == WhichOnes)
    {
        if (1 > SetupPages->MaxPages)
        {
            // ask ocm allocate enough pages
            return 1; // only final, 1 page
        }
        hr = CreateCertsrvWizPage(
                     pComp,
                     IDS_FINAL_TITLE,      // title,
                     -1,                   // no sub-title
                     IDD_WIZFINALPAGE,
                     WizFinalPageDlgProc,
                     TRUE,
                     &SetupPages->Pages[0]);
        _JumpIfError(hr, error, "CreateCertsrvWizPage");
        return 1; // create 1 page
    }

    // from now on, we should only handle post net wiz pages

    if (WizPagesPostnet != WhichOnes)
    {
        // ignore all others except postnet pages
        return 0;
    }

    if (dwWizPageNum > SetupPages->MaxPages)
    {
        // OCM didn't allocate enough for pages, return # and ask more
        return dwWizPageNum;
    }

    // Create the property sheet pages for the wizard
    for (i = 0; i < dwWizPageNum; i++)
    {
        hr = CreateCertsrvWizPage(
                     pComp,
                     pWizPageResources[i].idTitle,      // title,
                     pWizPageResources[i].idSubTitle,   // sub-title
                     pWizPageResources[i].idResource,
                     pWizPageResources[i].fnDlgProc,
                     FALSE,
                     &SetupPages->Pages[i]);
        _JumpIfError(hr, error, "CreateCertsrvWizPage");
    }

    dwPageNum = dwWizPageNum;

error:
    return dwPageNum;
}

DWORD
myDoPageRequest(
    IN PER_COMPONENT_DATA *pComp,
    IN WizardPagesType WhichOnes,
    IN OUT PSETUP_REQUEST_PAGES SetupPages)
{
    pComp->CA.pServer->LastWiz = ENUM_WIZ_UNKNOWN;

    return DoPageRequest(pComp,
               aWizPageResources,
               NUM_SERVERWIZPAGES,
               WhichOnes,
               SetupPages);
}

//+-------------------------------------------------------------------------
//
//  Function:   DirExists()
//
//  Synopsis:   Determines whether or not a directory already exists.
//
//  Arguments:  [pszTestFileName]   -- Name of directory to test for.
//
//  Returns:    FALSE           --  Directory doesn't exist
//              DE_DIREXISTS    --  Directory exists
//              DE_NAMEINUSE    --  Name in use by non-directory entity
//
//  History:    10/23/96    JerryK  Created
//
//--------------------------------------------------------------------------
int
DirExists(LPTSTR pszTestFileName)
{
    DWORD dwFileAttrs;
    int nRetVal;

    // Get file attributes
    dwFileAttrs = GetFileAttributes(pszTestFileName);

    if (0xFFFFFFFF == dwFileAttrs)  // Error code from GetFileAttributes
    {
        nRetVal = FALSE;            // Couldn't open file
    }
    else if (dwFileAttrs & FILE_ATTRIBUTE_DIRECTORY)
    {
        nRetVal = DE_DIREXISTS;     // Directory already exists
    }
    else
    {
        nRetVal = DE_NAMEINUSE;     // Name in use by non-directory entity
    }

    return nRetVal;
}

BOOL
IsEverythingMatched(CASERVERSETUPINFO *pServer)
{
    return pServer->fAdvance &&
           (NULL!=pServer->pwszKeyContainerName) &&
           NULL!=pServer->pccExistingCert;
}


//====================================================================
//
// CA info code
//
//
//====================================================================

WNDPROC g_pfnValidityWndProcs;
WNDPROC g_pfnIdInfoWndProcs;


HRESULT
GetValidityEditCount(
    HWND   hDlg,
    DWORD *pdwPeriodCount)
{
    HRESULT    hr;
    WCHAR     *pwszPeriodCount = NULL;
    BOOL fValidDigitString;

    // init to 0
    *pdwPeriodCount = 0;

    hr = myUIGetWindowText(GetDlgItem(hDlg, IDC_IDINFO_EDIT_VALIDITYCOUNT),
                            &pwszPeriodCount);
    _JumpIfError(hr, error, "myUIGetWindowText");

    if (NULL != pwszPeriodCount)
    {
        *pdwPeriodCount = myWtoI(pwszPeriodCount, &fValidDigitString);
    }
    hr = S_OK;

error:
    if (NULL != pwszPeriodCount)
    {
        LocalFree(pwszPeriodCount);
    }
    return hr;
}


HRESULT
UpdateExpirationDate(
    HWND               hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT    hr;
    WCHAR      *pwszExpiration = NULL;

    hr = GetValidityEditCount(hDlg, &pServer->dwValidityPeriodCount);
    _JumpIfError(hr, error, "GetValidityEditCount");

    if (0 < pServer->dwValidityPeriodCount)
    {
        if(!pServer->pccExistingCert)
        {
            GetSystemTimeAsFileTime(&pServer->NotBefore);        
            pServer->NotAfter = pServer->NotBefore;
            myMakeExprDateTime(
		        &pServer->NotAfter,
		        pServer->dwValidityPeriodCount,
		        pServer->enumValidityPeriod);
        }

        hr = myGMTFileTimeToWszLocalTime(
				&pServer->NotAfter,
				FALSE,
				&pwszExpiration);
        _JumpIfError(hr, error, "myGMTFileTimeToWszLocalTime");

        if (!SetWindowText(GetDlgItem(hDlg, IDC_IDINFO_EXPIRATION),
                 pwszExpiration))
        {
            hr = myHLastError();
            _JumpError(hr, error, "SetWindowText");
        }
    }

    hr = S_OK;
error:
    if (NULL != pwszExpiration)
    {
        LocalFree(pwszExpiration);
    }
    return hr;
}

HRESULT
AddValidityString(
    IN HINSTANCE  hInstance,
    const HWND    hList,
    const int     ids,
    ENUM_PERIOD   enumValidityPeriod)
{
    HRESULT    hr;
    WCHAR      *pwsz = NULL;
    LRESULT    nIndex;

    hr = myLoadRCString(hInstance, ids, &pwsz);
    _JumpIfError(hr, error, "myLoadRCString");

    // add string
    nIndex = (INT)SendMessage(hList, CB_ADDSTRING, (WPARAM)0, (LPARAM)pwsz);
    if (CB_ERR == nIndex)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "SendMessage(CB_ADDSTRING)");
    }
    // set data
    nIndex = (INT)SendMessage(hList, CB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)enumValidityPeriod);
    if (CB_ERR == nIndex)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "SendMessage(CB_ADDSTRING)");
    }

    hr = S_OK;
error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    return hr;
}

HRESULT
SelectValidityString(
    PER_COMPONENT_DATA *pComp,
    HWND                hList,
    ENUM_PERIOD  enumValidityPeriod)
{
    HRESULT    hr;
    WCHAR     *pwsz = NULL;
    LRESULT    nIndex;
    LRESULT    lr;
    int        id;

    switch (enumValidityPeriod)
    {
        case ENUM_PERIOD_YEARS:
            id = IDS_VALIDITY_YEAR;
	    break;

        case ENUM_PERIOD_MONTHS:
            id = IDS_VALIDITY_MONTH;
	    break;

        case ENUM_PERIOD_WEEKS:
            id = IDS_VALIDITY_WEEK;
	    break;

        case ENUM_PERIOD_DAYS:
            id = IDS_VALIDITY_DAY;
	    break;

        default:
            hr = E_INVALIDARG;
            _JumpError(hr, error, "Invalid validity period enum");
        break;
    }

    hr = myLoadRCString(pComp->hInstance, id, &pwsz);
    _JumpIfError(hr, error, "myLoadRCString");

    nIndex = (INT)SendMessage(hList, CB_FINDSTRING, (WPARAM)0, (LPARAM)pwsz);
    if (CB_ERR == nIndex)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "SendMessage(CB_FINDSTRING)");
    }

    lr = (INT)SendMessage(hList, CB_SETCURSEL, (WPARAM)nIndex, (LPARAM)0);
    if (CB_ERR == lr)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "SendMessage(CB_FINDSTRING)");
    }

    lr = (INT)SendMessage(hList, CB_GETITEMDATA, (WPARAM)nIndex, (LPARAM)0);
    if (CB_ERR == lr)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "SendMessage(CB_FINDSTRING)");
    }

    pComp->CA.pServer->enumValidityPeriod = (ENUM_PERIOD)lr;

    hr = S_OK;
error:
    if (pwsz)
       LocalFree(pwsz);

    return hr;
}

HRESULT
DetermineKeyExistence(
    CSP_INFO *pCSPInfo,
    WCHAR    *pwszKeyName)
{
    HRESULT      hr;
    HCRYPTPROV   hProv = NULL;

    if (!myCertSrvCryptAcquireContext(
                &hProv,
                pwszKeyName,
                pCSPInfo->pwszProvName,
                pCSPInfo->dwProvType,
                CRYPT_SILENT,
                TRUE))
    {
        hr = myHLastError();
        goto error;
    }
    hr = S_OK;
error:
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    return hr;
}

LRESULT CALLBACK
ValidityEditFilterHook(
    HWND hwnd,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL  fUpdate = FALSE;
    LRESULT  lr;
    CASERVERSETUPINFO *pServer = (CASERVERSETUPINFO*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch(iMsg)
    {
        case WM_CHAR:
            fUpdate = TRUE;
            if (!iswdigit((TCHAR) wParam))
            {
                if (VK_BACK != (int)wParam)
                {
                    // ignore the key
                    MessageBeep(0xFFFFFFFF);
                    return 0;
                }
            }
            break;
        case WM_KEYDOWN:
            if (VK_DELETE == (int)wParam)
            {
                // validity is changed
                fUpdate = TRUE;
            }
            break;
    }
    lr = CallWindowProc(
            g_pfnValidityWndProcs,
            hwnd,
            iMsg,
            wParam,
            lParam);
    if (fUpdate)
    {
        UpdateExpirationDate(GetParent(hwnd), pServer);
    }
    return lr;
}

HRESULT MakeNullStringEmpty(LPWSTR *ppwszStr)
{
    if(!*ppwszStr)
        return myDupString(L"", ppwszStr);
    return S_OK;
}

HRESULT
HideAndShowMachineDNControls(
    HWND hDlg,
    CASERVERSETUPINFO   *pServer)
{
    HRESULT hr;

    hr = MakeNullStringEmpty(&pServer->pwszFullCADN);
    _JumpIfError(hr, error, "MakeNullStringEmpty");
    hr = MakeNullStringEmpty(&pServer->pwszCACommonName);
    _JumpIfError(hr, error, "MakeNullStringEmpty");
    hr = MakeNullStringEmpty(&pServer->pwszDNSuffix);
    _JumpIfError(hr, error, "MakeNullStringEmpty");

    SetDlgItemText(hDlg, IDC_IDINFO_NAMEEDIT,       pServer->pwszCACommonName);
    SetDlgItemText(hDlg, IDC_IDINFO_DNSUFFIXEDIT,   pServer->pwszDNSuffix);
    SetDlgItemText(hDlg, IDC_IDINFO_NAMEPREVIEW,    pServer->pwszFullCADN);

    // name preview is never editable
//    EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_NAMEPREVIEW),  FALSE);
    SendDlgItemMessage(hDlg, IDC_IDINFO_NAMEPREVIEW,  EM_SETREADONLY, TRUE, 0);    

    // if we're in reuse cert mode, we can't edit the DNs
    if (NULL != pServer->pccExistingCert)
    {
//        EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT),     FALSE);
//        EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_DNSUFFIXEDIT), FALSE);
        

        SendDlgItemMessage(hDlg, IDC_IDINFO_NAMEEDIT,     EM_SETREADONLY, TRUE, 0);
        SendDlgItemMessage(hDlg, IDC_IDINFO_DNSUFFIXEDIT, EM_SETREADONLY, TRUE, 0);
    }
    else
    {
        // set the defaults again
        // and re-enable everything else
//        EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT), TRUE);
//        EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_DNSUFFIXEDIT), TRUE);

        SendDlgItemMessage(hDlg, IDC_IDINFO_NAMEEDIT, EM_SETREADONLY, FALSE, 0);
        SendDlgItemMessage(hDlg, IDC_IDINFO_DNSUFFIXEDIT, EM_SETREADONLY, FALSE, 0);
    //    SendDlgItemMessage(hDlg, IDC_IDINFO_NAMEPREVIEW,  EM_SETREADONLY, FALSE, 0);    
    }

    hr = S_OK;
error:

    return hr;
}

HRESULT InitNameFields(CASERVERSETUPINFO *pServer)
{
    HRESULT hr = S_OK;
    CAutoLPWSTR pwsz;
    const WCHAR *pwszFirstDCComponent = L"";
    
    if(pServer->pccExistingCert)
    {
    }
    else
    {
        if(!pServer->pwszCACommonName)
        {
            // avoid null name
            hr = myDupString(L"", &pServer->pwszCACommonName);
            _JumpIfError(hr, error, "myDupString");
        }
    
        hr = myGetComputerObjectName(NameFullyQualifiedDN, &pwsz);
        _PrintIfError(hr, "myGetComputerObjectName");

        if (S_OK == hr && pwsz != NULL)
        {
            pwszFirstDCComponent = wcsstr(pwsz, L"DC=");
        }

        if(pServer->pwszDNSuffix)
        {
            LocalFree(pServer->pwszDNSuffix);
            pServer->pwszDNSuffix = NULL;
        }

        if(!pwszFirstDCComponent)
        {
            pwszFirstDCComponent = L"";
        }

        hr = myDupString(pwszFirstDCComponent, &pServer->pwszDNSuffix);
	    _JumpIfError(hr, error, "myDupString");

        if(pServer->pwszFullCADN)
        {
            LocalFree(pServer->pwszFullCADN);
            pServer->pwszFullCADN = NULL;
        }
    
        hr = BuildFullDN(
            pServer->pwszCACommonName,
            pwszFirstDCComponent,
            &pServer->pwszFullCADN);
        _JumpIfError(hr, error, "BuildFullDN");
    }

error:
    return hr;
}


// Builds full DN "CN=CAName,DistinguishedName" where CAName and DistinguishedName
// could be empty or NULL;
HRESULT BuildFullDN(
    OPTIONAL LPCWSTR pcwszCAName,
    OPTIONAL LPCWSTR pcwszDNSuffix,
    LPWSTR* ppwszFullDN)
{
    HRESULT hr = S_OK;
    DWORD cBytes = 4; // 4 chars for leading "CN=" plus null terminator

    CSASSERT(ppwszFullDN);

    if(!EmptyString(pcwszCAName))
        cBytes += wcslen(pcwszCAName);

    if(!EmptyString(pcwszDNSuffix))
        cBytes += wcslen(pcwszDNSuffix)+1; // comma

    cBytes *= sizeof(WCHAR);

    *ppwszFullDN = (LPWSTR) LocalAlloc(LMEM_FIXED, cBytes);
    _JumpIfAllocFailed(*ppwszFullDN, error);

    wcscpy(*ppwszFullDN, L"CN=");

    if(!EmptyString(pcwszCAName))
    {
        wcscat(*ppwszFullDN, pcwszCAName);
    }
    
    if(!EmptyString(pcwszDNSuffix))
    {
        wcscat(*ppwszFullDN, L",");
        wcscat(*ppwszFullDN, pcwszDNSuffix);
    }

error:
    return hr;
}

HRESULT
EnableValidityControls(HWND hDlg, BOOL fEnabled)
{
    EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_COMBO_VALIDITYSTRING), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_EDIT_VALIDITYCOUNT), fEnabled);
    return S_OK;
}

HRESULT
HideAndShowValidityControls(
    HWND         hDlg,
    ENUM_CATYPES CAType)
{
    // default to root ca
    int    showValidity = SW_SHOW;
    int    showHelp = SW_HIDE;
    BOOL   fEnableLabel = TRUE;

    if (IsSubordinateCA(CAType))
    {
        showValidity = SW_HIDE;
        showHelp = SW_SHOW;
        fEnableLabel = FALSE;
    }

    ShowWindow(GetDlgItem(hDlg, IDC_IDINFO_DETERMINEDBYPCA), showHelp);
    ShowWindow(GetDlgItem(hDlg, IDC_IDINFO_EDIT_VALIDITYCOUNT), showValidity);
    ShowWindow(GetDlgItem(hDlg, IDC_IDINFO_COMBO_VALIDITYSTRING), showValidity);
    ShowWindow(GetDlgItem(hDlg, IDC_IDINFO_EXPIRATION_LABEL), showValidity);
    ShowWindow(GetDlgItem(hDlg, IDC_IDINFO_EXPIRATION), showValidity);
    EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_VPLABEL), fEnableLabel);

   return S_OK;
}

HRESULT
InitValidityControls(
    HWND hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT    hr;
    HWND       hwndCtrl = GetDlgItem(hDlg, IDC_IDINFO_COMBO_VALIDITYSTRING);
    WCHAR      *pwsz = NULL;

    // load validity help text
    hr = myLoadRCString(pComp->hInstance, IDS_IDINFO_DETERMINEDBYPCA, &pwsz);
    _JumpIfError(hr, error, "LoadString");

    if (!SetWindowText(GetDlgItem(hDlg, IDC_IDINFO_DETERMINEDBYPCA), pwsz))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetWindowText");
    }

    // load validity period strings

    hr = AddValidityString(pComp->hInstance, hwndCtrl, IDS_VALIDITY_YEAR,
             ENUM_PERIOD_YEARS);
    _JumpIfError(hr, error, "AddValidityString");

    hr = AddValidityString(pComp->hInstance, hwndCtrl, IDS_VALIDITY_MONTH,
             ENUM_PERIOD_MONTHS);
    _JumpIfError(hr, error, "AddValidityString");

    hr = AddValidityString(pComp->hInstance, hwndCtrl, IDS_VALIDITY_WEEK,
             ENUM_PERIOD_WEEKS);
    _JumpIfError(hr, error, "AddValidityString");

    hr = AddValidityString(pComp->hInstance, hwndCtrl, IDS_VALIDITY_DAY,
             ENUM_PERIOD_DAYS);
    _JumpIfError(hr, error, "AddValidityString");

    hr = S_OK;
error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    return hr;
}


HRESULT
EnableMatchedCertIdInfoEditFields(HWND hDlg, BOOL fEnable)
{
    HRESULT hr;

    EnableValidityControls(hDlg, fEnable);
    
    hr = S_OK;
//error:
    return hr;
}

HRESULT 
WizIdInfoPageSetHooks(HWND hDlg, PER_COMPONENT_DATA *pComp)
{
    HRESULT     hr;

    CSASSERT (NULL != pComp);

    // CA Name filter proc
    g_pfnIdInfoWndProcs = 
        (WNDPROC) SetWindowLongPtr(
                    GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT),
                    GWLP_WNDPROC,
                    (LPARAM)IdInfoNameEditFilterHook);
    if (0 == g_pfnIdInfoWndProcs)
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetWindowLongPtr");
    }

    SetLastError(0);
    if (0 == SetWindowLongPtr(
                    GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT),
                    GWLP_USERDATA,
                    (LPARAM)pComp->CA.pServer))
    {
        hr = myHLastError(); // might return S_OK
        _JumpIfError(hr, error, "SetWindowLongPtr USERDATA");
    }

    hr = S_OK;
error:
    return hr;
}

HRESULT
HandleValidityStringChange(
    HWND               hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    LRESULT nItem;
    LRESULT lr;
    HWND hwndCtrl = GetDlgItem(hDlg, IDC_IDINFO_COMBO_VALIDITYSTRING);

    if (NULL == hwndCtrl)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal Error");
    }

    nItem = (INT)SendMessage(hwndCtrl, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
    if (CB_ERR == nItem)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal Error");
    }

    lr = (INT)SendMessage(hwndCtrl, CB_GETITEMDATA, (WPARAM)nItem, (LPARAM)0);
    if (CB_ERR == nItem)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal Error");
    }

    pServer->enumValidityPeriod = (ENUM_PERIOD)lr;

    hr = UpdateExpirationDate(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateExpirationDate");

    hr = S_OK;

error:

    return hr;
}
HRESULT
HookIdInfoPageStrings(
    PAGESTRINGS       *pPageString,
    CASERVERSETUPINFO *pServer)
{
    HRESULT    hr;

    for ( ; 0 != pPageString->idControl; pPageString++)
    {
        switch (pPageString->idControl)
        {
            case IDC_IDINFO_NAMEEDIT:
                pPageString->ppwszString = &(pServer->pwszCACommonName);
            break;
            case IDC_IDINFO_EDIT_VALIDITYCOUNT:
                pPageString->ppwszString = &(pServer->pwszValidityPeriodCount);
            break;
            default:
                hr = E_INVALIDARG;
                _JumpError(hr, error, "Internal error");
            break;
        }
    }
    hr = S_OK;
error:
    return hr;
}

HRESULT
InitIdInfoWizControls(
    HWND                hDlg,
    PAGESTRINGS        *pIdPageString,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT        hr;
    HWND           hwndCtrl;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    // now make page strings complete
    hr = HookIdInfoPageStrings(pIdPageString, pServer);
    _JumpIfError(hr, error, "HookIdInfoPageStrings");

    hr = WizPageSetTextLimits(hDlg, pIdPageString);
    _JumpIfError(hr, error, "WizPageSetTextLimits");

    hr = WizIdInfoPageSetHooks(hDlg, pComp);
    _JumpIfError(hr, error, "WizIdInfoPageSetHooks");

    hr = InitValidityControls(hDlg, pComp);
    _JumpIfError(hr, error, "InitValidityControls");

    if (!IsSubordinateCA(pServer->CAType))
    {
        hwndCtrl = GetDlgItem(hDlg, IDC_IDINFO_EDIT_VALIDITYCOUNT);
        g_pfnValidityWndProcs = (WNDPROC)SetWindowLongPtr(hwndCtrl,
            GWLP_WNDPROC, (LPARAM)ValidityEditFilterHook);
        if (NULL == g_pfnValidityWndProcs)
        {
            hr = myHLastError();
            _JumpError(hr, error, "SetWindowLongPtr");
        }
        // pass data
        SetWindowLongPtr(hwndCtrl, GWLP_USERDATA, (ULONG_PTR)pServer);
    }

    hr = S_OK;
error:
    return hr;
}

HRESULT
UpdateValidityMaxDigits(
    BOOL         fMatchAll,
    PAGESTRINGS *pIdPageString)
{
    HRESULT hr;

    for (; 0 != pIdPageString; pIdPageString++)
    {
        if (IDC_IDINFO_EDIT_VALIDITYCOUNT == pIdPageString->idControl)
        {
            pIdPageString->cchMax = fMatchAll? UB_VALIDITY_ANY : UB_VALIDITY;
            break;
        }
    }

    hr = S_OK;
//error:
    return hr;
}

HRESULT
HandleIdInfoWizActive(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp,
    PAGESTRINGS       *pIdPageString)
{
    HRESULT              hr;
    WCHAR                wszValidity[cwcDWORDSPRINTF];
    CASERVERSETUPINFO   *pServer = pComp->CA.pServer;
    ENUM_PERIOD   enumValidityPeriod = pServer->enumValidityPeriod;
    BOOL                 fMatchAll;

    // Suppress this wizard page if
    // we've already seen an error, or
    // we are not installing the server.

    if (!(IS_SERVER_INSTALL & pComp->dwInstallStatus) )
    {
        // disable page
        CSILOGDWORD(IDS_IDINFO_TITLE, dwWIZDISABLE);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
        goto done;
    }
 
    if (ENUM_WIZ_STORE == pServer->LastWiz)
    {
        // if back from ca request, reset
        g_fAllowUnicodeStrEncoding = FALSE;
    }

    if (pServer->fAdvance &&
        ENUM_WIZ_KEYGEN == pServer->LastWiz &&
        (pServer->fKeyGenFailed || pServer->fValidatedHashAndKey) )
    {
        // key gen failed and go back
        PropSheet_PressButton(GetParent(hDlg), PSBTN_BACK);
    }

    if (!pServer->fAdvance && ENUM_WIZ_CATYPE == pServer->LastWiz)
    {
        hr = LoadDefaultAdvanceAttributes(pServer);
        _JumpIfError(hr, error, "LoadDefaultAdvanceAttributes");
    }

    hr = HideAndShowValidityControls(hDlg, pServer->CAType);
    _JumpIfError(hr, error, "HideAndShowValidityControls");
 
    hr = HideAndShowMachineDNControls(hDlg, pServer);
    _JumpIfError(hr, error, "HideAndShowMachineDNControls");
 
    // load id info
    hr = StartWizardPageEditControls(hDlg, pIdPageString);
    _JumpIfError(hr, error, "StartWizardPageEditControls");

    hr = EnableMatchedCertIdInfoEditFields(hDlg, TRUE);
    _JumpIfError(hr, error, "EnableMatchedCertIdInfoEditFields");

    // default
    wsprintf(wszValidity, L"%u", pServer->dwValidityPeriodCount);

    fMatchAll = IsEverythingMatched(pServer);

    if (fMatchAll)
    {
        enumValidityPeriod = ENUM_PERIOD_DAYS;
        wsprintf(wszValidity, L"%u", pServer->lExistingValidity);
        hr = EnableMatchedCertIdInfoEditFields(hDlg, FALSE);
        _JumpIfError(hr, error, "EnableMatchedCertIdInfoEditFields");
    }

    // update validity period string

    hr = SelectValidityString(
			pComp, 
			GetDlgItem(hDlg, IDC_IDINFO_COMBO_VALIDITYSTRING),
			enumValidityPeriod);
    _JumpIfError(hr, error, "SelectValidityString");
    // update validity
    SetWindowText(GetDlgItem(hDlg, IDC_IDINFO_EDIT_VALIDITYCOUNT), wszValidity);
    
    hr = UpdateExpirationDate(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateExpirationDate");

    // update validity digits max for validation
    hr = UpdateValidityMaxDigits(fMatchAll, pIdPageString);
    _JumpIfError(hr, error, "UpdateValidityMaxDigits");

    EnableValidityControls(hDlg, !IsSubordinateCA(pServer->CAType) && !fMatchAll);

done:
    hr = S_OK;
error:
    return hr;
}


// check server RDN info, warning any invalid or
// or confirm from users once if any unicode string encoding
BOOL
IsAnyInvalidRDN(
    OPTIONAL HWND       hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr = S_OK;
    BOOL  fInvalidRDN = TRUE;
    BYTE  *pbEncodedName = NULL;
    DWORD  cbEncodedName;
    CERT_NAME_INFO *pbDecodedNameInfo = NULL;
    DWORD           cbDecodedNameInfo;
    CERT_NAME_INFO *pNameInfo = NULL;
    DWORD   *pIndexRDN = NULL;
    DWORD   *pIndexAttr = NULL;
    DWORD   dwUnicodeCount;
    WCHAR   *pwszAllStrings = NULL;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    DWORD indexRDN;
    DWORD indexAttr;

    LPCWSTR pszErrorPtr = NULL;

    // don't bother calling with CERT_NAME_STR_REVERSE_FLAG, we're just throwing this encoding away
    hr = myCertStrToName(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            pServer->pwszDNSuffix,
            CERT_X500_NAME_STR | CERT_NAME_STR_COMMA_FLAG, 
            NULL,
            &pbEncodedName,
            &cbEncodedName,
            &pszErrorPtr);

    if(S_OK != hr)
    {
            CertWarningMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hDlg,
                        IDS_WRN_IDINFO_INVALIDDN,
                        0,
                        NULL);

            int nStartIndex = 0;
            int nEndIndex = wcslen(pServer->pwszDNSuffix);

            if(pszErrorPtr)
            {
                nStartIndex = SAFE_SUBTRACT_POINTERS(pszErrorPtr,pServer->pwszDNSuffix);

                const WCHAR *pwszNextComma = wcsstr(pszErrorPtr, L",");
                if(pwszNextComma)
                {
                    nEndIndex = SAFE_SUBTRACT_POINTERS(pwszNextComma,pServer->pwszDNSuffix+1);
                }
            }

            SetEditFocusAndSelect(
                GetDlgItem(hDlg, IDC_IDINFO_DNSUFFIXEDIT),
                nStartIndex, 
                nEndIndex);
    }
    _JumpIfError(hr, error, "myCertStrToName");

    LocalFree(pbEncodedName);
    pbEncodedName = NULL;

    hr = AddCNAndEncode(
		pServer->pwszCACommonName,
		pServer->pwszDNSuffix,
		&pbEncodedName,
		&cbEncodedName);
    _JumpIfError(hr, error, "AddCNAndEncode");

    // call CryptDecodeObject to get pbDecodedNameInfo

    // if hit here, check if any unicode string encoding
    if (!g_fAllowUnicodeStrEncoding && !pComp->fUnattended)
    {

        // decode to nameinfo
        if (!myDecodeName(
                X509_ASN_ENCODING,
                X509_UNICODE_NAME,
                pbEncodedName,
                cbEncodedName,
                CERTLIB_USE_LOCALALLOC,
                &pbDecodedNameInfo,
                &cbDecodedNameInfo))
        {
            hr = myHLastError();
            _JumpError(hr, error, "myDecodeName");
        }

        // calculate attributes total in RDN
        dwUnicodeCount = 0;
        for (indexRDN = 0; indexRDN < pbDecodedNameInfo->cRDN; ++indexRDN)
        {
            dwUnicodeCount += pbDecodedNameInfo->rgRDN[indexRDN].cRDNAttr;
        }

        // allocate & init index
        // sure allocate max for possible all unicode strings
        pIndexRDN = (DWORD*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                             dwUnicodeCount * sizeof(DWORD));
        _JumpIfOutOfMemory(hr, error, pIndexRDN);
        pIndexAttr = (DWORD*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                             dwUnicodeCount * sizeof(DWORD));
        _JumpIfOutOfMemory(hr, error, pIndexAttr);

        dwUnicodeCount = 0; // reset count
        for (indexRDN = 0; indexRDN < pbDecodedNameInfo->cRDN; ++indexRDN)
        {
	    DWORD cRDNAttr = pbDecodedNameInfo->rgRDN[indexRDN].cRDNAttr;
	    CERT_RDN_ATTR *rgRDNAttr = pbDecodedNameInfo->rgRDN[indexRDN].rgRDNAttr;

            // for each RDN
            for (indexAttr = 0; indexAttr < cRDNAttr; indexAttr++)
            {
                // for each attr, check unicode string

		switch (rgRDNAttr[indexAttr].dwValueType)
		{
		    case CERT_RDN_UTF8_STRING:
		    case CERT_RDN_UNICODE_STRING:
			// there is a unicode or UTF8 string, save index

			pIndexRDN[dwUnicodeCount] = indexRDN;
			pIndexAttr[dwUnicodeCount] = indexAttr;

			// set count

			++dwUnicodeCount;
			break;
                }
            }
        }
        if (0 == dwUnicodeCount)
        {
            // no unicode string encoding
            goto done;
        }

        // calculate size of all unicode strings for display
        DWORD dwLen = 0;
        for (indexAttr = 0; indexAttr < dwUnicodeCount; ++indexAttr)
        {
          dwLen += (wcslen((WCHAR*)pbDecodedNameInfo->rgRDN[pIndexRDN[indexAttr]].rgRDNAttr[pIndexAttr[indexAttr]].Value.pbData) + 3 ) * sizeof(WCHAR);
        }
        pwszAllStrings = (WCHAR*)LocalAlloc(LMEM_FIXED, dwLen);
        _JumpIfOutOfMemory(hr, error, pwszAllStrings);

        // form all strings for display
        for (indexAttr = 0; indexAttr < dwUnicodeCount; ++indexAttr)
        {
            if (0 == indexAttr)
            {
                wcscpy(pwszAllStrings, (WCHAR*)
                       pbDecodedNameInfo->rgRDN[pIndexRDN[indexAttr]].rgRDNAttr[pIndexAttr[indexAttr]].Value.pbData);
            }
            else
            {
                wcscat(pwszAllStrings, (WCHAR*)
                       pbDecodedNameInfo->rgRDN[pIndexRDN[indexAttr]].rgRDNAttr[pIndexAttr[indexAttr]].Value.pbData);
            }
            if (dwUnicodeCount - 1 > indexAttr)
            {
                // add comma + new line
                wcscat(pwszAllStrings, L",\n");
            }
        }

        // ok, ready to put out a warning
        if (IDYES == CertMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_WRN_UNICODESTRINGENCODING,
                    0,
                    MB_YESNO |
                    MB_ICONWARNING |
                    CMB_NOERRFROMSYS,
                    NULL)) //pwszAllStrings))
        {
            // warning only once
            g_fAllowUnicodeStrEncoding = TRUE;
            goto done;
        }

        goto error;
    }

done:

    fInvalidRDN = FALSE;
error:
    if (NULL != pIndexRDN)
    {
        LocalFree(pIndexRDN);
    }
    if (NULL != pIndexAttr)
    {
        LocalFree(pIndexAttr);
    }
    if (NULL != pwszAllStrings)
    {
        LocalFree(pwszAllStrings);
    }
    if (NULL != pbEncodedName)
    {
        LocalFree(pbEncodedName);
    }
    if (NULL != pbDecodedNameInfo)
    {
        LocalFree(pbDecodedNameInfo);
    }
    if (NULL != pNameInfo)
    {
        csiFreeCertNameInfo(pNameInfo);
    }
    return fInvalidRDN;
}
    
/*HRESULT ExtractCommonName(LPCWSTR pcwszDN, LPWSTR* ppwszCN)
{
    HRESULT hr = S_OK;
    WCHAR* pszComma;
    LPWSTR pwszDNUpperCase = NULL;
    const WCHAR* pszCN = pcwszDN;

    if(0!=_wcsnicmp(pcwszDN, L"CN=", wcslen(L"CN=")))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, 
            "distinguished name doesn't start with the common name");
    }

    pszCN += wcslen(L"CN=");

    while(iswspace(*pszCN))
        pszCN++;

    pszComma = wcsstr(pszCN, L",");
    DWORD iChars;
    if (pszComma == NULL)
    {
       // ONLY CN= string, no additional names
       iChars = wcslen(pszCN);
    }
    else
    {
       iChars = SAFE_SUBTRACT_POINTERS(pszComma, pszCN);
    }

    if(0==iChars)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, 
            "invalid syntax, common name should follow CN=");
    }

    *ppwszCN = (LPWSTR)LocalAlloc(LMEM_FIXED, (iChars+1)*sizeof(WCHAR));
    _JumpIfAllocFailed(*ppwszCN, error);

    CopyMemory(*ppwszCN, pszCN, iChars*sizeof(WCHAR));
    (*ppwszCN)[iChars] = L'\0';

error:

    LOCAL_FREE(pwszDNUpperCase);
    return hr;
}*/

HRESULT
HandleIdInfoWizNextOrBack(
    HWND hDlg,
    PER_COMPONENT_DATA *pComp,
    PAGESTRINGS       *pIdPageString,
    int                iWizBN)
{
    HRESULT  hr;
    WCHAR   *pwszSanitizedName = NULL;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    BOOL     fDontNext = FALSE;
    BOOL fValidDigitString;
    WCHAR * pwszFullPath = NULL;
    WCHAR * pwszDir = NULL;
    DWORD cDirLen;

    hr = FinishWizardPageEditControls(hDlg, pIdPageString);
    _JumpIfError(hr, error, "FinishWizardPageEditControls");

    if (PSN_WIZBACK == iWizBN)
    {
        goto done;
    }

    hr = WizardPageValidation(pComp->hInstance, pComp->fUnattended,
             hDlg, pIdPageString);
    if (S_OK != hr)
    {
        _PrintError(hr, "WizardPageValidation");
        fDontNext = TRUE;
        goto done;
    }

    // snag the full DN specified
    if (NULL != pServer->pwszCACommonName)
    {
        LocalFree(pServer->pwszCACommonName);
	pServer->pwszCACommonName = NULL;
    }
    if (NULL != pServer->pwszFullCADN)
    {
        LocalFree(pServer->pwszFullCADN); 
        pServer->pwszFullCADN = NULL;
    }
    if (NULL != pServer->pwszDNSuffix)
    {
        LocalFree(pServer->pwszDNSuffix);
        pServer->pwszDNSuffix = NULL;
    }

    myUIGetWindowText(GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT), &pServer->pwszCACommonName);
    myUIGetWindowText(GetDlgItem(hDlg, IDC_IDINFO_NAMEPREVIEW), &pServer->pwszFullCADN);
    myUIGetWindowText(GetDlgItem(hDlg, IDC_IDINFO_DNSUFFIXEDIT), &pServer->pwszDNSuffix);

    // if generate a new cert
    if (NULL == pServer->pccExistingCert &&
        IsAnyInvalidRDN(hDlg, pComp))
    {
        fDontNext = TRUE;
        goto done;
    }

    // if we are not using an existing cert, verify the chosen validity
    // period of the new cert.
    if (NULL==pServer->pccExistingCert)
    {
        // convert validity count string to a number

        pServer->dwValidityPeriodCount = myWtoI(
					    pServer->pwszValidityPeriodCount,
					    &fValidDigitString);
	if (!fValidDigitString ||
        !IsValidPeriod(pServer))
        {
            // validity out of range, put out a warning dlg
            CertWarningMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hDlg,
                IDS_IDINFO_INVALID_VALIDITY,
                0,
                NULL);
            SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_IDINFO_EDIT_VALIDITYCOUNT), 0, MAXDWORD);
            _PrintError(E_INVALIDARG, "invalid validity");
            fDontNext = TRUE;
            goto done;
        }
    }

    // get sanitized name
    hr = mySanitizeName(pServer->pwszCACommonName, &pwszSanitizedName);
    _JumpIfError(hr, error, "mySanitizeName");

    CSILOG(
	hr,
	IDS_ILOG_SANITIZEDNAME,
	pwszSanitizedName,
	NULL,
	NULL);

    if (MAX_PATH <= wcslen(pwszSanitizedName) + cwcSUFFIXMAX)
    {
        CertMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hDlg,
                IDS_WRN_KEYNAMETOOLONG,
                S_OK,
                MB_ICONWARNING | CMB_NOERRFROMSYS,
                pwszSanitizedName);
        SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT), 0, MAXDWORD);
        fDontNext = TRUE;
        goto done;
    }

    // if we are making a new key, see if a key by that name already exists.
    // if it does, see if the user wants to overwrite it.

    if (NULL == pServer->pwszKeyContainerName)
    {
        if (S_OK == DetermineKeyExistence(pServer->pCSPInfo, pwszSanitizedName))
        {
            // warn user if key exist
            if (IDYES != CertMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_WRN_OVERWRITEEXISTINGKEY,
                    S_OK,
                    MB_YESNO |
                        MB_ICONWARNING |
                        MB_DEFBUTTON2 |
                        CMB_NOERRFROMSYS,
                    pServer->pwszCACommonName))
            {
                SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT), 0, MAXDWORD);
                fDontNext = TRUE;
                goto done;
            }
        }
    }

    if (NULL != pServer->pwszSanitizedName)
    {
        // free old
        LocalFree(pServer->pwszSanitizedName);
    }
    pServer->pwszSanitizedName = pwszSanitizedName;
    pwszSanitizedName = NULL;

    if (pServer->fUseDS)
    {
        if (IsCAExistInDS(pServer->pwszSanitizedName))
        {
            int ret = CertMessageBox(
                          pComp->hInstance,
                          pComp->fUnattended,
                          hDlg,
                          IDS_IDINFO_CAEXISTINDS,
                          0,
                          MB_YESNO |
                          MB_ICONWARNING |
                          CMB_NOERRFROMSYS,
                          NULL);
            if (IDYES != ret)
            {
                // not overwrite
                SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT), 0, MAXDWORD);
                fDontNext = TRUE;
                goto done;
            }
            else
            {
                hr =  RemoveCAInDS(pServer->pwszSanitizedName);
                if(hr != S_OK)
                {
                    _PrintError(hr, "RemoveCAInDS");
                    SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT), 0, MAXDWORD);
                    fDontNext = TRUE;
                    goto done;
                }
            }
        }
    }

    hr = UpdateDomainAndUserName(hDlg, pComp);
    _JumpIfError(hr, error, "UpdateDomainAndUserName");


    if(pServer->fUseDS)
    {
        pServer->dwRevocationFlags = REVEXT_DEFAULT_DS;
    }
    else
    {
        pServer->dwRevocationFlags = REVEXT_DEFAULT_NODS;
    }

    // validate cert file path lenght
    cDirLen = wcslen(pComp->pwszSystem32)+
        wcslen(wszCERTENROLLSHAREPATH) + 1;

    pwszDir = (WCHAR *) LocalAlloc(LMEM_FIXED, cDirLen * sizeof(WCHAR));
    if (NULL == pwszDir)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    wcscpy(pwszDir, pComp->pwszSystem32); // has trailing "\\"
    wcscat(pwszDir, wszCERTENROLLSHAREPATH);

    hr = csiBuildFileName(
                pwszDir,
                pServer->pwszSanitizedName,
                L".crt",
                0,
                &pwszFullPath,
                pComp->hInstance,
                pComp->fUnattended,
                hDlg);
    _JumpIfError(hr, error, "csiBuildFileName");
    
    if (MAX_PATH <= wcslen(pwszFullPath) + cwcSUFFIXMAX)
    {
        // pop up warning
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg,
            IDS_PATH_TOO_LONG_CANAME,
            S_OK,
            pwszFullPath);
        fDontNext = TRUE;
        goto done;
    }

done:
    if (fDontNext)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE); // forbid
    }
    else
    {
        pServer->LastWiz = ENUM_WIZ_IDINFO;
    }
    hr = S_OK;
error:
    if (NULL != pwszSanitizedName)
    {
        LocalFree(pwszSanitizedName);
    }
    if(NULL != pwszFullPath)
    {
        LocalFree(pwszFullPath);
    }
    if(NULL != pwszDir)
    {
        LocalFree(pwszDir);
    }

    return hr;
}


PAGESTRINGS g_aIdPageString[] =
    {
        {
            IDC_IDINFO_NAMEEDIT,
            IDS_LOG_CANAME,
            IDS_IDINFO_NAMENULLSTRERR,
            IDS_IDINFO_NAMELENSTRERR,
            cchCOMMONNAMEMAX,
            NULL,
        },
        {
            IDC_IDINFO_EDIT_VALIDITYCOUNT,
            IDS_LOG_VALIDITY,
            IDS_IDINFO_VALIDITYNULLSTRERR,
            IDS_IDINFO_VALIDITYLENSTRERR,
            UB_VALIDITY,
            NULL,
        },
// you need to add code in HookIdInfoPageStrings if adding more...
        {
            0,
            0,
            0,
            0,
            0,
            NULL,
        }
    };

LRESULT CALLBACK
IdInfoNameEditFilterHook(
    HWND hwnd,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (iMsg)
    {
	case WM_CHAR:
	    if ((WCHAR)wParam == L',')
	    {
                MessageBeep(0xFFFFFFFF);
                return(0);
	    }
	    break;
    }
    return(CallWindowProc(
		g_pfnIdInfoWndProcs,
		hwnd,
		iMsg,
		wParam,
		lParam));
}


//-------------------------------------------------------------------------
//  WizIdInfoPageDlgProc
//-------------------------------------------------------------------------
INT_PTR
WizIdInfoPageDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    PER_COMPONENT_DATA *pComp = NULL;

    switch(iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            (ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)(ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam;
        _ReturnIfWizError(pComp->hrContinue);
        pComp->hrContinue = InitIdInfoWizControls(hDlg,
                                 g_aIdPageString,
                                 pComp);
        _ReturnIfWizError(pComp->hrContinue);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_IDINFO_NAMEEDIT:
        case IDC_IDINFO_DNSUFFIXEDIT:
            if (HIWORD(wParam) == EN_CHANGE)
            {
                CAutoLPWSTR pwszCAName, pwszDNSuffix, pwszFullDN;
                CASERVERSETUPINFO* pServer;
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pServer = pComp->CA.pServer;
                // if using existing certs ignore the notification
                // to avoid building the full DN
                if(pServer->pccExistingCert)
                {
                    break;
                }
            
                pComp->hrContinue = myUIGetWindowText(
                    GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT),
                    &pwszCAName);
                _ReturnIfWizError(pComp->hrContinue);

                pComp->hrContinue = myUIGetWindowText(
                    GetDlgItem(hDlg, IDC_IDINFO_DNSUFFIXEDIT),
                    &pwszDNSuffix);
                _ReturnIfWizError(pComp->hrContinue);

                pComp->hrContinue = BuildFullDN(
                    pwszCAName,
                    pwszDNSuffix,
                    &pwszFullDN);
                _ReturnIfWizError(pComp->hrContinue);

                SetDlgItemText(
                    hDlg, 
                    IDC_IDINFO_NAMEPREVIEW,
                    pwszFullDN);
            }
           
            break;

        case IDC_IDINFO_EDIT_VALIDITYCOUNT:
            break;
        case IDC_IDINFO_COMBO_VALIDITYSTRING:
            switch (HIWORD(wParam))
            {
            case CBN_SELCHANGE:
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleValidityStringChange(
						hDlg,
						pComp->CA.pServer);
                _ReturnIfWizError(pComp->hrContinue);
                break;
            }
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_KILLACTIVE:
            break;

        case PSN_RESET:
            break;

        case PSN_QUERYCANCEL:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            return CertConfirmCancel(hDlg, pComp);
            break;

        case PSN_SETACTIVE:
            CSILOGDWORD(IDS_IDINFO_TITLE, dwWIZACTIVE);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
            pComp = _GetCompDataOrReturn(pComp, hDlg);
            _DisableWizDisplayIfError(pComp, hDlg);
            _ReturnIfWizError(pComp->hrContinue);
            pComp->hrContinue = HandleIdInfoWizActive(hDlg,
                                     pComp,
                                     g_aIdPageString);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZBACK:
            CSILOGDWORD(IDS_IDINFO_TITLE, dwWIZBACK);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleIdInfoWizNextOrBack(
                                    hDlg, pComp, g_aIdPageString, PSN_WIZBACK);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZNEXT:
            CSILOGDWORD(IDS_IDINFO_TITLE, dwWIZNEXT);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleIdInfoWizNextOrBack(
                                    hDlg, pComp, g_aIdPageString, PSN_WIZNEXT);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        default:
            return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);
        }
        break;

    default:
        return DefaultPageDlgProc(hDlg, iMsg, wParam, lParam);

    }
    return TRUE;
}

//-------------------------------------------------------------------------
//  DefaultPageDlgProc
//-------------------------------------------------------------------------
INT_PTR
DefaultPageDlgProc(
    IN HWND /* hDlg */ ,
    IN UINT iMsg,
    IN WPARAM /* wParam */ ,
    IN LPARAM lParam)
{
    LPCWSTR pwszHelpExecute;

    switch(iMsg)
    {
    case WM_NOTIFY:
        
        switch (((NMHDR FAR *) lParam)->code)
        {
            case PSN_HELP:
                pwszHelpExecute = myLoadResourceString(IDS_HELP_EXECUTE);
                if (NULL == (LPCWSTR)pwszHelpExecute)
                {
                    return FALSE;
                }
                ShellExecute(
                    NULL,
                    TEXT("open"),
                    pwszHelpExecute,
                    NULL,
                    NULL,
                    SW_SHOW);
                break;

            default:
                return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\ocmsetup\wizpage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       wizpage.h
//
//--------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  File:       wizpage.h
// 
//  Contents:   Header file for OCM wizard support functions.
//
//  History:    04/17/97        JerryK  Created
//
//-------------------------------------------------------------------------


#ifndef __WIZPAGE_H__
#define __WIZPAGE_H__

typedef struct tagWizPageResEntry
{
    int         idResource;
    DLGPROC     fnDlgProc;
    int         idTitle;
    int         idSubTitle;
} WIZPAGERESENTRY, *PWIZPAGERESENTRY;

typedef struct _PAGESTRINGS
{
    int     idControl;
    int     idLog;
    int     idMsgBoxNullString;
    DWORD   idMsgBoxLenString;
    int     cchMax;     // max num of characters allowed
    WCHAR **ppwszString;
} PAGESTRINGS;

int FileExists(LPTSTR pszTestFileName);
int DirExists(LPTSTR pszTestFileName);

#define DE_DIREXISTS            1               // Return codes for
#define DE_NAMEINUSE            2               // DirExists

#define STRBUF_SIZE             2048

#define UB_DESCRIPTION          1024      // This is not an X.500 limit
#define UB_VALIDITY             4
#define UB_VALIDITY_ANY         1024     // no limit actually

extern PAGESTRINGS g_aIdPageString[];

BOOL BrowseForDirectory(
                HWND hwndParent,
                LPCTSTR pszInitialDir,
                LPTSTR pszBuf,
                int cchBuf,
                LPCTSTR pszDialogTitle);

DWORD
SeekFileNameIndex(WCHAR const *pwszFullPath);

BOOL
IsAnyInvalidRDN(
    OPTIONAL HWND       hDlg,
    PER_COMPONENT_DATA *pComp);

HRESULT
SetKeyContainerName(
        CASERVERSETUPINFO *pServer,
        const WCHAR * pwszKeyContainerName);

HRESULT
DetermineDefaultHash(CASERVERSETUPINFO *pServer);

void
ClearKeyContainerName(CASERVERSETUPINFO *pServer);

HRESULT
BuildRequestFileName(
    IN WCHAR const *pwszCACertFile,
    OUT WCHAR     **ppwszRequestFile);

HRESULT
HookIdInfoPageStrings(
    PAGESTRINGS       *pPageString,
    CASERVERSETUPINFO *pServer);

HRESULT
WizardPageValidation(
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hDlg,
    IN PAGESTRINGS *pPageStrings);

HRESULT
StorePageValidation(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp,
    BOOL              *pfDontNext);

HRESULT 
ExtractCommonName(
    LPCWSTR pcwszDN, 
    LPWSTR* ppwszCN);

INT_PTR
WizIdInfoPageDlgProc(
    HWND hDlg, 
    UINT iMsg, 
    WPARAM wParam, 
    LPARAM lParam);

HRESULT
WizPageSetTextLimits(
    HWND hDlg,
    IN OUT PAGESTRINGS *pPageStrings);

BOOL
IsEverythingMatched(CASERVERSETUPINFO *pServer);

HRESULT BuildFullDN(
    OPTIONAL LPCWSTR pcwszCAName,
    OPTIONAL LPCWSTR pcwszDNSuffix,
    LPWSTR* pwszFullDN);

HRESULT InitNameFields(CASERVERSETUPINFO *pServer);

#endif // #ifndef __WIZPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\default\atl.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        atl.cpp
//
// Contents:    ActiveX Template Library COM support
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\default\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#define __DIR__		"default"

#include <windows.h>

#include <setupapi.h>
#include "ocmanage.h"

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <certsrv.h>
#include <certpdef.h>

#include "certlib.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\default\module.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

#include "module.h"
#include "policy.h"
#include "cslistvw.h"
#include "tfc.h"

#include <ntverp.h>
#include <common.ver>
#include "csdisp.h"

// help ids
#include "csmmchlp.h"

#define __dwFILE__	__dwFILE_POLICY_DEFAULT_MODULE_CPP__


#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

extern HINSTANCE g_hInstance;

STDMETHODIMP
CCertManagePolicyModule::GetProperty(
    /* [in] */ const BSTR, // strConfig
    /* [in] */ BSTR, // strStorageLocation
    /* [in] */ BSTR strPropertyName,
    /* [in] */ LONG, // dwFlags
    /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    UINT uiStr = 0;
    HRESULT hr;

    if (NULL == pvarProperty)
    {
        hr = E_POINTER;
        _PrintError(hr, "NULL parm");
        return hr;
    }
    VariantInit(pvarProperty);

    if (NULL == strPropertyName)
    {
        hr = S_FALSE;
        _PrintError(hr, "NULL in parm");
        return hr;
    }

    // load string from resource
    WCHAR szStr[MAX_PATH];
    szStr[0] = L'\0';

    if (0 == LSTRCMPIS(strPropertyName, wszCMM_PROP_FILEVER))
    {
        LPWSTR pwszTmp = NULL;
        if (!ConvertSzToWsz(&pwszTmp, VER_FILEVERSION_STR, -1))
            return myHLastError();
        wcscpy(szStr, pwszTmp);
        LocalFree(pwszTmp);
    }
    else if (0 == LSTRCMPIS(strPropertyName, wszCMM_PROP_PRODUCTVER))
    {
        LPWSTR pwszTmp = NULL;
        if (!ConvertSzToWsz(&pwszTmp, VER_PRODUCTVERSION_STR, -1))
            return myHLastError();
        wcscpy(szStr, pwszTmp);
        LocalFree(pwszTmp);
    }
    else
    {
      if (0 == LSTRCMPIS(strPropertyName, wszCMM_PROP_NAME))
          uiStr = IDS_MODULE_NAME;
      else if (0 == LSTRCMPIS(strPropertyName, wszCMM_PROP_DESCRIPTION))
          uiStr = IDS_MODULE_DESCR;
      else if (0 == LSTRCMPIS(strPropertyName, wszCMM_PROP_COPYRIGHT))
          uiStr = IDS_MODULE_COPYRIGHT;
      else
          return S_FALSE;  

      LoadString(g_hInstance, uiStr, szStr, ARRAYLEN(szStr));
    }

    pvarProperty->bstrVal = SysAllocString(szStr);
    if (NULL == pvarProperty->bstrVal)
        return E_OUTOFMEMORY;
    myRegisterMemFree(pvarProperty->bstrVal, CSM_SYSALLOC);  // this mem owned by caller


    pvarProperty->vt = VT_BSTR;

    return S_OK;
}
        
STDMETHODIMP 
CCertManagePolicyModule::SetProperty(
    /* [in] */ const BSTR, // strConfig
    /* [in] */ BSTR, // strStorageLocation
    /* [in] */ BSTR strPropertyName,
    /* [in] */ LONG, // dwFlags
    /* [in] */ VARIANT const __RPC_FAR *pvarProperty)
{
    HRESULT hr;

     if (NULL == strPropertyName)
    {
        hr = S_FALSE;
        _PrintError(hr, "NULL in parm");
        return hr;
    }

    if (NULL == pvarProperty)
    {
        hr = E_POINTER;
        _PrintError(hr, "NULL parm");
        return hr;
    }

     if (0 == LSTRCMPIS(strPropertyName, wszCMM_PROP_DISPLAY_HWND))
     {
         if (pvarProperty->vt != VT_BSTR)
              return E_INVALIDARG;

         if (SysStringByteLen(pvarProperty->bstrVal) != sizeof(HWND))
              return E_INVALIDARG;
         
         // the value is stored as bytes in the bstr itself, not the bstr ptr
         m_hWnd = *(HWND*)pvarProperty->bstrVal;
         return S_OK;
     }
     
     return S_FALSE;
}

INT_PTR CALLBACK WizPage1DlgProc(
  HWND hwndDlg,  
  UINT uMsg,     
  WPARAM wParam,
  LPARAM lParam);

struct POLICY_CONFIGSTRUCT
{
    POLICY_CONFIGSTRUCT() :
        pstrConfig(NULL),
        CAType(ENUM_UNKNOWN_CA),
        pCertAdmin(NULL),
        Flags(),
        dwPageModified(0) {}
    ~POLICY_CONFIGSTRUCT()
    { 
        if(pCertAdmin)
        {
            pCertAdmin->Release();
            pCertAdmin = NULL;
        }
    }
    const BSTR*  pstrConfig;
    CString      strSanitizedConfig;
    ENUM_CATYPES CAType;
    ICertAdmin2  *pCertAdmin;
    LONG         Flags;
    
    DWORD        dwPageModified;
};

typedef POLICY_CONFIGSTRUCT *PPOLICY_CONFIGSTRUCT;
        
// dwPageModified
#define PAGE1 (0x1)
#define PAGE2 (0x2)


void MessageBoxWarnReboot(HWND hwndDlg)
{
    WCHAR szText[MAX_PATH], szTitle[MAX_PATH];

    if (!LoadString(g_hInstance, IDS_MODULE_NAME, szTitle, ARRAYLEN(szTitle)))
    {
	szTitle[0] = L'\0';
    }
    if (!LoadString(g_hInstance, IDS_WARNING_REBOOT, szText, ARRAYLEN(szText)))
    {
	szText[0] = L'\0';
    }
    MessageBox(hwndDlg, szText, szTitle, MB_OK|MB_ICONINFORMATION);
}

void MessageBoxNoSave(HWND hwndDlg)
{
    WCHAR szText[MAX_PATH], szTitle[MAX_PATH];

    if (!LoadString(g_hInstance, IDS_MODULE_NAME, szTitle, ARRAYLEN(szTitle)))
    {
	szTitle[0] = L'\0';
    }
    if (!LoadString(g_hInstance, IDS_WARNING_NOSAVE, szText, ARRAYLEN(szText)))
    {
	szText[0] = L'\0';
    }
    MessageBox(hwndDlg, szText, szTitle, MB_OK|MB_ICONINFORMATION);
}

STDMETHODIMP
CCertManagePolicyModule::Configure( 
    /* [in] */ const BSTR strConfig,
    /* [in] */ BSTR, // strStorageLocation
    /* [in] */ LONG dwFlags)
{
    HRESULT hr;
    ICertServerPolicy *pServer = NULL;
    POLICY_CONFIGSTRUCT sConfig;

    BOOL fLocal;
    LPWSTR szMachine = NULL;
    CAutoLPWSTR autoszMachine, autoszCAName, autoszSanitizedCAName;

    if (NULL == strConfig)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }
    hr = myIsConfigLocal(strConfig, &szMachine, &fLocal);
    _JumpIfError(hr, error, "myIsConfigLocal");

    // use callbacks for info
    hr = polGetServerCallbackInterface(&pServer, 0);    // no context : 0
    _JumpIfError(hr, error, "polGetServerCallbackInterface");

    // we need to find out who we're running under
    hr = polGetCertificateLongProperty(
			    pServer,
			    wszPROPCATYPE,
			    (LONG *) &sConfig.CAType);
    _JumpIfErrorStr(hr, error, "polGetCertificateLongProperty", wszPROPCATYPE);

    hr = GetAdmin(&sConfig.pCertAdmin);
    _JumpIfError(hr, error, "GetAdmin");

    sConfig.pstrConfig = &strConfig;
    sConfig.Flags = dwFlags;

    hr = mySplitConfigString(
        *sConfig.pstrConfig,
        &autoszMachine,
        &autoszCAName);
    _JumpIfErrorStr(hr, error, "mySanitizeName", *sConfig.pstrConfig);

    hr = mySanitizeName(autoszCAName, &autoszSanitizedCAName);
    _JumpIfErrorStr(hr, error, "mySanitizeName", autoszCAName);
    
    sConfig.strSanitizedConfig = autoszMachine;
    sConfig.strSanitizedConfig += L"\\";
    sConfig.strSanitizedConfig += autoszSanitizedCAName;


    PROPSHEETPAGE page[1];
    ZeroMemory(&page[0], sizeof(PROPSHEETPAGE));
    page[0].dwSize = sizeof(PROPSHEETPAGE);
    page[0].dwFlags = PSP_DEFAULT;
    page[0].hInstance = g_hInstance;
    page[0].lParam = (LPARAM)&sConfig;
    page[0].pszTemplate = MAKEINTRESOURCE(IDD_POLICYPG1);
    page[0].pfnDlgProc = WizPage1DlgProc;

    PROPSHEETHEADER sSheet;
    ZeroMemory(&sSheet, sizeof(PROPSHEETHEADER));
    sSheet.dwSize = sizeof(PROPSHEETHEADER);
    sSheet.dwFlags = PSH_PROPSHEETPAGE | PSH_PROPTITLE;
    sSheet.hwndParent = m_hWnd;
    sSheet.pszCaption = MAKEINTRESOURCE(IDS_MODULE_NAME);
    sSheet.nPages = ARRAYLEN(page);
    sSheet.ppsp = page;

    
    // finally, invoke the modal sheet
    INT_PTR iRet;
    iRet = ::PropertySheet(&sSheet);

error:
    if (szMachine)
        LocalFree(szMachine);

    if (pServer)
        pServer->Release();

    return hr;
}



void mySetModified(HWND hwndPage, POLICY_CONFIGSTRUCT* psConfig)
{
    if (psConfig->dwPageModified != 0)
    {
        PropSheet_Changed( ::GetParent(hwndPage), hwndPage); 
    }
    else
    {
        PropSheet_UnChanged( ::GetParent(hwndPage), hwndPage); 
    }
}

INT_PTR CALLBACK WizPage1DlgProc(
  HWND hwndDlg,  
  UINT uMsg,     
  WPARAM wParam,
  LPARAM lParam)
{
    POLICY_CONFIGSTRUCT* psConfig;
    BOOL fReturn = FALSE;
    HRESULT hr;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            PROPSHEETPAGE* ps = (PROPSHEETPAGE *) lParam;

	    if (NULL == ps || NULL == (POLICY_CONFIGSTRUCT *) ps->lParam)
	    {
		_PrintError(E_POINTER, "NULL parm");
		break;
	    }
            psConfig = (POLICY_CONFIGSTRUCT*)ps->lParam;

            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM)psConfig);

            DWORD dwRequestDisposition;

            CAutoBSTR bstrSanitizedConfig, bstrSubkey; //bstrValueName;
            VARIANT var;

            VariantInit(&var);

            bstrSanitizedConfig = SysAllocString(psConfig->strSanitizedConfig);
            if(NULL == (BSTR)bstrSanitizedConfig)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            bstrSubkey = SysAllocString(
                                wszREGKEYPOLICYMODULES 
                                L"\\" 
                                wszMICROSOFTCERTMODULE_PREFIX 
                                wszCERTPOLICYMODULE_POSTFIX);
            if(NULL == (BSTR)bstrSubkey)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            BSTR bstrValueName = SysAllocString(wszREGREQUESTDISPOSITION);
            if(NULL == (BSTR)bstrValueName)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = psConfig->pCertAdmin->GetConfigEntry(
                    bstrSanitizedConfig,
                    bstrSubkey,
		    bstrValueName,
                    &var);
            if(S_OK!=hr)
                break;

            dwRequestDisposition = V_I4(&var);

            // if disposition includes Issue
            if ((dwRequestDisposition & REQDISP_MASK) == REQDISP_ISSUE)
            {
                // if pending bit set
                if (dwRequestDisposition & REQDISP_PENDINGFIRST)
                    SendMessage(GetDlgItem(hwndDlg, IDC_RADIO_PENDFIRST), BM_SETCHECK, TRUE, BST_CHECKED);
                else
                    SendMessage(GetDlgItem(hwndDlg, IDC_RADIO_ISSUE), BM_SETCHECK, TRUE, BST_CHECKED);
            }

            if (CMM_READONLY & psConfig->Flags)
            {
                DBGPRINT((DBG_SS_CERTPOL, "Read-only mode\n"));
                EnableWindow(GetDlgItem(hwndDlg, IDC_RADIO_PENDFIRST), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_RADIO_ISSUE), FALSE);
            }

            psConfig->dwPageModified &= ~PAGE1; // we're virgin
            mySetModified(hwndDlg, psConfig);

            // no other work to be done
            fReturn = TRUE;
            break;
        }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_POLICYPG1);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_POLICYPG1);
        break;
    }
    case WM_NOTIFY:
	if (NULL == (LPNMHDR) lParam)
	{
	    _PrintError(E_POINTER, "NULL parm");
	    break;
	}
        switch( ((LPNMHDR)lParam) -> code)
        {
        case PSN_APPLY:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                if (psConfig->dwPageModified & PAGE1)
                {
                    DWORD dwCheckState, dwRequestDisposition;
                    dwCheckState = (DWORD)SendMessage(GetDlgItem(hwndDlg, IDC_RADIO_ISSUE), BM_GETCHECK, 0, 0);

                    if (dwCheckState == BST_CHECKED)
                        dwRequestDisposition = REQDISP_ISSUE;
                    else
                        dwRequestDisposition = REQDISP_ISSUE | REQDISP_PENDINGFIRST;

                    CAutoBSTR bstrConfig, bstrSubkey, bstrValue;

                    bstrConfig = SysAllocString(psConfig->strSanitizedConfig.GetBuffer());
                    if(NULL == (BSTR)bstrConfig)
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                    bstrSubkey = SysAllocString(
                                        wszREGKEYPOLICYMODULES 
                                        L"\\" 
                                        wszMICROSOFTCERTMODULE_PREFIX 
                                        wszCERTPOLICYMODULE_POSTFIX);
                    if(NULL == (BSTR)bstrSubkey)
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                    bstrValue = SysAllocString(wszREGREQUESTDISPOSITION);
                    if(NULL == (BSTR)bstrValue)
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                    VARIANT var;
                    VariantInit(&var);
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = dwRequestDisposition;

                    hr = psConfig->pCertAdmin->SetConfigEntry(
                            bstrConfig,
                            bstrSubkey,
                            bstrValue,
                            &var);
                    if(S_OK!=hr)
                    {
                        MessageBoxNoSave(hwndDlg);
                    }
                    else
                    {
                        MessageBoxWarnReboot(NULL);
                        psConfig->dwPageModified &= ~PAGE1;
                    }
                }
            }
            break;
        case PSN_RESET:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                psConfig->dwPageModified &= ~PAGE1;
                mySetModified(hwndDlg, psConfig);
            }
            break;
        default:
            break;
        }
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_RADIO_ISSUE:
        case IDC_RADIO_PENDFIRST:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                if (BN_CLICKED == HIWORD(wParam))
                {
                    psConfig->dwPageModified |= PAGE1;
                    mySetModified(hwndDlg, psConfig);
                }
            }
            break;

        default:
            break;
        }
    default:
        break;
    }
    return fReturn;
}

HRESULT CCertManagePolicyModule::GetAdmin(ICertAdmin2 **ppAdmin)
{
    HRESULT hr = S_OK, hr1;
    BOOL fCoInit = FALSE;

    hr1 = CoInitialize(NULL);
    if ((S_OK == hr1) || (S_FALSE == hr1))
        fCoInit = TRUE;

    // create interface, pass back
    hr = CoCreateInstance(
			CLSID_CCertAdmin,
			NULL,		// pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertAdmin2,
			(void **) ppAdmin);
    _PrintIfError(hr, "CoCreateInstance");

    if (fCoInit)
        CoUninitialize();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\default\module.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       module.h
//
//--------------------------------------------------------------------------

#include "resource.h"       // main symbols

class CCertManagePolicyModule: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTPOLICYLib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManagePolicyModule, &CLSID_CCertManagePolicyModule>
{
public:
    CCertManagePolicyModule() {m_hWnd = NULL;}
    ~CCertManagePolicyModule() {}

BEGIN_COM_MAP(CCertManagePolicyModule)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManagePolicyModule) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// UNDONE UNDONE
DECLARE_REGISTRY(
    CCertManagePolicyModule,
    wszCLASS_CERTMANAGEPOLICYMODULE TEXT(".1"),
    wszCLASS_CERTMANAGEPOLICYMODULE,
    IDS_CERTMANAGEPOLICYMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:

    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);

        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);

    HWND m_hWnd;

private:
    HRESULT GetAdmin(ICertAdmin2 **ppAdmin);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\expolicy\atl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       atl.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp: source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\default\certpdef.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certpdef.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "resource.h"
#include "policy.h"
#include "module.h"

#define __dwFILE__	__dwFILE_POLICY_DEFAULT_CERTPDEF_CPP__

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertPolicy, CCertPolicyEnterprise)
    OBJECT_ENTRY(CLSID_CCertManagePolicyModule, CCertManagePolicyModule)
END_OBJECT_MAP()

#define EVENT_SOURCE_LOCATION L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\"
#define EVENT_SOURCE_NAME L"CertEnterprisePolicy"

HANDLE g_hEventLog = NULL;
HINSTANCE g_hInstance = NULL;


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    _Module.Init(ObjectMap, hInstance);
        g_hEventLog = RegisterEventSource(NULL, EVENT_SOURCE_NAME);
		g_hInstance = hInstance;
	    DisableThreadLibraryCalls(hInstance);
	    break;

        case DLL_PROCESS_DETACH:

        if(g_hEventLog)
        {
            DeregisterEventSource(g_hEventLog);
            g_hEventLog = NULL;
        }
	    _Module.Term();
            break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;
    
    hr = _Module.GetClassObject(rclsid, riid, ppv);
    if (S_OK == hr && NULL != ppv && NULL != *ppv)
    {
	myRegisterMemFree(*ppv, CSM_NEW | CSM_GLOBALDESTRUCTOR);
    }
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    HRESULT hr;
    HRESULT hr2;
    HKEY hkey = NULL;
    DWORD disp;
    DWORD dwData;
    LPWSTR wszModuleLocation = L"%SystemRoot%\\System32\\certpdef.dll"; 

    // wrap delayloaded func with try/except
    hr = S_OK;
    __try
    {
        // registers object, typelib and all interfaces in typelib
        // Register the event logging
	hr = RegCreateKeyEx(
			HKEY_LOCAL_MACHINE,
			EVENT_SOURCE_LOCATION EVENT_SOURCE_NAME,
			NULL,
			TEXT(""),
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS,
			NULL,
			&hkey,
			&disp);
	_LeaveIfError(hr, "RegCreateKeyEx");

        hr = RegSetValueEx(
			hkey,			// subkey handle 
			L"EventMessageFile",	// value name 
			0,
			REG_EXPAND_SZ,
			(LPBYTE) wszModuleLocation, // pointer to value data 
			sizeof(WCHAR) * (wcslen(wszModuleLocation) + 1));
        _LeaveIfError(hr, "RegSetValueEx");

        dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
            EVENTLOG_INFORMATION_TYPE; 
     
        hr = RegSetValueEx(
			hkey,
			L"TypesSupported",  // value name 
			0,
			REG_DWORD,
			(LPBYTE) &dwData,  // pointer to value data 
			sizeof(DWORD));           
        _LeaveIfError(hr, "RegSetValueEx");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }
    hr2 = _Module.RegisterServer(TRUE);
    _PrintIfError(hr2, "_Module.RegisterServer");
    if (S_OK == hr)
    {
	hr = hr2;
    }
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    return(myHError(hr));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    // wrap delayloaded func with try/except
    HRESULT hr;

    hr = S_OK;
    __try
    {
        hr = RegDeleteKey(
		    HKEY_LOCAL_MACHINE,
		    EVENT_SOURCE_LOCATION EVENT_SOURCE_NAME);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

    _Module.UnregisterServer();
    return(S_OK);
}


void __RPC_FAR *__RPC_USER
MIDL_user_allocate(size_t cb)
{
    return(LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb));
}


void __RPC_USER
MIDL_user_free(void __RPC_FAR *pb)
{
    LocalFree(pb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\default\policy.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        policy.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <ntdsapi.h>
#include <lm.h>
#include <winldap.h>
#include <security.h>

#include "cspelog.h"
#include "pollog.h"

#include "csprop.h"
#include "csldap.h"
#include "csdisp.h"
#include "policy.h"
#include "cainfop.h"


#define __dwFILE__	__dwFILE_POLICY_DEFAULT_POLICY_CPP__


// begin_sdksample

#ifndef DBG_CERTSRV
#error -- DBG_CERTSRV not defined!
#endif

// worker
HRESULT
polGetServerCallbackInterface(
    OUT ICertServerPolicy **ppServer,
    IN LONG Context)
{
    HRESULT hr;

    if (NULL == ppServer)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "Policy:polGetServerCallbackInterface");
    }

    hr = CoCreateInstance(
                    CLSID_CCertServerPolicy,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
                    IID_ICertServerPolicy,
                    (VOID **) ppServer);
    _JumpIfError(hr, error, "Policy:CoCreateInstance");

    if (NULL == *ppServer)
    {
        hr = E_UNEXPECTED;
	_JumpError(hr, error, "Policy:CoCreateInstance");
    }

    // only set context if nonzero
    if (0 != Context)
    {
        hr = (*ppServer)->SetContext(Context);
        _JumpIfError(hr, error, "Policy:SetContext");
    }

error:
    return hr;
}


HRESULT
polGetProperty(
    IN ICertServerPolicy *pServer,
    IN BOOL fRequest,
    IN WCHAR const *pwszPropertyName,
    IN DWORD PropType,
    OUT VARIANT *pvarOut)
{
    HRESULT hr;
    BSTR strName = NULL;

    VariantInit(pvarOut);
    strName = SysAllocString(pwszPropertyName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    if (fRequest)
    {
	hr = pServer->GetRequestProperty(strName, PropType, pvarOut);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "Policy:GetRequestProperty",
		    pwszPropertyName,
		    CERTSRV_E_PROPERTY_EMPTY);
    }
    else
    {
	hr = pServer->GetCertificateProperty(strName, PropType, pvarOut);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "Policy:GetCertificateProperty",
		    pwszPropertyName,
		    CERTSRV_E_PROPERTY_EMPTY);
    }

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


HRESULT
polGetStringProperty(
    IN ICertServerPolicy *pServer,
    IN BOOL fRequest,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    VARIANT var;

    VariantInit(&var);
    if (NULL != *pstrOut)
    {
	SysFreeString(*pstrOut);
	*pstrOut = NULL;
    }
    hr = polGetProperty(
		    pServer,
		    fRequest,
		    pwszPropertyName,
		    PROPTYPE_STRING,
		    &var);
    _JumpIfError2(
	    hr,
	    error,
	    "Policy:polGetProperty",
	    CERTSRV_E_PROPERTY_EMPTY);

    if (VT_BSTR != var.vt || NULL == var.bstrVal || L'\0' == var.bstrVal)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "Policy:polGetProperty");
    }
    *pstrOut = var.bstrVal;
    var.vt = VT_EMPTY;
    hr = S_OK;

error:
    VariantClear(&var);
    return(hr);
}


HRESULT
polGetLongProperty(
    IN ICertServerPolicy *pServer,
    IN BOOL fRequest,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut)
{
    HRESULT hr;
    VARIANT var;

    VariantInit(&var);
    hr = polGetProperty(
		    pServer,
		    fRequest,
		    pwszPropertyName,
		    PROPTYPE_LONG,
		    &var);
    _JumpIfError2(hr, error, "Policy:polGetProperty", CERTSRV_E_PROPERTY_EMPTY);

    if (VT_I4 != var.vt)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "Policy:polGetProperty");
    }
    *plOut = var.lVal;
    hr = S_OK;

error:
    VariantClear(&var);
    return(hr);
}


HRESULT
polGetRequestStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    
    hr = polGetStringProperty(pServer, TRUE, pwszPropertyName, pstrOut);
    _JumpIfError2(hr, error, "polGetStringProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetCertificateStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    
    hr = polGetStringProperty(pServer, FALSE, pwszPropertyName, pstrOut);
    _JumpIfError2(hr, error, "polGetStringProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetRequestLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut)
{
    HRESULT hr;
    
    hr = polGetLongProperty(pServer, TRUE, pwszPropertyName, plOut);
    _JumpIfError2(hr, error, "polGetLongProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetCertificateLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut)
{
    HRESULT hr;
    
    hr = polGetLongProperty(pServer, FALSE, pwszPropertyName, plOut);
    _JumpIfError2(hr, error, "polGetLongProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetRequestAttribute(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszAttributeName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    BSTR strName = NULL;

    strName = SysAllocString(pwszAttributeName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetRequestAttribute(strName, pstrOut);
    _JumpIfErrorStr2(
		hr,
		error,
		"Policy:GetRequestAttribute",
		pwszAttributeName,
		CERTSRV_E_PROPERTY_EMPTY);

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


HRESULT
polGetCertificateExtension(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszExtensionName,
    IN DWORD dwPropType,
    IN OUT VARIANT *pvarOut)
{
    HRESULT hr;
    BSTR strName = NULL;

    strName = SysAllocString(pwszExtensionName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetCertificateExtension(strName, dwPropType, pvarOut);
    _JumpIfErrorStr2(
		hr,
		error,
		"Policy:GetCertificateExtension",
		pwszExtensionName,
		CERTSRV_E_PROPERTY_EMPTY);

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


HRESULT
polSetCertificateExtension(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszExtensionName,
    IN DWORD dwPropType,
    IN DWORD dwExtFlags,
    IN VARIANT const *pvarIn)
{
    HRESULT hr;
    BSTR strName = NULL;

    strName = SysAllocString(pwszExtensionName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->SetCertificateExtension(
				    strName,
				    dwPropType,
				    dwExtFlags,
				    pvarIn);
    _JumpIfErrorStr(
		hr,
		error,
		"Policy:SetCertificateExtension",
		pwszExtensionName);

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::~CCertPolicyEnterprise -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertPolicyEnterprise::~CCertPolicyEnterprise()
{
    _Cleanup();

    // end_sdksample
    if (m_fTemplateCriticalSection)
    {
        DeleteCriticalSection(&m_TemplateCriticalSection);
    }
    // begin_sdksample
}


VOID
CCertPolicyEnterprise::_FreeStringArray(
    IN OUT DWORD *pcString,
    IN OUT LPWSTR **papwsz)
{
    LPWSTR *apwsz = *papwsz;
    DWORD i;

    if (NULL != apwsz)
    {
        for (i = *pcString; i-- > 0; )
        {
            if (NULL != apwsz[i])
            {
                DBGPRINT((DBG_SS_CERTPOLI, "_FreeStringArray[%u]: '%ws'\n", i, apwsz[i]));
                LocalFree(apwsz[i]);
            }
        }
        LocalFree(apwsz);
        *papwsz = NULL;
    }
    *pcString = 0;
}


// end_sdksample

//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_UnloadDSConfig -- release LDAP related resources
//
//+--------------------------------------------------------------------------

VOID
CCertPolicyEnterprise::_UnloadDSConfig()
{
    HRESULT hr;
    
    _ReleaseTemplates();
    if (NULL != m_hCertTypeQuery)
    {
	hr = CACertTypeUnregisterQuery(m_hCertTypeQuery);
	_PrintIfError(hr, "Policy:CACertTypeUnregisterQuery");
        m_hCertTypeQuery = NULL;
    }
    myLdapClose(m_pld, m_strDomainDN, m_strConfigDN);
    m_pld = NULL;
    m_strDomainDN = NULL;
    m_strConfigDN = NULL;
    m_fConfigLoaded = FALSE;
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_LoadDSConfig -- acquire LDAP related resources
//
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_LoadDSConfig(
    IN ICertServerPolicy *pServer,
    IN BOOL fRediscover)
{
    HRESULT hr;
    DWORD dwLogId = 0;
    ULONG ldaperr;
    WCHAR *pwszHostName = NULL;

    _UnloadDSConfig();
    if (m_fUseDS)
    {
	hr = myDoesDSExist(TRUE);
	if (hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN))
	{
	    dwLogId = MSG_NO_DOMAIN;
	    _JumpError(hr, error, "Policy:myDoesDSExist");
	}

	// Renewal domain and config containers (%5, %6)
	// We're going to be signing LDAP traffic and setting a template watch
	// point, so require a related DS bug fix: RLBF_REQUIRE_LDAP_INTEG.

	hr = myLdapOpen(
		NULL,		// pwszDomainName
		RLBF_REQUIRE_SECURE_LDAP |
		    RLBF_REQUIRE_LDAP_INTEG |
		    (fRediscover? RLBF_ATTEMPT_REDISCOVER : 0),
		&m_pld,
		&m_strDomainDN,
		&m_strConfigDN);
	if (S_OK != hr)
	{
	    dwLogId = MSG_NO_DOMAIN;
	    _JumpError(hr, error, "myLdapOpen");
	}

	if (IsEnterpriseCA(m_CAType))
	{
	    // turn off auto-reconnect for the template container watch

	    ldaperr = ldap_set_option(
				m_pld,
				LDAP_OPT_AUTO_RECONNECT,
				(void *) LDAP_OPT_OFF);
	    if (LDAP_SUCCESS != ldaperr)
	    {
		hr = myHLdapError(m_pld, ldaperr, NULL);
		_JumpError(hr, error, "ldap_set_option:LDAP_OPT_AUTO_RECONNECT");
	    }

	    hr = CACertTypeRegisterQuery(0, m_pld, &m_hCertTypeQuery);
	    _JumpIfError(hr, error, "Policy:CACertTypeRegisterQuery");

	    hr = _UpdateTemplates(pServer, TRUE);
	    _JumpIfError(hr, error, "Policy:_UpdateTemplates");
	}
	hr = myLdapGetDSHostName(m_pld, &pwszHostName);
	_JumpIfError(hr, error, "myLdapGetDSHostName");

	CSASSERT(NULL != pwszHostName);
	if (fRediscover || NULL != m_pwszHostName)
	{
	    LPCWSTR apwsz[2];

	    apwsz[0] = NULL != m_pwszHostName? m_pwszHostName : L"???";
	    apwsz[1] = pwszHostName;
	    hr = LogPolicyEvent(
			g_hInstance,
			S_OK,
			MSG_DS_RECONNECTED,
			pServer,
			wszPROPEVENTLOGWARNING,
			apwsz);
	    _PrintIfError(hr, "Policy:LogPolicyEvent");

	    if (NULL != m_pwszHostName)
	    {
		LocalFree(m_pwszHostName);
		m_pwszHostName = NULL;
	    }
	}
	hr = myDupString(pwszHostName, &m_pwszHostName);
	_JumpIfError(hr, error, "myDupString");

	hr = _SetSystemStringProp(pServer, wszPROPDCNAME, m_pwszHostName);
	_PrintIfErrorStr(hr, "_SetSystemStringProp(wszPROPDCNAME)", m_pwszHostName);
    }
    else
    {
	m_strDomainDN = SysAllocString(L"");
	m_strConfigDN = SysAllocString(L"");
	if (NULL == m_strDomainDN || NULL == m_strConfigDN)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:LocalAlloc");
	}
    }
    m_fConfigLoaded = TRUE;
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	if (0 == dwLogId && NULL == m_pCreateErrorInfo)
	{
	    dwLogId = MSG_DOMAIN_INIT;
	}
	if (0 != dwLogId)
	{
	    _BuildErrorInfo(hr, dwLogId);
	}
	_UnloadDSConfig();
    }
    return(hr);
}

// begin_sdksample


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_Cleanup -- free memory associated with this instance
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertPolicyEnterprise::_Cleanup()
{
    DWORD i;

    if (m_strDescription)
    {
        SysFreeString(m_strDescription);
        m_strDescription = NULL;
    }

    // RevocationExtension variables:

    if (NULL != m_wszASPRevocationURL)
    {
        LocalFree(m_wszASPRevocationURL);
    	m_wszASPRevocationURL = NULL;
    }

    // end_sdksample
    // SubjectAltNameExtension variables:

    for (i = 0; i < 2; i++)
    {
	if (NULL != m_astrSubjectAltNameProp[i])
	{
	    SysFreeString(m_astrSubjectAltNameProp[i]);
	    m_astrSubjectAltNameProp[i] = NULL;
	}
	if (NULL != m_astrSubjectAltNameObjectId[i])
	{
	    SysFreeString(m_astrSubjectAltNameObjectId[i]);
	    m_astrSubjectAltNameObjectId[i] = NULL;
	}
    }
    // begin_sdksample

    _FreeStringArray(&m_cEnableRequestExtensions, &m_apwszEnableRequestExtensions);
    _FreeStringArray(&m_cEnableEnrolleeRequestExtensions, &m_apwszEnableEnrolleeRequestExtensions);
    _FreeStringArray(&m_cDisableExtensions, &m_apwszDisableExtensions);

    if (NULL != m_strCAName)
    {
        SysFreeString(m_strCAName);
        m_strCAName = NULL;
    }
    if (NULL != m_strCASanitizedName)
    {
        SysFreeString(m_strCASanitizedName);
        m_strCASanitizedName = NULL;
    }
    if (NULL != m_strCASanitizedDSName)
    {
        SysFreeString(m_strCASanitizedDSName);
        m_strCASanitizedDSName = NULL;
    }
    if (NULL != m_strRegStorageLoc)
    {
        SysFreeString(m_strRegStorageLoc);
        m_strRegStorageLoc = NULL;
    }
    if (NULL != m_pCert)
    {
        CertFreeCertificateContext(m_pCert);
        m_pCert = NULL;
    }
    if (m_strMachineDNSName)
    {
        SysFreeString(m_strMachineDNSName);
        m_strMachineDNSName=NULL;
    }

    // end_sdksample

    if (NULL != m_pbSMIME)
    {
	LocalFree(m_pbSMIME);
	m_pbSMIME = NULL;
    }
    if (NULL != m_pwszHostName)
    {
	LocalFree(m_pwszHostName);
	m_pwszHostName = NULL;
    }
    _UnloadDSConfig();
    if (NULL != m_pCreateErrorInfo)
    {
	m_pCreateErrorInfo->Release();
	m_pCreateErrorInfo = NULL;
    }
    // begin_sdksample
}


HRESULT
CCertPolicyEnterprise::_ReadRegistryString(
    IN HKEY hkey,
    IN BOOL fURL,
    IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszSuffix,
    OUT LPWSTR *ppwszOut)
{
    HRESULT hr;
    WCHAR *pwszRegValue = NULL;
    DWORD cbValue;
    DWORD dwType;

    *ppwszOut = NULL;
    hr = RegQueryValueEx(
		    hkey,
		    pwszRegName,
		    NULL,           // lpdwReserved
		    &dwType,
		    NULL,
		    &cbValue);
    _JumpIfErrorStr2(
		hr,
		error,
		"Policy:RegQueryValueEx",
		pwszRegName,
		ERROR_FILE_NOT_FOUND);

    if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpErrorStr(hr, error, "Policy:RegQueryValueEx TYPE", pwszRegName);
    }
    if (NULL != pwszSuffix)
    {
	cbValue += wcslen(pwszSuffix) * sizeof(WCHAR);
    }
    pwszRegValue = (WCHAR *) LocalAlloc(LMEM_FIXED, cbValue + sizeof(WCHAR));
    if (NULL == pwszRegValue)
    {
        hr = E_OUTOFMEMORY;
        _JumpErrorStr(hr, error, "Policy:LocalAlloc", pwszRegName);
    }
    hr = RegQueryValueEx(
		    hkey,
		    pwszRegName,
		    NULL,           // lpdwReserved
		    &dwType,
		    (BYTE *) pwszRegValue,
		    &cbValue);
    _JumpIfErrorStr(hr, error, "Policy:RegQueryValueEx", pwszRegName);

    // Handle malformed registry values cleanly:

    pwszRegValue[cbValue / sizeof(WCHAR)] = L'\0';
    if (NULL != pwszSuffix)
    {
	wcscat(pwszRegValue, pwszSuffix);
    }

    hr = myFormatCertsrvStringArray(
			fURL,			// fURL
			m_strMachineDNSName, 	// pwszServerName_p1_2
			m_strCASanitizedName,	// pwszSanitizedName_p3_7
			m_iCert,		// iCert_p4
			MAXDWORD,		// iCertTarget_p4
			m_strDomainDN,		// pwszDomainDN_p5
			m_strConfigDN,		// pwszConfigDN_p6
			m_iCRL,			// iCRL_p8
			FALSE,			// fDeltaCRL_p9
			TRUE,			// fDSAttrib_p10_11
			1,			// cStrings
			(LPCWSTR *) &pwszRegValue, // apwszStringsIn
			ppwszOut);		// apwszStringsOut
    _JumpIfError(hr, error, "Policy:myFormatCertsrvStringArray");

error:
    if (NULL != pwszRegValue)
    {
        LocalFree(pwszRegValue);
    }
    return(myHError(hr));	// Reg routines return Win32 error codes
}


#if DBG_CERTSRV

VOID
CCertPolicyEnterprise::_DumpStringArray(
    IN char const *pszType,
    IN DWORD count,
    IN LPWSTR const *apwsz)
{
    DWORD i;
    WCHAR const *pwszName;

    for (i = 0; i < count; i++)
    {
	pwszName = L"";
	if (iswdigit(apwsz[i][0]))
	{
	    pwszName = myGetOIDName(apwsz[i]);	// Static: do not free!
	}
	DBGPRINT((
